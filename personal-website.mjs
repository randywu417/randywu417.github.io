function mz(r, e) {
  for (var t = 0; t < e.length; t++) {
    const n = e[t];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in r)) {
          const o = Object.getOwnPropertyDescriptor(n, i);
          o && Object.defineProperty(r, i, o.get ? o : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }));
}
(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload"))
    return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
    n(i);
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === "childList")
        for (const l of o.addedNodes)
          l.tagName === "LINK" && l.rel === "modulepreload" && n(l);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const o = {};
    return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o;
  }
  function n(i) {
    if (i.ep)
      return;
    i.ep = !0;
    const o = t(i);
    fetch(i.href, o);
  }
})();
function BW(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Qx = { exports: {} }, pZ = {}, jx = { exports: {} }, Mr = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rT;
function uP() {
  if (rT) return Mr;
  rT = 1;
  var r = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), I = Symbol.for("react.suspense"), C = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), v = Symbol.iterator;
  function b(le) {
    return le === null || typeof le != "object" ? null : (le = v && le[v] || le["@@iterator"], typeof le == "function" ? le : null);
  }
  var S = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, R = Object.assign, W = {};
  function x(le, Ye, nt) {
    this.props = le, this.context = Ye, this.refs = W, this.updater = nt || S;
  }
  x.prototype.isReactComponent = {}, x.prototype.setState = function(le, Ye) {
    if (typeof le != "object" && typeof le != "function" && le != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, le, Ye, "setState");
  }, x.prototype.forceUpdate = function(le) {
    this.updater.enqueueForceUpdate(this, le, "forceUpdate");
  };
  function N() {
  }
  N.prototype = x.prototype;
  function Y(le, Ye, nt) {
    this.props = le, this.context = Ye, this.refs = W, this.updater = nt || S;
  }
  var F = Y.prototype = new N();
  F.constructor = Y, R(F, x.prototype), F.isPureReactComponent = !0;
  var T = Array.isArray, P = Object.prototype.hasOwnProperty, D = { current: null }, L = { key: !0, ref: !0, __self: !0, __source: !0 };
  function j(le, Ye, nt) {
    var ze, Je = {}, wt = null, mt = null;
    if (Ye != null) for (ze in Ye.ref !== void 0 && (mt = Ye.ref), Ye.key !== void 0 && (wt = "" + Ye.key), Ye) P.call(Ye, ze) && !L.hasOwnProperty(ze) && (Je[ze] = Ye[ze]);
    var Dt = arguments.length - 2;
    if (Dt === 1) Je.children = nt;
    else if (1 < Dt) {
      for (var mn = Array(Dt), An = 0; An < Dt; An++) mn[An] = arguments[An + 2];
      Je.children = mn;
    }
    if (le && le.defaultProps) for (ze in Dt = le.defaultProps, Dt) Je[ze] === void 0 && (Je[ze] = Dt[ze]);
    return { $$typeof: r, type: le, key: wt, ref: mt, props: Je, _owner: D.current };
  }
  function J(le, Ye) {
    return { $$typeof: r, type: le.type, key: Ye, ref: le.ref, props: le.props, _owner: le._owner };
  }
  function O(le) {
    return typeof le == "object" && le !== null && le.$$typeof === r;
  }
  function ne(le) {
    var Ye = { "=": "=0", ":": "=2" };
    return "$" + le.replace(/[=:]/g, function(nt) {
      return Ye[nt];
    });
  }
  var he = /\/+/g;
  function pe(le, Ye) {
    return typeof le == "object" && le !== null && le.key != null ? ne("" + le.key) : Ye.toString(36);
  }
  function Ae(le, Ye, nt, ze, Je) {
    var wt = typeof le;
    (wt === "undefined" || wt === "boolean") && (le = null);
    var mt = !1;
    if (le === null) mt = !0;
    else switch (wt) {
      case "string":
      case "number":
        mt = !0;
        break;
      case "object":
        switch (le.$$typeof) {
          case r:
          case e:
            mt = !0;
        }
    }
    if (mt) return mt = le, Je = Je(mt), le = ze === "" ? "." + pe(mt, 0) : ze, T(Je) ? (nt = "", le != null && (nt = le.replace(he, "$&/") + "/"), Ae(Je, Ye, nt, "", function(An) {
      return An;
    })) : Je != null && (O(Je) && (Je = J(Je, nt + (!Je.key || mt && mt.key === Je.key ? "" : ("" + Je.key).replace(he, "$&/") + "/") + le)), Ye.push(Je)), 1;
    if (mt = 0, ze = ze === "" ? "." : ze + ":", T(le)) for (var Dt = 0; Dt < le.length; Dt++) {
      wt = le[Dt];
      var mn = ze + pe(wt, Dt);
      mt += Ae(wt, Ye, nt, mn, Je);
    }
    else if (mn = b(le), typeof mn == "function") for (le = mn.call(le), Dt = 0; !(wt = le.next()).done; ) wt = wt.value, mn = ze + pe(wt, Dt++), mt += Ae(wt, Ye, nt, mn, Je);
    else if (wt === "object") throw Ye = String(le), Error("Objects are not valid as a React child (found: " + (Ye === "[object Object]" ? "object with keys {" + Object.keys(le).join(", ") + "}" : Ye) + "). If you meant to render a collection of children, use an array instead.");
    return mt;
  }
  function ke(le, Ye, nt) {
    if (le == null) return le;
    var ze = [], Je = 0;
    return Ae(le, ze, "", "", function(wt) {
      return Ye.call(nt, wt, Je++);
    }), ze;
  }
  function Re(le) {
    if (le._status === -1) {
      var Ye = le._result;
      Ye = Ye(), Ye.then(function(nt) {
        (le._status === 0 || le._status === -1) && (le._status = 1, le._result = nt);
      }, function(nt) {
        (le._status === 0 || le._status === -1) && (le._status = 2, le._result = nt);
      }), le._status === -1 && (le._status = 0, le._result = Ye);
    }
    if (le._status === 1) return le._result.default;
    throw le._result;
  }
  var Xe = { current: null }, re = { transition: null }, Se = { ReactCurrentDispatcher: Xe, ReactCurrentBatchConfig: re, ReactCurrentOwner: D };
  function Be() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Mr.Children = { map: ke, forEach: function(le, Ye, nt) {
    ke(le, function() {
      Ye.apply(this, arguments);
    }, nt);
  }, count: function(le) {
    var Ye = 0;
    return ke(le, function() {
      Ye++;
    }), Ye;
  }, toArray: function(le) {
    return ke(le, function(Ye) {
      return Ye;
    }) || [];
  }, only: function(le) {
    if (!O(le)) throw Error("React.Children.only expected to receive a single React element child.");
    return le;
  } }, Mr.Component = x, Mr.Fragment = t, Mr.Profiler = i, Mr.PureComponent = Y, Mr.StrictMode = n, Mr.Suspense = I, Mr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Se, Mr.act = Be, Mr.cloneElement = function(le, Ye, nt) {
    if (le == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + le + ".");
    var ze = R({}, le.props), Je = le.key, wt = le.ref, mt = le._owner;
    if (Ye != null) {
      if (Ye.ref !== void 0 && (wt = Ye.ref, mt = D.current), Ye.key !== void 0 && (Je = "" + Ye.key), le.type && le.type.defaultProps) var Dt = le.type.defaultProps;
      for (mn in Ye) P.call(Ye, mn) && !L.hasOwnProperty(mn) && (ze[mn] = Ye[mn] === void 0 && Dt !== void 0 ? Dt[mn] : Ye[mn]);
    }
    var mn = arguments.length - 2;
    if (mn === 1) ze.children = nt;
    else if (1 < mn) {
      Dt = Array(mn);
      for (var An = 0; An < mn; An++) Dt[An] = arguments[An + 2];
      ze.children = Dt;
    }
    return { $$typeof: r, type: le.type, key: Je, ref: wt, props: ze, _owner: mt };
  }, Mr.createContext = function(le) {
    return le = { $$typeof: l, _currentValue: le, _currentValue2: le, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, le.Provider = { $$typeof: o, _context: le }, le.Consumer = le;
  }, Mr.createElement = j, Mr.createFactory = function(le) {
    var Ye = j.bind(null, le);
    return Ye.type = le, Ye;
  }, Mr.createRef = function() {
    return { current: null };
  }, Mr.forwardRef = function(le) {
    return { $$typeof: u, render: le };
  }, Mr.isValidElement = O, Mr.lazy = function(le) {
    return { $$typeof: f, _payload: { _status: -1, _result: le }, _init: Re };
  }, Mr.memo = function(le, Ye) {
    return { $$typeof: C, type: le, compare: Ye === void 0 ? null : Ye };
  }, Mr.startTransition = function(le) {
    var Ye = re.transition;
    re.transition = {};
    try {
      le();
    } finally {
      re.transition = Ye;
    }
  }, Mr.unstable_act = Be, Mr.useCallback = function(le, Ye) {
    return Xe.current.useCallback(le, Ye);
  }, Mr.useContext = function(le) {
    return Xe.current.useContext(le);
  }, Mr.useDebugValue = function() {
  }, Mr.useDeferredValue = function(le) {
    return Xe.current.useDeferredValue(le);
  }, Mr.useEffect = function(le, Ye) {
    return Xe.current.useEffect(le, Ye);
  }, Mr.useId = function() {
    return Xe.current.useId();
  }, Mr.useImperativeHandle = function(le, Ye, nt) {
    return Xe.current.useImperativeHandle(le, Ye, nt);
  }, Mr.useInsertionEffect = function(le, Ye) {
    return Xe.current.useInsertionEffect(le, Ye);
  }, Mr.useLayoutEffect = function(le, Ye) {
    return Xe.current.useLayoutEffect(le, Ye);
  }, Mr.useMemo = function(le, Ye) {
    return Xe.current.useMemo(le, Ye);
  }, Mr.useReducer = function(le, Ye, nt) {
    return Xe.current.useReducer(le, Ye, nt);
  }, Mr.useRef = function(le) {
    return Xe.current.useRef(le);
  }, Mr.useState = function(le) {
    return Xe.current.useState(le);
  }, Mr.useSyncExternalStore = function(le, Ye, nt) {
    return Xe.current.useSyncExternalStore(le, Ye, nt);
  }, Mr.useTransition = function() {
    return Xe.current.useTransition();
  }, Mr.version = "18.3.1", Mr;
}
var kZ = { exports: {} };
kZ.exports;
var aT;
function cP() {
  return aT || (aT = 1, function(r, e) {
    var t = {};
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    t.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = "18.3.1", i = Symbol.for("react.element"), o = Symbol.for("react.portal"), l = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), I = Symbol.for("react.profiler"), C = Symbol.for("react.provider"), f = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), S = Symbol.for("react.suspense_list"), R = Symbol.for("react.memo"), W = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), N = Symbol.iterator, Y = "@@iterator";
      function F(ie) {
        if (ie === null || typeof ie != "object")
          return null;
        var Me = N && ie[N] || ie[Y];
        return typeof Me == "function" ? Me : null;
      }
      var T = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, P = {
        transition: null
      }, D = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, L = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, j = {}, J = null;
      function O(ie) {
        J = ie;
      }
      j.setExtraStackFrame = function(ie) {
        J = ie;
      }, j.getCurrentStack = null, j.getStackAddendum = function() {
        var ie = "";
        J && (ie += J);
        var Me = j.getCurrentStack;
        return Me && (ie += Me() || ""), ie;
      };
      var ne = !1, he = !1, pe = !1, Ae = !1, ke = !1, Re = {
        ReactCurrentDispatcher: T,
        ReactCurrentBatchConfig: P,
        ReactCurrentOwner: L
      };
      Re.ReactDebugCurrentFrame = j, Re.ReactCurrentActQueue = D;
      function Xe(ie) {
        {
          for (var Me = arguments.length, gt = new Array(Me > 1 ? Me - 1 : 0), St = 1; St < Me; St++)
            gt[St - 1] = arguments[St];
          Se("warn", ie, gt);
        }
      }
      function re(ie) {
        {
          for (var Me = arguments.length, gt = new Array(Me > 1 ? Me - 1 : 0), St = 1; St < Me; St++)
            gt[St - 1] = arguments[St];
          Se("error", ie, gt);
        }
      }
      function Se(ie, Me, gt) {
        {
          var St = Re.ReactDebugCurrentFrame, dn = St.getStackAddendum();
          dn !== "" && (Me += "%s", gt = gt.concat([dn]));
          var qn = gt.map(function(_n) {
            return String(_n);
          });
          qn.unshift("Warning: " + Me), Function.prototype.apply.call(console[ie], console, qn);
        }
      }
      var Be = {};
      function le(ie, Me) {
        {
          var gt = ie.constructor, St = gt && (gt.displayName || gt.name) || "ReactClass", dn = St + "." + Me;
          if (Be[dn])
            return;
          re("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Me, St), Be[dn] = !0;
        }
      }
      var Ye = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(ie) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(ie, Me, gt) {
          le(ie, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(ie, Me, gt, St) {
          le(ie, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(ie, Me, gt, St) {
          le(ie, "setState");
        }
      }, nt = Object.assign, ze = {};
      Object.freeze(ze);
      function Je(ie, Me, gt) {
        this.props = ie, this.context = Me, this.refs = ze, this.updater = gt || Ye;
      }
      Je.prototype.isReactComponent = {}, Je.prototype.setState = function(ie, Me) {
        if (typeof ie != "object" && typeof ie != "function" && ie != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, ie, Me, "setState");
      }, Je.prototype.forceUpdate = function(ie) {
        this.updater.enqueueForceUpdate(this, ie, "forceUpdate");
      };
      {
        var wt = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, mt = function(ie, Me) {
          Object.defineProperty(Je.prototype, ie, {
            get: function() {
              Xe("%s(...) is deprecated in plain JavaScript React classes. %s", Me[0], Me[1]);
            }
          });
        };
        for (var Dt in wt)
          wt.hasOwnProperty(Dt) && mt(Dt, wt[Dt]);
      }
      function mn() {
      }
      mn.prototype = Je.prototype;
      function An(ie, Me, gt) {
        this.props = ie, this.context = Me, this.refs = ze, this.updater = gt || Ye;
      }
      var Hn = An.prototype = new mn();
      Hn.constructor = An, nt(Hn, Je.prototype), Hn.isPureReactComponent = !0;
      function ge() {
        var ie = {
          current: null
        };
        return Object.seal(ie), ie;
      }
      var Wt = Array.isArray;
      function Nt(ie) {
        return Wt(ie);
      }
      function $t(ie) {
        {
          var Me = typeof Symbol == "function" && Symbol.toStringTag, gt = Me && ie[Symbol.toStringTag] || ie.constructor.name || "Object";
          return gt;
        }
      }
      function ft(ie) {
        try {
          return bn(ie), !1;
        } catch {
          return !0;
        }
      }
      function bn(ie) {
        return "" + ie;
      }
      function en(ie) {
        if (ft(ie))
          return re("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", $t(ie)), bn(ie);
      }
      function hn(ie, Me, gt) {
        var St = ie.displayName;
        if (St)
          return St;
        var dn = Me.displayName || Me.name || "";
        return dn !== "" ? gt + "(" + dn + ")" : gt;
      }
      function me(ie) {
        return ie.displayName || "Context";
      }
      function se(ie) {
        if (ie == null)
          return null;
        if (typeof ie.tag == "number" && re("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ie == "function")
          return ie.displayName || ie.name || null;
        if (typeof ie == "string")
          return ie;
        switch (ie) {
          case l:
            return "Fragment";
          case o:
            return "Portal";
          case I:
            return "Profiler";
          case u:
            return "StrictMode";
          case b:
            return "Suspense";
          case S:
            return "SuspenseList";
        }
        if (typeof ie == "object")
          switch (ie.$$typeof) {
            case f:
              var Me = ie;
              return me(Me) + ".Consumer";
            case C:
              var gt = ie;
              return me(gt._context) + ".Provider";
            case v:
              return hn(ie, ie.render, "ForwardRef");
            case R:
              var St = ie.displayName || null;
              return St !== null ? St : se(ie.type) || "Memo";
            case W: {
              var dn = ie, qn = dn._payload, _n = dn._init;
              try {
                return se(_n(qn));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var $e = Object.prototype.hasOwnProperty, Vt = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Bt, Mt, Gn;
      Gn = {};
      function jt(ie) {
        if ($e.call(ie, "ref")) {
          var Me = Object.getOwnPropertyDescriptor(ie, "ref").get;
          if (Me && Me.isReactWarning)
            return !1;
        }
        return ie.ref !== void 0;
      }
      function an(ie) {
        if ($e.call(ie, "key")) {
          var Me = Object.getOwnPropertyDescriptor(ie, "key").get;
          if (Me && Me.isReactWarning)
            return !1;
        }
        return ie.key !== void 0;
      }
      function jn(ie, Me) {
        var gt = function() {
          Bt || (Bt = !0, re("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Me));
        };
        gt.isReactWarning = !0, Object.defineProperty(ie, "key", {
          get: gt,
          configurable: !0
        });
      }
      function Ot(ie, Me) {
        var gt = function() {
          Mt || (Mt = !0, re("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Me));
        };
        gt.isReactWarning = !0, Object.defineProperty(ie, "ref", {
          get: gt,
          configurable: !0
        });
      }
      function He(ie) {
        if (typeof ie.ref == "string" && L.current && ie.__self && L.current.stateNode !== ie.__self) {
          var Me = se(L.current.type);
          Gn[Me] || (re('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Me, ie.ref), Gn[Me] = !0);
        }
      }
      var vt = function(ie, Me, gt, St, dn, qn, _n) {
        var Si = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: i,
          // Built-in properties that belong on the element
          type: ie,
          key: Me,
          ref: gt,
          props: _n,
          // Record the component responsible for creating this element.
          _owner: qn
        };
        return Si._store = {}, Object.defineProperty(Si._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Si, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: St
        }), Object.defineProperty(Si, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: dn
        }), Object.freeze && (Object.freeze(Si.props), Object.freeze(Si)), Si;
      };
      function xt(ie, Me, gt) {
        var St, dn = {}, qn = null, _n = null, Si = null, Ui = null;
        if (Me != null) {
          jt(Me) && (_n = Me.ref, He(Me)), an(Me) && (en(Me.key), qn = "" + Me.key), Si = Me.__self === void 0 ? null : Me.__self, Ui = Me.__source === void 0 ? null : Me.__source;
          for (St in Me)
            $e.call(Me, St) && !Vt.hasOwnProperty(St) && (dn[St] = Me[St]);
        }
        var ur = arguments.length - 2;
        if (ur === 1)
          dn.children = gt;
        else if (ur > 1) {
          for (var nr = Array(ur), $i = 0; $i < ur; $i++)
            nr[$i] = arguments[$i + 2];
          Object.freeze && Object.freeze(nr), dn.children = nr;
        }
        if (ie && ie.defaultProps) {
          var Zi = ie.defaultProps;
          for (St in Zi)
            dn[St] === void 0 && (dn[St] = Zi[St]);
        }
        if (qn || _n) {
          var kr = typeof ie == "function" ? ie.displayName || ie.name || "Unknown" : ie;
          qn && jn(dn, kr), _n && Ot(dn, kr);
        }
        return vt(ie, qn, _n, Si, Ui, L.current, dn);
      }
      function ht(ie, Me) {
        var gt = vt(ie.type, Me, ie.ref, ie._self, ie._source, ie._owner, ie.props);
        return gt;
      }
      function on(ie, Me, gt) {
        if (ie == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + ie + ".");
        var St, dn = nt({}, ie.props), qn = ie.key, _n = ie.ref, Si = ie._self, Ui = ie._source, ur = ie._owner;
        if (Me != null) {
          jt(Me) && (_n = Me.ref, ur = L.current), an(Me) && (en(Me.key), qn = "" + Me.key);
          var nr;
          ie.type && ie.type.defaultProps && (nr = ie.type.defaultProps);
          for (St in Me)
            $e.call(Me, St) && !Vt.hasOwnProperty(St) && (Me[St] === void 0 && nr !== void 0 ? dn[St] = nr[St] : dn[St] = Me[St]);
        }
        var $i = arguments.length - 2;
        if ($i === 1)
          dn.children = gt;
        else if ($i > 1) {
          for (var Zi = Array($i), kr = 0; kr < $i; kr++)
            Zi[kr] = arguments[kr + 2];
          dn.children = Zi;
        }
        return vt(ie.type, qn, _n, Si, Ui, ur, dn);
      }
      function we(ie) {
        return typeof ie == "object" && ie !== null && ie.$$typeof === i;
      }
      var qe = ".", de = ":";
      function it(ie) {
        var Me = /[=:]/g, gt = {
          "=": "=0",
          ":": "=2"
        }, St = ie.replace(Me, function(dn) {
          return gt[dn];
        });
        return "$" + St;
      }
      var je = !1, et = /\/+/g;
      function Jt(ie) {
        return ie.replace(et, "$&/");
      }
      function Kn(ie, Me) {
        return typeof ie == "object" && ie !== null && ie.key != null ? (en(ie.key), it("" + ie.key)) : Me.toString(36);
      }
      function di(ie, Me, gt, St, dn) {
        var qn = typeof ie;
        (qn === "undefined" || qn === "boolean") && (ie = null);
        var _n = !1;
        if (ie === null)
          _n = !0;
        else
          switch (qn) {
            case "string":
            case "number":
              _n = !0;
              break;
            case "object":
              switch (ie.$$typeof) {
                case i:
                case o:
                  _n = !0;
              }
          }
        if (_n) {
          var Si = ie, Ui = dn(Si), ur = St === "" ? qe + Kn(Si, 0) : St;
          if (Nt(Ui)) {
            var nr = "";
            ur != null && (nr = Jt(ur) + "/"), di(Ui, Me, nr, "", function(ih) {
              return ih;
            });
          } else Ui != null && (we(Ui) && (Ui.key && (!Si || Si.key !== Ui.key) && en(Ui.key), Ui = ht(
            Ui,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            gt + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (Ui.key && (!Si || Si.key !== Ui.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              Jt("" + Ui.key) + "/"
            ) : "") + ur
          )), Me.push(Ui));
          return 1;
        }
        var $i, Zi, kr = 0, Ka = St === "" ? qe : St + de;
        if (Nt(ie))
          for (var Js = 0; Js < ie.length; Js++)
            $i = ie[Js], Zi = Ka + Kn($i, Js), kr += di($i, Me, gt, Zi, dn);
        else {
          var mu = F(ie);
          if (typeof mu == "function") {
            var Au = ie;
            mu === Au.entries && (je || Xe("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), je = !0);
            for (var ud = mu.call(Au), mg, lf = 0; !(mg = ud.next()).done; )
              $i = mg.value, Zi = Ka + Kn($i, lf++), kr += di($i, Me, gt, Zi, dn);
          } else if (qn === "object") {
            var nh = String(ie);
            throw new Error("Objects are not valid as a React child (found: " + (nh === "[object Object]" ? "object with keys {" + Object.keys(ie).join(", ") + "}" : nh) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return kr;
      }
      function Di(ie, Me, gt) {
        if (ie == null)
          return ie;
        var St = [], dn = 0;
        return di(ie, St, "", "", function(qn) {
          return Me.call(gt, qn, dn++);
        }), St;
      }
      function Jn(ie) {
        var Me = 0;
        return Di(ie, function() {
          Me++;
        }), Me;
      }
      function Ii(ie, Me, gt) {
        Di(ie, function() {
          Me.apply(this, arguments);
        }, gt);
      }
      function dr(ie) {
        return Di(ie, function(Me) {
          return Me;
        }) || [];
      }
      function xr(ie) {
        if (!we(ie))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return ie;
      }
      function la(ie) {
        var Me = {
          $$typeof: f,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: ie,
          _currentValue2: ie,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        Me.Provider = {
          $$typeof: C,
          _context: Me
        };
        var gt = !1, St = !1, dn = !1;
        {
          var qn = {
            $$typeof: f,
            _context: Me
          };
          Object.defineProperties(qn, {
            Provider: {
              get: function() {
                return St || (St = !0, re("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Me.Provider;
              },
              set: function(_n) {
                Me.Provider = _n;
              }
            },
            _currentValue: {
              get: function() {
                return Me._currentValue;
              },
              set: function(_n) {
                Me._currentValue = _n;
              }
            },
            _currentValue2: {
              get: function() {
                return Me._currentValue2;
              },
              set: function(_n) {
                Me._currentValue2 = _n;
              }
            },
            _threadCount: {
              get: function() {
                return Me._threadCount;
              },
              set: function(_n) {
                Me._threadCount = _n;
              }
            },
            Consumer: {
              get: function() {
                return gt || (gt = !0, re("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Me.Consumer;
              }
            },
            displayName: {
              get: function() {
                return Me.displayName;
              },
              set: function(_n) {
                dn || (Xe("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", _n), dn = !0);
              }
            }
          }), Me.Consumer = qn;
        }
        return Me._currentRenderer = null, Me._currentRenderer2 = null, Me;
      }
      var Ve = -1, Oe = 0, rt = 1, Et = 2;
      function gn(ie) {
        if (ie._status === Ve) {
          var Me = ie._result, gt = Me();
          if (gt.then(function(qn) {
            if (ie._status === Oe || ie._status === Ve) {
              var _n = ie;
              _n._status = rt, _n._result = qn;
            }
          }, function(qn) {
            if (ie._status === Oe || ie._status === Ve) {
              var _n = ie;
              _n._status = Et, _n._result = qn;
            }
          }), ie._status === Ve) {
            var St = ie;
            St._status = Oe, St._result = gt;
          }
        }
        if (ie._status === rt) {
          var dn = ie._result;
          return dn === void 0 && re(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, dn), "default" in dn || re(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, dn), dn.default;
        } else
          throw ie._result;
      }
      function Vn(ie) {
        var Me = {
          // We use these fields to store the result.
          _status: Ve,
          _result: ie
        }, gt = {
          $$typeof: W,
          _payload: Me,
          _init: gn
        };
        {
          var St, dn;
          Object.defineProperties(gt, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return St;
              },
              set: function(qn) {
                re("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), St = qn, Object.defineProperty(gt, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return dn;
              },
              set: function(qn) {
                re("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), dn = qn, Object.defineProperty(gt, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return gt;
      }
      function Ln(ie) {
        ie != null && ie.$$typeof === R ? re("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof ie != "function" ? re("forwardRef requires a render function but was given %s.", ie === null ? "null" : typeof ie) : ie.length !== 0 && ie.length !== 2 && re("forwardRef render functions accept exactly two parameters: props and ref. %s", ie.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), ie != null && (ie.defaultProps != null || ie.propTypes != null) && re("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var Me = {
          $$typeof: v,
          render: ie
        };
        {
          var gt;
          Object.defineProperty(Me, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return gt;
            },
            set: function(St) {
              gt = St, !ie.name && !ie.displayName && (ie.displayName = St);
            }
          });
        }
        return Me;
      }
      var Ie;
      Ie = Symbol.for("react.module.reference");
      function tt(ie) {
        return !!(typeof ie == "string" || typeof ie == "function" || ie === l || ie === I || ke || ie === u || ie === b || ie === S || Ae || ie === x || ne || he || pe || typeof ie == "object" && ie !== null && (ie.$$typeof === W || ie.$$typeof === R || ie.$$typeof === C || ie.$$typeof === f || ie.$$typeof === v || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        ie.$$typeof === Ie || ie.getModuleId !== void 0));
      }
      function At(ie, Me) {
        tt(ie) || re("memo: The first argument must be a component. Instead received: %s", ie === null ? "null" : typeof ie);
        var gt = {
          $$typeof: R,
          type: ie,
          compare: Me === void 0 ? null : Me
        };
        {
          var St;
          Object.defineProperty(gt, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return St;
            },
            set: function(dn) {
              St = dn, !ie.name && !ie.displayName && (ie.displayName = dn);
            }
          });
        }
        return gt;
      }
      function Gt() {
        var ie = T.current;
        return ie === null && re(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), ie;
      }
      function vn(ie) {
        var Me = Gt();
        if (ie._context !== void 0) {
          var gt = ie._context;
          gt.Consumer === ie ? re("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : gt.Provider === ie && re("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return Me.useContext(ie);
      }
      function ae(ie) {
        var Me = Gt();
        return Me.useState(ie);
      }
      function Ne(ie, Me, gt) {
        var St = Gt();
        return St.useReducer(ie, Me, gt);
      }
      function Te(ie) {
        var Me = Gt();
        return Me.useRef(ie);
      }
      function De(ie, Me) {
        var gt = Gt();
        return gt.useEffect(ie, Me);
      }
      function Ee(ie, Me) {
        var gt = Gt();
        return gt.useInsertionEffect(ie, Me);
      }
      function Tt(ie, Me) {
        var gt = Gt();
        return gt.useLayoutEffect(ie, Me);
      }
      function tn(ie, Me) {
        var gt = Gt();
        return gt.useCallback(ie, Me);
      }
      function Bn(ie, Me) {
        var gt = Gt();
        return gt.useMemo(ie, Me);
      }
      function Pt(ie, Me, gt) {
        var St = Gt();
        return St.useImperativeHandle(ie, Me, gt);
      }
      function Zn(ie, Me) {
        {
          var gt = Gt();
          return gt.useDebugValue(ie, Me);
        }
      }
      function rn() {
        var ie = Gt();
        return ie.useTransition();
      }
      function Yn(ie) {
        var Me = Gt();
        return Me.useDeferredValue(ie);
      }
      function Fi() {
        var ie = Gt();
        return ie.useId();
      }
      function Ir(ie, Me, gt) {
        var St = Gt();
        return St.useSyncExternalStore(ie, Me, gt);
      }
      var Tn = 0, mi, xn, un, Xn, li, Wr, Xo;
      function $r() {
      }
      $r.__reactDisabledLog = !0;
      function ba() {
        {
          if (Tn === 0) {
            mi = console.log, xn = console.info, un = console.warn, Xn = console.error, li = console.group, Wr = console.groupCollapsed, Xo = console.groupEnd;
            var ie = {
              configurable: !0,
              enumerable: !0,
              value: $r,
              writable: !0
            };
            Object.defineProperties(console, {
              info: ie,
              log: ie,
              warn: ie,
              error: ie,
              group: ie,
              groupCollapsed: ie,
              groupEnd: ie
            });
          }
          Tn++;
        }
      }
      function or() {
        {
          if (Tn--, Tn === 0) {
            var ie = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: nt({}, ie, {
                value: mi
              }),
              info: nt({}, ie, {
                value: xn
              }),
              warn: nt({}, ie, {
                value: un
              }),
              error: nt({}, ie, {
                value: Xn
              }),
              group: nt({}, ie, {
                value: li
              }),
              groupCollapsed: nt({}, ie, {
                value: Wr
              }),
              groupEnd: nt({}, ie, {
                value: Xo
              })
            });
          }
          Tn < 0 && re("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var za = Re.ReactCurrentDispatcher, pl;
      function Xa(ie, Me, gt) {
        {
          if (pl === void 0)
            try {
              throw Error();
            } catch (dn) {
              var St = dn.stack.trim().match(/\n( *(at )?)/);
              pl = St && St[1] || "";
            }
          return `
` + pl + ie;
        }
      }
      var bs = !1, Ao;
      {
        var Ou = typeof WeakMap == "function" ? WeakMap : Map;
        Ao = new Ou();
      }
      function od(ie, Me) {
        if (!ie || bs)
          return "";
        {
          var gt = Ao.get(ie);
          if (gt !== void 0)
            return gt;
        }
        var St;
        bs = !0;
        var dn = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var qn;
        qn = za.current, za.current = null, ba();
        try {
          if (Me) {
            var _n = function() {
              throw Error();
            };
            if (Object.defineProperty(_n.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(_n, []);
              } catch (Ka) {
                St = Ka;
              }
              Reflect.construct(ie, [], _n);
            } else {
              try {
                _n.call();
              } catch (Ka) {
                St = Ka;
              }
              ie.call(_n.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Ka) {
              St = Ka;
            }
            ie();
          }
        } catch (Ka) {
          if (Ka && St && typeof Ka.stack == "string") {
            for (var Si = Ka.stack.split(`
`), Ui = St.stack.split(`
`), ur = Si.length - 1, nr = Ui.length - 1; ur >= 1 && nr >= 0 && Si[ur] !== Ui[nr]; )
              nr--;
            for (; ur >= 1 && nr >= 0; ur--, nr--)
              if (Si[ur] !== Ui[nr]) {
                if (ur !== 1 || nr !== 1)
                  do
                    if (ur--, nr--, nr < 0 || Si[ur] !== Ui[nr]) {
                      var $i = `
` + Si[ur].replace(" at new ", " at ");
                      return ie.displayName && $i.includes("<anonymous>") && ($i = $i.replace("<anonymous>", ie.displayName)), typeof ie == "function" && Ao.set(ie, $i), $i;
                    }
                  while (ur >= 1 && nr >= 0);
                break;
              }
          }
        } finally {
          bs = !1, za.current = qn, or(), Error.prepareStackTrace = dn;
        }
        var Zi = ie ? ie.displayName || ie.name : "", kr = Zi ? Xa(Zi) : "";
        return typeof ie == "function" && Ao.set(ie, kr), kr;
      }
      function dI(ie, Me, gt) {
        return od(ie, !1);
      }
      function Pu(ie) {
        var Me = ie.prototype;
        return !!(Me && Me.isReactComponent);
      }
      function sr(ie, Me, gt) {
        if (ie == null)
          return "";
        if (typeof ie == "function")
          return od(ie, Pu(ie));
        if (typeof ie == "string")
          return Xa(ie);
        switch (ie) {
          case b:
            return Xa("Suspense");
          case S:
            return Xa("SuspenseList");
        }
        if (typeof ie == "object")
          switch (ie.$$typeof) {
            case v:
              return dI(ie.render);
            case R:
              return sr(ie.type, Me, gt);
            case W: {
              var St = ie, dn = St._payload, qn = St._init;
              try {
                return sr(qn(dn), Me, gt);
              } catch {
              }
            }
          }
        return "";
      }
      var Yo = {}, Cu = Re.ReactDebugCurrentFrame;
      function Hi(ie) {
        if (ie) {
          var Me = ie._owner, gt = sr(ie.type, ie._source, Me ? Me.type : null);
          Cu.setExtraStackFrame(gt);
        } else
          Cu.setExtraStackFrame(null);
      }
      function sf(ie, Me, gt, St, dn) {
        {
          var qn = Function.call.bind($e);
          for (var _n in ie)
            if (qn(ie, _n)) {
              var Si = void 0;
              try {
                if (typeof ie[_n] != "function") {
                  var Ui = Error((St || "React class") + ": " + gt + " type `" + _n + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ie[_n] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Ui.name = "Invariant Violation", Ui;
                }
                Si = ie[_n](Me, _n, St, gt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ur) {
                Si = ur;
              }
              Si && !(Si instanceof Error) && (Hi(dn), re("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", St || "React class", gt, _n, typeof Si), Hi(null)), Si instanceof Error && !(Si.message in Yo) && (Yo[Si.message] = !0, Hi(dn), re("Failed %s type: %s", gt, Si.message), Hi(null));
            }
        }
      }
      function hu(ie) {
        if (ie) {
          var Me = ie._owner, gt = sr(ie.type, ie._source, Me ? Me.type : null);
          O(gt);
        } else
          O(null);
      }
      var xi;
      xi = !1;
      function Ju() {
        if (L.current) {
          var ie = se(L.current.type);
          if (ie)
            return `

Check the render method of \`` + ie + "`.";
        }
        return "";
      }
      function Po(ie) {
        if (ie !== void 0) {
          var Me = ie.fileName.replace(/^.*[\\\/]/, ""), gt = ie.lineNumber;
          return `

Check your code at ` + Me + ":" + gt + ".";
        }
        return "";
      }
      function Gs(ie) {
        return ie != null ? Po(ie.__source) : "";
      }
      var Bi = {};
      function Qu(ie) {
        var Me = Ju();
        if (!Me) {
          var gt = typeof ie == "string" ? ie : ie.displayName || ie.name;
          gt && (Me = `

Check the top-level render call using <` + gt + ">.");
        }
        return Me;
      }
      function Ra(ie, Me) {
        if (!(!ie._store || ie._store.validated || ie.key != null)) {
          ie._store.validated = !0;
          var gt = Qu(Me);
          if (!Bi[gt]) {
            Bi[gt] = !0;
            var St = "";
            ie && ie._owner && ie._owner !== L.current && (St = " It was passed a child from " + se(ie._owner.type) + "."), hu(ie), re('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', gt, St), hu(null);
          }
        }
      }
      function Lr(ie, Me) {
        if (typeof ie == "object") {
          if (Nt(ie))
            for (var gt = 0; gt < ie.length; gt++) {
              var St = ie[gt];
              we(St) && Ra(St, Me);
            }
          else if (we(ie))
            ie._store && (ie._store.validated = !0);
          else if (ie) {
            var dn = F(ie);
            if (typeof dn == "function" && dn !== ie.entries)
              for (var qn = dn.call(ie), _n; !(_n = qn.next()).done; )
                we(_n.value) && Ra(_n.value, Me);
          }
        }
      }
      function Ds(ie) {
        {
          var Me = ie.type;
          if (Me == null || typeof Me == "string")
            return;
          var gt;
          if (typeof Me == "function")
            gt = Me.propTypes;
          else if (typeof Me == "object" && (Me.$$typeof === v || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          Me.$$typeof === R))
            gt = Me.propTypes;
          else
            return;
          if (gt) {
            var St = se(Me);
            sf(gt, ie.props, "prop", St, ie);
          } else if (Me.PropTypes !== void 0 && !xi) {
            xi = !0;
            var dn = se(Me);
            re("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", dn || "Unknown");
          }
          typeof Me.getDefaultProps == "function" && !Me.getDefaultProps.isReactClassApproved && re("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function fu(ie) {
        {
          for (var Me = Object.keys(ie.props), gt = 0; gt < Me.length; gt++) {
            var St = Me[gt];
            if (St !== "children" && St !== "key") {
              hu(ie), re("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", St), hu(null);
              break;
            }
          }
          ie.ref !== null && (hu(ie), re("Invalid attribute `ref` supplied to `React.Fragment`."), hu(null));
        }
      }
      function Sr(ie, Me, gt) {
        var St = tt(ie);
        if (!St) {
          var dn = "";
          (ie === void 0 || typeof ie == "object" && ie !== null && Object.keys(ie).length === 0) && (dn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var qn = Gs(Me);
          qn ? dn += qn : dn += Ju();
          var _n;
          ie === null ? _n = "null" : Nt(ie) ? _n = "array" : ie !== void 0 && ie.$$typeof === i ? (_n = "<" + (se(ie.type) || "Unknown") + " />", dn = " Did you accidentally export a JSX literal instead of a component?") : _n = typeof ie, re("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", _n, dn);
        }
        var Si = xt.apply(this, arguments);
        if (Si == null)
          return Si;
        if (St)
          for (var Ui = 2; Ui < arguments.length; Ui++)
            Lr(arguments[Ui], ie);
        return ie === l ? fu(Si) : Ds(Si), Si;
      }
      var as = !1;
      function Ap(ie) {
        var Me = Sr.bind(null, ie);
        return Me.type = ie, as || (as = !0, Xe("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Me, "type", {
          enumerable: !1,
          get: function() {
            return Xe("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: ie
            }), ie;
          }
        }), Me;
      }
      function sd(ie, Me, gt) {
        for (var St = on.apply(this, arguments), dn = 2; dn < arguments.length; dn++)
          Lr(arguments[dn], St.type);
        return Ds(St), St;
      }
      function II(ie, Me) {
        var gt = P.transition;
        P.transition = {};
        var St = P.transition;
        P.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          ie();
        } finally {
          if (P.transition = gt, gt === null && St._updatedFibers) {
            var dn = St._updatedFibers.size;
            dn > 10 && Xe("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), St._updatedFibers.clear();
          }
        }
      }
      var hg = !1, Us = null;
      function CI(ie) {
        if (Us === null)
          try {
            var Me = ("require" + Math.random()).slice(0, 7), gt = r && r[Me];
            Us = gt.call(r, "timers").setImmediate;
          } catch {
            Us = function(dn) {
              hg === !1 && (hg = !0, typeof MessageChannel > "u" && re("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var qn = new MessageChannel();
              qn.port1.onmessage = dn, qn.port2.postMessage(void 0);
            };
          }
        return Us(ie);
      }
      var pu = 0, $a = !1;
      function Bs(ie) {
        {
          var Me = pu;
          pu++, D.current === null && (D.current = []);
          var gt = D.isBatchingLegacy, St;
          try {
            if (D.isBatchingLegacy = !0, St = ie(), !gt && D.didScheduleLegacyUpdate) {
              var dn = D.current;
              dn !== null && (D.didScheduleLegacyUpdate = !1, pg(dn));
            }
          } catch (Zi) {
            throw Ul(Me), Zi;
          } finally {
            D.isBatchingLegacy = gt;
          }
          if (St !== null && typeof St == "object" && typeof St.then == "function") {
            var qn = St, _n = !1, Si = {
              then: function(Zi, kr) {
                _n = !0, qn.then(function(Ka) {
                  Ul(Me), pu === 0 ? ld(Ka, Zi, kr) : Zi(Ka);
                }, function(Ka) {
                  Ul(Me), kr(Ka);
                });
              }
            };
            return !$a && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              _n || ($a = !0, re("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), Si;
          } else {
            var Ui = St;
            if (Ul(Me), pu === 0) {
              var ur = D.current;
              ur !== null && (pg(ur), D.current = null);
              var nr = {
                then: function(Zi, kr) {
                  D.current === null ? (D.current = [], ld(Ui, Zi, kr)) : Zi(Ui);
                }
              };
              return nr;
            } else {
              var $i = {
                then: function(Zi, kr) {
                  Zi(Ui);
                }
              };
              return $i;
            }
          }
        }
      }
      function Ul(ie) {
        ie !== pu - 1 && re("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), pu = ie;
      }
      function ld(ie, Me, gt) {
        {
          var St = D.current;
          if (St !== null)
            try {
              pg(St), CI(function() {
                St.length === 0 ? (D.current = null, Me(ie)) : ld(ie, Me, gt);
              });
            } catch (dn) {
              gt(dn);
            }
          else
            Me(ie);
        }
      }
      var fg = !1;
      function pg(ie) {
        if (!fg) {
          fg = !0;
          var Me = 0;
          try {
            for (; Me < ie.length; Me++) {
              var gt = ie[Me];
              do
                gt = gt(!0);
              while (gt !== null);
            }
            ie.length = 0;
          } catch (St) {
            throw ie = ie.slice(Me + 1), St;
          } finally {
            fg = !1;
          }
        }
      }
      var Os = Sr, th = sd, Ps = Ap, hI = {
        map: Di,
        forEach: Ii,
        count: Jn,
        toArray: dr,
        only: xr
      };
      e.Children = hI, e.Component = Je, e.Fragment = l, e.Profiler = I, e.PureComponent = An, e.StrictMode = u, e.Suspense = b, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Re, e.act = Bs, e.cloneElement = th, e.createContext = la, e.createElement = Os, e.createFactory = Ps, e.createRef = ge, e.forwardRef = Ln, e.isValidElement = we, e.lazy = Vn, e.memo = At, e.startTransition = II, e.unstable_act = Bs, e.useCallback = tn, e.useContext = vn, e.useDebugValue = Zn, e.useDeferredValue = Yn, e.useEffect = De, e.useId = Fi, e.useImperativeHandle = Pt, e.useInsertionEffect = Ee, e.useLayoutEffect = Tt, e.useMemo = Bn, e.useReducer = Ne, e.useRef = Te, e.useState = ae, e.useSyncExternalStore = Ir, e.useTransition = rn, e.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(kZ, kZ.exports)), kZ.exports;
}
var oT;
function xb() {
  if (oT) return jx.exports;
  oT = 1;
  var r = {};
  return r.NODE_ENV === "production" ? jx.exports = uP() : jx.exports = cP(), jx.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sT;
function gP() {
  if (sT) return pZ;
  sT = 1;
  var r = xb(), e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(u, I, C) {
    var f, v = {}, b = null, S = null;
    C !== void 0 && (b = "" + C), I.key !== void 0 && (b = "" + I.key), I.ref !== void 0 && (S = I.ref);
    for (f in I) n.call(I, f) && !o.hasOwnProperty(f) && (v[f] = I[f]);
    if (u && u.defaultProps) for (f in I = u.defaultProps, I) v[f] === void 0 && (v[f] = I[f]);
    return { $$typeof: e, type: u, key: b, ref: S, props: v, _owner: i.current };
  }
  return pZ.Fragment = t, pZ.jsx = l, pZ.jsxs = l, pZ;
}
var mZ = {}, lT;
function dP() {
  if (lT) return mZ;
  lT = 1;
  var r = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return r.NODE_ENV !== "production" && function() {
    var e = xb(), t = Symbol.for("react.element"), n = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), I = Symbol.for("react.context"), C = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), v = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), R = Symbol.for("react.offscreen"), W = Symbol.iterator, x = "@@iterator";
    function N(Ie) {
      if (Ie === null || typeof Ie != "object")
        return null;
      var tt = W && Ie[W] || Ie[x];
      return typeof tt == "function" ? tt : null;
    }
    var Y = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function F(Ie) {
      {
        for (var tt = arguments.length, At = new Array(tt > 1 ? tt - 1 : 0), Gt = 1; Gt < tt; Gt++)
          At[Gt - 1] = arguments[Gt];
        T("error", Ie, At);
      }
    }
    function T(Ie, tt, At) {
      {
        var Gt = Y.ReactDebugCurrentFrame, vn = Gt.getStackAddendum();
        vn !== "" && (tt += "%s", At = At.concat([vn]));
        var ae = At.map(function(Ne) {
          return String(Ne);
        });
        ae.unshift("Warning: " + tt), Function.prototype.apply.call(console[Ie], console, ae);
      }
    }
    var P = !1, D = !1, L = !1, j = !1, J = !1, O;
    O = Symbol.for("react.module.reference");
    function ne(Ie) {
      return !!(typeof Ie == "string" || typeof Ie == "function" || Ie === i || Ie === l || J || Ie === o || Ie === f || Ie === v || j || Ie === R || P || D || L || typeof Ie == "object" && Ie !== null && (Ie.$$typeof === S || Ie.$$typeof === b || Ie.$$typeof === u || Ie.$$typeof === I || Ie.$$typeof === C || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ie.$$typeof === O || Ie.getModuleId !== void 0));
    }
    function he(Ie, tt, At) {
      var Gt = Ie.displayName;
      if (Gt)
        return Gt;
      var vn = tt.displayName || tt.name || "";
      return vn !== "" ? At + "(" + vn + ")" : At;
    }
    function pe(Ie) {
      return Ie.displayName || "Context";
    }
    function Ae(Ie) {
      if (Ie == null)
        return null;
      if (typeof Ie.tag == "number" && F("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ie == "function")
        return Ie.displayName || Ie.name || null;
      if (typeof Ie == "string")
        return Ie;
      switch (Ie) {
        case i:
          return "Fragment";
        case n:
          return "Portal";
        case l:
          return "Profiler";
        case o:
          return "StrictMode";
        case f:
          return "Suspense";
        case v:
          return "SuspenseList";
      }
      if (typeof Ie == "object")
        switch (Ie.$$typeof) {
          case I:
            var tt = Ie;
            return pe(tt) + ".Consumer";
          case u:
            var At = Ie;
            return pe(At._context) + ".Provider";
          case C:
            return he(Ie, Ie.render, "ForwardRef");
          case b:
            var Gt = Ie.displayName || null;
            return Gt !== null ? Gt : Ae(Ie.type) || "Memo";
          case S: {
            var vn = Ie, ae = vn._payload, Ne = vn._init;
            try {
              return Ae(Ne(ae));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ke = Object.assign, Re = 0, Xe, re, Se, Be, le, Ye, nt;
    function ze() {
    }
    ze.__reactDisabledLog = !0;
    function Je() {
      {
        if (Re === 0) {
          Xe = console.log, re = console.info, Se = console.warn, Be = console.error, le = console.group, Ye = console.groupCollapsed, nt = console.groupEnd;
          var Ie = {
            configurable: !0,
            enumerable: !0,
            value: ze,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Ie,
            log: Ie,
            warn: Ie,
            error: Ie,
            group: Ie,
            groupCollapsed: Ie,
            groupEnd: Ie
          });
        }
        Re++;
      }
    }
    function wt() {
      {
        if (Re--, Re === 0) {
          var Ie = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ke({}, Ie, {
              value: Xe
            }),
            info: ke({}, Ie, {
              value: re
            }),
            warn: ke({}, Ie, {
              value: Se
            }),
            error: ke({}, Ie, {
              value: Be
            }),
            group: ke({}, Ie, {
              value: le
            }),
            groupCollapsed: ke({}, Ie, {
              value: Ye
            }),
            groupEnd: ke({}, Ie, {
              value: nt
            })
          });
        }
        Re < 0 && F("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var mt = Y.ReactCurrentDispatcher, Dt;
    function mn(Ie, tt, At) {
      {
        if (Dt === void 0)
          try {
            throw Error();
          } catch (vn) {
            var Gt = vn.stack.trim().match(/\n( *(at )?)/);
            Dt = Gt && Gt[1] || "";
          }
        return `
` + Dt + Ie;
      }
    }
    var An = !1, Hn;
    {
      var ge = typeof WeakMap == "function" ? WeakMap : Map;
      Hn = new ge();
    }
    function Wt(Ie, tt) {
      if (!Ie || An)
        return "";
      {
        var At = Hn.get(Ie);
        if (At !== void 0)
          return At;
      }
      var Gt;
      An = !0;
      var vn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ae;
      ae = mt.current, mt.current = null, Je();
      try {
        if (tt) {
          var Ne = function() {
            throw Error();
          };
          if (Object.defineProperty(Ne.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ne, []);
            } catch (Zn) {
              Gt = Zn;
            }
            Reflect.construct(Ie, [], Ne);
          } else {
            try {
              Ne.call();
            } catch (Zn) {
              Gt = Zn;
            }
            Ie.call(Ne.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Zn) {
            Gt = Zn;
          }
          Ie();
        }
      } catch (Zn) {
        if (Zn && Gt && typeof Zn.stack == "string") {
          for (var Te = Zn.stack.split(`
`), De = Gt.stack.split(`
`), Ee = Te.length - 1, Tt = De.length - 1; Ee >= 1 && Tt >= 0 && Te[Ee] !== De[Tt]; )
            Tt--;
          for (; Ee >= 1 && Tt >= 0; Ee--, Tt--)
            if (Te[Ee] !== De[Tt]) {
              if (Ee !== 1 || Tt !== 1)
                do
                  if (Ee--, Tt--, Tt < 0 || Te[Ee] !== De[Tt]) {
                    var tn = `
` + Te[Ee].replace(" at new ", " at ");
                    return Ie.displayName && tn.includes("<anonymous>") && (tn = tn.replace("<anonymous>", Ie.displayName)), typeof Ie == "function" && Hn.set(Ie, tn), tn;
                  }
                while (Ee >= 1 && Tt >= 0);
              break;
            }
        }
      } finally {
        An = !1, mt.current = ae, wt(), Error.prepareStackTrace = vn;
      }
      var Bn = Ie ? Ie.displayName || Ie.name : "", Pt = Bn ? mn(Bn) : "";
      return typeof Ie == "function" && Hn.set(Ie, Pt), Pt;
    }
    function Nt(Ie, tt, At) {
      return Wt(Ie, !1);
    }
    function $t(Ie) {
      var tt = Ie.prototype;
      return !!(tt && tt.isReactComponent);
    }
    function ft(Ie, tt, At) {
      if (Ie == null)
        return "";
      if (typeof Ie == "function")
        return Wt(Ie, $t(Ie));
      if (typeof Ie == "string")
        return mn(Ie);
      switch (Ie) {
        case f:
          return mn("Suspense");
        case v:
          return mn("SuspenseList");
      }
      if (typeof Ie == "object")
        switch (Ie.$$typeof) {
          case C:
            return Nt(Ie.render);
          case b:
            return ft(Ie.type, tt, At);
          case S: {
            var Gt = Ie, vn = Gt._payload, ae = Gt._init;
            try {
              return ft(ae(vn), tt, At);
            } catch {
            }
          }
        }
      return "";
    }
    var bn = Object.prototype.hasOwnProperty, en = {}, hn = Y.ReactDebugCurrentFrame;
    function me(Ie) {
      if (Ie) {
        var tt = Ie._owner, At = ft(Ie.type, Ie._source, tt ? tt.type : null);
        hn.setExtraStackFrame(At);
      } else
        hn.setExtraStackFrame(null);
    }
    function se(Ie, tt, At, Gt, vn) {
      {
        var ae = Function.call.bind(bn);
        for (var Ne in Ie)
          if (ae(Ie, Ne)) {
            var Te = void 0;
            try {
              if (typeof Ie[Ne] != "function") {
                var De = Error((Gt || "React class") + ": " + At + " type `" + Ne + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ie[Ne] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              Te = Ie[Ne](tt, Ne, Gt, At, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ee) {
              Te = Ee;
            }
            Te && !(Te instanceof Error) && (me(vn), F("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Gt || "React class", At, Ne, typeof Te), me(null)), Te instanceof Error && !(Te.message in en) && (en[Te.message] = !0, me(vn), F("Failed %s type: %s", At, Te.message), me(null));
          }
      }
    }
    var $e = Array.isArray;
    function Vt(Ie) {
      return $e(Ie);
    }
    function Bt(Ie) {
      {
        var tt = typeof Symbol == "function" && Symbol.toStringTag, At = tt && Ie[Symbol.toStringTag] || Ie.constructor.name || "Object";
        return At;
      }
    }
    function Mt(Ie) {
      try {
        return Gn(Ie), !1;
      } catch {
        return !0;
      }
    }
    function Gn(Ie) {
      return "" + Ie;
    }
    function jt(Ie) {
      if (Mt(Ie))
        return F("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Bt(Ie)), Gn(Ie);
    }
    var an = Y.ReactCurrentOwner, jn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ot, He;
    function vt(Ie) {
      if (bn.call(Ie, "ref")) {
        var tt = Object.getOwnPropertyDescriptor(Ie, "ref").get;
        if (tt && tt.isReactWarning)
          return !1;
      }
      return Ie.ref !== void 0;
    }
    function xt(Ie) {
      if (bn.call(Ie, "key")) {
        var tt = Object.getOwnPropertyDescriptor(Ie, "key").get;
        if (tt && tt.isReactWarning)
          return !1;
      }
      return Ie.key !== void 0;
    }
    function ht(Ie, tt) {
      typeof Ie.ref == "string" && an.current;
    }
    function on(Ie, tt) {
      {
        var At = function() {
          Ot || (Ot = !0, F("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", tt));
        };
        At.isReactWarning = !0, Object.defineProperty(Ie, "key", {
          get: At,
          configurable: !0
        });
      }
    }
    function we(Ie, tt) {
      {
        var At = function() {
          He || (He = !0, F("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", tt));
        };
        At.isReactWarning = !0, Object.defineProperty(Ie, "ref", {
          get: At,
          configurable: !0
        });
      }
    }
    var qe = function(Ie, tt, At, Gt, vn, ae, Ne) {
      var Te = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: Ie,
        key: tt,
        ref: At,
        props: Ne,
        // Record the component responsible for creating this element.
        _owner: ae
      };
      return Te._store = {}, Object.defineProperty(Te._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Te, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Gt
      }), Object.defineProperty(Te, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: vn
      }), Object.freeze && (Object.freeze(Te.props), Object.freeze(Te)), Te;
    };
    function de(Ie, tt, At, Gt, vn) {
      {
        var ae, Ne = {}, Te = null, De = null;
        At !== void 0 && (jt(At), Te = "" + At), xt(tt) && (jt(tt.key), Te = "" + tt.key), vt(tt) && (De = tt.ref, ht(tt, vn));
        for (ae in tt)
          bn.call(tt, ae) && !jn.hasOwnProperty(ae) && (Ne[ae] = tt[ae]);
        if (Ie && Ie.defaultProps) {
          var Ee = Ie.defaultProps;
          for (ae in Ee)
            Ne[ae] === void 0 && (Ne[ae] = Ee[ae]);
        }
        if (Te || De) {
          var Tt = typeof Ie == "function" ? Ie.displayName || Ie.name || "Unknown" : Ie;
          Te && on(Ne, Tt), De && we(Ne, Tt);
        }
        return qe(Ie, Te, De, vn, Gt, an.current, Ne);
      }
    }
    var it = Y.ReactCurrentOwner, je = Y.ReactDebugCurrentFrame;
    function et(Ie) {
      if (Ie) {
        var tt = Ie._owner, At = ft(Ie.type, Ie._source, tt ? tt.type : null);
        je.setExtraStackFrame(At);
      } else
        je.setExtraStackFrame(null);
    }
    var Jt;
    Jt = !1;
    function Kn(Ie) {
      return typeof Ie == "object" && Ie !== null && Ie.$$typeof === t;
    }
    function di() {
      {
        if (it.current) {
          var Ie = Ae(it.current.type);
          if (Ie)
            return `

Check the render method of \`` + Ie + "`.";
        }
        return "";
      }
    }
    function Di(Ie) {
      return "";
    }
    var Jn = {};
    function Ii(Ie) {
      {
        var tt = di();
        if (!tt) {
          var At = typeof Ie == "string" ? Ie : Ie.displayName || Ie.name;
          At && (tt = `

Check the top-level render call using <` + At + ">.");
        }
        return tt;
      }
    }
    function dr(Ie, tt) {
      {
        if (!Ie._store || Ie._store.validated || Ie.key != null)
          return;
        Ie._store.validated = !0;
        var At = Ii(tt);
        if (Jn[At])
          return;
        Jn[At] = !0;
        var Gt = "";
        Ie && Ie._owner && Ie._owner !== it.current && (Gt = " It was passed a child from " + Ae(Ie._owner.type) + "."), et(Ie), F('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', At, Gt), et(null);
      }
    }
    function xr(Ie, tt) {
      {
        if (typeof Ie != "object")
          return;
        if (Vt(Ie))
          for (var At = 0; At < Ie.length; At++) {
            var Gt = Ie[At];
            Kn(Gt) && dr(Gt, tt);
          }
        else if (Kn(Ie))
          Ie._store && (Ie._store.validated = !0);
        else if (Ie) {
          var vn = N(Ie);
          if (typeof vn == "function" && vn !== Ie.entries)
            for (var ae = vn.call(Ie), Ne; !(Ne = ae.next()).done; )
              Kn(Ne.value) && dr(Ne.value, tt);
        }
      }
    }
    function la(Ie) {
      {
        var tt = Ie.type;
        if (tt == null || typeof tt == "string")
          return;
        var At;
        if (typeof tt == "function")
          At = tt.propTypes;
        else if (typeof tt == "object" && (tt.$$typeof === C || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        tt.$$typeof === b))
          At = tt.propTypes;
        else
          return;
        if (At) {
          var Gt = Ae(tt);
          se(At, Ie.props, "prop", Gt, Ie);
        } else if (tt.PropTypes !== void 0 && !Jt) {
          Jt = !0;
          var vn = Ae(tt);
          F("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", vn || "Unknown");
        }
        typeof tt.getDefaultProps == "function" && !tt.getDefaultProps.isReactClassApproved && F("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ve(Ie) {
      {
        for (var tt = Object.keys(Ie.props), At = 0; At < tt.length; At++) {
          var Gt = tt[At];
          if (Gt !== "children" && Gt !== "key") {
            et(Ie), F("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Gt), et(null);
            break;
          }
        }
        Ie.ref !== null && (et(Ie), F("Invalid attribute `ref` supplied to `React.Fragment`."), et(null));
      }
    }
    var Oe = {};
    function rt(Ie, tt, At, Gt, vn, ae) {
      {
        var Ne = ne(Ie);
        if (!Ne) {
          var Te = "";
          (Ie === void 0 || typeof Ie == "object" && Ie !== null && Object.keys(Ie).length === 0) && (Te += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = Di();
          De ? Te += De : Te += di();
          var Ee;
          Ie === null ? Ee = "null" : Vt(Ie) ? Ee = "array" : Ie !== void 0 && Ie.$$typeof === t ? (Ee = "<" + (Ae(Ie.type) || "Unknown") + " />", Te = " Did you accidentally export a JSX literal instead of a component?") : Ee = typeof Ie, F("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ee, Te);
        }
        var Tt = de(Ie, tt, At, vn, ae);
        if (Tt == null)
          return Tt;
        if (Ne) {
          var tn = tt.children;
          if (tn !== void 0)
            if (Gt)
              if (Vt(tn)) {
                for (var Bn = 0; Bn < tn.length; Bn++)
                  xr(tn[Bn], Ie);
                Object.freeze && Object.freeze(tn);
              } else
                F("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              xr(tn, Ie);
        }
        if (bn.call(tt, "key")) {
          var Pt = Ae(Ie), Zn = Object.keys(tt).filter(function(Fi) {
            return Fi !== "key";
          }), rn = Zn.length > 0 ? "{key: someKey, " + Zn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Oe[Pt + rn]) {
            var Yn = Zn.length > 0 ? "{" + Zn.join(": ..., ") + ": ...}" : "{}";
            F(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, rn, Pt, Yn, Pt), Oe[Pt + rn] = !0;
          }
        }
        return Ie === i ? Ve(Tt) : la(Tt), Tt;
      }
    }
    function Et(Ie, tt, At) {
      return rt(Ie, tt, At, !0);
    }
    function gn(Ie, tt, At) {
      return rt(Ie, tt, At, !1);
    }
    var Vn = gn, Ln = Et;
    mZ.Fragment = i, mZ.jsx = Vn, mZ.jsxs = Ln;
  }(), mZ;
}
var uT;
function IP() {
  if (uT) return Qx.exports;
  uT = 1;
  var r = {};
  return r.NODE_ENV === "production" ? Qx.exports = gP() : Qx.exports = dP(), Qx.exports;
}
var We = IP(), ye = xb();
const wc = /* @__PURE__ */ BW(ye), CP = /* @__PURE__ */ mz({
  __proto__: null,
  default: wc
}, [ye]);
var AG = {}, qx = { exports: {} }, Qd = {}, $x = { exports: {} }, CM = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cT;
function hP() {
  return cT || (cT = 1, function(r) {
    function e(re, Se) {
      var Be = re.length;
      re.push(Se);
      e: for (; 0 < Be; ) {
        var le = Be - 1 >>> 1, Ye = re[le];
        if (0 < i(Ye, Se)) re[le] = Se, re[Be] = Ye, Be = le;
        else break e;
      }
    }
    function t(re) {
      return re.length === 0 ? null : re[0];
    }
    function n(re) {
      if (re.length === 0) return null;
      var Se = re[0], Be = re.pop();
      if (Be !== Se) {
        re[0] = Be;
        e: for (var le = 0, Ye = re.length, nt = Ye >>> 1; le < nt; ) {
          var ze = 2 * (le + 1) - 1, Je = re[ze], wt = ze + 1, mt = re[wt];
          if (0 > i(Je, Be)) wt < Ye && 0 > i(mt, Je) ? (re[le] = mt, re[wt] = Be, le = wt) : (re[le] = Je, re[ze] = Be, le = ze);
          else if (wt < Ye && 0 > i(mt, Be)) re[le] = mt, re[wt] = Be, le = wt;
          else break e;
        }
      }
      return Se;
    }
    function i(re, Se) {
      var Be = re.sortIndex - Se.sortIndex;
      return Be !== 0 ? Be : re.id - Se.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      r.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, u = l.now();
      r.unstable_now = function() {
        return l.now() - u;
      };
    }
    var I = [], C = [], f = 1, v = null, b = 3, S = !1, R = !1, W = !1, x = typeof setTimeout == "function" ? setTimeout : null, N = typeof clearTimeout == "function" ? clearTimeout : null, Y = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function F(re) {
      for (var Se = t(C); Se !== null; ) {
        if (Se.callback === null) n(C);
        else if (Se.startTime <= re) n(C), Se.sortIndex = Se.expirationTime, e(I, Se);
        else break;
        Se = t(C);
      }
    }
    function T(re) {
      if (W = !1, F(re), !R) if (t(I) !== null) R = !0, Re(P);
      else {
        var Se = t(C);
        Se !== null && Xe(T, Se.startTime - re);
      }
    }
    function P(re, Se) {
      R = !1, W && (W = !1, N(j), j = -1), S = !0;
      var Be = b;
      try {
        for (F(Se), v = t(I); v !== null && (!(v.expirationTime > Se) || re && !ne()); ) {
          var le = v.callback;
          if (typeof le == "function") {
            v.callback = null, b = v.priorityLevel;
            var Ye = le(v.expirationTime <= Se);
            Se = r.unstable_now(), typeof Ye == "function" ? v.callback = Ye : v === t(I) && n(I), F(Se);
          } else n(I);
          v = t(I);
        }
        if (v !== null) var nt = !0;
        else {
          var ze = t(C);
          ze !== null && Xe(T, ze.startTime - Se), nt = !1;
        }
        return nt;
      } finally {
        v = null, b = Be, S = !1;
      }
    }
    var D = !1, L = null, j = -1, J = 5, O = -1;
    function ne() {
      return !(r.unstable_now() - O < J);
    }
    function he() {
      if (L !== null) {
        var re = r.unstable_now();
        O = re;
        var Se = !0;
        try {
          Se = L(!0, re);
        } finally {
          Se ? pe() : (D = !1, L = null);
        }
      } else D = !1;
    }
    var pe;
    if (typeof Y == "function") pe = function() {
      Y(he);
    };
    else if (typeof MessageChannel < "u") {
      var Ae = new MessageChannel(), ke = Ae.port2;
      Ae.port1.onmessage = he, pe = function() {
        ke.postMessage(null);
      };
    } else pe = function() {
      x(he, 0);
    };
    function Re(re) {
      L = re, D || (D = !0, pe());
    }
    function Xe(re, Se) {
      j = x(function() {
        re(r.unstable_now());
      }, Se);
    }
    r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function(re) {
      re.callback = null;
    }, r.unstable_continueExecution = function() {
      R || S || (R = !0, Re(P));
    }, r.unstable_forceFrameRate = function(re) {
      0 > re || 125 < re ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : J = 0 < re ? Math.floor(1e3 / re) : 5;
    }, r.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, r.unstable_getFirstCallbackNode = function() {
      return t(I);
    }, r.unstable_next = function(re) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var Se = 3;
          break;
        default:
          Se = b;
      }
      var Be = b;
      b = Se;
      try {
        return re();
      } finally {
        b = Be;
      }
    }, r.unstable_pauseExecution = function() {
    }, r.unstable_requestPaint = function() {
    }, r.unstable_runWithPriority = function(re, Se) {
      switch (re) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          re = 3;
      }
      var Be = b;
      b = re;
      try {
        return Se();
      } finally {
        b = Be;
      }
    }, r.unstable_scheduleCallback = function(re, Se, Be) {
      var le = r.unstable_now();
      switch (typeof Be == "object" && Be !== null ? (Be = Be.delay, Be = typeof Be == "number" && 0 < Be ? le + Be : le) : Be = le, re) {
        case 1:
          var Ye = -1;
          break;
        case 2:
          Ye = 250;
          break;
        case 5:
          Ye = 1073741823;
          break;
        case 4:
          Ye = 1e4;
          break;
        default:
          Ye = 5e3;
      }
      return Ye = Be + Ye, re = { id: f++, callback: Se, priorityLevel: re, startTime: Be, expirationTime: Ye, sortIndex: -1 }, Be > le ? (re.sortIndex = Be, e(C, re), t(I) === null && re === t(C) && (W ? (N(j), j = -1) : W = !0, Xe(T, Be - le))) : (re.sortIndex = Ye, e(I, re), R || S || (R = !0, Re(P))), re;
    }, r.unstable_shouldYield = ne, r.unstable_wrapCallback = function(re) {
      var Se = b;
      return function() {
        var Be = b;
        b = Se;
        try {
          return re.apply(this, arguments);
        } finally {
          b = Be;
        }
      };
    };
  }(CM)), CM;
}
var hM = {}, gT;
function fP() {
  return gT || (gT = 1, function(r) {
    var e = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    e.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = 5;
      function i(He, vt) {
        var xt = He.length;
        He.push(vt), u(He, vt, xt);
      }
      function o(He) {
        return He.length === 0 ? null : He[0];
      }
      function l(He) {
        if (He.length === 0)
          return null;
        var vt = He[0], xt = He.pop();
        return xt !== vt && (He[0] = xt, I(He, xt, 0)), vt;
      }
      function u(He, vt, xt) {
        for (var ht = xt; ht > 0; ) {
          var on = ht - 1 >>> 1, we = He[on];
          if (C(we, vt) > 0)
            He[on] = vt, He[ht] = we, ht = on;
          else
            return;
        }
      }
      function I(He, vt, xt) {
        for (var ht = xt, on = He.length, we = on >>> 1; ht < we; ) {
          var qe = (ht + 1) * 2 - 1, de = He[qe], it = qe + 1, je = He[it];
          if (C(de, vt) < 0)
            it < on && C(je, de) < 0 ? (He[ht] = je, He[it] = vt, ht = it) : (He[ht] = de, He[qe] = vt, ht = qe);
          else if (it < on && C(je, vt) < 0)
            He[ht] = je, He[it] = vt, ht = it;
          else
            return;
        }
      }
      function C(He, vt) {
        var xt = He.sortIndex - vt.sortIndex;
        return xt !== 0 ? xt : He.id - vt.id;
      }
      var f = 1, v = 2, b = 3, S = 4, R = 5;
      function W(He, vt) {
      }
      var x = typeof performance == "object" && typeof performance.now == "function";
      if (x) {
        var N = performance;
        r.unstable_now = function() {
          return N.now();
        };
      } else {
        var Y = Date, F = Y.now();
        r.unstable_now = function() {
          return Y.now() - F;
        };
      }
      var T = 1073741823, P = -1, D = 250, L = 5e3, j = 1e4, J = T, O = [], ne = [], he = 1, pe = null, Ae = b, ke = !1, Re = !1, Xe = !1, re = typeof setTimeout == "function" ? setTimeout : null, Se = typeof clearTimeout == "function" ? clearTimeout : null, Be = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function le(He) {
        for (var vt = o(ne); vt !== null; ) {
          if (vt.callback === null)
            l(ne);
          else if (vt.startTime <= He)
            l(ne), vt.sortIndex = vt.expirationTime, i(O, vt);
          else
            return;
          vt = o(ne);
        }
      }
      function Ye(He) {
        if (Xe = !1, le(He), !Re)
          if (o(O) !== null)
            Re = !0, Gn(nt);
          else {
            var vt = o(ne);
            vt !== null && jt(Ye, vt.startTime - He);
          }
      }
      function nt(He, vt) {
        Re = !1, Xe && (Xe = !1, an()), ke = !0;
        var xt = Ae;
        try {
          var ht;
          if (!t) return ze(He, vt);
        } finally {
          pe = null, Ae = xt, ke = !1;
        }
      }
      function ze(He, vt) {
        var xt = vt;
        for (le(xt), pe = o(O); pe !== null && !(pe.expirationTime > xt && (!He || hn())); ) {
          var ht = pe.callback;
          if (typeof ht == "function") {
            pe.callback = null, Ae = pe.priorityLevel;
            var on = pe.expirationTime <= xt, we = ht(on);
            xt = r.unstable_now(), typeof we == "function" ? pe.callback = we : pe === o(O) && l(O), le(xt);
          } else
            l(O);
          pe = o(O);
        }
        if (pe !== null)
          return !0;
        var qe = o(ne);
        return qe !== null && jt(Ye, qe.startTime - xt), !1;
      }
      function Je(He, vt) {
        switch (He) {
          case f:
          case v:
          case b:
          case S:
          case R:
            break;
          default:
            He = b;
        }
        var xt = Ae;
        Ae = He;
        try {
          return vt();
        } finally {
          Ae = xt;
        }
      }
      function wt(He) {
        var vt;
        switch (Ae) {
          case f:
          case v:
          case b:
            vt = b;
            break;
          default:
            vt = Ae;
            break;
        }
        var xt = Ae;
        Ae = vt;
        try {
          return He();
        } finally {
          Ae = xt;
        }
      }
      function mt(He) {
        var vt = Ae;
        return function() {
          var xt = Ae;
          Ae = vt;
          try {
            return He.apply(this, arguments);
          } finally {
            Ae = xt;
          }
        };
      }
      function Dt(He, vt, xt) {
        var ht = r.unstable_now(), on;
        if (typeof xt == "object" && xt !== null) {
          var we = xt.delay;
          typeof we == "number" && we > 0 ? on = ht + we : on = ht;
        } else
          on = ht;
        var qe;
        switch (He) {
          case f:
            qe = P;
            break;
          case v:
            qe = D;
            break;
          case R:
            qe = J;
            break;
          case S:
            qe = j;
            break;
          case b:
          default:
            qe = L;
            break;
        }
        var de = on + qe, it = {
          id: he++,
          callback: vt,
          priorityLevel: He,
          startTime: on,
          expirationTime: de,
          sortIndex: -1
        };
        return on > ht ? (it.sortIndex = on, i(ne, it), o(O) === null && it === o(ne) && (Xe ? an() : Xe = !0, jt(Ye, on - ht))) : (it.sortIndex = de, i(O, it), !Re && !ke && (Re = !0, Gn(nt))), it;
      }
      function mn() {
      }
      function An() {
        !Re && !ke && (Re = !0, Gn(nt));
      }
      function Hn() {
        return o(O);
      }
      function ge(He) {
        He.callback = null;
      }
      function Wt() {
        return Ae;
      }
      var Nt = !1, $t = null, ft = -1, bn = n, en = -1;
      function hn() {
        var He = r.unstable_now() - en;
        return !(He < bn);
      }
      function me() {
      }
      function se(He) {
        if (He < 0 || He > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        He > 0 ? bn = Math.floor(1e3 / He) : bn = n;
      }
      var $e = function() {
        if ($t !== null) {
          var He = r.unstable_now();
          en = He;
          var vt = !0, xt = !0;
          try {
            xt = $t(vt, He);
          } finally {
            xt ? Vt() : (Nt = !1, $t = null);
          }
        } else
          Nt = !1;
      }, Vt;
      if (typeof Be == "function")
        Vt = function() {
          Be($e);
        };
      else if (typeof MessageChannel < "u") {
        var Bt = new MessageChannel(), Mt = Bt.port2;
        Bt.port1.onmessage = $e, Vt = function() {
          Mt.postMessage(null);
        };
      } else
        Vt = function() {
          re($e, 0);
        };
      function Gn(He) {
        $t = He, Nt || (Nt = !0, Vt());
      }
      function jt(He, vt) {
        ft = re(function() {
          He(r.unstable_now());
        }, vt);
      }
      function an() {
        Se(ft), ft = -1;
      }
      var jn = me, Ot = null;
      r.unstable_IdlePriority = R, r.unstable_ImmediatePriority = f, r.unstable_LowPriority = S, r.unstable_NormalPriority = b, r.unstable_Profiling = Ot, r.unstable_UserBlockingPriority = v, r.unstable_cancelCallback = ge, r.unstable_continueExecution = An, r.unstable_forceFrameRate = se, r.unstable_getCurrentPriorityLevel = Wt, r.unstable_getFirstCallbackNode = Hn, r.unstable_next = wt, r.unstable_pauseExecution = mn, r.unstable_requestPaint = jn, r.unstable_runWithPriority = Je, r.unstable_scheduleCallback = Dt, r.unstable_shouldYield = hn, r.unstable_wrapCallback = mt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(hM)), hM;
}
var dT;
function Az() {
  if (dT) return $x.exports;
  dT = 1;
  var r = {};
  return r.NODE_ENV === "production" ? $x.exports = hP() : $x.exports = fP(), $x.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IT;
function pP() {
  if (IT) return Qd;
  IT = 1;
  var r = xb(), e = Az();
  function t(c) {
    for (var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, B = 1; B < arguments.length; B++) h += "&args[]=" + encodeURIComponent(arguments[B]);
    return "Minified React error #" + c + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = /* @__PURE__ */ new Set(), i = {};
  function o(c, h) {
    l(c, h), l(c + "Capture", h);
  }
  function l(c, h) {
    for (i[c] = h, c = 0; c < h.length; c++) n.add(h[c]);
  }
  var u = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), I = Object.prototype.hasOwnProperty, C = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, v = {};
  function b(c) {
    return I.call(v, c) ? !0 : I.call(f, c) ? !1 : C.test(c) ? v[c] = !0 : (f[c] = !0, !1);
  }
  function S(c, h, B, M) {
    if (B !== null && B.type === 0) return !1;
    switch (typeof h) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return M ? !1 : B !== null ? !B.acceptsBooleans : (c = c.toLowerCase().slice(0, 5), c !== "data-" && c !== "aria-");
      default:
        return !1;
    }
  }
  function R(c, h, B, M) {
    if (h === null || typeof h > "u" || S(c, h, B, M)) return !0;
    if (M) return !1;
    if (B !== null) switch (B.type) {
      case 3:
        return !h;
      case 4:
        return h === !1;
      case 5:
        return isNaN(h);
      case 6:
        return isNaN(h) || 1 > h;
    }
    return !1;
  }
  function W(c, h, B, M, _, U, oe) {
    this.acceptsBooleans = h === 2 || h === 3 || h === 4, this.attributeName = M, this.attributeNamespace = _, this.mustUseProperty = B, this.propertyName = c, this.type = h, this.sanitizeURL = U, this.removeEmptyString = oe;
  }
  var x = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(c) {
    x[c] = new W(c, 0, !1, c, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
    var h = c[0];
    x[h] = new W(h, 1, !1, c[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
    x[c] = new W(c, 2, !1, c.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
    x[c] = new W(c, 2, !1, c, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(c) {
    x[c] = new W(c, 3, !1, c.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(c) {
    x[c] = new W(c, 3, !0, c, null, !1, !1);
  }), ["capture", "download"].forEach(function(c) {
    x[c] = new W(c, 4, !1, c, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(c) {
    x[c] = new W(c, 6, !1, c, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(c) {
    x[c] = new W(c, 5, !1, c.toLowerCase(), null, !1, !1);
  });
  var N = /[\-:]([a-z])/g;
  function Y(c) {
    return c[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(c) {
    var h = c.replace(
      N,
      Y
    );
    x[h] = new W(h, 1, !1, c, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(c) {
    var h = c.replace(N, Y);
    x[h] = new W(h, 1, !1, c, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(c) {
    var h = c.replace(N, Y);
    x[h] = new W(h, 1, !1, c, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(c) {
    x[c] = new W(c, 1, !1, c.toLowerCase(), null, !1, !1);
  }), x.xlinkHref = new W("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(c) {
    x[c] = new W(c, 1, !1, c.toLowerCase(), null, !0, !0);
  });
  function F(c, h, B, M) {
    var _ = x.hasOwnProperty(h) ? x[h] : null;
    (_ !== null ? _.type !== 0 : M || !(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (R(h, B, _, M) && (B = null), M || _ === null ? b(h) && (B === null ? c.removeAttribute(h) : c.setAttribute(h, "" + B)) : _.mustUseProperty ? c[_.propertyName] = B === null ? _.type === 3 ? !1 : "" : B : (h = _.attributeName, M = _.attributeNamespace, B === null ? c.removeAttribute(h) : (_ = _.type, B = _ === 3 || _ === 4 && B === !0 ? "" : "" + B, M ? c.setAttributeNS(M, h, B) : c.setAttribute(h, B))));
  }
  var T = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, P = Symbol.for("react.element"), D = Symbol.for("react.portal"), L = Symbol.for("react.fragment"), j = Symbol.for("react.strict_mode"), J = Symbol.for("react.profiler"), O = Symbol.for("react.provider"), ne = Symbol.for("react.context"), he = Symbol.for("react.forward_ref"), pe = Symbol.for("react.suspense"), Ae = Symbol.for("react.suspense_list"), ke = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), Xe = Symbol.for("react.offscreen"), re = Symbol.iterator;
  function Se(c) {
    return c === null || typeof c != "object" ? null : (c = re && c[re] || c["@@iterator"], typeof c == "function" ? c : null);
  }
  var Be = Object.assign, le;
  function Ye(c) {
    if (le === void 0) try {
      throw Error();
    } catch (B) {
      var h = B.stack.trim().match(/\n( *(at )?)/);
      le = h && h[1] || "";
    }
    return `
` + le + c;
  }
  var nt = !1;
  function ze(c, h) {
    if (!c || nt) return "";
    nt = !0;
    var B = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (h) if (h = function() {
        throw Error();
      }, Object.defineProperty(h.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(h, []);
        } catch (It) {
          var M = It;
        }
        Reflect.construct(c, [], h);
      } else {
        try {
          h.call();
        } catch (It) {
          M = It;
        }
        c.call(h.prototype);
      }
      else {
        try {
          throw Error();
        } catch (It) {
          M = It;
        }
        c();
      }
    } catch (It) {
      if (It && M && typeof It.stack == "string") {
        for (var _ = It.stack.split(`
`), U = M.stack.split(`
`), oe = _.length - 1, xe = U.length - 1; 1 <= oe && 0 <= xe && _[oe] !== U[xe]; ) xe--;
        for (; 1 <= oe && 0 <= xe; oe--, xe--) if (_[oe] !== U[xe]) {
          if (oe !== 1 || xe !== 1)
            do
              if (oe--, xe--, 0 > xe || _[oe] !== U[xe]) {
                var Le = `
` + _[oe].replace(" at new ", " at ");
                return c.displayName && Le.includes("<anonymous>") && (Le = Le.replace("<anonymous>", c.displayName)), Le;
              }
            while (1 <= oe && 0 <= xe);
          break;
        }
      }
    } finally {
      nt = !1, Error.prepareStackTrace = B;
    }
    return (c = c ? c.displayName || c.name : "") ? Ye(c) : "";
  }
  function Je(c) {
    switch (c.tag) {
      case 5:
        return Ye(c.type);
      case 16:
        return Ye("Lazy");
      case 13:
        return Ye("Suspense");
      case 19:
        return Ye("SuspenseList");
      case 0:
      case 2:
      case 15:
        return c = ze(c.type, !1), c;
      case 11:
        return c = ze(c.type.render, !1), c;
      case 1:
        return c = ze(c.type, !0), c;
      default:
        return "";
    }
  }
  function wt(c) {
    if (c == null) return null;
    if (typeof c == "function") return c.displayName || c.name || null;
    if (typeof c == "string") return c;
    switch (c) {
      case L:
        return "Fragment";
      case D:
        return "Portal";
      case J:
        return "Profiler";
      case j:
        return "StrictMode";
      case pe:
        return "Suspense";
      case Ae:
        return "SuspenseList";
    }
    if (typeof c == "object") switch (c.$$typeof) {
      case ne:
        return (c.displayName || "Context") + ".Consumer";
      case O:
        return (c._context.displayName || "Context") + ".Provider";
      case he:
        var h = c.render;
        return c = c.displayName, c || (c = h.displayName || h.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
      case ke:
        return h = c.displayName || null, h !== null ? h : wt(c.type) || "Memo";
      case Re:
        h = c._payload, c = c._init;
        try {
          return wt(c(h));
        } catch {
        }
    }
    return null;
  }
  function mt(c) {
    var h = c.type;
    switch (c.tag) {
      case 24:
        return "Cache";
      case 9:
        return (h.displayName || "Context") + ".Consumer";
      case 10:
        return (h._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return c = h.render, c = c.displayName || c.name || "", h.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return h;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return wt(h);
      case 8:
        return h === j ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
    }
    return null;
  }
  function Dt(c) {
    switch (typeof c) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return c;
      case "object":
        return c;
      default:
        return "";
    }
  }
  function mn(c) {
    var h = c.type;
    return (c = c.nodeName) && c.toLowerCase() === "input" && (h === "checkbox" || h === "radio");
  }
  function An(c) {
    var h = mn(c) ? "checked" : "value", B = Object.getOwnPropertyDescriptor(c.constructor.prototype, h), M = "" + c[h];
    if (!c.hasOwnProperty(h) && typeof B < "u" && typeof B.get == "function" && typeof B.set == "function") {
      var _ = B.get, U = B.set;
      return Object.defineProperty(c, h, { configurable: !0, get: function() {
        return _.call(this);
      }, set: function(oe) {
        M = "" + oe, U.call(this, oe);
      } }), Object.defineProperty(c, h, { enumerable: B.enumerable }), { getValue: function() {
        return M;
      }, setValue: function(oe) {
        M = "" + oe;
      }, stopTracking: function() {
        c._valueTracker = null, delete c[h];
      } };
    }
  }
  function Hn(c) {
    c._valueTracker || (c._valueTracker = An(c));
  }
  function ge(c) {
    if (!c) return !1;
    var h = c._valueTracker;
    if (!h) return !0;
    var B = h.getValue(), M = "";
    return c && (M = mn(c) ? c.checked ? "true" : "false" : c.value), c = M, c !== B ? (h.setValue(c), !0) : !1;
  }
  function Wt(c) {
    if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u") return null;
    try {
      return c.activeElement || c.body;
    } catch {
      return c.body;
    }
  }
  function Nt(c, h) {
    var B = h.checked;
    return Be({}, h, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: B ?? c._wrapperState.initialChecked });
  }
  function $t(c, h) {
    var B = h.defaultValue == null ? "" : h.defaultValue, M = h.checked != null ? h.checked : h.defaultChecked;
    B = Dt(h.value != null ? h.value : B), c._wrapperState = { initialChecked: M, initialValue: B, controlled: h.type === "checkbox" || h.type === "radio" ? h.checked != null : h.value != null };
  }
  function ft(c, h) {
    h = h.checked, h != null && F(c, "checked", h, !1);
  }
  function bn(c, h) {
    ft(c, h);
    var B = Dt(h.value), M = h.type;
    if (B != null) M === "number" ? (B === 0 && c.value === "" || c.value != B) && (c.value = "" + B) : c.value !== "" + B && (c.value = "" + B);
    else if (M === "submit" || M === "reset") {
      c.removeAttribute("value");
      return;
    }
    h.hasOwnProperty("value") ? hn(c, h.type, B) : h.hasOwnProperty("defaultValue") && hn(c, h.type, Dt(h.defaultValue)), h.checked == null && h.defaultChecked != null && (c.defaultChecked = !!h.defaultChecked);
  }
  function en(c, h, B) {
    if (h.hasOwnProperty("value") || h.hasOwnProperty("defaultValue")) {
      var M = h.type;
      if (!(M !== "submit" && M !== "reset" || h.value !== void 0 && h.value !== null)) return;
      h = "" + c._wrapperState.initialValue, B || h === c.value || (c.value = h), c.defaultValue = h;
    }
    B = c.name, B !== "" && (c.name = ""), c.defaultChecked = !!c._wrapperState.initialChecked, B !== "" && (c.name = B);
  }
  function hn(c, h, B) {
    (h !== "number" || Wt(c.ownerDocument) !== c) && (B == null ? c.defaultValue = "" + c._wrapperState.initialValue : c.defaultValue !== "" + B && (c.defaultValue = "" + B));
  }
  var me = Array.isArray;
  function se(c, h, B, M) {
    if (c = c.options, h) {
      h = {};
      for (var _ = 0; _ < B.length; _++) h["$" + B[_]] = !0;
      for (B = 0; B < c.length; B++) _ = h.hasOwnProperty("$" + c[B].value), c[B].selected !== _ && (c[B].selected = _), _ && M && (c[B].defaultSelected = !0);
    } else {
      for (B = "" + Dt(B), h = null, _ = 0; _ < c.length; _++) {
        if (c[_].value === B) {
          c[_].selected = !0, M && (c[_].defaultSelected = !0);
          return;
        }
        h !== null || c[_].disabled || (h = c[_]);
      }
      h !== null && (h.selected = !0);
    }
  }
  function $e(c, h) {
    if (h.dangerouslySetInnerHTML != null) throw Error(t(91));
    return Be({}, h, { value: void 0, defaultValue: void 0, children: "" + c._wrapperState.initialValue });
  }
  function Vt(c, h) {
    var B = h.value;
    if (B == null) {
      if (B = h.children, h = h.defaultValue, B != null) {
        if (h != null) throw Error(t(92));
        if (me(B)) {
          if (1 < B.length) throw Error(t(93));
          B = B[0];
        }
        h = B;
      }
      h == null && (h = ""), B = h;
    }
    c._wrapperState = { initialValue: Dt(B) };
  }
  function Bt(c, h) {
    var B = Dt(h.value), M = Dt(h.defaultValue);
    B != null && (B = "" + B, B !== c.value && (c.value = B), h.defaultValue == null && c.defaultValue !== B && (c.defaultValue = B)), M != null && (c.defaultValue = "" + M);
  }
  function Mt(c) {
    var h = c.textContent;
    h === c._wrapperState.initialValue && h !== "" && h !== null && (c.value = h);
  }
  function Gn(c) {
    switch (c) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function jt(c, h) {
    return c == null || c === "http://www.w3.org/1999/xhtml" ? Gn(h) : c === "http://www.w3.org/2000/svg" && h === "foreignObject" ? "http://www.w3.org/1999/xhtml" : c;
  }
  var an, jn = function(c) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(h, B, M, _) {
      MSApp.execUnsafeLocalFunction(function() {
        return c(h, B, M, _);
      });
    } : c;
  }(function(c, h) {
    if (c.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in c) c.innerHTML = h;
    else {
      for (an = an || document.createElement("div"), an.innerHTML = "<svg>" + h.valueOf().toString() + "</svg>", h = an.firstChild; c.firstChild; ) c.removeChild(c.firstChild);
      for (; h.firstChild; ) c.appendChild(h.firstChild);
    }
  });
  function Ot(c, h) {
    if (h) {
      var B = c.firstChild;
      if (B && B === c.lastChild && B.nodeType === 3) {
        B.nodeValue = h;
        return;
      }
    }
    c.textContent = h;
  }
  var He = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, vt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(He).forEach(function(c) {
    vt.forEach(function(h) {
      h = h + c.charAt(0).toUpperCase() + c.substring(1), He[h] = He[c];
    });
  });
  function xt(c, h, B) {
    return h == null || typeof h == "boolean" || h === "" ? "" : B || typeof h != "number" || h === 0 || He.hasOwnProperty(c) && He[c] ? ("" + h).trim() : h + "px";
  }
  function ht(c, h) {
    c = c.style;
    for (var B in h) if (h.hasOwnProperty(B)) {
      var M = B.indexOf("--") === 0, _ = xt(B, h[B], M);
      B === "float" && (B = "cssFloat"), M ? c.setProperty(B, _) : c[B] = _;
    }
  }
  var on = Be({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function we(c, h) {
    if (h) {
      if (on[c] && (h.children != null || h.dangerouslySetInnerHTML != null)) throw Error(t(137, c));
      if (h.dangerouslySetInnerHTML != null) {
        if (h.children != null) throw Error(t(60));
        if (typeof h.dangerouslySetInnerHTML != "object" || !("__html" in h.dangerouslySetInnerHTML)) throw Error(t(61));
      }
      if (h.style != null && typeof h.style != "object") throw Error(t(62));
    }
  }
  function qe(c, h) {
    if (c.indexOf("-") === -1) return typeof h.is == "string";
    switch (c) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var de = null;
  function it(c) {
    return c = c.target || c.srcElement || window, c.correspondingUseElement && (c = c.correspondingUseElement), c.nodeType === 3 ? c.parentNode : c;
  }
  var je = null, et = null, Jt = null;
  function Kn(c) {
    if (c = yr(c)) {
      if (typeof je != "function") throw Error(t(280));
      var h = c.stateNode;
      h && (h = Ru(h), je(c.stateNode, c.type, h));
    }
  }
  function di(c) {
    et ? Jt ? Jt.push(c) : Jt = [c] : et = c;
  }
  function Di() {
    if (et) {
      var c = et, h = Jt;
      if (Jt = et = null, Kn(c), h) for (c = 0; c < h.length; c++) Kn(h[c]);
    }
  }
  function Jn(c, h) {
    return c(h);
  }
  function Ii() {
  }
  var dr = !1;
  function xr(c, h, B) {
    if (dr) return c(h, B);
    dr = !0;
    try {
      return Jn(c, h, B);
    } finally {
      dr = !1, (et !== null || Jt !== null) && (Ii(), Di());
    }
  }
  function la(c, h) {
    var B = c.stateNode;
    if (B === null) return null;
    var M = Ru(B);
    if (M === null) return null;
    B = M[h];
    e: switch (h) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (M = !M.disabled) || (c = c.type, M = !(c === "button" || c === "input" || c === "select" || c === "textarea")), c = !M;
        break e;
      default:
        c = !1;
    }
    if (c) return null;
    if (B && typeof B != "function") throw Error(t(231, h, typeof B));
    return B;
  }
  var Ve = !1;
  if (u) try {
    var Oe = {};
    Object.defineProperty(Oe, "passive", { get: function() {
      Ve = !0;
    } }), window.addEventListener("test", Oe, Oe), window.removeEventListener("test", Oe, Oe);
  } catch {
    Ve = !1;
  }
  function rt(c, h, B, M, _, U, oe, xe, Le) {
    var It = Array.prototype.slice.call(arguments, 3);
    try {
      h.apply(B, It);
    } catch (Ut) {
      this.onError(Ut);
    }
  }
  var Et = !1, gn = null, Vn = !1, Ln = null, Ie = { onError: function(c) {
    Et = !0, gn = c;
  } };
  function tt(c, h, B, M, _, U, oe, xe, Le) {
    Et = !1, gn = null, rt.apply(Ie, arguments);
  }
  function At(c, h, B, M, _, U, oe, xe, Le) {
    if (tt.apply(this, arguments), Et) {
      if (Et) {
        var It = gn;
        Et = !1, gn = null;
      } else throw Error(t(198));
      Vn || (Vn = !0, Ln = It);
    }
  }
  function Gt(c) {
    var h = c, B = c;
    if (c.alternate) for (; h.return; ) h = h.return;
    else {
      c = h;
      do
        h = c, (h.flags & 4098) !== 0 && (B = h.return), c = h.return;
      while (c);
    }
    return h.tag === 3 ? B : null;
  }
  function vn(c) {
    if (c.tag === 13) {
      var h = c.memoizedState;
      if (h === null && (c = c.alternate, c !== null && (h = c.memoizedState)), h !== null) return h.dehydrated;
    }
    return null;
  }
  function ae(c) {
    if (Gt(c) !== c) throw Error(t(188));
  }
  function Ne(c) {
    var h = c.alternate;
    if (!h) {
      if (h = Gt(c), h === null) throw Error(t(188));
      return h !== c ? null : c;
    }
    for (var B = c, M = h; ; ) {
      var _ = B.return;
      if (_ === null) break;
      var U = _.alternate;
      if (U === null) {
        if (M = _.return, M !== null) {
          B = M;
          continue;
        }
        break;
      }
      if (_.child === U.child) {
        for (U = _.child; U; ) {
          if (U === B) return ae(_), c;
          if (U === M) return ae(_), h;
          U = U.sibling;
        }
        throw Error(t(188));
      }
      if (B.return !== M.return) B = _, M = U;
      else {
        for (var oe = !1, xe = _.child; xe; ) {
          if (xe === B) {
            oe = !0, B = _, M = U;
            break;
          }
          if (xe === M) {
            oe = !0, M = _, B = U;
            break;
          }
          xe = xe.sibling;
        }
        if (!oe) {
          for (xe = U.child; xe; ) {
            if (xe === B) {
              oe = !0, B = U, M = _;
              break;
            }
            if (xe === M) {
              oe = !0, M = U, B = _;
              break;
            }
            xe = xe.sibling;
          }
          if (!oe) throw Error(t(189));
        }
      }
      if (B.alternate !== M) throw Error(t(190));
    }
    if (B.tag !== 3) throw Error(t(188));
    return B.stateNode.current === B ? c : h;
  }
  function Te(c) {
    return c = Ne(c), c !== null ? De(c) : null;
  }
  function De(c) {
    if (c.tag === 5 || c.tag === 6) return c;
    for (c = c.child; c !== null; ) {
      var h = De(c);
      if (h !== null) return h;
      c = c.sibling;
    }
    return null;
  }
  var Ee = e.unstable_scheduleCallback, Tt = e.unstable_cancelCallback, tn = e.unstable_shouldYield, Bn = e.unstable_requestPaint, Pt = e.unstable_now, Zn = e.unstable_getCurrentPriorityLevel, rn = e.unstable_ImmediatePriority, Yn = e.unstable_UserBlockingPriority, Fi = e.unstable_NormalPriority, Ir = e.unstable_LowPriority, Tn = e.unstable_IdlePriority, mi = null, xn = null;
  function un(c) {
    if (xn && typeof xn.onCommitFiberRoot == "function") try {
      xn.onCommitFiberRoot(mi, c, void 0, (c.current.flags & 128) === 128);
    } catch {
    }
  }
  var Xn = Math.clz32 ? Math.clz32 : Xo, li = Math.log, Wr = Math.LN2;
  function Xo(c) {
    return c >>>= 0, c === 0 ? 32 : 31 - (li(c) / Wr | 0) | 0;
  }
  var $r = 64, ba = 4194304;
  function or(c) {
    switch (c & -c) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return c & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return c;
    }
  }
  function za(c, h) {
    var B = c.pendingLanes;
    if (B === 0) return 0;
    var M = 0, _ = c.suspendedLanes, U = c.pingedLanes, oe = B & 268435455;
    if (oe !== 0) {
      var xe = oe & ~_;
      xe !== 0 ? M = or(xe) : (U &= oe, U !== 0 && (M = or(U)));
    } else oe = B & ~_, oe !== 0 ? M = or(oe) : U !== 0 && (M = or(U));
    if (M === 0) return 0;
    if (h !== 0 && h !== M && (h & _) === 0 && (_ = M & -M, U = h & -h, _ >= U || _ === 16 && (U & 4194240) !== 0)) return h;
    if ((M & 4) !== 0 && (M |= B & 16), h = c.entangledLanes, h !== 0) for (c = c.entanglements, h &= M; 0 < h; ) B = 31 - Xn(h), _ = 1 << B, M |= c[B], h &= ~_;
    return M;
  }
  function pl(c, h) {
    switch (c) {
      case 1:
      case 2:
      case 4:
        return h + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return h + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Xa(c, h) {
    for (var B = c.suspendedLanes, M = c.pingedLanes, _ = c.expirationTimes, U = c.pendingLanes; 0 < U; ) {
      var oe = 31 - Xn(U), xe = 1 << oe, Le = _[oe];
      Le === -1 ? ((xe & B) === 0 || (xe & M) !== 0) && (_[oe] = pl(xe, h)) : Le <= h && (c.expiredLanes |= xe), U &= ~xe;
    }
  }
  function bs(c) {
    return c = c.pendingLanes & -1073741825, c !== 0 ? c : c & 1073741824 ? 1073741824 : 0;
  }
  function Ao() {
    var c = $r;
    return $r <<= 1, ($r & 4194240) === 0 && ($r = 64), c;
  }
  function Ou(c) {
    for (var h = [], B = 0; 31 > B; B++) h.push(c);
    return h;
  }
  function od(c, h, B) {
    c.pendingLanes |= h, h !== 536870912 && (c.suspendedLanes = 0, c.pingedLanes = 0), c = c.eventTimes, h = 31 - Xn(h), c[h] = B;
  }
  function dI(c, h) {
    var B = c.pendingLanes & ~h;
    c.pendingLanes = h, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= h, c.mutableReadLanes &= h, c.entangledLanes &= h, h = c.entanglements;
    var M = c.eventTimes;
    for (c = c.expirationTimes; 0 < B; ) {
      var _ = 31 - Xn(B), U = 1 << _;
      h[_] = 0, M[_] = -1, c[_] = -1, B &= ~U;
    }
  }
  function Pu(c, h) {
    var B = c.entangledLanes |= h;
    for (c = c.entanglements; B; ) {
      var M = 31 - Xn(B), _ = 1 << M;
      _ & h | c[M] & h && (c[M] |= h), B &= ~_;
    }
  }
  var sr = 0;
  function Yo(c) {
    return c &= -c, 1 < c ? 4 < c ? (c & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
  }
  var Cu, Hi, sf, hu, xi, Ju = !1, Po = [], Gs = null, Bi = null, Qu = null, Ra = /* @__PURE__ */ new Map(), Lr = /* @__PURE__ */ new Map(), Ds = [], fu = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sr(c, h) {
    switch (c) {
      case "focusin":
      case "focusout":
        Gs = null;
        break;
      case "dragenter":
      case "dragleave":
        Bi = null;
        break;
      case "mouseover":
      case "mouseout":
        Qu = null;
        break;
      case "pointerover":
      case "pointerout":
        Ra.delete(h.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Lr.delete(h.pointerId);
    }
  }
  function as(c, h, B, M, _, U) {
    return c === null || c.nativeEvent !== U ? (c = { blockedOn: h, domEventName: B, eventSystemFlags: M, nativeEvent: U, targetContainers: [_] }, h !== null && (h = yr(h), h !== null && Hi(h)), c) : (c.eventSystemFlags |= M, h = c.targetContainers, _ !== null && h.indexOf(_) === -1 && h.push(_), c);
  }
  function Ap(c, h, B, M, _) {
    switch (h) {
      case "focusin":
        return Gs = as(Gs, c, h, B, M, _), !0;
      case "dragenter":
        return Bi = as(Bi, c, h, B, M, _), !0;
      case "mouseover":
        return Qu = as(Qu, c, h, B, M, _), !0;
      case "pointerover":
        var U = _.pointerId;
        return Ra.set(U, as(Ra.get(U) || null, c, h, B, M, _)), !0;
      case "gotpointercapture":
        return U = _.pointerId, Lr.set(U, as(Lr.get(U) || null, c, h, B, M, _)), !0;
    }
    return !1;
  }
  function sd(c) {
    var h = yd(c.target);
    if (h !== null) {
      var B = Gt(h);
      if (B !== null) {
        if (h = B.tag, h === 13) {
          if (h = vn(B), h !== null) {
            c.blockedOn = h, xi(c.priority, function() {
              sf(B);
            });
            return;
          }
        } else if (h === 3 && B.stateNode.current.memoizedState.isDehydrated) {
          c.blockedOn = B.tag === 3 ? B.stateNode.containerInfo : null;
          return;
        }
      }
    }
    c.blockedOn = null;
  }
  function II(c) {
    if (c.blockedOn !== null) return !1;
    for (var h = c.targetContainers; 0 < h.length; ) {
      var B = Os(c.domEventName, c.eventSystemFlags, h[0], c.nativeEvent);
      if (B === null) {
        B = c.nativeEvent;
        var M = new B.constructor(B.type, B);
        de = M, B.target.dispatchEvent(M), de = null;
      } else return h = yr(B), h !== null && Hi(h), c.blockedOn = B, !1;
      h.shift();
    }
    return !0;
  }
  function hg(c, h, B) {
    II(c) && B.delete(h);
  }
  function Us() {
    Ju = !1, Gs !== null && II(Gs) && (Gs = null), Bi !== null && II(Bi) && (Bi = null), Qu !== null && II(Qu) && (Qu = null), Ra.forEach(hg), Lr.forEach(hg);
  }
  function CI(c, h) {
    c.blockedOn === h && (c.blockedOn = null, Ju || (Ju = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Us)));
  }
  function pu(c) {
    function h(_) {
      return CI(_, c);
    }
    if (0 < Po.length) {
      CI(Po[0], c);
      for (var B = 1; B < Po.length; B++) {
        var M = Po[B];
        M.blockedOn === c && (M.blockedOn = null);
      }
    }
    for (Gs !== null && CI(Gs, c), Bi !== null && CI(Bi, c), Qu !== null && CI(Qu, c), Ra.forEach(h), Lr.forEach(h), B = 0; B < Ds.length; B++) M = Ds[B], M.blockedOn === c && (M.blockedOn = null);
    for (; 0 < Ds.length && (B = Ds[0], B.blockedOn === null); ) sd(B), B.blockedOn === null && Ds.shift();
  }
  var $a = T.ReactCurrentBatchConfig, Bs = !0;
  function Ul(c, h, B, M) {
    var _ = sr, U = $a.transition;
    $a.transition = null;
    try {
      sr = 1, fg(c, h, B, M);
    } finally {
      sr = _, $a.transition = U;
    }
  }
  function ld(c, h, B, M) {
    var _ = sr, U = $a.transition;
    $a.transition = null;
    try {
      sr = 4, fg(c, h, B, M);
    } finally {
      sr = _, $a.transition = U;
    }
  }
  function fg(c, h, B, M) {
    if (Bs) {
      var _ = Os(c, h, B, M);
      if (_ === null) Ad(c, h, M, pg, B), Sr(c, M);
      else if (Ap(_, c, h, B, M)) M.stopPropagation();
      else if (Sr(c, M), h & 4 && -1 < fu.indexOf(c)) {
        for (; _ !== null; ) {
          var U = yr(_);
          if (U !== null && Cu(U), U = Os(c, h, B, M), U === null && Ad(c, h, M, pg, B), U === _) break;
          _ = U;
        }
        _ !== null && M.stopPropagation();
      } else Ad(c, h, M, null, B);
    }
  }
  var pg = null;
  function Os(c, h, B, M) {
    if (pg = null, c = it(M), c = yd(c), c !== null) if (h = Gt(c), h === null) c = null;
    else if (B = h.tag, B === 13) {
      if (c = vn(h), c !== null) return c;
      c = null;
    } else if (B === 3) {
      if (h.stateNode.current.memoizedState.isDehydrated) return h.tag === 3 ? h.stateNode.containerInfo : null;
      c = null;
    } else h !== c && (c = null);
    return pg = c, null;
  }
  function th(c) {
    switch (c) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Zn()) {
          case rn:
            return 1;
          case Yn:
            return 4;
          case Fi:
          case Ir:
            return 16;
          case Tn:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ps = null, hI = null, ie = null;
  function Me() {
    if (ie) return ie;
    var c, h = hI, B = h.length, M, _ = "value" in Ps ? Ps.value : Ps.textContent, U = _.length;
    for (c = 0; c < B && h[c] === _[c]; c++) ;
    var oe = B - c;
    for (M = 1; M <= oe && h[B - M] === _[U - M]; M++) ;
    return ie = _.slice(c, 1 < M ? 1 - M : void 0);
  }
  function gt(c) {
    var h = c.keyCode;
    return "charCode" in c ? (c = c.charCode, c === 0 && h === 13 && (c = 13)) : c = h, c === 10 && (c = 13), 32 <= c || c === 13 ? c : 0;
  }
  function St() {
    return !0;
  }
  function dn() {
    return !1;
  }
  function qn(c) {
    function h(B, M, _, U, oe) {
      this._reactName = B, this._targetInst = _, this.type = M, this.nativeEvent = U, this.target = oe, this.currentTarget = null;
      for (var xe in c) c.hasOwnProperty(xe) && (B = c[xe], this[xe] = B ? B(U) : U[xe]);
      return this.isDefaultPrevented = (U.defaultPrevented != null ? U.defaultPrevented : U.returnValue === !1) ? St : dn, this.isPropagationStopped = dn, this;
    }
    return Be(h.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var B = this.nativeEvent;
      B && (B.preventDefault ? B.preventDefault() : typeof B.returnValue != "unknown" && (B.returnValue = !1), this.isDefaultPrevented = St);
    }, stopPropagation: function() {
      var B = this.nativeEvent;
      B && (B.stopPropagation ? B.stopPropagation() : typeof B.cancelBubble != "unknown" && (B.cancelBubble = !0), this.isPropagationStopped = St);
    }, persist: function() {
    }, isPersistent: St }), h;
  }
  var _n = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(c) {
    return c.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Si = qn(_n), Ui = Be({}, _n, { view: 0, detail: 0 }), ur = qn(Ui), nr, $i, Zi, kr = Be({}, Ui, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ss, button: 0, buttons: 0, relatedTarget: function(c) {
    return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget;
  }, movementX: function(c) {
    return "movementX" in c ? c.movementX : (c !== Zi && (Zi && c.type === "mousemove" ? (nr = c.screenX - Zi.screenX, $i = c.screenY - Zi.screenY) : $i = nr = 0, Zi = c), nr);
  }, movementY: function(c) {
    return "movementY" in c ? c.movementY : $i;
  } }), Ka = qn(kr), Js = Be({}, kr, { dataTransfer: 0 }), mu = qn(Js), Au = Be({}, Ui, { relatedTarget: 0 }), ud = qn(Au), mg = Be({}, _n, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), lf = qn(mg), nh = Be({}, _n, { clipboardData: function(c) {
    return "clipboardData" in c ? c.clipboardData : window.clipboardData;
  } }), ih = qn(nh), rh = Be({}, _n, { data: 0 }), ah = qn(rh), vp = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, yp = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, uf = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function qI(c) {
    var h = this.nativeEvent;
    return h.getModifierState ? h.getModifierState(c) : (c = uf[c]) ? !!h[c] : !1;
  }
  function Ss() {
    return qI;
  }
  var cf = Be({}, Ui, { key: function(c) {
    if (c.key) {
      var h = vp[c.key] || c.key;
      if (h !== "Unidentified") return h;
    }
    return c.type === "keypress" ? (c = gt(c), c === 13 ? "Enter" : String.fromCharCode(c)) : c.type === "keydown" || c.type === "keyup" ? yp[c.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ss, charCode: function(c) {
    return c.type === "keypress" ? gt(c) : 0;
  }, keyCode: function(c) {
    return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
  }, which: function(c) {
    return c.type === "keypress" ? gt(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
  } }), $I = qn(cf), ml = Be({}, kr, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Qs = qn(ml), fI = Be({}, Ui, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ss }), vu = qn(fI), xc = Be({}, _n, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), vo = qn(xc), Wc = Be({}, kr, {
    deltaX: function(c) {
      return "deltaX" in c ? c.deltaX : "wheelDeltaX" in c ? -c.wheelDeltaX : 0;
    },
    deltaY: function(c) {
      return "deltaY" in c ? c.deltaY : "wheelDeltaY" in c ? -c.wheelDeltaY : "wheelDelta" in c ? -c.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), ha = qn(Wc), yu = [9, 13, 27, 32], Jo = u && "CompositionEvent" in window, eo = null;
  u && "documentMode" in document && (eo = document.documentMode);
  var Ga = u && "TextEvent" in window && !eo, ju = u && (!Jo || eo && 8 < eo && 11 >= eo), Ol = " ", gf = !1;
  function eC(c, h) {
    switch (c) {
      case "keyup":
        return yu.indexOf(h.keyCode) !== -1;
      case "keydown":
        return h.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function df(c) {
    return c = c.detail, typeof c == "object" && "data" in c ? c.data : null;
  }
  var cd = !1;
  function If(c, h) {
    switch (c) {
      case "compositionend":
        return df(h);
      case "keypress":
        return h.which !== 32 ? null : (gf = !0, Ol);
      case "textInput":
        return c = h.data, c === Ol && gf ? null : c;
      default:
        return null;
    }
  }
  function gd(c, h) {
    if (cd) return c === "compositionend" || !Jo && eC(c, h) ? (c = Me(), ie = hI = Ps = null, cd = !1, c) : null;
    switch (c) {
      case "paste":
        return null;
      case "keypress":
        if (!(h.ctrlKey || h.altKey || h.metaKey) || h.ctrlKey && h.altKey) {
          if (h.char && 1 < h.char.length) return h.char;
          if (h.which) return String.fromCharCode(h.which);
        }
        return null;
      case "compositionend":
        return ju && h.locale !== "ko" ? null : h.data;
      default:
        return null;
    }
  }
  var Pl = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function tC(c) {
    var h = c && c.nodeName && c.nodeName.toLowerCase();
    return h === "input" ? !!Pl[c.type] : h === "textarea";
  }
  function Ag(c, h, B, M) {
    di(M), h = pI(h, "onChange"), 0 < h.length && (B = new Si("onChange", "change", null, B, M), c.push({ event: B, listeners: h }));
  }
  var vg = null, Jl = null;
  function Cf(c) {
    $l(c, 0);
  }
  function bu(c) {
    var h = Nn(c);
    if (ge(h)) return c;
  }
  function bp(c, h) {
    if (c === "change") return h;
  }
  var dd = !1;
  if (u) {
    var js;
    if (u) {
      var Id = "oninput" in document;
      if (!Id) {
        var Cd = document.createElement("div");
        Cd.setAttribute("oninput", "return;"), Id = typeof Cd.oninput == "function";
      }
      js = Id;
    } else js = !1;
    dd = js && (!document.documentMode || 9 < document.documentMode);
  }
  function Al() {
    vg && (vg.detachEvent("onpropertychange", vl), Jl = vg = null);
  }
  function vl(c) {
    if (c.propertyName === "value" && bu(Jl)) {
      var h = [];
      Ag(h, Jl, c, it(c)), xr(Cf, h);
    }
  }
  function hd(c, h, B) {
    c === "focusin" ? (Al(), vg = h, Jl = B, vg.attachEvent("onpropertychange", vl)) : c === "focusout" && Al();
  }
  function oh(c) {
    if (c === "selectionchange" || c === "keyup" || c === "keydown") return bu(Jl);
  }
  function Gu(c, h) {
    if (c === "click") return bu(h);
  }
  function Tr(c, h) {
    if (c === "input" || c === "change") return bu(h);
  }
  function yo(c, h) {
    return c === h && (c !== 0 || 1 / c === 1 / h) || c !== c && h !== h;
  }
  var Dr = typeof Object.is == "function" ? Object.is : yo;
  function yg(c, h) {
    if (Dr(c, h)) return !0;
    if (typeof c != "object" || c === null || typeof h != "object" || h === null) return !1;
    var B = Object.keys(c), M = Object.keys(h);
    if (B.length !== M.length) return !1;
    for (M = 0; M < B.length; M++) {
      var _ = B[M];
      if (!I.call(h, _) || !Dr(c[_], h[_])) return !1;
    }
    return !0;
  }
  function os(c) {
    for (; c && c.firstChild; ) c = c.firstChild;
    return c;
  }
  function to(c, h) {
    var B = os(c);
    c = 0;
    for (var M; B; ) {
      if (B.nodeType === 3) {
        if (M = c + B.textContent.length, c <= h && M >= h) return { node: B, offset: h - c };
        c = M;
      }
      e: {
        for (; B; ) {
          if (B.nextSibling) {
            B = B.nextSibling;
            break e;
          }
          B = B.parentNode;
        }
        B = void 0;
      }
      B = os(B);
    }
  }
  function Qo(c, h) {
    return c && h ? c === h ? !0 : c && c.nodeType === 3 ? !1 : h && h.nodeType === 3 ? Qo(c, h.parentNode) : "contains" in c ? c.contains(h) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(h) & 16) : !1 : !1;
  }
  function Hr() {
    for (var c = window, h = Wt(); h instanceof c.HTMLIFrameElement; ) {
      try {
        var B = typeof h.contentWindow.location.href == "string";
      } catch {
        B = !1;
      }
      if (B) c = h.contentWindow;
      else break;
      h = Wt(c.document);
    }
    return h;
  }
  function fa(c) {
    var h = c && c.nodeName && c.nodeName.toLowerCase();
    return h && (h === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || h === "textarea" || c.contentEditable === "true");
  }
  function bo(c) {
    var h = Hr(), B = c.focusedElem, M = c.selectionRange;
    if (h !== B && B && B.ownerDocument && Qo(B.ownerDocument.documentElement, B)) {
      if (M !== null && fa(B)) {
        if (h = M.start, c = M.end, c === void 0 && (c = h), "selectionStart" in B) B.selectionStart = h, B.selectionEnd = Math.min(c, B.value.length);
        else if (c = (h = B.ownerDocument || document) && h.defaultView || window, c.getSelection) {
          c = c.getSelection();
          var _ = B.textContent.length, U = Math.min(M.start, _);
          M = M.end === void 0 ? U : Math.min(M.end, _), !c.extend && U > M && (_ = M, M = U, U = _), _ = to(B, U);
          var oe = to(
            B,
            M
          );
          _ && oe && (c.rangeCount !== 1 || c.anchorNode !== _.node || c.anchorOffset !== _.offset || c.focusNode !== oe.node || c.focusOffset !== oe.offset) && (h = h.createRange(), h.setStart(_.node, _.offset), c.removeAllRanges(), U > M ? (c.addRange(h), c.extend(oe.node, oe.offset)) : (h.setEnd(oe.node, oe.offset), c.addRange(h)));
        }
      }
      for (h = [], c = B; c = c.parentNode; ) c.nodeType === 1 && h.push({ element: c, left: c.scrollLeft, top: c.scrollTop });
      for (typeof B.focus == "function" && B.focus(), B = 0; B < h.length; B++) c = h[B], c.element.scrollLeft = c.left, c.element.scrollTop = c.top;
    }
  }
  var yl = u && "documentMode" in document && 11 >= document.documentMode, Ql = null, Zs = null, fd = null, Go = !1;
  function sh(c, h, B) {
    var M = B.window === B ? B.document : B.nodeType === 9 ? B : B.ownerDocument;
    Go || Ql == null || Ql !== Wt(M) || (M = Ql, "selectionStart" in M && fa(M) ? M = { start: M.selectionStart, end: M.selectionEnd } : (M = (M.ownerDocument && M.ownerDocument.defaultView || window).getSelection(), M = { anchorNode: M.anchorNode, anchorOffset: M.anchorOffset, focusNode: M.focusNode, focusOffset: M.focusOffset }), fd && yg(fd, M) || (fd = M, M = pI(Zs, "onSelect"), 0 < M.length && (h = new Si("onSelect", "select", null, h, B), c.push({ event: h, listeners: M }), h.target = Ql)));
  }
  function pd(c, h) {
    var B = {};
    return B[c.toLowerCase()] = h.toLowerCase(), B["Webkit" + c] = "webkit" + h, B["Moz" + c] = "moz" + h, B;
  }
  var qu = { animationend: pd("Animation", "AnimationEnd"), animationiteration: pd("Animation", "AnimationIteration"), animationstart: pd("Animation", "AnimationStart"), transitionend: pd("Transition", "TransitionEnd") }, jl = {}, Ba = {};
  u && (Ba = document.createElement("div").style, "AnimationEvent" in window || (delete qu.animationend.animation, delete qu.animationiteration.animation, delete qu.animationstart.animation), "TransitionEvent" in window || delete qu.transitionend.transition);
  function ws(c) {
    if (jl[c]) return jl[c];
    if (!qu[c]) return c;
    var h = qu[c], B;
    for (B in h) if (h.hasOwnProperty(B) && B in Ba) return jl[c] = h[B];
    return c;
  }
  var nC = ws("animationend"), wi = ws("animationiteration"), _r = ws("animationstart"), vr = ws("transitionend"), La = /* @__PURE__ */ new Map(), ql = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Bu(c, h) {
    La.set(c, h), o(h, [c]);
  }
  for (var md = 0; md < ql.length; md++) {
    var lh = ql[md], bg = lh.toLowerCase(), hf = lh[0].toUpperCase() + lh.slice(1);
    Bu(bg, "on" + hf);
  }
  Bu(nC, "onAnimationEnd"), Bu(wi, "onAnimationIteration"), Bu(_r, "onAnimationStart"), Bu("dblclick", "onDoubleClick"), Bu("focusin", "onFocus"), Bu("focusout", "onBlur"), Bu(vr, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), o("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), o("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), o("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Qt = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), no = new Set("cancel close invalid load scroll toggle".split(" ").concat(Qt));
  function ji(c, h, B) {
    var M = c.type || "unknown-event";
    c.currentTarget = B, At(M, h, void 0, c), c.currentTarget = null;
  }
  function $l(c, h) {
    h = (h & 4) !== 0;
    for (var B = 0; B < c.length; B++) {
      var M = c[B], _ = M.event;
      M = M.listeners;
      e: {
        var U = void 0;
        if (h) for (var oe = M.length - 1; 0 <= oe; oe--) {
          var xe = M[oe], Le = xe.instance, It = xe.currentTarget;
          if (xe = xe.listener, Le !== U && _.isPropagationStopped()) break e;
          ji(_, xe, It), U = Le;
        }
        else for (oe = 0; oe < M.length; oe++) {
          if (xe = M[oe], Le = xe.instance, It = xe.currentTarget, xe = xe.listener, Le !== U && _.isPropagationStopped()) break e;
          ji(_, xe, It), U = Le;
        }
      }
    }
    if (Vn) throw c = Ln, Vn = !1, Ln = null, c;
  }
  function lr(c, h) {
    var B = h[$u];
    B === void 0 && (B = h[$u] = /* @__PURE__ */ new Set());
    var M = c + "__bubble";
    B.has(M) || (Nc(h, c, 2, !1), B.add(M));
  }
  function qs(c, h, B) {
    var M = 0;
    h && (M |= 4), Nc(B, c, M, h);
  }
  var bl = "_reactListening" + Math.random().toString(36).slice(2);
  function Vc(c) {
    if (!c[bl]) {
      c[bl] = !0, n.forEach(function(B) {
        B !== "selectionchange" && (no.has(B) || qs(B, !1, c), qs(B, !0, c));
      });
      var h = c.nodeType === 9 ? c : c.ownerDocument;
      h === null || h[bl] || (h[bl] = !0, qs("selectionchange", !1, h));
    }
  }
  function Nc(c, h, B, M) {
    switch (th(h)) {
      case 1:
        var _ = Ul;
        break;
      case 4:
        _ = ld;
        break;
      default:
        _ = fg;
    }
    B = _.bind(null, h, B, c), _ = void 0, !Ve || h !== "touchstart" && h !== "touchmove" && h !== "wheel" || (_ = !0), M ? _ !== void 0 ? c.addEventListener(h, B, { capture: !0, passive: _ }) : c.addEventListener(h, B, !0) : _ !== void 0 ? c.addEventListener(h, B, { passive: _ }) : c.addEventListener(h, B, !1);
  }
  function Ad(c, h, B, M, _) {
    var U = M;
    if ((h & 1) === 0 && (h & 2) === 0 && M !== null) e: for (; ; ) {
      if (M === null) return;
      var oe = M.tag;
      if (oe === 3 || oe === 4) {
        var xe = M.stateNode.containerInfo;
        if (xe === _ || xe.nodeType === 8 && xe.parentNode === _) break;
        if (oe === 4) for (oe = M.return; oe !== null; ) {
          var Le = oe.tag;
          if ((Le === 3 || Le === 4) && (Le = oe.stateNode.containerInfo, Le === _ || Le.nodeType === 8 && Le.parentNode === _)) return;
          oe = oe.return;
        }
        for (; xe !== null; ) {
          if (oe = yd(xe), oe === null) return;
          if (Le = oe.tag, Le === 5 || Le === 6) {
            M = U = oe;
            continue e;
          }
          xe = xe.parentNode;
        }
      }
      M = M.return;
    }
    xr(function() {
      var It = U, Ut = it(B), sn = [];
      e: {
        var qt = La.get(c);
        if (qt !== void 0) {
          var kn = Si, ii = c;
          switch (c) {
            case "keypress":
              if (gt(B) === 0) break e;
            case "keydown":
            case "keyup":
              kn = $I;
              break;
            case "focusin":
              ii = "focus", kn = ud;
              break;
            case "focusout":
              ii = "blur", kn = ud;
              break;
            case "beforeblur":
            case "afterblur":
              kn = ud;
              break;
            case "click":
              if (B.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              kn = Ka;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              kn = mu;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              kn = vu;
              break;
            case nC:
            case wi:
            case _r:
              kn = lf;
              break;
            case vr:
              kn = vo;
              break;
            case "scroll":
              kn = ur;
              break;
            case "wheel":
              kn = ha;
              break;
            case "copy":
            case "cut":
            case "paste":
              kn = ih;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              kn = Qs;
          }
          var oi = (h & 4) !== 0, ts = !oi && c === "scroll", at = oi ? qt !== null ? qt + "Capture" : null : qt;
          oi = [];
          for (var Ue = It, lt; Ue !== null; ) {
            lt = Ue;
            var pn = lt.stateNode;
            if (lt.tag === 5 && pn !== null && (lt = pn, at !== null && (pn = la(Ue, at), pn != null && oi.push(Gg(Ue, pn, lt)))), ts) break;
            Ue = Ue.return;
          }
          0 < oi.length && (qt = new kn(qt, ii, null, B, Ut), sn.push({ event: qt, listeners: oi }));
        }
      }
      if ((h & 7) === 0) {
        e: {
          if (qt = c === "mouseover" || c === "pointerover", kn = c === "mouseout" || c === "pointerout", qt && B !== de && (ii = B.relatedTarget || B.fromElement) && (yd(ii) || ii[Bl])) break e;
          if ((kn || qt) && (qt = Ut.window === Ut ? Ut : (qt = Ut.ownerDocument) ? qt.defaultView || qt.parentWindow : window, kn ? (ii = B.relatedTarget || B.toElement, kn = It, ii = ii ? yd(ii) : null, ii !== null && (ts = Gt(ii), ii !== ts || ii.tag !== 5 && ii.tag !== 6) && (ii = null)) : (kn = null, ii = It), kn !== ii)) {
            if (oi = Ka, pn = "onMouseLeave", at = "onMouseEnter", Ue = "mouse", (c === "pointerout" || c === "pointerover") && (oi = Qs, pn = "onPointerLeave", at = "onPointerEnter", Ue = "pointer"), ts = kn == null ? qt : Nn(kn), lt = ii == null ? qt : Nn(ii), qt = new oi(pn, Ue + "leave", kn, B, Ut), qt.target = ts, qt.relatedTarget = lt, pn = null, yd(Ut) === It && (oi = new oi(at, Ue + "enter", ii, B, Ut), oi.target = lt, oi.relatedTarget = ts, pn = oi), ts = pn, kn && ii) t: {
              for (oi = kn, at = ii, Ue = 0, lt = oi; lt; lt = Mc(lt)) Ue++;
              for (lt = 0, pn = at; pn; pn = Mc(pn)) lt++;
              for (; 0 < Ue - lt; ) oi = Mc(oi), Ue--;
              for (; 0 < lt - Ue; ) at = Mc(at), lt--;
              for (; Ue--; ) {
                if (oi === at || at !== null && oi === at.alternate) break t;
                oi = Mc(oi), at = Mc(at);
              }
              oi = null;
            }
            else oi = null;
            kn !== null && iC(sn, qt, kn, oi, !1), ii !== null && ts !== null && iC(sn, ts, ii, oi, !0);
          }
        }
        e: {
          if (qt = It ? Nn(It) : window, kn = qt.nodeName && qt.nodeName.toLowerCase(), kn === "select" || kn === "input" && qt.type === "file") var zn = bp;
          else if (tC(qt)) if (dd) zn = Tr;
          else {
            zn = oh;
            var Ci = hd;
          }
          else (kn = qt.nodeName) && kn.toLowerCase() === "input" && (qt.type === "checkbox" || qt.type === "radio") && (zn = Gu);
          if (zn && (zn = zn(c, It))) {
            Ag(sn, zn, B, Ut);
            break e;
          }
          Ci && Ci(c, qt, It), c === "focusout" && (Ci = qt._wrapperState) && Ci.controlled && qt.type === "number" && hn(qt, "number", qt.value);
        }
        switch (Ci = It ? Nn(It) : window, c) {
          case "focusin":
            (tC(Ci) || Ci.contentEditable === "true") && (Ql = Ci, Zs = It, fd = null);
            break;
          case "focusout":
            fd = Zs = Ql = null;
            break;
          case "mousedown":
            Go = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Go = !1, sh(sn, B, Ut);
            break;
          case "selectionchange":
            if (yl) break;
          case "keydown":
          case "keyup":
            sh(sn, B, Ut);
        }
        var vi;
        if (Jo) e: {
          switch (c) {
            case "compositionstart":
              var Ei = "onCompositionStart";
              break e;
            case "compositionend":
              Ei = "onCompositionEnd";
              break e;
            case "compositionupdate":
              Ei = "onCompositionUpdate";
              break e;
          }
          Ei = void 0;
        }
        else cd ? eC(c, B) && (Ei = "onCompositionEnd") : c === "keydown" && B.keyCode === 229 && (Ei = "onCompositionStart");
        Ei && (ju && B.locale !== "ko" && (cd || Ei !== "onCompositionStart" ? Ei === "onCompositionEnd" && cd && (vi = Me()) : (Ps = Ut, hI = "value" in Ps ? Ps.value : Ps.textContent, cd = !0)), Ci = pI(It, Ei), 0 < Ci.length && (Ei = new ah(Ei, c, null, B, Ut), sn.push({ event: Ei, listeners: Ci }), vi ? Ei.data = vi : (vi = df(B), vi !== null && (Ei.data = vi)))), (vi = Ga ? If(c, B) : gd(c, B)) && (It = pI(It, "onBeforeInput"), 0 < It.length && (Ut = new ah("onBeforeInput", "beforeinput", null, B, Ut), sn.push({ event: Ut, listeners: It }), Ut.data = vi));
      }
      $l(sn, h);
    });
  }
  function Gg(c, h, B) {
    return { instance: c, listener: h, currentTarget: B };
  }
  function pI(c, h) {
    for (var B = h + "Capture", M = []; c !== null; ) {
      var _ = c, U = _.stateNode;
      _.tag === 5 && U !== null && (_ = U, U = la(c, B), U != null && M.unshift(Gg(c, U, _)), U = la(c, h), U != null && M.push(Gg(c, U, _))), c = c.return;
    }
    return M;
  }
  function Mc(c) {
    if (c === null) return null;
    do
      c = c.return;
    while (c && c.tag !== 5);
    return c || null;
  }
  function iC(c, h, B, M, _) {
    for (var U = h._reactName, oe = []; B !== null && B !== M; ) {
      var xe = B, Le = xe.alternate, It = xe.stateNode;
      if (Le !== null && Le === M) break;
      xe.tag === 5 && It !== null && (xe = It, _ ? (Le = la(B, U), Le != null && oe.unshift(Gg(B, Le, xe))) : _ || (Le = la(B, U), Le != null && oe.push(Gg(B, Le, xe)))), B = B.return;
    }
    oe.length !== 0 && c.push({ event: h, listeners: oe });
  }
  var Gp = /\r\n?/g, uh = /\u0000|\uFFFD/g;
  function ch(c) {
    return (typeof c == "string" ? c : "" + c).replace(Gp, `
`).replace(uh, "");
  }
  function mI(c, h, B) {
    if (h = ch(h), ch(c) !== h && B) throw Error(t(425));
  }
  function AI() {
  }
  var Su = null, vI = null;
  function Bg(c, h) {
    return c === "textarea" || c === "noscript" || typeof h.children == "string" || typeof h.children == "number" || typeof h.dangerouslySetInnerHTML == "object" && h.dangerouslySetInnerHTML !== null && h.dangerouslySetInnerHTML.__html != null;
  }
  var rC = typeof setTimeout == "function" ? setTimeout : void 0, aC = typeof clearTimeout == "function" ? clearTimeout : void 0, vd = typeof Promise == "function" ? Promise : void 0, ff = typeof queueMicrotask == "function" ? queueMicrotask : typeof vd < "u" ? function(c) {
    return vd.resolve(null).then(c).catch(Zu);
  } : rC;
  function Zu(c) {
    setTimeout(function() {
      throw c;
    });
  }
  function Sg(c, h) {
    var B = h, M = 0;
    do {
      var _ = B.nextSibling;
      if (c.removeChild(B), _ && _.nodeType === 8) if (B = _.data, B === "/$") {
        if (M === 0) {
          c.removeChild(_), pu(h);
          return;
        }
        M--;
      } else B !== "$" && B !== "$?" && B !== "$!" || M++;
      B = _;
    } while (B);
    pu(h);
  }
  function Gl(c) {
    for (; c != null; c = c.nextSibling) {
      var h = c.nodeType;
      if (h === 1 || h === 3) break;
      if (h === 8) {
        if (h = c.data, h === "$" || h === "$!" || h === "$?") break;
        if (h === "/$") return null;
      }
    }
    return c;
  }
  function yI(c) {
    c = c.previousSibling;
    for (var h = 0; c; ) {
      if (c.nodeType === 8) {
        var B = c.data;
        if (B === "$" || B === "$!" || B === "$?") {
          if (h === 0) return c;
          h--;
        } else B === "/$" && h++;
      }
      c = c.previousSibling;
    }
    return null;
  }
  var Zg = Math.random().toString(36).slice(2), ka = "__reactFiber$" + Zg, Hc = "__reactProps$" + Zg, Bl = "__reactContainer$" + Zg, $u = "__reactEvents$" + Zg, wu = "__reactListeners$" + Zg, Bo = "__reactHandles$" + Zg;
  function yd(c) {
    var h = c[ka];
    if (h) return h;
    for (var B = c.parentNode; B; ) {
      if (h = B[Bl] || B[ka]) {
        if (B = h.alternate, h.child !== null || B !== null && B.child !== null) for (c = yI(c); c !== null; ) {
          if (B = c[ka]) return B;
          c = yI(c);
        }
        return h;
      }
      c = B, B = c.parentNode;
    }
    return null;
  }
  function yr(c) {
    return c = c[ka] || c[Bl], !c || c.tag !== 5 && c.tag !== 6 && c.tag !== 13 && c.tag !== 3 ? null : c;
  }
  function Nn(c) {
    if (c.tag === 5 || c.tag === 6) return c.stateNode;
    throw Error(t(33));
  }
  function Ru(c) {
    return c[Hc] || null;
  }
  var xa = [], pi = -1;
  function ea(c) {
    return { current: c };
  }
  function Ur(c) {
    0 > pi || (c.current = xa[pi], xa[pi] = null, pi--);
  }
  function ta(c, h) {
    pi++, xa[pi] = c.current, c.current = h;
  }
  var er = {}, Sa = ea(er), io = ea(!1), Rs = er;
  function $s(c, h) {
    var B = c.type.contextTypes;
    if (!B) return er;
    var M = c.stateNode;
    if (M && M.__reactInternalMemoizedUnmaskedChildContext === h) return M.__reactInternalMemoizedMaskedChildContext;
    var _ = {}, U;
    for (U in B) _[U] = h[U];
    return M && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = h, c.__reactInternalMemoizedMaskedChildContext = _), _;
  }
  function Da(c) {
    return c = c.childContextTypes, c != null;
  }
  function Sl() {
    Ur(io), Ur(Sa);
  }
  function gh(c, h, B) {
    if (Sa.current !== er) throw Error(t(168));
    ta(Sa, h), ta(io, B);
  }
  function oC(c, h, B) {
    var M = c.stateNode;
    if (h = h.childContextTypes, typeof M.getChildContext != "function") return B;
    M = M.getChildContext();
    for (var _ in M) if (!(_ in h)) throw Error(t(108, mt(c) || "Unknown", _));
    return Be({}, B, M);
  }
  function Xc(c) {
    return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || er, Rs = Sa.current, ta(Sa, c), ta(io, io.current), !0;
  }
  function eu(c, h, B) {
    var M = c.stateNode;
    if (!M) throw Error(t(169));
    B ? (c = oC(c, h, Rs), M.__reactInternalMemoizedMergedChildContext = c, Ur(io), Ur(Sa), ta(Sa, c)) : Ur(io), ta(io, B);
  }
  var Fo = null, Yc = !1, xu = !1;
  function tu(c) {
    Fo === null ? Fo = [c] : Fo.push(c);
  }
  function xs(c) {
    Yc = !0, tu(c);
  }
  function Ua() {
    if (!xu && Fo !== null) {
      xu = !0;
      var c = 0, h = sr;
      try {
        var B = Fo;
        for (sr = 1; c < B.length; c++) {
          var M = B[c];
          do
            M = M(!0);
          while (M !== null);
        }
        Fo = null, Yc = !1;
      } catch (_) {
        throw Fo !== null && (Fo = Fo.slice(c + 1)), Ee(rn, Ua), _;
      } finally {
        sr = h, xu = !1;
      }
    }
    return null;
  }
  var Wi = [], Eo = 0, bI = null, GI = 0, So = [], na = 0, ec = null, fn = 1, Zl = "";
  function Fc(c, h) {
    Wi[Eo++] = GI, Wi[Eo++] = bI, bI = c, GI = h;
  }
  function dh(c, h, B) {
    So[na++] = fn, So[na++] = Zl, So[na++] = ec, ec = c;
    var M = fn;
    c = Zl;
    var _ = 32 - Xn(M) - 1;
    M &= ~(1 << _), B += 1;
    var U = 32 - Xn(h) + _;
    if (30 < U) {
      var oe = _ - _ % 5;
      U = (M & (1 << oe) - 1).toString(32), M >>= oe, _ -= oe, fn = 1 << 32 - Xn(h) + _ | B << _ | M, Zl = U + c;
    } else fn = 1 << U | B << _ | M, Zl = c;
  }
  function Bp(c) {
    c.return !== null && (Fc(c, 1), dh(c, 1, 0));
  }
  function tc(c) {
    for (; c === bI; ) bI = Wi[--Eo], Wi[Eo] = null, GI = Wi[--Eo], Wi[Eo] = null;
    for (; c === ec; ) ec = So[--na], So[na] = null, Zl = So[--na], So[na] = null, fn = So[--na], So[na] = null;
  }
  var To = null, Za = null, zr = !1, Ws = null;
  function sC(c, h) {
    var B = kc(5, null, null, 0);
    B.elementType = "DELETED", B.stateNode = h, B.return = c, h = c.deletions, h === null ? (c.deletions = [B], c.flags |= 16) : h.push(B);
  }
  function bd(c, h) {
    switch (c.tag) {
      case 5:
        var B = c.type;
        return h = h.nodeType !== 1 || B.toLowerCase() !== h.nodeName.toLowerCase() ? null : h, h !== null ? (c.stateNode = h, To = c, Za = Gl(h.firstChild), !0) : !1;
      case 6:
        return h = c.pendingProps === "" || h.nodeType !== 3 ? null : h, h !== null ? (c.stateNode = h, To = c, Za = null, !0) : !1;
      case 13:
        return h = h.nodeType !== 8 ? null : h, h !== null ? (B = ec !== null ? { id: fn, overflow: Zl } : null, c.memoizedState = { dehydrated: h, treeContext: B, retryLane: 1073741824 }, B = kc(18, null, null, 0), B.stateNode = h, B.return = c, c.child = B, To = c, Za = null, !0) : !1;
      default:
        return !1;
    }
  }
  function wl(c) {
    return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
  }
  function ro(c) {
    if (zr) {
      var h = Za;
      if (h) {
        var B = h;
        if (!bd(c, h)) {
          if (wl(c)) throw Error(t(418));
          h = Gl(B.nextSibling);
          var M = To;
          h && bd(c, h) ? sC(M, B) : (c.flags = c.flags & -4097 | 2, zr = !1, To = c);
        }
      } else {
        if (wl(c)) throw Error(t(418));
        c.flags = c.flags & -4097 | 2, zr = !1, To = c;
      }
    }
  }
  function pf(c) {
    for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; ) c = c.return;
    To = c;
  }
  function Ya(c) {
    if (c !== To) return !1;
    if (!zr) return pf(c), zr = !0, !1;
    var h;
    if ((h = c.tag !== 3) && !(h = c.tag !== 5) && (h = c.type, h = h !== "head" && h !== "body" && !Bg(c.type, c.memoizedProps)), h && (h = Za)) {
      if (wl(c)) throw Sp(), Error(t(418));
      for (; h; ) sC(c, h), h = Gl(h.nextSibling);
    }
    if (pf(c), c.tag === 13) {
      if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(t(317));
      e: {
        for (c = c.nextSibling, h = 0; c; ) {
          if (c.nodeType === 8) {
            var B = c.data;
            if (B === "/$") {
              if (h === 0) {
                Za = Gl(c.nextSibling);
                break e;
              }
              h--;
            } else B !== "$" && B !== "$!" && B !== "$?" || h++;
          }
          c = c.nextSibling;
        }
        Za = null;
      }
    } else Za = To ? Gl(c.stateNode.nextSibling) : null;
    return !0;
  }
  function Sp() {
    for (var c = Za; c; ) c = Gl(c.nextSibling);
  }
  function Wu() {
    Za = To = null, zr = !1;
  }
  function wg(c) {
    Ws === null ? Ws = [c] : Ws.push(c);
  }
  var Gd = T.ReactCurrentBatchConfig;
  function Ih(c, h, B) {
    if (c = B.ref, c !== null && typeof c != "function" && typeof c != "object") {
      if (B._owner) {
        if (B = B._owner, B) {
          if (B.tag !== 1) throw Error(t(309));
          var M = B.stateNode;
        }
        if (!M) throw Error(t(147, c));
        var _ = M, U = "" + c;
        return h !== null && h.ref !== null && typeof h.ref == "function" && h.ref._stringRef === U ? h.ref : (h = function(oe) {
          var xe = _.refs;
          oe === null ? delete xe[U] : xe[U] = oe;
        }, h._stringRef = U, h);
      }
      if (typeof c != "string") throw Error(t(284));
      if (!B._owner) throw Error(t(290, c));
    }
    return c;
  }
  function BI(c, h) {
    throw c = Object.prototype.toString.call(h), Error(t(31, c === "[object Object]" ? "object with keys {" + Object.keys(h).join(", ") + "}" : c));
  }
  function Zp(c) {
    var h = c._init;
    return h(c._payload);
  }
  function Zo(c) {
    function h(at, Ue) {
      if (c) {
        var lt = at.deletions;
        lt === null ? (at.deletions = [Ue], at.flags |= 16) : lt.push(Ue);
      }
    }
    function B(at, Ue) {
      if (!c) return null;
      for (; Ue !== null; ) h(at, Ue), Ue = Ue.sibling;
      return null;
    }
    function M(at, Ue) {
      for (at = /* @__PURE__ */ new Map(); Ue !== null; ) Ue.key !== null ? at.set(Ue.key, Ue) : at.set(Ue.index, Ue), Ue = Ue.sibling;
      return at;
    }
    function _(at, Ue) {
      return at = SC(at, Ue), at.index = 0, at.sibling = null, at;
    }
    function U(at, Ue, lt) {
      return at.index = lt, c ? (lt = at.alternate, lt !== null ? (lt = lt.index, lt < Ue ? (at.flags |= 2, Ue) : lt) : (at.flags |= 2, Ue)) : (at.flags |= 1048576, Ue);
    }
    function oe(at) {
      return c && at.alternate === null && (at.flags |= 2), at;
    }
    function xe(at, Ue, lt, pn) {
      return Ue === null || Ue.tag !== 6 ? (Ue = Yu(lt, at.mode, pn), Ue.return = at, Ue) : (Ue = _(Ue, lt), Ue.return = at, Ue);
    }
    function Le(at, Ue, lt, pn) {
      var zn = lt.type;
      return zn === L ? Ut(at, Ue, lt.props.children, pn, lt.key) : Ue !== null && (Ue.elementType === zn || typeof zn == "object" && zn !== null && zn.$$typeof === Re && Zp(zn) === Ue.type) ? (pn = _(Ue, lt.props), pn.ref = Ih(at, Ue, lt), pn.return = at, pn) : (pn = Zh(lt.type, lt.key, lt.props, null, at.mode, pn), pn.ref = Ih(at, Ue, lt), pn.return = at, pn);
    }
    function It(at, Ue, lt, pn) {
      return Ue === null || Ue.tag !== 4 || Ue.stateNode.containerInfo !== lt.containerInfo || Ue.stateNode.implementation !== lt.implementation ? (Ue = go(lt, at.mode, pn), Ue.return = at, Ue) : (Ue = _(Ue, lt.children || []), Ue.return = at, Ue);
    }
    function Ut(at, Ue, lt, pn, zn) {
      return Ue === null || Ue.tag !== 7 ? (Ue = ll(lt, at.mode, pn, zn), Ue.return = at, Ue) : (Ue = _(Ue, lt), Ue.return = at, Ue);
    }
    function sn(at, Ue, lt) {
      if (typeof Ue == "string" && Ue !== "" || typeof Ue == "number") return Ue = Yu("" + Ue, at.mode, lt), Ue.return = at, Ue;
      if (typeof Ue == "object" && Ue !== null) {
        switch (Ue.$$typeof) {
          case P:
            return lt = Zh(Ue.type, Ue.key, Ue.props, null, at.mode, lt), lt.ref = Ih(at, null, Ue), lt.return = at, lt;
          case D:
            return Ue = go(Ue, at.mode, lt), Ue.return = at, Ue;
          case Re:
            var pn = Ue._init;
            return sn(at, pn(Ue._payload), lt);
        }
        if (me(Ue) || Se(Ue)) return Ue = ll(Ue, at.mode, lt, null), Ue.return = at, Ue;
        BI(at, Ue);
      }
      return null;
    }
    function qt(at, Ue, lt, pn) {
      var zn = Ue !== null ? Ue.key : null;
      if (typeof lt == "string" && lt !== "" || typeof lt == "number") return zn !== null ? null : xe(at, Ue, "" + lt, pn);
      if (typeof lt == "object" && lt !== null) {
        switch (lt.$$typeof) {
          case P:
            return lt.key === zn ? Le(at, Ue, lt, pn) : null;
          case D:
            return lt.key === zn ? It(at, Ue, lt, pn) : null;
          case Re:
            return zn = lt._init, qt(
              at,
              Ue,
              zn(lt._payload),
              pn
            );
        }
        if (me(lt) || Se(lt)) return zn !== null ? null : Ut(at, Ue, lt, pn, null);
        BI(at, lt);
      }
      return null;
    }
    function kn(at, Ue, lt, pn, zn) {
      if (typeof pn == "string" && pn !== "" || typeof pn == "number") return at = at.get(lt) || null, xe(Ue, at, "" + pn, zn);
      if (typeof pn == "object" && pn !== null) {
        switch (pn.$$typeof) {
          case P:
            return at = at.get(pn.key === null ? lt : pn.key) || null, Le(Ue, at, pn, zn);
          case D:
            return at = at.get(pn.key === null ? lt : pn.key) || null, It(Ue, at, pn, zn);
          case Re:
            var Ci = pn._init;
            return kn(at, Ue, lt, Ci(pn._payload), zn);
        }
        if (me(pn) || Se(pn)) return at = at.get(lt) || null, Ut(Ue, at, pn, zn, null);
        BI(Ue, pn);
      }
      return null;
    }
    function ii(at, Ue, lt, pn) {
      for (var zn = null, Ci = null, vi = Ue, Ei = Ue = 0, Io = null; vi !== null && Ei < lt.length; Ei++) {
        vi.index > Ei ? (Io = vi, vi = null) : Io = vi.sibling;
        var Zr = qt(at, vi, lt[Ei], pn);
        if (Zr === null) {
          vi === null && (vi = Io);
          break;
        }
        c && vi && Zr.alternate === null && h(at, vi), Ue = U(Zr, Ue, Ei), Ci === null ? zn = Zr : Ci.sibling = Zr, Ci = Zr, vi = Io;
      }
      if (Ei === lt.length) return B(at, vi), zr && Fc(at, Ei), zn;
      if (vi === null) {
        for (; Ei < lt.length; Ei++) vi = sn(at, lt[Ei], pn), vi !== null && (Ue = U(vi, Ue, Ei), Ci === null ? zn = vi : Ci.sibling = vi, Ci = vi);
        return zr && Fc(at, Ei), zn;
      }
      for (vi = M(at, vi); Ei < lt.length; Ei++) Io = kn(vi, at, Ei, lt[Ei], pn), Io !== null && (c && Io.alternate !== null && vi.delete(Io.key === null ? Ei : Io.key), Ue = U(Io, Ue, Ei), Ci === null ? zn = Io : Ci.sibling = Io, Ci = Io);
      return c && vi.forEach(function(_g) {
        return h(at, _g);
      }), zr && Fc(at, Ei), zn;
    }
    function oi(at, Ue, lt, pn) {
      var zn = Se(lt);
      if (typeof zn != "function") throw Error(t(150));
      if (lt = zn.call(lt), lt == null) throw Error(t(151));
      for (var Ci = zn = null, vi = Ue, Ei = Ue = 0, Io = null, Zr = lt.next(); vi !== null && !Zr.done; Ei++, Zr = lt.next()) {
        vi.index > Ei ? (Io = vi, vi = null) : Io = vi.sibling;
        var _g = qt(at, vi, Zr.value, pn);
        if (_g === null) {
          vi === null && (vi = Io);
          break;
        }
        c && vi && _g.alternate === null && h(at, vi), Ue = U(_g, Ue, Ei), Ci === null ? zn = _g : Ci.sibling = _g, Ci = _g, vi = Io;
      }
      if (Zr.done) return B(
        at,
        vi
      ), zr && Fc(at, Ei), zn;
      if (vi === null) {
        for (; !Zr.done; Ei++, Zr = lt.next()) Zr = sn(at, Zr.value, pn), Zr !== null && (Ue = U(Zr, Ue, Ei), Ci === null ? zn = Zr : Ci.sibling = Zr, Ci = Zr);
        return zr && Fc(at, Ei), zn;
      }
      for (vi = M(at, vi); !Zr.done; Ei++, Zr = lt.next()) Zr = kn(vi, at, Ei, Zr.value, pn), Zr !== null && (c && Zr.alternate !== null && vi.delete(Zr.key === null ? Ei : Zr.key), Ue = U(Zr, Ue, Ei), Ci === null ? zn = Zr : Ci.sibling = Zr, Ci = Zr);
      return c && vi.forEach(function(Lp) {
        return h(at, Lp);
      }), zr && Fc(at, Ei), zn;
    }
    function ts(at, Ue, lt, pn) {
      if (typeof lt == "object" && lt !== null && lt.type === L && lt.key === null && (lt = lt.props.children), typeof lt == "object" && lt !== null) {
        switch (lt.$$typeof) {
          case P:
            e: {
              for (var zn = lt.key, Ci = Ue; Ci !== null; ) {
                if (Ci.key === zn) {
                  if (zn = lt.type, zn === L) {
                    if (Ci.tag === 7) {
                      B(at, Ci.sibling), Ue = _(Ci, lt.props.children), Ue.return = at, at = Ue;
                      break e;
                    }
                  } else if (Ci.elementType === zn || typeof zn == "object" && zn !== null && zn.$$typeof === Re && Zp(zn) === Ci.type) {
                    B(at, Ci.sibling), Ue = _(Ci, lt.props), Ue.ref = Ih(at, Ci, lt), Ue.return = at, at = Ue;
                    break e;
                  }
                  B(at, Ci);
                  break;
                } else h(at, Ci);
                Ci = Ci.sibling;
              }
              lt.type === L ? (Ue = ll(lt.props.children, at.mode, pn, lt.key), Ue.return = at, at = Ue) : (pn = Zh(lt.type, lt.key, lt.props, null, at.mode, pn), pn.ref = Ih(at, Ue, lt), pn.return = at, at = pn);
            }
            return oe(at);
          case D:
            e: {
              for (Ci = lt.key; Ue !== null; ) {
                if (Ue.key === Ci) if (Ue.tag === 4 && Ue.stateNode.containerInfo === lt.containerInfo && Ue.stateNode.implementation === lt.implementation) {
                  B(at, Ue.sibling), Ue = _(Ue, lt.children || []), Ue.return = at, at = Ue;
                  break e;
                } else {
                  B(at, Ue);
                  break;
                }
                else h(at, Ue);
                Ue = Ue.sibling;
              }
              Ue = go(lt, at.mode, pn), Ue.return = at, at = Ue;
            }
            return oe(at);
          case Re:
            return Ci = lt._init, ts(at, Ue, Ci(lt._payload), pn);
        }
        if (me(lt)) return ii(at, Ue, lt, pn);
        if (Se(lt)) return oi(at, Ue, lt, pn);
        BI(at, lt);
      }
      return typeof lt == "string" && lt !== "" || typeof lt == "number" ? (lt = "" + lt, Ue !== null && Ue.tag === 6 ? (B(at, Ue.sibling), Ue = _(Ue, lt), Ue.return = at, at = Ue) : (B(at, Ue), Ue = Yu(lt, at.mode, pn), Ue.return = at, at = Ue), oe(at)) : B(at, Ue);
    }
    return ts;
  }
  var el = Zo(!0), ao = Zo(!1), yn = ea(null), ss = null, _o = null, lC = null;
  function Vu() {
    lC = _o = ss = null;
  }
  function wo(c) {
    var h = yn.current;
    Ur(yn), c._currentValue = h;
  }
  function Wn(c, h, B) {
    for (; c !== null; ) {
      var M = c.alternate;
      if ((c.childLanes & h) !== h ? (c.childLanes |= h, M !== null && (M.childLanes |= h)) : M !== null && (M.childLanes & h) !== h && (M.childLanes |= h), c === B) break;
      c = c.return;
    }
  }
  function ls(c, h) {
    ss = c, lC = _o = null, c = c.dependencies, c !== null && c.firstContext !== null && ((c.lanes & h) !== 0 && (Yi = !0), c.firstContext = null);
  }
  function tr(c) {
    var h = c._currentValue;
    if (lC !== c) if (c = { context: c, memoizedValue: h, next: null }, _o === null) {
      if (ss === null) throw Error(t(308));
      _o = c, ss.dependencies = { lanes: 0, firstContext: c };
    } else _o = _o.next = c;
    return h;
  }
  var Rg = null;
  function wp(c) {
    Rg === null ? Rg = [c] : Rg.push(c);
  }
  function Ch(c, h, B, M) {
    var _ = h.interleaved;
    return _ === null ? (B.next = B, wp(h)) : (B.next = _.next, _.next = B), h.interleaved = B, Nu(c, M);
  }
  function Nu(c, h) {
    c.lanes |= h;
    var B = c.alternate;
    for (B !== null && (B.lanes |= h), B = c, c = c.return; c !== null; ) c.childLanes |= h, B = c.alternate, B !== null && (B.childLanes |= h), B = c, c = c.return;
    return B.tag === 3 ? B.stateNode : null;
  }
  var Vr = !1;
  function ri(c) {
    c.updateQueue = { baseState: c.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function oo(c, h) {
    c = c.updateQueue, h.updateQueue === c && (h.updateQueue = { baseState: c.baseState, firstBaseUpdate: c.firstBaseUpdate, lastBaseUpdate: c.lastBaseUpdate, shared: c.shared, effects: c.effects });
  }
  function ia(c, h) {
    return { eventTime: c, lane: h, tag: 0, payload: null, callback: null, next: null };
  }
  function Wa(c, h, B) {
    var M = c.updateQueue;
    if (M === null) return null;
    if (M = M.shared, (Qi & 2) !== 0) {
      var _ = M.pending;
      return _ === null ? h.next = h : (h.next = _.next, _.next = h), M.pending = h, Nu(c, B);
    }
    return _ = M.interleaved, _ === null ? (h.next = h, wp(M)) : (h.next = _.next, _.next = h), M.interleaved = h, Nu(c, B);
  }
  function us(c, h, B) {
    if (h = h.updateQueue, h !== null && (h = h.shared, (B & 4194240) !== 0)) {
      var M = h.lanes;
      M &= c.pendingLanes, B |= M, h.lanes = B, Pu(c, B);
    }
  }
  function nc(c, h) {
    var B = c.updateQueue, M = c.alternate;
    if (M !== null && (M = M.updateQueue, B === M)) {
      var _ = null, U = null;
      if (B = B.firstBaseUpdate, B !== null) {
        do {
          var oe = { eventTime: B.eventTime, lane: B.lane, tag: B.tag, payload: B.payload, callback: B.callback, next: null };
          U === null ? _ = U = oe : U = U.next = oe, B = B.next;
        } while (B !== null);
        U === null ? _ = U = h : U = U.next = h;
      } else _ = U = h;
      B = { baseState: M.baseState, firstBaseUpdate: _, lastBaseUpdate: U, shared: M.shared, effects: M.effects }, c.updateQueue = B;
      return;
    }
    c = B.lastBaseUpdate, c === null ? B.firstBaseUpdate = h : c.next = h, B.lastBaseUpdate = h;
  }
  function ua(c, h, B, M) {
    var _ = c.updateQueue;
    Vr = !1;
    var U = _.firstBaseUpdate, oe = _.lastBaseUpdate, xe = _.shared.pending;
    if (xe !== null) {
      _.shared.pending = null;
      var Le = xe, It = Le.next;
      Le.next = null, oe === null ? U = It : oe.next = It, oe = Le;
      var Ut = c.alternate;
      Ut !== null && (Ut = Ut.updateQueue, xe = Ut.lastBaseUpdate, xe !== oe && (xe === null ? Ut.firstBaseUpdate = It : xe.next = It, Ut.lastBaseUpdate = Le));
    }
    if (U !== null) {
      var sn = _.baseState;
      oe = 0, Ut = It = Le = null, xe = U;
      do {
        var qt = xe.lane, kn = xe.eventTime;
        if ((M & qt) === qt) {
          Ut !== null && (Ut = Ut.next = {
            eventTime: kn,
            lane: 0,
            tag: xe.tag,
            payload: xe.payload,
            callback: xe.callback,
            next: null
          });
          e: {
            var ii = c, oi = xe;
            switch (qt = h, kn = B, oi.tag) {
              case 1:
                if (ii = oi.payload, typeof ii == "function") {
                  sn = ii.call(kn, sn, qt);
                  break e;
                }
                sn = ii;
                break e;
              case 3:
                ii.flags = ii.flags & -65537 | 128;
              case 0:
                if (ii = oi.payload, qt = typeof ii == "function" ? ii.call(kn, sn, qt) : ii, qt == null) break e;
                sn = Be({}, sn, qt);
                break e;
              case 2:
                Vr = !0;
            }
          }
          xe.callback !== null && xe.lane !== 0 && (c.flags |= 64, qt = _.effects, qt === null ? _.effects = [xe] : qt.push(xe));
        } else kn = { eventTime: kn, lane: qt, tag: xe.tag, payload: xe.payload, callback: xe.callback, next: null }, Ut === null ? (It = Ut = kn, Le = sn) : Ut = Ut.next = kn, oe |= qt;
        if (xe = xe.next, xe === null) {
          if (xe = _.shared.pending, xe === null) break;
          qt = xe, xe = qt.next, qt.next = null, _.lastBaseUpdate = qt, _.shared.pending = null;
        }
      } while (!0);
      if (Ut === null && (Le = sn), _.baseState = Le, _.firstBaseUpdate = It, _.lastBaseUpdate = Ut, h = _.shared.interleaved, h !== null) {
        _ = h;
        do
          oe |= _.lane, _ = _.next;
        while (_ !== h);
      } else U === null && (_.shared.lanes = 0);
      NI |= oe, c.lanes = oe, c.memoizedState = sn;
    }
  }
  function SI(c, h, B) {
    if (c = h.effects, h.effects = null, c !== null) for (h = 0; h < c.length; h++) {
      var M = c[h], _ = M.callback;
      if (_ !== null) {
        if (M.callback = null, M = B, typeof _ != "function") throw Error(t(191, _));
        _.call(M);
      }
    }
  }
  var ic = {}, nu = ea(ic), ZI = ea(ic), xg = ea(ic);
  function Ro(c) {
    if (c === ic) throw Error(t(174));
    return c;
  }
  function uC(c, h) {
    switch (ta(xg, h), ta(ZI, c), ta(nu, ic), c = h.nodeType, c) {
      case 9:
      case 11:
        h = (h = h.documentElement) ? h.namespaceURI : jt(null, "");
        break;
      default:
        c = c === 8 ? h.parentNode : h, h = c.namespaceURI || null, c = c.tagName, h = jt(h, c);
    }
    Ur(nu), ta(nu, h);
  }
  function Wg() {
    Ur(nu), Ur(ZI), Ur(xg);
  }
  function Bd(c) {
    Ro(xg.current);
    var h = Ro(nu.current), B = jt(h, c.type);
    h !== B && (ta(ZI, c), ta(nu, B));
  }
  function cC(c) {
    ZI.current === c && (Ur(nu), Ur(ZI));
  }
  var pa = ea(0);
  function rc(c) {
    for (var h = c; h !== null; ) {
      if (h.tag === 13) {
        var B = h.memoizedState;
        if (B !== null && (B = B.dehydrated, B === null || B.data === "$?" || B.data === "$!")) return h;
      } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
        if ((h.flags & 128) !== 0) return h;
      } else if (h.child !== null) {
        h.child.return = h, h = h.child;
        continue;
      }
      if (h === c) break;
      for (; h.sibling === null; ) {
        if (h.return === null || h.return === c) return null;
        h = h.return;
      }
      h.sibling.return = h.return, h = h.sibling;
    }
    return null;
  }
  var gC = [];
  function Mu() {
    for (var c = 0; c < gC.length; c++) gC[c]._workInProgressVersionPrimary = null;
    gC.length = 0;
  }
  var si = T.ReactCurrentDispatcher, Oi = T.ReactCurrentBatchConfig, ir = 0, Xi = null, Xr = null, fr = null, ac = !1, ca = !1, Vs = 0, jo = 0;
  function Ht() {
    throw Error(t(321));
  }
  function Fa(c, h) {
    if (h === null) return !1;
    for (var B = 0; B < h.length && B < c.length; B++) if (!Dr(c[B], h[B])) return !1;
    return !0;
  }
  function Ai(c, h, B, M, _, U) {
    if (ir = U, Xi = h, h.memoizedState = null, h.updateQueue = null, h.lanes = 0, si.current = c === null || c.memoizedState === null ? Yg : xd, c = B(M, _), ca) {
      U = 0;
      do {
        if (ca = !1, Vs = 0, 25 <= U) throw Error(t(301));
        U += 1, fr = Xr = null, h.updateQueue = null, si.current = lc, c = B(M, _);
      } while (ca);
    }
    if (si.current = Nr, h = Xr !== null && Xr.next !== null, ir = 0, fr = Xr = Xi = null, ac = !1, h) throw Error(t(300));
    return c;
  }
  function Vg() {
    var c = Vs !== 0;
    return Vs = 0, c;
  }
  function br() {
    var c = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return fr === null ? Xi.memoizedState = fr = c : fr = fr.next = c, fr;
  }
  function xo() {
    if (Xr === null) {
      var c = Xi.alternate;
      c = c !== null ? c.memoizedState : null;
    } else c = Xr.next;
    var h = fr === null ? Xi.memoizedState : fr.next;
    if (h !== null) fr = h, Xr = c;
    else {
      if (c === null) throw Error(t(310));
      Xr = c, c = { memoizedState: Xr.memoizedState, baseState: Xr.baseState, baseQueue: Xr.baseQueue, queue: Xr.queue, next: null }, fr === null ? Xi.memoizedState = fr = c : fr = fr.next = c;
    }
    return fr;
  }
  function tl(c, h) {
    return typeof h == "function" ? h(c) : h;
  }
  function Ng(c) {
    var h = xo(), B = h.queue;
    if (B === null) throw Error(t(311));
    B.lastRenderedReducer = c;
    var M = Xr, _ = M.baseQueue, U = B.pending;
    if (U !== null) {
      if (_ !== null) {
        var oe = _.next;
        _.next = U.next, U.next = oe;
      }
      M.baseQueue = _ = U, B.pending = null;
    }
    if (_ !== null) {
      U = _.next, M = M.baseState;
      var xe = oe = null, Le = null, It = U;
      do {
        var Ut = It.lane;
        if ((ir & Ut) === Ut) Le !== null && (Le = Le.next = { lane: 0, action: It.action, hasEagerState: It.hasEagerState, eagerState: It.eagerState, next: null }), M = It.hasEagerState ? It.eagerState : c(M, It.action);
        else {
          var sn = {
            lane: Ut,
            action: It.action,
            hasEagerState: It.hasEagerState,
            eagerState: It.eagerState,
            next: null
          };
          Le === null ? (xe = Le = sn, oe = M) : Le = Le.next = sn, Xi.lanes |= Ut, NI |= Ut;
        }
        It = It.next;
      } while (It !== null && It !== U);
      Le === null ? oe = M : Le.next = xe, Dr(M, h.memoizedState) || (Yi = !0), h.memoizedState = M, h.baseState = oe, h.baseQueue = Le, B.lastRenderedState = M;
    }
    if (c = B.interleaved, c !== null) {
      _ = c;
      do
        U = _.lane, Xi.lanes |= U, NI |= U, _ = _.next;
      while (_ !== c);
    } else _ === null && (B.lanes = 0);
    return [h.memoizedState, B.dispatch];
  }
  function Rl(c) {
    var h = xo(), B = h.queue;
    if (B === null) throw Error(t(311));
    B.lastRenderedReducer = c;
    var M = B.dispatch, _ = B.pending, U = h.memoizedState;
    if (_ !== null) {
      B.pending = null;
      var oe = _ = _.next;
      do
        U = c(U, oe.action), oe = oe.next;
      while (oe !== _);
      Dr(U, h.memoizedState) || (Yi = !0), h.memoizedState = U, h.baseQueue === null && (h.baseState = U), B.lastRenderedState = U;
    }
    return [U, M];
  }
  function Ec() {
  }
  function hh(c, h) {
    var B = Xi, M = xo(), _ = h(), U = !Dr(M.memoizedState, _);
    if (U && (M.memoizedState = _, Yi = !0), M = M.queue, oc(nl.bind(null, B, M, c), [c]), M.getSnapshot !== h || U || fr !== null && fr.memoizedState.tag & 1) {
      if (B.flags |= 2048, ra(9, Sd.bind(null, B, M, _, h), void 0, null), wa === null) throw Error(t(349));
      (ir & 30) !== 0 || wI(B, h, _);
    }
    return _;
  }
  function wI(c, h, B) {
    c.flags |= 16384, c = { getSnapshot: h, value: B }, h = Xi.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, Xi.updateQueue = h, h.stores = [c]) : (B = h.stores, B === null ? h.stores = [c] : B.push(c));
  }
  function Sd(c, h, B, M) {
    h.value = B, h.getSnapshot = M, Zd(h) && fh(c);
  }
  function nl(c, h, B) {
    return B(function() {
      Zd(h) && fh(c);
    });
  }
  function Zd(c) {
    var h = c.getSnapshot;
    c = c.value;
    try {
      var B = h();
      return !Dr(c, B);
    } catch {
      return !0;
    }
  }
  function fh(c) {
    var h = Nu(c, 1);
    h !== null && au(h, c, 1, -1);
  }
  function ph(c) {
    var h = br();
    return typeof c == "function" && (c = c()), h.memoizedState = h.baseState = c, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: tl, lastRenderedState: c }, h.queue = c, c = c.dispatch = iu.bind(null, Xi, c), [h.memoizedState, c];
  }
  function ra(c, h, B, M) {
    return c = { tag: c, create: h, destroy: B, deps: M, next: null }, h = Xi.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, Xi.updateQueue = h, h.lastEffect = c.next = c) : (B = h.lastEffect, B === null ? h.lastEffect = c.next = c : (M = B.next, B.next = c, c.next = M, h.lastEffect = c)), c;
  }
  function so() {
    return xo().memoizedState;
  }
  function lo(c, h, B, M) {
    var _ = br();
    Xi.flags |= c, _.memoizedState = ra(1 | h, B, void 0, M === void 0 ? null : M);
  }
  function cs(c, h, B, M) {
    var _ = xo();
    M = M === void 0 ? null : M;
    var U = void 0;
    if (Xr !== null) {
      var oe = Xr.memoizedState;
      if (U = oe.destroy, M !== null && Fa(M, oe.deps)) {
        _.memoizedState = ra(h, B, U, M);
        return;
      }
    }
    Xi.flags |= c, _.memoizedState = ra(1 | h, B, U, M);
  }
  function gs(c, h) {
    return lo(8390656, 8, c, h);
  }
  function oc(c, h) {
    return cs(2048, 8, c, h);
  }
  function Mg(c, h) {
    return cs(4, 2, c, h);
  }
  function wd(c, h) {
    return cs(4, 4, c, h);
  }
  function Hg(c, h) {
    if (typeof h == "function") return c = c(), h(c), function() {
      h(null);
    };
    if (h != null) return c = c(), h.current = c, function() {
      h.current = null;
    };
  }
  function Hu(c, h, B) {
    return B = B != null ? B.concat([c]) : null, cs(4, 4, Hg.bind(null, h, c), B);
  }
  function Tc() {
  }
  function Rd(c, h) {
    var B = xo();
    h = h === void 0 ? null : h;
    var M = B.memoizedState;
    return M !== null && h !== null && Fa(h, M[1]) ? M[0] : (B.memoizedState = [c, h], c);
  }
  function uo(c, h) {
    var B = xo();
    h = h === void 0 ? null : h;
    var M = B.memoizedState;
    return M !== null && h !== null && Fa(h, M[1]) ? M[0] : (c = c(), B.memoizedState = [c, h], c);
  }
  function Xg(c, h, B) {
    return (ir & 21) === 0 ? (c.baseState && (c.baseState = !1, Yi = !0), c.memoizedState = B) : (Dr(B, h) || (B = Ao(), Xi.lanes |= B, NI |= B, c.baseState = !0), h);
  }
  function Rp(c, h) {
    var B = sr;
    sr = B !== 0 && 4 > B ? B : 4, c(!0);
    var M = Oi.transition;
    Oi.transition = {};
    try {
      c(!1), h();
    } finally {
      sr = B, Oi.transition = M;
    }
  }
  function xl() {
    return xo().memoizedState;
  }
  function dC(c, h, B) {
    var M = ru(c);
    if (B = { lane: M, action: B, hasEagerState: !1, eagerState: null, next: null }, sc(c)) il(h, B);
    else if (B = Ch(c, h, B, M), B !== null) {
      var _ = da();
      au(B, c, M, _), Wl(B, h, M);
    }
  }
  function iu(c, h, B) {
    var M = ru(c), _ = { lane: M, action: B, hasEagerState: !1, eagerState: null, next: null };
    if (sc(c)) il(h, _);
    else {
      var U = c.alternate;
      if (c.lanes === 0 && (U === null || U.lanes === 0) && (U = h.lastRenderedReducer, U !== null)) try {
        var oe = h.lastRenderedState, xe = U(oe, B);
        if (_.hasEagerState = !0, _.eagerState = xe, Dr(xe, oe)) {
          var Le = h.interleaved;
          Le === null ? (_.next = _, wp(h)) : (_.next = Le.next, Le.next = _), h.interleaved = _;
          return;
        }
      } catch {
      } finally {
      }
      B = Ch(c, h, _, M), B !== null && (_ = da(), au(B, c, M, _), Wl(B, h, M));
    }
  }
  function sc(c) {
    var h = c.alternate;
    return c === Xi || h !== null && h === Xi;
  }
  function il(c, h) {
    ca = ac = !0;
    var B = c.pending;
    B === null ? h.next = h : (h.next = B.next, B.next = h), c.pending = h;
  }
  function Wl(c, h, B) {
    if ((B & 4194240) !== 0) {
      var M = h.lanes;
      M &= c.pendingLanes, B |= M, h.lanes = B, Pu(c, B);
    }
  }
  var Nr = { readContext: tr, useCallback: Ht, useContext: Ht, useEffect: Ht, useImperativeHandle: Ht, useInsertionEffect: Ht, useLayoutEffect: Ht, useMemo: Ht, useReducer: Ht, useRef: Ht, useState: Ht, useDebugValue: Ht, useDeferredValue: Ht, useTransition: Ht, useMutableSource: Ht, useSyncExternalStore: Ht, useId: Ht, unstable_isNewReconciler: !1 }, Yg = { readContext: tr, useCallback: function(c, h) {
    return br().memoizedState = [c, h === void 0 ? null : h], c;
  }, useContext: tr, useEffect: gs, useImperativeHandle: function(c, h, B) {
    return B = B != null ? B.concat([c]) : null, lo(
      4194308,
      4,
      Hg.bind(null, h, c),
      B
    );
  }, useLayoutEffect: function(c, h) {
    return lo(4194308, 4, c, h);
  }, useInsertionEffect: function(c, h) {
    return lo(4, 2, c, h);
  }, useMemo: function(c, h) {
    var B = br();
    return h = h === void 0 ? null : h, c = c(), B.memoizedState = [c, h], c;
  }, useReducer: function(c, h, B) {
    var M = br();
    return h = B !== void 0 ? B(h) : h, M.memoizedState = M.baseState = h, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: c, lastRenderedState: h }, M.queue = c, c = c.dispatch = dC.bind(null, Xi, c), [M.memoizedState, c];
  }, useRef: function(c) {
    var h = br();
    return c = { current: c }, h.memoizedState = c;
  }, useState: ph, useDebugValue: Tc, useDeferredValue: function(c) {
    return br().memoizedState = c;
  }, useTransition: function() {
    var c = ph(!1), h = c[0];
    return c = Rp.bind(null, c[1]), br().memoizedState = c, [h, c];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(c, h, B) {
    var M = Xi, _ = br();
    if (zr) {
      if (B === void 0) throw Error(t(407));
      B = B();
    } else {
      if (B = h(), wa === null) throw Error(t(349));
      (ir & 30) !== 0 || wI(M, h, B);
    }
    _.memoizedState = B;
    var U = { value: B, getSnapshot: h };
    return _.queue = U, gs(nl.bind(
      null,
      M,
      U,
      c
    ), [c]), M.flags |= 2048, ra(9, Sd.bind(null, M, U, B, h), void 0, null), B;
  }, useId: function() {
    var c = br(), h = wa.identifierPrefix;
    if (zr) {
      var B = Zl, M = fn;
      B = (M & ~(1 << 32 - Xn(M) - 1)).toString(32) + B, h = ":" + h + "R" + B, B = Vs++, 0 < B && (h += "H" + B.toString(32)), h += ":";
    } else B = jo++, h = ":" + h + "r" + B.toString(32) + ":";
    return c.memoizedState = h;
  }, unstable_isNewReconciler: !1 }, xd = {
    readContext: tr,
    useCallback: Rd,
    useContext: tr,
    useEffect: oc,
    useImperativeHandle: Hu,
    useInsertionEffect: Mg,
    useLayoutEffect: wd,
    useMemo: uo,
    useReducer: Ng,
    useRef: so,
    useState: function() {
      return Ng(tl);
    },
    useDebugValue: Tc,
    useDeferredValue: function(c) {
      var h = xo();
      return Xg(h, Xr.memoizedState, c);
    },
    useTransition: function() {
      var c = Ng(tl)[0], h = xo().memoizedState;
      return [c, h];
    },
    useMutableSource: Ec,
    useSyncExternalStore: hh,
    useId: xl,
    unstable_isNewReconciler: !1
  }, lc = { readContext: tr, useCallback: Rd, useContext: tr, useEffect: oc, useImperativeHandle: Hu, useInsertionEffect: Mg, useLayoutEffect: wd, useMemo: uo, useReducer: Rl, useRef: so, useState: function() {
    return Rl(tl);
  }, useDebugValue: Tc, useDeferredValue: function(c) {
    var h = xo();
    return Xr === null ? h.memoizedState = c : Xg(h, Xr.memoizedState, c);
  }, useTransition: function() {
    var c = Rl(tl)[0], h = xo().memoizedState;
    return [c, h];
  }, useMutableSource: Ec, useSyncExternalStore: hh, useId: xl, unstable_isNewReconciler: !1 };
  function ds(c, h) {
    if (c && c.defaultProps) {
      h = Be({}, h), c = c.defaultProps;
      for (var B in c) h[B] === void 0 && (h[B] = c[B]);
      return h;
    }
    return h;
  }
  function Wd(c, h, B, M) {
    h = c.memoizedState, B = B(M, h), B = B == null ? h : Be({}, h, B), c.memoizedState = B, c.lanes === 0 && (c.updateQueue.baseState = B);
  }
  var RI = { isMounted: function(c) {
    return (c = c._reactInternals) ? Gt(c) === c : !1;
  }, enqueueSetState: function(c, h, B) {
    c = c._reactInternals;
    var M = da(), _ = ru(c), U = ia(M, _);
    U.payload = h, B != null && (U.callback = B), h = Wa(c, U, _), h !== null && (au(h, c, _, M), us(h, c, _));
  }, enqueueReplaceState: function(c, h, B) {
    c = c._reactInternals;
    var M = da(), _ = ru(c), U = ia(M, _);
    U.tag = 1, U.payload = h, B != null && (U.callback = B), h = Wa(c, U, _), h !== null && (au(h, c, _, M), us(h, c, _));
  }, enqueueForceUpdate: function(c, h) {
    c = c._reactInternals;
    var B = da(), M = ru(c), _ = ia(B, M);
    _.tag = 2, h != null && (_.callback = h), h = Wa(c, _, M), h !== null && (au(h, c, M, B), us(h, c, M));
  } };
  function xp(c, h, B, M, _, U, oe) {
    return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(M, U, oe) : h.prototype && h.prototype.isPureReactComponent ? !yg(B, M) || !yg(_, U) : !0;
  }
  function m(c, h, B) {
    var M = !1, _ = er, U = h.contextType;
    return typeof U == "object" && U !== null ? U = tr(U) : (_ = Da(h) ? Rs : Sa.current, M = h.contextTypes, U = (M = M != null) ? $s(c, _) : er), h = new h(B, U), c.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, h.updater = RI, c.stateNode = h, h._reactInternals = c, M && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = _, c.__reactInternalMemoizedMaskedChildContext = U), h;
  }
  function A(c, h, B, M) {
    c = h.state, typeof h.componentWillReceiveProps == "function" && h.componentWillReceiveProps(B, M), typeof h.UNSAFE_componentWillReceiveProps == "function" && h.UNSAFE_componentWillReceiveProps(B, M), h.state !== c && RI.enqueueReplaceState(h, h.state, null);
  }
  function V(c, h, B, M) {
    var _ = c.stateNode;
    _.props = B, _.state = c.memoizedState, _.refs = {}, ri(c);
    var U = h.contextType;
    typeof U == "object" && U !== null ? _.context = tr(U) : (U = Da(h) ? Rs : Sa.current, _.context = $s(c, U)), _.state = c.memoizedState, U = h.getDerivedStateFromProps, typeof U == "function" && (Wd(c, h, U, B), _.state = c.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof _.getSnapshotBeforeUpdate == "function" || typeof _.UNSAFE_componentWillMount != "function" && typeof _.componentWillMount != "function" || (h = _.state, typeof _.componentWillMount == "function" && _.componentWillMount(), typeof _.UNSAFE_componentWillMount == "function" && _.UNSAFE_componentWillMount(), h !== _.state && RI.enqueueReplaceState(_, _.state, null), ua(c, B, _, M), _.state = c.memoizedState), typeof _.componentDidMount == "function" && (c.flags |= 4194308);
  }
  function E(c, h) {
    try {
      var B = "", M = h;
      do
        B += Je(M), M = M.return;
      while (M);
      var _ = B;
    } catch (U) {
      _ = `
Error generating stack: ` + U.message + `
` + U.stack;
    }
    return { value: c, source: h, stack: _, digest: null };
  }
  function k(c, h, B) {
    return { value: c, source: null, stack: B ?? null, digest: h ?? null };
  }
  function $(c, h) {
    try {
      console.error(h.value);
    } catch (B) {
      setTimeout(function() {
        throw B;
      });
    }
  }
  var ve = typeof WeakMap == "function" ? WeakMap : Map;
  function Ke(c, h, B) {
    B = ia(-1, B), B.tag = 3, B.payload = { element: null };
    var M = h.value;
    return B.callback = function() {
      vC || (vC = !0, Fp = M), $(c, h);
    }, B;
  }
  function Rt(c, h, B) {
    B = ia(-1, B), B.tag = 3;
    var M = c.type.getDerivedStateFromError;
    if (typeof M == "function") {
      var _ = h.value;
      B.payload = function() {
        return M(_);
      }, B.callback = function() {
        $(c, h);
      };
    }
    var U = c.stateNode;
    return U !== null && typeof U.componentDidCatch == "function" && (B.callback = function() {
      $(c, h), typeof M != "function" && (gc === null ? gc = /* @__PURE__ */ new Set([this]) : gc.add(this));
      var oe = h.stack;
      this.componentDidCatch(h.value, { componentStack: oe !== null ? oe : "" });
    }), B;
  }
  function In(c, h, B) {
    var M = c.pingCache;
    if (M === null) {
      M = c.pingCache = new ve();
      var _ = /* @__PURE__ */ new Set();
      M.set(h, _);
    } else _ = M.get(h), _ === void 0 && (_ = /* @__PURE__ */ new Set(), M.set(h, _));
    _.has(B) || (_.add(B), c = IA.bind(null, c, h, B), h.then(c, c));
  }
  function $n(c) {
    do {
      var h;
      if ((h = c.tag === 13) && (h = c.memoizedState, h = h !== null ? h.dehydrated !== null : !0), h) return c;
      c = c.return;
    } while (c !== null);
    return null;
  }
  function zi(c, h, B, M, _) {
    return (c.mode & 1) === 0 ? (c === h ? c.flags |= 65536 : (c.flags |= 128, B.flags |= 131072, B.flags &= -52805, B.tag === 1 && (B.alternate === null ? B.tag = 17 : (h = ia(-1, 1), h.tag = 2, Wa(B, h, 1))), B.lanes |= 1), c) : (c.flags |= 65536, c.lanes = _, c);
  }
  var ci = T.ReactCurrentOwner, Yi = !1;
  function wn(c, h, B, M) {
    h.child = c === null ? ao(h, null, B, M) : el(h, c.child, B, M);
  }
  function Oa(c, h, B, M, _) {
    B = B.render;
    var U = h.ref;
    return ls(h, _), M = Ai(c, h, B, M, U, _), B = Vg(), c !== null && !Yi ? (h.updateQueue = c.updateQueue, h.flags &= -2053, c.lanes &= ~_, Is(c, h, _)) : (zr && B && Bp(h), h.flags |= 1, wn(c, h, M, _), h.child);
  }
  function ga(c, h, B, M, _) {
    if (c === null) {
      var U = B.type;
      return typeof U == "function" && !Md(U) && U.defaultProps === void 0 && B.compare === null && B.defaultProps === void 0 ? (h.tag = 15, h.type = U, ot(c, h, U, M, _)) : (c = Zh(B.type, null, M, h, h.mode, _), c.ref = h.ref, c.return = h, h.child = c);
    }
    if (U = c.child, (c.lanes & _) === 0) {
      var oe = U.memoizedProps;
      if (B = B.compare, B = B !== null ? B : yg, B(oe, M) && c.ref === h.ref) return Is(c, h, _);
    }
    return h.flags |= 1, c = SC(U, M), c.ref = h.ref, c.return = h, h.child = c;
  }
  function ot(c, h, B, M, _) {
    if (c !== null) {
      var U = c.memoizedProps;
      if (yg(U, M) && c.ref === h.ref) if (Yi = !1, h.pendingProps = M = U, (c.lanes & _) !== 0) (c.flags & 131072) !== 0 && (Yi = !0);
      else return h.lanes = c.lanes, Is(c, h, _);
    }
    return Sn(c, h, B, M, _);
  }
  function Fe(c, h, B) {
    var M = h.pendingProps, _ = M.children, U = c !== null ? c.memoizedState : null;
    if (M.mode === "hidden") if ((h.mode & 1) === 0) h.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ta(yf, cc), cc |= B;
    else {
      if ((B & 1073741824) === 0) return c = U !== null ? U.baseLanes | B : B, h.lanes = h.childLanes = 1073741824, h.memoizedState = { baseLanes: c, cachePool: null, transitions: null }, h.updateQueue = null, ta(yf, cc), cc |= c, null;
      h.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, M = U !== null ? U.baseLanes : B, ta(yf, cc), cc |= M;
    }
    else U !== null ? (M = U.baseLanes | B, h.memoizedState = null) : M = B, ta(yf, cc), cc |= M;
    return wn(c, h, _, B), h.child;
  }
  function bt(c, h) {
    var B = h.ref;
    (c === null && B !== null || c !== null && c.ref !== B) && (h.flags |= 512, h.flags |= 2097152);
  }
  function Sn(c, h, B, M, _) {
    var U = Da(B) ? Rs : Sa.current;
    return U = $s(h, U), ls(h, _), B = Ai(c, h, B, M, U, _), M = Vg(), c !== null && !Yi ? (h.updateQueue = c.updateQueue, h.flags &= -2053, c.lanes &= ~_, Is(c, h, _)) : (zr && M && Bp(h), h.flags |= 1, wn(c, h, B, _), h.child);
  }
  function ei(c, h, B, M, _) {
    if (Da(B)) {
      var U = !0;
      Xc(h);
    } else U = !1;
    if (ls(h, _), h.stateNode === null) Xu(c, h), m(h, B, M), V(h, B, M, _), M = !0;
    else if (c === null) {
      var oe = h.stateNode, xe = h.memoizedProps;
      oe.props = xe;
      var Le = oe.context, It = B.contextType;
      typeof It == "object" && It !== null ? It = tr(It) : (It = Da(B) ? Rs : Sa.current, It = $s(h, It));
      var Ut = B.getDerivedStateFromProps, sn = typeof Ut == "function" || typeof oe.getSnapshotBeforeUpdate == "function";
      sn || typeof oe.UNSAFE_componentWillReceiveProps != "function" && typeof oe.componentWillReceiveProps != "function" || (xe !== M || Le !== It) && A(h, oe, M, It), Vr = !1;
      var qt = h.memoizedState;
      oe.state = qt, ua(h, M, oe, _), Le = h.memoizedState, xe !== M || qt !== Le || io.current || Vr ? (typeof Ut == "function" && (Wd(h, B, Ut, M), Le = h.memoizedState), (xe = Vr || xp(h, B, xe, M, qt, Le, It)) ? (sn || typeof oe.UNSAFE_componentWillMount != "function" && typeof oe.componentWillMount != "function" || (typeof oe.componentWillMount == "function" && oe.componentWillMount(), typeof oe.UNSAFE_componentWillMount == "function" && oe.UNSAFE_componentWillMount()), typeof oe.componentDidMount == "function" && (h.flags |= 4194308)) : (typeof oe.componentDidMount == "function" && (h.flags |= 4194308), h.memoizedProps = M, h.memoizedState = Le), oe.props = M, oe.state = Le, oe.context = It, M = xe) : (typeof oe.componentDidMount == "function" && (h.flags |= 4194308), M = !1);
    } else {
      oe = h.stateNode, oo(c, h), xe = h.memoizedProps, It = h.type === h.elementType ? xe : ds(h.type, xe), oe.props = It, sn = h.pendingProps, qt = oe.context, Le = B.contextType, typeof Le == "object" && Le !== null ? Le = tr(Le) : (Le = Da(B) ? Rs : Sa.current, Le = $s(h, Le));
      var kn = B.getDerivedStateFromProps;
      (Ut = typeof kn == "function" || typeof oe.getSnapshotBeforeUpdate == "function") || typeof oe.UNSAFE_componentWillReceiveProps != "function" && typeof oe.componentWillReceiveProps != "function" || (xe !== sn || qt !== Le) && A(h, oe, M, Le), Vr = !1, qt = h.memoizedState, oe.state = qt, ua(h, M, oe, _);
      var ii = h.memoizedState;
      xe !== sn || qt !== ii || io.current || Vr ? (typeof kn == "function" && (Wd(h, B, kn, M), ii = h.memoizedState), (It = Vr || xp(h, B, It, M, qt, ii, Le) || !1) ? (Ut || typeof oe.UNSAFE_componentWillUpdate != "function" && typeof oe.componentWillUpdate != "function" || (typeof oe.componentWillUpdate == "function" && oe.componentWillUpdate(M, ii, Le), typeof oe.UNSAFE_componentWillUpdate == "function" && oe.UNSAFE_componentWillUpdate(M, ii, Le)), typeof oe.componentDidUpdate == "function" && (h.flags |= 4), typeof oe.getSnapshotBeforeUpdate == "function" && (h.flags |= 1024)) : (typeof oe.componentDidUpdate != "function" || xe === c.memoizedProps && qt === c.memoizedState || (h.flags |= 4), typeof oe.getSnapshotBeforeUpdate != "function" || xe === c.memoizedProps && qt === c.memoizedState || (h.flags |= 1024), h.memoizedProps = M, h.memoizedState = ii), oe.props = M, oe.state = ii, oe.context = Le, M = It) : (typeof oe.componentDidUpdate != "function" || xe === c.memoizedProps && qt === c.memoizedState || (h.flags |= 4), typeof oe.getSnapshotBeforeUpdate != "function" || xe === c.memoizedProps && qt === c.memoizedState || (h.flags |= 1024), M = !1);
    }
    return Ki(c, h, B, M, U, _);
  }
  function Ki(c, h, B, M, _, U) {
    bt(c, h);
    var oe = (h.flags & 128) !== 0;
    if (!M && !oe) return _ && eu(h, B, !1), Is(c, h, U);
    M = h.stateNode, ci.current = h;
    var xe = oe && typeof B.getDerivedStateFromError != "function" ? null : M.render();
    return h.flags |= 1, c !== null && oe ? (h.child = el(h, c.child, null, U), h.child = el(h, null, xe, U)) : wn(c, h, xe, U), h.memoizedState = M.state, _ && eu(h, B, !0), h.child;
  }
  function Vi(c) {
    var h = c.stateNode;
    h.pendingContext ? gh(c, h.pendingContext, h.pendingContext !== h.context) : h.context && gh(c, h.context, !1), uC(c, h.containerInfo);
  }
  function cr(c, h, B, M, _) {
    return Wu(), wg(_), h.flags |= 256, wn(c, h, B, M), h.child;
  }
  var Ea = { dehydrated: null, treeContext: null, retryLane: 0 };
  function pr(c) {
    return { baseLanes: c, cachePool: null, transitions: null };
  }
  function _c(c, h, B) {
    var M = h.pendingProps, _ = pa.current, U = !1, oe = (h.flags & 128) !== 0, xe;
    if ((xe = oe) || (xe = c !== null && c.memoizedState === null ? !1 : (_ & 2) !== 0), xe ? (U = !0, h.flags &= -129) : (c === null || c.memoizedState !== null) && (_ |= 1), ta(pa, _ & 1), c === null)
      return ro(h), c = h.memoizedState, c !== null && (c = c.dehydrated, c !== null) ? ((h.mode & 1) === 0 ? h.lanes = 1 : c.data === "$!" ? h.lanes = 8 : h.lanes = 1073741824, null) : (oe = M.children, c = M.fallback, U ? (M = h.mode, U = h.child, oe = { mode: "hidden", children: oe }, (M & 1) === 0 && U !== null ? (U.childLanes = 0, U.pendingProps = oe) : U = ma(oe, M, 0, null), c = ll(c, M, B, null), U.return = h, c.return = h, U.sibling = c, h.child = U, h.child.memoizedState = pr(B), h.memoizedState = Ea, c) : Vd(h, oe));
    if (_ = c.memoizedState, _ !== null && (xe = _.dehydrated, xe !== null)) return tA(c, h, oe, M, xe, _, B);
    if (U) {
      U = M.fallback, oe = h.mode, _ = c.child, xe = _.sibling;
      var Le = { mode: "hidden", children: M.children };
      return (oe & 1) === 0 && h.child !== _ ? (M = h.child, M.childLanes = 0, M.pendingProps = Le, h.deletions = null) : (M = SC(_, Le), M.subtreeFlags = _.subtreeFlags & 14680064), xe !== null ? U = SC(xe, U) : (U = ll(U, oe, B, null), U.flags |= 2), U.return = h, M.return = h, M.sibling = U, h.child = M, M = U, U = h.child, oe = c.child.memoizedState, oe = oe === null ? pr(B) : { baseLanes: oe.baseLanes | B, cachePool: null, transitions: oe.transitions }, U.memoizedState = oe, U.childLanes = c.childLanes & ~B, h.memoizedState = Ea, M;
    }
    return U = c.child, c = U.sibling, M = SC(U, { mode: "visible", children: M.children }), (h.mode & 1) === 0 && (M.lanes = B), M.return = h, M.sibling = null, c !== null && (B = h.deletions, B === null ? (h.deletions = [c], h.flags |= 16) : B.push(c)), h.child = M, h.memoizedState = null, M;
  }
  function Vd(c, h) {
    return h = ma({ mode: "visible", children: h }, c.mode, 0, null), h.return = c, c.child = h;
  }
  function Wp(c, h, B, M) {
    return M !== null && wg(M), el(h, c.child, null, B), c = Vd(h, h.pendingProps.children), c.flags |= 2, h.memoizedState = null, c;
  }
  function tA(c, h, B, M, _, U, oe) {
    if (B)
      return h.flags & 256 ? (h.flags &= -257, M = k(Error(t(422))), Wp(c, h, oe, M)) : h.memoizedState !== null ? (h.child = c.child, h.flags |= 128, null) : (U = M.fallback, _ = h.mode, M = ma({ mode: "visible", children: M.children }, _, 0, null), U = ll(U, _, oe, null), U.flags |= 2, M.return = h, U.return = h, M.sibling = U, h.child = M, (h.mode & 1) !== 0 && el(h, c.child, null, oe), h.child.memoizedState = pr(oe), h.memoizedState = Ea, U);
    if ((h.mode & 1) === 0) return Wp(c, h, oe, null);
    if (_.data === "$!") {
      if (M = _.nextSibling && _.nextSibling.dataset, M) var xe = M.dgst;
      return M = xe, U = Error(t(419)), M = k(U, M, void 0), Wp(c, h, oe, M);
    }
    if (xe = (oe & c.childLanes) !== 0, Yi || xe) {
      if (M = wa, M !== null) {
        switch (oe & -oe) {
          case 4:
            _ = 2;
            break;
          case 16:
            _ = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            _ = 32;
            break;
          case 536870912:
            _ = 268435456;
            break;
          default:
            _ = 0;
        }
        _ = (_ & (M.suspendedLanes | oe)) !== 0 ? 0 : _, _ !== 0 && _ !== U.retryLane && (U.retryLane = _, Nu(c, _), au(M, c, _, -1));
      }
      return Nd(), M = k(Error(t(421))), Wp(c, h, oe, M);
    }
    return _.data === "$?" ? (h.flags |= 128, h.child = c.child, h = zp.bind(null, c), _._reactRetry = h, null) : (c = U.treeContext, Za = Gl(_.nextSibling), To = h, zr = !0, Ws = null, c !== null && (So[na++] = fn, So[na++] = Zl, So[na++] = ec, fn = c.id, Zl = c.overflow, ec = h), h = Vd(h, M.children), h.flags |= 4096, h);
  }
  function nA(c, h, B) {
    c.lanes |= h;
    var M = c.alternate;
    M !== null && (M.lanes |= h), Wn(c.return, h, B);
  }
  function mf(c, h, B, M, _) {
    var U = c.memoizedState;
    U === null ? c.memoizedState = { isBackwards: h, rendering: null, renderingStartTime: 0, last: M, tail: B, tailMode: _ } : (U.isBackwards = h, U.rendering = null, U.renderingStartTime = 0, U.last = M, U.tail = B, U.tailMode = _);
  }
  function Vl(c, h, B) {
    var M = h.pendingProps, _ = M.revealOrder, U = M.tail;
    if (wn(c, h, M.children, B), M = pa.current, (M & 2) !== 0) M = M & 1 | 2, h.flags |= 128;
    else {
      if (c !== null && (c.flags & 128) !== 0) e: for (c = h.child; c !== null; ) {
        if (c.tag === 13) c.memoizedState !== null && nA(c, B, h);
        else if (c.tag === 19) nA(c, B, h);
        else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === h) break e;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === h) break e;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      M &= 1;
    }
    if (ta(pa, M), (h.mode & 1) === 0) h.memoizedState = null;
    else switch (_) {
      case "forwards":
        for (B = h.child, _ = null; B !== null; ) c = B.alternate, c !== null && rc(c) === null && (_ = B), B = B.sibling;
        B = _, B === null ? (_ = h.child, h.child = null) : (_ = B.sibling, B.sibling = null), mf(h, !1, _, B, U);
        break;
      case "backwards":
        for (B = null, _ = h.child, h.child = null; _ !== null; ) {
          if (c = _.alternate, c !== null && rc(c) === null) {
            h.child = _;
            break;
          }
          c = _.sibling, _.sibling = B, B = _, _ = c;
        }
        mf(h, !0, B, null, U);
        break;
      case "together":
        mf(h, !1, null, null, void 0);
        break;
      default:
        h.memoizedState = null;
    }
    return h.child;
  }
  function Xu(c, h) {
    (h.mode & 1) === 0 && c !== null && (c.alternate = null, h.alternate = null, h.flags |= 2);
  }
  function Is(c, h, B) {
    if (c !== null && (h.dependencies = c.dependencies), NI |= h.lanes, (B & h.childLanes) === 0) return null;
    if (c !== null && h.child !== c.child) throw Error(t(153));
    if (h.child !== null) {
      for (c = h.child, B = SC(c, c.pendingProps), h.child = B, B.return = h; c.sibling !== null; ) c = c.sibling, B = B.sibling = SC(c, c.pendingProps), B.return = h;
      B.sibling = null;
    }
    return h.child;
  }
  function Af(c, h, B) {
    switch (h.tag) {
      case 3:
        Vi(h), Wu();
        break;
      case 5:
        Bd(h);
        break;
      case 1:
        Da(h.type) && Xc(h);
        break;
      case 4:
        uC(h, h.stateNode.containerInfo);
        break;
      case 10:
        var M = h.type._context, _ = h.memoizedProps.value;
        ta(yn, M._currentValue), M._currentValue = _;
        break;
      case 13:
        if (M = h.memoizedState, M !== null)
          return M.dehydrated !== null ? (ta(pa, pa.current & 1), h.flags |= 128, null) : (B & h.child.childLanes) !== 0 ? _c(c, h, B) : (ta(pa, pa.current & 1), c = Is(c, h, B), c !== null ? c.sibling : null);
        ta(pa, pa.current & 1);
        break;
      case 19:
        if (M = (B & h.childLanes) !== 0, (c.flags & 128) !== 0) {
          if (M) return Vl(c, h, B);
          h.flags |= 128;
        }
        if (_ = h.memoizedState, _ !== null && (_.rendering = null, _.tail = null, _.lastEffect = null), ta(pa, pa.current), M) break;
        return null;
      case 22:
      case 23:
        return h.lanes = 0, Fe(c, h, B);
    }
    return Is(c, h, B);
  }
  var mh, Nl, zo, iA;
  mh = function(c, h) {
    for (var B = h.child; B !== null; ) {
      if (B.tag === 5 || B.tag === 6) c.appendChild(B.stateNode);
      else if (B.tag !== 4 && B.child !== null) {
        B.child.return = B, B = B.child;
        continue;
      }
      if (B === h) break;
      for (; B.sibling === null; ) {
        if (B.return === null || B.return === h) return;
        B = B.return;
      }
      B.sibling.return = B.return, B = B.sibling;
    }
  }, Nl = function() {
  }, zo = function(c, h, B, M) {
    var _ = c.memoizedProps;
    if (_ !== M) {
      c = h.stateNode, Ro(nu.current);
      var U = null;
      switch (B) {
        case "input":
          _ = Nt(c, _), M = Nt(c, M), U = [];
          break;
        case "select":
          _ = Be({}, _, { value: void 0 }), M = Be({}, M, { value: void 0 }), U = [];
          break;
        case "textarea":
          _ = $e(c, _), M = $e(c, M), U = [];
          break;
        default:
          typeof _.onClick != "function" && typeof M.onClick == "function" && (c.onclick = AI);
      }
      we(B, M);
      var oe;
      B = null;
      for (It in _) if (!M.hasOwnProperty(It) && _.hasOwnProperty(It) && _[It] != null) if (It === "style") {
        var xe = _[It];
        for (oe in xe) xe.hasOwnProperty(oe) && (B || (B = {}), B[oe] = "");
      } else It !== "dangerouslySetInnerHTML" && It !== "children" && It !== "suppressContentEditableWarning" && It !== "suppressHydrationWarning" && It !== "autoFocus" && (i.hasOwnProperty(It) ? U || (U = []) : (U = U || []).push(It, null));
      for (It in M) {
        var Le = M[It];
        if (xe = _?.[It], M.hasOwnProperty(It) && Le !== xe && (Le != null || xe != null)) if (It === "style") if (xe) {
          for (oe in xe) !xe.hasOwnProperty(oe) || Le && Le.hasOwnProperty(oe) || (B || (B = {}), B[oe] = "");
          for (oe in Le) Le.hasOwnProperty(oe) && xe[oe] !== Le[oe] && (B || (B = {}), B[oe] = Le[oe]);
        } else B || (U || (U = []), U.push(
          It,
          B
        )), B = Le;
        else It === "dangerouslySetInnerHTML" ? (Le = Le ? Le.__html : void 0, xe = xe ? xe.__html : void 0, Le != null && xe !== Le && (U = U || []).push(It, Le)) : It === "children" ? typeof Le != "string" && typeof Le != "number" || (U = U || []).push(It, "" + Le) : It !== "suppressContentEditableWarning" && It !== "suppressHydrationWarning" && (i.hasOwnProperty(It) ? (Le != null && It === "onScroll" && lr("scroll", c), U || xe === Le || (U = [])) : (U = U || []).push(It, Le));
      }
      B && (U = U || []).push("style", B);
      var It = U;
      (h.updateQueue = It) && (h.flags |= 4);
    }
  }, iA = function(c, h, B, M) {
    B !== M && (h.flags |= 4);
  };
  function Ah(c, h) {
    if (!zr) switch (c.tailMode) {
      case "hidden":
        h = c.tail;
        for (var B = null; h !== null; ) h.alternate !== null && (B = h), h = h.sibling;
        B === null ? c.tail = null : B.sibling = null;
        break;
      case "collapsed":
        B = c.tail;
        for (var M = null; B !== null; ) B.alternate !== null && (M = B), B = B.sibling;
        M === null ? h || c.tail === null ? c.tail = null : c.tail.sibling = null : M.sibling = null;
    }
  }
  function rl(c) {
    var h = c.alternate !== null && c.alternate.child === c.child, B = 0, M = 0;
    if (h) for (var _ = c.child; _ !== null; ) B |= _.lanes | _.childLanes, M |= _.subtreeFlags & 14680064, M |= _.flags & 14680064, _.return = c, _ = _.sibling;
    else for (_ = c.child; _ !== null; ) B |= _.lanes | _.childLanes, M |= _.subtreeFlags, M |= _.flags, _.return = c, _ = _.sibling;
    return c.subtreeFlags |= M, c.childLanes = B, h;
  }
  function Vp(c, h, B) {
    var M = h.pendingProps;
    switch (tc(h), h.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return rl(h), null;
      case 1:
        return Da(h.type) && Sl(), rl(h), null;
      case 3:
        return M = h.stateNode, Wg(), Ur(io), Ur(Sa), Mu(), M.pendingContext && (M.context = M.pendingContext, M.pendingContext = null), (c === null || c.child === null) && (Ya(h) ? h.flags |= 4 : c === null || c.memoizedState.isDehydrated && (h.flags & 256) === 0 || (h.flags |= 1024, Ws !== null && (HI(Ws), Ws = null))), Nl(c, h), rl(h), null;
      case 5:
        cC(h);
        var _ = Ro(xg.current);
        if (B = h.type, c !== null && h.stateNode != null) zo(c, h, B, M, _), c.ref !== h.ref && (h.flags |= 512, h.flags |= 2097152);
        else {
          if (!M) {
            if (h.stateNode === null) throw Error(t(166));
            return rl(h), null;
          }
          if (c = Ro(nu.current), Ya(h)) {
            M = h.stateNode, B = h.type;
            var U = h.memoizedProps;
            switch (M[ka] = h, M[Hc] = U, c = (h.mode & 1) !== 0, B) {
              case "dialog":
                lr("cancel", M), lr("close", M);
                break;
              case "iframe":
              case "object":
              case "embed":
                lr("load", M);
                break;
              case "video":
              case "audio":
                for (_ = 0; _ < Qt.length; _++) lr(Qt[_], M);
                break;
              case "source":
                lr("error", M);
                break;
              case "img":
              case "image":
              case "link":
                lr(
                  "error",
                  M
                ), lr("load", M);
                break;
              case "details":
                lr("toggle", M);
                break;
              case "input":
                $t(M, U), lr("invalid", M);
                break;
              case "select":
                M._wrapperState = { wasMultiple: !!U.multiple }, lr("invalid", M);
                break;
              case "textarea":
                Vt(M, U), lr("invalid", M);
            }
            we(B, U), _ = null;
            for (var oe in U) if (U.hasOwnProperty(oe)) {
              var xe = U[oe];
              oe === "children" ? typeof xe == "string" ? M.textContent !== xe && (U.suppressHydrationWarning !== !0 && mI(M.textContent, xe, c), _ = ["children", xe]) : typeof xe == "number" && M.textContent !== "" + xe && (U.suppressHydrationWarning !== !0 && mI(
                M.textContent,
                xe,
                c
              ), _ = ["children", "" + xe]) : i.hasOwnProperty(oe) && xe != null && oe === "onScroll" && lr("scroll", M);
            }
            switch (B) {
              case "input":
                Hn(M), en(M, U, !0);
                break;
              case "textarea":
                Hn(M), Mt(M);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof U.onClick == "function" && (M.onclick = AI);
            }
            M = _, h.updateQueue = M, M !== null && (h.flags |= 4);
          } else {
            oe = _.nodeType === 9 ? _ : _.ownerDocument, c === "http://www.w3.org/1999/xhtml" && (c = Gn(B)), c === "http://www.w3.org/1999/xhtml" ? B === "script" ? (c = oe.createElement("div"), c.innerHTML = "<script><\/script>", c = c.removeChild(c.firstChild)) : typeof M.is == "string" ? c = oe.createElement(B, { is: M.is }) : (c = oe.createElement(B), B === "select" && (oe = c, M.multiple ? oe.multiple = !0 : M.size && (oe.size = M.size))) : c = oe.createElementNS(c, B), c[ka] = h, c[Hc] = M, mh(c, h, !1, !1), h.stateNode = c;
            e: {
              switch (oe = qe(B, M), B) {
                case "dialog":
                  lr("cancel", c), lr("close", c), _ = M;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  lr("load", c), _ = M;
                  break;
                case "video":
                case "audio":
                  for (_ = 0; _ < Qt.length; _++) lr(Qt[_], c);
                  _ = M;
                  break;
                case "source":
                  lr("error", c), _ = M;
                  break;
                case "img":
                case "image":
                case "link":
                  lr(
                    "error",
                    c
                  ), lr("load", c), _ = M;
                  break;
                case "details":
                  lr("toggle", c), _ = M;
                  break;
                case "input":
                  $t(c, M), _ = Nt(c, M), lr("invalid", c);
                  break;
                case "option":
                  _ = M;
                  break;
                case "select":
                  c._wrapperState = { wasMultiple: !!M.multiple }, _ = Be({}, M, { value: void 0 }), lr("invalid", c);
                  break;
                case "textarea":
                  Vt(c, M), _ = $e(c, M), lr("invalid", c);
                  break;
                default:
                  _ = M;
              }
              we(B, _), xe = _;
              for (U in xe) if (xe.hasOwnProperty(U)) {
                var Le = xe[U];
                U === "style" ? ht(c, Le) : U === "dangerouslySetInnerHTML" ? (Le = Le ? Le.__html : void 0, Le != null && jn(c, Le)) : U === "children" ? typeof Le == "string" ? (B !== "textarea" || Le !== "") && Ot(c, Le) : typeof Le == "number" && Ot(c, "" + Le) : U !== "suppressContentEditableWarning" && U !== "suppressHydrationWarning" && U !== "autoFocus" && (i.hasOwnProperty(U) ? Le != null && U === "onScroll" && lr("scroll", c) : Le != null && F(c, U, Le, oe));
              }
              switch (B) {
                case "input":
                  Hn(c), en(c, M, !1);
                  break;
                case "textarea":
                  Hn(c), Mt(c);
                  break;
                case "option":
                  M.value != null && c.setAttribute("value", "" + Dt(M.value));
                  break;
                case "select":
                  c.multiple = !!M.multiple, U = M.value, U != null ? se(c, !!M.multiple, U, !1) : M.defaultValue != null && se(
                    c,
                    !!M.multiple,
                    M.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof _.onClick == "function" && (c.onclick = AI);
              }
              switch (B) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  M = !!M.autoFocus;
                  break e;
                case "img":
                  M = !0;
                  break e;
                default:
                  M = !1;
              }
            }
            M && (h.flags |= 4);
          }
          h.ref !== null && (h.flags |= 512, h.flags |= 2097152);
        }
        return rl(h), null;
      case 6:
        if (c && h.stateNode != null) iA(c, h, c.memoizedProps, M);
        else {
          if (typeof M != "string" && h.stateNode === null) throw Error(t(166));
          if (B = Ro(xg.current), Ro(nu.current), Ya(h)) {
            if (M = h.stateNode, B = h.memoizedProps, M[ka] = h, (U = M.nodeValue !== B) && (c = To, c !== null)) switch (c.tag) {
              case 3:
                mI(M.nodeValue, B, (c.mode & 1) !== 0);
                break;
              case 5:
                c.memoizedProps.suppressHydrationWarning !== !0 && mI(M.nodeValue, B, (c.mode & 1) !== 0);
            }
            U && (h.flags |= 4);
          } else M = (B.nodeType === 9 ? B : B.ownerDocument).createTextNode(M), M[ka] = h, h.stateNode = M;
        }
        return rl(h), null;
      case 13:
        if (Ur(pa), M = h.memoizedState, c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
          if (zr && Za !== null && (h.mode & 1) !== 0 && (h.flags & 128) === 0) Sp(), Wu(), h.flags |= 98560, U = !1;
          else if (U = Ya(h), M !== null && M.dehydrated !== null) {
            if (c === null) {
              if (!U) throw Error(t(318));
              if (U = h.memoizedState, U = U !== null ? U.dehydrated : null, !U) throw Error(t(317));
              U[ka] = h;
            } else Wu(), (h.flags & 128) === 0 && (h.memoizedState = null), h.flags |= 4;
            rl(h), U = !1;
          } else Ws !== null && (HI(Ws), Ws = null), U = !0;
          if (!U) return h.flags & 65536 ? h : null;
        }
        return (h.flags & 128) !== 0 ? (h.lanes = B, h) : (M = M !== null, M !== (c !== null && c.memoizedState !== null) && M && (h.child.flags |= 8192, (h.mode & 1) !== 0 && (c === null || (pa.current & 1) !== 0 ? $o === 0 && ($o = 3) : Nd())), h.updateQueue !== null && (h.flags |= 4), rl(h), null);
      case 4:
        return Wg(), Nl(c, h), c === null && Vc(h.stateNode.containerInfo), rl(h), null;
      case 10:
        return wo(h.type._context), rl(h), null;
      case 17:
        return Da(h.type) && Sl(), rl(h), null;
      case 19:
        if (Ur(pa), U = h.memoizedState, U === null) return rl(h), null;
        if (M = (h.flags & 128) !== 0, oe = U.rendering, oe === null) if (M) Ah(U, !1);
        else {
          if ($o !== 0 || c !== null && (c.flags & 128) !== 0) for (c = h.child; c !== null; ) {
            if (oe = rc(c), oe !== null) {
              for (h.flags |= 128, Ah(U, !1), M = oe.updateQueue, M !== null && (h.updateQueue = M, h.flags |= 4), h.subtreeFlags = 0, M = B, B = h.child; B !== null; ) U = B, c = M, U.flags &= 14680066, oe = U.alternate, oe === null ? (U.childLanes = 0, U.lanes = c, U.child = null, U.subtreeFlags = 0, U.memoizedProps = null, U.memoizedState = null, U.updateQueue = null, U.dependencies = null, U.stateNode = null) : (U.childLanes = oe.childLanes, U.lanes = oe.lanes, U.child = oe.child, U.subtreeFlags = 0, U.deletions = null, U.memoizedProps = oe.memoizedProps, U.memoizedState = oe.memoizedState, U.updateQueue = oe.updateQueue, U.type = oe.type, c = oe.dependencies, U.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }), B = B.sibling;
              return ta(pa, pa.current & 1 | 2), h.child;
            }
            c = c.sibling;
          }
          U.tail !== null && Pt() > Gf && (h.flags |= 128, M = !0, Ah(U, !1), h.lanes = 4194304);
        }
        else {
          if (!M) if (c = rc(oe), c !== null) {
            if (h.flags |= 128, M = !0, B = c.updateQueue, B !== null && (h.updateQueue = B, h.flags |= 4), Ah(U, !0), U.tail === null && U.tailMode === "hidden" && !oe.alternate && !zr) return rl(h), null;
          } else 2 * Pt() - U.renderingStartTime > Gf && B !== 1073741824 && (h.flags |= 128, M = !0, Ah(U, !1), h.lanes = 4194304);
          U.isBackwards ? (oe.sibling = h.child, h.child = oe) : (B = U.last, B !== null ? B.sibling = oe : h.child = oe, U.last = oe);
        }
        return U.tail !== null ? (h = U.tail, U.rendering = h, U.tail = h.sibling, U.renderingStartTime = Pt(), h.sibling = null, B = pa.current, ta(pa, M ? B & 1 | 2 : B & 1), h) : (rl(h), null);
      case 22:
      case 23:
        return sA(), M = h.memoizedState !== null, c !== null && c.memoizedState !== null !== M && (h.flags |= 8192), M && (h.mode & 1) !== 0 ? (cc & 1073741824) !== 0 && (rl(h), h.subtreeFlags & 6 && (h.flags |= 8192)) : rl(h), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, h.tag));
  }
  function rA(c, h) {
    switch (tc(h), h.tag) {
      case 1:
        return Da(h.type) && Sl(), c = h.flags, c & 65536 ? (h.flags = c & -65537 | 128, h) : null;
      case 3:
        return Wg(), Ur(io), Ur(Sa), Mu(), c = h.flags, (c & 65536) !== 0 && (c & 128) === 0 ? (h.flags = c & -65537 | 128, h) : null;
      case 5:
        return cC(h), null;
      case 13:
        if (Ur(pa), c = h.memoizedState, c !== null && c.dehydrated !== null) {
          if (h.alternate === null) throw Error(t(340));
          Wu();
        }
        return c = h.flags, c & 65536 ? (h.flags = c & -65537 | 128, h) : null;
      case 19:
        return Ur(pa), null;
      case 4:
        return Wg(), null;
      case 10:
        return wo(h.type._context), null;
      case 22:
      case 23:
        return sA(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var IC = !1, al = !1, Tb = typeof WeakSet == "function" ? WeakSet : Set, ti = null;
  function CC(c, h) {
    var B = c.ref;
    if (B !== null) if (typeof B == "function") try {
      B(null);
    } catch (M) {
      Vo(c, h, M);
    }
    else B.current = null;
  }
  function aA(c, h, B) {
    try {
      B();
    } catch (M) {
      Vo(c, h, M);
    }
  }
  var Np = !1;
  function HB(c, h) {
    if (Su = Bs, c = Hr(), fa(c)) {
      if ("selectionStart" in c) var B = { start: c.selectionStart, end: c.selectionEnd };
      else e: {
        B = (B = c.ownerDocument) && B.defaultView || window;
        var M = B.getSelection && B.getSelection();
        if (M && M.rangeCount !== 0) {
          B = M.anchorNode;
          var _ = M.anchorOffset, U = M.focusNode;
          M = M.focusOffset;
          try {
            B.nodeType, U.nodeType;
          } catch {
            B = null;
            break e;
          }
          var oe = 0, xe = -1, Le = -1, It = 0, Ut = 0, sn = c, qt = null;
          t: for (; ; ) {
            for (var kn; sn !== B || _ !== 0 && sn.nodeType !== 3 || (xe = oe + _), sn !== U || M !== 0 && sn.nodeType !== 3 || (Le = oe + M), sn.nodeType === 3 && (oe += sn.nodeValue.length), (kn = sn.firstChild) !== null; )
              qt = sn, sn = kn;
            for (; ; ) {
              if (sn === c) break t;
              if (qt === B && ++It === _ && (xe = oe), qt === U && ++Ut === M && (Le = oe), (kn = sn.nextSibling) !== null) break;
              sn = qt, qt = sn.parentNode;
            }
            sn = kn;
          }
          B = xe === -1 || Le === -1 ? null : { start: xe, end: Le };
        } else B = null;
      }
      B = B || { start: 0, end: 0 };
    } else B = null;
    for (vI = { focusedElem: c, selectionRange: B }, Bs = !1, ti = h; ti !== null; ) if (h = ti, c = h.child, (h.subtreeFlags & 1028) !== 0 && c !== null) c.return = h, ti = c;
    else for (; ti !== null; ) {
      h = ti;
      try {
        var ii = h.alternate;
        if ((h.flags & 1024) !== 0) switch (h.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (ii !== null) {
              var oi = ii.memoizedProps, ts = ii.memoizedState, at = h.stateNode, Ue = at.getSnapshotBeforeUpdate(h.elementType === h.type ? oi : ds(h.type, oi), ts);
              at.__reactInternalSnapshotBeforeUpdate = Ue;
            }
            break;
          case 3:
            var lt = h.stateNode.containerInfo;
            lt.nodeType === 1 ? lt.textContent = "" : lt.nodeType === 9 && lt.documentElement && lt.removeChild(lt.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(t(163));
        }
      } catch (pn) {
        Vo(h, h.return, pn);
      }
      if (c = h.sibling, c !== null) {
        c.return = h.return, ti = c;
        break;
      }
      ti = h.return;
    }
    return ii = Np, Np = !1, ii;
  }
  function vf(c, h, B) {
    var M = h.updateQueue;
    if (M = M !== null ? M.lastEffect : null, M !== null) {
      var _ = M = M.next;
      do {
        if ((_.tag & c) === c) {
          var U = _.destroy;
          _.destroy = void 0, U !== void 0 && aA(h, B, U);
        }
        _ = _.next;
      } while (_ !== M);
    }
  }
  function xI(c, h) {
    if (h = h.updateQueue, h = h !== null ? h.lastEffect : null, h !== null) {
      var B = h = h.next;
      do {
        if ((B.tag & c) === c) {
          var M = B.create;
          B.destroy = M();
        }
        B = B.next;
      } while (B !== h);
    }
  }
  function WI(c) {
    var h = c.ref;
    if (h !== null) {
      var B = c.stateNode;
      switch (c.tag) {
        case 5:
          c = B;
          break;
        default:
          c = B;
      }
      typeof h == "function" ? h(c) : h.current = c;
    }
  }
  function Mp(c) {
    var h = c.alternate;
    h !== null && (c.alternate = null, Mp(h)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (h = c.stateNode, h !== null && (delete h[ka], delete h[Hc], delete h[$u], delete h[wu], delete h[Bo])), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
  }
  function vh(c) {
    return c.tag === 5 || c.tag === 3 || c.tag === 4;
  }
  function Ml(c) {
    e: for (; ; ) {
      for (; c.sibling === null; ) {
        if (c.return === null || vh(c.return)) return null;
        c = c.return;
      }
      for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
        if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
        c.child.return = c, c = c.child;
      }
      if (!(c.flags & 2)) return c.stateNode;
    }
  }
  function Ko(c, h, B) {
    var M = c.tag;
    if (M === 5 || M === 6) c = c.stateNode, h ? B.nodeType === 8 ? B.parentNode.insertBefore(c, h) : B.insertBefore(c, h) : (B.nodeType === 8 ? (h = B.parentNode, h.insertBefore(c, B)) : (h = B, h.appendChild(c)), B = B._reactRootContainer, B != null || h.onclick !== null || (h.onclick = AI));
    else if (M !== 4 && (c = c.child, c !== null)) for (Ko(c, h, B), c = c.sibling; c !== null; ) Ko(c, h, B), c = c.sibling;
  }
  function Hl(c, h, B) {
    var M = c.tag;
    if (M === 5 || M === 6) c = c.stateNode, h ? B.insertBefore(c, h) : B.appendChild(c);
    else if (M !== 4 && (c = c.child, c !== null)) for (Hl(c, h, B), c = c.sibling; c !== null; ) Hl(c, h, B), c = c.sibling;
  }
  var Kr = null, co = !1;
  function zc(c, h, B) {
    for (B = B.child; B !== null; ) VI(c, h, B), B = B.sibling;
  }
  function VI(c, h, B) {
    if (xn && typeof xn.onCommitFiberUnmount == "function") try {
      xn.onCommitFiberUnmount(mi, B);
    } catch {
    }
    switch (B.tag) {
      case 5:
        al || CC(B, h);
      case 6:
        var M = Kr, _ = co;
        Kr = null, zc(c, h, B), Kr = M, co = _, Kr !== null && (co ? (c = Kr, B = B.stateNode, c.nodeType === 8 ? c.parentNode.removeChild(B) : c.removeChild(B)) : Kr.removeChild(B.stateNode));
        break;
      case 18:
        Kr !== null && (co ? (c = Kr, B = B.stateNode, c.nodeType === 8 ? Sg(c.parentNode, B) : c.nodeType === 1 && Sg(c, B), pu(c)) : Sg(Kr, B.stateNode));
        break;
      case 4:
        M = Kr, _ = co, Kr = B.stateNode.containerInfo, co = !0, zc(c, h, B), Kr = M, co = _;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!al && (M = B.updateQueue, M !== null && (M = M.lastEffect, M !== null))) {
          _ = M = M.next;
          do {
            var U = _, oe = U.destroy;
            U = U.tag, oe !== void 0 && ((U & 2) !== 0 || (U & 4) !== 0) && aA(B, h, oe), _ = _.next;
          } while (_ !== M);
        }
        zc(c, h, B);
        break;
      case 1:
        if (!al && (CC(B, h), M = B.stateNode, typeof M.componentWillUnmount == "function")) try {
          M.props = B.memoizedProps, M.state = B.memoizedState, M.componentWillUnmount();
        } catch (xe) {
          Vo(B, h, xe);
        }
        zc(c, h, B);
        break;
      case 21:
        zc(c, h, B);
        break;
      case 22:
        B.mode & 1 ? (al = (M = al) || B.memoizedState !== null, zc(c, h, B), al = M) : zc(c, h, B);
        break;
      default:
        zc(c, h, B);
    }
  }
  function _b(c) {
    var h = c.updateQueue;
    if (h !== null) {
      c.updateQueue = null;
      var B = c.stateNode;
      B === null && (B = c.stateNode = new Tb()), h.forEach(function(M) {
        var _ = Tg.bind(null, c, M);
        B.has(M) || (B.add(M), M.then(_, _));
      });
    }
  }
  function ol(c, h) {
    var B = h.deletions;
    if (B !== null) for (var M = 0; M < B.length; M++) {
      var _ = B[M];
      try {
        var U = c, oe = h, xe = oe;
        e: for (; xe !== null; ) {
          switch (xe.tag) {
            case 5:
              Kr = xe.stateNode, co = !1;
              break e;
            case 3:
              Kr = xe.stateNode.containerInfo, co = !0;
              break e;
            case 4:
              Kr = xe.stateNode.containerInfo, co = !0;
              break e;
          }
          xe = xe.return;
        }
        if (Kr === null) throw Error(t(160));
        VI(U, oe, _), Kr = null, co = !1;
        var Le = _.alternate;
        Le !== null && (Le.return = null), _.return = null;
      } catch (It) {
        Vo(_, h, It);
      }
    }
    if (h.subtreeFlags & 12854) for (h = h.child; h !== null; ) Vv(h, c), h = h.sibling;
  }
  function Vv(c, h) {
    var B = c.alternate, M = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ol(h, c), uc(c), M & 4) {
          try {
            vf(3, c, c.return), xI(3, c);
          } catch (oi) {
            Vo(c, c.return, oi);
          }
          try {
            vf(5, c, c.return);
          } catch (oi) {
            Vo(c, c.return, oi);
          }
        }
        break;
      case 1:
        ol(h, c), uc(c), M & 512 && B !== null && CC(B, B.return);
        break;
      case 5:
        if (ol(h, c), uc(c), M & 512 && B !== null && CC(B, B.return), c.flags & 32) {
          var _ = c.stateNode;
          try {
            Ot(_, "");
          } catch (oi) {
            Vo(c, c.return, oi);
          }
        }
        if (M & 4 && (_ = c.stateNode, _ != null)) {
          var U = c.memoizedProps, oe = B !== null ? B.memoizedProps : U, xe = c.type, Le = c.updateQueue;
          if (c.updateQueue = null, Le !== null) try {
            xe === "input" && U.type === "radio" && U.name != null && ft(_, U), qe(xe, oe);
            var It = qe(xe, U);
            for (oe = 0; oe < Le.length; oe += 2) {
              var Ut = Le[oe], sn = Le[oe + 1];
              Ut === "style" ? ht(_, sn) : Ut === "dangerouslySetInnerHTML" ? jn(_, sn) : Ut === "children" ? Ot(_, sn) : F(_, Ut, sn, It);
            }
            switch (xe) {
              case "input":
                bn(_, U);
                break;
              case "textarea":
                Bt(_, U);
                break;
              case "select":
                var qt = _._wrapperState.wasMultiple;
                _._wrapperState.wasMultiple = !!U.multiple;
                var kn = U.value;
                kn != null ? se(_, !!U.multiple, kn, !1) : qt !== !!U.multiple && (U.defaultValue != null ? se(
                  _,
                  !!U.multiple,
                  U.defaultValue,
                  !0
                ) : se(_, !!U.multiple, U.multiple ? [] : "", !1));
            }
            _[Hc] = U;
          } catch (oi) {
            Vo(c, c.return, oi);
          }
        }
        break;
      case 6:
        if (ol(h, c), uc(c), M & 4) {
          if (c.stateNode === null) throw Error(t(162));
          _ = c.stateNode, U = c.memoizedProps;
          try {
            _.nodeValue = U;
          } catch (oi) {
            Vo(c, c.return, oi);
          }
        }
        break;
      case 3:
        if (ol(h, c), uc(c), M & 4 && B !== null && B.memoizedState.isDehydrated) try {
          pu(h.containerInfo);
        } catch (oi) {
          Vo(c, c.return, oi);
        }
        break;
      case 4:
        ol(h, c), uc(c);
        break;
      case 13:
        ol(h, c), uc(c), _ = c.child, _.flags & 8192 && (U = _.memoizedState !== null, _.stateNode.isHidden = U, !U || _.alternate !== null && _.alternate.memoizedState !== null || (Yp = Pt())), M & 4 && _b(c);
        break;
      case 22:
        if (Ut = B !== null && B.memoizedState !== null, c.mode & 1 ? (al = (It = al) || Ut, ol(h, c), al = It) : ol(h, c), uc(c), M & 8192) {
          if (It = c.memoizedState !== null, (c.stateNode.isHidden = It) && !Ut && (c.mode & 1) !== 0) for (ti = c, Ut = c.child; Ut !== null; ) {
            for (sn = ti = Ut; ti !== null; ) {
              switch (qt = ti, kn = qt.child, qt.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  vf(4, qt, qt.return);
                  break;
                case 1:
                  CC(qt, qt.return);
                  var ii = qt.stateNode;
                  if (typeof ii.componentWillUnmount == "function") {
                    M = qt, B = qt.return;
                    try {
                      h = M, ii.props = h.memoizedProps, ii.state = h.memoizedState, ii.componentWillUnmount();
                    } catch (oi) {
                      Vo(M, B, oi);
                    }
                  }
                  break;
                case 5:
                  CC(qt, qt.return);
                  break;
                case 22:
                  if (qt.memoizedState !== null) {
                    Kb(sn);
                    continue;
                  }
              }
              kn !== null ? (kn.return = qt, ti = kn) : Kb(sn);
            }
            Ut = Ut.sibling;
          }
          e: for (Ut = null, sn = c; ; ) {
            if (sn.tag === 5) {
              if (Ut === null) {
                Ut = sn;
                try {
                  _ = sn.stateNode, It ? (U = _.style, typeof U.setProperty == "function" ? U.setProperty("display", "none", "important") : U.display = "none") : (xe = sn.stateNode, Le = sn.memoizedProps.style, oe = Le != null && Le.hasOwnProperty("display") ? Le.display : null, xe.style.display = xt("display", oe));
                } catch (oi) {
                  Vo(c, c.return, oi);
                }
              }
            } else if (sn.tag === 6) {
              if (Ut === null) try {
                sn.stateNode.nodeValue = It ? "" : sn.memoizedProps;
              } catch (oi) {
                Vo(c, c.return, oi);
              }
            } else if ((sn.tag !== 22 && sn.tag !== 23 || sn.memoizedState === null || sn === c) && sn.child !== null) {
              sn.child.return = sn, sn = sn.child;
              continue;
            }
            if (sn === c) break e;
            for (; sn.sibling === null; ) {
              if (sn.return === null || sn.return === c) break e;
              Ut === sn && (Ut = null), sn = sn.return;
            }
            Ut === sn && (Ut = null), sn.sibling.return = sn.return, sn = sn.sibling;
          }
        }
        break;
      case 19:
        ol(h, c), uc(c), M & 4 && _b(c);
        break;
      case 21:
        break;
      default:
        ol(
          h,
          c
        ), uc(c);
    }
  }
  function uc(c) {
    var h = c.flags;
    if (h & 2) {
      try {
        e: {
          for (var B = c.return; B !== null; ) {
            if (vh(B)) {
              var M = B;
              break e;
            }
            B = B.return;
          }
          throw Error(t(160));
        }
        switch (M.tag) {
          case 5:
            var _ = M.stateNode;
            M.flags & 32 && (Ot(_, ""), M.flags &= -33);
            var U = Ml(c);
            Hl(c, U, _);
            break;
          case 3:
          case 4:
            var oe = M.stateNode.containerInfo, xe = Ml(c);
            Ko(c, xe, oe);
            break;
          default:
            throw Error(t(161));
        }
      } catch (Le) {
        Vo(c, c.return, Le);
      }
      c.flags &= -3;
    }
    h & 4096 && (c.flags &= -4097);
  }
  function hC(c, h, B) {
    ti = c, zb(c);
  }
  function zb(c, h, B) {
    for (var M = (c.mode & 1) !== 0; ti !== null; ) {
      var _ = ti, U = _.child;
      if (_.tag === 22 && M) {
        var oe = _.memoizedState !== null || IC;
        if (!oe) {
          var xe = _.alternate, Le = xe !== null && xe.memoizedState !== null || al;
          xe = IC;
          var It = al;
          if (IC = oe, (al = Le) && !It) for (ti = _; ti !== null; ) oe = ti, Le = oe.child, oe.tag === 22 && oe.memoizedState !== null ? Xp(_) : Le !== null ? (Le.return = oe, ti = Le) : Xp(_);
          for (; U !== null; ) ti = U, zb(U), U = U.sibling;
          ti = _, IC = xe, al = It;
        }
        Hp(c);
      } else (_.subtreeFlags & 8772) !== 0 && U !== null ? (U.return = _, ti = U) : Hp(c);
    }
  }
  function Hp(c) {
    for (; ti !== null; ) {
      var h = ti;
      if ((h.flags & 8772) !== 0) {
        var B = h.alternate;
        try {
          if ((h.flags & 8772) !== 0) switch (h.tag) {
            case 0:
            case 11:
            case 15:
              al || xI(5, h);
              break;
            case 1:
              var M = h.stateNode;
              if (h.flags & 4 && !al) if (B === null) M.componentDidMount();
              else {
                var _ = h.elementType === h.type ? B.memoizedProps : ds(h.type, B.memoizedProps);
                M.componentDidUpdate(_, B.memoizedState, M.__reactInternalSnapshotBeforeUpdate);
              }
              var U = h.updateQueue;
              U !== null && SI(h, U, M);
              break;
            case 3:
              var oe = h.updateQueue;
              if (oe !== null) {
                if (B = null, h.child !== null) switch (h.child.tag) {
                  case 5:
                    B = h.child.stateNode;
                    break;
                  case 1:
                    B = h.child.stateNode;
                }
                SI(h, oe, B);
              }
              break;
            case 5:
              var xe = h.stateNode;
              if (B === null && h.flags & 4) {
                B = xe;
                var Le = h.memoizedProps;
                switch (h.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    Le.autoFocus && B.focus();
                    break;
                  case "img":
                    Le.src && (B.src = Le.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (h.memoizedState === null) {
                var It = h.alternate;
                if (It !== null) {
                  var Ut = It.memoizedState;
                  if (Ut !== null) {
                    var sn = Ut.dehydrated;
                    sn !== null && pu(sn);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(t(163));
          }
          al || h.flags & 512 && WI(h);
        } catch (qt) {
          Vo(h, h.return, qt);
        }
      }
      if (h === c) {
        ti = null;
        break;
      }
      if (B = h.sibling, B !== null) {
        B.return = h.return, ti = B;
        break;
      }
      ti = h.return;
    }
  }
  function Kb(c) {
    for (; ti !== null; ) {
      var h = ti;
      if (h === c) {
        ti = null;
        break;
      }
      var B = h.sibling;
      if (B !== null) {
        B.return = h.return, ti = B;
        break;
      }
      ti = h.return;
    }
  }
  function Xp(c) {
    for (; ti !== null; ) {
      var h = ti;
      try {
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            var B = h.return;
            try {
              xI(4, h);
            } catch (Le) {
              Vo(h, B, Le);
            }
            break;
          case 1:
            var M = h.stateNode;
            if (typeof M.componentDidMount == "function") {
              var _ = h.return;
              try {
                M.componentDidMount();
              } catch (Le) {
                Vo(h, _, Le);
              }
            }
            var U = h.return;
            try {
              WI(h);
            } catch (Le) {
              Vo(h, U, Le);
            }
            break;
          case 5:
            var oe = h.return;
            try {
              WI(h);
            } catch (Le) {
              Vo(h, oe, Le);
            }
        }
      } catch (Le) {
        Vo(h, h.return, Le);
      }
      if (h === c) {
        ti = null;
        break;
      }
      var xe = h.sibling;
      if (xe !== null) {
        xe.return = h.return, ti = xe;
        break;
      }
      ti = h.return;
    }
  }
  var fC = Math.ceil, qo = T.ReactCurrentDispatcher, Ns = T.ReactCurrentOwner, Va = T.ReactCurrentBatchConfig, Qi = 0, wa = null, Lo = null, sl = 0, cc = 0, yf = ea(0), $o = 0, pC = null, NI = 0, mC = 0, bf = 0, AC = null, Xl = null, Yp = 0, Gf = 1 / 0, MI = null, vC = !1, Fp = null, gc = null, yC = !1, bC = null, Bf = 0, Fg = 0, yh = null, Wo = -1, bh = 0;
  function da() {
    return (Qi & 6) !== 0 ? Pt() : Wo !== -1 ? Wo : Wo = Pt();
  }
  function ru(c) {
    return (c.mode & 1) === 0 ? 1 : (Qi & 2) !== 0 && sl !== 0 ? sl & -sl : Gd.transition !== null ? (bh === 0 && (bh = Ao()), bh) : (c = sr, c !== 0 || (c = window.event, c = c === void 0 ? 16 : th(c.type)), c);
  }
  function au(c, h, B, M) {
    if (50 < Fg) throw Fg = 0, yh = null, Error(t(185));
    od(c, B, M), ((Qi & 2) === 0 || c !== wa) && (c === wa && ((Qi & 2) === 0 && (mC |= B), $o === 4 && Eg(c, sl)), es(c, M), B === 1 && Qi === 0 && (h.mode & 1) === 0 && (Gf = Pt() + 500, Yc && Ua()));
  }
  function es(c, h) {
    var B = c.callbackNode;
    Xa(c, h);
    var M = za(c, c === wa ? sl : 0);
    if (M === 0) B !== null && Tt(B), c.callbackNode = null, c.callbackPriority = 0;
    else if (h = M & -M, c.callbackPriority !== h) {
      if (B != null && Tt(B), h === 1) c.tag === 0 ? xs(Zf.bind(null, c)) : tu(Zf.bind(null, c)), ff(function() {
        (Qi & 6) === 0 && Ua();
      }), B = null;
      else {
        switch (Yo(M)) {
          case 1:
            B = rn;
            break;
          case 4:
            B = Yn;
            break;
          case 16:
            B = Fi;
            break;
          case 536870912:
            B = Tn;
            break;
          default:
            B = Fi;
        }
        B = Sh(B, oA.bind(null, c));
      }
      c.callbackPriority = h, c.callbackNode = B;
    }
  }
  function oA(c, h) {
    if (Wo = -1, bh = 0, (Qi & 6) !== 0) throw Error(t(327));
    var B = c.callbackNode;
    if (Bh() && c.callbackNode !== B) return null;
    var M = za(c, c === wa ? sl : 0);
    if (M === 0) return null;
    if ((M & 30) !== 0 || (M & c.expiredLanes) !== 0 || h) h = BC(c, M);
    else {
      h = M;
      var _ = Qi;
      Qi |= 2;
      var U = wf();
      (wa !== c || sl !== h) && (MI = null, Gf = Pt() + 500, Gh(c, h));
      do
        try {
          cA();
          break;
        } catch (xe) {
          lA(c, xe);
        }
      while (!0);
      Vu(), qo.current = U, Qi = _, Lo !== null ? h = 0 : (wa = null, sl = 0, h = $o);
    }
    if (h !== 0) {
      if (h === 2 && (_ = bs(c), _ !== 0 && (M = _, h = Sf(c, _))), h === 1) throw B = pC, Gh(c, 0), Eg(c, M), es(c, Pt()), B;
      if (h === 6) Eg(c, M);
      else {
        if (_ = c.current.alternate, (M & 30) === 0 && !GC(_) && (h = BC(c, M), h === 2 && (U = bs(c), U !== 0 && (M = U, h = Sf(c, U))), h === 1)) throw B = pC, Gh(c, 0), Eg(c, M), es(c, Pt()), B;
        switch (c.finishedWork = _, c.finishedLanes = M, h) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            Lc(c, Xl, MI);
            break;
          case 3:
            if (Eg(c, M), (M & 130023424) === M && (h = Yp + 500 - Pt(), 10 < h)) {
              if (za(c, 0) !== 0) break;
              if (_ = c.suspendedLanes, (_ & M) !== M) {
                da(), c.pingedLanes |= c.suspendedLanes & _;
                break;
              }
              c.timeoutHandle = rC(Lc.bind(null, c, Xl, MI), h);
              break;
            }
            Lc(c, Xl, MI);
            break;
          case 4:
            if (Eg(c, M), (M & 4194240) === M) break;
            for (h = c.eventTimes, _ = -1; 0 < M; ) {
              var oe = 31 - Xn(M);
              U = 1 << oe, oe = h[oe], oe > _ && (_ = oe), M &= ~U;
            }
            if (M = _, M = Pt() - M, M = (120 > M ? 120 : 480 > M ? 480 : 1080 > M ? 1080 : 1920 > M ? 1920 : 3e3 > M ? 3e3 : 4320 > M ? 4320 : 1960 * fC(M / 1960)) - M, 10 < M) {
              c.timeoutHandle = rC(Lc.bind(null, c, Xl, MI), M);
              break;
            }
            Lc(c, Xl, MI);
            break;
          case 5:
            Lc(c, Xl, MI);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return es(c, Pt()), c.callbackNode === B ? oA.bind(null, c) : null;
  }
  function Sf(c, h) {
    var B = AC;
    return c.current.memoizedState.isDehydrated && (Gh(c, h).flags |= 256), c = BC(c, h), c !== 2 && (h = Xl, Xl = B, h !== null && HI(h)), c;
  }
  function HI(c) {
    Xl === null ? Xl = c : Xl.push.apply(Xl, c);
  }
  function GC(c) {
    for (var h = c; ; ) {
      if (h.flags & 16384) {
        var B = h.updateQueue;
        if (B !== null && (B = B.stores, B !== null)) for (var M = 0; M < B.length; M++) {
          var _ = B[M], U = _.getSnapshot;
          _ = _.value;
          try {
            if (!Dr(U(), _)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (B = h.child, h.subtreeFlags & 16384 && B !== null) B.return = h, h = B;
      else {
        if (h === c) break;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === c) return !0;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
    }
    return !0;
  }
  function Eg(c, h) {
    for (h &= ~bf, h &= ~mC, c.suspendedLanes |= h, c.pingedLanes &= ~h, c = c.expirationTimes; 0 < h; ) {
      var B = 31 - Xn(h), M = 1 << B;
      c[B] = -1, h &= ~M;
    }
  }
  function Zf(c) {
    if ((Qi & 6) !== 0) throw Error(t(327));
    Bh();
    var h = za(c, 0);
    if ((h & 1) === 0) return es(c, Pt()), null;
    var B = BC(c, h);
    if (c.tag !== 0 && B === 2) {
      var M = bs(c);
      M !== 0 && (h = M, B = Sf(c, M));
    }
    if (B === 1) throw B = pC, Gh(c, 0), Eg(c, h), es(c, Pt()), B;
    if (B === 6) throw Error(t(345));
    return c.finishedWork = c.current.alternate, c.finishedLanes = h, Lc(c, Xl, MI), es(c, Pt()), null;
  }
  function Ep(c, h) {
    var B = Qi;
    Qi |= 1;
    try {
      return c(h);
    } finally {
      Qi = B, Qi === 0 && (Gf = Pt() + 500, Yc && Ua());
    }
  }
  function Kc(c) {
    bC !== null && bC.tag === 0 && (Qi & 6) === 0 && Bh();
    var h = Qi;
    Qi |= 1;
    var B = Va.transition, M = sr;
    try {
      if (Va.transition = null, sr = 1, c) return c();
    } finally {
      sr = M, Va.transition = B, Qi = h, (Qi & 6) === 0 && Ua();
    }
  }
  function sA() {
    cc = yf.current, Ur(yf);
  }
  function Gh(c, h) {
    c.finishedWork = null, c.finishedLanes = 0;
    var B = c.timeoutHandle;
    if (B !== -1 && (c.timeoutHandle = -1, aC(B)), Lo !== null) for (B = Lo.return; B !== null; ) {
      var M = B;
      switch (tc(M), M.tag) {
        case 1:
          M = M.type.childContextTypes, M != null && Sl();
          break;
        case 3:
          Wg(), Ur(io), Ur(Sa), Mu();
          break;
        case 5:
          cC(M);
          break;
        case 4:
          Wg();
          break;
        case 13:
          Ur(pa);
          break;
        case 19:
          Ur(pa);
          break;
        case 10:
          wo(M.type._context);
          break;
        case 22:
        case 23:
          sA();
      }
      B = B.return;
    }
    if (wa = c, Lo = c = SC(c.current, null), sl = cc = h, $o = 0, pC = null, bf = mC = NI = 0, Xl = AC = null, Rg !== null) {
      for (h = 0; h < Rg.length; h++) if (B = Rg[h], M = B.interleaved, M !== null) {
        B.interleaved = null;
        var _ = M.next, U = B.pending;
        if (U !== null) {
          var oe = U.next;
          U.next = _, M.next = oe;
        }
        B.pending = M;
      }
      Rg = null;
    }
    return c;
  }
  function lA(c, h) {
    do {
      var B = Lo;
      try {
        if (Vu(), si.current = Nr, ac) {
          for (var M = Xi.memoizedState; M !== null; ) {
            var _ = M.queue;
            _ !== null && (_.pending = null), M = M.next;
          }
          ac = !1;
        }
        if (ir = 0, fr = Xr = Xi = null, ca = !1, Vs = 0, Ns.current = null, B === null || B.return === null) {
          $o = 1, pC = h, Lo = null;
          break;
        }
        e: {
          var U = c, oe = B.return, xe = B, Le = h;
          if (h = sl, xe.flags |= 32768, Le !== null && typeof Le == "object" && typeof Le.then == "function") {
            var It = Le, Ut = xe, sn = Ut.tag;
            if ((Ut.mode & 1) === 0 && (sn === 0 || sn === 11 || sn === 15)) {
              var qt = Ut.alternate;
              qt ? (Ut.updateQueue = qt.updateQueue, Ut.memoizedState = qt.memoizedState, Ut.lanes = qt.lanes) : (Ut.updateQueue = null, Ut.memoizedState = null);
            }
            var kn = $n(oe);
            if (kn !== null) {
              kn.flags &= -257, zi(kn, oe, xe, U, h), kn.mode & 1 && In(U, It, h), h = kn, Le = It;
              var ii = h.updateQueue;
              if (ii === null) {
                var oi = /* @__PURE__ */ new Set();
                oi.add(Le), h.updateQueue = oi;
              } else ii.add(Le);
              break e;
            } else {
              if ((h & 1) === 0) {
                In(U, It, h), Nd();
                break e;
              }
              Le = Error(t(426));
            }
          } else if (zr && xe.mode & 1) {
            var ts = $n(oe);
            if (ts !== null) {
              (ts.flags & 65536) === 0 && (ts.flags |= 256), zi(ts, oe, xe, U, h), wg(E(Le, xe));
              break e;
            }
          }
          U = Le = E(Le, xe), $o !== 4 && ($o = 2), AC === null ? AC = [U] : AC.push(U), U = oe;
          do {
            switch (U.tag) {
              case 3:
                U.flags |= 65536, h &= -h, U.lanes |= h;
                var at = Ke(U, Le, h);
                nc(U, at);
                break e;
              case 1:
                xe = Le;
                var Ue = U.type, lt = U.stateNode;
                if ((U.flags & 128) === 0 && (typeof Ue.getDerivedStateFromError == "function" || lt !== null && typeof lt.componentDidCatch == "function" && (gc === null || !gc.has(lt)))) {
                  U.flags |= 65536, h &= -h, U.lanes |= h;
                  var pn = Rt(U, xe, h);
                  nc(U, pn);
                  break e;
                }
            }
            U = U.return;
          } while (U !== null);
        }
        gA(B);
      } catch (zn) {
        h = zn, Lo === B && B !== null && (Lo = B = B.return);
        continue;
      }
      break;
    } while (!0);
  }
  function wf() {
    var c = qo.current;
    return qo.current = Nr, c === null ? Nr : c;
  }
  function Nd() {
    ($o === 0 || $o === 3 || $o === 2) && ($o = 4), wa === null || (NI & 268435455) === 0 && (mC & 268435455) === 0 || Eg(wa, sl);
  }
  function BC(c, h) {
    var B = Qi;
    Qi |= 2;
    var M = wf();
    (wa !== c || sl !== h) && (MI = null, Gh(c, h));
    do
      try {
        uA();
        break;
      } catch (_) {
        lA(c, _);
      }
    while (!0);
    if (Vu(), Qi = B, qo.current = M, Lo !== null) throw Error(t(261));
    return wa = null, sl = 0, $o;
  }
  function uA() {
    for (; Lo !== null; ) Tp(Lo);
  }
  function cA() {
    for (; Lo !== null && !tn(); ) Tp(Lo);
  }
  function Tp(c) {
    var h = Kp(c.alternate, c, cc);
    c.memoizedProps = c.pendingProps, h === null ? gA(c) : Lo = h, Ns.current = null;
  }
  function gA(c) {
    var h = c;
    do {
      var B = h.alternate;
      if (c = h.return, (h.flags & 32768) === 0) {
        if (B = Vp(B, h, cc), B !== null) {
          Lo = B;
          return;
        }
      } else {
        if (B = rA(B, h), B !== null) {
          B.flags &= 32767, Lo = B;
          return;
        }
        if (c !== null) c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null;
        else {
          $o = 6, Lo = null;
          return;
        }
      }
      if (h = h.sibling, h !== null) {
        Lo = h;
        return;
      }
      Lo = h = c;
    } while (h !== null);
    $o === 0 && ($o = 5);
  }
  function Lc(c, h, B) {
    var M = sr, _ = Va.transition;
    try {
      Va.transition = null, sr = 1, _p(c, h, B, M);
    } finally {
      Va.transition = _, sr = M;
    }
    return null;
  }
  function _p(c, h, B, M) {
    do
      Bh();
    while (bC !== null);
    if ((Qi & 6) !== 0) throw Error(t(327));
    B = c.finishedWork;
    var _ = c.finishedLanes;
    if (B === null) return null;
    if (c.finishedWork = null, c.finishedLanes = 0, B === c.current) throw Error(t(177));
    c.callbackNode = null, c.callbackPriority = 0;
    var U = B.lanes | B.childLanes;
    if (dI(c, U), c === wa && (Lo = wa = null, sl = 0), (B.subtreeFlags & 2064) === 0 && (B.flags & 2064) === 0 || yC || (yC = !0, Sh(Fi, function() {
      return Bh(), null;
    })), U = (B.flags & 15990) !== 0, (B.subtreeFlags & 15990) !== 0 || U) {
      U = Va.transition, Va.transition = null;
      var oe = sr;
      sr = 1;
      var xe = Qi;
      Qi |= 4, Ns.current = null, HB(c, B), Vv(B, c), bo(vI), Bs = !!Su, vI = Su = null, c.current = B, hC(B), Bn(), Qi = xe, sr = oe, Va.transition = U;
    } else c.current = B;
    if (yC && (yC = !1, bC = c, Bf = _), U = c.pendingLanes, U === 0 && (gc = null), un(B.stateNode), es(c, Pt()), h !== null) for (M = c.onRecoverableError, B = 0; B < h.length; B++) _ = h[B], M(_.value, { componentStack: _.stack, digest: _.digest });
    if (vC) throw vC = !1, c = Fp, Fp = null, c;
    return (Bf & 1) !== 0 && c.tag !== 0 && Bh(), U = c.pendingLanes, (U & 1) !== 0 ? c === yh ? Fg++ : (Fg = 0, yh = c) : Fg = 0, Ua(), null;
  }
  function Bh() {
    if (bC !== null) {
      var c = Yo(Bf), h = Va.transition, B = sr;
      try {
        if (Va.transition = null, sr = 16 > c ? 16 : c, bC === null) var M = !1;
        else {
          if (c = bC, bC = null, Bf = 0, (Qi & 6) !== 0) throw Error(t(331));
          var _ = Qi;
          for (Qi |= 4, ti = c.current; ti !== null; ) {
            var U = ti, oe = U.child;
            if ((ti.flags & 16) !== 0) {
              var xe = U.deletions;
              if (xe !== null) {
                for (var Le = 0; Le < xe.length; Le++) {
                  var It = xe[Le];
                  for (ti = It; ti !== null; ) {
                    var Ut = ti;
                    switch (Ut.tag) {
                      case 0:
                      case 11:
                      case 15:
                        vf(8, Ut, U);
                    }
                    var sn = Ut.child;
                    if (sn !== null) sn.return = Ut, ti = sn;
                    else for (; ti !== null; ) {
                      Ut = ti;
                      var qt = Ut.sibling, kn = Ut.return;
                      if (Mp(Ut), Ut === It) {
                        ti = null;
                        break;
                      }
                      if (qt !== null) {
                        qt.return = kn, ti = qt;
                        break;
                      }
                      ti = kn;
                    }
                  }
                }
                var ii = U.alternate;
                if (ii !== null) {
                  var oi = ii.child;
                  if (oi !== null) {
                    ii.child = null;
                    do {
                      var ts = oi.sibling;
                      oi.sibling = null, oi = ts;
                    } while (oi !== null);
                  }
                }
                ti = U;
              }
            }
            if ((U.subtreeFlags & 2064) !== 0 && oe !== null) oe.return = U, ti = oe;
            else e: for (; ti !== null; ) {
              if (U = ti, (U.flags & 2048) !== 0) switch (U.tag) {
                case 0:
                case 11:
                case 15:
                  vf(9, U, U.return);
              }
              var at = U.sibling;
              if (at !== null) {
                at.return = U.return, ti = at;
                break e;
              }
              ti = U.return;
            }
          }
          var Ue = c.current;
          for (ti = Ue; ti !== null; ) {
            oe = ti;
            var lt = oe.child;
            if ((oe.subtreeFlags & 2064) !== 0 && lt !== null) lt.return = oe, ti = lt;
            else e: for (oe = Ue; ti !== null; ) {
              if (xe = ti, (xe.flags & 2048) !== 0) try {
                switch (xe.tag) {
                  case 0:
                  case 11:
                  case 15:
                    xI(9, xe);
                }
              } catch (zn) {
                Vo(xe, xe.return, zn);
              }
              if (xe === oe) {
                ti = null;
                break e;
              }
              var pn = xe.sibling;
              if (pn !== null) {
                pn.return = xe.return, ti = pn;
                break e;
              }
              ti = xe.return;
            }
          }
          if (Qi = _, Ua(), xn && typeof xn.onPostCommitFiberRoot == "function") try {
            xn.onPostCommitFiberRoot(mi, c);
          } catch {
          }
          M = !0;
        }
        return M;
      } finally {
        sr = B, Va.transition = h;
      }
    }
    return !1;
  }
  function dA(c, h, B) {
    h = E(B, h), h = Ke(c, h, 1), c = Wa(c, h, 1), h = da(), c !== null && (od(c, 1, h), es(c, h));
  }
  function Vo(c, h, B) {
    if (c.tag === 3) dA(c, c, B);
    else for (; h !== null; ) {
      if (h.tag === 3) {
        dA(h, c, B);
        break;
      } else if (h.tag === 1) {
        var M = h.stateNode;
        if (typeof h.type.getDerivedStateFromError == "function" || typeof M.componentDidCatch == "function" && (gc === null || !gc.has(M))) {
          c = E(B, c), c = Rt(h, c, 1), h = Wa(h, c, 1), c = da(), h !== null && (od(h, 1, c), es(h, c));
          break;
        }
      }
      h = h.return;
    }
  }
  function IA(c, h, B) {
    var M = c.pingCache;
    M !== null && M.delete(h), h = da(), c.pingedLanes |= c.suspendedLanes & B, wa === c && (sl & B) === B && ($o === 4 || $o === 3 && (sl & 130023424) === sl && 500 > Pt() - Yp ? Gh(c, 0) : bf |= B), es(c, h);
  }
  function Nv(c, h) {
    h === 0 && ((c.mode & 1) === 0 ? h = 1 : (h = ba, ba <<= 1, (ba & 130023424) === 0 && (ba = 4194304)));
    var B = da();
    c = Nu(c, h), c !== null && (od(c, h, B), es(c, B));
  }
  function zp(c) {
    var h = c.memoizedState, B = 0;
    h !== null && (B = h.retryLane), Nv(c, B);
  }
  function Tg(c, h) {
    var B = 0;
    switch (c.tag) {
      case 13:
        var M = c.stateNode, _ = c.memoizedState;
        _ !== null && (B = _.retryLane);
        break;
      case 19:
        M = c.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    M !== null && M.delete(h), Nv(c, B);
  }
  var Kp;
  Kp = function(c, h, B) {
    if (c !== null) if (c.memoizedProps !== h.pendingProps || io.current) Yi = !0;
    else {
      if ((c.lanes & B) === 0 && (h.flags & 128) === 0) return Yi = !1, Af(c, h, B);
      Yi = (c.flags & 131072) !== 0;
    }
    else Yi = !1, zr && (h.flags & 1048576) !== 0 && dh(h, GI, h.index);
    switch (h.lanes = 0, h.tag) {
      case 2:
        var M = h.type;
        Xu(c, h), c = h.pendingProps;
        var _ = $s(h, Sa.current);
        ls(h, B), _ = Ai(null, h, M, c, _, B);
        var U = Vg();
        return h.flags |= 1, typeof _ == "object" && _ !== null && typeof _.render == "function" && _.$$typeof === void 0 ? (h.tag = 1, h.memoizedState = null, h.updateQueue = null, Da(M) ? (U = !0, Xc(h)) : U = !1, h.memoizedState = _.state !== null && _.state !== void 0 ? _.state : null, ri(h), _.updater = RI, h.stateNode = _, _._reactInternals = h, V(h, M, c, B), h = Ki(null, h, M, !0, U, B)) : (h.tag = 0, zr && U && Bp(h), wn(null, h, _, B), h = h.child), h;
      case 16:
        M = h.elementType;
        e: {
          switch (Xu(c, h), c = h.pendingProps, _ = M._init, M = _(M._payload), h.type = M, _ = h.tag = Rf(M), c = ds(M, c), _) {
            case 0:
              h = Sn(null, h, M, c, B);
              break e;
            case 1:
              h = ei(null, h, M, c, B);
              break e;
            case 11:
              h = Oa(null, h, M, c, B);
              break e;
            case 14:
              h = ga(null, h, M, ds(M.type, c), B);
              break e;
          }
          throw Error(t(
            306,
            M,
            ""
          ));
        }
        return h;
      case 0:
        return M = h.type, _ = h.pendingProps, _ = h.elementType === M ? _ : ds(M, _), Sn(c, h, M, _, B);
      case 1:
        return M = h.type, _ = h.pendingProps, _ = h.elementType === M ? _ : ds(M, _), ei(c, h, M, _, B);
      case 3:
        e: {
          if (Vi(h), c === null) throw Error(t(387));
          M = h.pendingProps, U = h.memoizedState, _ = U.element, oo(c, h), ua(h, M, null, B);
          var oe = h.memoizedState;
          if (M = oe.element, U.isDehydrated) if (U = { element: M, isDehydrated: !1, cache: oe.cache, pendingSuspenseBoundaries: oe.pendingSuspenseBoundaries, transitions: oe.transitions }, h.updateQueue.baseState = U, h.memoizedState = U, h.flags & 256) {
            _ = E(Error(t(423)), h), h = cr(c, h, M, B, _);
            break e;
          } else if (M !== _) {
            _ = E(Error(t(424)), h), h = cr(c, h, M, B, _);
            break e;
          } else for (Za = Gl(h.stateNode.containerInfo.firstChild), To = h, zr = !0, Ws = null, B = ao(h, null, M, B), h.child = B; B; ) B.flags = B.flags & -3 | 4096, B = B.sibling;
          else {
            if (Wu(), M === _) {
              h = Is(c, h, B);
              break e;
            }
            wn(c, h, M, B);
          }
          h = h.child;
        }
        return h;
      case 5:
        return Bd(h), c === null && ro(h), M = h.type, _ = h.pendingProps, U = c !== null ? c.memoizedProps : null, oe = _.children, Bg(M, _) ? oe = null : U !== null && Bg(M, U) && (h.flags |= 32), bt(c, h), wn(c, h, oe, B), h.child;
      case 6:
        return c === null && ro(h), null;
      case 13:
        return _c(c, h, B);
      case 4:
        return uC(h, h.stateNode.containerInfo), M = h.pendingProps, c === null ? h.child = el(h, null, M, B) : wn(c, h, M, B), h.child;
      case 11:
        return M = h.type, _ = h.pendingProps, _ = h.elementType === M ? _ : ds(M, _), Oa(c, h, M, _, B);
      case 7:
        return wn(c, h, h.pendingProps, B), h.child;
      case 8:
        return wn(c, h, h.pendingProps.children, B), h.child;
      case 12:
        return wn(c, h, h.pendingProps.children, B), h.child;
      case 10:
        e: {
          if (M = h.type._context, _ = h.pendingProps, U = h.memoizedProps, oe = _.value, ta(yn, M._currentValue), M._currentValue = oe, U !== null) if (Dr(U.value, oe)) {
            if (U.children === _.children && !io.current) {
              h = Is(c, h, B);
              break e;
            }
          } else for (U = h.child, U !== null && (U.return = h); U !== null; ) {
            var xe = U.dependencies;
            if (xe !== null) {
              oe = U.child;
              for (var Le = xe.firstContext; Le !== null; ) {
                if (Le.context === M) {
                  if (U.tag === 1) {
                    Le = ia(-1, B & -B), Le.tag = 2;
                    var It = U.updateQueue;
                    if (It !== null) {
                      It = It.shared;
                      var Ut = It.pending;
                      Ut === null ? Le.next = Le : (Le.next = Ut.next, Ut.next = Le), It.pending = Le;
                    }
                  }
                  U.lanes |= B, Le = U.alternate, Le !== null && (Le.lanes |= B), Wn(
                    U.return,
                    B,
                    h
                  ), xe.lanes |= B;
                  break;
                }
                Le = Le.next;
              }
            } else if (U.tag === 10) oe = U.type === h.type ? null : U.child;
            else if (U.tag === 18) {
              if (oe = U.return, oe === null) throw Error(t(341));
              oe.lanes |= B, xe = oe.alternate, xe !== null && (xe.lanes |= B), Wn(oe, B, h), oe = U.sibling;
            } else oe = U.child;
            if (oe !== null) oe.return = U;
            else for (oe = U; oe !== null; ) {
              if (oe === h) {
                oe = null;
                break;
              }
              if (U = oe.sibling, U !== null) {
                U.return = oe.return, oe = U;
                break;
              }
              oe = oe.return;
            }
            U = oe;
          }
          wn(c, h, _.children, B), h = h.child;
        }
        return h;
      case 9:
        return _ = h.type, M = h.pendingProps.children, ls(h, B), _ = tr(_), M = M(_), h.flags |= 1, wn(c, h, M, B), h.child;
      case 14:
        return M = h.type, _ = ds(M, h.pendingProps), _ = ds(M.type, _), ga(c, h, M, _, B);
      case 15:
        return ot(c, h, h.type, h.pendingProps, B);
      case 17:
        return M = h.type, _ = h.pendingProps, _ = h.elementType === M ? _ : ds(M, _), Xu(c, h), h.tag = 1, Da(M) ? (c = !0, Xc(h)) : c = !1, ls(h, B), m(h, M, _), V(h, M, _, B), Ki(null, h, M, !0, c, B);
      case 19:
        return Vl(c, h, B);
      case 22:
        return Fe(c, h, B);
    }
    throw Error(t(156, h.tag));
  };
  function Sh(c, h) {
    return Ee(c, h);
  }
  function Mv(c, h, B, M) {
    this.tag = c, this.key = B, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = h, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = M, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function kc(c, h, B, M) {
    return new Mv(c, h, B, M);
  }
  function Md(c) {
    return c = c.prototype, !(!c || !c.isReactComponent);
  }
  function Rf(c) {
    if (typeof c == "function") return Md(c) ? 1 : 0;
    if (c != null) {
      if (c = c.$$typeof, c === he) return 11;
      if (c === ke) return 14;
    }
    return 2;
  }
  function SC(c, h) {
    var B = c.alternate;
    return B === null ? (B = kc(c.tag, h, c.key, c.mode), B.elementType = c.elementType, B.type = c.type, B.stateNode = c.stateNode, B.alternate = c, c.alternate = B) : (B.pendingProps = h, B.type = c.type, B.flags = 0, B.subtreeFlags = 0, B.deletions = null), B.flags = c.flags & 14680064, B.childLanes = c.childLanes, B.lanes = c.lanes, B.child = c.child, B.memoizedProps = c.memoizedProps, B.memoizedState = c.memoizedState, B.updateQueue = c.updateQueue, h = c.dependencies, B.dependencies = h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }, B.sibling = c.sibling, B.index = c.index, B.ref = c.ref, B;
  }
  function Zh(c, h, B, M, _, U) {
    var oe = 2;
    if (M = c, typeof c == "function") Md(c) && (oe = 1);
    else if (typeof c == "string") oe = 5;
    else e: switch (c) {
      case L:
        return ll(B.children, _, U, h);
      case j:
        oe = 8, _ |= 8;
        break;
      case J:
        return c = kc(12, B, h, _ | 2), c.elementType = J, c.lanes = U, c;
      case pe:
        return c = kc(13, B, h, _), c.elementType = pe, c.lanes = U, c;
      case Ae:
        return c = kc(19, B, h, _), c.elementType = Ae, c.lanes = U, c;
      case Xe:
        return ma(B, _, U, h);
      default:
        if (typeof c == "object" && c !== null) switch (c.$$typeof) {
          case O:
            oe = 10;
            break e;
          case ne:
            oe = 9;
            break e;
          case he:
            oe = 11;
            break e;
          case ke:
            oe = 14;
            break e;
          case Re:
            oe = 16, M = null;
            break e;
        }
        throw Error(t(130, c == null ? c : typeof c, ""));
    }
    return h = kc(oe, B, h, _), h.elementType = c, h.type = M, h.lanes = U, h;
  }
  function ll(c, h, B, M) {
    return c = kc(7, c, M, h), c.lanes = B, c;
  }
  function ma(c, h, B, M) {
    return c = kc(22, c, M, h), c.elementType = Xe, c.lanes = B, c.stateNode = { isHidden: !1 }, c;
  }
  function Yu(c, h, B) {
    return c = kc(6, c, null, h), c.lanes = B, c;
  }
  function go(c, h, B) {
    return h = kc(4, c.children !== null ? c.children : [], c.key, h), h.lanes = B, h.stateNode = { containerInfo: c.containerInfo, pendingChildren: null, implementation: c.implementation }, h;
  }
  function Ms(c, h, B, M, _) {
    this.tag = h, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ou(0), this.expirationTimes = Ou(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ou(0), this.identifierPrefix = M, this.onRecoverableError = _, this.mutableSourceEagerHydrationData = null;
  }
  function xf(c, h, B, M, _, U, oe, xe, Le) {
    return c = new Ms(c, h, B, xe, Le), h === 1 ? (h = 1, U === !0 && (h |= 8)) : h = 0, U = kc(3, null, null, h), c.current = U, U.stateNode = c, U.memoizedState = { element: M, isDehydrated: B, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ri(U), c;
  }
  function CA(c, h, B) {
    var M = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: D, key: M == null ? null : "" + M, children: c, containerInfo: h, implementation: B };
  }
  function Lb(c) {
    if (!c) return er;
    c = c._reactInternals;
    e: {
      if (Gt(c) !== c || c.tag !== 1) throw Error(t(170));
      var h = c;
      do {
        switch (h.tag) {
          case 3:
            h = h.stateNode.context;
            break e;
          case 1:
            if (Da(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        h = h.return;
      } while (h !== null);
      throw Error(t(171));
    }
    if (c.tag === 1) {
      var B = c.type;
      if (Da(B)) return oC(c, B, h);
    }
    return h;
  }
  function Fn(c, h, B, M, _, U, oe, xe, Le) {
    return c = xf(B, M, !0, c, _, U, oe, xe, Le), c.context = Lb(null), B = c.current, M = da(), _ = ru(B), U = ia(M, _), U.callback = h ?? null, Wa(B, U, _), c.current.lanes = _, od(c, _, M), es(c, M), c;
  }
  function ul(c, h, B, M) {
    var _ = h.current, U = da(), oe = ru(_);
    return B = Lb(B), h.context === null ? h.context = B : h.pendingContext = B, h = ia(U, oe), h.payload = { element: c }, M = M === void 0 ? null : M, M !== null && (h.callback = M), c = Wa(_, h, oe), c !== null && (au(c, _, oe, U), us(c, _, oe)), oe;
  }
  function Wf(c) {
    if (c = c.current, !c.child) return null;
    switch (c.child.tag) {
      case 5:
        return c.child.stateNode;
      default:
        return c.child.stateNode;
    }
  }
  function wh(c, h) {
    if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
      var B = c.retryLane;
      c.retryLane = B !== 0 && B < h ? B : h;
    }
  }
  function XI(c, h) {
    wh(c, h), (c = c.alternate) && wh(c, h);
  }
  function Ia() {
    return null;
  }
  var Hs = typeof reportError == "function" ? reportError : function(c) {
    console.error(c);
  };
  function Na(c) {
    this._internalRoot = c;
  }
  Rh.prototype.render = Na.prototype.render = function(c) {
    var h = this._internalRoot;
    if (h === null) throw Error(t(409));
    ul(c, h, null, null);
  }, Rh.prototype.unmount = Na.prototype.unmount = function() {
    var c = this._internalRoot;
    if (c !== null) {
      this._internalRoot = null;
      var h = c.containerInfo;
      Kc(function() {
        ul(null, c, null, null);
      }), h[Bl] = null;
    }
  };
  function Rh(c) {
    this._internalRoot = c;
  }
  Rh.prototype.unstable_scheduleHydration = function(c) {
    if (c) {
      var h = hu();
      c = { blockedOn: null, target: c, priority: h };
      for (var B = 0; B < Ds.length && h !== 0 && h < Ds[B].priority; B++) ;
      Ds.splice(B, 0, c), B === 0 && sd(c);
    }
  };
  function xh(c) {
    return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11);
  }
  function ZC(c) {
    return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11 && (c.nodeType !== 8 || c.nodeValue !== " react-mount-point-unstable "));
  }
  function kb() {
  }
  function XB(c, h, B, M, _) {
    if (_) {
      if (typeof M == "function") {
        var U = M;
        M = function() {
          var It = Wf(oe);
          U.call(It);
        };
      }
      var oe = Fn(h, M, c, 0, null, !1, !1, "", kb);
      return c._reactRootContainer = oe, c[Bl] = oe.current, Vc(c.nodeType === 8 ? c.parentNode : c), Kc(), oe;
    }
    for (; _ = c.lastChild; ) c.removeChild(_);
    if (typeof M == "function") {
      var xe = M;
      M = function() {
        var It = Wf(Le);
        xe.call(It);
      };
    }
    var Le = xf(c, 0, !1, null, null, !1, !1, "", kb);
    return c._reactRootContainer = Le, c[Bl] = Le.current, Vc(c.nodeType === 8 ? c.parentNode : c), Kc(function() {
      ul(h, Le, B, M);
    }), Le;
  }
  function _t(c, h, B, M, _) {
    var U = B._reactRootContainer;
    if (U) {
      var oe = U;
      if (typeof _ == "function") {
        var xe = _;
        _ = function() {
          var Le = Wf(oe);
          xe.call(Le);
        };
      }
      ul(h, oe, c, _);
    } else oe = XB(B, h, c, _, M);
    return Wf(oe);
  }
  Cu = function(c) {
    switch (c.tag) {
      case 3:
        var h = c.stateNode;
        if (h.current.memoizedState.isDehydrated) {
          var B = or(h.pendingLanes);
          B !== 0 && (Pu(h, B | 1), es(h, Pt()), (Qi & 6) === 0 && (Gf = Pt() + 500, Ua()));
        }
        break;
      case 13:
        Kc(function() {
          var M = Nu(c, 1);
          if (M !== null) {
            var _ = da();
            au(M, c, 1, _);
          }
        }), XI(c, 1);
    }
  }, Hi = function(c) {
    if (c.tag === 13) {
      var h = Nu(c, 134217728);
      if (h !== null) {
        var B = da();
        au(h, c, 134217728, B);
      }
      XI(c, 134217728);
    }
  }, sf = function(c) {
    if (c.tag === 13) {
      var h = ru(c), B = Nu(c, h);
      if (B !== null) {
        var M = da();
        au(B, c, h, M);
      }
      XI(c, h);
    }
  }, hu = function() {
    return sr;
  }, xi = function(c, h) {
    var B = sr;
    try {
      return sr = c, h();
    } finally {
      sr = B;
    }
  }, je = function(c, h, B) {
    switch (h) {
      case "input":
        if (bn(c, B), h = B.name, B.type === "radio" && h != null) {
          for (B = c; B.parentNode; ) B = B.parentNode;
          for (B = B.querySelectorAll("input[name=" + JSON.stringify("" + h) + '][type="radio"]'), h = 0; h < B.length; h++) {
            var M = B[h];
            if (M !== c && M.form === c.form) {
              var _ = Ru(M);
              if (!_) throw Error(t(90));
              ge(M), bn(M, _);
            }
          }
        }
        break;
      case "textarea":
        Bt(c, B);
        break;
      case "select":
        h = B.value, h != null && se(c, !!B.multiple, h, !1);
    }
  }, Jn = Ep, Ii = Kc;
  var dc = { usingClientEntryPoint: !1, Events: [yr, Nn, Ru, di, Di, Ep] }, Dc = { findFiberByHostInstance: yd, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Hv = { bundleType: Dc.bundleType, version: Dc.version, rendererPackageName: Dc.rendererPackageName, rendererConfig: Dc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: T.ReactCurrentDispatcher, findHostInstanceByFiber: function(c) {
    return c = Te(c), c === null ? null : c.stateNode;
  }, findFiberByHostInstance: Dc.findFiberByHostInstance || Ia, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Gr = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Gr.isDisabled && Gr.supportsFiber) try {
      mi = Gr.inject(Hv), xn = Gr;
    } catch {
    }
  }
  return Qd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = dc, Qd.createPortal = function(c, h) {
    var B = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!xh(h)) throw Error(t(200));
    return CA(c, h, null, B);
  }, Qd.createRoot = function(c, h) {
    if (!xh(c)) throw Error(t(299));
    var B = !1, M = "", _ = Hs;
    return h != null && (h.unstable_strictMode === !0 && (B = !0), h.identifierPrefix !== void 0 && (M = h.identifierPrefix), h.onRecoverableError !== void 0 && (_ = h.onRecoverableError)), h = xf(c, 1, !1, null, null, B, !1, M, _), c[Bl] = h.current, Vc(c.nodeType === 8 ? c.parentNode : c), new Na(h);
  }, Qd.findDOMNode = function(c) {
    if (c == null) return null;
    if (c.nodeType === 1) return c;
    var h = c._reactInternals;
    if (h === void 0)
      throw typeof c.render == "function" ? Error(t(188)) : (c = Object.keys(c).join(","), Error(t(268, c)));
    return c = Te(h), c = c === null ? null : c.stateNode, c;
  }, Qd.flushSync = function(c) {
    return Kc(c);
  }, Qd.hydrate = function(c, h, B) {
    if (!ZC(h)) throw Error(t(200));
    return _t(null, c, h, !0, B);
  }, Qd.hydrateRoot = function(c, h, B) {
    if (!xh(c)) throw Error(t(405));
    var M = B != null && B.hydratedSources || null, _ = !1, U = "", oe = Hs;
    if (B != null && (B.unstable_strictMode === !0 && (_ = !0), B.identifierPrefix !== void 0 && (U = B.identifierPrefix), B.onRecoverableError !== void 0 && (oe = B.onRecoverableError)), h = Fn(h, null, c, 1, B ?? null, _, !1, U, oe), c[Bl] = h.current, Vc(c), M) for (c = 0; c < M.length; c++) B = M[c], _ = B._getVersion, _ = _(B._source), h.mutableSourceEagerHydrationData == null ? h.mutableSourceEagerHydrationData = [B, _] : h.mutableSourceEagerHydrationData.push(
      B,
      _
    );
    return new Rh(h);
  }, Qd.render = function(c, h, B) {
    if (!ZC(h)) throw Error(t(200));
    return _t(null, c, h, !1, B);
  }, Qd.unmountComponentAtNode = function(c) {
    if (!ZC(c)) throw Error(t(40));
    return c._reactRootContainer ? (Kc(function() {
      _t(null, null, c, !1, function() {
        c._reactRootContainer = null, c[Bl] = null;
      });
    }), !0) : !1;
  }, Qd.unstable_batchedUpdates = Ep, Qd.unstable_renderSubtreeIntoContainer = function(c, h, B, M) {
    if (!ZC(B)) throw Error(t(200));
    if (c == null || c._reactInternals === void 0) throw Error(t(38));
    return _t(c, h, B, !1, M);
  }, Qd.version = "18.3.1-next-f1338f8080-20240426", Qd;
}
var jd = {}, CT;
function mP() {
  if (CT) return jd;
  CT = 1;
  var r = {};
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return r.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = xb(), t = Az(), n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, i = !1;
    function o(a) {
      i = a;
    }
    function l(a) {
      if (!i) {
        for (var s = arguments.length, p = new Array(s > 1 ? s - 1 : 0), y = 1; y < s; y++)
          p[y - 1] = arguments[y];
        I("warn", a, p);
      }
    }
    function u(a) {
      if (!i) {
        for (var s = arguments.length, p = new Array(s > 1 ? s - 1 : 0), y = 1; y < s; y++)
          p[y - 1] = arguments[y];
        I("error", a, p);
      }
    }
    function I(a, s, p) {
      {
        var y = n.ReactDebugCurrentFrame, Z = y.getStackAddendum();
        Z !== "" && (s += "%s", p = p.concat([Z]));
        var X = p.map(function(K) {
          return String(K);
        });
        X.unshift("Warning: " + s), Function.prototype.apply.call(console[a], console, X);
      }
    }
    var C = 0, f = 1, v = 2, b = 3, S = 4, R = 5, W = 6, x = 7, N = 8, Y = 9, F = 10, T = 11, P = 12, D = 13, L = 14, j = 15, J = 16, O = 17, ne = 18, he = 19, pe = 21, Ae = 22, ke = 23, Re = 24, Xe = 25, re = !0, Se = !1, Be = !1, le = !1, Ye = !1, nt = !0, ze = !0, Je = !0, wt = !0, mt = /* @__PURE__ */ new Set(), Dt = {}, mn = {};
    function An(a, s) {
      Hn(a, s), Hn(a + "Capture", s);
    }
    function Hn(a, s) {
      Dt[a] && u("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", a), Dt[a] = s;
      {
        var p = a.toLowerCase();
        mn[p] = a, a === "onDoubleClick" && (mn.ondblclick = a);
      }
      for (var y = 0; y < s.length; y++)
        mt.add(s[y]);
    }
    var ge = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Wt = Object.prototype.hasOwnProperty;
    function Nt(a) {
      {
        var s = typeof Symbol == "function" && Symbol.toStringTag, p = s && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return p;
      }
    }
    function $t(a) {
      try {
        return ft(a), !1;
      } catch {
        return !0;
      }
    }
    function ft(a) {
      return "" + a;
    }
    function bn(a, s) {
      if ($t(a))
        return u("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Nt(a)), ft(a);
    }
    function en(a) {
      if ($t(a))
        return u("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Nt(a)), ft(a);
    }
    function hn(a, s) {
      if ($t(a))
        return u("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Nt(a)), ft(a);
    }
    function me(a, s) {
      if ($t(a))
        return u("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Nt(a)), ft(a);
    }
    function se(a) {
      if ($t(a))
        return u("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Nt(a)), ft(a);
    }
    function $e(a) {
      if ($t(a))
        return u("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Nt(a)), ft(a);
    }
    var Vt = 0, Bt = 1, Mt = 2, Gn = 3, jt = 4, an = 5, jn = 6, Ot = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", He = Ot + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", vt = new RegExp("^[" + Ot + "][" + He + "]*$"), xt = {}, ht = {};
    function on(a) {
      return Wt.call(ht, a) ? !0 : Wt.call(xt, a) ? !1 : vt.test(a) ? (ht[a] = !0, !0) : (xt[a] = !0, u("Invalid attribute name: `%s`", a), !1);
    }
    function we(a, s, p) {
      return s !== null ? s.type === Vt : p ? !1 : a.length > 2 && (a[0] === "o" || a[0] === "O") && (a[1] === "n" || a[1] === "N");
    }
    function qe(a, s, p, y) {
      if (p !== null && p.type === Vt)
        return !1;
      switch (typeof s) {
        case "function":
        // $FlowIssue symbol is perfectly valid here
        case "symbol":
          return !0;
        case "boolean": {
          if (y)
            return !1;
          if (p !== null)
            return !p.acceptsBooleans;
          var Z = a.toLowerCase().slice(0, 5);
          return Z !== "data-" && Z !== "aria-";
        }
        default:
          return !1;
      }
    }
    function de(a, s, p, y) {
      if (s === null || typeof s > "u" || qe(a, s, p, y))
        return !0;
      if (y)
        return !1;
      if (p !== null)
        switch (p.type) {
          case Gn:
            return !s;
          case jt:
            return s === !1;
          case an:
            return isNaN(s);
          case jn:
            return isNaN(s) || s < 1;
        }
      return !1;
    }
    function it(a) {
      return et.hasOwnProperty(a) ? et[a] : null;
    }
    function je(a, s, p, y, Z, X, K) {
      this.acceptsBooleans = s === Mt || s === Gn || s === jt, this.attributeName = y, this.attributeNamespace = Z, this.mustUseProperty = p, this.propertyName = a, this.type = s, this.sanitizeURL = X, this.removeEmptyString = K;
    }
    var et = {}, Jt = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Jt.forEach(function(a) {
      et[a] = new je(
        a,
        Vt,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var s = a[0], p = a[1];
      et[s] = new je(
        s,
        Bt,
        !1,
        // mustUseProperty
        p,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      et[a] = new je(
        a,
        Mt,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      et[a] = new je(
        a,
        Mt,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(a) {
      et[a] = new je(
        a,
        Gn,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      et[a] = new je(
        a,
        Gn,
        !0,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      et[a] = new je(
        a,
        jt,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      et[a] = new je(
        a,
        jn,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(a) {
      et[a] = new je(
        a,
        an,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Kn = /[\-\:]([a-z])/g, di = function(a) {
      return a[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var s = a.replace(Kn, di);
      et[s] = new je(
        s,
        Bt,
        !1,
        // mustUseProperty
        a,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var s = a.replace(Kn, di);
      et[s] = new je(
        s,
        Bt,
        !1,
        // mustUseProperty
        a,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var s = a.replace(Kn, di);
      et[s] = new je(
        s,
        Bt,
        !1,
        // mustUseProperty
        a,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(a) {
      et[a] = new je(
        a,
        Bt,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Di = "xlinkHref";
    et[Di] = new je(
      "xlinkHref",
      Bt,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(a) {
      et[a] = new je(
        a,
        Bt,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Jn = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Ii = !1;
    function dr(a) {
      !Ii && Jn.test(a) && (Ii = !0, u("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(a)));
    }
    function xr(a, s, p, y) {
      if (y.mustUseProperty) {
        var Z = y.propertyName;
        return a[Z];
      } else {
        bn(p, s), y.sanitizeURL && dr("" + p);
        var X = y.attributeName, K = null;
        if (y.type === jt) {
          if (a.hasAttribute(X)) {
            var Q = a.getAttribute(X);
            return Q === "" ? !0 : de(s, p, y, !1) ? Q : Q === "" + p ? p : Q;
          }
        } else if (a.hasAttribute(X)) {
          if (de(s, p, y, !1))
            return a.getAttribute(X);
          if (y.type === Gn)
            return p;
          K = a.getAttribute(X);
        }
        return de(s, p, y, !1) ? K === null ? p : K : K === "" + p ? p : K;
      }
    }
    function la(a, s, p, y) {
      {
        if (!on(s))
          return;
        if (!a.hasAttribute(s))
          return p === void 0 ? void 0 : null;
        var Z = a.getAttribute(s);
        return bn(p, s), Z === "" + p ? p : Z;
      }
    }
    function Ve(a, s, p, y) {
      var Z = it(s);
      if (!we(s, Z, y)) {
        if (de(s, p, Z, y) && (p = null), y || Z === null) {
          if (on(s)) {
            var X = s;
            p === null ? a.removeAttribute(X) : (bn(p, s), a.setAttribute(X, "" + p));
          }
          return;
        }
        var K = Z.mustUseProperty;
        if (K) {
          var Q = Z.propertyName;
          if (p === null) {
            var te = Z.type;
            a[Q] = te === Gn ? !1 : "";
          } else
            a[Q] = p;
          return;
        }
        var ce = Z.attributeName, Ce = Z.attributeNamespace;
        if (p === null)
          a.removeAttribute(ce);
        else {
          var Qe = Z.type, Pe;
          Qe === Gn || Qe === jt && p === !0 ? Pe = "" : (bn(p, ce), Pe = "" + p, Z.sanitizeURL && dr(Pe.toString())), Ce ? a.setAttributeNS(Ce, ce, Pe) : a.setAttribute(ce, Pe);
        }
      }
    }
    var Oe = Symbol.for("react.element"), rt = Symbol.for("react.portal"), Et = Symbol.for("react.fragment"), gn = Symbol.for("react.strict_mode"), Vn = Symbol.for("react.profiler"), Ln = Symbol.for("react.provider"), Ie = Symbol.for("react.context"), tt = Symbol.for("react.forward_ref"), At = Symbol.for("react.suspense"), Gt = Symbol.for("react.suspense_list"), vn = Symbol.for("react.memo"), ae = Symbol.for("react.lazy"), Ne = Symbol.for("react.scope"), Te = Symbol.for("react.debug_trace_mode"), De = Symbol.for("react.offscreen"), Ee = Symbol.for("react.legacy_hidden"), Tt = Symbol.for("react.cache"), tn = Symbol.for("react.tracing_marker"), Bn = Symbol.iterator, Pt = "@@iterator";
    function Zn(a) {
      if (a === null || typeof a != "object")
        return null;
      var s = Bn && a[Bn] || a[Pt];
      return typeof s == "function" ? s : null;
    }
    var rn = Object.assign, Yn = 0, Fi, Ir, Tn, mi, xn, un, Xn;
    function li() {
    }
    li.__reactDisabledLog = !0;
    function Wr() {
      {
        if (Yn === 0) {
          Fi = console.log, Ir = console.info, Tn = console.warn, mi = console.error, xn = console.group, un = console.groupCollapsed, Xn = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: li,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        Yn++;
      }
    }
    function Xo() {
      {
        if (Yn--, Yn === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: rn({}, a, {
              value: Fi
            }),
            info: rn({}, a, {
              value: Ir
            }),
            warn: rn({}, a, {
              value: Tn
            }),
            error: rn({}, a, {
              value: mi
            }),
            group: rn({}, a, {
              value: xn
            }),
            groupCollapsed: rn({}, a, {
              value: un
            }),
            groupEnd: rn({}, a, {
              value: Xn
            })
          });
        }
        Yn < 0 && u("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var $r = n.ReactCurrentDispatcher, ba;
    function or(a, s, p) {
      {
        if (ba === void 0)
          try {
            throw Error();
          } catch (Z) {
            var y = Z.stack.trim().match(/\n( *(at )?)/);
            ba = y && y[1] || "";
          }
        return `
` + ba + a;
      }
    }
    var za = !1, pl;
    {
      var Xa = typeof WeakMap == "function" ? WeakMap : Map;
      pl = new Xa();
    }
    function bs(a, s) {
      if (!a || za)
        return "";
      {
        var p = pl.get(a);
        if (p !== void 0)
          return p;
      }
      var y;
      za = !0;
      var Z = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var X;
      X = $r.current, $r.current = null, Wr();
      try {
        if (s) {
          var K = function() {
            throw Error();
          };
          if (Object.defineProperty(K.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(K, []);
            } catch (yt) {
              y = yt;
            }
            Reflect.construct(a, [], K);
          } else {
            try {
              K.call();
            } catch (yt) {
              y = yt;
            }
            a.call(K.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (yt) {
            y = yt;
          }
          a();
        }
      } catch (yt) {
        if (yt && y && typeof yt.stack == "string") {
          for (var Q = yt.stack.split(`
`), te = y.stack.split(`
`), ce = Q.length - 1, Ce = te.length - 1; ce >= 1 && Ce >= 0 && Q[ce] !== te[Ce]; )
            Ce--;
          for (; ce >= 1 && Ce >= 0; ce--, Ce--)
            if (Q[ce] !== te[Ce]) {
              if (ce !== 1 || Ce !== 1)
                do
                  if (ce--, Ce--, Ce < 0 || Q[ce] !== te[Ce]) {
                    var Qe = `
` + Q[ce].replace(" at new ", " at ");
                    return a.displayName && Qe.includes("<anonymous>") && (Qe = Qe.replace("<anonymous>", a.displayName)), typeof a == "function" && pl.set(a, Qe), Qe;
                  }
                while (ce >= 1 && Ce >= 0);
              break;
            }
        }
      } finally {
        za = !1, $r.current = X, Xo(), Error.prepareStackTrace = Z;
      }
      var Pe = a ? a.displayName || a.name : "", pt = Pe ? or(Pe) : "";
      return typeof a == "function" && pl.set(a, pt), pt;
    }
    function Ao(a, s, p) {
      return bs(a, !0);
    }
    function Ou(a, s, p) {
      return bs(a, !1);
    }
    function od(a) {
      var s = a.prototype;
      return !!(s && s.isReactComponent);
    }
    function dI(a, s, p) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return bs(a, od(a));
      if (typeof a == "string")
        return or(a);
      switch (a) {
        case At:
          return or("Suspense");
        case Gt:
          return or("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case tt:
            return Ou(a.render);
          case vn:
            return dI(a.type, s, p);
          case ae: {
            var y = a, Z = y._payload, X = y._init;
            try {
              return dI(X(Z), s, p);
            } catch {
            }
          }
        }
      return "";
    }
    function Pu(a) {
      switch (a._debugOwner && a._debugOwner.type, a._debugSource, a.tag) {
        case R:
          return or(a.type);
        case J:
          return or("Lazy");
        case D:
          return or("Suspense");
        case he:
          return or("SuspenseList");
        case C:
        case v:
        case j:
          return Ou(a.type);
        case T:
          return Ou(a.type.render);
        case f:
          return Ao(a.type);
        default:
          return "";
      }
    }
    function sr(a) {
      try {
        var s = "", p = a;
        do
          s += Pu(p), p = p.return;
        while (p);
        return s;
      } catch (y) {
        return `
Error generating stack: ` + y.message + `
` + y.stack;
      }
    }
    function Yo(a, s, p) {
      var y = a.displayName;
      if (y)
        return y;
      var Z = s.displayName || s.name || "";
      return Z !== "" ? p + "(" + Z + ")" : p;
    }
    function Cu(a) {
      return a.displayName || "Context";
    }
    function Hi(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && u("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case Et:
          return "Fragment";
        case rt:
          return "Portal";
        case Vn:
          return "Profiler";
        case gn:
          return "StrictMode";
        case At:
          return "Suspense";
        case Gt:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Ie:
            var s = a;
            return Cu(s) + ".Consumer";
          case Ln:
            var p = a;
            return Cu(p._context) + ".Provider";
          case tt:
            return Yo(a, a.render, "ForwardRef");
          case vn:
            var y = a.displayName || null;
            return y !== null ? y : Hi(a.type) || "Memo";
          case ae: {
            var Z = a, X = Z._payload, K = Z._init;
            try {
              return Hi(K(X));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function sf(a, s, p) {
      var y = s.displayName || s.name || "";
      return a.displayName || (y !== "" ? p + "(" + y + ")" : p);
    }
    function hu(a) {
      return a.displayName || "Context";
    }
    function xi(a) {
      var s = a.tag, p = a.type;
      switch (s) {
        case Re:
          return "Cache";
        case Y:
          var y = p;
          return hu(y) + ".Consumer";
        case F:
          var Z = p;
          return hu(Z._context) + ".Provider";
        case ne:
          return "DehydratedFragment";
        case T:
          return sf(p, p.render, "ForwardRef");
        case x:
          return "Fragment";
        case R:
          return p;
        case S:
          return "Portal";
        case b:
          return "Root";
        case W:
          return "Text";
        case J:
          return Hi(p);
        case N:
          return p === gn ? "StrictMode" : "Mode";
        case Ae:
          return "Offscreen";
        case P:
          return "Profiler";
        case pe:
          return "Scope";
        case D:
          return "Suspense";
        case he:
          return "SuspenseList";
        case Xe:
          return "TracingMarker";
        // The display name for this tags come from the user-provided type:
        case f:
        case C:
        case O:
        case v:
        case L:
        case j:
          if (typeof p == "function")
            return p.displayName || p.name || null;
          if (typeof p == "string")
            return p;
          break;
      }
      return null;
    }
    var Ju = n.ReactDebugCurrentFrame, Po = null, Gs = !1;
    function Bi() {
      {
        if (Po === null)
          return null;
        var a = Po._debugOwner;
        if (a !== null && typeof a < "u")
          return xi(a);
      }
      return null;
    }
    function Qu() {
      return Po === null ? "" : sr(Po);
    }
    function Ra() {
      Ju.getCurrentStack = null, Po = null, Gs = !1;
    }
    function Lr(a) {
      Ju.getCurrentStack = a === null ? null : Qu, Po = a, Gs = !1;
    }
    function Ds() {
      return Po;
    }
    function fu(a) {
      Gs = a;
    }
    function Sr(a) {
      return "" + a;
    }
    function as(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return $e(a), a;
        default:
          return "";
      }
    }
    var Ap = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function sd(a, s) {
      Ap[s.type] || s.onChange || s.onInput || s.readOnly || s.disabled || s.value == null || u("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), s.onChange || s.readOnly || s.disabled || s.checked == null || u("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function II(a) {
      var s = a.type, p = a.nodeName;
      return p && p.toLowerCase() === "input" && (s === "checkbox" || s === "radio");
    }
    function hg(a) {
      return a._valueTracker;
    }
    function Us(a) {
      a._valueTracker = null;
    }
    function CI(a) {
      var s = "";
      return a && (II(a) ? s = a.checked ? "true" : "false" : s = a.value), s;
    }
    function pu(a) {
      var s = II(a) ? "checked" : "value", p = Object.getOwnPropertyDescriptor(a.constructor.prototype, s);
      $e(a[s]);
      var y = "" + a[s];
      if (!(a.hasOwnProperty(s) || typeof p > "u" || typeof p.get != "function" || typeof p.set != "function")) {
        var Z = p.get, X = p.set;
        Object.defineProperty(a, s, {
          configurable: !0,
          get: function() {
            return Z.call(this);
          },
          set: function(Q) {
            $e(Q), y = "" + Q, X.call(this, Q);
          }
        }), Object.defineProperty(a, s, {
          enumerable: p.enumerable
        });
        var K = {
          getValue: function() {
            return y;
          },
          setValue: function(Q) {
            $e(Q), y = "" + Q;
          },
          stopTracking: function() {
            Us(a), delete a[s];
          }
        };
        return K;
      }
    }
    function $a(a) {
      hg(a) || (a._valueTracker = pu(a));
    }
    function Bs(a) {
      if (!a)
        return !1;
      var s = hg(a);
      if (!s)
        return !0;
      var p = s.getValue(), y = CI(a);
      return y !== p ? (s.setValue(y), !0) : !1;
    }
    function Ul(a) {
      if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
        return null;
      try {
        return a.activeElement || a.body;
      } catch {
        return a.body;
      }
    }
    var ld = !1, fg = !1, pg = !1, Os = !1;
    function th(a) {
      var s = a.type === "checkbox" || a.type === "radio";
      return s ? a.checked != null : a.value != null;
    }
    function Ps(a, s) {
      var p = a, y = s.checked, Z = rn({}, s, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: y ?? p._wrapperState.initialChecked
      });
      return Z;
    }
    function hI(a, s) {
      sd("input", s), s.checked !== void 0 && s.defaultChecked !== void 0 && !fg && (u("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Bi() || "A component", s.type), fg = !0), s.value !== void 0 && s.defaultValue !== void 0 && !ld && (u("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Bi() || "A component", s.type), ld = !0);
      var p = a, y = s.defaultValue == null ? "" : s.defaultValue;
      p._wrapperState = {
        initialChecked: s.checked != null ? s.checked : s.defaultChecked,
        initialValue: as(s.value != null ? s.value : y),
        controlled: th(s)
      };
    }
    function ie(a, s) {
      var p = a, y = s.checked;
      y != null && Ve(p, "checked", y, !1);
    }
    function Me(a, s) {
      var p = a;
      {
        var y = th(s);
        !p._wrapperState.controlled && y && !Os && (u("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Os = !0), p._wrapperState.controlled && !y && !pg && (u("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), pg = !0);
      }
      ie(a, s);
      var Z = as(s.value), X = s.type;
      if (Z != null)
        X === "number" ? (Z === 0 && p.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        p.value != Z) && (p.value = Sr(Z)) : p.value !== Sr(Z) && (p.value = Sr(Z));
      else if (X === "submit" || X === "reset") {
        p.removeAttribute("value");
        return;
      }
      s.hasOwnProperty("value") ? qn(p, s.type, Z) : s.hasOwnProperty("defaultValue") && qn(p, s.type, as(s.defaultValue)), s.checked == null && s.defaultChecked != null && (p.defaultChecked = !!s.defaultChecked);
    }
    function gt(a, s, p) {
      var y = a;
      if (s.hasOwnProperty("value") || s.hasOwnProperty("defaultValue")) {
        var Z = s.type, X = Z === "submit" || Z === "reset";
        if (X && (s.value === void 0 || s.value === null))
          return;
        var K = Sr(y._wrapperState.initialValue);
        p || K !== y.value && (y.value = K), y.defaultValue = K;
      }
      var Q = y.name;
      Q !== "" && (y.name = ""), y.defaultChecked = !y.defaultChecked, y.defaultChecked = !!y._wrapperState.initialChecked, Q !== "" && (y.name = Q);
    }
    function St(a, s) {
      var p = a;
      Me(p, s), dn(p, s);
    }
    function dn(a, s) {
      var p = s.name;
      if (s.type === "radio" && p != null) {
        for (var y = a; y.parentNode; )
          y = y.parentNode;
        bn(p, "name");
        for (var Z = y.querySelectorAll("input[name=" + JSON.stringify("" + p) + '][type="radio"]'), X = 0; X < Z.length; X++) {
          var K = Z[X];
          if (!(K === a || K.form !== a.form)) {
            var Q = y0(K);
            if (!Q)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Bs(K), Me(K, Q);
          }
        }
      }
    }
    function qn(a, s, p) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (s !== "number" || Ul(a.ownerDocument) !== a) && (p == null ? a.defaultValue = Sr(a._wrapperState.initialValue) : a.defaultValue !== Sr(p) && (a.defaultValue = Sr(p)));
    }
    var _n = !1, Si = !1, Ui = !1;
    function ur(a, s) {
      s.value == null && (typeof s.children == "object" && s.children !== null ? e.Children.forEach(s.children, function(p) {
        p != null && (typeof p == "string" || typeof p == "number" || Si || (Si = !0, u("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : s.dangerouslySetInnerHTML != null && (Ui || (Ui = !0, u("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), s.selected != null && !_n && (u("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), _n = !0);
    }
    function nr(a, s) {
      s.value != null && a.setAttribute("value", Sr(as(s.value)));
    }
    var $i = Array.isArray;
    function Zi(a) {
      return $i(a);
    }
    var kr;
    kr = !1;
    function Ka() {
      var a = Bi();
      return a ? `

Check the render method of \`` + a + "`." : "";
    }
    var Js = ["value", "defaultValue"];
    function mu(a) {
      {
        sd("select", a);
        for (var s = 0; s < Js.length; s++) {
          var p = Js[s];
          if (a[p] != null) {
            var y = Zi(a[p]);
            a.multiple && !y ? u("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", p, Ka()) : !a.multiple && y && u("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", p, Ka());
          }
        }
      }
    }
    function Au(a, s, p, y) {
      var Z = a.options;
      if (s) {
        for (var X = p, K = {}, Q = 0; Q < X.length; Q++)
          K["$" + X[Q]] = !0;
        for (var te = 0; te < Z.length; te++) {
          var ce = K.hasOwnProperty("$" + Z[te].value);
          Z[te].selected !== ce && (Z[te].selected = ce), ce && y && (Z[te].defaultSelected = !0);
        }
      } else {
        for (var Ce = Sr(as(p)), Qe = null, Pe = 0; Pe < Z.length; Pe++) {
          if (Z[Pe].value === Ce) {
            Z[Pe].selected = !0, y && (Z[Pe].defaultSelected = !0);
            return;
          }
          Qe === null && !Z[Pe].disabled && (Qe = Z[Pe]);
        }
        Qe !== null && (Qe.selected = !0);
      }
    }
    function ud(a, s) {
      return rn({}, s, {
        value: void 0
      });
    }
    function mg(a, s) {
      var p = a;
      mu(s), p._wrapperState = {
        wasMultiple: !!s.multiple
      }, s.value !== void 0 && s.defaultValue !== void 0 && !kr && (u("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), kr = !0);
    }
    function lf(a, s) {
      var p = a;
      p.multiple = !!s.multiple;
      var y = s.value;
      y != null ? Au(p, !!s.multiple, y, !1) : s.defaultValue != null && Au(p, !!s.multiple, s.defaultValue, !0);
    }
    function nh(a, s) {
      var p = a, y = p._wrapperState.wasMultiple;
      p._wrapperState.wasMultiple = !!s.multiple;
      var Z = s.value;
      Z != null ? Au(p, !!s.multiple, Z, !1) : y !== !!s.multiple && (s.defaultValue != null ? Au(p, !!s.multiple, s.defaultValue, !0) : Au(p, !!s.multiple, s.multiple ? [] : "", !1));
    }
    function ih(a, s) {
      var p = a, y = s.value;
      y != null && Au(p, !!s.multiple, y, !1);
    }
    var rh = !1;
    function ah(a, s) {
      var p = a;
      if (s.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var y = rn({}, s, {
        value: void 0,
        defaultValue: void 0,
        children: Sr(p._wrapperState.initialValue)
      });
      return y;
    }
    function vp(a, s) {
      var p = a;
      sd("textarea", s), s.value !== void 0 && s.defaultValue !== void 0 && !rh && (u("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Bi() || "A component"), rh = !0);
      var y = s.value;
      if (y == null) {
        var Z = s.children, X = s.defaultValue;
        if (Z != null) {
          u("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (X != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Zi(Z)) {
              if (Z.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              Z = Z[0];
            }
            X = Z;
          }
        }
        X == null && (X = ""), y = X;
      }
      p._wrapperState = {
        initialValue: as(y)
      };
    }
    function yp(a, s) {
      var p = a, y = as(s.value), Z = as(s.defaultValue);
      if (y != null) {
        var X = Sr(y);
        X !== p.value && (p.value = X), s.defaultValue == null && p.defaultValue !== X && (p.defaultValue = X);
      }
      Z != null && (p.defaultValue = Sr(Z));
    }
    function uf(a, s) {
      var p = a, y = p.textContent;
      y === p._wrapperState.initialValue && y !== "" && y !== null && (p.value = y);
    }
    function qI(a, s) {
      yp(a, s);
    }
    var Ss = "http://www.w3.org/1999/xhtml", cf = "http://www.w3.org/1998/Math/MathML", $I = "http://www.w3.org/2000/svg";
    function ml(a) {
      switch (a) {
        case "svg":
          return $I;
        case "math":
          return cf;
        default:
          return Ss;
      }
    }
    function Qs(a, s) {
      return a == null || a === Ss ? ml(s) : a === $I && s === "foreignObject" ? Ss : a;
    }
    var fI = function(a) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(s, p, y, Z) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(s, p, y, Z);
        });
      } : a;
    }, vu, xc = fI(function(a, s) {
      if (a.namespaceURI === $I && !("innerHTML" in a)) {
        vu = vu || document.createElement("div"), vu.innerHTML = "<svg>" + s.valueOf().toString() + "</svg>";
        for (var p = vu.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; p.firstChild; )
          a.appendChild(p.firstChild);
        return;
      }
      a.innerHTML = s;
    }), vo = 1, Wc = 3, ha = 8, yu = 9, Jo = 11, eo = function(a, s) {
      if (s) {
        var p = a.firstChild;
        if (p && p === a.lastChild && p.nodeType === Wc) {
          p.nodeValue = s;
          return;
        }
      }
      a.textContent = s;
    }, Ga = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, ju = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ol(a, s) {
      return a + s.charAt(0).toUpperCase() + s.substring(1);
    }
    var gf = ["Webkit", "ms", "Moz", "O"];
    Object.keys(ju).forEach(function(a) {
      gf.forEach(function(s) {
        ju[Ol(s, a)] = ju[a];
      });
    });
    function eC(a, s, p) {
      var y = s == null || typeof s == "boolean" || s === "";
      return y ? "" : !p && typeof s == "number" && s !== 0 && !(ju.hasOwnProperty(a) && ju[a]) ? s + "px" : (me(s, a), ("" + s).trim());
    }
    var df = /([A-Z])/g, cd = /^ms-/;
    function If(a) {
      return a.replace(df, "-$1").toLowerCase().replace(cd, "-ms-");
    }
    var gd = function() {
    };
    {
      var Pl = /^(?:webkit|moz|o)[A-Z]/, tC = /^-ms-/, Ag = /-(.)/g, vg = /;\s*$/, Jl = {}, Cf = {}, bu = !1, bp = !1, dd = function(a) {
        return a.replace(Ag, function(s, p) {
          return p.toUpperCase();
        });
      }, js = function(a) {
        Jl.hasOwnProperty(a) && Jl[a] || (Jl[a] = !0, u(
          "Unsupported style property %s. Did you mean %s?",
          a,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          dd(a.replace(tC, "ms-"))
        ));
      }, Id = function(a) {
        Jl.hasOwnProperty(a) && Jl[a] || (Jl[a] = !0, u("Unsupported vendor-prefixed style property %s. Did you mean %s?", a, a.charAt(0).toUpperCase() + a.slice(1)));
      }, Cd = function(a, s) {
        Cf.hasOwnProperty(s) && Cf[s] || (Cf[s] = !0, u(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, a, s.replace(vg, "")));
      }, Al = function(a, s) {
        bu || (bu = !0, u("`NaN` is an invalid value for the `%s` css style property.", a));
      }, vl = function(a, s) {
        bp || (bp = !0, u("`Infinity` is an invalid value for the `%s` css style property.", a));
      };
      gd = function(a, s) {
        a.indexOf("-") > -1 ? js(a) : Pl.test(a) ? Id(a) : vg.test(s) && Cd(a, s), typeof s == "number" && (isNaN(s) ? Al(a, s) : isFinite(s) || vl(a, s));
      };
    }
    var hd = gd;
    function oh(a) {
      {
        var s = "", p = "";
        for (var y in a)
          if (a.hasOwnProperty(y)) {
            var Z = a[y];
            if (Z != null) {
              var X = y.indexOf("--") === 0;
              s += p + (X ? y : If(y)) + ":", s += eC(y, Z, X), p = ";";
            }
          }
        return s || null;
      }
    }
    function Gu(a, s) {
      var p = a.style;
      for (var y in s)
        if (s.hasOwnProperty(y)) {
          var Z = y.indexOf("--") === 0;
          Z || hd(y, s[y]);
          var X = eC(y, s[y], Z);
          y === "float" && (y = "cssFloat"), Z ? p.setProperty(y, X) : p[y] = X;
        }
    }
    function Tr(a) {
      return a == null || typeof a == "boolean" || a === "";
    }
    function yo(a) {
      var s = {};
      for (var p in a)
        for (var y = Ga[p] || [p], Z = 0; Z < y.length; Z++)
          s[y[Z]] = p;
      return s;
    }
    function Dr(a, s) {
      {
        if (!s)
          return;
        var p = yo(a), y = yo(s), Z = {};
        for (var X in p) {
          var K = p[X], Q = y[X];
          if (Q && K !== Q) {
            var te = K + "," + Q;
            if (Z[te])
              continue;
            Z[te] = !0, u("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Tr(a[K]) ? "Removing" : "Updating", K, Q);
          }
        }
      }
    }
    var yg = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, os = rn({
      menuitem: !0
    }, yg), to = "__html";
    function Qo(a, s) {
      if (s) {
        if (os[a] && (s.children != null || s.dangerouslySetInnerHTML != null))
          throw new Error(a + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (s.dangerouslySetInnerHTML != null) {
          if (s.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof s.dangerouslySetInnerHTML != "object" || !(to in s.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!s.suppressContentEditableWarning && s.contentEditable && s.children != null && u("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), s.style != null && typeof s.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Hr(a, s) {
      if (a.indexOf("-") === -1)
        return typeof s.is == "string";
      switch (a) {
        // These are reserved SVG and MathML elements.
        // We don't mind this list too much because we expect it to never grow.
        // The alternative is to track the namespace in a few places which is convoluted.
        // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var fa = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, bo = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, yl = {}, Ql = new RegExp("^(aria)-[" + He + "]*$"), Zs = new RegExp("^(aria)[A-Z][" + He + "]*$");
    function fd(a, s) {
      {
        if (Wt.call(yl, s) && yl[s])
          return !0;
        if (Zs.test(s)) {
          var p = "aria-" + s.slice(4).toLowerCase(), y = bo.hasOwnProperty(p) ? p : null;
          if (y == null)
            return u("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", s), yl[s] = !0, !0;
          if (s !== y)
            return u("Invalid ARIA attribute `%s`. Did you mean `%s`?", s, y), yl[s] = !0, !0;
        }
        if (Ql.test(s)) {
          var Z = s.toLowerCase(), X = bo.hasOwnProperty(Z) ? Z : null;
          if (X == null)
            return yl[s] = !0, !1;
          if (s !== X)
            return u("Unknown ARIA attribute `%s`. Did you mean `%s`?", s, X), yl[s] = !0, !0;
        }
      }
      return !0;
    }
    function Go(a, s) {
      {
        var p = [];
        for (var y in s) {
          var Z = fd(a, y);
          Z || p.push(y);
        }
        var X = p.map(function(K) {
          return "`" + K + "`";
        }).join(", ");
        p.length === 1 ? u("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", X, a) : p.length > 1 && u("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", X, a);
      }
    }
    function sh(a, s) {
      Hr(a, s) || Go(a, s);
    }
    var pd = !1;
    function qu(a, s) {
      {
        if (a !== "input" && a !== "textarea" && a !== "select")
          return;
        s != null && s.value === null && !pd && (pd = !0, a === "select" && s.multiple ? u("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", a) : u("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", a));
      }
    }
    var jl = function() {
    };
    {
      var Ba = {}, ws = /^on./, nC = /^on[^A-Z]/, wi = new RegExp("^(aria)-[" + He + "]*$"), _r = new RegExp("^(aria)[A-Z][" + He + "]*$");
      jl = function(a, s, p, y) {
        if (Wt.call(Ba, s) && Ba[s])
          return !0;
        var Z = s.toLowerCase();
        if (Z === "onfocusin" || Z === "onfocusout")
          return u("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Ba[s] = !0, !0;
        if (y != null) {
          var X = y.registrationNameDependencies, K = y.possibleRegistrationNames;
          if (X.hasOwnProperty(s))
            return !0;
          var Q = K.hasOwnProperty(Z) ? K[Z] : null;
          if (Q != null)
            return u("Invalid event handler property `%s`. Did you mean `%s`?", s, Q), Ba[s] = !0, !0;
          if (ws.test(s))
            return u("Unknown event handler property `%s`. It will be ignored.", s), Ba[s] = !0, !0;
        } else if (ws.test(s))
          return nC.test(s) && u("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", s), Ba[s] = !0, !0;
        if (wi.test(s) || _r.test(s))
          return !0;
        if (Z === "innerhtml")
          return u("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Ba[s] = !0, !0;
        if (Z === "aria")
          return u("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Ba[s] = !0, !0;
        if (Z === "is" && p !== null && p !== void 0 && typeof p != "string")
          return u("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof p), Ba[s] = !0, !0;
        if (typeof p == "number" && isNaN(p))
          return u("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", s), Ba[s] = !0, !0;
        var te = it(s), ce = te !== null && te.type === Vt;
        if (fa.hasOwnProperty(Z)) {
          var Ce = fa[Z];
          if (Ce !== s)
            return u("Invalid DOM property `%s`. Did you mean `%s`?", s, Ce), Ba[s] = !0, !0;
        } else if (!ce && s !== Z)
          return u("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", s, Z), Ba[s] = !0, !0;
        return typeof p == "boolean" && qe(s, p, te, !1) ? (p ? u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', p, s, s, p, s) : u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', p, s, s, p, s, s, s), Ba[s] = !0, !0) : ce ? !0 : qe(s, p, te, !1) ? (Ba[s] = !0, !1) : ((p === "false" || p === "true") && te !== null && te.type === Gn && (u("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", p, s, p === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', s, p), Ba[s] = !0), !0);
      };
    }
    var vr = function(a, s, p) {
      {
        var y = [];
        for (var Z in s) {
          var X = jl(a, Z, s[Z], p);
          X || y.push(Z);
        }
        var K = y.map(function(Q) {
          return "`" + Q + "`";
        }).join(", ");
        y.length === 1 ? u("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", K, a) : y.length > 1 && u("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", K, a);
      }
    };
    function La(a, s, p) {
      Hr(a, s) || vr(a, s, p);
    }
    var ql = 1, Bu = 2, md = 4, lh = ql | Bu | md, bg = null;
    function hf(a) {
      bg !== null && u("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), bg = a;
    }
    function Qt() {
      bg === null && u("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), bg = null;
    }
    function no(a) {
      return a === bg;
    }
    function ji(a) {
      var s = a.target || a.srcElement || window;
      return s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === Wc ? s.parentNode : s;
    }
    var $l = null, lr = null, qs = null;
    function bl(a) {
      var s = Cs(a);
      if (s) {
        if (typeof $l != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var p = s.stateNode;
        if (p) {
          var y = y0(p);
          $l(s.stateNode, s.type, y);
        }
      }
    }
    function Vc(a) {
      $l = a;
    }
    function Nc(a) {
      lr ? qs ? qs.push(a) : qs = [a] : lr = a;
    }
    function Ad() {
      return lr !== null || qs !== null;
    }
    function Gg() {
      if (lr) {
        var a = lr, s = qs;
        if (lr = null, qs = null, bl(a), s)
          for (var p = 0; p < s.length; p++)
            bl(s[p]);
      }
    }
    var pI = function(a, s) {
      return a(s);
    }, Mc = function() {
    }, iC = !1;
    function Gp() {
      var a = Ad();
      a && (Mc(), Gg());
    }
    function uh(a, s, p) {
      if (iC)
        return a(s, p);
      iC = !0;
      try {
        return pI(a, s, p);
      } finally {
        iC = !1, Gp();
      }
    }
    function ch(a, s, p) {
      pI = a, Mc = p;
    }
    function mI(a) {
      return a === "button" || a === "input" || a === "select" || a === "textarea";
    }
    function AI(a, s, p) {
      switch (a) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(p.disabled && mI(s));
        default:
          return !1;
      }
    }
    function Su(a, s) {
      var p = a.stateNode;
      if (p === null)
        return null;
      var y = y0(p);
      if (y === null)
        return null;
      var Z = y[s];
      if (AI(s, a.type, y))
        return null;
      if (Z && typeof Z != "function")
        throw new Error("Expected `" + s + "` listener to be a function, instead got a value of `" + typeof Z + "` type.");
      return Z;
    }
    var vI = !1;
    if (ge)
      try {
        var Bg = {};
        Object.defineProperty(Bg, "passive", {
          get: function() {
            vI = !0;
          }
        }), window.addEventListener("test", Bg, Bg), window.removeEventListener("test", Bg, Bg);
      } catch {
        vI = !1;
      }
    function rC(a, s, p, y, Z, X, K, Q, te) {
      var ce = Array.prototype.slice.call(arguments, 3);
      try {
        s.apply(p, ce);
      } catch (Ce) {
        this.onError(Ce);
      }
    }
    var aC = rC;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var vd = document.createElement("react");
      aC = function(s, p, y, Z, X, K, Q, te, ce) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Ce = document.createEvent("Event"), Qe = !1, Pe = !0, pt = window.event, yt = Object.getOwnPropertyDescriptor(window, "event");
        function Yt() {
          vd.removeEventListener(Ft, Ri, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = pt);
        }
        var On = Array.prototype.slice.call(arguments, 3);
        function Ri() {
          Qe = !0, Yt(), p.apply(y, On), Pe = !1;
        }
        var hi, Er = !1, Rr = !1;
        function ut(ct) {
          if (hi = ct.error, Er = !0, hi === null && ct.colno === 0 && ct.lineno === 0 && (Rr = !0), ct.defaultPrevented && hi != null && typeof hi == "object")
            try {
              hi._suppressLogging = !0;
            } catch {
            }
        }
        var Ft = "react-" + (s || "invokeguardedcallback");
        if (window.addEventListener("error", ut), vd.addEventListener(Ft, Ri, !1), Ce.initEvent(Ft, !1, !1), vd.dispatchEvent(Ce), yt && Object.defineProperty(window, "event", yt), Qe && Pe && (Er ? Rr && (hi = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : hi = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(hi)), window.removeEventListener("error", ut), !Qe)
          return Yt(), rC.apply(this, arguments);
      };
    }
    var ff = aC, Zu = !1, Sg = null, Gl = !1, yI = null, Zg = {
      onError: function(a) {
        Zu = !0, Sg = a;
      }
    };
    function ka(a, s, p, y, Z, X, K, Q, te) {
      Zu = !1, Sg = null, ff.apply(Zg, arguments);
    }
    function Hc(a, s, p, y, Z, X, K, Q, te) {
      if (ka.apply(this, arguments), Zu) {
        var ce = wu();
        Gl || (Gl = !0, yI = ce);
      }
    }
    function Bl() {
      if (Gl) {
        var a = yI;
        throw Gl = !1, yI = null, a;
      }
    }
    function $u() {
      return Zu;
    }
    function wu() {
      if (Zu) {
        var a = Sg;
        return Zu = !1, Sg = null, a;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Bo(a) {
      return a._reactInternals;
    }
    function yd(a) {
      return a._reactInternals !== void 0;
    }
    function yr(a, s) {
      a._reactInternals = s;
    }
    var Nn = (
      /*                      */
      0
    ), Ru = (
      /*                */
      1
    ), xa = (
      /*                    */
      2
    ), pi = (
      /*                       */
      4
    ), ea = (
      /*                */
      16
    ), Ur = (
      /*                 */
      32
    ), ta = (
      /*                     */
      64
    ), er = (
      /*                   */
      128
    ), Sa = (
      /*            */
      256
    ), io = (
      /*                          */
      512
    ), Rs = (
      /*                     */
      1024
    ), $s = (
      /*                      */
      2048
    ), Da = (
      /*                    */
      4096
    ), Sl = (
      /*                   */
      8192
    ), gh = (
      /*             */
      16384
    ), oC = (
      /*               */
      32767
    ), Xc = (
      /*                   */
      32768
    ), eu = (
      /*                */
      65536
    ), Fo = (
      /* */
      131072
    ), Yc = (
      /*                       */
      1048576
    ), xu = (
      /*                    */
      2097152
    ), tu = (
      /*                 */
      4194304
    ), xs = (
      /*                */
      8388608
    ), Ua = (
      /*               */
      16777216
    ), Wi = (
      /*              */
      33554432
    ), Eo = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      pi | Rs | 0
    ), bI = xa | pi | ea | Ur | io | Da | Sl, GI = pi | ta | io | Sl, So = $s | ea, na = tu | xs | xu, ec = n.ReactCurrentOwner;
    function fn(a) {
      var s = a, p = a;
      if (a.alternate)
        for (; s.return; )
          s = s.return;
      else {
        var y = s;
        do
          s = y, (s.flags & (xa | Da)) !== Nn && (p = s.return), y = s.return;
        while (y);
      }
      return s.tag === b ? p : null;
    }
    function Zl(a) {
      if (a.tag === D) {
        var s = a.memoizedState;
        if (s === null) {
          var p = a.alternate;
          p !== null && (s = p.memoizedState);
        }
        if (s !== null)
          return s.dehydrated;
      }
      return null;
    }
    function Fc(a) {
      return a.tag === b ? a.stateNode.containerInfo : null;
    }
    function dh(a) {
      return fn(a) === a;
    }
    function Bp(a) {
      {
        var s = ec.current;
        if (s !== null && s.tag === f) {
          var p = s, y = p.stateNode;
          y._warnedAboutRefsInRender || u("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", xi(p) || "A component"), y._warnedAboutRefsInRender = !0;
        }
      }
      var Z = Bo(a);
      return Z ? fn(Z) === Z : !1;
    }
    function tc(a) {
      if (fn(a) !== a)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function To(a) {
      var s = a.alternate;
      if (!s) {
        var p = fn(a);
        if (p === null)
          throw new Error("Unable to find node on an unmounted component.");
        return p !== a ? null : a;
      }
      for (var y = a, Z = s; ; ) {
        var X = y.return;
        if (X === null)
          break;
        var K = X.alternate;
        if (K === null) {
          var Q = X.return;
          if (Q !== null) {
            y = Z = Q;
            continue;
          }
          break;
        }
        if (X.child === K.child) {
          for (var te = X.child; te; ) {
            if (te === y)
              return tc(X), a;
            if (te === Z)
              return tc(X), s;
            te = te.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (y.return !== Z.return)
          y = X, Z = K;
        else {
          for (var ce = !1, Ce = X.child; Ce; ) {
            if (Ce === y) {
              ce = !0, y = X, Z = K;
              break;
            }
            if (Ce === Z) {
              ce = !0, Z = X, y = K;
              break;
            }
            Ce = Ce.sibling;
          }
          if (!ce) {
            for (Ce = K.child; Ce; ) {
              if (Ce === y) {
                ce = !0, y = K, Z = X;
                break;
              }
              if (Ce === Z) {
                ce = !0, Z = K, y = X;
                break;
              }
              Ce = Ce.sibling;
            }
            if (!ce)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (y.alternate !== Z)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (y.tag !== b)
        throw new Error("Unable to find node on an unmounted component.");
      return y.stateNode.current === y ? a : s;
    }
    function Za(a) {
      var s = To(a);
      return s !== null ? zr(s) : null;
    }
    function zr(a) {
      if (a.tag === R || a.tag === W)
        return a;
      for (var s = a.child; s !== null; ) {
        var p = zr(s);
        if (p !== null)
          return p;
        s = s.sibling;
      }
      return null;
    }
    function Ws(a) {
      var s = To(a);
      return s !== null ? sC(s) : null;
    }
    function sC(a) {
      if (a.tag === R || a.tag === W)
        return a;
      for (var s = a.child; s !== null; ) {
        if (s.tag !== S) {
          var p = sC(s);
          if (p !== null)
            return p;
        }
        s = s.sibling;
      }
      return null;
    }
    var bd = t.unstable_scheduleCallback, wl = t.unstable_cancelCallback, ro = t.unstable_shouldYield, pf = t.unstable_requestPaint, Ya = t.unstable_now, Sp = t.unstable_getCurrentPriorityLevel, Wu = t.unstable_ImmediatePriority, wg = t.unstable_UserBlockingPriority, Gd = t.unstable_NormalPriority, Ih = t.unstable_LowPriority, BI = t.unstable_IdlePriority, Zp = t.unstable_yieldValue, Zo = t.unstable_setDisableYieldValue, el = null, ao = null, yn = null, ss = !1, _o = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function lC(a) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var s = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (s.isDisabled)
        return !0;
      if (!s.supportsFiber)
        return u("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        ze && (a = rn({}, a, {
          getLaneLabelMap: wp,
          injectProfilingHooks: Rg
        })), el = s.inject(a), ao = s;
      } catch (p) {
        u("React instrumentation encountered an error: %s.", p);
      }
      return !!s.checkDCE;
    }
    function Vu(a, s) {
      if (ao && typeof ao.onScheduleFiberRoot == "function")
        try {
          ao.onScheduleFiberRoot(el, a, s);
        } catch (p) {
          ss || (ss = !0, u("React instrumentation encountered an error: %s", p));
        }
    }
    function wo(a, s) {
      if (ao && typeof ao.onCommitFiberRoot == "function")
        try {
          var p = (a.current.flags & er) === er;
          if (Je) {
            var y;
            switch (s) {
              case Vl:
                y = Wu;
                break;
              case Xu:
                y = wg;
                break;
              case Is:
                y = Gd;
                break;
              case Af:
                y = BI;
                break;
              default:
                y = Gd;
                break;
            }
            ao.onCommitFiberRoot(el, a, y, p);
          }
        } catch (Z) {
          ss || (ss = !0, u("React instrumentation encountered an error: %s", Z));
        }
    }
    function Wn(a) {
      if (ao && typeof ao.onPostCommitFiberRoot == "function")
        try {
          ao.onPostCommitFiberRoot(el, a);
        } catch (s) {
          ss || (ss = !0, u("React instrumentation encountered an error: %s", s));
        }
    }
    function ls(a) {
      if (ao && typeof ao.onCommitFiberUnmount == "function")
        try {
          ao.onCommitFiberUnmount(el, a);
        } catch (s) {
          ss || (ss = !0, u("React instrumentation encountered an error: %s", s));
        }
    }
    function tr(a) {
      if (typeof Zp == "function" && (Zo(a), o(a)), ao && typeof ao.setStrictMode == "function")
        try {
          ao.setStrictMode(el, a);
        } catch (s) {
          ss || (ss = !0, u("React instrumentation encountered an error: %s", s));
        }
    }
    function Rg(a) {
      yn = a;
    }
    function wp() {
      {
        for (var a = /* @__PURE__ */ new Map(), s = 1, p = 0; p < jo; p++) {
          var y = Wl(s);
          a.set(s, y), s *= 2;
        }
        return a;
      }
    }
    function Ch(a) {
      yn !== null && typeof yn.markCommitStarted == "function" && yn.markCommitStarted(a);
    }
    function Nu() {
      yn !== null && typeof yn.markCommitStopped == "function" && yn.markCommitStopped();
    }
    function Vr(a) {
      yn !== null && typeof yn.markComponentRenderStarted == "function" && yn.markComponentRenderStarted(a);
    }
    function ri() {
      yn !== null && typeof yn.markComponentRenderStopped == "function" && yn.markComponentRenderStopped();
    }
    function oo(a) {
      yn !== null && typeof yn.markComponentPassiveEffectMountStarted == "function" && yn.markComponentPassiveEffectMountStarted(a);
    }
    function ia() {
      yn !== null && typeof yn.markComponentPassiveEffectMountStopped == "function" && yn.markComponentPassiveEffectMountStopped();
    }
    function Wa(a) {
      yn !== null && typeof yn.markComponentPassiveEffectUnmountStarted == "function" && yn.markComponentPassiveEffectUnmountStarted(a);
    }
    function us() {
      yn !== null && typeof yn.markComponentPassiveEffectUnmountStopped == "function" && yn.markComponentPassiveEffectUnmountStopped();
    }
    function nc(a) {
      yn !== null && typeof yn.markComponentLayoutEffectMountStarted == "function" && yn.markComponentLayoutEffectMountStarted(a);
    }
    function ua() {
      yn !== null && typeof yn.markComponentLayoutEffectMountStopped == "function" && yn.markComponentLayoutEffectMountStopped();
    }
    function SI(a) {
      yn !== null && typeof yn.markComponentLayoutEffectUnmountStarted == "function" && yn.markComponentLayoutEffectUnmountStarted(a);
    }
    function ic() {
      yn !== null && typeof yn.markComponentLayoutEffectUnmountStopped == "function" && yn.markComponentLayoutEffectUnmountStopped();
    }
    function nu(a, s, p) {
      yn !== null && typeof yn.markComponentErrored == "function" && yn.markComponentErrored(a, s, p);
    }
    function ZI(a, s, p) {
      yn !== null && typeof yn.markComponentSuspended == "function" && yn.markComponentSuspended(a, s, p);
    }
    function xg(a) {
      yn !== null && typeof yn.markLayoutEffectsStarted == "function" && yn.markLayoutEffectsStarted(a);
    }
    function Ro() {
      yn !== null && typeof yn.markLayoutEffectsStopped == "function" && yn.markLayoutEffectsStopped();
    }
    function uC(a) {
      yn !== null && typeof yn.markPassiveEffectsStarted == "function" && yn.markPassiveEffectsStarted(a);
    }
    function Wg() {
      yn !== null && typeof yn.markPassiveEffectsStopped == "function" && yn.markPassiveEffectsStopped();
    }
    function Bd(a) {
      yn !== null && typeof yn.markRenderStarted == "function" && yn.markRenderStarted(a);
    }
    function cC() {
      yn !== null && typeof yn.markRenderYielded == "function" && yn.markRenderYielded();
    }
    function pa() {
      yn !== null && typeof yn.markRenderStopped == "function" && yn.markRenderStopped();
    }
    function rc(a) {
      yn !== null && typeof yn.markRenderScheduled == "function" && yn.markRenderScheduled(a);
    }
    function gC(a, s) {
      yn !== null && typeof yn.markForceUpdateScheduled == "function" && yn.markForceUpdateScheduled(a, s);
    }
    function Mu(a, s) {
      yn !== null && typeof yn.markStateUpdateScheduled == "function" && yn.markStateUpdateScheduled(a, s);
    }
    var si = (
      /*                         */
      0
    ), Oi = (
      /*                 */
      1
    ), ir = (
      /*                    */
      2
    ), Xi = (
      /*               */
      8
    ), Xr = (
      /*              */
      16
    ), fr = Math.clz32 ? Math.clz32 : Vs, ac = Math.log, ca = Math.LN2;
    function Vs(a) {
      var s = a >>> 0;
      return s === 0 ? 32 : 31 - (ac(s) / ca | 0) | 0;
    }
    var jo = 31, Ht = (
      /*                        */
      0
    ), Fa = (
      /*                          */
      0
    ), Ai = (
      /*                        */
      1
    ), Vg = (
      /*    */
      2
    ), br = (
      /*             */
      4
    ), xo = (
      /*            */
      8
    ), tl = (
      /*                     */
      16
    ), Ng = (
      /*                */
      32
    ), Rl = (
      /*                       */
      4194240
    ), Ec = (
      /*                        */
      64
    ), hh = (
      /*                        */
      128
    ), wI = (
      /*                        */
      256
    ), Sd = (
      /*                        */
      512
    ), nl = (
      /*                        */
      1024
    ), Zd = (
      /*                        */
      2048
    ), fh = (
      /*                        */
      4096
    ), ph = (
      /*                        */
      8192
    ), ra = (
      /*                        */
      16384
    ), so = (
      /*                       */
      32768
    ), lo = (
      /*                       */
      65536
    ), cs = (
      /*                       */
      131072
    ), gs = (
      /*                       */
      262144
    ), oc = (
      /*                       */
      524288
    ), Mg = (
      /*                       */
      1048576
    ), wd = (
      /*                       */
      2097152
    ), Hg = (
      /*                            */
      130023424
    ), Hu = (
      /*                             */
      4194304
    ), Tc = (
      /*                             */
      8388608
    ), Rd = (
      /*                             */
      16777216
    ), uo = (
      /*                             */
      33554432
    ), Xg = (
      /*                             */
      67108864
    ), Rp = Hu, xl = (
      /*          */
      134217728
    ), dC = (
      /*                          */
      268435455
    ), iu = (
      /*               */
      268435456
    ), sc = (
      /*                        */
      536870912
    ), il = (
      /*                   */
      1073741824
    );
    function Wl(a) {
      {
        if (a & Ai)
          return "Sync";
        if (a & Vg)
          return "InputContinuousHydration";
        if (a & br)
          return "InputContinuous";
        if (a & xo)
          return "DefaultHydration";
        if (a & tl)
          return "Default";
        if (a & Ng)
          return "TransitionHydration";
        if (a & Rl)
          return "Transition";
        if (a & Hg)
          return "Retry";
        if (a & xl)
          return "SelectiveHydration";
        if (a & iu)
          return "IdleHydration";
        if (a & sc)
          return "Idle";
        if (a & il)
          return "Offscreen";
      }
    }
    var Nr = -1, Yg = Ec, xd = Hu;
    function lc(a) {
      switch (ci(a)) {
        case Ai:
          return Ai;
        case Vg:
          return Vg;
        case br:
          return br;
        case xo:
          return xo;
        case tl:
          return tl;
        case Ng:
          return Ng;
        case Ec:
        case hh:
        case wI:
        case Sd:
        case nl:
        case Zd:
        case fh:
        case ph:
        case ra:
        case so:
        case lo:
        case cs:
        case gs:
        case oc:
        case Mg:
        case wd:
          return a & Rl;
        case Hu:
        case Tc:
        case Rd:
        case uo:
        case Xg:
          return a & Hg;
        case xl:
          return xl;
        case iu:
          return iu;
        case sc:
          return sc;
        case il:
          return il;
        default:
          return u("Should have found matching lanes. This is a bug in React."), a;
      }
    }
    function ds(a, s) {
      var p = a.pendingLanes;
      if (p === Ht)
        return Ht;
      var y = Ht, Z = a.suspendedLanes, X = a.pingedLanes, K = p & dC;
      if (K !== Ht) {
        var Q = K & ~Z;
        if (Q !== Ht)
          y = lc(Q);
        else {
          var te = K & X;
          te !== Ht && (y = lc(te));
        }
      } else {
        var ce = p & ~Z;
        ce !== Ht ? y = lc(ce) : X !== Ht && (y = lc(X));
      }
      if (y === Ht)
        return Ht;
      if (s !== Ht && s !== y && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (s & Z) === Ht) {
        var Ce = ci(y), Qe = ci(s);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          Ce >= Qe || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          Ce === tl && (Qe & Rl) !== Ht
        )
          return s;
      }
      (y & br) !== Ht && (y |= p & tl);
      var Pe = a.entangledLanes;
      if (Pe !== Ht)
        for (var pt = a.entanglements, yt = y & Pe; yt > 0; ) {
          var Yt = wn(yt), On = 1 << Yt;
          y |= pt[Yt], yt &= ~On;
        }
      return y;
    }
    function Wd(a, s) {
      for (var p = a.eventTimes, y = Nr; s > 0; ) {
        var Z = wn(s), X = 1 << Z, K = p[Z];
        K > y && (y = K), s &= ~X;
      }
      return y;
    }
    function RI(a, s) {
      switch (a) {
        case Ai:
        case Vg:
        case br:
          return s + 250;
        case xo:
        case tl:
        case Ng:
        case Ec:
        case hh:
        case wI:
        case Sd:
        case nl:
        case Zd:
        case fh:
        case ph:
        case ra:
        case so:
        case lo:
        case cs:
        case gs:
        case oc:
        case Mg:
        case wd:
          return s + 5e3;
        case Hu:
        case Tc:
        case Rd:
        case uo:
        case Xg:
          return Nr;
        case xl:
        case iu:
        case sc:
        case il:
          return Nr;
        default:
          return u("Should have found matching lanes. This is a bug in React."), Nr;
      }
    }
    function xp(a, s) {
      for (var p = a.pendingLanes, y = a.suspendedLanes, Z = a.pingedLanes, X = a.expirationTimes, K = p; K > 0; ) {
        var Q = wn(K), te = 1 << Q, ce = X[Q];
        ce === Nr ? ((te & y) === Ht || (te & Z) !== Ht) && (X[Q] = RI(te, s)) : ce <= s && (a.expiredLanes |= te), K &= ~te;
      }
    }
    function m(a) {
      return lc(a.pendingLanes);
    }
    function A(a) {
      var s = a.pendingLanes & -1073741825;
      return s !== Ht ? s : s & il ? il : Ht;
    }
    function V(a) {
      return (a & Ai) !== Ht;
    }
    function E(a) {
      return (a & dC) !== Ht;
    }
    function k(a) {
      return (a & Hg) === a;
    }
    function $(a) {
      var s = Ai | br | tl;
      return (a & s) === Ht;
    }
    function ve(a) {
      return (a & Rl) === a;
    }
    function Ke(a, s) {
      var p = Vg | br | xo | tl;
      return (s & p) !== Ht;
    }
    function Rt(a, s) {
      return (s & a.expiredLanes) !== Ht;
    }
    function In(a) {
      return (a & Rl) !== Ht;
    }
    function $n() {
      var a = Yg;
      return Yg <<= 1, (Yg & Rl) === Ht && (Yg = Ec), a;
    }
    function zi() {
      var a = xd;
      return xd <<= 1, (xd & Hg) === Ht && (xd = Hu), a;
    }
    function ci(a) {
      return a & -a;
    }
    function Yi(a) {
      return ci(a);
    }
    function wn(a) {
      return 31 - fr(a);
    }
    function Oa(a) {
      return wn(a);
    }
    function ga(a, s) {
      return (a & s) !== Ht;
    }
    function ot(a, s) {
      return (a & s) === s;
    }
    function Fe(a, s) {
      return a | s;
    }
    function bt(a, s) {
      return a & ~s;
    }
    function Sn(a, s) {
      return a & s;
    }
    function ei(a) {
      return a;
    }
    function Ki(a, s) {
      return a !== Fa && a < s ? a : s;
    }
    function Vi(a) {
      for (var s = [], p = 0; p < jo; p++)
        s.push(a);
      return s;
    }
    function cr(a, s, p) {
      a.pendingLanes |= s, s !== sc && (a.suspendedLanes = Ht, a.pingedLanes = Ht);
      var y = a.eventTimes, Z = Oa(s);
      y[Z] = p;
    }
    function Ea(a, s) {
      a.suspendedLanes |= s, a.pingedLanes &= ~s;
      for (var p = a.expirationTimes, y = s; y > 0; ) {
        var Z = wn(y), X = 1 << Z;
        p[Z] = Nr, y &= ~X;
      }
    }
    function pr(a, s, p) {
      a.pingedLanes |= a.suspendedLanes & s;
    }
    function _c(a, s) {
      var p = a.pendingLanes & ~s;
      a.pendingLanes = s, a.suspendedLanes = Ht, a.pingedLanes = Ht, a.expiredLanes &= s, a.mutableReadLanes &= s, a.entangledLanes &= s;
      for (var y = a.entanglements, Z = a.eventTimes, X = a.expirationTimes, K = p; K > 0; ) {
        var Q = wn(K), te = 1 << Q;
        y[Q] = Ht, Z[Q] = Nr, X[Q] = Nr, K &= ~te;
      }
    }
    function Vd(a, s) {
      for (var p = a.entangledLanes |= s, y = a.entanglements, Z = p; Z; ) {
        var X = wn(Z), K = 1 << X;
        // Is this one of the newly entangled lanes?
        K & s | // Is this lane transitively entangled with the newly entangled lanes?
        y[X] & s && (y[X] |= s), Z &= ~K;
      }
    }
    function Wp(a, s) {
      var p = ci(s), y;
      switch (p) {
        case br:
          y = Vg;
          break;
        case tl:
          y = xo;
          break;
        case Ec:
        case hh:
        case wI:
        case Sd:
        case nl:
        case Zd:
        case fh:
        case ph:
        case ra:
        case so:
        case lo:
        case cs:
        case gs:
        case oc:
        case Mg:
        case wd:
        case Hu:
        case Tc:
        case Rd:
        case uo:
        case Xg:
          y = Ng;
          break;
        case sc:
          y = iu;
          break;
        default:
          y = Fa;
          break;
      }
      return (y & (a.suspendedLanes | s)) !== Fa ? Fa : y;
    }
    function tA(a, s, p) {
      if (_o)
        for (var y = a.pendingUpdatersLaneMap; p > 0; ) {
          var Z = Oa(p), X = 1 << Z, K = y[Z];
          K.add(s), p &= ~X;
        }
    }
    function nA(a, s) {
      if (_o)
        for (var p = a.pendingUpdatersLaneMap, y = a.memoizedUpdaters; s > 0; ) {
          var Z = Oa(s), X = 1 << Z, K = p[Z];
          K.size > 0 && (K.forEach(function(Q) {
            var te = Q.alternate;
            (te === null || !y.has(te)) && y.add(Q);
          }), K.clear()), s &= ~X;
        }
    }
    function mf(a, s) {
      return null;
    }
    var Vl = Ai, Xu = br, Is = tl, Af = sc, mh = Fa;
    function Nl() {
      return mh;
    }
    function zo(a) {
      mh = a;
    }
    function iA(a, s) {
      var p = mh;
      try {
        return mh = a, s();
      } finally {
        mh = p;
      }
    }
    function Ah(a, s) {
      return a !== 0 && a < s ? a : s;
    }
    function rl(a, s) {
      return a > s ? a : s;
    }
    function Vp(a, s) {
      return a !== 0 && a < s;
    }
    function rA(a) {
      var s = ci(a);
      return Vp(Vl, s) ? Vp(Xu, s) ? E(s) ? Is : Af : Xu : Vl;
    }
    function IC(a) {
      var s = a.current.memoizedState;
      return s.isDehydrated;
    }
    var al;
    function Tb(a) {
      al = a;
    }
    function ti(a) {
      al(a);
    }
    var CC;
    function aA(a) {
      CC = a;
    }
    var Np;
    function HB(a) {
      Np = a;
    }
    var vf;
    function xI(a) {
      vf = a;
    }
    var WI;
    function Mp(a) {
      WI = a;
    }
    var vh = !1, Ml = [], Ko = null, Hl = null, Kr = null, co = /* @__PURE__ */ new Map(), zc = /* @__PURE__ */ new Map(), VI = [], _b = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function ol(a) {
      return _b.indexOf(a) > -1;
    }
    function Vv(a, s, p, y, Z) {
      return {
        blockedOn: a,
        domEventName: s,
        eventSystemFlags: p,
        nativeEvent: Z,
        targetContainers: [y]
      };
    }
    function uc(a, s) {
      switch (a) {
        case "focusin":
        case "focusout":
          Ko = null;
          break;
        case "dragenter":
        case "dragleave":
          Hl = null;
          break;
        case "mouseover":
        case "mouseout":
          Kr = null;
          break;
        case "pointerover":
        case "pointerout": {
          var p = s.pointerId;
          co.delete(p);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var y = s.pointerId;
          zc.delete(y);
          break;
        }
      }
    }
    function hC(a, s, p, y, Z, X) {
      if (a === null || a.nativeEvent !== X) {
        var K = Vv(s, p, y, Z, X);
        if (s !== null) {
          var Q = Cs(s);
          Q !== null && CC(Q);
        }
        return K;
      }
      a.eventSystemFlags |= y;
      var te = a.targetContainers;
      return Z !== null && te.indexOf(Z) === -1 && te.push(Z), a;
    }
    function zb(a, s, p, y, Z) {
      switch (s) {
        case "focusin": {
          var X = Z;
          return Ko = hC(Ko, a, s, p, y, X), !0;
        }
        case "dragenter": {
          var K = Z;
          return Hl = hC(Hl, a, s, p, y, K), !0;
        }
        case "mouseover": {
          var Q = Z;
          return Kr = hC(Kr, a, s, p, y, Q), !0;
        }
        case "pointerover": {
          var te = Z, ce = te.pointerId;
          return co.set(ce, hC(co.get(ce) || null, a, s, p, y, te)), !0;
        }
        case "gotpointercapture": {
          var Ce = Z, Qe = Ce.pointerId;
          return zc.set(Qe, hC(zc.get(Qe) || null, a, s, p, y, Ce)), !0;
        }
      }
      return !1;
    }
    function Hp(a) {
      var s = Qp(a.target);
      if (s !== null) {
        var p = fn(s);
        if (p !== null) {
          var y = p.tag;
          if (y === D) {
            var Z = Zl(p);
            if (Z !== null) {
              a.blockedOn = Z, WI(a.priority, function() {
                Np(p);
              });
              return;
            }
          } else if (y === b) {
            var X = p.stateNode;
            if (IC(X)) {
              a.blockedOn = Fc(p);
              return;
            }
          }
        }
      }
      a.blockedOn = null;
    }
    function Kb(a) {
      for (var s = vf(), p = {
        blockedOn: null,
        target: a,
        priority: s
      }, y = 0; y < VI.length && Vp(s, VI[y].priority); y++)
        ;
      VI.splice(y, 0, p), y === 0 && Hp(p);
    }
    function Xp(a) {
      if (a.blockedOn !== null)
        return !1;
      for (var s = a.targetContainers; s.length > 0; ) {
        var p = s[0], y = bf(a.domEventName, a.eventSystemFlags, p, a.nativeEvent);
        if (y === null) {
          var Z = a.nativeEvent, X = new Z.constructor(Z.type, Z);
          hf(X), Z.target.dispatchEvent(X), Qt();
        } else {
          var K = Cs(y);
          return K !== null && CC(K), a.blockedOn = y, !1;
        }
        s.shift();
      }
      return !0;
    }
    function fC(a, s, p) {
      Xp(a) && p.delete(s);
    }
    function qo() {
      vh = !1, Ko !== null && Xp(Ko) && (Ko = null), Hl !== null && Xp(Hl) && (Hl = null), Kr !== null && Xp(Kr) && (Kr = null), co.forEach(fC), zc.forEach(fC);
    }
    function Ns(a, s) {
      a.blockedOn === s && (a.blockedOn = null, vh || (vh = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, qo)));
    }
    function Va(a) {
      if (Ml.length > 0) {
        Ns(Ml[0], a);
        for (var s = 1; s < Ml.length; s++) {
          var p = Ml[s];
          p.blockedOn === a && (p.blockedOn = null);
        }
      }
      Ko !== null && Ns(Ko, a), Hl !== null && Ns(Hl, a), Kr !== null && Ns(Kr, a);
      var y = function(Q) {
        return Ns(Q, a);
      };
      co.forEach(y), zc.forEach(y);
      for (var Z = 0; Z < VI.length; Z++) {
        var X = VI[Z];
        X.blockedOn === a && (X.blockedOn = null);
      }
      for (; VI.length > 0; ) {
        var K = VI[0];
        if (K.blockedOn !== null)
          break;
        Hp(K), K.blockedOn === null && VI.shift();
      }
    }
    var Qi = n.ReactCurrentBatchConfig, wa = !0;
    function Lo(a) {
      wa = !!a;
    }
    function sl() {
      return wa;
    }
    function cc(a, s, p) {
      var y = AC(s), Z;
      switch (y) {
        case Vl:
          Z = yf;
          break;
        case Xu:
          Z = $o;
          break;
        case Is:
        default:
          Z = pC;
          break;
      }
      return Z.bind(null, s, p, a);
    }
    function yf(a, s, p, y) {
      var Z = Nl(), X = Qi.transition;
      Qi.transition = null;
      try {
        zo(Vl), pC(a, s, p, y);
      } finally {
        zo(Z), Qi.transition = X;
      }
    }
    function $o(a, s, p, y) {
      var Z = Nl(), X = Qi.transition;
      Qi.transition = null;
      try {
        zo(Xu), pC(a, s, p, y);
      } finally {
        zo(Z), Qi.transition = X;
      }
    }
    function pC(a, s, p, y) {
      wa && NI(a, s, p, y);
    }
    function NI(a, s, p, y) {
      var Z = bf(a, s, p, y);
      if (Z === null) {
        wC(a, s, y, mC, p), uc(a, y);
        return;
      }
      if (zb(Z, a, s, p, y)) {
        y.stopPropagation();
        return;
      }
      if (uc(a, y), s & md && ol(a)) {
        for (; Z !== null; ) {
          var X = Cs(Z);
          X !== null && ti(X);
          var K = bf(a, s, p, y);
          if (K === null && wC(a, s, y, mC, p), K === Z)
            break;
          Z = K;
        }
        Z !== null && y.stopPropagation();
        return;
      }
      wC(a, s, y, null, p);
    }
    var mC = null;
    function bf(a, s, p, y) {
      mC = null;
      var Z = ji(y), X = Qp(Z);
      if (X !== null) {
        var K = fn(X);
        if (K === null)
          X = null;
        else {
          var Q = K.tag;
          if (Q === D) {
            var te = Zl(K);
            if (te !== null)
              return te;
            X = null;
          } else if (Q === b) {
            var ce = K.stateNode;
            if (IC(ce))
              return Fc(K);
            X = null;
          } else K !== X && (X = null);
        }
      }
      return mC = X, null;
    }
    function AC(a) {
      switch (a) {
        // Used by SimpleEventPlugin:
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        // Used by polyfills:
        // eslint-disable-next-line no-fallthrough
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        // Only enableCreateEventHandleAPI:
        // eslint-disable-next-line no-fallthrough
        case "beforeblur":
        case "afterblur":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Vl;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Xu;
        case "message": {
          var s = Sp();
          switch (s) {
            case Wu:
              return Vl;
            case wg:
              return Xu;
            case Gd:
            case Ih:
              return Is;
            case BI:
              return Af;
            default:
              return Is;
          }
        }
        default:
          return Is;
      }
    }
    function Xl(a, s, p) {
      return a.addEventListener(s, p, !1), p;
    }
    function Yp(a, s, p) {
      return a.addEventListener(s, p, !0), p;
    }
    function Gf(a, s, p, y) {
      return a.addEventListener(s, p, {
        capture: !0,
        passive: y
      }), p;
    }
    function MI(a, s, p, y) {
      return a.addEventListener(s, p, {
        passive: y
      }), p;
    }
    var vC = null, Fp = null, gc = null;
    function yC(a) {
      return vC = a, Fp = Fg(), !0;
    }
    function bC() {
      vC = null, Fp = null, gc = null;
    }
    function Bf() {
      if (gc)
        return gc;
      var a, s = Fp, p = s.length, y, Z = Fg(), X = Z.length;
      for (a = 0; a < p && s[a] === Z[a]; a++)
        ;
      var K = p - a;
      for (y = 1; y <= K && s[p - y] === Z[X - y]; y++)
        ;
      var Q = y > 1 ? 1 - y : void 0;
      return gc = Z.slice(a, Q), gc;
    }
    function Fg() {
      return "value" in vC ? vC.value : vC.textContent;
    }
    function yh(a) {
      var s, p = a.keyCode;
      return "charCode" in a ? (s = a.charCode, s === 0 && p === 13 && (s = 13)) : s = p, s === 10 && (s = 13), s >= 32 || s === 13 ? s : 0;
    }
    function Wo() {
      return !0;
    }
    function bh() {
      return !1;
    }
    function da(a) {
      function s(p, y, Z, X, K) {
        this._reactName = p, this._targetInst = Z, this.type = y, this.nativeEvent = X, this.target = K, this.currentTarget = null;
        for (var Q in a)
          if (a.hasOwnProperty(Q)) {
            var te = a[Q];
            te ? this[Q] = te(X) : this[Q] = X[Q];
          }
        var ce = X.defaultPrevented != null ? X.defaultPrevented : X.returnValue === !1;
        return ce ? this.isDefaultPrevented = Wo : this.isDefaultPrevented = bh, this.isPropagationStopped = bh, this;
      }
      return rn(s.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var p = this.nativeEvent;
          p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = Wo);
        },
        stopPropagation: function() {
          var p = this.nativeEvent;
          p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = Wo);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Wo
      }), s;
    }
    var ru = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(a) {
        return a.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, au = da(ru), es = rn({}, ru, {
      view: 0,
      detail: 0
    }), oA = da(es), Sf, HI, GC;
    function Eg(a) {
      a !== GC && (GC && a.type === "mousemove" ? (Sf = a.screenX - GC.screenX, HI = a.screenY - GC.screenY) : (Sf = 0, HI = 0), GC = a);
    }
    var Zf = rn({}, es, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: IA,
      button: 0,
      buttons: 0,
      relatedTarget: function(a) {
        return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      },
      movementX: function(a) {
        return "movementX" in a ? a.movementX : (Eg(a), Sf);
      },
      movementY: function(a) {
        return "movementY" in a ? a.movementY : HI;
      }
    }), Ep = da(Zf), Kc = rn({}, Zf, {
      dataTransfer: 0
    }), sA = da(Kc), Gh = rn({}, es, {
      relatedTarget: 0
    }), lA = da(Gh), wf = rn({}, ru, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Nd = da(wf), BC = rn({}, ru, {
      clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      }
    }), uA = da(BC), cA = rn({}, ru, {
      data: 0
    }), Tp = da(cA), gA = Tp, Lc = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, _p = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Bh(a) {
      if (a.key) {
        var s = Lc[a.key] || a.key;
        if (s !== "Unidentified")
          return s;
      }
      if (a.type === "keypress") {
        var p = yh(a);
        return p === 13 ? "Enter" : String.fromCharCode(p);
      }
      return a.type === "keydown" || a.type === "keyup" ? _p[a.keyCode] || "Unidentified" : "";
    }
    var dA = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Vo(a) {
      var s = this, p = s.nativeEvent;
      if (p.getModifierState)
        return p.getModifierState(a);
      var y = dA[a];
      return y ? !!p[y] : !1;
    }
    function IA(a) {
      return Vo;
    }
    var Nv = rn({}, es, {
      key: Bh,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: IA,
      // Legacy Interface
      charCode: function(a) {
        return a.type === "keypress" ? yh(a) : 0;
      },
      keyCode: function(a) {
        return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      },
      which: function(a) {
        return a.type === "keypress" ? yh(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      }
    }), zp = da(Nv), Tg = rn({}, Zf, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Kp = da(Tg), Sh = rn({}, es, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: IA
    }), Mv = da(Sh), kc = rn({}, ru, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Md = da(kc), Rf = rn({}, Zf, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in a ? -a.wheelDeltaX : 0
        );
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in a ? -a.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in a ? -a.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), SC = da(Rf), Zh = [9, 13, 27, 32], ll = 229, ma = ge && "CompositionEvent" in window, Yu = null;
    ge && "documentMode" in document && (Yu = document.documentMode);
    var go = ge && "TextEvent" in window && !Yu, Ms = ge && (!ma || Yu && Yu > 8 && Yu <= 11), xf = 32, CA = String.fromCharCode(xf);
    function Lb() {
      An("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), An("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), An("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), An("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Fn = !1;
    function ul(a) {
      return (a.ctrlKey || a.altKey || a.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(a.ctrlKey && a.altKey);
    }
    function Wf(a) {
      switch (a) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function wh(a, s) {
      return a === "keydown" && s.keyCode === ll;
    }
    function XI(a, s) {
      switch (a) {
        case "keyup":
          return Zh.indexOf(s.keyCode) !== -1;
        case "keydown":
          return s.keyCode !== ll;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Ia(a) {
      var s = a.detail;
      return typeof s == "object" && "data" in s ? s.data : null;
    }
    function Hs(a) {
      return a.locale === "ko";
    }
    var Na = !1;
    function Rh(a, s, p, y, Z) {
      var X, K;
      if (ma ? X = Wf(s) : Na ? XI(s, y) && (X = "onCompositionEnd") : wh(s, y) && (X = "onCompositionStart"), !X)
        return null;
      Ms && !Hs(y) && (!Na && X === "onCompositionStart" ? Na = yC(Z) : X === "onCompositionEnd" && Na && (K = Bf()));
      var Q = Hf(p, X);
      if (Q.length > 0) {
        var te = new Tp(X, s, null, y, Z);
        if (a.push({
          event: te,
          listeners: Q
        }), K)
          te.data = K;
        else {
          var ce = Ia(y);
          ce !== null && (te.data = ce);
        }
      }
    }
    function xh(a, s) {
      switch (a) {
        case "compositionend":
          return Ia(s);
        case "keypress":
          var p = s.which;
          return p !== xf ? null : (Fn = !0, CA);
        case "textInput":
          var y = s.data;
          return y === CA && Fn ? null : y;
        default:
          return null;
      }
    }
    function ZC(a, s) {
      if (Na) {
        if (a === "compositionend" || !ma && XI(a, s)) {
          var p = Bf();
          return bC(), Na = !1, p;
        }
        return null;
      }
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!ul(s)) {
            if (s.char && s.char.length > 1)
              return s.char;
            if (s.which)
              return String.fromCharCode(s.which);
          }
          return null;
        case "compositionend":
          return Ms && !Hs(s) ? null : s.data;
        default:
          return null;
      }
    }
    function kb(a, s, p, y, Z) {
      var X;
      if (go ? X = xh(s, y) : X = ZC(s, y), !X)
        return null;
      var K = Hf(p, "onBeforeInput");
      if (K.length > 0) {
        var Q = new gA("onBeforeInput", "beforeinput", null, y, Z);
        a.push({
          event: Q,
          listeners: K
        }), Q.data = X;
      }
    }
    function XB(a, s, p, y, Z, X, K) {
      Rh(a, s, p, y, Z), kb(a, s, p, y, Z);
    }
    var _t = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function dc(a) {
      var s = a && a.nodeName && a.nodeName.toLowerCase();
      return s === "input" ? !!_t[a.type] : s === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function Dc(a) {
      if (!ge)
        return !1;
      var s = "on" + a, p = s in document;
      if (!p) {
        var y = document.createElement("div");
        y.setAttribute(s, "return;"), p = typeof y[s] == "function";
      }
      return p;
    }
    function Hv() {
      An("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function Gr(a, s, p, y) {
      Nc(y);
      var Z = Hf(s, "onChange");
      if (Z.length > 0) {
        var X = new au("onChange", "change", null, p, y);
        a.push({
          event: X,
          listeners: Z
        });
      }
    }
    var c = null, h = null;
    function B(a) {
      var s = a.nodeName && a.nodeName.toLowerCase();
      return s === "select" || s === "input" && a.type === "file";
    }
    function M(a) {
      var s = [];
      Gr(s, h, a, ji(a)), uh(_, s);
    }
    function _(a) {
      DB(a, 0);
    }
    function U(a) {
      var s = Pc(a);
      if (Bs(s))
        return a;
    }
    function oe(a, s) {
      if (a === "change")
        return s;
    }
    var xe = !1;
    ge && (xe = Dc("input") && (!document.documentMode || document.documentMode > 9));
    function Le(a, s) {
      c = a, h = s, c.attachEvent("onpropertychange", Ut);
    }
    function It() {
      c && (c.detachEvent("onpropertychange", Ut), c = null, h = null);
    }
    function Ut(a) {
      a.propertyName === "value" && U(h) && M(a);
    }
    function sn(a, s, p) {
      a === "focusin" ? (It(), Le(s, p)) : a === "focusout" && It();
    }
    function qt(a, s) {
      if (a === "selectionchange" || a === "keyup" || a === "keydown")
        return U(h);
    }
    function kn(a) {
      var s = a.nodeName;
      return s && s.toLowerCase() === "input" && (a.type === "checkbox" || a.type === "radio");
    }
    function ii(a, s) {
      if (a === "click")
        return U(s);
    }
    function oi(a, s) {
      if (a === "input" || a === "change")
        return U(s);
    }
    function ts(a) {
      var s = a._wrapperState;
      !s || !s.controlled || a.type !== "number" || qn(a, "number", a.value);
    }
    function at(a, s, p, y, Z, X, K) {
      var Q = p ? Pc(p) : window, te, ce;
      if (B(Q) ? te = oe : dc(Q) ? xe ? te = oi : (te = qt, ce = sn) : kn(Q) && (te = ii), te) {
        var Ce = te(s, p);
        if (Ce) {
          Gr(a, Ce, y, Z);
          return;
        }
      }
      ce && ce(s, Q, p), s === "focusout" && ts(Q);
    }
    function Ue() {
      Hn("onMouseEnter", ["mouseout", "mouseover"]), Hn("onMouseLeave", ["mouseout", "mouseover"]), Hn("onPointerEnter", ["pointerout", "pointerover"]), Hn("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function lt(a, s, p, y, Z, X, K) {
      var Q = s === "mouseover" || s === "pointerover", te = s === "mouseout" || s === "pointerout";
      if (Q && !no(y)) {
        var ce = y.relatedTarget || y.fromElement;
        if (ce && (Qp(ce) || iy(ce)))
          return;
      }
      if (!(!te && !Q)) {
        var Ce;
        if (Z.window === Z)
          Ce = Z;
        else {
          var Qe = Z.ownerDocument;
          Qe ? Ce = Qe.defaultView || Qe.parentWindow : Ce = window;
        }
        var Pe, pt;
        if (te) {
          var yt = y.relatedTarget || y.toElement;
          if (Pe = p, pt = yt ? Qp(yt) : null, pt !== null) {
            var Yt = fn(pt);
            (pt !== Yt || pt.tag !== R && pt.tag !== W) && (pt = null);
          }
        } else
          Pe = null, pt = p;
        if (Pe !== pt) {
          var On = Ep, Ri = "onMouseLeave", hi = "onMouseEnter", Er = "mouse";
          (s === "pointerout" || s === "pointerover") && (On = Kp, Ri = "onPointerLeave", hi = "onPointerEnter", Er = "pointer");
          var Rr = Pe == null ? Ce : Pc(Pe), ut = pt == null ? Ce : Pc(pt), Ft = new On(Ri, Er + "leave", Pe, y, Z);
          Ft.target = Rr, Ft.relatedTarget = ut;
          var ct = null, cn = Qp(Z);
          if (cn === p) {
            var ni = new On(hi, Er + "enter", pt, y, Z);
            ni.target = ut, ni.relatedTarget = Rr, ct = ni;
          }
          mR(a, Ft, ct, Pe, pt);
        }
      }
    }
    function pn(a, s) {
      return a === s && (a !== 0 || 1 / a === 1 / s) || a !== a && s !== s;
    }
    var zn = typeof Object.is == "function" ? Object.is : pn;
    function Ci(a, s) {
      if (zn(a, s))
        return !0;
      if (typeof a != "object" || a === null || typeof s != "object" || s === null)
        return !1;
      var p = Object.keys(a), y = Object.keys(s);
      if (p.length !== y.length)
        return !1;
      for (var Z = 0; Z < p.length; Z++) {
        var X = p[Z];
        if (!Wt.call(s, X) || !zn(a[X], s[X]))
          return !1;
      }
      return !0;
    }
    function vi(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ei(a) {
      for (; a; ) {
        if (a.nextSibling)
          return a.nextSibling;
        a = a.parentNode;
      }
    }
    function Io(a, s) {
      for (var p = vi(a), y = 0, Z = 0; p; ) {
        if (p.nodeType === Wc) {
          if (Z = y + p.textContent.length, y <= s && Z >= s)
            return {
              node: p,
              offset: s - y
            };
          y = Z;
        }
        p = vi(Ei(p));
      }
    }
    function Zr(a) {
      var s = a.ownerDocument, p = s && s.defaultView || window, y = p.getSelection && p.getSelection();
      if (!y || y.rangeCount === 0)
        return null;
      var Z = y.anchorNode, X = y.anchorOffset, K = y.focusNode, Q = y.focusOffset;
      try {
        Z.nodeType, K.nodeType;
      } catch {
        return null;
      }
      return _g(a, Z, X, K, Q);
    }
    function _g(a, s, p, y, Z) {
      var X = 0, K = -1, Q = -1, te = 0, ce = 0, Ce = a, Qe = null;
      e: for (; ; ) {
        for (var Pe = null; Ce === s && (p === 0 || Ce.nodeType === Wc) && (K = X + p), Ce === y && (Z === 0 || Ce.nodeType === Wc) && (Q = X + Z), Ce.nodeType === Wc && (X += Ce.nodeValue.length), (Pe = Ce.firstChild) !== null; )
          Qe = Ce, Ce = Pe;
        for (; ; ) {
          if (Ce === a)
            break e;
          if (Qe === s && ++te === p && (K = X), Qe === y && ++ce === Z && (Q = X), (Pe = Ce.nextSibling) !== null)
            break;
          Ce = Qe, Qe = Ce.parentNode;
        }
        Ce = Pe;
      }
      return K === -1 || Q === -1 ? null : {
        start: K,
        end: Q
      };
    }
    function Lp(a, s) {
      var p = a.ownerDocument || document, y = p && p.defaultView || window;
      if (y.getSelection) {
        var Z = y.getSelection(), X = a.textContent.length, K = Math.min(s.start, X), Q = s.end === void 0 ? K : Math.min(s.end, X);
        if (!Z.extend && K > Q) {
          var te = Q;
          Q = K, K = te;
        }
        var ce = Io(a, K), Ce = Io(a, Q);
        if (ce && Ce) {
          if (Z.rangeCount === 1 && Z.anchorNode === ce.node && Z.anchorOffset === ce.offset && Z.focusNode === Ce.node && Z.focusOffset === Ce.offset)
            return;
          var Qe = p.createRange();
          Qe.setStart(ce.node, ce.offset), Z.removeAllRanges(), K > Q ? (Z.addRange(Qe), Z.extend(Ce.node, Ce.offset)) : (Qe.setEnd(Ce.node, Ce.offset), Z.addRange(Qe));
        }
      }
    }
    function Db(a) {
      return a && a.nodeType === Wc;
    }
    function Xv(a, s) {
      return !a || !s ? !1 : a === s ? !0 : Db(a) ? !1 : Db(s) ? Xv(a, s.parentNode) : "contains" in a ? a.contains(s) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(s) & 16) : !1;
    }
    function Yv(a) {
      return a && a.ownerDocument && Xv(a.ownerDocument.documentElement, a);
    }
    function Ub(a) {
      try {
        return typeof a.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function hA() {
      for (var a = window, s = Ul(); s instanceof a.HTMLIFrameElement; ) {
        if (Ub(s))
          a = s.contentWindow;
        else
          return s;
        s = Ul(a.document);
      }
      return s;
    }
    function Wh(a) {
      var s = a && a.nodeName && a.nodeName.toLowerCase();
      return s && (s === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || s === "textarea" || a.contentEditable === "true");
    }
    function YB() {
      var a = hA();
      return {
        focusedElem: a,
        selectionRange: Wh(a) ? FB(a) : null
      };
    }
    function Ob(a) {
      var s = hA(), p = a.focusedElem, y = a.selectionRange;
      if (s !== p && Yv(p)) {
        y !== null && Wh(p) && Pb(p, y);
        for (var Z = [], X = p; X = X.parentNode; )
          X.nodeType === vo && Z.push({
            element: X,
            left: X.scrollLeft,
            top: X.scrollTop
          });
        typeof p.focus == "function" && p.focus();
        for (var K = 0; K < Z.length; K++) {
          var Q = Z[K];
          Q.element.scrollLeft = Q.left, Q.element.scrollTop = Q.top;
        }
      }
    }
    function FB(a) {
      var s;
      return "selectionStart" in a ? s = {
        start: a.selectionStart,
        end: a.selectionEnd
      } : s = Zr(a), s || {
        start: 0,
        end: 0
      };
    }
    function Pb(a, s) {
      var p = s.start, y = s.end;
      y === void 0 && (y = p), "selectionStart" in a ? (a.selectionStart = p, a.selectionEnd = Math.min(y, a.value.length)) : Lp(a, s);
    }
    var cR = ge && "documentMode" in document && document.documentMode <= 11;
    function EB() {
      An("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Vh = null, TB = null, Vf = null, Fv = !1;
    function Jb(a) {
      if ("selectionStart" in a && Wh(a))
        return {
          start: a.selectionStart,
          end: a.selectionEnd
        };
      var s = a.ownerDocument && a.ownerDocument.defaultView || window, p = s.getSelection();
      return {
        anchorNode: p.anchorNode,
        anchorOffset: p.anchorOffset,
        focusNode: p.focusNode,
        focusOffset: p.focusOffset
      };
    }
    function _B(a) {
      return a.window === a ? a.document : a.nodeType === yu ? a : a.ownerDocument;
    }
    function Ev(a, s, p) {
      var y = _B(p);
      if (!(Fv || Vh == null || Vh !== Ul(y))) {
        var Z = Jb(Vh);
        if (!Vf || !Ci(Vf, Z)) {
          Vf = Z;
          var X = Hf(TB, "onSelect");
          if (X.length > 0) {
            var K = new au("onSelect", "select", null, s, p);
            a.push({
              event: K,
              listeners: X
            }), K.target = Vh;
          }
        }
      }
    }
    function zB(a, s, p, y, Z, X, K) {
      var Q = p ? Pc(p) : window;
      switch (s) {
        // Track the input node that has focus.
        case "focusin":
          (dc(Q) || Q.contentEditable === "true") && (Vh = Q, TB = p, Vf = null);
          break;
        case "focusout":
          Vh = null, TB = null, Vf = null;
          break;
        // Don't fire the event while the user is dragging. This matches the
        // semantics of the native select event.
        case "mousedown":
          Fv = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Fv = !1, Ev(a, y, Z);
          break;
        // Chrome and IE fire non-standard event when selection is changed (and
        // sometimes when it hasn't). IE's event fires out of order with respect
        // to key and input events on deletion, so we discard it.
        //
        // Firefox doesn't support selectionchange, so check selection status
        // after each key entry. The selection changes after keydown and before
        // keyup, but we check on keydown as well in the case of holding down a
        // key, when multiple keydown events are fired but only one keyup is.
        // This is also our approach for IE handling, for the reason above.
        case "selectionchange":
          if (cR)
            break;
        // falls through
        case "keydown":
        case "keyup":
          Ev(a, y, Z);
      }
    }
    function Tv(a, s) {
      var p = {};
      return p[a.toLowerCase()] = s.toLowerCase(), p["Webkit" + a] = "webkit" + s, p["Moz" + a] = "moz" + s, p;
    }
    var kp = {
      animationend: Tv("Animation", "AnimationEnd"),
      animationiteration: Tv("Animation", "AnimationIteration"),
      animationstart: Tv("Animation", "AnimationStart"),
      transitionend: Tv("Transition", "TransitionEnd")
    }, KB = {}, Qb = {};
    ge && (Qb = document.createElement("div").style, "AnimationEvent" in window || (delete kp.animationend.animation, delete kp.animationiteration.animation, delete kp.animationstart.animation), "TransitionEvent" in window || delete kp.transitionend.transition);
    function _v(a) {
      if (KB[a])
        return KB[a];
      if (!kp[a])
        return a;
      var s = kp[a];
      for (var p in s)
        if (s.hasOwnProperty(p) && p in Qb)
          return KB[a] = s[p];
      return a;
    }
    var LB = _v("animationend"), kB = _v("animationiteration"), gR = _v("animationstart"), jb = _v("transitionend"), zv = /* @__PURE__ */ new Map(), dR = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Nf(a, s) {
      zv.set(a, s), An(s, [a]);
    }
    function IR() {
      for (var a = 0; a < dR.length; a++) {
        var s = dR[a], p = s.toLowerCase(), y = s[0].toUpperCase() + s.slice(1);
        Nf(p, "on" + y);
      }
      Nf(LB, "onAnimationEnd"), Nf(kB, "onAnimationIteration"), Nf(gR, "onAnimationStart"), Nf("dblclick", "onDoubleClick"), Nf("focusin", "onFocus"), Nf("focusout", "onBlur"), Nf(jb, "onTransitionEnd");
    }
    function CR(a, s, p, y, Z, X, K) {
      var Q = zv.get(s);
      if (Q !== void 0) {
        var te = au, ce = s;
        switch (s) {
          case "keypress":
            if (yh(y) === 0)
              return;
          /* falls through */
          case "keydown":
          case "keyup":
            te = zp;
            break;
          case "focusin":
            ce = "focus", te = lA;
            break;
          case "focusout":
            ce = "blur", te = lA;
            break;
          case "beforeblur":
          case "afterblur":
            te = lA;
            break;
          case "click":
            if (y.button === 2)
              return;
          /* falls through */
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          // TODO: Disabled elements should not respond to mouse events
          /* falls through */
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            te = Ep;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            te = sA;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            te = Mv;
            break;
          case LB:
          case kB:
          case gR:
            te = Nd;
            break;
          case jb:
            te = Md;
            break;
          case "scroll":
            te = oA;
            break;
          case "wheel":
            te = SC;
            break;
          case "copy":
          case "cut":
          case "paste":
            te = uA;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            te = Kp;
            break;
        }
        var Ce = (X & md) !== 0;
        {
          var Qe = !Ce && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          s === "scroll", Pe = e0(p, Q, y.type, Ce, Qe);
          if (Pe.length > 0) {
            var pt = new te(Q, ce, null, y, Z);
            a.push({
              event: pt,
              listeners: Pe
            });
          }
        }
      }
    }
    IR(), Ue(), Hv(), EB(), Lb();
    function hR(a, s, p, y, Z, X, K) {
      CR(a, s, p, y, Z, X);
      var Q = (X & lh) === 0;
      Q && (lt(a, s, p, y, Z), at(a, s, p, y, Z), zB(a, s, p, y, Z), XB(a, s, p, y, Z));
    }
    var fA = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], qb = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(fA));
    function Kv(a, s, p) {
      var y = a.type || "unknown-event";
      a.currentTarget = p, Hc(y, s, void 0, a), a.currentTarget = null;
    }
    function fR(a, s, p) {
      var y;
      if (p)
        for (var Z = s.length - 1; Z >= 0; Z--) {
          var X = s[Z], K = X.instance, Q = X.currentTarget, te = X.listener;
          if (K !== y && a.isPropagationStopped())
            return;
          Kv(a, te, Q), y = K;
        }
      else
        for (var ce = 0; ce < s.length; ce++) {
          var Ce = s[ce], Qe = Ce.instance, Pe = Ce.currentTarget, pt = Ce.listener;
          if (Qe !== y && a.isPropagationStopped())
            return;
          Kv(a, pt, Pe), y = Qe;
        }
    }
    function DB(a, s) {
      for (var p = (s & md) !== 0, y = 0; y < a.length; y++) {
        var Z = a[y], X = Z.event, K = Z.listeners;
        fR(X, K, p);
      }
      Bl();
    }
    function pR(a, s, p, y, Z) {
      var X = ji(p), K = [];
      hR(K, a, y, p, X, s), DB(K, s);
    }
    function Pa(a, s) {
      qb.has(a) || u('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', a);
      var p = !1, y = UV(s), Z = mV(a);
      y.has(Z) || ($b(s, a, Bu, p), y.add(Z));
    }
    function Hd(a, s, p) {
      qb.has(a) && !s && u('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', a);
      var y = 0;
      s && (y |= md), $b(p, a, y, s);
    }
    var Uc = "_reactListening" + Math.random().toString(36).slice(2);
    function Mf(a) {
      if (!a[Uc]) {
        a[Uc] = !0, mt.forEach(function(p) {
          p !== "selectionchange" && (qb.has(p) || Hd(p, !1, a), Hd(p, !0, a));
        });
        var s = a.nodeType === yu ? a : a.ownerDocument;
        s !== null && (s[Uc] || (s[Uc] = !0, Hd("selectionchange", !1, s)));
      }
    }
    function $b(a, s, p, y, Z) {
      var X = cc(a, s, p), K = void 0;
      vI && (s === "touchstart" || s === "touchmove" || s === "wheel") && (K = !0), a = a, y ? K !== void 0 ? Gf(a, s, X, K) : Yp(a, s, X) : K !== void 0 ? MI(a, s, X, K) : Xl(a, s, X);
    }
    function Li(a, s) {
      return a === s || a.nodeType === ha && a.parentNode === s;
    }
    function wC(a, s, p, y, Z) {
      var X = y;
      if ((s & ql) === 0 && (s & Bu) === 0) {
        var K = Z;
        if (y !== null) {
          var Q = y;
          e: for (; ; ) {
            if (Q === null)
              return;
            var te = Q.tag;
            if (te === b || te === S) {
              var ce = Q.stateNode.containerInfo;
              if (Li(ce, K))
                break;
              if (te === S)
                for (var Ce = Q.return; Ce !== null; ) {
                  var Qe = Ce.tag;
                  if (Qe === b || Qe === S) {
                    var Pe = Ce.stateNode.containerInfo;
                    if (Li(Pe, K))
                      return;
                  }
                  Ce = Ce.return;
                }
              for (; ce !== null; ) {
                var pt = Qp(ce);
                if (pt === null)
                  return;
                var yt = pt.tag;
                if (yt === R || yt === W) {
                  Q = X = pt;
                  continue e;
                }
                ce = ce.parentNode;
              }
            }
            Q = Q.return;
          }
        }
      }
      uh(function() {
        return pR(a, s, p, X);
      });
    }
    function pA(a, s, p) {
      return {
        instance: a,
        listener: s,
        currentTarget: p
      };
    }
    function e0(a, s, p, y, Z, X) {
      for (var K = s !== null ? s + "Capture" : null, Q = y ? K : s, te = [], ce = a, Ce = null; ce !== null; ) {
        var Qe = ce, Pe = Qe.stateNode, pt = Qe.tag;
        if (pt === R && Pe !== null && (Ce = Pe, Q !== null)) {
          var yt = Su(ce, Q);
          yt != null && te.push(pA(ce, yt, Ce));
        }
        if (Z)
          break;
        ce = ce.return;
      }
      return te;
    }
    function Hf(a, s) {
      for (var p = s + "Capture", y = [], Z = a; Z !== null; ) {
        var X = Z, K = X.stateNode, Q = X.tag;
        if (Q === R && K !== null) {
          var te = K, ce = Su(Z, p);
          ce != null && y.unshift(pA(Z, ce, te));
          var Ce = Su(Z, s);
          Ce != null && y.push(pA(Z, Ce, te));
        }
        Z = Z.return;
      }
      return y;
    }
    function Nh(a) {
      if (a === null)
        return null;
      do
        a = a.return;
      while (a && a.tag !== R);
      return a || null;
    }
    function UB(a, s) {
      for (var p = a, y = s, Z = 0, X = p; X; X = Nh(X))
        Z++;
      for (var K = 0, Q = y; Q; Q = Nh(Q))
        K++;
      for (; Z - K > 0; )
        p = Nh(p), Z--;
      for (; K - Z > 0; )
        y = Nh(y), K--;
      for (var te = Z; te--; ) {
        if (p === y || y !== null && p === y.alternate)
          return p;
        p = Nh(p), y = Nh(y);
      }
      return null;
    }
    function Lv(a, s, p, y, Z) {
      for (var X = s._reactName, K = [], Q = p; Q !== null && Q !== y; ) {
        var te = Q, ce = te.alternate, Ce = te.stateNode, Qe = te.tag;
        if (ce !== null && ce === y)
          break;
        if (Qe === R && Ce !== null) {
          var Pe = Ce;
          if (Z) {
            var pt = Su(Q, X);
            pt != null && K.unshift(pA(Q, pt, Pe));
          } else if (!Z) {
            var yt = Su(Q, X);
            yt != null && K.push(pA(Q, yt, Pe));
          }
        }
        Q = Q.return;
      }
      K.length !== 0 && a.push({
        event: s,
        listeners: K
      });
    }
    function mR(a, s, p, y, Z) {
      var X = y && Z ? UB(y, Z) : null;
      y !== null && Lv(a, s, y, X, !1), Z !== null && p !== null && Lv(a, p, Z, X, !0);
    }
    function mV(a, s) {
      return a + "__bubble";
    }
    var Oc = !1, kv = "dangerouslySetInnerHTML", Dv = "suppressContentEditableWarning", Mh = "suppressHydrationWarning", t0 = "autoFocus", Xf = "children", RC = "style", Ic = "__html", Uv, Cc, Dp, n0, Up, AR, i0;
    Uv = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Cc = function(a, s) {
      sh(a, s), qu(a, s), La(a, s, {
        registrationNameDependencies: Dt,
        possibleRegistrationNames: mn
      });
    }, AR = ge && !document.documentMode, Dp = function(a, s, p) {
      if (!Oc) {
        var y = mA(p), Z = mA(s);
        Z !== y && (Oc = !0, u("Prop `%s` did not match. Server: %s Client: %s", a, JSON.stringify(Z), JSON.stringify(y)));
      }
    }, n0 = function(a) {
      if (!Oc) {
        Oc = !0;
        var s = [];
        a.forEach(function(p) {
          s.push(p);
        }), u("Extra attributes from the server: %s", s);
      }
    }, Up = function(a, s) {
      s === !1 ? u("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", a, a, a) : u("Expected `%s` listener to be a function, instead got a value of `%s` type.", a, typeof s);
    }, i0 = function(a, s) {
      var p = a.namespaceURI === Ss ? a.ownerDocument.createElement(a.tagName) : a.ownerDocument.createElementNS(a.namespaceURI, a.tagName);
      return p.innerHTML = s, p.innerHTML;
    };
    var AV = /\r\n?/g, vR = /\u0000|\uFFFD/g;
    function mA(a) {
      se(a);
      var s = typeof a == "string" ? a : "" + a;
      return s.replace(AV, `
`).replace(vR, "");
    }
    function Ov(a, s, p, y) {
      var Z = mA(s), X = mA(a);
      if (X !== Z && (y && (Oc || (Oc = !0, u('Text content did not match. Server: "%s" Client: "%s"', X, Z))), p && re))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function yR(a) {
      return a.nodeType === yu ? a : a.ownerDocument;
    }
    function vV() {
    }
    function Pv(a) {
      a.onclick = vV;
    }
    function bR(a, s, p, y, Z) {
      for (var X in y)
        if (y.hasOwnProperty(X)) {
          var K = y[X];
          if (X === RC)
            K && Object.freeze(K), Gu(s, K);
          else if (X === kv) {
            var Q = K ? K[Ic] : void 0;
            Q != null && xc(s, Q);
          } else if (X === Xf)
            if (typeof K == "string") {
              var te = a !== "textarea" || K !== "";
              te && eo(s, K);
            } else typeof K == "number" && eo(s, "" + K);
          else X === Dv || X === Mh || X === t0 || (Dt.hasOwnProperty(X) ? K != null && (typeof K != "function" && Up(X, K), X === "onScroll" && Pa("scroll", s)) : K != null && Ve(s, X, K, Z));
        }
    }
    function yV(a, s, p, y) {
      for (var Z = 0; Z < s.length; Z += 2) {
        var X = s[Z], K = s[Z + 1];
        X === RC ? Gu(a, K) : X === kv ? xc(a, K) : X === Xf ? eo(a, K) : Ve(a, X, K, y);
      }
    }
    function bV(a, s, p, y) {
      var Z, X = yR(p), K, Q = y;
      if (Q === Ss && (Q = ml(a)), Q === Ss) {
        if (Z = Hr(a, s), !Z && a !== a.toLowerCase() && u("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", a), a === "script") {
          var te = X.createElement("div");
          te.innerHTML = "<script><\/script>";
          var ce = te.firstChild;
          K = te.removeChild(ce);
        } else if (typeof s.is == "string")
          K = X.createElement(a, {
            is: s.is
          });
        else if (K = X.createElement(a), a === "select") {
          var Ce = K;
          s.multiple ? Ce.multiple = !0 : s.size && (Ce.size = s.size);
        }
      } else
        K = X.createElementNS(Q, a);
      return Q === Ss && !Z && Object.prototype.toString.call(K) === "[object HTMLUnknownElement]" && !Wt.call(Uv, a) && (Uv[a] = !0, u("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", a)), K;
    }
    function xC(a, s) {
      return yR(s).createTextNode(a);
    }
    function GR(a, s, p, y) {
      var Z = Hr(s, p);
      Cc(s, p);
      var X;
      switch (s) {
        case "dialog":
          Pa("cancel", a), Pa("close", a), X = p;
          break;
        case "iframe":
        case "object":
        case "embed":
          Pa("load", a), X = p;
          break;
        case "video":
        case "audio":
          for (var K = 0; K < fA.length; K++)
            Pa(fA[K], a);
          X = p;
          break;
        case "source":
          Pa("error", a), X = p;
          break;
        case "img":
        case "image":
        case "link":
          Pa("error", a), Pa("load", a), X = p;
          break;
        case "details":
          Pa("toggle", a), X = p;
          break;
        case "input":
          hI(a, p), X = Ps(a, p), Pa("invalid", a);
          break;
        case "option":
          ur(a, p), X = p;
          break;
        case "select":
          mg(a, p), X = ud(a, p), Pa("invalid", a);
          break;
        case "textarea":
          vp(a, p), X = ah(a, p), Pa("invalid", a);
          break;
        default:
          X = p;
      }
      switch (Qo(s, X), bR(s, a, y, X, Z), s) {
        case "input":
          $a(a), gt(a, p, !1);
          break;
        case "textarea":
          $a(a), uf(a);
          break;
        case "option":
          nr(a, p);
          break;
        case "select":
          lf(a, p);
          break;
        default:
          typeof X.onClick == "function" && Pv(a);
          break;
      }
    }
    function BR(a, s, p, y, Z) {
      Cc(s, y);
      var X = null, K, Q;
      switch (s) {
        case "input":
          K = Ps(a, p), Q = Ps(a, y), X = [];
          break;
        case "select":
          K = ud(a, p), Q = ud(a, y), X = [];
          break;
        case "textarea":
          K = ah(a, p), Q = ah(a, y), X = [];
          break;
        default:
          K = p, Q = y, typeof K.onClick != "function" && typeof Q.onClick == "function" && Pv(a);
          break;
      }
      Qo(s, Q);
      var te, ce, Ce = null;
      for (te in K)
        if (!(Q.hasOwnProperty(te) || !K.hasOwnProperty(te) || K[te] == null))
          if (te === RC) {
            var Qe = K[te];
            for (ce in Qe)
              Qe.hasOwnProperty(ce) && (Ce || (Ce = {}), Ce[ce] = "");
          } else te === kv || te === Xf || te === Dv || te === Mh || te === t0 || (Dt.hasOwnProperty(te) ? X || (X = []) : (X = X || []).push(te, null));
      for (te in Q) {
        var Pe = Q[te], pt = K?.[te];
        if (!(!Q.hasOwnProperty(te) || Pe === pt || Pe == null && pt == null))
          if (te === RC)
            if (Pe && Object.freeze(Pe), pt) {
              for (ce in pt)
                pt.hasOwnProperty(ce) && (!Pe || !Pe.hasOwnProperty(ce)) && (Ce || (Ce = {}), Ce[ce] = "");
              for (ce in Pe)
                Pe.hasOwnProperty(ce) && pt[ce] !== Pe[ce] && (Ce || (Ce = {}), Ce[ce] = Pe[ce]);
            } else
              Ce || (X || (X = []), X.push(te, Ce)), Ce = Pe;
          else if (te === kv) {
            var yt = Pe ? Pe[Ic] : void 0, Yt = pt ? pt[Ic] : void 0;
            yt != null && Yt !== yt && (X = X || []).push(te, yt);
          } else te === Xf ? (typeof Pe == "string" || typeof Pe == "number") && (X = X || []).push(te, "" + Pe) : te === Dv || te === Mh || (Dt.hasOwnProperty(te) ? (Pe != null && (typeof Pe != "function" && Up(te, Pe), te === "onScroll" && Pa("scroll", a)), !X && pt !== Pe && (X = [])) : (X = X || []).push(te, Pe));
      }
      return Ce && (Dr(Ce, Q[RC]), (X = X || []).push(RC, Ce)), X;
    }
    function Jv(a, s, p, y, Z) {
      p === "input" && Z.type === "radio" && Z.name != null && ie(a, Z);
      var X = Hr(p, y), K = Hr(p, Z);
      switch (yV(a, s, X, K), p) {
        case "input":
          Me(a, Z);
          break;
        case "textarea":
          yp(a, Z);
          break;
        case "select":
          nh(a, Z);
          break;
      }
    }
    function Qv(a) {
      {
        var s = a.toLowerCase();
        return fa.hasOwnProperty(s) && fa[s] || null;
      }
    }
    function r0(a, s, p, y, Z, X, K) {
      var Q, te;
      switch (Q = Hr(s, p), Cc(s, p), s) {
        case "dialog":
          Pa("cancel", a), Pa("close", a);
          break;
        case "iframe":
        case "object":
        case "embed":
          Pa("load", a);
          break;
        case "video":
        case "audio":
          for (var ce = 0; ce < fA.length; ce++)
            Pa(fA[ce], a);
          break;
        case "source":
          Pa("error", a);
          break;
        case "img":
        case "image":
        case "link":
          Pa("error", a), Pa("load", a);
          break;
        case "details":
          Pa("toggle", a);
          break;
        case "input":
          hI(a, p), Pa("invalid", a);
          break;
        case "option":
          ur(a, p);
          break;
        case "select":
          mg(a, p), Pa("invalid", a);
          break;
        case "textarea":
          vp(a, p), Pa("invalid", a);
          break;
      }
      Qo(s, p);
      {
        te = /* @__PURE__ */ new Set();
        for (var Ce = a.attributes, Qe = 0; Qe < Ce.length; Qe++) {
          var Pe = Ce[Qe].name.toLowerCase();
          switch (Pe) {
            // Controlled attributes are not validated
            // TODO: Only ignore them on controlled tags.
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              te.add(Ce[Qe].name);
          }
        }
      }
      var pt = null;
      for (var yt in p)
        if (p.hasOwnProperty(yt)) {
          var Yt = p[yt];
          if (yt === Xf)
            typeof Yt == "string" ? a.textContent !== Yt && (p[Mh] !== !0 && Ov(a.textContent, Yt, X, K), pt = [Xf, Yt]) : typeof Yt == "number" && a.textContent !== "" + Yt && (p[Mh] !== !0 && Ov(a.textContent, Yt, X, K), pt = [Xf, "" + Yt]);
          else if (Dt.hasOwnProperty(yt))
            Yt != null && (typeof Yt != "function" && Up(yt, Yt), yt === "onScroll" && Pa("scroll", a));
          else if (K && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof Q == "boolean") {
            var On = void 0, Ri = it(yt);
            if (p[Mh] !== !0) {
              if (!(yt === Dv || yt === Mh || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              yt === "value" || yt === "checked" || yt === "selected")) {
                if (yt === kv) {
                  var hi = a.innerHTML, Er = Yt ? Yt[Ic] : void 0;
                  if (Er != null) {
                    var Rr = i0(a, Er);
                    Rr !== hi && Dp(yt, hi, Rr);
                  }
                } else if (yt === RC) {
                  if (te.delete(yt), AR) {
                    var ut = oh(Yt);
                    On = a.getAttribute("style"), ut !== On && Dp(yt, On, ut);
                  }
                } else if (Q)
                  te.delete(yt.toLowerCase()), On = la(a, yt, Yt), Yt !== On && Dp(yt, On, Yt);
                else if (!we(yt, Ri, Q) && !de(yt, Yt, Ri, Q)) {
                  var Ft = !1;
                  if (Ri !== null)
                    te.delete(Ri.attributeName), On = xr(a, yt, Yt, Ri);
                  else {
                    var ct = y;
                    if (ct === Ss && (ct = ml(s)), ct === Ss)
                      te.delete(yt.toLowerCase());
                    else {
                      var cn = Qv(yt);
                      cn !== null && cn !== yt && (Ft = !0, te.delete(cn)), te.delete(yt);
                    }
                    On = la(a, yt, Yt);
                  }
                  var ni = Ye;
                  !ni && Yt !== On && !Ft && Dp(yt, On, Yt);
                }
              }
            }
          }
        }
      switch (K && // $FlowFixMe - Should be inferred as not undefined.
      te.size > 0 && p[Mh] !== !0 && n0(te), s) {
        case "input":
          $a(a), gt(a, p, !0);
          break;
        case "textarea":
          $a(a), uf(a);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof p.onClick == "function" && Pv(a);
          break;
      }
      return pt;
    }
    function a0(a, s, p) {
      var y = a.nodeValue !== s;
      return y;
    }
    function o0(a, s) {
      {
        if (Oc)
          return;
        Oc = !0, u("Did not expect server HTML to contain a <%s> in <%s>.", s.nodeName.toLowerCase(), a.nodeName.toLowerCase());
      }
    }
    function Op(a, s) {
      {
        if (Oc)
          return;
        Oc = !0, u('Did not expect server HTML to contain the text node "%s" in <%s>.', s.nodeValue, a.nodeName.toLowerCase());
      }
    }
    function cl(a, s, p) {
      {
        if (Oc)
          return;
        Oc = !0, u("Expected server HTML to contain a matching <%s> in <%s>.", s, a.nodeName.toLowerCase());
      }
    }
    function s0(a, s) {
      {
        if (s === "" || Oc)
          return;
        Oc = !0, u('Expected server HTML to contain a matching text node for "%s" in <%s>.', s, a.nodeName.toLowerCase());
      }
    }
    function jv(a, s, p) {
      switch (s) {
        case "input":
          St(a, p);
          return;
        case "textarea":
          qI(a, p);
          return;
        case "select":
          ih(a, p);
          return;
      }
    }
    var hc = function() {
    }, Pp = function() {
    };
    {
      var qv = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], l0 = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], OB = l0.concat(["button"]), PB = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], Yf = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Pp = function(a, s) {
        var p = rn({}, a || Yf), y = {
          tag: s
        };
        return l0.indexOf(s) !== -1 && (p.aTagInScope = null, p.buttonTagInScope = null, p.nobrTagInScope = null), OB.indexOf(s) !== -1 && (p.pTagInButtonScope = null), qv.indexOf(s) !== -1 && s !== "address" && s !== "div" && s !== "p" && (p.listItemTagAutoclosing = null, p.dlItemTagAutoclosing = null), p.current = y, s === "form" && (p.formTag = y), s === "a" && (p.aTagInScope = y), s === "button" && (p.buttonTagInScope = y), s === "nobr" && (p.nobrTagInScope = y), s === "p" && (p.pTagInButtonScope = y), s === "li" && (p.listItemTagAutoclosing = y), (s === "dd" || s === "dt") && (p.dlItemTagAutoclosing = y), p;
      };
      var JB = function(a, s) {
        switch (s) {
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
          case "select":
            return a === "option" || a === "optgroup" || a === "#text";
          case "optgroup":
            return a === "option" || a === "#text";
          // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
          // but
          case "option":
            return a === "#text";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
          // No special behavior since these rules fall back to "in body" mode for
          // all except special table nodes which cause bad parsing behavior anyway.
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
          case "tr":
            return a === "th" || a === "td" || a === "style" || a === "script" || a === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
          case "tbody":
          case "thead":
          case "tfoot":
            return a === "tr" || a === "style" || a === "script" || a === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
          case "colgroup":
            return a === "col" || a === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
          case "table":
            return a === "caption" || a === "colgroup" || a === "tbody" || a === "tfoot" || a === "thead" || a === "style" || a === "script" || a === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
          case "head":
            return a === "base" || a === "basefont" || a === "bgsound" || a === "link" || a === "meta" || a === "title" || a === "noscript" || a === "noframes" || a === "style" || a === "script" || a === "template";
          // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
          case "html":
            return a === "head" || a === "body" || a === "frameset";
          case "frameset":
            return a === "frame";
          case "#document":
            return a === "html";
        }
        switch (a) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return s !== "h1" && s !== "h2" && s !== "h3" && s !== "h4" && s !== "h5" && s !== "h6";
          case "rp":
          case "rt":
            return PB.indexOf(s) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return s == null;
        }
        return !0;
      }, u0 = function(a, s) {
        switch (a) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return s.pTagInButtonScope;
          case "form":
            return s.formTag || s.pTagInButtonScope;
          case "li":
            return s.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return s.dlItemTagAutoclosing;
          case "button":
            return s.buttonTagInScope;
          case "a":
            return s.aTagInScope;
          case "nobr":
            return s.nobrTagInScope;
        }
        return null;
      }, Fu = {};
      hc = function(a, s, p) {
        p = p || Yf;
        var y = p.current, Z = y && y.tag;
        s != null && (a != null && u("validateDOMNesting: when childText is passed, childTag should be null"), a = "#text");
        var X = JB(a, Z) ? null : y, K = X ? null : u0(a, p), Q = X || K;
        if (Q) {
          var te = Q.tag, ce = !!X + "|" + a + "|" + te;
          if (!Fu[ce]) {
            Fu[ce] = !0;
            var Ce = a, Qe = "";
            if (a === "#text" ? /\S/.test(s) ? Ce = "Text nodes" : (Ce = "Whitespace text nodes", Qe = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Ce = "<" + a + ">", X) {
              var Pe = "";
              te === "table" && a === "tr" && (Pe += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), u("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Ce, te, Qe, Pe);
            } else
              u("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Ce, te);
          }
        }
      };
    }
    var c0 = "suppressHydrationWarning", $v = "$", ey = "/$", AA = "$?", vA = "$!", GV = "style", QB = null, jB = null;
    function SR(a) {
      var s, p, y = a.nodeType;
      switch (y) {
        case yu:
        case Jo: {
          s = y === yu ? "#document" : "#fragment";
          var Z = a.documentElement;
          p = Z ? Z.namespaceURI : Qs(null, "");
          break;
        }
        default: {
          var X = y === ha ? a.parentNode : a, K = X.namespaceURI || null;
          s = X.tagName, p = Qs(K, s);
          break;
        }
      }
      {
        var Q = s.toLowerCase(), te = Pp(null, Q);
        return {
          namespace: p,
          ancestorInfo: te
        };
      }
    }
    function qB(a, s, p) {
      {
        var y = a, Z = Qs(y.namespace, s), X = Pp(y.ancestorInfo, s);
        return {
          namespace: Z,
          ancestorInfo: X
        };
      }
    }
    function BV(a) {
      return a;
    }
    function $B(a) {
      QB = sl(), jB = YB();
      var s = null;
      return Lo(!1), s;
    }
    function ZR(a) {
      Ob(jB), Lo(QB), QB = null, jB = null;
    }
    function SV(a, s, p, y, Z) {
      var X;
      {
        var K = y;
        if (hc(a, null, K.ancestorInfo), typeof s.children == "string" || typeof s.children == "number") {
          var Q = "" + s.children, te = Pp(K.ancestorInfo, a);
          hc(null, Q, te);
        }
        X = K.namespace;
      }
      var ce = bV(a, s, p, X);
      return SA(Z, ce), cS(ce, s), ce;
    }
    function wR(a, s) {
      a.appendChild(s);
    }
    function ZV(a, s, p, y, Z) {
      switch (GR(a, s, p, y), s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!p.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function wV(a, s, p, y, Z, X) {
      {
        var K = X;
        if (typeof y.children != typeof p.children && (typeof y.children == "string" || typeof y.children == "number")) {
          var Q = "" + y.children, te = Pp(K.ancestorInfo, s);
          hc(null, Q, te);
        }
      }
      return BR(a, s, p, y);
    }
    function eS(a, s) {
      return a === "textarea" || a === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null;
    }
    function RV(a, s, p, y) {
      {
        var Z = p;
        hc(null, a, Z.ancestorInfo);
      }
      var X = xC(a, s);
      return SA(y, X), X;
    }
    function xV() {
      var a = window.event;
      return a === void 0 ? Is : AC(a.type);
    }
    var ty = typeof setTimeout == "function" ? setTimeout : void 0, g0 = typeof clearTimeout == "function" ? clearTimeout : void 0, yA = -1, tS = typeof Promise == "function" ? Promise : void 0, WV = typeof queueMicrotask == "function" ? queueMicrotask : typeof tS < "u" ? function(a) {
      return tS.resolve(null).then(a).catch(RR);
    } : ty;
    function RR(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function xR(a, s, p, y) {
      switch (s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && a.focus();
          return;
        case "img": {
          p.src && (a.src = p.src);
          return;
        }
      }
    }
    function nS(a, s, p, y, Z, X) {
      Jv(a, s, p, y, Z), cS(a, Z);
    }
    function WR(a) {
      eo(a, "");
    }
    function iS(a, s, p) {
      a.nodeValue = p;
    }
    function VR(a, s) {
      a.appendChild(s);
    }
    function NR(a, s) {
      var p;
      a.nodeType === ha ? (p = a.parentNode, p.insertBefore(s, a)) : (p = a, p.appendChild(s));
      var y = a._reactRootContainer;
      y == null && p.onclick === null && Pv(p);
    }
    function MR(a, s, p) {
      a.insertBefore(s, p);
    }
    function d0(a, s, p) {
      a.nodeType === ha ? a.parentNode.insertBefore(s, p) : a.insertBefore(s, p);
    }
    function VV(a, s) {
      a.removeChild(s);
    }
    function NV(a, s) {
      a.nodeType === ha ? a.parentNode.removeChild(s) : a.removeChild(s);
    }
    function rS(a, s) {
      var p = s, y = 0;
      do {
        var Z = p.nextSibling;
        if (a.removeChild(p), Z && Z.nodeType === ha) {
          var X = Z.data;
          if (X === ey)
            if (y === 0) {
              a.removeChild(Z), Va(s);
              return;
            } else
              y--;
          else (X === $v || X === AA || X === vA) && y++;
        }
        p = Z;
      } while (p);
      Va(s);
    }
    function HR(a, s) {
      a.nodeType === ha ? rS(a.parentNode, s) : a.nodeType === vo && rS(a, s), Va(a);
    }
    function MV(a) {
      a = a;
      var s = a.style;
      typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none";
    }
    function HV(a) {
      a.nodeValue = "";
    }
    function XV(a, s) {
      a = a;
      var p = s[GV], y = p != null && p.hasOwnProperty("display") ? p.display : null;
      a.style.display = eC("display", y);
    }
    function YV(a, s) {
      a.nodeValue = s;
    }
    function XR(a) {
      a.nodeType === vo ? a.textContent = "" : a.nodeType === yu && a.documentElement && a.removeChild(a.documentElement);
    }
    function FV(a, s, p) {
      return a.nodeType !== vo || s.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
    }
    function aS(a, s) {
      return s === "" || a.nodeType !== Wc ? null : a;
    }
    function YR(a) {
      return a.nodeType !== ha ? null : a;
    }
    function FR(a) {
      return a.data === AA;
    }
    function I0(a) {
      return a.data === vA;
    }
    function EV(a) {
      var s = a.nextSibling && a.nextSibling.dataset, p, y, Z;
      return s && (p = s.dgst, y = s.msg, Z = s.stck), {
        message: y,
        digest: p,
        stack: Z
      };
    }
    function ER(a, s) {
      a._reactRetry = s;
    }
    function C0(a) {
      for (; a != null; a = a.nextSibling) {
        var s = a.nodeType;
        if (s === vo || s === Wc)
          break;
        if (s === ha) {
          var p = a.data;
          if (p === $v || p === vA || p === AA)
            break;
          if (p === ey)
            return null;
        }
      }
      return a;
    }
    function Ff(a) {
      return C0(a.nextSibling);
    }
    function Hh(a) {
      return C0(a.firstChild);
    }
    function TV(a) {
      return C0(a.firstChild);
    }
    function oS(a) {
      return C0(a.nextSibling);
    }
    function _V(a, s, p, y, Z, X, K) {
      SA(X, a), cS(a, p);
      var Q;
      {
        var te = Z;
        Q = te.namespace;
      }
      var ce = (X.mode & Oi) !== si;
      return r0(a, s, p, Q, y, ce, K);
    }
    function TR(a, s, p, y) {
      return SA(p, a), p.mode & Oi, a0(a, s);
    }
    function zV(a, s) {
      SA(s, a);
    }
    function _R(a) {
      for (var s = a.nextSibling, p = 0; s; ) {
        if (s.nodeType === ha) {
          var y = s.data;
          if (y === ey) {
            if (p === 0)
              return Ff(s);
            p--;
          } else (y === $v || y === vA || y === AA) && p++;
        }
        s = s.nextSibling;
      }
      return null;
    }
    function sS(a) {
      for (var s = a.previousSibling, p = 0; s; ) {
        if (s.nodeType === ha) {
          var y = s.data;
          if (y === $v || y === vA || y === AA) {
            if (p === 0)
              return s;
            p--;
          } else y === ey && p++;
        }
        s = s.previousSibling;
      }
      return null;
    }
    function zR(a) {
      Va(a);
    }
    function lS(a) {
      Va(a);
    }
    function KV(a) {
      return a !== "head" && a !== "body";
    }
    function ny(a, s, p, y) {
      var Z = !0;
      Ov(s.nodeValue, p, y, Z);
    }
    function h0(a, s, p, y, Z, X) {
      if (s[c0] !== !0) {
        var K = !0;
        Ov(y.nodeValue, Z, X, K);
      }
    }
    function LV(a, s) {
      s.nodeType === vo ? o0(a, s) : s.nodeType === ha || Op(a, s);
    }
    function KR(a, s) {
      {
        var p = a.parentNode;
        p !== null && (s.nodeType === vo ? o0(p, s) : s.nodeType === ha || Op(p, s));
      }
    }
    function kV(a, s, p, y, Z) {
      (Z || s[c0] !== !0) && (y.nodeType === vo ? o0(p, y) : y.nodeType === ha || Op(p, y));
    }
    function LR(a, s, p) {
      cl(a, s);
    }
    function kR(a, s) {
      s0(a, s);
    }
    function f0(a, s, p) {
      {
        var y = a.parentNode;
        y !== null && cl(y, s);
      }
    }
    function Ef(a, s) {
      {
        var p = a.parentNode;
        p !== null && s0(p, s);
      }
    }
    function DV(a, s, p, y, Z, X) {
      (X || s[c0] !== !0) && cl(p, y);
    }
    function Dn(a, s, p, y, Z) {
      (Z || s[c0] !== !0) && s0(p, y);
    }
    function bA(a) {
      u("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", a.nodeName.toLowerCase());
    }
    function GA(a) {
      Mf(a);
    }
    var ns = Math.random().toString(36).slice(2), BA = "__reactFiber$" + ns, p0 = "__reactProps$" + ns, Jp = "__reactContainer$" + ns, uS = "__reactEvents$" + ns, DR = "__reactListeners$" + ns, m0 = "__reactHandles$" + ns;
    function A0(a) {
      delete a[BA], delete a[p0], delete a[uS], delete a[DR], delete a[m0];
    }
    function SA(a, s) {
      s[BA] = a;
    }
    function v0(a, s) {
      s[Jp] = a;
    }
    function UR(a) {
      a[Jp] = null;
    }
    function iy(a) {
      return !!a[Jp];
    }
    function Qp(a) {
      var s = a[BA];
      if (s)
        return s;
      for (var p = a.parentNode; p; ) {
        if (s = p[Jp] || p[BA], s) {
          var y = s.alternate;
          if (s.child !== null || y !== null && y.child !== null)
            for (var Z = sS(a); Z !== null; ) {
              var X = Z[BA];
              if (X)
                return X;
              Z = sS(Z);
            }
          return s;
        }
        a = p, p = a.parentNode;
      }
      return null;
    }
    function Cs(a) {
      var s = a[BA] || a[Jp];
      return s && (s.tag === R || s.tag === W || s.tag === D || s.tag === b) ? s : null;
    }
    function Pc(a) {
      if (a.tag === R || a.tag === W)
        return a.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function y0(a) {
      return a[p0] || null;
    }
    function cS(a, s) {
      a[p0] = s;
    }
    function UV(a) {
      var s = a[uS];
      return s === void 0 && (s = a[uS] = /* @__PURE__ */ new Set()), s;
    }
    var OR = {}, gS = n.ReactDebugCurrentFrame;
    function b0(a) {
      if (a) {
        var s = a._owner, p = dI(a.type, a._source, s ? s.type : null);
        gS.setExtraStackFrame(p);
      } else
        gS.setExtraStackFrame(null);
    }
    function Xd(a, s, p, y, Z) {
      {
        var X = Function.call.bind(Wt);
        for (var K in a)
          if (X(a, K)) {
            var Q = void 0;
            try {
              if (typeof a[K] != "function") {
                var te = Error((y || "React class") + ": " + p + " type `" + K + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[K] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw te.name = "Invariant Violation", te;
              }
              Q = a[K](s, K, y, p, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ce) {
              Q = ce;
            }
            Q && !(Q instanceof Error) && (b0(Z), u("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", y || "React class", p, K, typeof Q), b0(null)), Q instanceof Error && !(Q.message in OR) && (OR[Q.message] = !0, b0(Z), u("Failed %s type: %s", p, Q.message), b0(null));
          }
      }
    }
    var G0 = [], B0;
    B0 = [];
    var WC = -1;
    function Tf(a) {
      return {
        current: a
      };
    }
    function Eu(a, s) {
      if (WC < 0) {
        u("Unexpected pop.");
        return;
      }
      s !== B0[WC] && u("Unexpected Fiber popped."), a.current = G0[WC], G0[WC] = null, B0[WC] = null, WC--;
    }
    function Tu(a, s, p) {
      WC++, G0[WC] = a.current, B0[WC] = p, a.current = s;
    }
    var S0;
    S0 = {};
    var Jc = {};
    Object.freeze(Jc);
    var VC = Tf(Jc), Yd = Tf(!1), ry = Jc;
    function jp(a, s, p) {
      return p && NC(s) ? ry : VC.current;
    }
    function PR(a, s, p) {
      {
        var y = a.stateNode;
        y.__reactInternalMemoizedUnmaskedChildContext = s, y.__reactInternalMemoizedMaskedChildContext = p;
      }
    }
    function _f(a, s) {
      {
        var p = a.type, y = p.contextTypes;
        if (!y)
          return Jc;
        var Z = a.stateNode;
        if (Z && Z.__reactInternalMemoizedUnmaskedChildContext === s)
          return Z.__reactInternalMemoizedMaskedChildContext;
        var X = {};
        for (var K in y)
          X[K] = s[K];
        {
          var Q = xi(a) || "Unknown";
          Xd(y, X, "context", Q);
        }
        return Z && PR(a, s, X), X;
      }
    }
    function ay() {
      return Yd.current;
    }
    function NC(a) {
      {
        var s = a.childContextTypes;
        return s != null;
      }
    }
    function qp(a) {
      Eu(Yd, a), Eu(VC, a);
    }
    function dS(a) {
      Eu(Yd, a), Eu(VC, a);
    }
    function JR(a, s, p) {
      {
        if (VC.current !== Jc)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Tu(VC, s, a), Tu(Yd, p, a);
      }
    }
    function QR(a, s, p) {
      {
        var y = a.stateNode, Z = s.childContextTypes;
        if (typeof y.getChildContext != "function") {
          {
            var X = xi(a) || "Unknown";
            S0[X] || (S0[X] = !0, u("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", X, X));
          }
          return p;
        }
        var K = y.getChildContext();
        for (var Q in K)
          if (!(Q in Z))
            throw new Error((xi(a) || "Unknown") + '.getChildContext(): key "' + Q + '" is not defined in childContextTypes.');
        {
          var te = xi(a) || "Unknown";
          Xd(Z, K, "child context", te);
        }
        return rn({}, p, K);
      }
    }
    function Z0(a) {
      {
        var s = a.stateNode, p = s && s.__reactInternalMemoizedMergedChildContext || Jc;
        return ry = VC.current, Tu(VC, p, a), Tu(Yd, Yd.current, a), !0;
      }
    }
    function jR(a, s, p) {
      {
        var y = a.stateNode;
        if (!y)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (p) {
          var Z = QR(a, s, ry);
          y.__reactInternalMemoizedMergedChildContext = Z, Eu(Yd, a), Eu(VC, a), Tu(VC, Z, a), Tu(Yd, p, a);
        } else
          Eu(Yd, a), Tu(Yd, p, a);
      }
    }
    function OV(a) {
      {
        if (!dh(a) || a.tag !== f)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var s = a;
        do {
          switch (s.tag) {
            case b:
              return s.stateNode.context;
            case f: {
              var p = s.type;
              if (NC(p))
                return s.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          s = s.return;
        } while (s !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Xh = 0, ZA = 1, Yh = null, w0 = !1, IS = !1;
    function CS(a) {
      Yh === null ? Yh = [a] : Yh.push(a);
    }
    function PV(a) {
      w0 = !0, CS(a);
    }
    function qR() {
      w0 && zf();
    }
    function zf() {
      if (!IS && Yh !== null) {
        IS = !0;
        var a = 0, s = Nl();
        try {
          var p = !0, y = Yh;
          for (zo(Vl); a < y.length; a++) {
            var Z = y[a];
            do
              Z = Z(p);
            while (Z !== null);
          }
          Yh = null, w0 = !1;
        } catch (X) {
          throw Yh !== null && (Yh = Yh.slice(a + 1)), bd(Wu, zf), X;
        } finally {
          zo(s), IS = !1;
        }
      }
      return null;
    }
    var wA = [], RA = 0, R0 = null, x0 = 0, Fd = [], Ed = 0, $p = null, Fh = 1, MC = "";
    function Td(a) {
      return nm(), (a.flags & Yc) !== Nn;
    }
    function JV(a) {
      return nm(), x0;
    }
    function QV() {
      var a = MC, s = Fh, p = s & ~W0(s);
      return p.toString(32) + a;
    }
    function em(a, s) {
      nm(), wA[RA++] = x0, wA[RA++] = R0, R0 = a, x0 = s;
    }
    function $R(a, s, p) {
      nm(), Fd[Ed++] = Fh, Fd[Ed++] = MC, Fd[Ed++] = $p, $p = a;
      var y = Fh, Z = MC, X = tm(y) - 1, K = y & ~(1 << X), Q = p + 1, te = tm(s) + X;
      if (te > 30) {
        var ce = X - X % 5, Ce = (1 << ce) - 1, Qe = (K & Ce).toString(32), Pe = K >> ce, pt = X - ce, yt = tm(s) + pt, Yt = Q << pt, On = Yt | Pe, Ri = Qe + Z;
        Fh = 1 << yt | On, MC = Ri;
      } else {
        var hi = Q << X, Er = hi | K, Rr = Z;
        Fh = 1 << te | Er, MC = Rr;
      }
    }
    function xA(a) {
      nm();
      var s = a.return;
      if (s !== null) {
        var p = 1, y = 0;
        em(a, p), $R(a, p, y);
      }
    }
    function tm(a) {
      return 32 - fr(a);
    }
    function W0(a) {
      return 1 << tm(a) - 1;
    }
    function WA(a) {
      for (; a === R0; )
        R0 = wA[--RA], wA[RA] = null, x0 = wA[--RA], wA[RA] = null;
      for (; a === $p; )
        $p = Fd[--Ed], Fd[Ed] = null, MC = Fd[--Ed], Fd[Ed] = null, Fh = Fd[--Ed], Fd[Ed] = null;
    }
    function V0() {
      return nm(), $p !== null ? {
        id: Fh,
        overflow: MC
      } : null;
    }
    function oy(a, s) {
      nm(), Fd[Ed++] = Fh, Fd[Ed++] = MC, Fd[Ed++] = $p, Fh = s.id, MC = s.overflow, $p = a;
    }
    function nm() {
      Co() || u("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var ou = null, _d = null, YI = !1, im = !1, HC = null;
    function hS() {
      YI && u("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function N0() {
      im = !0;
    }
    function ex() {
      return im;
    }
    function jV(a) {
      var s = a.stateNode.containerInfo;
      return _d = TV(s), ou = a, YI = !0, HC = null, im = !1, !0;
    }
    function M0(a, s, p) {
      return _d = oS(s), ou = a, YI = !0, HC = null, im = !1, p !== null && oy(a, p), !0;
    }
    function tx(a, s) {
      switch (a.tag) {
        case b: {
          LV(a.stateNode.containerInfo, s);
          break;
        }
        case R: {
          var p = (a.mode & Oi) !== si;
          kV(
            a.type,
            a.memoizedProps,
            a.stateNode,
            s,
            // TODO: Delete this argument when we remove the legacy root API.
            p
          );
          break;
        }
        case D: {
          var y = a.memoizedState;
          y.dehydrated !== null && KR(y.dehydrated, s);
          break;
        }
      }
    }
    function nx(a, s) {
      tx(a, s);
      var p = WO();
      p.stateNode = s, p.return = a;
      var y = a.deletions;
      y === null ? (a.deletions = [p], a.flags |= ea) : y.push(p);
    }
    function fS(a, s) {
      {
        if (im)
          return;
        switch (a.tag) {
          case b: {
            var p = a.stateNode.containerInfo;
            switch (s.tag) {
              case R:
                var y = s.type;
                s.pendingProps, LR(p, y);
                break;
              case W:
                var Z = s.pendingProps;
                kR(p, Z);
                break;
            }
            break;
          }
          case R: {
            var X = a.type, K = a.memoizedProps, Q = a.stateNode;
            switch (s.tag) {
              case R: {
                var te = s.type, ce = s.pendingProps, Ce = (a.mode & Oi) !== si;
                DV(
                  X,
                  K,
                  Q,
                  te,
                  ce,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Ce
                );
                break;
              }
              case W: {
                var Qe = s.pendingProps, Pe = (a.mode & Oi) !== si;
                Dn(
                  X,
                  K,
                  Q,
                  Qe,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Pe
                );
                break;
              }
            }
            break;
          }
          case D: {
            var pt = a.memoizedState, yt = pt.dehydrated;
            if (yt !== null) switch (s.tag) {
              case R:
                var Yt = s.type;
                s.pendingProps, f0(yt, Yt);
                break;
              case W:
                var On = s.pendingProps;
                Ef(yt, On);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function sy(a, s) {
      s.flags = s.flags & -4097 | xa, fS(a, s);
    }
    function ix(a, s) {
      switch (a.tag) {
        case R: {
          var p = a.type;
          a.pendingProps;
          var y = FV(s, p);
          return y !== null ? (a.stateNode = y, ou = a, _d = Hh(y), !0) : !1;
        }
        case W: {
          var Z = a.pendingProps, X = aS(s, Z);
          return X !== null ? (a.stateNode = X, ou = a, _d = null, !0) : !1;
        }
        case D: {
          var K = YR(s);
          if (K !== null) {
            var Q = {
              dehydrated: K,
              treeContext: V0(),
              retryLane: il
            };
            a.memoizedState = Q;
            var te = VO(K);
            return te.return = a, a.child = te, ou = a, _d = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function pS(a) {
      return (a.mode & Oi) !== si && (a.flags & er) === Nn;
    }
    function mS(a) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function AS(a) {
      if (YI) {
        var s = _d;
        if (!s) {
          pS(a) && (fS(ou, a), mS()), sy(ou, a), YI = !1, ou = a;
          return;
        }
        var p = s;
        if (!ix(a, s)) {
          pS(a) && (fS(ou, a), mS()), s = Ff(p);
          var y = ou;
          if (!s || !ix(a, s)) {
            sy(ou, a), YI = !1, ou = a;
            return;
          }
          nx(y, p);
        }
      }
    }
    function rx(a, s, p) {
      var y = a.stateNode, Z = !im, X = _V(y, a.type, a.memoizedProps, s, p, a, Z);
      return a.updateQueue = X, X !== null;
    }
    function qV(a) {
      var s = a.stateNode, p = a.memoizedProps, y = TR(s, p, a);
      if (y) {
        var Z = ou;
        if (Z !== null)
          switch (Z.tag) {
            case b: {
              var X = Z.stateNode.containerInfo, K = (Z.mode & Oi) !== si;
              ny(
                X,
                s,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                K
              );
              break;
            }
            case R: {
              var Q = Z.type, te = Z.memoizedProps, ce = Z.stateNode, Ce = (Z.mode & Oi) !== si;
              h0(
                Q,
                te,
                ce,
                s,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                Ce
              );
              break;
            }
          }
      }
      return y;
    }
    function vS(a) {
      var s = a.memoizedState, p = s !== null ? s.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      zV(p, a);
    }
    function yS(a) {
      var s = a.memoizedState, p = s !== null ? s.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return _R(p);
    }
    function No(a) {
      for (var s = a.return; s !== null && s.tag !== R && s.tag !== b && s.tag !== D; )
        s = s.return;
      ou = s;
    }
    function Qc(a) {
      if (a !== ou)
        return !1;
      if (!YI)
        return No(a), YI = !0, !1;
      if (a.tag !== b && (a.tag !== R || KV(a.type) && !eS(a.type, a.memoizedProps))) {
        var s = _d;
        if (s)
          if (pS(a))
            H0(a), mS();
          else
            for (; s; )
              nx(a, s), s = Ff(s);
      }
      return No(a), a.tag === D ? _d = yS(a) : _d = ou ? Ff(a.stateNode) : null, !0;
    }
    function Xs() {
      return YI && _d !== null;
    }
    function H0(a) {
      for (var s = _d; s; )
        tx(a, s), s = Ff(s);
    }
    function hs() {
      ou = null, _d = null, YI = !1, im = !1;
    }
    function zd() {
      HC !== null && (sE(HC), HC = null);
    }
    function Co() {
      return YI;
    }
    function rm(a) {
      HC === null ? HC = [a] : HC.push(a);
    }
    var am = n.ReactCurrentBatchConfig, X0 = null;
    function ly() {
      return am.transition;
    }
    var Kd = {
      recordUnsafeLifecycleWarnings: function(a, s) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(a, s) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var bS = function(a) {
        for (var s = null, p = a; p !== null; )
          p.mode & Xi && (s = p), p = p.return;
        return s;
      }, Pi = function(a) {
        var s = [];
        return a.forEach(function(p) {
          s.push(p);
        }), s.sort().join(", ");
      }, Ys = [], Ta = [], ko = [], jc = [], om = [], Do = [], FI = /* @__PURE__ */ new Set();
      Kd.recordUnsafeLifecycleWarnings = function(a, s) {
        FI.has(a.type) || (typeof s.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        s.componentWillMount.__suppressDeprecationWarning !== !0 && Ys.push(a), a.mode & Xi && typeof s.UNSAFE_componentWillMount == "function" && Ta.push(a), typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && ko.push(a), a.mode & Xi && typeof s.UNSAFE_componentWillReceiveProps == "function" && jc.push(a), typeof s.componentWillUpdate == "function" && s.componentWillUpdate.__suppressDeprecationWarning !== !0 && om.push(a), a.mode & Xi && typeof s.UNSAFE_componentWillUpdate == "function" && Do.push(a));
      }, Kd.flushPendingUnsafeLifecycleWarnings = function() {
        var a = /* @__PURE__ */ new Set();
        Ys.length > 0 && (Ys.forEach(function(Pe) {
          a.add(xi(Pe) || "Component"), FI.add(Pe.type);
        }), Ys = []);
        var s = /* @__PURE__ */ new Set();
        Ta.length > 0 && (Ta.forEach(function(Pe) {
          s.add(xi(Pe) || "Component"), FI.add(Pe.type);
        }), Ta = []);
        var p = /* @__PURE__ */ new Set();
        ko.length > 0 && (ko.forEach(function(Pe) {
          p.add(xi(Pe) || "Component"), FI.add(Pe.type);
        }), ko = []);
        var y = /* @__PURE__ */ new Set();
        jc.length > 0 && (jc.forEach(function(Pe) {
          y.add(xi(Pe) || "Component"), FI.add(Pe.type);
        }), jc = []);
        var Z = /* @__PURE__ */ new Set();
        om.length > 0 && (om.forEach(function(Pe) {
          Z.add(xi(Pe) || "Component"), FI.add(Pe.type);
        }), om = []);
        var X = /* @__PURE__ */ new Set();
        if (Do.length > 0 && (Do.forEach(function(Pe) {
          X.add(xi(Pe) || "Component"), FI.add(Pe.type);
        }), Do = []), s.size > 0) {
          var K = Pi(s);
          u(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, K);
        }
        if (y.size > 0) {
          var Q = Pi(y);
          u(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, Q);
        }
        if (X.size > 0) {
          var te = Pi(X);
          u(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, te);
        }
        if (a.size > 0) {
          var ce = Pi(a);
          l(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ce);
        }
        if (p.size > 0) {
          var Ce = Pi(p);
          l(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ce);
        }
        if (Z.size > 0) {
          var Qe = Pi(Z);
          l(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Qe);
        }
      };
      var sm = /* @__PURE__ */ new Map(), VA = /* @__PURE__ */ new Set();
      Kd.recordLegacyContextWarning = function(a, s) {
        var p = bS(a);
        if (p === null) {
          u("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!VA.has(a.type)) {
          var y = sm.get(p);
          (a.type.contextTypes != null || a.type.childContextTypes != null || s !== null && typeof s.getChildContext == "function") && (y === void 0 && (y = [], sm.set(p, y)), y.push(a));
        }
      }, Kd.flushLegacyContextWarning = function() {
        sm.forEach(function(a, s) {
          if (a.length !== 0) {
            var p = a[0], y = /* @__PURE__ */ new Set();
            a.forEach(function(X) {
              y.add(xi(X) || "Component"), VA.add(X.type);
            });
            var Z = Pi(y);
            try {
              Lr(p), u(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, Z);
            } finally {
              Ra();
            }
          }
        });
      }, Kd.discardPendingWarnings = function() {
        Ys = [], Ta = [], ko = [], jc = [], om = [], Do = [], sm = /* @__PURE__ */ new Map();
      };
    }
    var NA, lm, _u, uy, Y0, GS = function(a, s) {
    };
    NA = !1, lm = !1, _u = {}, uy = {}, Y0 = {}, GS = function(a, s) {
      if (!(a === null || typeof a != "object") && !(!a._store || a._store.validated || a.key != null)) {
        if (typeof a._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        a._store.validated = !0;
        var p = xi(s) || "Component";
        uy[p] || (uy[p] = !0, u('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function $V(a) {
      return a.prototype && a.prototype.isReactComponent;
    }
    function XC(a, s, p) {
      var y = p.ref;
      if (y !== null && typeof y != "function" && typeof y != "object") {
        if ((a.mode & Xi || nt) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(p._owner && p._self && p._owner.stateNode !== p._self) && // Will already throw with "Function components cannot have string refs"
        !(p._owner && p._owner.tag !== f) && // Will already warn with "Function components cannot be given refs"
        !(typeof p.type == "function" && !$V(p.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        p._owner) {
          var Z = xi(a) || "Component";
          _u[Z] || (u('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Z, y), _u[Z] = !0);
        }
        if (p._owner) {
          var X = p._owner, K;
          if (X) {
            var Q = X;
            if (Q.tag !== f)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            K = Q.stateNode;
          }
          if (!K)
            throw new Error("Missing owner for string ref " + y + ". This error is likely caused by a bug in React. Please file an issue.");
          var te = K;
          hn(y, "ref");
          var ce = "" + y;
          if (s !== null && s.ref !== null && typeof s.ref == "function" && s.ref._stringRef === ce)
            return s.ref;
          var Ce = function(Qe) {
            var Pe = te.refs;
            Qe === null ? delete Pe[ce] : Pe[ce] = Qe;
          };
          return Ce._stringRef = ce, Ce;
        } else {
          if (typeof y != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!p._owner)
            throw new Error("Element ref was specified as a string (" + y + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return y;
    }
    function cy(a, s) {
      var p = Object.prototype.toString.call(s);
      throw new Error("Objects are not valid as a React child (found: " + (p === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : p) + "). If you meant to render a collection of children, use an array instead.");
    }
    function um(a) {
      {
        var s = xi(a) || "Component";
        if (Y0[s])
          return;
        Y0[s] = !0, u("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function F0(a) {
      var s = a._payload, p = a._init;
      return p(s);
    }
    function cm(a) {
      function s(ut, Ft) {
        if (a) {
          var ct = ut.deletions;
          ct === null ? (ut.deletions = [Ft], ut.flags |= ea) : ct.push(Ft);
        }
      }
      function p(ut, Ft) {
        if (!a)
          return null;
        for (var ct = Ft; ct !== null; )
          s(ut, ct), ct = ct.sibling;
        return null;
      }
      function y(ut, Ft) {
        for (var ct = /* @__PURE__ */ new Map(), cn = Ft; cn !== null; )
          cn.key !== null ? ct.set(cn.key, cn) : ct.set(cn.index, cn), cn = cn.sibling;
        return ct;
      }
      function Z(ut, Ft) {
        var ct = Yy(ut, Ft);
        return ct.index = 0, ct.sibling = null, ct;
      }
      function X(ut, Ft, ct) {
        if (ut.index = ct, !a)
          return ut.flags |= Yc, Ft;
        var cn = ut.alternate;
        if (cn !== null) {
          var ni = cn.index;
          return ni < Ft ? (ut.flags |= xa, Ft) : ni;
        } else
          return ut.flags |= xa, Ft;
      }
      function K(ut) {
        return a && ut.alternate === null && (ut.flags |= xa), ut;
      }
      function Q(ut, Ft, ct, cn) {
        if (Ft === null || Ft.tag !== W) {
          var ni = rM(ct, ut.mode, cn);
          return ni.return = ut, ni;
        } else {
          var Qn = Z(Ft, ct);
          return Qn.return = ut, Qn;
        }
      }
      function te(ut, Ft, ct, cn) {
        var ni = ct.type;
        if (ni === Et)
          return Ce(ut, Ft, ct.props.children, cn, ct.key);
        if (Ft !== null && (Ft.elementType === ni || // Keep this check inline so it only runs on the false path:
        GE(Ft, ct) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof ni == "object" && ni !== null && ni.$$typeof === ae && F0(ni) === Ft.type)) {
          var Qn = Z(Ft, ct.props);
          return Qn.ref = XC(ut, Ft, ct), Qn.return = ut, Qn._debugSource = ct._source, Qn._debugOwner = ct._owner, Qn;
        }
        var ki = iM(ct, ut.mode, cn);
        return ki.ref = XC(ut, Ft, ct), ki.return = ut, ki;
      }
      function ce(ut, Ft, ct, cn) {
        if (Ft === null || Ft.tag !== S || Ft.stateNode.containerInfo !== ct.containerInfo || Ft.stateNode.implementation !== ct.implementation) {
          var ni = aM(ct, ut.mode, cn);
          return ni.return = ut, ni;
        } else {
          var Qn = Z(Ft, ct.children || []);
          return Qn.return = ut, Qn;
        }
      }
      function Ce(ut, Ft, ct, cn, ni) {
        if (Ft === null || Ft.tag !== x) {
          var Qn = $A(ct, ut.mode, cn, ni);
          return Qn.return = ut, Qn;
        } else {
          var ki = Z(Ft, ct);
          return ki.return = ut, ki;
        }
      }
      function Qe(ut, Ft, ct) {
        if (typeof Ft == "string" && Ft !== "" || typeof Ft == "number") {
          var cn = rM("" + Ft, ut.mode, ct);
          return cn.return = ut, cn;
        }
        if (typeof Ft == "object" && Ft !== null) {
          switch (Ft.$$typeof) {
            case Oe: {
              var ni = iM(Ft, ut.mode, ct);
              return ni.ref = XC(ut, null, Ft), ni.return = ut, ni;
            }
            case rt: {
              var Qn = aM(Ft, ut.mode, ct);
              return Qn.return = ut, Qn;
            }
            case ae: {
              var ki = Ft._payload, qi = Ft._init;
              return Qe(ut, qi(ki), ct);
            }
          }
          if (Zi(Ft) || Zn(Ft)) {
            var Ma = $A(Ft, ut.mode, ct, null);
            return Ma.return = ut, Ma;
          }
          cy(ut, Ft);
        }
        return typeof Ft == "function" && um(ut), null;
      }
      function Pe(ut, Ft, ct, cn) {
        var ni = Ft !== null ? Ft.key : null;
        if (typeof ct == "string" && ct !== "" || typeof ct == "number")
          return ni !== null ? null : Q(ut, Ft, "" + ct, cn);
        if (typeof ct == "object" && ct !== null) {
          switch (ct.$$typeof) {
            case Oe:
              return ct.key === ni ? te(ut, Ft, ct, cn) : null;
            case rt:
              return ct.key === ni ? ce(ut, Ft, ct, cn) : null;
            case ae: {
              var Qn = ct._payload, ki = ct._init;
              return Pe(ut, Ft, ki(Qn), cn);
            }
          }
          if (Zi(ct) || Zn(ct))
            return ni !== null ? null : Ce(ut, Ft, ct, cn, null);
          cy(ut, ct);
        }
        return typeof ct == "function" && um(ut), null;
      }
      function pt(ut, Ft, ct, cn, ni) {
        if (typeof cn == "string" && cn !== "" || typeof cn == "number") {
          var Qn = ut.get(ct) || null;
          return Q(Ft, Qn, "" + cn, ni);
        }
        if (typeof cn == "object" && cn !== null) {
          switch (cn.$$typeof) {
            case Oe: {
              var ki = ut.get(cn.key === null ? ct : cn.key) || null;
              return te(Ft, ki, cn, ni);
            }
            case rt: {
              var qi = ut.get(cn.key === null ? ct : cn.key) || null;
              return ce(Ft, qi, cn, ni);
            }
            case ae:
              var Ma = cn._payload, oa = cn._init;
              return pt(ut, Ft, ct, oa(Ma), ni);
          }
          if (Zi(cn) || Zn(cn)) {
            var dl = ut.get(ct) || null;
            return Ce(Ft, dl, cn, ni, null);
          }
          cy(Ft, cn);
        }
        return typeof cn == "function" && um(Ft), null;
      }
      function yt(ut, Ft, ct) {
        {
          if (typeof ut != "object" || ut === null)
            return Ft;
          switch (ut.$$typeof) {
            case Oe:
            case rt:
              GS(ut, ct);
              var cn = ut.key;
              if (typeof cn != "string")
                break;
              if (Ft === null) {
                Ft = /* @__PURE__ */ new Set(), Ft.add(cn);
                break;
              }
              if (!Ft.has(cn)) {
                Ft.add(cn);
                break;
              }
              u("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", cn);
              break;
            case ae:
              var ni = ut._payload, Qn = ut._init;
              yt(Qn(ni), Ft, ct);
              break;
          }
        }
        return Ft;
      }
      function Yt(ut, Ft, ct, cn) {
        for (var ni = null, Qn = 0; Qn < ct.length; Qn++) {
          var ki = ct[Qn];
          ni = yt(ki, ni, ut);
        }
        for (var qi = null, Ma = null, oa = Ft, dl = 0, sa = 0, Ts = null; oa !== null && sa < ct.length; sa++) {
          oa.index > sa ? (Ts = oa, oa = null) : Ts = oa.sibling;
          var qc = Pe(ut, oa, ct[sa], cn);
          if (qc === null) {
            oa === null && (oa = Ts);
            break;
          }
          a && oa && qc.alternate === null && s(ut, oa), dl = X(qc, dl, sa), Ma === null ? qi = qc : Ma.sibling = qc, Ma = qc, oa = Ts;
        }
        if (sa === ct.length) {
          if (p(ut, oa), Co()) {
            var Sc = sa;
            em(ut, Sc);
          }
          return qi;
        }
        if (oa === null) {
          for (; sa < ct.length; sa++) {
            var _I = Qe(ut, ct[sa], cn);
            _I !== null && (dl = X(_I, dl, sa), Ma === null ? qi = _I : Ma.sibling = _I, Ma = _I);
          }
          if (Co()) {
            var Dg = sa;
            em(ut, Dg);
          }
          return qi;
        }
        for (var Ug = y(ut, oa); sa < ct.length; sa++) {
          var $c = pt(Ug, ut, sa, ct[sa], cn);
          $c !== null && (a && $c.alternate !== null && Ug.delete($c.key === null ? sa : $c.key), dl = X($c, dl, sa), Ma === null ? qi = $c : Ma.sibling = $c, Ma = $c);
        }
        if (a && Ug.forEach(function(mG) {
          return s(ut, mG);
        }), Co()) {
          var Zm = sa;
          em(ut, Zm);
        }
        return qi;
      }
      function On(ut, Ft, ct, cn) {
        var ni = Zn(ct);
        if (typeof ni != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          ct[Symbol.toStringTag] === "Generator" && (lm || u("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), lm = !0), ct.entries === ni && (NA || u("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), NA = !0);
          var Qn = ni.call(ct);
          if (Qn)
            for (var ki = null, qi = Qn.next(); !qi.done; qi = Qn.next()) {
              var Ma = qi.value;
              ki = yt(Ma, ki, ut);
            }
        }
        var oa = ni.call(ct);
        if (oa == null)
          throw new Error("An iterable object provided no iterator.");
        for (var dl = null, sa = null, Ts = Ft, qc = 0, Sc = 0, _I = null, Dg = oa.next(); Ts !== null && !Dg.done; Sc++, Dg = oa.next()) {
          Ts.index > Sc ? (_I = Ts, Ts = null) : _I = Ts.sibling;
          var Ug = Pe(ut, Ts, Dg.value, cn);
          if (Ug === null) {
            Ts === null && (Ts = _I);
            break;
          }
          a && Ts && Ug.alternate === null && s(ut, Ts), qc = X(Ug, qc, Sc), sa === null ? dl = Ug : sa.sibling = Ug, sa = Ug, Ts = _I;
        }
        if (Dg.done) {
          if (p(ut, Ts), Co()) {
            var $c = Sc;
            em(ut, $c);
          }
          return dl;
        }
        if (Ts === null) {
          for (; !Dg.done; Sc++, Dg = oa.next()) {
            var Zm = Qe(ut, Dg.value, cn);
            Zm !== null && (qc = X(Zm, qc, Sc), sa === null ? dl = Zm : sa.sibling = Zm, sa = Zm);
          }
          if (Co()) {
            var mG = Sc;
            em(ut, mG);
          }
          return dl;
        }
        for (var fZ = y(ut, Ts); !Dg.done; Sc++, Dg = oa.next()) {
          var jf = pt(fZ, ut, Sc, Dg.value, cn);
          jf !== null && (a && jf.alternate !== null && fZ.delete(jf.key === null ? Sc : jf.key), qc = X(jf, qc, Sc), sa === null ? dl = jf : sa.sibling = jf, sa = jf);
        }
        if (a && fZ.forEach(function(lP) {
          return s(ut, lP);
        }), Co()) {
          var sP = Sc;
          em(ut, sP);
        }
        return dl;
      }
      function Ri(ut, Ft, ct, cn) {
        if (Ft !== null && Ft.tag === W) {
          p(ut, Ft.sibling);
          var ni = Z(Ft, ct);
          return ni.return = ut, ni;
        }
        p(ut, Ft);
        var Qn = rM(ct, ut.mode, cn);
        return Qn.return = ut, Qn;
      }
      function hi(ut, Ft, ct, cn) {
        for (var ni = ct.key, Qn = Ft; Qn !== null; ) {
          if (Qn.key === ni) {
            var ki = ct.type;
            if (ki === Et) {
              if (Qn.tag === x) {
                p(ut, Qn.sibling);
                var qi = Z(Qn, ct.props.children);
                return qi.return = ut, qi._debugSource = ct._source, qi._debugOwner = ct._owner, qi;
              }
            } else if (Qn.elementType === ki || // Keep this check inline so it only runs on the false path:
            GE(Qn, ct) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof ki == "object" && ki !== null && ki.$$typeof === ae && F0(ki) === Qn.type) {
              p(ut, Qn.sibling);
              var Ma = Z(Qn, ct.props);
              return Ma.ref = XC(ut, Qn, ct), Ma.return = ut, Ma._debugSource = ct._source, Ma._debugOwner = ct._owner, Ma;
            }
            p(ut, Qn);
            break;
          } else
            s(ut, Qn);
          Qn = Qn.sibling;
        }
        if (ct.type === Et) {
          var oa = $A(ct.props.children, ut.mode, cn, ct.key);
          return oa.return = ut, oa;
        } else {
          var dl = iM(ct, ut.mode, cn);
          return dl.ref = XC(ut, Ft, ct), dl.return = ut, dl;
        }
      }
      function Er(ut, Ft, ct, cn) {
        for (var ni = ct.key, Qn = Ft; Qn !== null; ) {
          if (Qn.key === ni)
            if (Qn.tag === S && Qn.stateNode.containerInfo === ct.containerInfo && Qn.stateNode.implementation === ct.implementation) {
              p(ut, Qn.sibling);
              var ki = Z(Qn, ct.children || []);
              return ki.return = ut, ki;
            } else {
              p(ut, Qn);
              break;
            }
          else
            s(ut, Qn);
          Qn = Qn.sibling;
        }
        var qi = aM(ct, ut.mode, cn);
        return qi.return = ut, qi;
      }
      function Rr(ut, Ft, ct, cn) {
        var ni = typeof ct == "object" && ct !== null && ct.type === Et && ct.key === null;
        if (ni && (ct = ct.props.children), typeof ct == "object" && ct !== null) {
          switch (ct.$$typeof) {
            case Oe:
              return K(hi(ut, Ft, ct, cn));
            case rt:
              return K(Er(ut, Ft, ct, cn));
            case ae:
              var Qn = ct._payload, ki = ct._init;
              return Rr(ut, Ft, ki(Qn), cn);
          }
          if (Zi(ct))
            return Yt(ut, Ft, ct, cn);
          if (Zn(ct))
            return On(ut, Ft, ct, cn);
          cy(ut, ct);
        }
        return typeof ct == "string" && ct !== "" || typeof ct == "number" ? K(Ri(ut, Ft, "" + ct, cn)) : (typeof ct == "function" && um(ut), p(ut, Ft));
      }
      return Rr;
    }
    var Ld = cm(!0), YC = cm(!1);
    function gy(a, s) {
      if (a !== null && s.child !== a.child)
        throw new Error("Resuming work not yet implemented.");
      if (s.child !== null) {
        var p = s.child, y = Yy(p, p.pendingProps);
        for (s.child = y, y.return = s; p.sibling !== null; )
          p = p.sibling, y = y.sibling = Yy(p, p.pendingProps), y.return = s;
        y.sibling = null;
      }
    }
    function BS(a, s) {
      for (var p = a.child; p !== null; )
        SO(p, s), p = p.sibling;
    }
    var SS = Tf(null), gm;
    gm = {};
    var MA = null, HA = null, XA = null, Kf = !1;
    function dm() {
      MA = null, HA = null, XA = null, Kf = !1;
    }
    function dy() {
      Kf = !0;
    }
    function zu() {
      Kf = !1;
    }
    function Eh(a, s, p) {
      Tu(SS, s._currentValue, a), s._currentValue = p, s._currentRenderer !== void 0 && s._currentRenderer !== null && s._currentRenderer !== gm && u("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer = gm;
    }
    function ZS(a, s) {
      var p = SS.current;
      Eu(SS, s), a._currentValue = p;
    }
    function fs(a, s, p) {
      for (var y = a; y !== null; ) {
        var Z = y.alternate;
        if (ot(y.childLanes, s) ? Z !== null && !ot(Z.childLanes, s) && (Z.childLanes = Fe(Z.childLanes, s)) : (y.childLanes = Fe(y.childLanes, s), Z !== null && (Z.childLanes = Fe(Z.childLanes, s))), y === p)
          break;
        y = y.return;
      }
      y !== p && u("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function eN(a, s, p) {
      E0(a, s, p);
    }
    function E0(a, s, p) {
      var y = a.child;
      for (y !== null && (y.return = a); y !== null; ) {
        var Z = void 0, X = y.dependencies;
        if (X !== null) {
          Z = y.child;
          for (var K = X.firstContext; K !== null; ) {
            if (K.context === s) {
              if (y.tag === f) {
                var Q = Yi(p), te = FC(Nr, Q);
                te.tag = Cm;
                var ce = y.updateQueue;
                if (ce !== null) {
                  var Ce = ce.shared, Qe = Ce.pending;
                  Qe === null ? te.next = te : (te.next = Qe.next, Qe.next = te), Ce.pending = te;
                }
              }
              y.lanes = Fe(y.lanes, p);
              var Pe = y.alternate;
              Pe !== null && (Pe.lanes = Fe(Pe.lanes, p)), fs(y.return, p, a), X.lanes = Fe(X.lanes, p);
              break;
            }
            K = K.next;
          }
        } else if (y.tag === F)
          Z = y.type === a.type ? null : y.child;
        else if (y.tag === ne) {
          var pt = y.return;
          if (pt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          pt.lanes = Fe(pt.lanes, p);
          var yt = pt.alternate;
          yt !== null && (yt.lanes = Fe(yt.lanes, p)), fs(pt, p, a), Z = y.sibling;
        } else
          Z = y.child;
        if (Z !== null)
          Z.return = y;
        else
          for (Z = y; Z !== null; ) {
            if (Z === a) {
              Z = null;
              break;
            }
            var Yt = Z.sibling;
            if (Yt !== null) {
              Yt.return = Z.return, Z = Yt;
              break;
            }
            Z = Z.return;
          }
        y = Z;
      }
    }
    function Im(a, s) {
      MA = a, HA = null, XA = null;
      var p = a.dependencies;
      if (p !== null) {
        var y = p.firstContext;
        y !== null && (ga(p.lanes, s) && $S(), p.firstContext = null);
      }
    }
    function Or(a) {
      Kf && u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var s = a._currentValue;
      if (XA !== a) {
        var p = {
          context: a,
          memoizedValue: s,
          next: null
        };
        if (HA === null) {
          if (MA === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          HA = p, MA.dependencies = {
            lanes: Ht,
            firstContext: p
          };
        } else
          HA = HA.next = p;
      }
      return s;
    }
    var Lf = null;
    function Iy(a) {
      Lf === null ? Lf = [a] : Lf.push(a);
    }
    function ax() {
      if (Lf !== null) {
        for (var a = 0; a < Lf.length; a++) {
          var s = Lf[a], p = s.interleaved;
          if (p !== null) {
            s.interleaved = null;
            var y = p.next, Z = s.pending;
            if (Z !== null) {
              var X = Z.next;
              Z.next = y, p.next = X;
            }
            s.pending = p;
          }
        }
        Lf = null;
      }
    }
    function ox(a, s, p, y) {
      var Z = s.interleaved;
      return Z === null ? (p.next = p, Iy(s)) : (p.next = Z.next, Z.next = p), s.interleaved = p, T0(a, y);
    }
    function tN(a, s, p, y) {
      var Z = s.interleaved;
      Z === null ? (p.next = p, Iy(s)) : (p.next = Z.next, Z.next = p), s.interleaved = p;
    }
    function kf(a, s, p, y) {
      var Z = s.interleaved;
      return Z === null ? (p.next = p, Iy(s)) : (p.next = Z.next, Z.next = p), s.interleaved = p, T0(a, y);
    }
    function fc(a, s) {
      return T0(a, s);
    }
    var nN = T0;
    function T0(a, s) {
      a.lanes = Fe(a.lanes, s);
      var p = a.alternate;
      p !== null && (p.lanes = Fe(p.lanes, s)), p === null && (a.flags & (xa | Da)) !== Nn && AE(a);
      for (var y = a, Z = a.return; Z !== null; )
        Z.childLanes = Fe(Z.childLanes, s), p = Z.alternate, p !== null ? p.childLanes = Fe(p.childLanes, s) : (Z.flags & (xa | Da)) !== Nn && AE(a), y = Z, Z = Z.return;
      if (y.tag === b) {
        var X = y.stateNode;
        return X;
      } else
        return null;
    }
    var sx = 0, lx = 1, Cm = 2, wS = 3, _0 = !1, YA, FA;
    YA = !1, FA = null;
    function Th(a) {
      var s = {
        baseState: a.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ht
        },
        effects: null
      };
      a.updateQueue = s;
    }
    function RS(a, s) {
      var p = s.updateQueue, y = a.updateQueue;
      if (p === y) {
        var Z = {
          baseState: y.baseState,
          firstBaseUpdate: y.firstBaseUpdate,
          lastBaseUpdate: y.lastBaseUpdate,
          shared: y.shared,
          effects: y.effects
        };
        s.updateQueue = Z;
      }
    }
    function FC(a, s) {
      var p = {
        eventTime: a,
        lane: s,
        tag: sx,
        payload: null,
        callback: null,
        next: null
      };
      return p;
    }
    function _h(a, s, p) {
      var y = a.updateQueue;
      if (y === null)
        return null;
      var Z = y.shared;
      if (FA === Z && !YA && (u("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), YA = !0), KU()) {
        var X = Z.pending;
        return X === null ? s.next = s : (s.next = X.next, X.next = s), Z.pending = s, nN(a, p);
      } else
        return kf(a, Z, s, p);
    }
    function z0(a, s, p) {
      var y = s.updateQueue;
      if (y !== null) {
        var Z = y.shared;
        if (In(p)) {
          var X = Z.lanes;
          X = Sn(X, a.pendingLanes);
          var K = Fe(X, p);
          Z.lanes = K, Vd(a, K);
        }
      }
    }
    function EA(a, s) {
      var p = a.updateQueue, y = a.alternate;
      if (y !== null) {
        var Z = y.updateQueue;
        if (p === Z) {
          var X = null, K = null, Q = p.firstBaseUpdate;
          if (Q !== null) {
            var te = Q;
            do {
              var ce = {
                eventTime: te.eventTime,
                lane: te.lane,
                tag: te.tag,
                payload: te.payload,
                callback: te.callback,
                next: null
              };
              K === null ? X = K = ce : (K.next = ce, K = ce), te = te.next;
            } while (te !== null);
            K === null ? X = K = s : (K.next = s, K = s);
          } else
            X = K = s;
          p = {
            baseState: Z.baseState,
            firstBaseUpdate: X,
            lastBaseUpdate: K,
            shared: Z.shared,
            effects: Z.effects
          }, a.updateQueue = p;
          return;
        }
      }
      var Ce = p.lastBaseUpdate;
      Ce === null ? p.firstBaseUpdate = s : Ce.next = s, p.lastBaseUpdate = s;
    }
    function iN(a, s, p, y, Z, X) {
      switch (p.tag) {
        case lx: {
          var K = p.payload;
          if (typeof K == "function") {
            dy();
            var Q = K.call(X, y, Z);
            {
              if (a.mode & Xi) {
                tr(!0);
                try {
                  K.call(X, y, Z);
                } finally {
                  tr(!1);
                }
              }
              zu();
            }
            return Q;
          }
          return K;
        }
        case wS:
          a.flags = a.flags & -65537 | er;
        // Intentional fallthrough
        case sx: {
          var te = p.payload, ce;
          if (typeof te == "function") {
            dy(), ce = te.call(X, y, Z);
            {
              if (a.mode & Xi) {
                tr(!0);
                try {
                  te.call(X, y, Z);
                } finally {
                  tr(!1);
                }
              }
              zu();
            }
          } else
            ce = te;
          return ce == null ? y : rn({}, y, ce);
        }
        case Cm:
          return _0 = !0, y;
      }
      return y;
    }
    function TA(a, s, p, y) {
      var Z = a.updateQueue;
      _0 = !1, FA = Z.shared;
      var X = Z.firstBaseUpdate, K = Z.lastBaseUpdate, Q = Z.shared.pending;
      if (Q !== null) {
        Z.shared.pending = null;
        var te = Q, ce = te.next;
        te.next = null, K === null ? X = ce : K.next = ce, K = te;
        var Ce = a.alternate;
        if (Ce !== null) {
          var Qe = Ce.updateQueue, Pe = Qe.lastBaseUpdate;
          Pe !== K && (Pe === null ? Qe.firstBaseUpdate = ce : Pe.next = ce, Qe.lastBaseUpdate = te);
        }
      }
      if (X !== null) {
        var pt = Z.baseState, yt = Ht, Yt = null, On = null, Ri = null, hi = X;
        do {
          var Er = hi.lane, Rr = hi.eventTime;
          if (ot(y, Er)) {
            if (Ri !== null) {
              var Ft = {
                eventTime: Rr,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Fa,
                tag: hi.tag,
                payload: hi.payload,
                callback: hi.callback,
                next: null
              };
              Ri = Ri.next = Ft;
            }
            pt = iN(a, Z, hi, pt, s, p);
            var ct = hi.callback;
            if (ct !== null && // If the update was already committed, we should not queue its
            // callback again.
            hi.lane !== Fa) {
              a.flags |= ta;
              var cn = Z.effects;
              cn === null ? Z.effects = [hi] : cn.push(hi);
            }
          } else {
            var ut = {
              eventTime: Rr,
              lane: Er,
              tag: hi.tag,
              payload: hi.payload,
              callback: hi.callback,
              next: null
            };
            Ri === null ? (On = Ri = ut, Yt = pt) : Ri = Ri.next = ut, yt = Fe(yt, Er);
          }
          if (hi = hi.next, hi === null) {
            if (Q = Z.shared.pending, Q === null)
              break;
            var ni = Q, Qn = ni.next;
            ni.next = null, hi = Qn, Z.lastBaseUpdate = ni, Z.shared.pending = null;
          }
        } while (!0);
        Ri === null && (Yt = pt), Z.baseState = Yt, Z.firstBaseUpdate = On, Z.lastBaseUpdate = Ri;
        var ki = Z.shared.interleaved;
        if (ki !== null) {
          var qi = ki;
          do
            yt = Fe(yt, qi.lane), qi = qi.next;
          while (qi !== ki);
        } else X === null && (Z.shared.lanes = Ht);
        gZ(yt), a.lanes = yt, a.memoizedState = pt;
      }
      FA = null;
    }
    function rN(a, s) {
      if (typeof a != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + a));
      a.call(s);
    }
    function ux() {
      _0 = !1;
    }
    function hm() {
      return _0;
    }
    function cx(a, s, p) {
      var y = s.effects;
      if (s.effects = null, y !== null)
        for (var Z = 0; Z < y.length; Z++) {
          var X = y[Z], K = X.callback;
          K !== null && (X.callback = null, rN(K, p));
        }
    }
    var Cy = {}, Df = Tf(Cy), _A = Tf(Cy), hy = Tf(Cy);
    function EC(a) {
      if (a === Cy)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return a;
    }
    function gx() {
      var a = EC(hy.current);
      return a;
    }
    function kd(a, s) {
      Tu(hy, s, a), Tu(_A, a, a), Tu(Df, Cy, a);
      var p = SR(s);
      Eu(Df, a), Tu(Df, p, a);
    }
    function zA(a) {
      Eu(Df, a), Eu(_A, a), Eu(hy, a);
    }
    function xS() {
      var a = EC(Df.current);
      return a;
    }
    function WS(a) {
      EC(hy.current);
      var s = EC(Df.current), p = qB(s, a.type);
      s !== p && (Tu(_A, a, a), Tu(Df, p, a));
    }
    function VS(a) {
      _A.current === a && (Eu(Df, a), Eu(_A, a));
    }
    var aN = 0, dx = 1, NS = 1, ps = 2, EI = Tf(aN);
    function K0(a, s) {
      return (a & s) !== 0;
    }
    function KA(a) {
      return a & dx;
    }
    function MS(a, s) {
      return a & dx | s;
    }
    function oN(a, s) {
      return a | s;
    }
    function Uf(a, s) {
      Tu(EI, s, a);
    }
    function LA(a) {
      Eu(EI, a);
    }
    function Ix(a, s) {
      var p = a.memoizedState;
      return p !== null ? p.dehydrated !== null : (a.memoizedProps, !0);
    }
    function fm(a) {
      for (var s = a; s !== null; ) {
        if (s.tag === D) {
          var p = s.memoizedState;
          if (p !== null) {
            var y = p.dehydrated;
            if (y === null || FR(y) || I0(y))
              return s;
          }
        } else if (s.tag === he && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        s.memoizedProps.revealOrder !== void 0) {
          var Z = (s.flags & er) !== Nn;
          if (Z)
            return s;
        } else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === a)
          return null;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === a)
            return null;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return null;
    }
    var su = (
      /*   */
      0
    ), Fs = (
      /* */
      1
    ), Dd = (
      /*  */
      2
    ), gl = (
      /*    */
      4
    ), Yl = (
      /*   */
      8
    ), fy = [];
    function HS() {
      for (var a = 0; a < fy.length; a++) {
        var s = fy[a];
        s._workInProgressVersionPrimary = null;
      }
      fy.length = 0;
    }
    function py(a, s) {
      var p = s._getVersion, y = p(s._source);
      a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [s, y] : a.mutableSourceEagerHydrationData.push(s, y);
    }
    var Un = n.ReactCurrentDispatcher, Of = n.ReactCurrentBatchConfig, L0, pm;
    L0 = /* @__PURE__ */ new Set();
    var mm = Ht, Aa = null, va = null, Mo = null, k0 = !1, TC = !1, Am = 0, XS = 0, Cx = 25, Kt = null, Ud = null, Pf = -1, my = !1;
    function aa() {
      {
        var a = Kt;
        Ud === null ? Ud = [a] : Ud.push(a);
      }
    }
    function Rn() {
      {
        var a = Kt;
        Ud !== null && (Pf++, Ud[Pf] !== a && sN(a));
      }
    }
    function kA(a) {
      a != null && !Zi(a) && u("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Kt, typeof a);
    }
    function sN(a) {
      {
        var s = xi(Aa);
        if (!L0.has(s) && (L0.add(s), Ud !== null)) {
          for (var p = "", y = 30, Z = 0; Z <= Pf; Z++) {
            for (var X = Ud[Z], K = Z === Pf ? a : X, Q = Z + 1 + ". " + X; Q.length < y; )
              Q += " ";
            Q += K + `
`, p += Q;
          }
          u(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, s, p);
        }
      }
    }
    function Fl() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function D0(a, s) {
      if (my)
        return !1;
      if (s === null)
        return u("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Kt), !1;
      a.length !== s.length && u(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Kt, "[" + s.join(", ") + "]", "[" + a.join(", ") + "]");
      for (var p = 0; p < s.length && p < a.length; p++)
        if (!zn(a[p], s[p]))
          return !1;
      return !0;
    }
    function DA(a, s, p, y, Z, X) {
      mm = X, Aa = s, Ud = a !== null ? a._debugHookTypes : null, Pf = -1, my = a !== null && a.type !== s.type, s.memoizedState = null, s.updateQueue = null, s.lanes = Ht, a !== null && a.memoizedState !== null ? Un.current = d : Ud !== null ? Un.current = g : Un.current = Sx;
      var K = p(y, Z);
      if (TC) {
        var Q = 0;
        do {
          if (TC = !1, Am = 0, Q >= Cx)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          Q += 1, my = !1, va = null, Mo = null, s.updateQueue = null, Pf = -1, Un.current = G, K = p(y, Z);
        } while (TC);
      }
      Un.current = lG, s._debugHookTypes = Ud;
      var te = va !== null && va.next !== null;
      if (mm = Ht, Aa = null, va = null, Mo = null, Kt = null, Ud = null, Pf = -1, a !== null && (a.flags & na) !== (s.flags & na) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (a.mode & Oi) !== si && u("Internal React error: Expected static flag was missing. Please notify the React team."), k0 = !1, te)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return K;
    }
    function El() {
      var a = Am !== 0;
      return Am = 0, a;
    }
    function U0(a, s, p) {
      s.updateQueue = a.updateQueue, (s.mode & Xr) !== si ? s.flags &= -50333701 : s.flags &= -2053, a.lanes = bt(a.lanes, p);
    }
    function hx() {
      if (Un.current = lG, k0) {
        for (var a = Aa.memoizedState; a !== null; ) {
          var s = a.queue;
          s !== null && (s.pending = null), a = a.next;
        }
        k0 = !1;
      }
      mm = Ht, Aa = null, va = null, Mo = null, Ud = null, Pf = -1, Kt = null, PS = !1, TC = !1, Am = 0;
    }
    function _C() {
      var a = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Mo === null ? Aa.memoizedState = Mo = a : Mo = Mo.next = a, Mo;
    }
    function Tl() {
      var a;
      if (va === null) {
        var s = Aa.alternate;
        s !== null ? a = s.memoizedState : a = null;
      } else
        a = va.next;
      var p;
      if (Mo === null ? p = Aa.memoizedState : p = Mo.next, p !== null)
        Mo = p, p = Mo.next, va = a;
      else {
        if (a === null)
          throw new Error("Rendered more hooks than during the previous render.");
        va = a;
        var y = {
          memoizedState: va.memoizedState,
          baseState: va.baseState,
          baseQueue: va.baseQueue,
          queue: va.queue,
          next: null
        };
        Mo === null ? Aa.memoizedState = Mo = y : Mo = Mo.next = y;
      }
      return Mo;
    }
    function fx() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function YS(a, s) {
      return typeof s == "function" ? s(a) : s;
    }
    function Ay(a, s, p) {
      var y = _C(), Z;
      p !== void 0 ? Z = p(s) : Z = s, y.memoizedState = y.baseState = Z;
      var X = {
        pending: null,
        interleaved: null,
        lanes: Ht,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: Z
      };
      y.queue = X;
      var K = X.dispatch = yx.bind(null, Aa, X);
      return [y.memoizedState, K];
    }
    function vy(a, s, p) {
      var y = Tl(), Z = y.queue;
      if (Z === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Z.lastRenderedReducer = a;
      var X = va, K = X.baseQueue, Q = Z.pending;
      if (Q !== null) {
        if (K !== null) {
          var te = K.next, ce = Q.next;
          K.next = ce, Q.next = te;
        }
        X.baseQueue !== K && u("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), X.baseQueue = K = Q, Z.pending = null;
      }
      if (K !== null) {
        var Ce = K.next, Qe = X.baseState, Pe = null, pt = null, yt = null, Yt = Ce;
        do {
          var On = Yt.lane;
          if (ot(mm, On)) {
            if (yt !== null) {
              var hi = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Fa,
                action: Yt.action,
                hasEagerState: Yt.hasEagerState,
                eagerState: Yt.eagerState,
                next: null
              };
              yt = yt.next = hi;
            }
            if (Yt.hasEagerState)
              Qe = Yt.eagerState;
            else {
              var Er = Yt.action;
              Qe = a(Qe, Er);
            }
          } else {
            var Ri = {
              lane: On,
              action: Yt.action,
              hasEagerState: Yt.hasEagerState,
              eagerState: Yt.eagerState,
              next: null
            };
            yt === null ? (pt = yt = Ri, Pe = Qe) : yt = yt.next = Ri, Aa.lanes = Fe(Aa.lanes, On), gZ(On);
          }
          Yt = Yt.next;
        } while (Yt !== null && Yt !== Ce);
        yt === null ? Pe = Qe : yt.next = pt, zn(Qe, y.memoizedState) || $S(), y.memoizedState = Qe, y.baseState = Pe, y.baseQueue = yt, Z.lastRenderedState = Qe;
      }
      var Rr = Z.interleaved;
      if (Rr !== null) {
        var ut = Rr;
        do {
          var Ft = ut.lane;
          Aa.lanes = Fe(Aa.lanes, Ft), gZ(Ft), ut = ut.next;
        } while (ut !== Rr);
      } else K === null && (Z.lanes = Ht);
      var ct = Z.dispatch;
      return [y.memoizedState, ct];
    }
    function zC(a, s, p) {
      var y = Tl(), Z = y.queue;
      if (Z === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Z.lastRenderedReducer = a;
      var X = Z.dispatch, K = Z.pending, Q = y.memoizedState;
      if (K !== null) {
        Z.pending = null;
        var te = K.next, ce = te;
        do {
          var Ce = ce.action;
          Q = a(Q, Ce), ce = ce.next;
        } while (ce !== te);
        zn(Q, y.memoizedState) || $S(), y.memoizedState = Q, y.baseQueue === null && (y.baseState = Q), Z.lastRenderedState = Q;
      }
      return [Q, X];
    }
    function cF(a, s, p) {
    }
    function gF(a, s, p) {
    }
    function FS(a, s, p) {
      var y = Aa, Z = _C(), X, K = Co();
      if (K) {
        if (p === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        X = p(), pm || X !== p() && (u("The result of getServerSnapshot should be cached to avoid an infinite loop"), pm = !0);
      } else {
        if (X = s(), !pm) {
          var Q = s();
          zn(X, Q) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), pm = !0);
        }
        var te = zx();
        if (te === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Ke(te, mm) || O0(y, s, X);
      }
      Z.memoizedState = X;
      var ce = {
        value: X,
        getSnapshot: s
      };
      return Z.queue = ce, q0(mx.bind(null, y, ce, a), [a]), y.flags |= $s, by(Fs | Yl, px.bind(null, y, ce, X, s), void 0, null), X;
    }
    function yy(a, s, p) {
      var y = Aa, Z = Tl(), X = s();
      if (!pm) {
        var K = s();
        zn(X, K) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), pm = !0);
      }
      var Q = Z.memoizedState, te = !zn(Q, X);
      te && (Z.memoizedState = X, $S());
      var ce = Z.queue;
      if (By(mx.bind(null, y, ce, a), [a]), ce.getSnapshot !== s || te || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Mo !== null && Mo.memoizedState.tag & Fs) {
        y.flags |= $s, by(Fs | Yl, px.bind(null, y, ce, X, s), void 0, null);
        var Ce = zx();
        if (Ce === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Ke(Ce, mm) || O0(y, s, X);
      }
      return X;
    }
    function O0(a, s, p) {
      a.flags |= gh;
      var y = {
        getSnapshot: s,
        value: p
      }, Z = Aa.updateQueue;
      if (Z === null)
        Z = fx(), Aa.updateQueue = Z, Z.stores = [y];
      else {
        var X = Z.stores;
        X === null ? Z.stores = [y] : X.push(y);
      }
    }
    function px(a, s, p, y) {
      s.value = p, s.getSnapshot = y, P0(s) && ES(a);
    }
    function mx(a, s, p) {
      var y = function() {
        P0(s) && ES(a);
      };
      return p(y);
    }
    function P0(a) {
      var s = a.getSnapshot, p = a.value;
      try {
        var y = s();
        return !zn(p, y);
      } catch {
        return !0;
      }
    }
    function ES(a) {
      var s = fc(a, Ai);
      s !== null && gu(s, a, Ai, Nr);
    }
    function J0(a) {
      var s = _C();
      typeof a == "function" && (a = a()), s.memoizedState = s.baseState = a;
      var p = {
        pending: null,
        interleaved: null,
        lanes: Ht,
        dispatch: null,
        lastRenderedReducer: YS,
        lastRenderedState: a
      };
      s.queue = p;
      var y = p.dispatch = bx.bind(null, Aa, p);
      return [s.memoizedState, y];
    }
    function Q0(a) {
      return vy(YS);
    }
    function TS(a) {
      return zC(YS);
    }
    function by(a, s, p, y) {
      var Z = {
        tag: a,
        create: s,
        destroy: p,
        deps: y,
        // Circular
        next: null
      }, X = Aa.updateQueue;
      if (X === null)
        X = fx(), Aa.updateQueue = X, X.lastEffect = Z.next = Z;
      else {
        var K = X.lastEffect;
        if (K === null)
          X.lastEffect = Z.next = Z;
        else {
          var Q = K.next;
          K.next = Z, Z.next = Q, X.lastEffect = Z;
        }
      }
      return Z;
    }
    function Gy(a) {
      var s = _C();
      {
        var p = {
          current: a
        };
        return s.memoizedState = p, p;
      }
    }
    function UA(a) {
      var s = Tl();
      return s.memoizedState;
    }
    function OA(a, s, p, y) {
      var Z = _C(), X = y === void 0 ? null : y;
      Aa.flags |= a, Z.memoizedState = by(Fs | s, p, void 0, X);
    }
    function j0(a, s, p, y) {
      var Z = Tl(), X = y === void 0 ? null : y, K = void 0;
      if (va !== null) {
        var Q = va.memoizedState;
        if (K = Q.destroy, X !== null) {
          var te = Q.deps;
          if (D0(X, te)) {
            Z.memoizedState = by(s, p, K, X);
            return;
          }
        }
      }
      Aa.flags |= a, Z.memoizedState = by(Fs | s, p, K, X);
    }
    function q0(a, s) {
      return (Aa.mode & Xr) !== si ? OA(Wi | $s | xs, Yl, a, s) : OA($s | xs, Yl, a, s);
    }
    function By(a, s) {
      return j0($s, Yl, a, s);
    }
    function _S(a, s) {
      return OA(pi, Dd, a, s);
    }
    function Sy(a, s) {
      return j0(pi, Dd, a, s);
    }
    function zS(a, s) {
      var p = pi;
      return p |= tu, (Aa.mode & Xr) !== si && (p |= Ua), OA(p, gl, a, s);
    }
    function $0(a, s) {
      return j0(pi, gl, a, s);
    }
    function KS(a, s) {
      if (typeof s == "function") {
        var p = s, y = a();
        return p(y), function() {
          p(null);
        };
      } else if (s != null) {
        var Z = s;
        Z.hasOwnProperty("current") || u("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(Z).join(", ") + "}");
        var X = a();
        return Z.current = X, function() {
          Z.current = null;
        };
      }
    }
    function Zy(a, s, p) {
      typeof s != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", s !== null ? typeof s : "null");
      var y = p != null ? p.concat([a]) : null, Z = pi;
      return Z |= tu, (Aa.mode & Xr) !== si && (Z |= Ua), OA(Z, gl, KS.bind(null, s, a), y);
    }
    function eG(a, s, p) {
      typeof s != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", s !== null ? typeof s : "null");
      var y = p != null ? p.concat([a]) : null;
      return j0(pi, gl, KS.bind(null, s, a), y);
    }
    function lN(a, s) {
    }
    var tG = lN;
    function nG(a, s) {
      var p = _C(), y = s === void 0 ? null : s;
      return p.memoizedState = [a, y], a;
    }
    function wy(a, s) {
      var p = Tl(), y = s === void 0 ? null : s, Z = p.memoizedState;
      if (Z !== null && y !== null) {
        var X = Z[1];
        if (D0(y, X))
          return Z[0];
      }
      return p.memoizedState = [a, y], a;
    }
    function iG(a, s) {
      var p = _C(), y = s === void 0 ? null : s, Z = a();
      return p.memoizedState = [Z, y], Z;
    }
    function Ry(a, s) {
      var p = Tl(), y = s === void 0 ? null : s, Z = p.memoizedState;
      if (Z !== null && y !== null) {
        var X = Z[1];
        if (D0(y, X))
          return Z[0];
      }
      var K = a();
      return p.memoizedState = [K, y], K;
    }
    function rG(a) {
      var s = _C();
      return s.memoizedState = a, a;
    }
    function LS(a) {
      var s = Tl(), p = va, y = p.memoizedState;
      return DS(s, y, a);
    }
    function kS(a) {
      var s = Tl();
      if (va === null)
        return s.memoizedState = a, a;
      var p = va.memoizedState;
      return DS(s, p, a);
    }
    function DS(a, s, p) {
      var y = !$(mm);
      if (y) {
        if (!zn(p, s)) {
          var Z = $n();
          Aa.lanes = Fe(Aa.lanes, Z), gZ(Z), a.baseState = !0;
        }
        return s;
      } else
        return a.baseState && (a.baseState = !1, $S()), a.memoizedState = p, p;
    }
    function Ax(a, s, p) {
      var y = Nl();
      zo(Ah(y, Xu)), a(!0);
      var Z = Of.transition;
      Of.transition = {};
      var X = Of.transition;
      Of.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        a(!1), s();
      } finally {
        if (zo(y), Of.transition = Z, Z === null && X._updatedFibers) {
          var K = X._updatedFibers.size;
          K > 10 && l("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), X._updatedFibers.clear();
        }
      }
    }
    function aG() {
      var a = J0(!1), s = a[0], p = a[1], y = Ax.bind(null, p), Z = _C();
      return Z.memoizedState = y, [s, y];
    }
    function US() {
      var a = Q0(), s = a[0], p = Tl(), y = p.memoizedState;
      return [s, y];
    }
    function OS() {
      var a = TS(), s = a[0], p = Tl(), y = p.memoizedState;
      return [s, y];
    }
    var PS = !1;
    function vx() {
      return PS;
    }
    function oG() {
      var a = _C(), s = zx(), p = s.identifierPrefix, y;
      if (Co()) {
        var Z = QV();
        y = ":" + p + "R" + Z;
        var X = Am++;
        X > 0 && (y += "H" + X.toString(32)), y += ":";
      } else {
        var K = XS++;
        y = ":" + p + "r" + K.toString(32) + ":";
      }
      return a.memoizedState = y, y;
    }
    function xy() {
      var a = Tl(), s = a.memoizedState;
      return s;
    }
    function yx(a, s, p) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var y = jA(a), Z = {
        lane: y,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (JS(a))
        sG(s, Z);
      else {
        var X = ox(a, s, Z, y);
        if (X !== null) {
          var K = kg();
          gu(X, a, y, K), Gx(X, s, y);
        }
      }
      Bx(a, y);
    }
    function bx(a, s, p) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var y = jA(a), Z = {
        lane: y,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (JS(a))
        sG(s, Z);
      else {
        var X = a.alternate;
        if (a.lanes === Ht && (X === null || X.lanes === Ht)) {
          var K = s.lastRenderedReducer;
          if (K !== null) {
            var Q;
            Q = Un.current, Un.current = H;
            try {
              var te = s.lastRenderedState, ce = K(te, p);
              if (Z.hasEagerState = !0, Z.eagerState = ce, zn(ce, te)) {
                tN(a, s, Z, y);
                return;
              }
            } catch {
            } finally {
              Un.current = Q;
            }
          }
        }
        var Ce = ox(a, s, Z, y);
        if (Ce !== null) {
          var Qe = kg();
          gu(Ce, a, y, Qe), Gx(Ce, s, y);
        }
      }
      Bx(a, y);
    }
    function JS(a) {
      var s = a.alternate;
      return a === Aa || s !== null && s === Aa;
    }
    function sG(a, s) {
      TC = k0 = !0;
      var p = a.pending;
      p === null ? s.next = s : (s.next = p.next, p.next = s), a.pending = s;
    }
    function Gx(a, s, p) {
      if (In(p)) {
        var y = s.lanes;
        y = Sn(y, a.pendingLanes);
        var Z = Fe(y, p);
        s.lanes = Z, Vd(a, Z);
      }
    }
    function Bx(a, s, p) {
      Mu(a, s);
    }
    var lG = {
      readContext: Or,
      useCallback: Fl,
      useContext: Fl,
      useEffect: Fl,
      useImperativeHandle: Fl,
      useInsertionEffect: Fl,
      useLayoutEffect: Fl,
      useMemo: Fl,
      useReducer: Fl,
      useRef: Fl,
      useState: Fl,
      useDebugValue: Fl,
      useDeferredValue: Fl,
      useTransition: Fl,
      useMutableSource: Fl,
      useSyncExternalStore: Fl,
      useId: Fl,
      unstable_isNewReconciler: Se
    }, Sx = null, g = null, d = null, G = null, w = null, H = null, z = null;
    {
      var q = function() {
        u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, ee = function() {
        u("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Sx = {
        readContext: function(a) {
          return Or(a);
        },
        useCallback: function(a, s) {
          return Kt = "useCallback", aa(), kA(s), nG(a, s);
        },
        useContext: function(a) {
          return Kt = "useContext", aa(), Or(a);
        },
        useEffect: function(a, s) {
          return Kt = "useEffect", aa(), kA(s), q0(a, s);
        },
        useImperativeHandle: function(a, s, p) {
          return Kt = "useImperativeHandle", aa(), kA(p), Zy(a, s, p);
        },
        useInsertionEffect: function(a, s) {
          return Kt = "useInsertionEffect", aa(), kA(s), _S(a, s);
        },
        useLayoutEffect: function(a, s) {
          return Kt = "useLayoutEffect", aa(), kA(s), zS(a, s);
        },
        useMemo: function(a, s) {
          Kt = "useMemo", aa(), kA(s);
          var p = Un.current;
          Un.current = w;
          try {
            return iG(a, s);
          } finally {
            Un.current = p;
          }
        },
        useReducer: function(a, s, p) {
          Kt = "useReducer", aa();
          var y = Un.current;
          Un.current = w;
          try {
            return Ay(a, s, p);
          } finally {
            Un.current = y;
          }
        },
        useRef: function(a) {
          return Kt = "useRef", aa(), Gy(a);
        },
        useState: function(a) {
          Kt = "useState", aa();
          var s = Un.current;
          Un.current = w;
          try {
            return J0(a);
          } finally {
            Un.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return Kt = "useDebugValue", aa(), void 0;
        },
        useDeferredValue: function(a) {
          return Kt = "useDeferredValue", aa(), rG(a);
        },
        useTransition: function() {
          return Kt = "useTransition", aa(), aG();
        },
        useMutableSource: function(a, s, p) {
          return Kt = "useMutableSource", aa(), void 0;
        },
        useSyncExternalStore: function(a, s, p) {
          return Kt = "useSyncExternalStore", aa(), FS(a, s, p);
        },
        useId: function() {
          return Kt = "useId", aa(), oG();
        },
        unstable_isNewReconciler: Se
      }, g = {
        readContext: function(a) {
          return Or(a);
        },
        useCallback: function(a, s) {
          return Kt = "useCallback", Rn(), nG(a, s);
        },
        useContext: function(a) {
          return Kt = "useContext", Rn(), Or(a);
        },
        useEffect: function(a, s) {
          return Kt = "useEffect", Rn(), q0(a, s);
        },
        useImperativeHandle: function(a, s, p) {
          return Kt = "useImperativeHandle", Rn(), Zy(a, s, p);
        },
        useInsertionEffect: function(a, s) {
          return Kt = "useInsertionEffect", Rn(), _S(a, s);
        },
        useLayoutEffect: function(a, s) {
          return Kt = "useLayoutEffect", Rn(), zS(a, s);
        },
        useMemo: function(a, s) {
          Kt = "useMemo", Rn();
          var p = Un.current;
          Un.current = w;
          try {
            return iG(a, s);
          } finally {
            Un.current = p;
          }
        },
        useReducer: function(a, s, p) {
          Kt = "useReducer", Rn();
          var y = Un.current;
          Un.current = w;
          try {
            return Ay(a, s, p);
          } finally {
            Un.current = y;
          }
        },
        useRef: function(a) {
          return Kt = "useRef", Rn(), Gy(a);
        },
        useState: function(a) {
          Kt = "useState", Rn();
          var s = Un.current;
          Un.current = w;
          try {
            return J0(a);
          } finally {
            Un.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return Kt = "useDebugValue", Rn(), void 0;
        },
        useDeferredValue: function(a) {
          return Kt = "useDeferredValue", Rn(), rG(a);
        },
        useTransition: function() {
          return Kt = "useTransition", Rn(), aG();
        },
        useMutableSource: function(a, s, p) {
          return Kt = "useMutableSource", Rn(), void 0;
        },
        useSyncExternalStore: function(a, s, p) {
          return Kt = "useSyncExternalStore", Rn(), FS(a, s, p);
        },
        useId: function() {
          return Kt = "useId", Rn(), oG();
        },
        unstable_isNewReconciler: Se
      }, d = {
        readContext: function(a) {
          return Or(a);
        },
        useCallback: function(a, s) {
          return Kt = "useCallback", Rn(), wy(a, s);
        },
        useContext: function(a) {
          return Kt = "useContext", Rn(), Or(a);
        },
        useEffect: function(a, s) {
          return Kt = "useEffect", Rn(), By(a, s);
        },
        useImperativeHandle: function(a, s, p) {
          return Kt = "useImperativeHandle", Rn(), eG(a, s, p);
        },
        useInsertionEffect: function(a, s) {
          return Kt = "useInsertionEffect", Rn(), Sy(a, s);
        },
        useLayoutEffect: function(a, s) {
          return Kt = "useLayoutEffect", Rn(), $0(a, s);
        },
        useMemo: function(a, s) {
          Kt = "useMemo", Rn();
          var p = Un.current;
          Un.current = H;
          try {
            return Ry(a, s);
          } finally {
            Un.current = p;
          }
        },
        useReducer: function(a, s, p) {
          Kt = "useReducer", Rn();
          var y = Un.current;
          Un.current = H;
          try {
            return vy(a, s, p);
          } finally {
            Un.current = y;
          }
        },
        useRef: function(a) {
          return Kt = "useRef", Rn(), UA();
        },
        useState: function(a) {
          Kt = "useState", Rn();
          var s = Un.current;
          Un.current = H;
          try {
            return Q0(a);
          } finally {
            Un.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return Kt = "useDebugValue", Rn(), tG();
        },
        useDeferredValue: function(a) {
          return Kt = "useDeferredValue", Rn(), LS(a);
        },
        useTransition: function() {
          return Kt = "useTransition", Rn(), US();
        },
        useMutableSource: function(a, s, p) {
          return Kt = "useMutableSource", Rn(), void 0;
        },
        useSyncExternalStore: function(a, s, p) {
          return Kt = "useSyncExternalStore", Rn(), yy(a, s);
        },
        useId: function() {
          return Kt = "useId", Rn(), xy();
        },
        unstable_isNewReconciler: Se
      }, G = {
        readContext: function(a) {
          return Or(a);
        },
        useCallback: function(a, s) {
          return Kt = "useCallback", Rn(), wy(a, s);
        },
        useContext: function(a) {
          return Kt = "useContext", Rn(), Or(a);
        },
        useEffect: function(a, s) {
          return Kt = "useEffect", Rn(), By(a, s);
        },
        useImperativeHandle: function(a, s, p) {
          return Kt = "useImperativeHandle", Rn(), eG(a, s, p);
        },
        useInsertionEffect: function(a, s) {
          return Kt = "useInsertionEffect", Rn(), Sy(a, s);
        },
        useLayoutEffect: function(a, s) {
          return Kt = "useLayoutEffect", Rn(), $0(a, s);
        },
        useMemo: function(a, s) {
          Kt = "useMemo", Rn();
          var p = Un.current;
          Un.current = z;
          try {
            return Ry(a, s);
          } finally {
            Un.current = p;
          }
        },
        useReducer: function(a, s, p) {
          Kt = "useReducer", Rn();
          var y = Un.current;
          Un.current = z;
          try {
            return zC(a, s, p);
          } finally {
            Un.current = y;
          }
        },
        useRef: function(a) {
          return Kt = "useRef", Rn(), UA();
        },
        useState: function(a) {
          Kt = "useState", Rn();
          var s = Un.current;
          Un.current = z;
          try {
            return TS(a);
          } finally {
            Un.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return Kt = "useDebugValue", Rn(), tG();
        },
        useDeferredValue: function(a) {
          return Kt = "useDeferredValue", Rn(), kS(a);
        },
        useTransition: function() {
          return Kt = "useTransition", Rn(), OS();
        },
        useMutableSource: function(a, s, p) {
          return Kt = "useMutableSource", Rn(), void 0;
        },
        useSyncExternalStore: function(a, s, p) {
          return Kt = "useSyncExternalStore", Rn(), yy(a, s);
        },
        useId: function() {
          return Kt = "useId", Rn(), xy();
        },
        unstable_isNewReconciler: Se
      }, w = {
        readContext: function(a) {
          return q(), Or(a);
        },
        useCallback: function(a, s) {
          return Kt = "useCallback", ee(), aa(), nG(a, s);
        },
        useContext: function(a) {
          return Kt = "useContext", ee(), aa(), Or(a);
        },
        useEffect: function(a, s) {
          return Kt = "useEffect", ee(), aa(), q0(a, s);
        },
        useImperativeHandle: function(a, s, p) {
          return Kt = "useImperativeHandle", ee(), aa(), Zy(a, s, p);
        },
        useInsertionEffect: function(a, s) {
          return Kt = "useInsertionEffect", ee(), aa(), _S(a, s);
        },
        useLayoutEffect: function(a, s) {
          return Kt = "useLayoutEffect", ee(), aa(), zS(a, s);
        },
        useMemo: function(a, s) {
          Kt = "useMemo", ee(), aa();
          var p = Un.current;
          Un.current = w;
          try {
            return iG(a, s);
          } finally {
            Un.current = p;
          }
        },
        useReducer: function(a, s, p) {
          Kt = "useReducer", ee(), aa();
          var y = Un.current;
          Un.current = w;
          try {
            return Ay(a, s, p);
          } finally {
            Un.current = y;
          }
        },
        useRef: function(a) {
          return Kt = "useRef", ee(), aa(), Gy(a);
        },
        useState: function(a) {
          Kt = "useState", ee(), aa();
          var s = Un.current;
          Un.current = w;
          try {
            return J0(a);
          } finally {
            Un.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return Kt = "useDebugValue", ee(), aa(), void 0;
        },
        useDeferredValue: function(a) {
          return Kt = "useDeferredValue", ee(), aa(), rG(a);
        },
        useTransition: function() {
          return Kt = "useTransition", ee(), aa(), aG();
        },
        useMutableSource: function(a, s, p) {
          return Kt = "useMutableSource", ee(), aa(), void 0;
        },
        useSyncExternalStore: function(a, s, p) {
          return Kt = "useSyncExternalStore", ee(), aa(), FS(a, s, p);
        },
        useId: function() {
          return Kt = "useId", ee(), aa(), oG();
        },
        unstable_isNewReconciler: Se
      }, H = {
        readContext: function(a) {
          return q(), Or(a);
        },
        useCallback: function(a, s) {
          return Kt = "useCallback", ee(), Rn(), wy(a, s);
        },
        useContext: function(a) {
          return Kt = "useContext", ee(), Rn(), Or(a);
        },
        useEffect: function(a, s) {
          return Kt = "useEffect", ee(), Rn(), By(a, s);
        },
        useImperativeHandle: function(a, s, p) {
          return Kt = "useImperativeHandle", ee(), Rn(), eG(a, s, p);
        },
        useInsertionEffect: function(a, s) {
          return Kt = "useInsertionEffect", ee(), Rn(), Sy(a, s);
        },
        useLayoutEffect: function(a, s) {
          return Kt = "useLayoutEffect", ee(), Rn(), $0(a, s);
        },
        useMemo: function(a, s) {
          Kt = "useMemo", ee(), Rn();
          var p = Un.current;
          Un.current = H;
          try {
            return Ry(a, s);
          } finally {
            Un.current = p;
          }
        },
        useReducer: function(a, s, p) {
          Kt = "useReducer", ee(), Rn();
          var y = Un.current;
          Un.current = H;
          try {
            return vy(a, s, p);
          } finally {
            Un.current = y;
          }
        },
        useRef: function(a) {
          return Kt = "useRef", ee(), Rn(), UA();
        },
        useState: function(a) {
          Kt = "useState", ee(), Rn();
          var s = Un.current;
          Un.current = H;
          try {
            return Q0(a);
          } finally {
            Un.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return Kt = "useDebugValue", ee(), Rn(), tG();
        },
        useDeferredValue: function(a) {
          return Kt = "useDeferredValue", ee(), Rn(), LS(a);
        },
        useTransition: function() {
          return Kt = "useTransition", ee(), Rn(), US();
        },
        useMutableSource: function(a, s, p) {
          return Kt = "useMutableSource", ee(), Rn(), void 0;
        },
        useSyncExternalStore: function(a, s, p) {
          return Kt = "useSyncExternalStore", ee(), Rn(), yy(a, s);
        },
        useId: function() {
          return Kt = "useId", ee(), Rn(), xy();
        },
        unstable_isNewReconciler: Se
      }, z = {
        readContext: function(a) {
          return q(), Or(a);
        },
        useCallback: function(a, s) {
          return Kt = "useCallback", ee(), Rn(), wy(a, s);
        },
        useContext: function(a) {
          return Kt = "useContext", ee(), Rn(), Or(a);
        },
        useEffect: function(a, s) {
          return Kt = "useEffect", ee(), Rn(), By(a, s);
        },
        useImperativeHandle: function(a, s, p) {
          return Kt = "useImperativeHandle", ee(), Rn(), eG(a, s, p);
        },
        useInsertionEffect: function(a, s) {
          return Kt = "useInsertionEffect", ee(), Rn(), Sy(a, s);
        },
        useLayoutEffect: function(a, s) {
          return Kt = "useLayoutEffect", ee(), Rn(), $0(a, s);
        },
        useMemo: function(a, s) {
          Kt = "useMemo", ee(), Rn();
          var p = Un.current;
          Un.current = H;
          try {
            return Ry(a, s);
          } finally {
            Un.current = p;
          }
        },
        useReducer: function(a, s, p) {
          Kt = "useReducer", ee(), Rn();
          var y = Un.current;
          Un.current = H;
          try {
            return zC(a, s, p);
          } finally {
            Un.current = y;
          }
        },
        useRef: function(a) {
          return Kt = "useRef", ee(), Rn(), UA();
        },
        useState: function(a) {
          Kt = "useState", ee(), Rn();
          var s = Un.current;
          Un.current = H;
          try {
            return TS(a);
          } finally {
            Un.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return Kt = "useDebugValue", ee(), Rn(), tG();
        },
        useDeferredValue: function(a) {
          return Kt = "useDeferredValue", ee(), Rn(), kS(a);
        },
        useTransition: function() {
          return Kt = "useTransition", ee(), Rn(), OS();
        },
        useMutableSource: function(a, s, p) {
          return Kt = "useMutableSource", ee(), Rn(), void 0;
        },
        useSyncExternalStore: function(a, s, p) {
          return Kt = "useSyncExternalStore", ee(), Rn(), yy(a, s);
        },
        useId: function() {
          return Kt = "useId", ee(), Rn(), xy();
        },
        unstable_isNewReconciler: Se
      };
    }
    var ue = t.unstable_now, Ze = 0, _e = -1, st = -1, Zt = -1, Xt = !1, nn = !1;
    function Cn() {
      return Xt;
    }
    function yi() {
      nn = !0;
    }
    function rr() {
      Xt = !1, nn = !1;
    }
    function Ni() {
      Xt = nn, nn = !1;
    }
    function Ja() {
      return Ze;
    }
    function Qa() {
      Ze = ue();
    }
    function Ct(a) {
      st = ue(), a.actualStartTime < 0 && (a.actualStartTime = ue());
    }
    function zt(a) {
      st = -1;
    }
    function dt(a, s) {
      if (st >= 0) {
        var p = ue() - st;
        a.actualDuration += p, s && (a.selfBaseDuration = p), st = -1;
      }
    }
    function ln(a) {
      if (_e >= 0) {
        var s = ue() - _e;
        _e = -1;
        for (var p = a.return; p !== null; ) {
          switch (p.tag) {
            case b:
              var y = p.stateNode;
              y.effectDuration += s;
              return;
            case P:
              var Z = p.stateNode;
              Z.effectDuration += s;
              return;
          }
          p = p.return;
        }
      }
    }
    function gi(a) {
      if (Zt >= 0) {
        var s = ue() - Zt;
        Zt = -1;
        for (var p = a.return; p !== null; ) {
          switch (p.tag) {
            case b:
              var y = p.stateNode;
              y !== null && (y.passiveEffectDuration += s);
              return;
            case P:
              var Z = p.stateNode;
              Z !== null && (Z.passiveEffectDuration += s);
              return;
          }
          p = p.return;
        }
      }
    }
    function Mn() {
      _e = ue();
    }
    function mr() {
      Zt = ue();
    }
    function Pr(a) {
      for (var s = a.child; s; )
        a.actualDuration += s.actualDuration, s = s.sibling;
    }
    function wr(a, s) {
      if (a && a.defaultProps) {
        var p = rn({}, s), y = a.defaultProps;
        for (var Z in y)
          p[Z] === void 0 && (p[Z] = y[Z]);
        return p;
      }
      return s;
    }
    var Jr = {}, ho, Yr, gr, Uo, fo, zg, Es, pc, mc, Od, KC;
    {
      ho = /* @__PURE__ */ new Set(), Yr = /* @__PURE__ */ new Set(), gr = /* @__PURE__ */ new Set(), Uo = /* @__PURE__ */ new Set(), pc = /* @__PURE__ */ new Set(), fo = /* @__PURE__ */ new Set(), mc = /* @__PURE__ */ new Set(), Od = /* @__PURE__ */ new Set(), KC = /* @__PURE__ */ new Set();
      var vm = /* @__PURE__ */ new Set();
      Es = function(a, s) {
        if (!(a === null || typeof a == "function")) {
          var p = s + "_" + a;
          vm.has(p) || (vm.add(p), u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s, a));
        }
      }, zg = function(a, s) {
        if (s === void 0) {
          var p = Hi(a) || "Component";
          fo.has(p) || (fo.add(p), u("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", p));
        }
      }, Object.defineProperty(Jr, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Jr);
    }
    function Ac(a, s, p, y) {
      var Z = a.memoizedState, X = p(y, Z);
      {
        if (a.mode & Xi) {
          tr(!0);
          try {
            X = p(y, Z);
          } finally {
            tr(!1);
          }
        }
        zg(s, X);
      }
      var K = X == null ? Z : rn({}, Z, X);
      if (a.memoizedState = K, a.lanes === Ht) {
        var Q = a.updateQueue;
        Q.baseState = K;
      }
    }
    var zh = {
      isMounted: Bp,
      enqueueSetState: function(a, s, p) {
        var y = Bo(a), Z = kg(), X = jA(y), K = FC(Z, X);
        K.payload = s, p != null && (Es(p, "setState"), K.callback = p);
        var Q = _h(y, K, X);
        Q !== null && (gu(Q, y, X, Z), z0(Q, y, X)), Mu(y, X);
      },
      enqueueReplaceState: function(a, s, p) {
        var y = Bo(a), Z = kg(), X = jA(y), K = FC(Z, X);
        K.tag = lx, K.payload = s, p != null && (Es(p, "replaceState"), K.callback = p);
        var Q = _h(y, K, X);
        Q !== null && (gu(Q, y, X, Z), z0(Q, y, X)), Mu(y, X);
      },
      enqueueForceUpdate: function(a, s) {
        var p = Bo(a), y = kg(), Z = jA(p), X = FC(y, Z);
        X.tag = Cm, s != null && (Es(s, "forceUpdate"), X.callback = s);
        var K = _h(p, X, Z);
        K !== null && (gu(K, p, Z, y), z0(K, p, Z)), gC(p, Z);
      }
    };
    function uG(a, s, p, y, Z, X, K) {
      var Q = a.stateNode;
      if (typeof Q.shouldComponentUpdate == "function") {
        var te = Q.shouldComponentUpdate(y, X, K);
        {
          if (a.mode & Xi) {
            tr(!0);
            try {
              te = Q.shouldComponentUpdate(y, X, K);
            } finally {
              tr(!1);
            }
          }
          te === void 0 && u("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Hi(s) || "Component");
        }
        return te;
      }
      return s.prototype && s.prototype.isPureReactComponent ? !Ci(p, y) || !Ci(Z, X) : !0;
    }
    function Zx(a, s, p) {
      var y = a.stateNode;
      {
        var Z = Hi(s) || "Component", X = y.render;
        X || (s.prototype && typeof s.prototype.render == "function" ? u("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", Z) : u("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", Z)), y.getInitialState && !y.getInitialState.isReactClassApproved && !y.state && u("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", Z), y.getDefaultProps && !y.getDefaultProps.isReactClassApproved && u("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", Z), y.propTypes && u("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", Z), y.contextType && u("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", Z), s.childContextTypes && !KC.has(s) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (a.mode & Xi) === si && (KC.add(s), u(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, Z)), s.contextTypes && !KC.has(s) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (a.mode & Xi) === si && (KC.add(s), u(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, Z)), y.contextTypes && u("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", Z), s.contextType && s.contextTypes && !mc.has(s) && (mc.add(s), u("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", Z)), typeof y.componentShouldUpdate == "function" && u("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", Z), s.prototype && s.prototype.isPureReactComponent && typeof y.shouldComponentUpdate < "u" && u("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Hi(s) || "A pure component"), typeof y.componentDidUnmount == "function" && u("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", Z), typeof y.componentDidReceiveProps == "function" && u("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", Z), typeof y.componentWillRecieveProps == "function" && u("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", Z), typeof y.UNSAFE_componentWillRecieveProps == "function" && u("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", Z);
        var K = y.props !== p;
        y.props !== void 0 && K && u("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", Z, Z), y.defaultProps && u("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", Z, Z), typeof y.getSnapshotBeforeUpdate == "function" && typeof y.componentDidUpdate != "function" && !gr.has(s) && (gr.add(s), u("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Hi(s))), typeof y.getDerivedStateFromProps == "function" && u("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Z), typeof y.getDerivedStateFromError == "function" && u("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Z), typeof s.getSnapshotBeforeUpdate == "function" && u("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", Z);
        var Q = y.state;
        Q && (typeof Q != "object" || Zi(Q)) && u("%s.state: must be set to an object or null", Z), typeof y.getChildContext == "function" && typeof s.childContextTypes != "object" && u("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", Z);
      }
    }
    function wx(a, s) {
      s.updater = zh, a.stateNode = s, yr(s, a), s._reactInternalInstance = Jr;
    }
    function Rx(a, s, p) {
      var y = !1, Z = Jc, X = Jc, K = s.contextType;
      if ("contextType" in s) {
        var Q = (
          // Allow null for conditional declaration
          K === null || K !== void 0 && K.$$typeof === Ie && K._context === void 0
        );
        if (!Q && !Od.has(s)) {
          Od.add(s);
          var te = "";
          K === void 0 ? te = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof K != "object" ? te = " However, it is set to a " + typeof K + "." : K.$$typeof === Ln ? te = " Did you accidentally pass the Context.Provider instead?" : K._context !== void 0 ? te = " Did you accidentally pass the Context.Consumer instead?" : te = " However, it is set to an object with keys {" + Object.keys(K).join(", ") + "}.", u("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Hi(s) || "Component", te);
        }
      }
      if (typeof K == "object" && K !== null)
        X = Or(K);
      else {
        Z = jp(a, s, !0);
        var ce = s.contextTypes;
        y = ce != null, X = y ? _f(a, Z) : Jc;
      }
      var Ce = new s(p, X);
      if (a.mode & Xi) {
        tr(!0);
        try {
          Ce = new s(p, X);
        } finally {
          tr(!1);
        }
      }
      var Qe = a.memoizedState = Ce.state !== null && Ce.state !== void 0 ? Ce.state : null;
      wx(a, Ce);
      {
        if (typeof s.getDerivedStateFromProps == "function" && Qe === null) {
          var Pe = Hi(s) || "Component";
          Yr.has(Pe) || (Yr.add(Pe), u("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Pe, Ce.state === null ? "null" : "undefined", Pe));
        }
        if (typeof s.getDerivedStateFromProps == "function" || typeof Ce.getSnapshotBeforeUpdate == "function") {
          var pt = null, yt = null, Yt = null;
          if (typeof Ce.componentWillMount == "function" && Ce.componentWillMount.__suppressDeprecationWarning !== !0 ? pt = "componentWillMount" : typeof Ce.UNSAFE_componentWillMount == "function" && (pt = "UNSAFE_componentWillMount"), typeof Ce.componentWillReceiveProps == "function" && Ce.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? yt = "componentWillReceiveProps" : typeof Ce.UNSAFE_componentWillReceiveProps == "function" && (yt = "UNSAFE_componentWillReceiveProps"), typeof Ce.componentWillUpdate == "function" && Ce.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Yt = "componentWillUpdate" : typeof Ce.UNSAFE_componentWillUpdate == "function" && (Yt = "UNSAFE_componentWillUpdate"), pt !== null || yt !== null || Yt !== null) {
            var On = Hi(s) || "Component", Ri = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Uo.has(On) || (Uo.add(On), u(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, On, Ri, pt !== null ? `
  ` + pt : "", yt !== null ? `
  ` + yt : "", Yt !== null ? `
  ` + Yt : ""));
          }
        }
      }
      return y && PR(a, Z, X), Ce;
    }
    function uD(a, s) {
      var p = s.state;
      typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), p !== s.state && (u("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", xi(a) || "Component"), zh.enqueueReplaceState(s, s.state, null));
    }
    function dF(a, s, p, y) {
      var Z = s.state;
      if (typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(p, y), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(p, y), s.state !== Z) {
        {
          var X = xi(a) || "Component";
          ho.has(X) || (ho.add(X), u("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", X));
        }
        zh.enqueueReplaceState(s, s.state, null);
      }
    }
    function uN(a, s, p, y) {
      Zx(a, s, p);
      var Z = a.stateNode;
      Z.props = p, Z.state = a.memoizedState, Z.refs = {}, Th(a);
      var X = s.contextType;
      if (typeof X == "object" && X !== null)
        Z.context = Or(X);
      else {
        var K = jp(a, s, !0);
        Z.context = _f(a, K);
      }
      {
        if (Z.state === p) {
          var Q = Hi(s) || "Component";
          pc.has(Q) || (pc.add(Q), u("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Q));
        }
        a.mode & Xi && Kd.recordLegacyContextWarning(a, Z), Kd.recordUnsafeLifecycleWarnings(a, Z);
      }
      Z.state = a.memoizedState;
      var te = s.getDerivedStateFromProps;
      if (typeof te == "function" && (Ac(a, s, te, p), Z.state = a.memoizedState), typeof s.getDerivedStateFromProps != "function" && typeof Z.getSnapshotBeforeUpdate != "function" && (typeof Z.UNSAFE_componentWillMount == "function" || typeof Z.componentWillMount == "function") && (uD(a, Z), TA(a, p, Z, y), Z.state = a.memoizedState), typeof Z.componentDidMount == "function") {
        var ce = pi;
        ce |= tu, (a.mode & Xr) !== si && (ce |= Ua), a.flags |= ce;
      }
    }
    function cD(a, s, p, y) {
      var Z = a.stateNode, X = a.memoizedProps;
      Z.props = X;
      var K = Z.context, Q = s.contextType, te = Jc;
      if (typeof Q == "object" && Q !== null)
        te = Or(Q);
      else {
        var ce = jp(a, s, !0);
        te = _f(a, ce);
      }
      var Ce = s.getDerivedStateFromProps, Qe = typeof Ce == "function" || typeof Z.getSnapshotBeforeUpdate == "function";
      !Qe && (typeof Z.UNSAFE_componentWillReceiveProps == "function" || typeof Z.componentWillReceiveProps == "function") && (X !== p || K !== te) && dF(a, Z, p, te), ux();
      var Pe = a.memoizedState, pt = Z.state = Pe;
      if (TA(a, p, Z, y), pt = a.memoizedState, X === p && Pe === pt && !ay() && !hm()) {
        if (typeof Z.componentDidMount == "function") {
          var yt = pi;
          yt |= tu, (a.mode & Xr) !== si && (yt |= Ua), a.flags |= yt;
        }
        return !1;
      }
      typeof Ce == "function" && (Ac(a, s, Ce, p), pt = a.memoizedState);
      var Yt = hm() || uG(a, s, X, p, Pe, pt, te);
      if (Yt) {
        if (!Qe && (typeof Z.UNSAFE_componentWillMount == "function" || typeof Z.componentWillMount == "function") && (typeof Z.componentWillMount == "function" && Z.componentWillMount(), typeof Z.UNSAFE_componentWillMount == "function" && Z.UNSAFE_componentWillMount()), typeof Z.componentDidMount == "function") {
          var On = pi;
          On |= tu, (a.mode & Xr) !== si && (On |= Ua), a.flags |= On;
        }
      } else {
        if (typeof Z.componentDidMount == "function") {
          var Ri = pi;
          Ri |= tu, (a.mode & Xr) !== si && (Ri |= Ua), a.flags |= Ri;
        }
        a.memoizedProps = p, a.memoizedState = pt;
      }
      return Z.props = p, Z.state = pt, Z.context = te, Yt;
    }
    function gD(a, s, p, y, Z) {
      var X = s.stateNode;
      RS(a, s);
      var K = s.memoizedProps, Q = s.type === s.elementType ? K : wr(s.type, K);
      X.props = Q;
      var te = s.pendingProps, ce = X.context, Ce = p.contextType, Qe = Jc;
      if (typeof Ce == "object" && Ce !== null)
        Qe = Or(Ce);
      else {
        var Pe = jp(s, p, !0);
        Qe = _f(s, Pe);
      }
      var pt = p.getDerivedStateFromProps, yt = typeof pt == "function" || typeof X.getSnapshotBeforeUpdate == "function";
      !yt && (typeof X.UNSAFE_componentWillReceiveProps == "function" || typeof X.componentWillReceiveProps == "function") && (K !== te || ce !== Qe) && dF(s, X, y, Qe), ux();
      var Yt = s.memoizedState, On = X.state = Yt;
      if (TA(s, y, X, Z), On = s.memoizedState, K === te && Yt === On && !ay() && !hm())
        return typeof X.componentDidUpdate == "function" && (K !== a.memoizedProps || Yt !== a.memoizedState) && (s.flags |= pi), typeof X.getSnapshotBeforeUpdate == "function" && (K !== a.memoizedProps || Yt !== a.memoizedState) && (s.flags |= Rs), !1;
      typeof pt == "function" && (Ac(s, p, pt, y), On = s.memoizedState);
      var Ri = hm() || uG(s, p, Q, y, Yt, On, Qe) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Be;
      return Ri ? (!yt && (typeof X.UNSAFE_componentWillUpdate == "function" || typeof X.componentWillUpdate == "function") && (typeof X.componentWillUpdate == "function" && X.componentWillUpdate(y, On, Qe), typeof X.UNSAFE_componentWillUpdate == "function" && X.UNSAFE_componentWillUpdate(y, On, Qe)), typeof X.componentDidUpdate == "function" && (s.flags |= pi), typeof X.getSnapshotBeforeUpdate == "function" && (s.flags |= Rs)) : (typeof X.componentDidUpdate == "function" && (K !== a.memoizedProps || Yt !== a.memoizedState) && (s.flags |= pi), typeof X.getSnapshotBeforeUpdate == "function" && (K !== a.memoizedProps || Yt !== a.memoizedState) && (s.flags |= Rs), s.memoizedProps = y, s.memoizedState = On), X.props = y, X.state = On, X.context = Qe, Ri;
    }
    function Wy(a, s) {
      return {
        value: a,
        source: s,
        stack: sr(s),
        digest: null
      };
    }
    function cN(a, s, p) {
      return {
        value: a,
        source: null,
        stack: p ?? null,
        digest: s ?? null
      };
    }
    function dD(a, s) {
      return !0;
    }
    function gN(a, s) {
      try {
        var p = dD(a, s);
        if (p === !1)
          return;
        var y = s.value, Z = s.source, X = s.stack, K = X !== null ? X : "";
        if (y != null && y._suppressLogging) {
          if (a.tag === f)
            return;
          console.error(y);
        }
        var Q = Z ? xi(Z) : null, te = Q ? "The above error occurred in the <" + Q + "> component:" : "The above error occurred in one of your React components:", ce;
        if (a.tag === b)
          ce = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Ce = xi(a) || "Anonymous";
          ce = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Ce + ".");
        }
        var Qe = te + `
` + K + `

` + ("" + ce);
        console.error(Qe);
      } catch (Pe) {
        setTimeout(function() {
          throw Pe;
        });
      }
    }
    var ID = typeof WeakMap == "function" ? WeakMap : Map;
    function IF(a, s, p) {
      var y = FC(Nr, p);
      y.tag = wS, y.payload = {
        element: null
      };
      var Z = s.value;
      return y.callback = function() {
        aO(Z), gN(a, s);
      }, y;
    }
    function dN(a, s, p) {
      var y = FC(Nr, p);
      y.tag = wS;
      var Z = a.type.getDerivedStateFromError;
      if (typeof Z == "function") {
        var X = s.value;
        y.payload = function() {
          return Z(X);
        }, y.callback = function() {
          BE(a), gN(a, s);
        };
      }
      var K = a.stateNode;
      return K !== null && typeof K.componentDidCatch == "function" && (y.callback = function() {
        BE(a), gN(a, s), typeof Z != "function" && iO(this);
        var te = s.value, ce = s.stack;
        this.componentDidCatch(te, {
          componentStack: ce !== null ? ce : ""
        }), typeof Z != "function" && (ga(a.lanes, Ai) || u("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", xi(a) || "Unknown"));
      }), y;
    }
    function CF(a, s, p) {
      var y = a.pingCache, Z;
      if (y === null ? (y = a.pingCache = new ID(), Z = /* @__PURE__ */ new Set(), y.set(s, Z)) : (Z = y.get(s), Z === void 0 && (Z = /* @__PURE__ */ new Set(), y.set(s, Z))), !Z.has(p)) {
        Z.add(p);
        var X = oO.bind(null, a, s, p);
        _o && dZ(a, p), s.then(X, X);
      }
    }
    function CD(a, s, p, y) {
      var Z = a.updateQueue;
      if (Z === null) {
        var X = /* @__PURE__ */ new Set();
        X.add(p), a.updateQueue = X;
      } else
        Z.add(p);
    }
    function hD(a, s) {
      var p = a.tag;
      if ((a.mode & Oi) === si && (p === C || p === T || p === j)) {
        var y = a.alternate;
        y ? (a.updateQueue = y.updateQueue, a.memoizedState = y.memoizedState, a.lanes = y.lanes) : (a.updateQueue = null, a.memoizedState = null);
      }
    }
    function hF(a) {
      var s = a;
      do {
        if (s.tag === D && Ix(s))
          return s;
        s = s.return;
      } while (s !== null);
      return null;
    }
    function fF(a, s, p, y, Z) {
      if ((a.mode & Oi) === si) {
        if (a === s)
          a.flags |= eu;
        else {
          if (a.flags |= er, p.flags |= Fo, p.flags &= -52805, p.tag === f) {
            var X = p.alternate;
            if (X === null)
              p.tag = O;
            else {
              var K = FC(Nr, Ai);
              K.tag = Cm, _h(p, K, Ai);
            }
          }
          p.lanes = Fe(p.lanes, Ai);
        }
        return a;
      }
      return a.flags |= eu, a.lanes = Z, a;
    }
    function fD(a, s, p, y, Z) {
      if (p.flags |= Xc, _o && dZ(a, Z), y !== null && typeof y == "object" && typeof y.then == "function") {
        var X = y;
        hD(p), Co() && p.mode & Oi && N0();
        var K = hF(s);
        if (K !== null) {
          K.flags &= -257, fF(K, s, p, a, Z), K.mode & Oi && CF(a, X, Z), CD(K, a, X);
          return;
        } else {
          if (!V(Z)) {
            CF(a, X, Z), DN();
            return;
          }
          var Q = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          y = Q;
        }
      } else if (Co() && p.mode & Oi) {
        N0();
        var te = hF(s);
        if (te !== null) {
          (te.flags & eu) === Nn && (te.flags |= Sa), fF(te, s, p, a, Z), rm(Wy(y, p));
          return;
        }
      }
      y = Wy(y, p), JU(y);
      var ce = s;
      do {
        switch (ce.tag) {
          case b: {
            var Ce = y;
            ce.flags |= eu;
            var Qe = Yi(Z);
            ce.lanes = Fe(ce.lanes, Qe);
            var Pe = IF(ce, Ce, Qe);
            EA(ce, Pe);
            return;
          }
          case f:
            var pt = y, yt = ce.type, Yt = ce.stateNode;
            if ((ce.flags & er) === Nn && (typeof yt.getDerivedStateFromError == "function" || Yt !== null && typeof Yt.componentDidCatch == "function" && !hE(Yt))) {
              ce.flags |= eu;
              var On = Yi(Z);
              ce.lanes = Fe(ce.lanes, On);
              var Ri = dN(ce, pt, On);
              EA(ce, Ri);
              return;
            }
            break;
        }
        ce = ce.return;
      } while (ce !== null);
    }
    function pD() {
      return null;
    }
    var QS = n.ReactCurrentOwner, Kh = !1, IN, jS, CN, hN, fN, Vy, pN, xx, qS;
    IN = {}, jS = {}, CN = {}, hN = {}, fN = {}, Vy = !1, pN = {}, xx = {}, qS = {};
    function Kg(a, s, p, y) {
      a === null ? s.child = YC(s, null, p, y) : s.child = Ld(s, a.child, p, y);
    }
    function mD(a, s, p, y) {
      s.child = Ld(s, a.child, null, y), s.child = Ld(s, null, p, y);
    }
    function pF(a, s, p, y, Z) {
      if (s.type !== s.elementType) {
        var X = p.propTypes;
        X && Xd(
          X,
          y,
          // Resolved props
          "prop",
          Hi(p)
        );
      }
      var K = p.render, Q = s.ref, te, ce;
      Im(s, Z), Vr(s);
      {
        if (QS.current = s, fu(!0), te = DA(a, s, K, y, Q, Z), ce = El(), s.mode & Xi) {
          tr(!0);
          try {
            te = DA(a, s, K, y, Q, Z), ce = El();
          } finally {
            tr(!1);
          }
        }
        fu(!1);
      }
      return ri(), a !== null && !Kh ? (U0(a, s, Z), ym(a, s, Z)) : (Co() && ce && xA(s), s.flags |= Ru, Kg(a, s, te, Z), s.child);
    }
    function mF(a, s, p, y, Z) {
      if (a === null) {
        var X = p.type;
        if (GO(X) && p.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        p.defaultProps === void 0) {
          var K = X;
          return K = pG(X), s.tag = j, s.type = K, vN(s, X), AF(a, s, K, y, Z);
        }
        {
          var Q = X.propTypes;
          if (Q && Xd(
            Q,
            y,
            // Resolved props
            "prop",
            Hi(X)
          ), p.defaultProps !== void 0) {
            var te = Hi(X) || "Unknown";
            qS[te] || (u("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", te), qS[te] = !0);
          }
        }
        var ce = nM(p.type, null, y, s, s.mode, Z);
        return ce.ref = s.ref, ce.return = s, s.child = ce, ce;
      }
      {
        var Ce = p.type, Qe = Ce.propTypes;
        Qe && Xd(
          Qe,
          y,
          // Resolved props
          "prop",
          Hi(Ce)
        );
      }
      var Pe = a.child, pt = ZN(a, Z);
      if (!pt) {
        var yt = Pe.memoizedProps, Yt = p.compare;
        if (Yt = Yt !== null ? Yt : Ci, Yt(yt, y) && a.ref === s.ref)
          return ym(a, s, Z);
      }
      s.flags |= Ru;
      var On = Yy(Pe, y);
      return On.ref = s.ref, On.return = s, s.child = On, On;
    }
    function AF(a, s, p, y, Z) {
      if (s.type !== s.elementType) {
        var X = s.elementType;
        if (X.$$typeof === ae) {
          var K = X, Q = K._payload, te = K._init;
          try {
            X = te(Q);
          } catch {
            X = null;
          }
          var ce = X && X.propTypes;
          ce && Xd(
            ce,
            y,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Hi(X)
          );
        }
      }
      if (a !== null) {
        var Ce = a.memoizedProps;
        if (Ci(Ce, y) && a.ref === s.ref && // Prevent bailout if the implementation changed due to hot reload.
        s.type === a.type)
          if (Kh = !1, s.pendingProps = y = Ce, ZN(a, Z))
            (a.flags & Fo) !== Nn && (Kh = !0);
          else return s.lanes = a.lanes, ym(a, s, Z);
      }
      return mN(a, s, p, y, Z);
    }
    function vF(a, s, p) {
      var y = s.pendingProps, Z = y.children, X = a !== null ? a.memoizedState : null;
      if (y.mode === "hidden" || le)
        if ((s.mode & Oi) === si) {
          var K = {
            baseLanes: Ht,
            cachePool: null,
            transitions: null
          };
          s.memoizedState = K, Kx(s, p);
        } else if (ga(p, il)) {
          var Qe = {
            baseLanes: Ht,
            cachePool: null,
            transitions: null
          };
          s.memoizedState = Qe;
          var Pe = X !== null ? X.baseLanes : p;
          Kx(s, Pe);
        } else {
          var Q = null, te;
          if (X !== null) {
            var ce = X.baseLanes;
            te = Fe(ce, p);
          } else
            te = p;
          s.lanes = s.childLanes = il;
          var Ce = {
            baseLanes: te,
            cachePool: Q,
            transitions: null
          };
          return s.memoizedState = Ce, s.updateQueue = null, Kx(s, te), null;
        }
      else {
        var pt;
        X !== null ? (pt = Fe(X.baseLanes, p), s.memoizedState = null) : pt = p, Kx(s, pt);
      }
      return Kg(a, s, Z, p), s.child;
    }
    function AD(a, s, p) {
      var y = s.pendingProps;
      return Kg(a, s, y, p), s.child;
    }
    function vD(a, s, p) {
      var y = s.pendingProps.children;
      return Kg(a, s, y, p), s.child;
    }
    function yD(a, s, p) {
      {
        s.flags |= pi;
        {
          var y = s.stateNode;
          y.effectDuration = 0, y.passiveEffectDuration = 0;
        }
      }
      var Z = s.pendingProps, X = Z.children;
      return Kg(a, s, X, p), s.child;
    }
    function yF(a, s) {
      var p = s.ref;
      (a === null && p !== null || a !== null && a.ref !== p) && (s.flags |= io, s.flags |= xu);
    }
    function mN(a, s, p, y, Z) {
      if (s.type !== s.elementType) {
        var X = p.propTypes;
        X && Xd(
          X,
          y,
          // Resolved props
          "prop",
          Hi(p)
        );
      }
      var K;
      {
        var Q = jp(s, p, !0);
        K = _f(s, Q);
      }
      var te, ce;
      Im(s, Z), Vr(s);
      {
        if (QS.current = s, fu(!0), te = DA(a, s, p, y, K, Z), ce = El(), s.mode & Xi) {
          tr(!0);
          try {
            te = DA(a, s, p, y, K, Z), ce = El();
          } finally {
            tr(!1);
          }
        }
        fu(!1);
      }
      return ri(), a !== null && !Kh ? (U0(a, s, Z), ym(a, s, Z)) : (Co() && ce && xA(s), s.flags |= Ru, Kg(a, s, te, Z), s.child);
    }
    function bF(a, s, p, y, Z) {
      {
        switch (EO(s)) {
          case !1: {
            var X = s.stateNode, K = s.type, Q = new K(s.memoizedProps, X.context), te = Q.state;
            X.updater.enqueueSetState(X, te, null);
            break;
          }
          case !0: {
            s.flags |= er, s.flags |= eu;
            var ce = new Error("Simulated error coming from DevTools"), Ce = Yi(Z);
            s.lanes = Fe(s.lanes, Ce);
            var Qe = dN(s, Wy(ce, s), Ce);
            EA(s, Qe);
            break;
          }
        }
        if (s.type !== s.elementType) {
          var Pe = p.propTypes;
          Pe && Xd(
            Pe,
            y,
            // Resolved props
            "prop",
            Hi(p)
          );
        }
      }
      var pt;
      NC(p) ? (pt = !0, Z0(s)) : pt = !1, Im(s, Z);
      var yt = s.stateNode, Yt;
      yt === null ? (Vx(a, s), Rx(s, p, y), uN(s, p, y, Z), Yt = !0) : a === null ? Yt = cD(s, p, y, Z) : Yt = gD(a, s, p, y, Z);
      var On = AN(a, s, p, Yt, pt, Z);
      {
        var Ri = s.stateNode;
        Yt && Ri.props !== y && (Vy || u("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", xi(s) || "a component"), Vy = !0);
      }
      return On;
    }
    function AN(a, s, p, y, Z, X) {
      yF(a, s);
      var K = (s.flags & er) !== Nn;
      if (!y && !K)
        return Z && jR(s, p, !1), ym(a, s, X);
      var Q = s.stateNode;
      QS.current = s;
      var te;
      if (K && typeof p.getDerivedStateFromError != "function")
        te = null, zt();
      else {
        Vr(s);
        {
          if (fu(!0), te = Q.render(), s.mode & Xi) {
            tr(!0);
            try {
              Q.render();
            } finally {
              tr(!1);
            }
          }
          fu(!1);
        }
        ri();
      }
      return s.flags |= Ru, a !== null && K ? mD(a, s, te, X) : Kg(a, s, te, X), s.memoizedState = Q.state, Z && jR(s, p, !0), s.child;
    }
    function GF(a) {
      var s = a.stateNode;
      s.pendingContext ? JR(a, s.pendingContext, s.pendingContext !== s.context) : s.context && JR(a, s.context, !1), kd(a, s.containerInfo);
    }
    function bD(a, s, p) {
      if (GF(s), a === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var y = s.pendingProps, Z = s.memoizedState, X = Z.element;
      RS(a, s), TA(s, y, null, p);
      var K = s.memoizedState;
      s.stateNode;
      var Q = K.element;
      if (Z.isDehydrated) {
        var te = {
          element: Q,
          isDehydrated: !1,
          cache: K.cache,
          pendingSuspenseBoundaries: K.pendingSuspenseBoundaries,
          transitions: K.transitions
        }, ce = s.updateQueue;
        if (ce.baseState = te, s.memoizedState = te, s.flags & Sa) {
          var Ce = Wy(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), s);
          return BF(a, s, Q, p, Ce);
        } else if (Q !== X) {
          var Qe = Wy(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), s);
          return BF(a, s, Q, p, Qe);
        } else {
          jV(s);
          var Pe = YC(s, null, Q, p);
          s.child = Pe;
          for (var pt = Pe; pt; )
            pt.flags = pt.flags & -3 | Da, pt = pt.sibling;
        }
      } else {
        if (hs(), Q === X)
          return ym(a, s, p);
        Kg(a, s, Q, p);
      }
      return s.child;
    }
    function BF(a, s, p, y, Z) {
      return hs(), rm(Z), s.flags |= Sa, Kg(a, s, p, y), s.child;
    }
    function GD(a, s, p) {
      WS(s), a === null && AS(s);
      var y = s.type, Z = s.pendingProps, X = a !== null ? a.memoizedProps : null, K = Z.children, Q = eS(y, Z);
      return Q ? K = null : X !== null && eS(y, X) && (s.flags |= Ur), yF(a, s), Kg(a, s, K, p), s.child;
    }
    function BD(a, s) {
      return a === null && AS(s), null;
    }
    function SD(a, s, p, y) {
      Vx(a, s);
      var Z = s.pendingProps, X = p, K = X._payload, Q = X._init, te = Q(K);
      s.type = te;
      var ce = s.tag = BO(te), Ce = wr(te, Z), Qe;
      switch (ce) {
        case C:
          return vN(s, te), s.type = te = pG(te), Qe = mN(null, s, te, Ce, y), Qe;
        case f:
          return s.type = te = QN(te), Qe = bF(null, s, te, Ce, y), Qe;
        case T:
          return s.type = te = jN(te), Qe = pF(null, s, te, Ce, y), Qe;
        case L: {
          if (s.type !== s.elementType) {
            var Pe = te.propTypes;
            Pe && Xd(
              Pe,
              Ce,
              // Resolved for outer only
              "prop",
              Hi(te)
            );
          }
          return Qe = mF(
            null,
            s,
            te,
            wr(te.type, Ce),
            // The inner type can have defaults too
            y
          ), Qe;
        }
      }
      var pt = "";
      throw te !== null && typeof te == "object" && te.$$typeof === ae && (pt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + te + ". " + ("Lazy element type must resolve to a class or function." + pt));
    }
    function ZD(a, s, p, y, Z) {
      Vx(a, s), s.tag = f;
      var X;
      return NC(p) ? (X = !0, Z0(s)) : X = !1, Im(s, Z), Rx(s, p, y), uN(s, p, y, Z), AN(null, s, p, !0, X, Z);
    }
    function wD(a, s, p, y) {
      Vx(a, s);
      var Z = s.pendingProps, X;
      {
        var K = jp(s, p, !1);
        X = _f(s, K);
      }
      Im(s, y);
      var Q, te;
      Vr(s);
      {
        if (p.prototype && typeof p.prototype.render == "function") {
          var ce = Hi(p) || "Unknown";
          IN[ce] || (u("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ce, ce), IN[ce] = !0);
        }
        s.mode & Xi && Kd.recordLegacyContextWarning(s, null), fu(!0), QS.current = s, Q = DA(null, s, p, Z, X, y), te = El(), fu(!1);
      }
      if (ri(), s.flags |= Ru, typeof Q == "object" && Q !== null && typeof Q.render == "function" && Q.$$typeof === void 0) {
        var Ce = Hi(p) || "Unknown";
        jS[Ce] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ce, Ce, Ce), jS[Ce] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof Q == "object" && Q !== null && typeof Q.render == "function" && Q.$$typeof === void 0
      ) {
        {
          var Qe = Hi(p) || "Unknown";
          jS[Qe] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Qe, Qe, Qe), jS[Qe] = !0);
        }
        s.tag = f, s.memoizedState = null, s.updateQueue = null;
        var Pe = !1;
        return NC(p) ? (Pe = !0, Z0(s)) : Pe = !1, s.memoizedState = Q.state !== null && Q.state !== void 0 ? Q.state : null, Th(s), wx(s, Q), uN(s, p, Z, y), AN(null, s, p, !0, Pe, y);
      } else {
        if (s.tag = C, s.mode & Xi) {
          tr(!0);
          try {
            Q = DA(null, s, p, Z, X, y), te = El();
          } finally {
            tr(!1);
          }
        }
        return Co() && te && xA(s), Kg(null, s, Q, y), vN(s, p), s.child;
      }
    }
    function vN(a, s) {
      {
        if (s && s.childContextTypes && u("%s(...): childContextTypes cannot be defined on a function component.", s.displayName || s.name || "Component"), a.ref !== null) {
          var p = "", y = Bi();
          y && (p += `

Check the render method of \`` + y + "`.");
          var Z = y || "", X = a._debugSource;
          X && (Z = X.fileName + ":" + X.lineNumber), fN[Z] || (fN[Z] = !0, u("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", p));
        }
        if (s.defaultProps !== void 0) {
          var K = Hi(s) || "Unknown";
          qS[K] || (u("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", K), qS[K] = !0);
        }
        if (typeof s.getDerivedStateFromProps == "function") {
          var Q = Hi(s) || "Unknown";
          hN[Q] || (u("%s: Function components do not support getDerivedStateFromProps.", Q), hN[Q] = !0);
        }
        if (typeof s.contextType == "object" && s.contextType !== null) {
          var te = Hi(s) || "Unknown";
          CN[te] || (u("%s: Function components do not support contextType.", te), CN[te] = !0);
        }
      }
    }
    var yN = {
      dehydrated: null,
      treeContext: null,
      retryLane: Fa
    };
    function bN(a) {
      return {
        baseLanes: a,
        cachePool: pD(),
        transitions: null
      };
    }
    function RD(a, s) {
      var p = null;
      return {
        baseLanes: Fe(a.baseLanes, s),
        cachePool: p,
        transitions: a.transitions
      };
    }
    function xD(a, s, p, y) {
      if (s !== null) {
        var Z = s.memoizedState;
        if (Z === null)
          return !1;
      }
      return K0(a, ps);
    }
    function WD(a, s) {
      return bt(a.childLanes, s);
    }
    function SF(a, s, p) {
      var y = s.pendingProps;
      TO(s) && (s.flags |= er);
      var Z = EI.current, X = !1, K = (s.flags & er) !== Nn;
      if (K || xD(Z, a) ? (X = !0, s.flags &= -129) : (a === null || a.memoizedState !== null) && (Z = oN(Z, NS)), Z = KA(Z), Uf(s, Z), a === null) {
        AS(s);
        var Q = s.memoizedState;
        if (Q !== null) {
          var te = Q.dehydrated;
          if (te !== null)
            return XD(s, te);
        }
        var ce = y.children, Ce = y.fallback;
        if (X) {
          var Qe = VD(s, ce, Ce, p), Pe = s.child;
          return Pe.memoizedState = bN(p), s.memoizedState = yN, Qe;
        } else
          return GN(s, ce);
      } else {
        var pt = a.memoizedState;
        if (pt !== null) {
          var yt = pt.dehydrated;
          if (yt !== null)
            return YD(a, s, K, y, yt, pt, p);
        }
        if (X) {
          var Yt = y.fallback, On = y.children, Ri = MD(a, s, On, Yt, p), hi = s.child, Er = a.child.memoizedState;
          return hi.memoizedState = Er === null ? bN(p) : RD(Er, p), hi.childLanes = WD(a, p), s.memoizedState = yN, Ri;
        } else {
          var Rr = y.children, ut = ND(a, s, Rr, p);
          return s.memoizedState = null, ut;
        }
      }
    }
    function GN(a, s, p) {
      var y = a.mode, Z = {
        mode: "visible",
        children: s
      }, X = BN(Z, y);
      return X.return = a, a.child = X, X;
    }
    function VD(a, s, p, y) {
      var Z = a.mode, X = a.child, K = {
        mode: "hidden",
        children: s
      }, Q, te;
      return (Z & Oi) === si && X !== null ? (Q = X, Q.childLanes = Ht, Q.pendingProps = K, a.mode & ir && (Q.actualDuration = 0, Q.actualStartTime = -1, Q.selfBaseDuration = 0, Q.treeBaseDuration = 0), te = $A(p, Z, y, null)) : (Q = BN(K, Z), te = $A(p, Z, y, null)), Q.return = a, te.return = a, Q.sibling = te, a.child = Q, te;
    }
    function BN(a, s, p) {
      return ZE(a, s, Ht, null);
    }
    function ZF(a, s) {
      return Yy(a, s);
    }
    function ND(a, s, p, y) {
      var Z = a.child, X = Z.sibling, K = ZF(Z, {
        mode: "visible",
        children: p
      });
      if ((s.mode & Oi) === si && (K.lanes = y), K.return = s, K.sibling = null, X !== null) {
        var Q = s.deletions;
        Q === null ? (s.deletions = [X], s.flags |= ea) : Q.push(X);
      }
      return s.child = K, K;
    }
    function MD(a, s, p, y, Z) {
      var X = s.mode, K = a.child, Q = K.sibling, te = {
        mode: "hidden",
        children: p
      }, ce;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (X & Oi) === si && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        s.child !== K
      ) {
        var Ce = s.child;
        ce = Ce, ce.childLanes = Ht, ce.pendingProps = te, s.mode & ir && (ce.actualDuration = 0, ce.actualStartTime = -1, ce.selfBaseDuration = K.selfBaseDuration, ce.treeBaseDuration = K.treeBaseDuration), s.deletions = null;
      } else
        ce = ZF(K, te), ce.subtreeFlags = K.subtreeFlags & na;
      var Qe;
      return Q !== null ? Qe = Yy(Q, y) : (Qe = $A(y, X, Z, null), Qe.flags |= xa), Qe.return = s, ce.return = s, ce.sibling = Qe, s.child = ce, Qe;
    }
    function Wx(a, s, p, y) {
      y !== null && rm(y), Ld(s, a.child, null, p);
      var Z = s.pendingProps, X = Z.children, K = GN(s, X);
      return K.flags |= xa, s.memoizedState = null, K;
    }
    function HD(a, s, p, y, Z) {
      var X = s.mode, K = {
        mode: "visible",
        children: p
      }, Q = BN(K, X), te = $A(y, X, Z, null);
      return te.flags |= xa, Q.return = s, te.return = s, Q.sibling = te, s.child = Q, (s.mode & Oi) !== si && Ld(s, a.child, null, Z), te;
    }
    function XD(a, s, p) {
      return (a.mode & Oi) === si ? (u("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), a.lanes = Ai) : I0(s) ? a.lanes = xo : a.lanes = il, null;
    }
    function YD(a, s, p, y, Z, X, K) {
      if (p)
        if (s.flags & Sa) {
          s.flags &= -257;
          var ut = cN(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Wx(a, s, K, ut);
        } else {
          if (s.memoizedState !== null)
            return s.child = a.child, s.flags |= er, null;
          var Ft = y.children, ct = y.fallback, cn = HD(a, s, Ft, ct, K), ni = s.child;
          return ni.memoizedState = bN(K), s.memoizedState = yN, cn;
        }
      else {
        if (hS(), (s.mode & Oi) === si)
          return Wx(
            a,
            s,
            K,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (I0(Z)) {
          var Q, te, ce;
          {
            var Ce = EV(Z);
            Q = Ce.digest, te = Ce.message, ce = Ce.stack;
          }
          var Qe;
          te ? Qe = new Error(te) : Qe = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var Pe = cN(Qe, Q, ce);
          return Wx(a, s, K, Pe);
        }
        var pt = ga(K, a.childLanes);
        if (Kh || pt) {
          var yt = zx();
          if (yt !== null) {
            var Yt = Wp(yt, K);
            if (Yt !== Fa && Yt !== X.retryLane) {
              X.retryLane = Yt;
              var On = Nr;
              fc(a, Yt), gu(yt, a, Yt, On);
            }
          }
          DN();
          var Ri = cN(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Wx(a, s, K, Ri);
        } else if (FR(Z)) {
          s.flags |= er, s.child = a.child;
          var hi = sO.bind(null, a);
          return ER(Z, hi), null;
        } else {
          M0(s, Z, X.treeContext);
          var Er = y.children, Rr = GN(s, Er);
          return Rr.flags |= Da, Rr;
        }
      }
    }
    function wF(a, s, p) {
      a.lanes = Fe(a.lanes, s);
      var y = a.alternate;
      y !== null && (y.lanes = Fe(y.lanes, s)), fs(a.return, s, p);
    }
    function FD(a, s, p) {
      for (var y = s; y !== null; ) {
        if (y.tag === D) {
          var Z = y.memoizedState;
          Z !== null && wF(y, p, a);
        } else if (y.tag === he)
          wF(y, p, a);
        else if (y.child !== null) {
          y.child.return = y, y = y.child;
          continue;
        }
        if (y === a)
          return;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === a)
            return;
          y = y.return;
        }
        y.sibling.return = y.return, y = y.sibling;
      }
    }
    function ED(a) {
      for (var s = a, p = null; s !== null; ) {
        var y = s.alternate;
        y !== null && fm(y) === null && (p = s), s = s.sibling;
      }
      return p;
    }
    function TD(a) {
      if (a !== void 0 && a !== "forwards" && a !== "backwards" && a !== "together" && !pN[a])
        if (pN[a] = !0, typeof a == "string")
          switch (a.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', a, a.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', a, a.toLowerCase());
              break;
            }
            default:
              u('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
              break;
          }
        else
          u('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
    }
    function _D(a, s) {
      a !== void 0 && !xx[a] && (a !== "collapsed" && a !== "hidden" ? (xx[a] = !0, u('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', a)) : s !== "forwards" && s !== "backwards" && (xx[a] = !0, u('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', a)));
    }
    function RF(a, s) {
      {
        var p = Zi(a), y = !p && typeof Zn(a) == "function";
        if (p || y) {
          var Z = p ? "array" : "iterable";
          return u("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", Z, s, Z), !1;
        }
      }
      return !0;
    }
    function zD(a, s) {
      if ((s === "forwards" || s === "backwards") && a !== void 0 && a !== null && a !== !1)
        if (Zi(a)) {
          for (var p = 0; p < a.length; p++)
            if (!RF(a[p], p))
              return;
        } else {
          var y = Zn(a);
          if (typeof y == "function") {
            var Z = y.call(a);
            if (Z)
              for (var X = Z.next(), K = 0; !X.done; X = Z.next()) {
                if (!RF(X.value, K))
                  return;
                K++;
              }
          } else
            u('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', s);
        }
    }
    function SN(a, s, p, y, Z) {
      var X = a.memoizedState;
      X === null ? a.memoizedState = {
        isBackwards: s,
        rendering: null,
        renderingStartTime: 0,
        last: y,
        tail: p,
        tailMode: Z
      } : (X.isBackwards = s, X.rendering = null, X.renderingStartTime = 0, X.last = y, X.tail = p, X.tailMode = Z);
    }
    function xF(a, s, p) {
      var y = s.pendingProps, Z = y.revealOrder, X = y.tail, K = y.children;
      TD(Z), _D(X, Z), zD(K, Z), Kg(a, s, K, p);
      var Q = EI.current, te = K0(Q, ps);
      if (te)
        Q = MS(Q, ps), s.flags |= er;
      else {
        var ce = a !== null && (a.flags & er) !== Nn;
        ce && FD(s, s.child, p), Q = KA(Q);
      }
      if (Uf(s, Q), (s.mode & Oi) === si)
        s.memoizedState = null;
      else
        switch (Z) {
          case "forwards": {
            var Ce = ED(s.child), Qe;
            Ce === null ? (Qe = s.child, s.child = null) : (Qe = Ce.sibling, Ce.sibling = null), SN(
              s,
              !1,
              // isBackwards
              Qe,
              Ce,
              X
            );
            break;
          }
          case "backwards": {
            var Pe = null, pt = s.child;
            for (s.child = null; pt !== null; ) {
              var yt = pt.alternate;
              if (yt !== null && fm(yt) === null) {
                s.child = pt;
                break;
              }
              var Yt = pt.sibling;
              pt.sibling = Pe, Pe = pt, pt = Yt;
            }
            SN(
              s,
              !0,
              // isBackwards
              Pe,
              null,
              // last
              X
            );
            break;
          }
          case "together": {
            SN(
              s,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            s.memoizedState = null;
        }
      return s.child;
    }
    function KD(a, s, p) {
      kd(s, s.stateNode.containerInfo);
      var y = s.pendingProps;
      return a === null ? s.child = Ld(s, null, y, p) : Kg(a, s, y, p), s.child;
    }
    var WF = !1;
    function LD(a, s, p) {
      var y = s.type, Z = y._context, X = s.pendingProps, K = s.memoizedProps, Q = X.value;
      {
        "value" in X || WF || (WF = !0, u("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var te = s.type.propTypes;
        te && Xd(te, X, "prop", "Context.Provider");
      }
      if (Eh(s, Z, Q), K !== null) {
        var ce = K.value;
        if (zn(ce, Q)) {
          if (K.children === X.children && !ay())
            return ym(a, s, p);
        } else
          eN(s, Z, p);
      }
      var Ce = X.children;
      return Kg(a, s, Ce, p), s.child;
    }
    var VF = !1;
    function kD(a, s, p) {
      var y = s.type;
      y._context === void 0 ? y !== y.Consumer && (VF || (VF = !0, u("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : y = y._context;
      var Z = s.pendingProps, X = Z.children;
      typeof X != "function" && u("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Im(s, p);
      var K = Or(y);
      Vr(s);
      var Q;
      return QS.current = s, fu(!0), Q = X(K), fu(!1), ri(), s.flags |= Ru, Kg(a, s, Q, p), s.child;
    }
    function $S() {
      Kh = !0;
    }
    function Vx(a, s) {
      (s.mode & Oi) === si && a !== null && (a.alternate = null, s.alternate = null, s.flags |= xa);
    }
    function ym(a, s, p) {
      return a !== null && (s.dependencies = a.dependencies), zt(), gZ(s.lanes), ga(p, s.childLanes) ? (gy(a, s), s.child) : null;
    }
    function DD(a, s, p) {
      {
        var y = s.return;
        if (y === null)
          throw new Error("Cannot swap the root fiber.");
        if (a.alternate = null, s.alternate = null, p.index = s.index, p.sibling = s.sibling, p.return = s.return, p.ref = s.ref, s === y.child)
          y.child = p;
        else {
          var Z = y.child;
          if (Z === null)
            throw new Error("Expected parent to have a child.");
          for (; Z.sibling !== s; )
            if (Z = Z.sibling, Z === null)
              throw new Error("Expected to find the previous sibling.");
          Z.sibling = p;
        }
        var X = y.deletions;
        return X === null ? (y.deletions = [a], y.flags |= ea) : X.push(a), p.flags |= xa, p;
      }
    }
    function ZN(a, s) {
      var p = a.lanes;
      return !!ga(p, s);
    }
    function UD(a, s, p) {
      switch (s.tag) {
        case b:
          GF(s), s.stateNode, hs();
          break;
        case R:
          WS(s);
          break;
        case f: {
          var y = s.type;
          NC(y) && Z0(s);
          break;
        }
        case S:
          kd(s, s.stateNode.containerInfo);
          break;
        case F: {
          var Z = s.memoizedProps.value, X = s.type._context;
          Eh(s, X, Z);
          break;
        }
        case P:
          {
            var K = ga(p, s.childLanes);
            K && (s.flags |= pi);
            {
              var Q = s.stateNode;
              Q.effectDuration = 0, Q.passiveEffectDuration = 0;
            }
          }
          break;
        case D: {
          var te = s.memoizedState;
          if (te !== null) {
            if (te.dehydrated !== null)
              return Uf(s, KA(EI.current)), s.flags |= er, null;
            var ce = s.child, Ce = ce.childLanes;
            if (ga(p, Ce))
              return SF(a, s, p);
            Uf(s, KA(EI.current));
            var Qe = ym(a, s, p);
            return Qe !== null ? Qe.sibling : null;
          } else
            Uf(s, KA(EI.current));
          break;
        }
        case he: {
          var Pe = (a.flags & er) !== Nn, pt = ga(p, s.childLanes);
          if (Pe) {
            if (pt)
              return xF(a, s, p);
            s.flags |= er;
          }
          var yt = s.memoizedState;
          if (yt !== null && (yt.rendering = null, yt.tail = null, yt.lastEffect = null), Uf(s, EI.current), pt)
            break;
          return null;
        }
        case Ae:
        case ke:
          return s.lanes = Ht, vF(a, s, p);
      }
      return ym(a, s, p);
    }
    function NF(a, s, p) {
      if (s._debugNeedsRemount && a !== null)
        return DD(a, s, nM(s.type, s.key, s.pendingProps, s._debugOwner || null, s.mode, s.lanes));
      if (a !== null) {
        var y = a.memoizedProps, Z = s.pendingProps;
        if (y !== Z || ay() || // Force a re-render if the implementation changed due to hot reload:
        s.type !== a.type)
          Kh = !0;
        else {
          var X = ZN(a, p);
          if (!X && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (s.flags & er) === Nn)
            return Kh = !1, UD(a, s, p);
          (a.flags & Fo) !== Nn ? Kh = !0 : Kh = !1;
        }
      } else if (Kh = !1, Co() && Td(s)) {
        var K = s.index, Q = JV();
        $R(s, Q, K);
      }
      switch (s.lanes = Ht, s.tag) {
        case v:
          return wD(a, s, s.type, p);
        case J: {
          var te = s.elementType;
          return SD(a, s, te, p);
        }
        case C: {
          var ce = s.type, Ce = s.pendingProps, Qe = s.elementType === ce ? Ce : wr(ce, Ce);
          return mN(a, s, ce, Qe, p);
        }
        case f: {
          var Pe = s.type, pt = s.pendingProps, yt = s.elementType === Pe ? pt : wr(Pe, pt);
          return bF(a, s, Pe, yt, p);
        }
        case b:
          return bD(a, s, p);
        case R:
          return GD(a, s, p);
        case W:
          return BD(a, s);
        case D:
          return SF(a, s, p);
        case S:
          return KD(a, s, p);
        case T: {
          var Yt = s.type, On = s.pendingProps, Ri = s.elementType === Yt ? On : wr(Yt, On);
          return pF(a, s, Yt, Ri, p);
        }
        case x:
          return AD(a, s, p);
        case N:
          return vD(a, s, p);
        case P:
          return yD(a, s, p);
        case F:
          return LD(a, s, p);
        case Y:
          return kD(a, s, p);
        case L: {
          var hi = s.type, Er = s.pendingProps, Rr = wr(hi, Er);
          if (s.type !== s.elementType) {
            var ut = hi.propTypes;
            ut && Xd(
              ut,
              Rr,
              // Resolved for outer only
              "prop",
              Hi(hi)
            );
          }
          return Rr = wr(hi.type, Rr), mF(a, s, hi, Rr, p);
        }
        case j:
          return AF(a, s, s.type, s.pendingProps, p);
        case O: {
          var Ft = s.type, ct = s.pendingProps, cn = s.elementType === Ft ? ct : wr(Ft, ct);
          return ZD(a, s, Ft, cn, p);
        }
        case he:
          return xF(a, s, p);
        case pe:
          break;
        case Ae:
          return vF(a, s, p);
      }
      throw new Error("Unknown unit of work tag (" + s.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function cG(a) {
      a.flags |= pi;
    }
    function MF(a) {
      a.flags |= io, a.flags |= xu;
    }
    var HF, wN, XF, YF;
    HF = function(a, s, p, y) {
      for (var Z = s.child; Z !== null; ) {
        if (Z.tag === R || Z.tag === W)
          wR(a, Z.stateNode);
        else if (Z.tag !== S) {
          if (Z.child !== null) {
            Z.child.return = Z, Z = Z.child;
            continue;
          }
        }
        if (Z === s)
          return;
        for (; Z.sibling === null; ) {
          if (Z.return === null || Z.return === s)
            return;
          Z = Z.return;
        }
        Z.sibling.return = Z.return, Z = Z.sibling;
      }
    }, wN = function(a, s) {
    }, XF = function(a, s, p, y, Z) {
      var X = a.memoizedProps;
      if (X !== y) {
        var K = s.stateNode, Q = xS(), te = wV(K, p, X, y, Z, Q);
        s.updateQueue = te, te && cG(s);
      }
    }, YF = function(a, s, p, y) {
      p !== y && cG(s);
    };
    function eZ(a, s) {
      if (!Co())
        switch (a.tailMode) {
          case "hidden": {
            for (var p = a.tail, y = null; p !== null; )
              p.alternate !== null && (y = p), p = p.sibling;
            y === null ? a.tail = null : y.sibling = null;
            break;
          }
          case "collapsed": {
            for (var Z = a.tail, X = null; Z !== null; )
              Z.alternate !== null && (X = Z), Z = Z.sibling;
            X === null ? !s && a.tail !== null ? a.tail.sibling = null : a.tail = null : X.sibling = null;
            break;
          }
        }
    }
    function vc(a) {
      var s = a.alternate !== null && a.alternate.child === a.child, p = Ht, y = Nn;
      if (s) {
        if ((a.mode & ir) !== si) {
          for (var te = a.selfBaseDuration, ce = a.child; ce !== null; )
            p = Fe(p, Fe(ce.lanes, ce.childLanes)), y |= ce.subtreeFlags & na, y |= ce.flags & na, te += ce.treeBaseDuration, ce = ce.sibling;
          a.treeBaseDuration = te;
        } else
          for (var Ce = a.child; Ce !== null; )
            p = Fe(p, Fe(Ce.lanes, Ce.childLanes)), y |= Ce.subtreeFlags & na, y |= Ce.flags & na, Ce.return = a, Ce = Ce.sibling;
        a.subtreeFlags |= y;
      } else {
        if ((a.mode & ir) !== si) {
          for (var Z = a.actualDuration, X = a.selfBaseDuration, K = a.child; K !== null; )
            p = Fe(p, Fe(K.lanes, K.childLanes)), y |= K.subtreeFlags, y |= K.flags, Z += K.actualDuration, X += K.treeBaseDuration, K = K.sibling;
          a.actualDuration = Z, a.treeBaseDuration = X;
        } else
          for (var Q = a.child; Q !== null; )
            p = Fe(p, Fe(Q.lanes, Q.childLanes)), y |= Q.subtreeFlags, y |= Q.flags, Q.return = a, Q = Q.sibling;
        a.subtreeFlags |= y;
      }
      return a.childLanes = p, s;
    }
    function OD(a, s, p) {
      if (Xs() && (s.mode & Oi) !== si && (s.flags & er) === Nn)
        return H0(s), hs(), s.flags |= Sa | Xc | eu, !1;
      var y = Qc(s);
      if (p !== null && p.dehydrated !== null)
        if (a === null) {
          if (!y)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (vS(s), vc(s), (s.mode & ir) !== si) {
            var Z = p !== null;
            if (Z) {
              var X = s.child;
              X !== null && (s.treeBaseDuration -= X.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (hs(), (s.flags & er) === Nn && (s.memoizedState = null), s.flags |= pi, vc(s), (s.mode & ir) !== si) {
            var K = p !== null;
            if (K) {
              var Q = s.child;
              Q !== null && (s.treeBaseDuration -= Q.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return zd(), !0;
    }
    function FF(a, s, p) {
      var y = s.pendingProps;
      switch (WA(s), s.tag) {
        case v:
        case J:
        case j:
        case C:
        case T:
        case x:
        case N:
        case P:
        case Y:
        case L:
          return vc(s), null;
        case f: {
          var Z = s.type;
          return NC(Z) && qp(s), vc(s), null;
        }
        case b: {
          var X = s.stateNode;
          if (zA(s), dS(s), HS(), X.pendingContext && (X.context = X.pendingContext, X.pendingContext = null), a === null || a.child === null) {
            var K = Qc(s);
            if (K)
              cG(s);
            else if (a !== null) {
              var Q = a.memoizedState;
              // Check if this is a client root
              (!Q.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (s.flags & Sa) !== Nn) && (s.flags |= Rs, zd());
            }
          }
          return wN(a, s), vc(s), null;
        }
        case R: {
          VS(s);
          var te = gx(), ce = s.type;
          if (a !== null && s.stateNode != null)
            XF(a, s, ce, y, te), a.ref !== s.ref && MF(s);
          else {
            if (!y) {
              if (s.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return vc(s), null;
            }
            var Ce = xS(), Qe = Qc(s);
            if (Qe)
              rx(s, te, Ce) && cG(s);
            else {
              var Pe = SV(ce, y, te, Ce, s);
              HF(Pe, s, !1, !1), s.stateNode = Pe, ZV(Pe, ce, y, te) && cG(s);
            }
            s.ref !== null && MF(s);
          }
          return vc(s), null;
        }
        case W: {
          var pt = y;
          if (a && s.stateNode != null) {
            var yt = a.memoizedProps;
            YF(a, s, yt, pt);
          } else {
            if (typeof pt != "string" && s.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Yt = gx(), On = xS(), Ri = Qc(s);
            Ri ? qV(s) && cG(s) : s.stateNode = RV(pt, Yt, On, s);
          }
          return vc(s), null;
        }
        case D: {
          LA(s);
          var hi = s.memoizedState;
          if (a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
            var Er = OD(a, s, hi);
            if (!Er)
              return s.flags & eu ? s : null;
          }
          if ((s.flags & er) !== Nn)
            return s.lanes = p, (s.mode & ir) !== si && Pr(s), s;
          var Rr = hi !== null, ut = a !== null && a.memoizedState !== null;
          if (Rr !== ut && Rr) {
            var Ft = s.child;
            if (Ft.flags |= Sl, (s.mode & Oi) !== si) {
              var ct = a === null && (s.memoizedProps.unstable_avoidThisFallback !== !0 || !0);
              ct || K0(EI.current, NS) ? PU() : DN();
            }
          }
          var cn = s.updateQueue;
          if (cn !== null && (s.flags |= pi), vc(s), (s.mode & ir) !== si && Rr) {
            var ni = s.child;
            ni !== null && (s.treeBaseDuration -= ni.treeBaseDuration);
          }
          return null;
        }
        case S:
          return zA(s), wN(a, s), a === null && GA(s.stateNode.containerInfo), vc(s), null;
        case F:
          var Qn = s.type._context;
          return ZS(Qn, s), vc(s), null;
        case O: {
          var ki = s.type;
          return NC(ki) && qp(s), vc(s), null;
        }
        case he: {
          LA(s);
          var qi = s.memoizedState;
          if (qi === null)
            return vc(s), null;
          var Ma = (s.flags & er) !== Nn, oa = qi.rendering;
          if (oa === null)
            if (Ma)
              eZ(qi, !1);
            else {
              var dl = QU() && (a === null || (a.flags & er) === Nn);
              if (!dl)
                for (var sa = s.child; sa !== null; ) {
                  var Ts = fm(sa);
                  if (Ts !== null) {
                    Ma = !0, s.flags |= er, eZ(qi, !1);
                    var qc = Ts.updateQueue;
                    return qc !== null && (s.updateQueue = qc, s.flags |= pi), s.subtreeFlags = Nn, BS(s, p), Uf(s, MS(EI.current, ps)), s.child;
                  }
                  sa = sa.sibling;
                }
              qi.tail !== null && Ya() > rE() && (s.flags |= er, Ma = !0, eZ(qi, !1), s.lanes = Rp);
            }
          else {
            if (!Ma) {
              var Sc = fm(oa);
              if (Sc !== null) {
                s.flags |= er, Ma = !0;
                var _I = Sc.updateQueue;
                if (_I !== null && (s.updateQueue = _I, s.flags |= pi), eZ(qi, !0), qi.tail === null && qi.tailMode === "hidden" && !oa.alternate && !Co())
                  return vc(s), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              Ya() * 2 - qi.renderingStartTime > rE() && p !== il && (s.flags |= er, Ma = !0, eZ(qi, !1), s.lanes = Rp);
            }
            if (qi.isBackwards)
              oa.sibling = s.child, s.child = oa;
            else {
              var Dg = qi.last;
              Dg !== null ? Dg.sibling = oa : s.child = oa, qi.last = oa;
            }
          }
          if (qi.tail !== null) {
            var Ug = qi.tail;
            qi.rendering = Ug, qi.tail = Ug.sibling, qi.renderingStartTime = Ya(), Ug.sibling = null;
            var $c = EI.current;
            return Ma ? $c = MS($c, ps) : $c = KA($c), Uf(s, $c), Ug;
          }
          return vc(s), null;
        }
        case pe:
          break;
        case Ae:
        case ke: {
          kN(s);
          var Zm = s.memoizedState, mG = Zm !== null;
          if (a !== null) {
            var fZ = a.memoizedState, jf = fZ !== null;
            jf !== mG && (s.flags |= Sl);
          }
          return !mG || (s.mode & Oi) === si ? vc(s) : ga(Qf, il) && (vc(s), s.subtreeFlags & (xa | pi) && (s.flags |= Sl)), null;
        }
        case Re:
          return null;
        case Xe:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + s.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function PD(a, s, p) {
      switch (WA(s), s.tag) {
        case f: {
          var y = s.type;
          NC(y) && qp(s);
          var Z = s.flags;
          return Z & eu ? (s.flags = Z & -65537 | er, (s.mode & ir) !== si && Pr(s), s) : null;
        }
        case b: {
          s.stateNode, zA(s), dS(s), HS();
          var X = s.flags;
          return (X & eu) !== Nn && (X & er) === Nn ? (s.flags = X & -65537 | er, s) : null;
        }
        case R:
          return VS(s), null;
        case D: {
          LA(s);
          var K = s.memoizedState;
          if (K !== null && K.dehydrated !== null) {
            if (s.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            hs();
          }
          var Q = s.flags;
          return Q & eu ? (s.flags = Q & -65537 | er, (s.mode & ir) !== si && Pr(s), s) : null;
        }
        case he:
          return LA(s), null;
        case S:
          return zA(s), null;
        case F:
          var te = s.type._context;
          return ZS(te, s), null;
        case Ae:
        case ke:
          return kN(s), null;
        case Re:
          return null;
        default:
          return null;
      }
    }
    function EF(a, s, p) {
      switch (WA(s), s.tag) {
        case f: {
          var y = s.type.childContextTypes;
          y != null && qp(s);
          break;
        }
        case b: {
          s.stateNode, zA(s), dS(s), HS();
          break;
        }
        case R: {
          VS(s);
          break;
        }
        case S:
          zA(s);
          break;
        case D:
          LA(s);
          break;
        case he:
          LA(s);
          break;
        case F:
          var Z = s.type._context;
          ZS(Z, s);
          break;
        case Ae:
        case ke:
          kN(s);
          break;
      }
    }
    var TF = null;
    TF = /* @__PURE__ */ new Set();
    var Nx = !1, yc = !1, JD = typeof WeakSet == "function" ? WeakSet : Set, ui = null, gG = null, dG = null;
    function QD(a) {
      ka(null, function() {
        throw a;
      }), wu();
    }
    var jD = function(a, s) {
      if (s.props = a.memoizedProps, s.state = a.memoizedState, a.mode & ir)
        try {
          Mn(), s.componentWillUnmount();
        } finally {
          ln(a);
        }
      else
        s.componentWillUnmount();
    };
    function _F(a, s) {
      try {
        PA(gl, a);
      } catch (p) {
        po(a, s, p);
      }
    }
    function RN(a, s, p) {
      try {
        jD(a, p);
      } catch (y) {
        po(a, s, y);
      }
    }
    function qD(a, s, p) {
      try {
        p.componentDidMount();
      } catch (y) {
        po(a, s, y);
      }
    }
    function zF(a, s) {
      try {
        LF(a);
      } catch (p) {
        po(a, s, p);
      }
    }
    function IG(a, s) {
      var p = a.ref;
      if (p !== null)
        if (typeof p == "function") {
          var y;
          try {
            if (Je && wt && a.mode & ir)
              try {
                Mn(), y = p(null);
              } finally {
                ln(a);
              }
            else
              y = p(null);
          } catch (Z) {
            po(a, s, Z);
          }
          typeof y == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xi(a));
        } else
          p.current = null;
    }
    function Mx(a, s, p) {
      try {
        p();
      } catch (y) {
        po(a, s, y);
      }
    }
    var KF = !1;
    function $D(a, s) {
      $B(a.containerInfo), ui = s, eU();
      var p = KF;
      return KF = !1, p;
    }
    function eU() {
      for (; ui !== null; ) {
        var a = ui, s = a.child;
        (a.subtreeFlags & Eo) !== Nn && s !== null ? (s.return = a, ui = s) : tU();
      }
    }
    function tU() {
      for (; ui !== null; ) {
        var a = ui;
        Lr(a);
        try {
          nU(a);
        } catch (p) {
          po(a, a.return, p);
        }
        Ra();
        var s = a.sibling;
        if (s !== null) {
          s.return = a.return, ui = s;
          return;
        }
        ui = a.return;
      }
    }
    function nU(a) {
      var s = a.alternate, p = a.flags;
      if ((p & Rs) !== Nn) {
        switch (Lr(a), a.tag) {
          case C:
          case T:
          case j:
            break;
          case f: {
            if (s !== null) {
              var y = s.memoizedProps, Z = s.memoizedState, X = a.stateNode;
              a.type === a.elementType && !Vy && (X.props !== a.memoizedProps && u("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xi(a) || "instance"), X.state !== a.memoizedState && u("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xi(a) || "instance"));
              var K = X.getSnapshotBeforeUpdate(a.elementType === a.type ? y : wr(a.type, y), Z);
              {
                var Q = TF;
                K === void 0 && !Q.has(a.type) && (Q.add(a.type), u("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", xi(a)));
              }
              X.__reactInternalSnapshotBeforeUpdate = K;
            }
            break;
          }
          case b: {
            {
              var te = a.stateNode;
              XR(te.containerInfo);
            }
            break;
          }
          case R:
          case W:
          case S:
          case O:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Ra();
      }
    }
    function Lh(a, s, p) {
      var y = s.updateQueue, Z = y !== null ? y.lastEffect : null;
      if (Z !== null) {
        var X = Z.next, K = X;
        do {
          if ((K.tag & a) === a) {
            var Q = K.destroy;
            K.destroy = void 0, Q !== void 0 && ((a & Yl) !== su ? Wa(s) : (a & gl) !== su && SI(s), (a & Dd) !== su && IZ(!0), Mx(s, p, Q), (a & Dd) !== su && IZ(!1), (a & Yl) !== su ? us() : (a & gl) !== su && ic());
          }
          K = K.next;
        } while (K !== X);
      }
    }
    function PA(a, s) {
      var p = s.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var Z = y.next, X = Z;
        do {
          if ((X.tag & a) === a) {
            (a & Yl) !== su ? oo(s) : (a & gl) !== su && nc(s);
            var K = X.create;
            (a & Dd) !== su && IZ(!0), X.destroy = K(), (a & Dd) !== su && IZ(!1), (a & Yl) !== su ? ia() : (a & gl) !== su && ua();
            {
              var Q = X.destroy;
              if (Q !== void 0 && typeof Q != "function") {
                var te = void 0;
                (X.tag & gl) !== Nn ? te = "useLayoutEffect" : (X.tag & Dd) !== Nn ? te = "useInsertionEffect" : te = "useEffect";
                var ce = void 0;
                Q === null ? ce = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof Q.then == "function" ? ce = `

It looks like you wrote ` + te + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + te + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : ce = " You returned: " + Q, u("%s must not return anything besides a function, which is used for clean-up.%s", te, ce);
              }
            }
          }
          X = X.next;
        } while (X !== Z);
      }
    }
    function iU(a, s) {
      if ((s.flags & pi) !== Nn)
        switch (s.tag) {
          case P: {
            var p = s.stateNode.passiveEffectDuration, y = s.memoizedProps, Z = y.id, X = y.onPostCommit, K = Ja(), Q = s.alternate === null ? "mount" : "update";
            Cn() && (Q = "nested-update"), typeof X == "function" && X(Z, Q, p, K);
            var te = s.return;
            e: for (; te !== null; ) {
              switch (te.tag) {
                case b:
                  var ce = te.stateNode;
                  ce.passiveEffectDuration += p;
                  break e;
                case P:
                  var Ce = te.stateNode;
                  Ce.passiveEffectDuration += p;
                  break e;
              }
              te = te.return;
            }
            break;
          }
        }
    }
    function rU(a, s, p, y) {
      if ((p.flags & GI) !== Nn)
        switch (p.tag) {
          case C:
          case T:
          case j: {
            if (!yc)
              if (p.mode & ir)
                try {
                  Mn(), PA(gl | Fs, p);
                } finally {
                  ln(p);
                }
              else
                PA(gl | Fs, p);
            break;
          }
          case f: {
            var Z = p.stateNode;
            if (p.flags & pi && !yc)
              if (s === null)
                if (p.type === p.elementType && !Vy && (Z.props !== p.memoizedProps && u("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xi(p) || "instance"), Z.state !== p.memoizedState && u("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xi(p) || "instance")), p.mode & ir)
                  try {
                    Mn(), Z.componentDidMount();
                  } finally {
                    ln(p);
                  }
                else
                  Z.componentDidMount();
              else {
                var X = p.elementType === p.type ? s.memoizedProps : wr(p.type, s.memoizedProps), K = s.memoizedState;
                if (p.type === p.elementType && !Vy && (Z.props !== p.memoizedProps && u("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xi(p) || "instance"), Z.state !== p.memoizedState && u("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xi(p) || "instance")), p.mode & ir)
                  try {
                    Mn(), Z.componentDidUpdate(X, K, Z.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    ln(p);
                  }
                else
                  Z.componentDidUpdate(X, K, Z.__reactInternalSnapshotBeforeUpdate);
              }
            var Q = p.updateQueue;
            Q !== null && (p.type === p.elementType && !Vy && (Z.props !== p.memoizedProps && u("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xi(p) || "instance"), Z.state !== p.memoizedState && u("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xi(p) || "instance")), cx(p, Q, Z));
            break;
          }
          case b: {
            var te = p.updateQueue;
            if (te !== null) {
              var ce = null;
              if (p.child !== null)
                switch (p.child.tag) {
                  case R:
                    ce = p.child.stateNode;
                    break;
                  case f:
                    ce = p.child.stateNode;
                    break;
                }
              cx(p, te, ce);
            }
            break;
          }
          case R: {
            var Ce = p.stateNode;
            if (s === null && p.flags & pi) {
              var Qe = p.type, Pe = p.memoizedProps;
              xR(Ce, Qe, Pe);
            }
            break;
          }
          case W:
            break;
          case S:
            break;
          case P: {
            {
              var pt = p.memoizedProps, yt = pt.onCommit, Yt = pt.onRender, On = p.stateNode.effectDuration, Ri = Ja(), hi = s === null ? "mount" : "update";
              Cn() && (hi = "nested-update"), typeof Yt == "function" && Yt(p.memoizedProps.id, hi, p.actualDuration, p.treeBaseDuration, p.actualStartTime, Ri);
              {
                typeof yt == "function" && yt(p.memoizedProps.id, hi, On, Ri), tO(p);
                var Er = p.return;
                e: for (; Er !== null; ) {
                  switch (Er.tag) {
                    case b:
                      var Rr = Er.stateNode;
                      Rr.effectDuration += On;
                      break e;
                    case P:
                      var ut = Er.stateNode;
                      ut.effectDuration += On;
                      break e;
                  }
                  Er = Er.return;
                }
              }
            }
            break;
          }
          case D: {
            dU(a, p);
            break;
          }
          case he:
          case O:
          case pe:
          case Ae:
          case ke:
          case Xe:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      yc || p.flags & io && LF(p);
    }
    function aU(a) {
      switch (a.tag) {
        case C:
        case T:
        case j: {
          if (a.mode & ir)
            try {
              Mn(), _F(a, a.return);
            } finally {
              ln(a);
            }
          else
            _F(a, a.return);
          break;
        }
        case f: {
          var s = a.stateNode;
          typeof s.componentDidMount == "function" && qD(a, a.return, s), zF(a, a.return);
          break;
        }
        case R: {
          zF(a, a.return);
          break;
        }
      }
    }
    function oU(a, s) {
      for (var p = null, y = a; ; ) {
        if (y.tag === R) {
          if (p === null) {
            p = y;
            try {
              var Z = y.stateNode;
              s ? MV(Z) : XV(y.stateNode, y.memoizedProps);
            } catch (K) {
              po(a, a.return, K);
            }
          }
        } else if (y.tag === W) {
          if (p === null)
            try {
              var X = y.stateNode;
              s ? HV(X) : YV(X, y.memoizedProps);
            } catch (K) {
              po(a, a.return, K);
            }
        } else if (!((y.tag === Ae || y.tag === ke) && y.memoizedState !== null && y !== a)) {
          if (y.child !== null) {
            y.child.return = y, y = y.child;
            continue;
          }
        }
        if (y === a)
          return;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === a)
            return;
          p === y && (p = null), y = y.return;
        }
        p === y && (p = null), y.sibling.return = y.return, y = y.sibling;
      }
    }
    function LF(a) {
      var s = a.ref;
      if (s !== null) {
        var p = a.stateNode, y;
        switch (a.tag) {
          case R:
            y = p;
            break;
          default:
            y = p;
        }
        if (typeof s == "function") {
          var Z;
          if (a.mode & ir)
            try {
              Mn(), Z = s(y);
            } finally {
              ln(a);
            }
          else
            Z = s(y);
          typeof Z == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xi(a));
        } else
          s.hasOwnProperty("current") || u("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", xi(a)), s.current = y;
      }
    }
    function sU(a) {
      var s = a.alternate;
      s !== null && (s.return = null), a.return = null;
    }
    function kF(a) {
      var s = a.alternate;
      s !== null && (a.alternate = null, kF(s));
      {
        if (a.child = null, a.deletions = null, a.sibling = null, a.tag === R) {
          var p = a.stateNode;
          p !== null && A0(p);
        }
        a.stateNode = null, a._debugOwner = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
      }
    }
    function lU(a) {
      for (var s = a.return; s !== null; ) {
        if (DF(s))
          return s;
        s = s.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function DF(a) {
      return a.tag === R || a.tag === b || a.tag === S;
    }
    function UF(a) {
      var s = a;
      e: for (; ; ) {
        for (; s.sibling === null; ) {
          if (s.return === null || DF(s.return))
            return null;
          s = s.return;
        }
        for (s.sibling.return = s.return, s = s.sibling; s.tag !== R && s.tag !== W && s.tag !== ne; ) {
          if (s.flags & xa || s.child === null || s.tag === S)
            continue e;
          s.child.return = s, s = s.child;
        }
        if (!(s.flags & xa))
          return s.stateNode;
      }
    }
    function uU(a) {
      var s = lU(a);
      switch (s.tag) {
        case R: {
          var p = s.stateNode;
          s.flags & Ur && (WR(p), s.flags &= -33);
          var y = UF(a);
          WN(a, y, p);
          break;
        }
        case b:
        case S: {
          var Z = s.stateNode.containerInfo, X = UF(a);
          xN(a, X, Z);
          break;
        }
        // eslint-disable-next-line-no-fallthrough
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function xN(a, s, p) {
      var y = a.tag, Z = y === R || y === W;
      if (Z) {
        var X = a.stateNode;
        s ? d0(p, X, s) : NR(p, X);
      } else if (y !== S) {
        var K = a.child;
        if (K !== null) {
          xN(K, s, p);
          for (var Q = K.sibling; Q !== null; )
            xN(Q, s, p), Q = Q.sibling;
        }
      }
    }
    function WN(a, s, p) {
      var y = a.tag, Z = y === R || y === W;
      if (Z) {
        var X = a.stateNode;
        s ? MR(p, X, s) : VR(p, X);
      } else if (y !== S) {
        var K = a.child;
        if (K !== null) {
          WN(K, s, p);
          for (var Q = K.sibling; Q !== null; )
            WN(Q, s, p), Q = Q.sibling;
        }
      }
    }
    var bc = null, kh = !1;
    function cU(a, s, p) {
      {
        var y = s;
        e: for (; y !== null; ) {
          switch (y.tag) {
            case R: {
              bc = y.stateNode, kh = !1;
              break e;
            }
            case b: {
              bc = y.stateNode.containerInfo, kh = !0;
              break e;
            }
            case S: {
              bc = y.stateNode.containerInfo, kh = !0;
              break e;
            }
          }
          y = y.return;
        }
        if (bc === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        OF(a, s, p), bc = null, kh = !1;
      }
      sU(p);
    }
    function JA(a, s, p) {
      for (var y = p.child; y !== null; )
        OF(a, s, y), y = y.sibling;
    }
    function OF(a, s, p) {
      switch (ls(p), p.tag) {
        case R:
          yc || IG(p, s);
        // eslint-disable-next-line-no-fallthrough
        case W: {
          {
            var y = bc, Z = kh;
            bc = null, JA(a, s, p), bc = y, kh = Z, bc !== null && (kh ? NV(bc, p.stateNode) : VV(bc, p.stateNode));
          }
          return;
        }
        case ne: {
          bc !== null && (kh ? HR(bc, p.stateNode) : rS(bc, p.stateNode));
          return;
        }
        case S: {
          {
            var X = bc, K = kh;
            bc = p.stateNode.containerInfo, kh = !0, JA(a, s, p), bc = X, kh = K;
          }
          return;
        }
        case C:
        case T:
        case L:
        case j: {
          if (!yc) {
            var Q = p.updateQueue;
            if (Q !== null) {
              var te = Q.lastEffect;
              if (te !== null) {
                var ce = te.next, Ce = ce;
                do {
                  var Qe = Ce, Pe = Qe.destroy, pt = Qe.tag;
                  Pe !== void 0 && ((pt & Dd) !== su ? Mx(p, s, Pe) : (pt & gl) !== su && (SI(p), p.mode & ir ? (Mn(), Mx(p, s, Pe), ln(p)) : Mx(p, s, Pe), ic())), Ce = Ce.next;
                } while (Ce !== ce);
              }
            }
          }
          JA(a, s, p);
          return;
        }
        case f: {
          if (!yc) {
            IG(p, s);
            var yt = p.stateNode;
            typeof yt.componentWillUnmount == "function" && RN(p, s, yt);
          }
          JA(a, s, p);
          return;
        }
        case pe: {
          JA(a, s, p);
          return;
        }
        case Ae: {
          if (
            // TODO: Remove this dead flag
            p.mode & Oi
          ) {
            var Yt = yc;
            yc = Yt || p.memoizedState !== null, JA(a, s, p), yc = Yt;
          } else
            JA(a, s, p);
          break;
        }
        default: {
          JA(a, s, p);
          return;
        }
      }
    }
    function gU(a) {
      a.memoizedState;
    }
    function dU(a, s) {
      var p = s.memoizedState;
      if (p === null) {
        var y = s.alternate;
        if (y !== null) {
          var Z = y.memoizedState;
          if (Z !== null) {
            var X = Z.dehydrated;
            X !== null && lS(X);
          }
        }
      }
    }
    function PF(a) {
      var s = a.updateQueue;
      if (s !== null) {
        a.updateQueue = null;
        var p = a.stateNode;
        p === null && (p = a.stateNode = new JD()), s.forEach(function(y) {
          var Z = lO.bind(null, a, y);
          if (!p.has(y)) {
            if (p.add(y), _o)
              if (gG !== null && dG !== null)
                dZ(dG, gG);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            y.then(Z, Z);
          }
        });
      }
    }
    function IU(a, s, p) {
      gG = p, dG = a, Lr(s), JF(s, a), Lr(s), gG = null, dG = null;
    }
    function Dh(a, s, p) {
      var y = s.deletions;
      if (y !== null)
        for (var Z = 0; Z < y.length; Z++) {
          var X = y[Z];
          try {
            cU(a, s, X);
          } catch (te) {
            po(X, s, te);
          }
        }
      var K = Ds();
      if (s.subtreeFlags & bI)
        for (var Q = s.child; Q !== null; )
          Lr(Q), JF(Q, a), Q = Q.sibling;
      Lr(K);
    }
    function JF(a, s, p) {
      var y = a.alternate, Z = a.flags;
      switch (a.tag) {
        case C:
        case T:
        case L:
        case j: {
          if (Dh(s, a), Jf(a), Z & pi) {
            try {
              Lh(Dd | Fs, a, a.return), PA(Dd | Fs, a);
            } catch (ki) {
              po(a, a.return, ki);
            }
            if (a.mode & ir) {
              try {
                Mn(), Lh(gl | Fs, a, a.return);
              } catch (ki) {
                po(a, a.return, ki);
              }
              ln(a);
            } else
              try {
                Lh(gl | Fs, a, a.return);
              } catch (ki) {
                po(a, a.return, ki);
              }
          }
          return;
        }
        case f: {
          Dh(s, a), Jf(a), Z & io && y !== null && IG(y, y.return);
          return;
        }
        case R: {
          Dh(s, a), Jf(a), Z & io && y !== null && IG(y, y.return);
          {
            if (a.flags & Ur) {
              var X = a.stateNode;
              try {
                WR(X);
              } catch (ki) {
                po(a, a.return, ki);
              }
            }
            if (Z & pi) {
              var K = a.stateNode;
              if (K != null) {
                var Q = a.memoizedProps, te = y !== null ? y.memoizedProps : Q, ce = a.type, Ce = a.updateQueue;
                if (a.updateQueue = null, Ce !== null)
                  try {
                    nS(K, Ce, ce, te, Q, a);
                  } catch (ki) {
                    po(a, a.return, ki);
                  }
              }
            }
          }
          return;
        }
        case W: {
          if (Dh(s, a), Jf(a), Z & pi) {
            if (a.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var Qe = a.stateNode, Pe = a.memoizedProps, pt = y !== null ? y.memoizedProps : Pe;
            try {
              iS(Qe, pt, Pe);
            } catch (ki) {
              po(a, a.return, ki);
            }
          }
          return;
        }
        case b: {
          if (Dh(s, a), Jf(a), Z & pi && y !== null) {
            var yt = y.memoizedState;
            if (yt.isDehydrated)
              try {
                zR(s.containerInfo);
              } catch (ki) {
                po(a, a.return, ki);
              }
          }
          return;
        }
        case S: {
          Dh(s, a), Jf(a);
          return;
        }
        case D: {
          Dh(s, a), Jf(a);
          var Yt = a.child;
          if (Yt.flags & Sl) {
            var On = Yt.stateNode, Ri = Yt.memoizedState, hi = Ri !== null;
            if (On.isHidden = hi, hi) {
              var Er = Yt.alternate !== null && Yt.alternate.memoizedState !== null;
              Er || OU();
            }
          }
          if (Z & pi) {
            try {
              gU(a);
            } catch (ki) {
              po(a, a.return, ki);
            }
            PF(a);
          }
          return;
        }
        case Ae: {
          var Rr = y !== null && y.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            a.mode & Oi
          ) {
            var ut = yc;
            yc = ut || Rr, Dh(s, a), yc = ut;
          } else
            Dh(s, a);
          if (Jf(a), Z & Sl) {
            var Ft = a.stateNode, ct = a.memoizedState, cn = ct !== null, ni = a;
            if (Ft.isHidden = cn, cn && !Rr && (ni.mode & Oi) !== si) {
              ui = ni;
              for (var Qn = ni.child; Qn !== null; )
                ui = Qn, hU(Qn), Qn = Qn.sibling;
            }
            oU(ni, cn);
          }
          return;
        }
        case he: {
          Dh(s, a), Jf(a), Z & pi && PF(a);
          return;
        }
        case pe:
          return;
        default: {
          Dh(s, a), Jf(a);
          return;
        }
      }
    }
    function Jf(a) {
      var s = a.flags;
      if (s & xa) {
        try {
          uU(a);
        } catch (p) {
          po(a, a.return, p);
        }
        a.flags &= -3;
      }
      s & Da && (a.flags &= -4097);
    }
    function CU(a, s, p) {
      gG = p, dG = s, ui = a, QF(a, s, p), gG = null, dG = null;
    }
    function QF(a, s, p) {
      for (var y = (a.mode & Oi) !== si; ui !== null; ) {
        var Z = ui, X = Z.child;
        if (Z.tag === Ae && y) {
          var K = Z.memoizedState !== null, Q = K || Nx;
          if (Q) {
            VN(a, s, p);
            continue;
          } else {
            var te = Z.alternate, ce = te !== null && te.memoizedState !== null, Ce = ce || yc, Qe = Nx, Pe = yc;
            Nx = Q, yc = Ce, yc && !Pe && (ui = Z, fU(Z));
            for (var pt = X; pt !== null; )
              ui = pt, QF(
                pt,
                // New root; bubble back up to here and stop.
                s,
                p
              ), pt = pt.sibling;
            ui = Z, Nx = Qe, yc = Pe, VN(a, s, p);
            continue;
          }
        }
        (Z.subtreeFlags & GI) !== Nn && X !== null ? (X.return = Z, ui = X) : VN(a, s, p);
      }
    }
    function VN(a, s, p) {
      for (; ui !== null; ) {
        var y = ui;
        if ((y.flags & GI) !== Nn) {
          var Z = y.alternate;
          Lr(y);
          try {
            rU(s, Z, y, p);
          } catch (K) {
            po(y, y.return, K);
          }
          Ra();
        }
        if (y === a) {
          ui = null;
          return;
        }
        var X = y.sibling;
        if (X !== null) {
          X.return = y.return, ui = X;
          return;
        }
        ui = y.return;
      }
    }
    function hU(a) {
      for (; ui !== null; ) {
        var s = ui, p = s.child;
        switch (s.tag) {
          case C:
          case T:
          case L:
          case j: {
            if (s.mode & ir)
              try {
                Mn(), Lh(gl, s, s.return);
              } finally {
                ln(s);
              }
            else
              Lh(gl, s, s.return);
            break;
          }
          case f: {
            IG(s, s.return);
            var y = s.stateNode;
            typeof y.componentWillUnmount == "function" && RN(s, s.return, y);
            break;
          }
          case R: {
            IG(s, s.return);
            break;
          }
          case Ae: {
            var Z = s.memoizedState !== null;
            if (Z) {
              jF(a);
              continue;
            }
            break;
          }
        }
        p !== null ? (p.return = s, ui = p) : jF(a);
      }
    }
    function jF(a) {
      for (; ui !== null; ) {
        var s = ui;
        if (s === a) {
          ui = null;
          return;
        }
        var p = s.sibling;
        if (p !== null) {
          p.return = s.return, ui = p;
          return;
        }
        ui = s.return;
      }
    }
    function fU(a) {
      for (; ui !== null; ) {
        var s = ui, p = s.child;
        if (s.tag === Ae) {
          var y = s.memoizedState !== null;
          if (y) {
            qF(a);
            continue;
          }
        }
        p !== null ? (p.return = s, ui = p) : qF(a);
      }
    }
    function qF(a) {
      for (; ui !== null; ) {
        var s = ui;
        Lr(s);
        try {
          aU(s);
        } catch (y) {
          po(s, s.return, y);
        }
        if (Ra(), s === a) {
          ui = null;
          return;
        }
        var p = s.sibling;
        if (p !== null) {
          p.return = s.return, ui = p;
          return;
        }
        ui = s.return;
      }
    }
    function pU(a, s, p, y) {
      ui = s, mU(s, a, p, y);
    }
    function mU(a, s, p, y) {
      for (; ui !== null; ) {
        var Z = ui, X = Z.child;
        (Z.subtreeFlags & So) !== Nn && X !== null ? (X.return = Z, ui = X) : AU(a, s, p, y);
      }
    }
    function AU(a, s, p, y) {
      for (; ui !== null; ) {
        var Z = ui;
        if ((Z.flags & $s) !== Nn) {
          Lr(Z);
          try {
            vU(s, Z, p, y);
          } catch (K) {
            po(Z, Z.return, K);
          }
          Ra();
        }
        if (Z === a) {
          ui = null;
          return;
        }
        var X = Z.sibling;
        if (X !== null) {
          X.return = Z.return, ui = X;
          return;
        }
        ui = Z.return;
      }
    }
    function vU(a, s, p, y) {
      switch (s.tag) {
        case C:
        case T:
        case j: {
          if (s.mode & ir) {
            mr();
            try {
              PA(Yl | Fs, s);
            } finally {
              gi(s);
            }
          } else
            PA(Yl | Fs, s);
          break;
        }
      }
    }
    function yU(a) {
      ui = a, bU();
    }
    function bU() {
      for (; ui !== null; ) {
        var a = ui, s = a.child;
        if ((ui.flags & ea) !== Nn) {
          var p = a.deletions;
          if (p !== null) {
            for (var y = 0; y < p.length; y++) {
              var Z = p[y];
              ui = Z, SU(Z, a);
            }
            {
              var X = a.alternate;
              if (X !== null) {
                var K = X.child;
                if (K !== null) {
                  X.child = null;
                  do {
                    var Q = K.sibling;
                    K.sibling = null, K = Q;
                  } while (K !== null);
                }
              }
            }
            ui = a;
          }
        }
        (a.subtreeFlags & So) !== Nn && s !== null ? (s.return = a, ui = s) : GU();
      }
    }
    function GU() {
      for (; ui !== null; ) {
        var a = ui;
        (a.flags & $s) !== Nn && (Lr(a), BU(a), Ra());
        var s = a.sibling;
        if (s !== null) {
          s.return = a.return, ui = s;
          return;
        }
        ui = a.return;
      }
    }
    function BU(a) {
      switch (a.tag) {
        case C:
        case T:
        case j: {
          a.mode & ir ? (mr(), Lh(Yl | Fs, a, a.return), gi(a)) : Lh(Yl | Fs, a, a.return);
          break;
        }
      }
    }
    function SU(a, s) {
      for (; ui !== null; ) {
        var p = ui;
        Lr(p), wU(p, s), Ra();
        var y = p.child;
        y !== null ? (y.return = p, ui = y) : ZU(a);
      }
    }
    function ZU(a) {
      for (; ui !== null; ) {
        var s = ui, p = s.sibling, y = s.return;
        if (kF(s), s === a) {
          ui = null;
          return;
        }
        if (p !== null) {
          p.return = y, ui = p;
          return;
        }
        ui = y;
      }
    }
    function wU(a, s) {
      switch (a.tag) {
        case C:
        case T:
        case j: {
          a.mode & ir ? (mr(), Lh(Yl, a, s), gi(a)) : Lh(Yl, a, s);
          break;
        }
      }
    }
    function RU(a) {
      switch (a.tag) {
        case C:
        case T:
        case j: {
          try {
            PA(gl | Fs, a);
          } catch (p) {
            po(a, a.return, p);
          }
          break;
        }
        case f: {
          var s = a.stateNode;
          try {
            s.componentDidMount();
          } catch (p) {
            po(a, a.return, p);
          }
          break;
        }
      }
    }
    function xU(a) {
      switch (a.tag) {
        case C:
        case T:
        case j: {
          try {
            PA(Yl | Fs, a);
          } catch (s) {
            po(a, a.return, s);
          }
          break;
        }
      }
    }
    function WU(a) {
      switch (a.tag) {
        case C:
        case T:
        case j: {
          try {
            Lh(gl | Fs, a, a.return);
          } catch (p) {
            po(a, a.return, p);
          }
          break;
        }
        case f: {
          var s = a.stateNode;
          typeof s.componentWillUnmount == "function" && RN(a, a.return, s);
          break;
        }
      }
    }
    function VU(a) {
      switch (a.tag) {
        case C:
        case T:
        case j:
          try {
            Lh(Yl | Fs, a, a.return);
          } catch (s) {
            po(a, a.return, s);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var tZ = Symbol.for;
      tZ("selector.component"), tZ("selector.has_pseudo_class"), tZ("selector.role"), tZ("selector.test_id"), tZ("selector.text");
    }
    var NU = [];
    function MU() {
      NU.forEach(function(a) {
        return a();
      });
    }
    var HU = n.ReactCurrentActQueue;
    function XU(a) {
      {
        var s = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), p = typeof jest < "u";
        return p && s !== !1;
      }
    }
    function $F() {
      {
        var a = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !a && HU.current !== null && u("The current testing environment is not configured to support act(...)"), a;
      }
    }
    var YU = Math.ceil, NN = n.ReactCurrentDispatcher, MN = n.ReactCurrentOwner, Gc = n.ReactCurrentBatchConfig, Uh = n.ReactCurrentActQueue, lu = (
      /*             */
      0
    ), eE = (
      /*               */
      1
    ), Bc = (
      /*                */
      2
    ), LC = (
      /*                */
      4
    ), bm = 0, nZ = 1, Ny = 2, Hx = 3, iZ = 4, tE = 5, HN = 6, Fr = lu, Lg = null, ms = null, uu = Ht, Qf = Ht, XN = Tf(Ht), cu = bm, rZ = null, Xx = Ht, aZ = Ht, Yx = Ht, oZ = null, Pd = null, YN = 0, nE = 500, iE = 1 / 0, FU = 500, Gm = null;
    function sZ() {
      iE = Ya() + FU;
    }
    function rE() {
      return iE;
    }
    var Fx = !1, FN = null, CG = null, My = !1, QA = null, lZ = Ht, EN = [], TN = null, EU = 50, uZ = 0, _N = null, zN = !1, Ex = !1, TU = 50, hG = 0, Tx = null, cZ = Nr, _x = Ht, aE = !1;
    function zx() {
      return Lg;
    }
    function kg() {
      return (Fr & (Bc | LC)) !== lu ? Ya() : (cZ !== Nr || (cZ = Ya()), cZ);
    }
    function jA(a) {
      var s = a.mode;
      if ((s & Oi) === si)
        return Ai;
      if ((Fr & Bc) !== lu && uu !== Ht)
        return Yi(uu);
      var p = ly() !== X0;
      if (p) {
        if (Gc.transition !== null) {
          var y = Gc.transition;
          y._updatedFibers || (y._updatedFibers = /* @__PURE__ */ new Set()), y._updatedFibers.add(a);
        }
        return _x === Fa && (_x = $n()), _x;
      }
      var Z = Nl();
      if (Z !== Fa)
        return Z;
      var X = xV();
      return X;
    }
    function _U(a) {
      var s = a.mode;
      return (s & Oi) === si ? Ai : zi();
    }
    function gu(a, s, p, y) {
      cO(), aE && u("useInsertionEffect must not schedule updates."), zN && (Ex = !0), cr(a, p, y), (Fr & Bc) !== Ht && a === Lg ? IO(s) : (_o && tA(a, s, p), CO(s), a === Lg && ((Fr & Bc) === lu && (aZ = Fe(aZ, p)), cu === iZ && qA(a, uu)), Jd(a, y), p === Ai && Fr === lu && (s.mode & Oi) === si && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Uh.isBatchingLegacy && (sZ(), qR()));
    }
    function zU(a, s, p) {
      var y = a.current;
      y.lanes = s, cr(a, s, p), Jd(a, p);
    }
    function KU(a) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Fr & Bc) !== lu
      );
    }
    function Jd(a, s) {
      var p = a.callbackNode;
      xp(a, s);
      var y = ds(a, a === Lg ? uu : Ht);
      if (y === Ht) {
        p !== null && yE(p), a.callbackNode = null, a.callbackPriority = Fa;
        return;
      }
      var Z = ci(y), X = a.callbackPriority;
      if (X === Z && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Uh.current !== null && p !== PN)) {
        p == null && X !== Ai && u("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      p != null && yE(p);
      var K;
      if (Z === Ai)
        a.tag === Xh ? (Uh.isBatchingLegacy !== null && (Uh.didScheduleLegacyUpdate = !0), PV(lE.bind(null, a))) : CS(lE.bind(null, a)), Uh.current !== null ? Uh.current.push(zf) : WV(function() {
          (Fr & (Bc | LC)) === lu && zf();
        }), K = null;
      else {
        var Q;
        switch (rA(y)) {
          case Vl:
            Q = Wu;
            break;
          case Xu:
            Q = wg;
            break;
          case Is:
            Q = Gd;
            break;
          case Af:
            Q = BI;
            break;
          default:
            Q = Gd;
            break;
        }
        K = JN(Q, oE.bind(null, a));
      }
      a.callbackPriority = Z, a.callbackNode = K;
    }
    function oE(a, s) {
      if (rr(), cZ = Nr, _x = Ht, (Fr & (Bc | LC)) !== lu)
        throw new Error("Should not already be working.");
      var p = a.callbackNode, y = Sm();
      if (y && a.callbackNode !== p)
        return null;
      var Z = ds(a, a === Lg ? uu : Ht);
      if (Z === Ht)
        return null;
      var X = !Ke(a, Z) && !Rt(a, Z) && !s, K = X ? qU(a, Z) : Lx(a, Z);
      if (K !== bm) {
        if (K === Ny) {
          var Q = A(a);
          Q !== Ht && (Z = Q, K = KN(a, Q));
        }
        if (K === nZ) {
          var te = rZ;
          throw Hy(a, Ht), qA(a, Z), Jd(a, Ya()), te;
        }
        if (K === HN)
          qA(a, Z);
        else {
          var ce = !Ke(a, Z), Ce = a.current.alternate;
          if (ce && !kU(Ce)) {
            if (K = Lx(a, Z), K === Ny) {
              var Qe = A(a);
              Qe !== Ht && (Z = Qe, K = KN(a, Qe));
            }
            if (K === nZ) {
              var Pe = rZ;
              throw Hy(a, Ht), qA(a, Z), Jd(a, Ya()), Pe;
            }
          }
          a.finishedWork = Ce, a.finishedLanes = Z, LU(a, K, Z);
        }
      }
      return Jd(a, Ya()), a.callbackNode === p ? oE.bind(null, a) : null;
    }
    function KN(a, s) {
      var p = oZ;
      if (IC(a)) {
        var y = Hy(a, s);
        y.flags |= Sa, bA(a.containerInfo);
      }
      var Z = Lx(a, s);
      if (Z !== Ny) {
        var X = Pd;
        Pd = p, X !== null && sE(X);
      }
      return Z;
    }
    function sE(a) {
      Pd === null ? Pd = a : Pd.push.apply(Pd, a);
    }
    function LU(a, s, p) {
      switch (s) {
        case bm:
        case nZ:
          throw new Error("Root did not complete. This is a bug in React.");
        // Flow knows about invariant, so it complains if I add a break
        // statement, but eslint doesn't know about invariant, so it complains
        // if I do. eslint-disable-next-line no-fallthrough
        case Ny: {
          Xy(a, Pd, Gm);
          break;
        }
        case Hx: {
          if (qA(a, p), k(p) && // do not delay if we're inside an act() scope
          !bE()) {
            var y = YN + nE - Ya();
            if (y > 10) {
              var Z = ds(a, Ht);
              if (Z !== Ht)
                break;
              var X = a.suspendedLanes;
              if (!ot(X, p)) {
                kg(), pr(a, X);
                break;
              }
              a.timeoutHandle = ty(Xy.bind(null, a, Pd, Gm), y);
              break;
            }
          }
          Xy(a, Pd, Gm);
          break;
        }
        case iZ: {
          if (qA(a, p), ve(p))
            break;
          if (!bE()) {
            var K = Wd(a, p), Q = K, te = Ya() - Q, ce = uO(te) - te;
            if (ce > 10) {
              a.timeoutHandle = ty(Xy.bind(null, a, Pd, Gm), ce);
              break;
            }
          }
          Xy(a, Pd, Gm);
          break;
        }
        case tE: {
          Xy(a, Pd, Gm);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function kU(a) {
      for (var s = a; ; ) {
        if (s.flags & gh) {
          var p = s.updateQueue;
          if (p !== null) {
            var y = p.stores;
            if (y !== null)
              for (var Z = 0; Z < y.length; Z++) {
                var X = y[Z], K = X.getSnapshot, Q = X.value;
                try {
                  if (!zn(K(), Q))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var te = s.child;
        if (s.subtreeFlags & gh && te !== null) {
          te.return = s, s = te;
          continue;
        }
        if (s === a)
          return !0;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === a)
            return !0;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return !0;
    }
    function qA(a, s) {
      s = bt(s, Yx), s = bt(s, aZ), Ea(a, s);
    }
    function lE(a) {
      if (Ni(), (Fr & (Bc | LC)) !== lu)
        throw new Error("Should not already be working.");
      Sm();
      var s = ds(a, Ht);
      if (!ga(s, Ai))
        return Jd(a, Ya()), null;
      var p = Lx(a, s);
      if (a.tag !== Xh && p === Ny) {
        var y = A(a);
        y !== Ht && (s = y, p = KN(a, y));
      }
      if (p === nZ) {
        var Z = rZ;
        throw Hy(a, Ht), qA(a, s), Jd(a, Ya()), Z;
      }
      if (p === HN)
        throw new Error("Root did not complete. This is a bug in React.");
      var X = a.current.alternate;
      return a.finishedWork = X, a.finishedLanes = s, Xy(a, Pd, Gm), Jd(a, Ya()), null;
    }
    function DU(a, s) {
      s !== Ht && (Vd(a, Fe(s, Ai)), Jd(a, Ya()), (Fr & (Bc | LC)) === lu && (sZ(), zf()));
    }
    function LN(a, s) {
      var p = Fr;
      Fr |= eE;
      try {
        return a(s);
      } finally {
        Fr = p, Fr === lu && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Uh.isBatchingLegacy && (sZ(), qR());
      }
    }
    function UU(a, s, p, y, Z) {
      var X = Nl(), K = Gc.transition;
      try {
        return Gc.transition = null, zo(Vl), a(s, p, y, Z);
      } finally {
        zo(X), Gc.transition = K, Fr === lu && sZ();
      }
    }
    function Bm(a) {
      QA !== null && QA.tag === Xh && (Fr & (Bc | LC)) === lu && Sm();
      var s = Fr;
      Fr |= eE;
      var p = Gc.transition, y = Nl();
      try {
        return Gc.transition = null, zo(Vl), a ? a() : void 0;
      } finally {
        zo(y), Gc.transition = p, Fr = s, (Fr & (Bc | LC)) === lu && zf();
      }
    }
    function uE() {
      return (Fr & (Bc | LC)) !== lu;
    }
    function Kx(a, s) {
      Tu(XN, Qf, a), Qf = Fe(Qf, s);
    }
    function kN(a) {
      Qf = XN.current, Eu(XN, a);
    }
    function Hy(a, s) {
      a.finishedWork = null, a.finishedLanes = Ht;
      var p = a.timeoutHandle;
      if (p !== yA && (a.timeoutHandle = yA, g0(p)), ms !== null)
        for (var y = ms.return; y !== null; ) {
          var Z = y.alternate;
          EF(Z, y), y = y.return;
        }
      Lg = a;
      var X = Yy(a.current, null);
      return ms = X, uu = Qf = s, cu = bm, rZ = null, Xx = Ht, aZ = Ht, Yx = Ht, oZ = null, Pd = null, ax(), Kd.discardPendingWarnings(), X;
    }
    function cE(a, s) {
      do {
        var p = ms;
        try {
          if (dm(), hx(), Ra(), MN.current = null, p === null || p.return === null) {
            cu = nZ, rZ = s, ms = null;
            return;
          }
          if (Je && p.mode & ir && dt(p, !0), ze)
            if (ri(), s !== null && typeof s == "object" && typeof s.then == "function") {
              var y = s;
              ZI(p, y, uu);
            } else
              nu(p, s, uu);
          fD(a, p.return, p, s, uu), CE(p);
        } catch (Z) {
          s = Z, ms === p && p !== null ? (p = p.return, ms = p) : p = ms;
          continue;
        }
        return;
      } while (!0);
    }
    function gE() {
      var a = NN.current;
      return NN.current = lG, a === null ? lG : a;
    }
    function dE(a) {
      NN.current = a;
    }
    function OU() {
      YN = Ya();
    }
    function gZ(a) {
      Xx = Fe(a, Xx);
    }
    function PU() {
      cu === bm && (cu = Hx);
    }
    function DN() {
      (cu === bm || cu === Hx || cu === Ny) && (cu = iZ), Lg !== null && (E(Xx) || E(aZ)) && qA(Lg, uu);
    }
    function JU(a) {
      cu !== iZ && (cu = Ny), oZ === null ? oZ = [a] : oZ.push(a);
    }
    function QU() {
      return cu === bm;
    }
    function Lx(a, s) {
      var p = Fr;
      Fr |= Bc;
      var y = gE();
      if (Lg !== a || uu !== s) {
        if (_o) {
          var Z = a.memoizedUpdaters;
          Z.size > 0 && (dZ(a, uu), Z.clear()), nA(a, s);
        }
        Gm = mf(), Hy(a, s);
      }
      Bd(s);
      do
        try {
          jU();
          break;
        } catch (X) {
          cE(a, X);
        }
      while (!0);
      if (dm(), Fr = p, dE(y), ms !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return pa(), Lg = null, uu = Ht, cu;
    }
    function jU() {
      for (; ms !== null; )
        IE(ms);
    }
    function qU(a, s) {
      var p = Fr;
      Fr |= Bc;
      var y = gE();
      if (Lg !== a || uu !== s) {
        if (_o) {
          var Z = a.memoizedUpdaters;
          Z.size > 0 && (dZ(a, uu), Z.clear()), nA(a, s);
        }
        Gm = mf(), sZ(), Hy(a, s);
      }
      Bd(s);
      do
        try {
          $U();
          break;
        } catch (X) {
          cE(a, X);
        }
      while (!0);
      return dm(), dE(y), Fr = p, ms !== null ? (cC(), bm) : (pa(), Lg = null, uu = Ht, cu);
    }
    function $U() {
      for (; ms !== null && !ro(); )
        IE(ms);
    }
    function IE(a) {
      var s = a.alternate;
      Lr(a);
      var p;
      (a.mode & ir) !== si ? (Ct(a), p = UN(s, a, Qf), dt(a, !0)) : p = UN(s, a, Qf), Ra(), a.memoizedProps = a.pendingProps, p === null ? CE(a) : ms = p, MN.current = null;
    }
    function CE(a) {
      var s = a;
      do {
        var p = s.alternate, y = s.return;
        if ((s.flags & Xc) === Nn) {
          Lr(s);
          var Z = void 0;
          if ((s.mode & ir) === si ? Z = FF(p, s, Qf) : (Ct(s), Z = FF(p, s, Qf), dt(s, !1)), Ra(), Z !== null) {
            ms = Z;
            return;
          }
        } else {
          var X = PD(p, s);
          if (X !== null) {
            X.flags &= oC, ms = X;
            return;
          }
          if ((s.mode & ir) !== si) {
            dt(s, !1);
            for (var K = s.actualDuration, Q = s.child; Q !== null; )
              K += Q.actualDuration, Q = Q.sibling;
            s.actualDuration = K;
          }
          if (y !== null)
            y.flags |= Xc, y.subtreeFlags = Nn, y.deletions = null;
          else {
            cu = HN, ms = null;
            return;
          }
        }
        var te = s.sibling;
        if (te !== null) {
          ms = te;
          return;
        }
        s = y, ms = s;
      } while (s !== null);
      cu === bm && (cu = tE);
    }
    function Xy(a, s, p) {
      var y = Nl(), Z = Gc.transition;
      try {
        Gc.transition = null, zo(Vl), eO(a, s, p, y);
      } finally {
        Gc.transition = Z, zo(y);
      }
      return null;
    }
    function eO(a, s, p, y) {
      do
        Sm();
      while (QA !== null);
      if (gO(), (Fr & (Bc | LC)) !== lu)
        throw new Error("Should not already be working.");
      var Z = a.finishedWork, X = a.finishedLanes;
      if (Ch(X), Z === null)
        return Nu(), null;
      if (X === Ht && u("root.finishedLanes should not be empty during a commit. This is a bug in React."), a.finishedWork = null, a.finishedLanes = Ht, Z === a.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      a.callbackNode = null, a.callbackPriority = Fa;
      var K = Fe(Z.lanes, Z.childLanes);
      _c(a, K), a === Lg && (Lg = null, ms = null, uu = Ht), ((Z.subtreeFlags & So) !== Nn || (Z.flags & So) !== Nn) && (My || (My = !0, TN = p, JN(Gd, function() {
        return Sm(), null;
      })));
      var Q = (Z.subtreeFlags & (Eo | bI | GI | So)) !== Nn, te = (Z.flags & (Eo | bI | GI | So)) !== Nn;
      if (Q || te) {
        var ce = Gc.transition;
        Gc.transition = null;
        var Ce = Nl();
        zo(Vl);
        var Qe = Fr;
        Fr |= LC, MN.current = null, $D(a, Z), Qa(), IU(a, Z, X), ZR(a.containerInfo), a.current = Z, xg(X), CU(Z, a, X), Ro(), pf(), Fr = Qe, zo(Ce), Gc.transition = ce;
      } else
        a.current = Z, Qa();
      var Pe = My;
      if (My ? (My = !1, QA = a, lZ = X) : (hG = 0, Tx = null), K = a.pendingLanes, K === Ht && (CG = null), Pe || mE(a.current, !1), wo(Z.stateNode, y), _o && a.memoizedUpdaters.clear(), MU(), Jd(a, Ya()), s !== null)
        for (var pt = a.onRecoverableError, yt = 0; yt < s.length; yt++) {
          var Yt = s[yt], On = Yt.stack, Ri = Yt.digest;
          pt(Yt.value, {
            componentStack: On,
            digest: Ri
          });
        }
      if (Fx) {
        Fx = !1;
        var hi = FN;
        throw FN = null, hi;
      }
      return ga(lZ, Ai) && a.tag !== Xh && Sm(), K = a.pendingLanes, ga(K, Ai) ? (yi(), a === _N ? uZ++ : (uZ = 0, _N = a)) : uZ = 0, zf(), Nu(), null;
    }
    function Sm() {
      if (QA !== null) {
        var a = rA(lZ), s = rl(Is, a), p = Gc.transition, y = Nl();
        try {
          return Gc.transition = null, zo(s), nO();
        } finally {
          zo(y), Gc.transition = p;
        }
      }
      return !1;
    }
    function tO(a) {
      EN.push(a), My || (My = !0, JN(Gd, function() {
        return Sm(), null;
      }));
    }
    function nO() {
      if (QA === null)
        return !1;
      var a = TN;
      TN = null;
      var s = QA, p = lZ;
      if (QA = null, lZ = Ht, (Fr & (Bc | LC)) !== lu)
        throw new Error("Cannot flush passive effects while already rendering.");
      zN = !0, Ex = !1, uC(p);
      var y = Fr;
      Fr |= LC, yU(s.current), pU(s, s.current, p, a);
      {
        var Z = EN;
        EN = [];
        for (var X = 0; X < Z.length; X++) {
          var K = Z[X];
          iU(s, K);
        }
      }
      Wg(), mE(s.current, !0), Fr = y, zf(), Ex ? s === Tx ? hG++ : (hG = 0, Tx = s) : hG = 0, zN = !1, Ex = !1, Wn(s);
      {
        var Q = s.current.stateNode;
        Q.effectDuration = 0, Q.passiveEffectDuration = 0;
      }
      return !0;
    }
    function hE(a) {
      return CG !== null && CG.has(a);
    }
    function iO(a) {
      CG === null ? CG = /* @__PURE__ */ new Set([a]) : CG.add(a);
    }
    function rO(a) {
      Fx || (Fx = !0, FN = a);
    }
    var aO = rO;
    function fE(a, s, p) {
      var y = Wy(p, s), Z = IF(a, y, Ai), X = _h(a, Z, Ai), K = kg();
      X !== null && (cr(X, Ai, K), Jd(X, K));
    }
    function po(a, s, p) {
      if (QD(p), IZ(!1), a.tag === b) {
        fE(a, a, p);
        return;
      }
      var y = null;
      for (y = s; y !== null; ) {
        if (y.tag === b) {
          fE(y, a, p);
          return;
        } else if (y.tag === f) {
          var Z = y.type, X = y.stateNode;
          if (typeof Z.getDerivedStateFromError == "function" || typeof X.componentDidCatch == "function" && !hE(X)) {
            var K = Wy(p, a), Q = dN(y, K, Ai), te = _h(y, Q, Ai), ce = kg();
            te !== null && (cr(te, Ai, ce), Jd(te, ce));
            return;
          }
        }
        y = y.return;
      }
      u(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, p);
    }
    function oO(a, s, p) {
      var y = a.pingCache;
      y !== null && y.delete(s);
      var Z = kg();
      pr(a, p), hO(a), Lg === a && ot(uu, p) && (cu === iZ || cu === Hx && k(uu) && Ya() - YN < nE ? Hy(a, Ht) : Yx = Fe(Yx, p)), Jd(a, Z);
    }
    function pE(a, s) {
      s === Fa && (s = _U(a));
      var p = kg(), y = fc(a, s);
      y !== null && (cr(y, s, p), Jd(y, p));
    }
    function sO(a) {
      var s = a.memoizedState, p = Fa;
      s !== null && (p = s.retryLane), pE(a, p);
    }
    function lO(a, s) {
      var p = Fa, y;
      switch (a.tag) {
        case D:
          y = a.stateNode;
          var Z = a.memoizedState;
          Z !== null && (p = Z.retryLane);
          break;
        case he:
          y = a.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      y !== null && y.delete(s), pE(a, p);
    }
    function uO(a) {
      return a < 120 ? 120 : a < 480 ? 480 : a < 1080 ? 1080 : a < 1920 ? 1920 : a < 3e3 ? 3e3 : a < 4320 ? 4320 : YU(a / 1960) * 1960;
    }
    function cO() {
      if (uZ > EU)
        throw uZ = 0, _N = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      hG > TU && (hG = 0, Tx = null, u("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function gO() {
      Kd.flushLegacyContextWarning(), Kd.flushPendingUnsafeLifecycleWarnings();
    }
    function mE(a, s) {
      Lr(a), kx(a, Ua, WU), s && kx(a, Wi, VU), kx(a, Ua, RU), s && kx(a, Wi, xU), Ra();
    }
    function kx(a, s, p) {
      for (var y = a, Z = null; y !== null; ) {
        var X = y.subtreeFlags & s;
        y !== Z && y.child !== null && X !== Nn ? y = y.child : ((y.flags & s) !== Nn && p(y), y.sibling !== null ? y = y.sibling : y = Z = y.return);
      }
    }
    var Dx = null;
    function AE(a) {
      {
        if ((Fr & Bc) !== lu || !(a.mode & Oi))
          return;
        var s = a.tag;
        if (s !== v && s !== b && s !== f && s !== C && s !== T && s !== L && s !== j)
          return;
        var p = xi(a) || "ReactComponent";
        if (Dx !== null) {
          if (Dx.has(p))
            return;
          Dx.add(p);
        } else
          Dx = /* @__PURE__ */ new Set([p]);
        var y = Po;
        try {
          Lr(a), u("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          y ? Lr(a) : Ra();
        }
      }
    }
    var UN;
    {
      var dO = null;
      UN = function(a, s, p) {
        var y = wE(dO, s);
        try {
          return NF(a, s, p);
        } catch (X) {
          if (ex() || X !== null && typeof X == "object" && typeof X.then == "function")
            throw X;
          if (dm(), hx(), EF(a, s), wE(s, y), s.mode & ir && Ct(s), ka(null, NF, null, a, s, p), $u()) {
            var Z = wu();
            typeof Z == "object" && Z !== null && Z._suppressLogging && typeof X == "object" && X !== null && !X._suppressLogging && (X._suppressLogging = !0);
          }
          throw X;
        }
      };
    }
    var vE = !1, ON;
    ON = /* @__PURE__ */ new Set();
    function IO(a) {
      if (Gs && !vx())
        switch (a.tag) {
          case C:
          case T:
          case j: {
            var s = ms && xi(ms) || "Unknown", p = s;
            if (!ON.has(p)) {
              ON.add(p);
              var y = xi(a) || "Unknown";
              u("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", y, s, s);
            }
            break;
          }
          case f: {
            vE || (u("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), vE = !0);
            break;
          }
        }
    }
    function dZ(a, s) {
      if (_o) {
        var p = a.memoizedUpdaters;
        p.forEach(function(y) {
          tA(a, y, s);
        });
      }
    }
    var PN = {};
    function JN(a, s) {
      {
        var p = Uh.current;
        return p !== null ? (p.push(s), PN) : bd(a, s);
      }
    }
    function yE(a) {
      if (a !== PN)
        return wl(a);
    }
    function bE() {
      return Uh.current !== null;
    }
    function CO(a) {
      {
        if (a.mode & Oi) {
          if (!$F())
            return;
        } else if (!XU() || Fr !== lu || a.tag !== C && a.tag !== T && a.tag !== j)
          return;
        if (Uh.current === null) {
          var s = Po;
          try {
            Lr(a), u(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, xi(a));
          } finally {
            s ? Lr(a) : Ra();
          }
        }
      }
    }
    function hO(a) {
      a.tag !== Xh && $F() && Uh.current === null && u(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function IZ(a) {
      aE = a;
    }
    var kC = null, fG = null, fO = function(a) {
      kC = a;
    };
    function pG(a) {
      {
        if (kC === null)
          return a;
        var s = kC(a);
        return s === void 0 ? a : s.current;
      }
    }
    function QN(a) {
      return pG(a);
    }
    function jN(a) {
      {
        if (kC === null)
          return a;
        var s = kC(a);
        if (s === void 0) {
          if (a != null && typeof a.render == "function") {
            var p = pG(a.render);
            if (a.render !== p) {
              var y = {
                $$typeof: tt,
                render: p
              };
              return a.displayName !== void 0 && (y.displayName = a.displayName), y;
            }
          }
          return a;
        }
        return s.current;
      }
    }
    function GE(a, s) {
      {
        if (kC === null)
          return !1;
        var p = a.elementType, y = s.type, Z = !1, X = typeof y == "object" && y !== null ? y.$$typeof : null;
        switch (a.tag) {
          case f: {
            typeof y == "function" && (Z = !0);
            break;
          }
          case C: {
            (typeof y == "function" || X === ae) && (Z = !0);
            break;
          }
          case T: {
            (X === tt || X === ae) && (Z = !0);
            break;
          }
          case L:
          case j: {
            (X === vn || X === ae) && (Z = !0);
            break;
          }
          default:
            return !1;
        }
        if (Z) {
          var K = kC(p);
          if (K !== void 0 && K === kC(y))
            return !0;
        }
        return !1;
      }
    }
    function BE(a) {
      {
        if (kC === null || typeof WeakSet != "function")
          return;
        fG === null && (fG = /* @__PURE__ */ new WeakSet()), fG.add(a);
      }
    }
    var pO = function(a, s) {
      {
        if (kC === null)
          return;
        var p = s.staleFamilies, y = s.updatedFamilies;
        Sm(), Bm(function() {
          qN(a.current, y, p);
        });
      }
    }, mO = function(a, s) {
      {
        if (a.context !== Jc)
          return;
        Sm(), Bm(function() {
          CZ(s, a, null, null);
        });
      }
    };
    function qN(a, s, p) {
      {
        var y = a.alternate, Z = a.child, X = a.sibling, K = a.tag, Q = a.type, te = null;
        switch (K) {
          case C:
          case j:
          case f:
            te = Q;
            break;
          case T:
            te = Q.render;
            break;
        }
        if (kC === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var ce = !1, Ce = !1;
        if (te !== null) {
          var Qe = kC(te);
          Qe !== void 0 && (p.has(Qe) ? Ce = !0 : s.has(Qe) && (K === f ? Ce = !0 : ce = !0));
        }
        if (fG !== null && (fG.has(a) || y !== null && fG.has(y)) && (Ce = !0), Ce && (a._debugNeedsRemount = !0), Ce || ce) {
          var Pe = fc(a, Ai);
          Pe !== null && gu(Pe, a, Ai, Nr);
        }
        Z !== null && !Ce && qN(Z, s, p), X !== null && qN(X, s, p);
      }
    }
    var AO = function(a, s) {
      {
        var p = /* @__PURE__ */ new Set(), y = new Set(s.map(function(Z) {
          return Z.current;
        }));
        return $N(a.current, y, p), p;
      }
    };
    function $N(a, s, p) {
      {
        var y = a.child, Z = a.sibling, X = a.tag, K = a.type, Q = null;
        switch (X) {
          case C:
          case j:
          case f:
            Q = K;
            break;
          case T:
            Q = K.render;
            break;
        }
        var te = !1;
        Q !== null && s.has(Q) && (te = !0), te ? vO(a, p) : y !== null && $N(y, s, p), Z !== null && $N(Z, s, p);
      }
    }
    function vO(a, s) {
      {
        var p = yO(a, s);
        if (p)
          return;
        for (var y = a; ; ) {
          switch (y.tag) {
            case R:
              s.add(y.stateNode);
              return;
            case S:
              s.add(y.stateNode.containerInfo);
              return;
            case b:
              s.add(y.stateNode.containerInfo);
              return;
          }
          if (y.return === null)
            throw new Error("Expected to reach root first.");
          y = y.return;
        }
      }
    }
    function yO(a, s) {
      for (var p = a, y = !1; ; ) {
        if (p.tag === R)
          y = !0, s.add(p.stateNode);
        else if (p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === a)
          return y;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === a)
            return y;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
      return !1;
    }
    var eM;
    {
      eM = !1;
      try {
        var SE = Object.preventExtensions({});
      } catch {
        eM = !0;
      }
    }
    function bO(a, s, p, y) {
      this.tag = a, this.key = p, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = s, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = y, this.flags = Nn, this.subtreeFlags = Nn, this.deletions = null, this.lanes = Ht, this.childLanes = Ht, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !eM && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var TI = function(a, s, p, y) {
      return new bO(a, s, p, y);
    };
    function tM(a) {
      var s = a.prototype;
      return !!(s && s.isReactComponent);
    }
    function GO(a) {
      return typeof a == "function" && !tM(a) && a.defaultProps === void 0;
    }
    function BO(a) {
      if (typeof a == "function")
        return tM(a) ? f : C;
      if (a != null) {
        var s = a.$$typeof;
        if (s === tt)
          return T;
        if (s === vn)
          return L;
      }
      return v;
    }
    function Yy(a, s) {
      var p = a.alternate;
      p === null ? (p = TI(a.tag, s, a.key, a.mode), p.elementType = a.elementType, p.type = a.type, p.stateNode = a.stateNode, p._debugSource = a._debugSource, p._debugOwner = a._debugOwner, p._debugHookTypes = a._debugHookTypes, p.alternate = a, a.alternate = p) : (p.pendingProps = s, p.type = a.type, p.flags = Nn, p.subtreeFlags = Nn, p.deletions = null, p.actualDuration = 0, p.actualStartTime = -1), p.flags = a.flags & na, p.childLanes = a.childLanes, p.lanes = a.lanes, p.child = a.child, p.memoizedProps = a.memoizedProps, p.memoizedState = a.memoizedState, p.updateQueue = a.updateQueue;
      var y = a.dependencies;
      switch (p.dependencies = y === null ? null : {
        lanes: y.lanes,
        firstContext: y.firstContext
      }, p.sibling = a.sibling, p.index = a.index, p.ref = a.ref, p.selfBaseDuration = a.selfBaseDuration, p.treeBaseDuration = a.treeBaseDuration, p._debugNeedsRemount = a._debugNeedsRemount, p.tag) {
        case v:
        case C:
        case j:
          p.type = pG(a.type);
          break;
        case f:
          p.type = QN(a.type);
          break;
        case T:
          p.type = jN(a.type);
          break;
      }
      return p;
    }
    function SO(a, s) {
      a.flags &= na | xa;
      var p = a.alternate;
      if (p === null)
        a.childLanes = Ht, a.lanes = s, a.child = null, a.subtreeFlags = Nn, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null, a.selfBaseDuration = 0, a.treeBaseDuration = 0;
      else {
        a.childLanes = p.childLanes, a.lanes = p.lanes, a.child = p.child, a.subtreeFlags = Nn, a.deletions = null, a.memoizedProps = p.memoizedProps, a.memoizedState = p.memoizedState, a.updateQueue = p.updateQueue, a.type = p.type;
        var y = p.dependencies;
        a.dependencies = y === null ? null : {
          lanes: y.lanes,
          firstContext: y.firstContext
        }, a.selfBaseDuration = p.selfBaseDuration, a.treeBaseDuration = p.treeBaseDuration;
      }
      return a;
    }
    function ZO(a, s, p) {
      var y;
      return a === ZA ? (y = Oi, s === !0 && (y |= Xi, y |= Xr)) : y = si, _o && (y |= ir), TI(b, null, null, y);
    }
    function nM(a, s, p, y, Z, X) {
      var K = v, Q = a;
      if (typeof a == "function")
        tM(a) ? (K = f, Q = QN(Q)) : Q = pG(Q);
      else if (typeof a == "string")
        K = R;
      else
        e: switch (a) {
          case Et:
            return $A(p.children, Z, X, s);
          case gn:
            K = N, Z |= Xi, (Z & Oi) !== si && (Z |= Xr);
            break;
          case Vn:
            return wO(p, Z, X, s);
          case At:
            return RO(p, Z, X, s);
          case Gt:
            return xO(p, Z, X, s);
          case De:
            return ZE(p, Z, X, s);
          case Ee:
          // eslint-disable-next-line no-fallthrough
          case Ne:
          // eslint-disable-next-line no-fallthrough
          case Tt:
          // eslint-disable-next-line no-fallthrough
          case tn:
          // eslint-disable-next-line no-fallthrough
          case Te:
          // eslint-disable-next-line no-fallthrough
          default: {
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case Ln:
                  K = F;
                  break e;
                case Ie:
                  K = Y;
                  break e;
                case tt:
                  K = T, Q = jN(Q);
                  break e;
                case vn:
                  K = L;
                  break e;
                case ae:
                  K = J, Q = null;
                  break e;
              }
            var te = "";
            {
              (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (te += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var ce = y ? xi(y) : null;
              ce && (te += `

Check the render method of \`` + ce + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (a == null ? a : typeof a) + "." + te));
          }
        }
      var Ce = TI(K, p, s, Z);
      return Ce.elementType = a, Ce.type = Q, Ce.lanes = X, Ce._debugOwner = y, Ce;
    }
    function iM(a, s, p) {
      var y = null;
      y = a._owner;
      var Z = a.type, X = a.key, K = a.props, Q = nM(Z, X, K, y, s, p);
      return Q._debugSource = a._source, Q._debugOwner = a._owner, Q;
    }
    function $A(a, s, p, y) {
      var Z = TI(x, a, y, s);
      return Z.lanes = p, Z;
    }
    function wO(a, s, p, y) {
      typeof a.id != "string" && u('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof a.id);
      var Z = TI(P, a, y, s | ir);
      return Z.elementType = Vn, Z.lanes = p, Z.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, Z;
    }
    function RO(a, s, p, y) {
      var Z = TI(D, a, y, s);
      return Z.elementType = At, Z.lanes = p, Z;
    }
    function xO(a, s, p, y) {
      var Z = TI(he, a, y, s);
      return Z.elementType = Gt, Z.lanes = p, Z;
    }
    function ZE(a, s, p, y) {
      var Z = TI(Ae, a, y, s);
      Z.elementType = De, Z.lanes = p;
      var X = {
        isHidden: !1
      };
      return Z.stateNode = X, Z;
    }
    function rM(a, s, p) {
      var y = TI(W, a, null, s);
      return y.lanes = p, y;
    }
    function WO() {
      var a = TI(R, null, null, si);
      return a.elementType = "DELETED", a;
    }
    function VO(a) {
      var s = TI(ne, null, null, si);
      return s.stateNode = a, s;
    }
    function aM(a, s, p) {
      var y = a.children !== null ? a.children : [], Z = TI(S, y, a.key, s);
      return Z.lanes = p, Z.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: a.implementation
      }, Z;
    }
    function wE(a, s) {
      return a === null && (a = TI(v, null, null, si)), a.tag = s.tag, a.key = s.key, a.elementType = s.elementType, a.type = s.type, a.stateNode = s.stateNode, a.return = s.return, a.child = s.child, a.sibling = s.sibling, a.index = s.index, a.ref = s.ref, a.pendingProps = s.pendingProps, a.memoizedProps = s.memoizedProps, a.updateQueue = s.updateQueue, a.memoizedState = s.memoizedState, a.dependencies = s.dependencies, a.mode = s.mode, a.flags = s.flags, a.subtreeFlags = s.subtreeFlags, a.deletions = s.deletions, a.lanes = s.lanes, a.childLanes = s.childLanes, a.alternate = s.alternate, a.actualDuration = s.actualDuration, a.actualStartTime = s.actualStartTime, a.selfBaseDuration = s.selfBaseDuration, a.treeBaseDuration = s.treeBaseDuration, a._debugSource = s._debugSource, a._debugOwner = s._debugOwner, a._debugNeedsRemount = s._debugNeedsRemount, a._debugHookTypes = s._debugHookTypes, a;
    }
    function NO(a, s, p, y, Z) {
      this.tag = s, this.containerInfo = a, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = yA, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Fa, this.eventTimes = Vi(Ht), this.expirationTimes = Vi(Nr), this.pendingLanes = Ht, this.suspendedLanes = Ht, this.pingedLanes = Ht, this.expiredLanes = Ht, this.mutableReadLanes = Ht, this.finishedLanes = Ht, this.entangledLanes = Ht, this.entanglements = Vi(Ht), this.identifierPrefix = y, this.onRecoverableError = Z, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var X = this.pendingUpdatersLaneMap = [], K = 0; K < jo; K++)
          X.push(/* @__PURE__ */ new Set());
      }
      switch (s) {
        case ZA:
          this._debugRootType = p ? "hydrateRoot()" : "createRoot()";
          break;
        case Xh:
          this._debugRootType = p ? "hydrate()" : "render()";
          break;
      }
    }
    function RE(a, s, p, y, Z, X, K, Q, te, ce) {
      var Ce = new NO(a, s, p, Q, te), Qe = ZO(s, X);
      Ce.current = Qe, Qe.stateNode = Ce;
      {
        var Pe = {
          element: y,
          isDehydrated: p,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        Qe.memoizedState = Pe;
      }
      return Th(Qe), Ce;
    }
    var oM = "18.3.1";
    function MO(a, s, p) {
      var y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return en(y), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: rt,
        key: y == null ? null : "" + y,
        children: a,
        containerInfo: s,
        implementation: p
      };
    }
    var sM, lM;
    sM = !1, lM = {};
    function xE(a) {
      if (!a)
        return Jc;
      var s = Bo(a), p = OV(s);
      if (s.tag === f) {
        var y = s.type;
        if (NC(y))
          return QR(s, y, p);
      }
      return p;
    }
    function HO(a, s) {
      {
        var p = Bo(a);
        if (p === void 0) {
          if (typeof a.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var y = Object.keys(a).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + y);
        }
        var Z = Za(p);
        if (Z === null)
          return null;
        if (Z.mode & Xi) {
          var X = xi(p) || "Component";
          if (!lM[X]) {
            lM[X] = !0;
            var K = Po;
            try {
              Lr(Z), p.mode & Xi ? u("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", s, s, X) : u("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", s, s, X);
            } finally {
              K ? Lr(K) : Ra();
            }
          }
        }
        return Z.stateNode;
      }
    }
    function WE(a, s, p, y, Z, X, K, Q) {
      var te = !1, ce = null;
      return RE(a, s, te, ce, p, y, Z, X, K);
    }
    function VE(a, s, p, y, Z, X, K, Q, te, ce) {
      var Ce = !0, Qe = RE(p, y, Ce, a, Z, X, K, Q, te);
      Qe.context = xE(null);
      var Pe = Qe.current, pt = kg(), yt = jA(Pe), Yt = FC(pt, yt);
      return Yt.callback = s ?? null, _h(Pe, Yt, yt), zU(Qe, yt, pt), Qe;
    }
    function CZ(a, s, p, y) {
      Vu(s, a);
      var Z = s.current, X = kg(), K = jA(Z);
      rc(K);
      var Q = xE(p);
      s.context === null ? s.context = Q : s.pendingContext = Q, Gs && Po !== null && !sM && (sM = !0, u(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, xi(Po) || "Unknown"));
      var te = FC(X, K);
      te.payload = {
        element: a
      }, y = y === void 0 ? null : y, y !== null && (typeof y != "function" && u("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", y), te.callback = y);
      var ce = _h(Z, te, K);
      return ce !== null && (gu(ce, Z, K, X), z0(ce, Z, K)), K;
    }
    function Ux(a) {
      var s = a.current;
      if (!s.child)
        return null;
      switch (s.child.tag) {
        case R:
          return s.child.stateNode;
        default:
          return s.child.stateNode;
      }
    }
    function XO(a) {
      switch (a.tag) {
        case b: {
          var s = a.stateNode;
          if (IC(s)) {
            var p = m(s);
            DU(s, p);
          }
          break;
        }
        case D: {
          Bm(function() {
            var Z = fc(a, Ai);
            if (Z !== null) {
              var X = kg();
              gu(Z, a, Ai, X);
            }
          });
          var y = Ai;
          uM(a, y);
          break;
        }
      }
    }
    function NE(a, s) {
      var p = a.memoizedState;
      p !== null && p.dehydrated !== null && (p.retryLane = Ki(p.retryLane, s));
    }
    function uM(a, s) {
      NE(a, s);
      var p = a.alternate;
      p && NE(p, s);
    }
    function YO(a) {
      if (a.tag === D) {
        var s = xl, p = fc(a, s);
        if (p !== null) {
          var y = kg();
          gu(p, a, s, y);
        }
        uM(a, s);
      }
    }
    function FO(a) {
      if (a.tag === D) {
        var s = jA(a), p = fc(a, s);
        if (p !== null) {
          var y = kg();
          gu(p, a, s, y);
        }
        uM(a, s);
      }
    }
    function ME(a) {
      var s = Ws(a);
      return s === null ? null : s.stateNode;
    }
    var HE = function(a) {
      return null;
    };
    function EO(a) {
      return HE(a);
    }
    var XE = function(a) {
      return !1;
    };
    function TO(a) {
      return XE(a);
    }
    var YE = null, FE = null, EE = null, TE = null, _E = null, zE = null, KE = null, LE = null, kE = null;
    {
      var DE = function(a, s, p) {
        var y = s[p], Z = Zi(a) ? a.slice() : rn({}, a);
        return p + 1 === s.length ? (Zi(Z) ? Z.splice(y, 1) : delete Z[y], Z) : (Z[y] = DE(a[y], s, p + 1), Z);
      }, UE = function(a, s) {
        return DE(a, s, 0);
      }, OE = function(a, s, p, y) {
        var Z = s[y], X = Zi(a) ? a.slice() : rn({}, a);
        if (y + 1 === s.length) {
          var K = p[y];
          X[K] = X[Z], Zi(X) ? X.splice(Z, 1) : delete X[Z];
        } else
          X[Z] = OE(
            // $FlowFixMe number or string is fine here
            a[Z],
            s,
            p,
            y + 1
          );
        return X;
      }, PE = function(a, s, p) {
        if (s.length !== p.length) {
          l("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var y = 0; y < p.length - 1; y++)
            if (s[y] !== p[y]) {
              l("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return OE(a, s, p, 0);
      }, JE = function(a, s, p, y) {
        if (p >= s.length)
          return y;
        var Z = s[p], X = Zi(a) ? a.slice() : rn({}, a);
        return X[Z] = JE(a[Z], s, p + 1, y), X;
      }, QE = function(a, s, p) {
        return JE(a, s, 0, p);
      }, cM = function(a, s) {
        for (var p = a.memoizedState; p !== null && s > 0; )
          p = p.next, s--;
        return p;
      };
      YE = function(a, s, p, y) {
        var Z = cM(a, s);
        if (Z !== null) {
          var X = QE(Z.memoizedState, p, y);
          Z.memoizedState = X, Z.baseState = X, a.memoizedProps = rn({}, a.memoizedProps);
          var K = fc(a, Ai);
          K !== null && gu(K, a, Ai, Nr);
        }
      }, FE = function(a, s, p) {
        var y = cM(a, s);
        if (y !== null) {
          var Z = UE(y.memoizedState, p);
          y.memoizedState = Z, y.baseState = Z, a.memoizedProps = rn({}, a.memoizedProps);
          var X = fc(a, Ai);
          X !== null && gu(X, a, Ai, Nr);
        }
      }, EE = function(a, s, p, y) {
        var Z = cM(a, s);
        if (Z !== null) {
          var X = PE(Z.memoizedState, p, y);
          Z.memoizedState = X, Z.baseState = X, a.memoizedProps = rn({}, a.memoizedProps);
          var K = fc(a, Ai);
          K !== null && gu(K, a, Ai, Nr);
        }
      }, TE = function(a, s, p) {
        a.pendingProps = QE(a.memoizedProps, s, p), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var y = fc(a, Ai);
        y !== null && gu(y, a, Ai, Nr);
      }, _E = function(a, s) {
        a.pendingProps = UE(a.memoizedProps, s), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var p = fc(a, Ai);
        p !== null && gu(p, a, Ai, Nr);
      }, zE = function(a, s, p) {
        a.pendingProps = PE(a.memoizedProps, s, p), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var y = fc(a, Ai);
        y !== null && gu(y, a, Ai, Nr);
      }, KE = function(a) {
        var s = fc(a, Ai);
        s !== null && gu(s, a, Ai, Nr);
      }, LE = function(a) {
        HE = a;
      }, kE = function(a) {
        XE = a;
      };
    }
    function _O(a) {
      var s = Za(a);
      return s === null ? null : s.stateNode;
    }
    function zO(a) {
      return null;
    }
    function KO() {
      return Po;
    }
    function LO(a) {
      var s = a.findFiberByHostInstance, p = n.ReactCurrentDispatcher;
      return lC({
        bundleType: a.bundleType,
        version: a.version,
        rendererPackageName: a.rendererPackageName,
        rendererConfig: a.rendererConfig,
        overrideHookState: YE,
        overrideHookStateDeletePath: FE,
        overrideHookStateRenamePath: EE,
        overrideProps: TE,
        overridePropsDeletePath: _E,
        overridePropsRenamePath: zE,
        setErrorHandler: LE,
        setSuspenseHandler: kE,
        scheduleUpdate: KE,
        currentDispatcherRef: p,
        findHostInstanceByFiber: _O,
        findFiberByHostInstance: s || zO,
        // React Refresh
        findHostInstancesForRefresh: AO,
        scheduleRefresh: pO,
        scheduleRoot: mO,
        setRefreshHandler: fO,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: KO,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: oM
      });
    }
    var jE = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(a) {
      console.error(a);
    };
    function gM(a) {
      this._internalRoot = a;
    }
    Ox.prototype.render = gM.prototype.render = function(a) {
      var s = this._internalRoot;
      if (s === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? u("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Px(arguments[1]) ? u("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && u("You passed a second argument to root.render(...) but it only accepts one argument.");
        var p = s.containerInfo;
        if (p.nodeType !== ha) {
          var y = ME(s.current);
          y && y.parentNode !== p && u("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      CZ(a, s, null, null);
    }, Ox.prototype.unmount = gM.prototype.unmount = function() {
      typeof arguments[0] == "function" && u("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var a = this._internalRoot;
      if (a !== null) {
        this._internalRoot = null;
        var s = a.containerInfo;
        uE() && u("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Bm(function() {
          CZ(null, a, null, null);
        }), UR(s);
      }
    };
    function kO(a, s) {
      if (!Px(a))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      qE(a);
      var p = !1, y = !1, Z = "", X = jE;
      s != null && (s.hydrate ? l("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof s == "object" && s !== null && s.$$typeof === Oe && u(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), s.unstable_strictMode === !0 && (p = !0), s.identifierPrefix !== void 0 && (Z = s.identifierPrefix), s.onRecoverableError !== void 0 && (X = s.onRecoverableError), s.transitionCallbacks !== void 0 && s.transitionCallbacks);
      var K = WE(a, ZA, null, p, y, Z, X);
      v0(K.current, a);
      var Q = a.nodeType === ha ? a.parentNode : a;
      return Mf(Q), new gM(K);
    }
    function Ox(a) {
      this._internalRoot = a;
    }
    function DO(a) {
      a && Kb(a);
    }
    Ox.prototype.unstable_scheduleHydration = DO;
    function UO(a, s, p) {
      if (!Px(a))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      qE(a), s === void 0 && u("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var y = p ?? null, Z = p != null && p.hydratedSources || null, X = !1, K = !1, Q = "", te = jE;
      p != null && (p.unstable_strictMode === !0 && (X = !0), p.identifierPrefix !== void 0 && (Q = p.identifierPrefix), p.onRecoverableError !== void 0 && (te = p.onRecoverableError));
      var ce = VE(s, null, a, ZA, y, X, K, Q, te);
      if (v0(ce.current, a), Mf(a), Z)
        for (var Ce = 0; Ce < Z.length; Ce++) {
          var Qe = Z[Ce];
          py(ce, Qe);
        }
      return new Ox(ce);
    }
    function Px(a) {
      return !!(a && (a.nodeType === vo || a.nodeType === yu || a.nodeType === Jo));
    }
    function hZ(a) {
      return !!(a && (a.nodeType === vo || a.nodeType === yu || a.nodeType === Jo || a.nodeType === ha && a.nodeValue === " react-mount-point-unstable "));
    }
    function qE(a) {
      a.nodeType === vo && a.tagName && a.tagName.toUpperCase() === "BODY" && u("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), iy(a) && (a._reactRootContainer ? u("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : u("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var OO = n.ReactCurrentOwner, $E;
    $E = function(a) {
      if (a._reactRootContainer && a.nodeType !== ha) {
        var s = ME(a._reactRootContainer.current);
        s && s.parentNode !== a && u("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var p = !!a._reactRootContainer, y = dM(a), Z = !!(y && Cs(y));
      Z && !p && u("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), a.nodeType === vo && a.tagName && a.tagName.toUpperCase() === "BODY" && u("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function dM(a) {
      return a ? a.nodeType === yu ? a.documentElement : a.firstChild : null;
    }
    function eT() {
    }
    function PO(a, s, p, y, Z) {
      if (Z) {
        if (typeof y == "function") {
          var X = y;
          y = function() {
            var Pe = Ux(K);
            X.call(Pe);
          };
        }
        var K = VE(
          s,
          y,
          a,
          Xh,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          eT
        );
        a._reactRootContainer = K, v0(K.current, a);
        var Q = a.nodeType === ha ? a.parentNode : a;
        return Mf(Q), Bm(), K;
      } else {
        for (var te; te = a.lastChild; )
          a.removeChild(te);
        if (typeof y == "function") {
          var ce = y;
          y = function() {
            var Pe = Ux(Ce);
            ce.call(Pe);
          };
        }
        var Ce = WE(
          a,
          Xh,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          eT
        );
        a._reactRootContainer = Ce, v0(Ce.current, a);
        var Qe = a.nodeType === ha ? a.parentNode : a;
        return Mf(Qe), Bm(function() {
          CZ(s, Ce, p, y);
        }), Ce;
      }
    }
    function JO(a, s) {
      a !== null && typeof a != "function" && u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s, a);
    }
    function Jx(a, s, p, y, Z) {
      $E(p), JO(Z === void 0 ? null : Z, "render");
      var X = p._reactRootContainer, K;
      if (!X)
        K = PO(p, s, a, Z, y);
      else {
        if (K = X, typeof Z == "function") {
          var Q = Z;
          Z = function() {
            var te = Ux(K);
            Q.call(te);
          };
        }
        CZ(s, K, a, Z);
      }
      return Ux(K);
    }
    var tT = !1;
    function QO(a) {
      {
        tT || (tT = !0, u("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var s = OO.current;
        if (s !== null && s.stateNode !== null) {
          var p = s.stateNode._warnedAboutRefsInRender;
          p || u("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Hi(s.type) || "A component"), s.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return a == null ? null : a.nodeType === vo ? a : HO(a, "findDOMNode");
    }
    function jO(a, s, p) {
      if (u("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !hZ(s))
        throw new Error("Target container is not a DOM element.");
      {
        var y = iy(s) && s._reactRootContainer === void 0;
        y && u("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return Jx(null, a, s, !0, p);
    }
    function qO(a, s, p) {
      if (u("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !hZ(s))
        throw new Error("Target container is not a DOM element.");
      {
        var y = iy(s) && s._reactRootContainer === void 0;
        y && u("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return Jx(null, a, s, !1, p);
    }
    function $O(a, s, p, y) {
      if (u("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !hZ(p))
        throw new Error("Target container is not a DOM element.");
      if (a == null || !yd(a))
        throw new Error("parentComponent must be a valid React Component");
      return Jx(a, s, p, !1, y);
    }
    var nT = !1;
    function eP(a) {
      if (nT || (nT = !0, u("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !hZ(a))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var s = iy(a) && a._reactRootContainer === void 0;
        s && u("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (a._reactRootContainer) {
        {
          var p = dM(a), y = p && !Cs(p);
          y && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Bm(function() {
          Jx(null, null, a, !1, function() {
            a._reactRootContainer = null, UR(a);
          });
        }), !0;
      } else {
        {
          var Z = dM(a), X = !!(Z && Cs(Z)), K = a.nodeType === vo && hZ(a.parentNode) && !!a.parentNode._reactRootContainer;
          X && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", K ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Tb(XO), aA(YO), HB(FO), xI(Nl), Mp(iA), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && u("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Vc(jv), ch(LN, UU, Bm);
    function tP(a, s) {
      var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Px(s))
        throw new Error("Target container is not a DOM element.");
      return MO(a, s, null, p);
    }
    function nP(a, s, p, y) {
      return $O(a, s, p, y);
    }
    var IM = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Cs, Pc, y0, Nc, Gg, LN]
    };
    function iP(a, s) {
      return IM.usingClientEntryPoint || u('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), kO(a, s);
    }
    function rP(a, s, p) {
      return IM.usingClientEntryPoint || u('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), UO(a, s, p);
    }
    function aP(a) {
      return uE() && u("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Bm(a);
    }
    var oP = LO({
      findFiberByHostInstance: Qp,
      bundleType: 1,
      version: oM,
      rendererPackageName: "react-dom"
    });
    if (!oP && ge && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var iT = window.location.protocol;
      /^(https?|file):$/.test(iT) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (iT === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    jd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = IM, jd.createPortal = tP, jd.createRoot = iP, jd.findDOMNode = QO, jd.flushSync = aP, jd.hydrate = jO, jd.hydrateRoot = rP, jd.render = qO, jd.unmountComponentAtNode = eP, jd.unstable_batchedUpdates = LN, jd.unstable_renderSubtreeIntoContainer = nP, jd.version = oM, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(), jd;
}
var hT;
function vz() {
  if (hT) return qx.exports;
  hT = 1;
  var r = {};
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (r.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
    }
  }
  return r.NODE_ENV === "production" ? (e(), qx.exports = pP()) : qx.exports = mP(), qx.exports;
}
var fT;
function AP() {
  if (fT) return AG;
  fT = 1;
  var r = {}, e = vz();
  if (r.NODE_ENV === "production")
    AG.createRoot = e.createRoot, AG.hydrateRoot = e.hydrateRoot;
  else {
    var t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    AG.createRoot = function(n, i) {
      t.usingClientEntryPoint = !0;
      try {
        return e.createRoot(n, i);
      } finally {
        t.usingClientEntryPoint = !1;
      }
    }, AG.hydrateRoot = function(n, i, o) {
      t.usingClientEntryPoint = !0;
      try {
        return e.hydrateRoot(n, i, o);
      } finally {
        t.usingClientEntryPoint = !1;
      }
    };
  }
  return AG;
}
var vP = AP();
const yP = /* @__PURE__ */ BW(vP);
var yz = vz();
const _X = /* @__PURE__ */ BW(yz), bP = /* @__PURE__ */ mz({
  __proto__: null,
  default: _X
}, [yz]);
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function is() {
  return is = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, is.apply(this, arguments);
}
var zl;
(function(r) {
  r.Pop = "POP", r.Push = "PUSH", r.Replace = "REPLACE";
})(zl || (zl = {}));
const pT = "popstate";
function GP(r) {
  r === void 0 && (r = {});
  function e(i, o) {
    let {
      pathname: l = "/",
      search: u = "",
      hash: I = ""
    } = qm(i.location.hash.substr(1));
    return !l.startsWith("/") && !l.startsWith(".") && (l = "/" + l), Cw(
      "",
      {
        pathname: l,
        search: u,
        hash: I
      },
      // state defaults to `null` because `window.history.state` does
      o.state && o.state.usr || null,
      o.state && o.state.key || "default"
    );
  }
  function t(i, o) {
    let l = i.document.querySelector("base"), u = "";
    if (l && l.getAttribute("href")) {
      let I = i.location.href, C = I.indexOf("#");
      u = C === -1 ? I : I.slice(0, C);
    }
    return u + "#" + (typeof o == "string" ? o : vv(o));
  }
  function n(i, o) {
    fl(i.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(o) + ")");
  }
  return SP(e, t, n, r);
}
function Mi(r, e) {
  if (r === !1 || r === null || typeof r > "u")
    throw new Error(e);
}
function fl(r, e) {
  if (!r) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {
    }
  }
}
function BP() {
  return Math.random().toString(36).substr(2, 8);
}
function mT(r, e) {
  return {
    usr: r.state,
    key: r.key,
    idx: e
  };
}
function Cw(r, e, t, n) {
  return t === void 0 && (t = null), is({
    pathname: typeof r == "string" ? r : r.pathname,
    search: "",
    hash: ""
  }, typeof e == "string" ? qm(e) : e, {
    state: t,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: e && e.key || n || BP()
  });
}
function vv(r) {
  let {
    pathname: e = "/",
    search: t = "",
    hash: n = ""
  } = r;
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function qm(r) {
  let e = {};
  if (r) {
    let t = r.indexOf("#");
    t >= 0 && (e.hash = r.substr(t), r = r.substr(0, t));
    let n = r.indexOf("?");
    n >= 0 && (e.search = r.substr(n), r = r.substr(0, n)), r && (e.pathname = r);
  }
  return e;
}
function SP(r, e, t, n) {
  n === void 0 && (n = {});
  let {
    window: i = document.defaultView,
    v5Compat: o = !1
  } = n, l = i.history, u = zl.Pop, I = null, C = f();
  C == null && (C = 0, l.replaceState(is({}, l.state, {
    idx: C
  }), ""));
  function f() {
    return (l.state || {
      idx: null
    }).idx;
  }
  function v() {
    u = zl.Pop;
    let x = f(), N = x == null ? null : x - C;
    C = x, I && I({
      action: u,
      location: W.location,
      delta: N
    });
  }
  function b(x, N) {
    u = zl.Push;
    let Y = Cw(W.location, x, N);
    t && t(Y, x), C = f() + 1;
    let F = mT(Y, C), T = W.createHref(Y);
    try {
      l.pushState(F, "", T);
    } catch (P) {
      if (P instanceof DOMException && P.name === "DataCloneError")
        throw P;
      i.location.assign(T);
    }
    o && I && I({
      action: u,
      location: W.location,
      delta: 1
    });
  }
  function S(x, N) {
    u = zl.Replace;
    let Y = Cw(W.location, x, N);
    t && t(Y, x), C = f();
    let F = mT(Y, C), T = W.createHref(Y);
    l.replaceState(F, "", T), o && I && I({
      action: u,
      location: W.location,
      delta: 0
    });
  }
  function R(x) {
    let N = i.location.origin !== "null" ? i.location.origin : i.location.href, Y = typeof x == "string" ? x : vv(x);
    return Y = Y.replace(/ $/, "%20"), Mi(N, "No window.location.(origin|href) available to create URL for href: " + Y), new URL(Y, N);
  }
  let W = {
    get action() {
      return u;
    },
    get location() {
      return r(i, l);
    },
    listen(x) {
      if (I)
        throw new Error("A history only accepts one active listener");
      return i.addEventListener(pT, v), I = x, () => {
        i.removeEventListener(pT, v), I = null;
      };
    },
    createHref(x) {
      return e(i, x);
    },
    createURL: R,
    encodeLocation(x) {
      let N = R(x);
      return {
        pathname: N.pathname,
        search: N.search,
        hash: N.hash
      };
    },
    push: b,
    replace: S,
    go(x) {
      return l.go(x);
    }
  };
  return W;
}
var _a;
(function(r) {
  r.data = "data", r.deferred = "deferred", r.redirect = "redirect", r.error = "error";
})(_a || (_a = {}));
const ZP = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function wP(r) {
  return r.index === !0;
}
function v2(r, e, t, n) {
  return t === void 0 && (t = []), n === void 0 && (n = {}), r.map((i, o) => {
    let l = [...t, String(o)], u = typeof i.id == "string" ? i.id : l.join("-");
    if (Mi(i.index !== !0 || !i.children, "Cannot specify children on an index route"), Mi(!n[u], 'Found a route id collision on id "' + u + `".  Route id's must be globally unique within Data Router usages`), wP(i)) {
      let I = is({}, i, e(i), {
        id: u
      });
      return n[u] = I, I;
    } else {
      let I = is({}, i, e(i), {
        id: u,
        children: void 0
      });
      return n[u] = I, i.children && (I.children = v2(i.children, e, l, n)), I;
    }
  });
}
function ib(r, e, t) {
  return t === void 0 && (t = "/"), l2(r, e, t, !1);
}
function l2(r, e, t, n) {
  let i = typeof e == "string" ? qm(e) : e, o = tf(i.pathname || "/", t);
  if (o == null)
    return null;
  let l = bz(r);
  xP(l);
  let u = null;
  for (let I = 0; u == null && I < l.length; ++I) {
    let C = _P(o);
    u = EP(l[I], C, n);
  }
  return u;
}
function RP(r, e) {
  let {
    route: t,
    pathname: n,
    params: i
  } = r;
  return {
    id: t.id,
    pathname: n,
    params: i,
    data: e[t.id],
    handle: t.handle
  };
}
function bz(r, e, t, n) {
  e === void 0 && (e = []), t === void 0 && (t = []), n === void 0 && (n = "");
  let i = (o, l, u) => {
    let I = {
      relativePath: u === void 0 ? o.path || "" : u,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: l,
      route: o
    };
    I.relativePath.startsWith("/") && (Mi(I.relativePath.startsWith(n), 'Absolute route path "' + I.relativePath + '" nested under path ' + ('"' + n + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), I.relativePath = I.relativePath.slice(n.length));
    let C = up([n, I.relativePath]), f = t.concat(I);
    o.children && o.children.length > 0 && (Mi(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      o.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + C + '".')
    ), bz(o.children, e, f, C)), !(o.path == null && !o.index) && e.push({
      path: C,
      score: YP(C, o.index),
      routesMeta: f
    });
  };
  return r.forEach((o, l) => {
    var u;
    if (o.path === "" || !((u = o.path) != null && u.includes("?")))
      i(o, l);
    else
      for (let I of Gz(o.path))
        i(o, l, I);
  }), e;
}
function Gz(r) {
  let e = r.split("/");
  if (e.length === 0) return [];
  let [t, ...n] = e, i = t.endsWith("?"), o = t.replace(/\?$/, "");
  if (n.length === 0)
    return i ? [o, ""] : [o];
  let l = Gz(n.join("/")), u = [];
  return u.push(...l.map((I) => I === "" ? o : [o, I].join("/"))), i && u.push(...l), u.map((I) => r.startsWith("/") && I === "" ? "/" : I);
}
function xP(r) {
  r.sort((e, t) => e.score !== t.score ? t.score - e.score : FP(e.routesMeta.map((n) => n.childrenIndex), t.routesMeta.map((n) => n.childrenIndex)));
}
const WP = /^:[\w-]+$/, VP = 3, NP = 2, MP = 1, HP = 10, XP = -2, AT = (r) => r === "*";
function YP(r, e) {
  let t = r.split("/"), n = t.length;
  return t.some(AT) && (n += XP), e && (n += NP), t.filter((i) => !AT(i)).reduce((i, o) => i + (WP.test(o) ? VP : o === "" ? MP : HP), n);
}
function FP(r, e) {
  return r.length === e.length && r.slice(0, -1).every((n, i) => n === e[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    r[r.length - 1] - e[e.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function EP(r, e, t) {
  t === void 0 && (t = !1);
  let {
    routesMeta: n
  } = r, i = {}, o = "/", l = [];
  for (let u = 0; u < n.length; ++u) {
    let I = n[u], C = u === n.length - 1, f = o === "/" ? e : e.slice(o.length) || "/", v = y2({
      path: I.relativePath,
      caseSensitive: I.caseSensitive,
      end: C
    }, f), b = I.route;
    if (!v && C && t && !n[n.length - 1].route.index && (v = y2({
      path: I.relativePath,
      caseSensitive: I.caseSensitive,
      end: !1
    }, f)), !v)
      return null;
    Object.assign(i, v.params), l.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: up([o, v.pathname]),
      pathnameBase: LP(up([o, v.pathnameBase])),
      route: b
    }), v.pathnameBase !== "/" && (o = up([o, v.pathnameBase]));
  }
  return l;
}
function y2(r, e) {
  typeof r == "string" && (r = {
    path: r,
    caseSensitive: !1,
    end: !0
  });
  let [t, n] = TP(r.path, r.caseSensitive, r.end), i = e.match(t);
  if (!i) return null;
  let o = i[0], l = o.replace(/(.)\/+$/, "$1"), u = i.slice(1);
  return {
    params: n.reduce((C, f, v) => {
      let {
        paramName: b,
        isOptional: S
      } = f;
      if (b === "*") {
        let W = u[v] || "";
        l = o.slice(0, o.length - W.length).replace(/(.)\/+$/, "$1");
      }
      const R = u[v];
      return S && !R ? C[b] = void 0 : C[b] = (R || "").replace(/%2F/g, "/"), C;
    }, {}),
    pathname: o,
    pathnameBase: l,
    pattern: r
  };
}
function TP(r, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !0), fl(r === "*" || !r.endsWith("*") || r.endsWith("/*"), 'Route path "' + r + '" will be treated as if it were ' + ('"' + r.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + r.replace(/\*$/, "/*") + '".'));
  let n = [], i = "^" + r.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (l, u, I) => (n.push({
    paramName: u,
    isOptional: I != null
  }), I ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return r.endsWith("*") ? (n.push({
    paramName: "*"
  }), i += r === "*" || r === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? i += "\\/*$" : r !== "" && r !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), n];
}
function _P(r) {
  try {
    return r.split("/").map((e) => decodeURIComponent(e).replace(/\//g, "%2F")).join("/");
  } catch (e) {
    return fl(!1, 'The URL path "' + r + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), r;
  }
}
function tf(r, e) {
  if (e === "/") return r;
  if (!r.toLowerCase().startsWith(e.toLowerCase()))
    return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length, n = r.charAt(t);
  return n && n !== "/" ? null : r.slice(t) || "/";
}
function zP(r, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: n = "",
    hash: i = ""
  } = typeof r == "string" ? qm(r) : r;
  return {
    pathname: t ? t.startsWith("/") ? t : KP(t, e) : e,
    search: kP(n),
    hash: DP(i)
  };
}
function KP(r, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return r.split("/").forEach((i) => {
    i === ".." ? t.length > 1 && t.pop() : i !== "." && t.push(i);
  }), t.length > 1 ? t.join("/") : "/";
}
function fM(r, e, t, n) {
  return "Cannot include a '" + r + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(n) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function Bz(r) {
  return r.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0);
}
function SW(r, e) {
  let t = Bz(r);
  return e ? t.map((n, i) => i === t.length - 1 ? n.pathname : n.pathnameBase) : t.map((n) => n.pathnameBase);
}
function ZW(r, e, t, n) {
  n === void 0 && (n = !1);
  let i;
  typeof r == "string" ? i = qm(r) : (i = is({}, r), Mi(!i.pathname || !i.pathname.includes("?"), fM("?", "pathname", "search", i)), Mi(!i.pathname || !i.pathname.includes("#"), fM("#", "pathname", "hash", i)), Mi(!i.search || !i.search.includes("#"), fM("#", "search", "hash", i)));
  let o = r === "" || i.pathname === "", l = o ? "/" : i.pathname, u;
  if (l == null)
    u = t;
  else {
    let v = e.length - 1;
    if (!n && l.startsWith("..")) {
      let b = l.split("/");
      for (; b[0] === ".."; )
        b.shift(), v -= 1;
      i.pathname = b.join("/");
    }
    u = v >= 0 ? e[v] : "/";
  }
  let I = zP(i, u), C = l && l !== "/" && l.endsWith("/"), f = (o || l === ".") && t.endsWith("/");
  return !I.pathname.endsWith("/") && (C || f) && (I.pathname += "/"), I;
}
const up = (r) => r.join("/").replace(/\/\/+/g, "/"), LP = (r) => r.replace(/\/+$/, "").replace(/^\/*/, "/"), kP = (r) => !r || r === "?" ? "" : r.startsWith("?") ? r : "?" + r, DP = (r) => !r || r === "#" ? "" : r.startsWith("#") ? r : "#" + r;
class b2 {
  constructor(e, t, n, i) {
    i === void 0 && (i = !1), this.status = e, this.statusText = t || "", this.internal = i, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n;
  }
}
function hw(r) {
  return r != null && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.internal == "boolean" && "data" in r;
}
const Sz = ["post", "put", "patch", "delete"], UP = new Set(Sz), OP = ["get", ...Sz], PP = new Set(OP), JP = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), QP = /* @__PURE__ */ new Set([307, 308]), pM = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, jP = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, AZ = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, zX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, qP = (r) => ({
  hasErrorBoundary: !!r.hasErrorBoundary
}), Zz = "remix-router-transitions";
function $P(r) {
  const e = r.window ? r.window : typeof window < "u" ? window : void 0, t = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u", n = !t;
  Mi(r.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let i;
  if (r.mapRouteProperties)
    i = r.mapRouteProperties;
  else if (r.detectErrorBoundary) {
    let Ve = r.detectErrorBoundary;
    i = (Oe) => ({
      hasErrorBoundary: Ve(Oe)
    });
  } else
    i = qP;
  let o = {}, l = v2(r.routes, i, void 0, o), u, I = r.basename || "/", C = r.dataStrategy || iJ, f = r.patchRoutesOnNavigation, v = is({
    v7_fetcherPersist: !1,
    v7_normalizeFormMethod: !1,
    v7_partialHydration: !1,
    v7_prependBasename: !1,
    v7_relativeSplatPath: !1,
    v7_skipActionErrorRevalidation: !1
  }, r.future), b = null, S = /* @__PURE__ */ new Set(), R = null, W = null, x = null, N = r.hydrationData != null, Y = ib(l, r.history.location, I), F = !1, T = null;
  if (Y == null && !f) {
    let Ve = tI(404, {
      pathname: r.history.location.pathname
    }), {
      matches: Oe,
      route: rt
    } = WT(l);
    Y = Oe, T = {
      [rt.id]: Ve
    };
  }
  Y && !r.hydrationData && Ii(Y, l, r.history.location.pathname).active && (Y = null);
  let P;
  if (Y)
    if (Y.some((Ve) => Ve.route.lazy))
      P = !1;
    else if (!Y.some((Ve) => Ve.route.loader))
      P = !0;
    else if (v.v7_partialHydration) {
      let Ve = r.hydrationData ? r.hydrationData.loaderData : null, Oe = r.hydrationData ? r.hydrationData.errors : null;
      if (Oe) {
        let rt = Y.findIndex((Et) => Oe[Et.route.id] !== void 0);
        P = Y.slice(0, rt + 1).every((Et) => !TH(Et.route, Ve, Oe));
      } else
        P = Y.every((rt) => !TH(rt.route, Ve, Oe));
    } else
      P = r.hydrationData != null;
  else if (P = !1, Y = [], v.v7_partialHydration) {
    let Ve = Ii(null, l, r.history.location.pathname);
    Ve.active && Ve.matches && (F = !0, Y = Ve.matches);
  }
  let D, L = {
    historyAction: r.history.action,
    location: r.history.location,
    matches: Y,
    initialized: P,
    navigation: pM,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: r.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: r.hydrationData && r.hydrationData.loaderData || {},
    actionData: r.hydrationData && r.hydrationData.actionData || null,
    errors: r.hydrationData && r.hydrationData.errors || T,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, j = zl.Pop, J = !1, O, ne = !1, he = /* @__PURE__ */ new Map(), pe = null, Ae = !1, ke = !1, Re = [], Xe = /* @__PURE__ */ new Set(), re = /* @__PURE__ */ new Map(), Se = 0, Be = -1, le = /* @__PURE__ */ new Map(), Ye = /* @__PURE__ */ new Set(), nt = /* @__PURE__ */ new Map(), ze = /* @__PURE__ */ new Map(), Je = /* @__PURE__ */ new Set(), wt = /* @__PURE__ */ new Map(), mt = /* @__PURE__ */ new Map(), Dt;
  function mn() {
    if (b = r.history.listen((Ve) => {
      let {
        action: Oe,
        location: rt,
        delta: Et
      } = Ve;
      if (Dt) {
        Dt(), Dt = void 0;
        return;
      }
      fl(mt.size === 0 || Et != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let gn = je({
        currentLocation: L.location,
        nextLocation: rt,
        historyAction: Oe
      });
      if (gn && Et != null) {
        let Vn = new Promise((Ln) => {
          Dt = Ln;
        });
        r.history.go(Et * -1), it(gn, {
          state: "blocked",
          location: rt,
          proceed() {
            it(gn, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: rt
            }), Vn.then(() => r.history.go(Et));
          },
          reset() {
            let Ln = new Map(L.blockers);
            Ln.set(gn, AZ), ge({
              blockers: Ln
            });
          }
        });
        return;
      }
      return ft(Oe, rt);
    }), t) {
      pJ(e, he);
      let Ve = () => mJ(e, he);
      e.addEventListener("pagehide", Ve), pe = () => e.removeEventListener("pagehide", Ve);
    }
    return L.initialized || ft(zl.Pop, L.location, {
      initialHydration: !0
    }), D;
  }
  function An() {
    b && b(), pe && pe(), S.clear(), O && O.abort(), L.fetchers.forEach((Ve, Oe) => He(Oe)), L.blockers.forEach((Ve, Oe) => de(Oe));
  }
  function Hn(Ve) {
    return S.add(Ve), () => S.delete(Ve);
  }
  function ge(Ve, Oe) {
    Oe === void 0 && (Oe = {}), L = is({}, L, Ve);
    let rt = [], Et = [];
    v.v7_fetcherPersist && L.fetchers.forEach((gn, Vn) => {
      gn.state === "idle" && (Je.has(Vn) ? Et.push(Vn) : rt.push(Vn));
    }), Je.forEach((gn) => {
      !L.fetchers.has(gn) && !re.has(gn) && Et.push(gn);
    }), [...S].forEach((gn) => gn(L, {
      deletedFetchers: Et,
      viewTransitionOpts: Oe.viewTransitionOpts,
      flushSync: Oe.flushSync === !0
    })), v.v7_fetcherPersist ? (rt.forEach((gn) => L.fetchers.delete(gn)), Et.forEach((gn) => He(gn))) : Et.forEach((gn) => Je.delete(gn));
  }
  function Wt(Ve, Oe, rt) {
    var Et, gn;
    let {
      flushSync: Vn
    } = rt === void 0 ? {} : rt, Ln = L.actionData != null && L.navigation.formMethod != null && $h(L.navigation.formMethod) && L.navigation.state === "loading" && ((Et = Ve.state) == null ? void 0 : Et._isRedirect) !== !0, Ie;
    Oe.actionData ? Object.keys(Oe.actionData).length > 0 ? Ie = Oe.actionData : Ie = null : Ln ? Ie = L.actionData : Ie = null;
    let tt = Oe.loaderData ? RT(L.loaderData, Oe.loaderData, Oe.matches || [], Oe.errors) : L.loaderData, At = L.blockers;
    At.size > 0 && (At = new Map(At), At.forEach((ae, Ne) => At.set(Ne, AZ)));
    let Gt = J === !0 || L.navigation.formMethod != null && $h(L.navigation.formMethod) && ((gn = Ve.state) == null ? void 0 : gn._isRedirect) !== !0;
    u && (l = u, u = void 0), Ae || j === zl.Pop || (j === zl.Push ? r.history.push(Ve, Ve.state) : j === zl.Replace && r.history.replace(Ve, Ve.state));
    let vn;
    if (j === zl.Pop) {
      let ae = he.get(L.location.pathname);
      ae && ae.has(Ve.pathname) ? vn = {
        currentLocation: L.location,
        nextLocation: Ve
      } : he.has(Ve.pathname) && (vn = {
        currentLocation: Ve,
        nextLocation: L.location
      });
    } else if (ne) {
      let ae = he.get(L.location.pathname);
      ae ? ae.add(Ve.pathname) : (ae = /* @__PURE__ */ new Set([Ve.pathname]), he.set(L.location.pathname, ae)), vn = {
        currentLocation: L.location,
        nextLocation: Ve
      };
    }
    ge(is({}, Oe, {
      actionData: Ie,
      loaderData: tt,
      historyAction: j,
      location: Ve,
      initialized: !0,
      navigation: pM,
      revalidation: "idle",
      restoreScrollPosition: Jn(Ve, Oe.matches || L.matches),
      preventScrollReset: Gt,
      blockers: At
    }), {
      viewTransitionOpts: vn,
      flushSync: Vn === !0
    }), j = zl.Pop, J = !1, ne = !1, Ae = !1, ke = !1, Re = [];
  }
  async function Nt(Ve, Oe) {
    if (typeof Ve == "number") {
      r.history.go(Ve);
      return;
    }
    let rt = EH(L.location, L.matches, I, v.v7_prependBasename, Ve, v.v7_relativeSplatPath, Oe?.fromRouteId, Oe?.relative), {
      path: Et,
      submission: gn,
      error: Vn
    } = vT(v.v7_normalizeFormMethod, !1, rt, Oe), Ln = L.location, Ie = Cw(L.location, Et, Oe && Oe.state);
    Ie = is({}, Ie, r.history.encodeLocation(Ie));
    let tt = Oe && Oe.replace != null ? Oe.replace : void 0, At = zl.Push;
    tt === !0 ? At = zl.Replace : tt === !1 || gn != null && $h(gn.formMethod) && gn.formAction === L.location.pathname + L.location.search && (At = zl.Replace);
    let Gt = Oe && "preventScrollReset" in Oe ? Oe.preventScrollReset === !0 : void 0, vn = (Oe && Oe.flushSync) === !0, ae = je({
      currentLocation: Ln,
      nextLocation: Ie,
      historyAction: At
    });
    if (ae) {
      it(ae, {
        state: "blocked",
        location: Ie,
        proceed() {
          it(ae, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: Ie
          }), Nt(Ve, Oe);
        },
        reset() {
          let Ne = new Map(L.blockers);
          Ne.set(ae, AZ), ge({
            blockers: Ne
          });
        }
      });
      return;
    }
    return await ft(At, Ie, {
      submission: gn,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: Vn,
      preventScrollReset: Gt,
      replace: Oe && Oe.replace,
      enableViewTransition: Oe && Oe.viewTransition,
      flushSync: vn
    });
  }
  function $t() {
    if (jt(), ge({
      revalidation: "loading"
    }), L.navigation.state !== "submitting") {
      if (L.navigation.state === "idle") {
        ft(L.historyAction, L.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      ft(j || L.historyAction, L.navigation.location, {
        overrideNavigation: L.navigation,
        // Proxy through any rending view transition
        enableViewTransition: ne === !0
      });
    }
  }
  async function ft(Ve, Oe, rt) {
    O && O.abort(), O = null, j = Ve, Ae = (rt && rt.startUninterruptedRevalidation) === !0, Di(L.location, L.matches), J = (rt && rt.preventScrollReset) === !0, ne = (rt && rt.enableViewTransition) === !0;
    let Et = u || l, gn = rt && rt.overrideNavigation, Vn = rt != null && rt.initialHydration && L.matches && L.matches.length > 0 && !F ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      L.matches
    ) : ib(Et, Oe, I), Ln = (rt && rt.flushSync) === !0;
    if (Vn && L.initialized && !ke && uJ(L.location, Oe) && !(rt && rt.submission && $h(rt.submission.formMethod))) {
      Wt(Oe, {
        matches: Vn
      }, {
        flushSync: Ln
      });
      return;
    }
    let Ie = Ii(Vn, Et, Oe.pathname);
    if (Ie.active && Ie.matches && (Vn = Ie.matches), !Vn) {
      let {
        error: Te,
        notFoundMatches: De,
        route: Ee
      } = et(Oe.pathname);
      Wt(Oe, {
        matches: De,
        loaderData: {},
        errors: {
          [Ee.id]: Te
        }
      }, {
        flushSync: Ln
      });
      return;
    }
    O = new AbortController();
    let tt = vG(r.history, Oe, O.signal, rt && rt.submission), At;
    if (rt && rt.pendingError)
      At = [rb(Vn).route.id, {
        type: _a.error,
        error: rt.pendingError
      }];
    else if (rt && rt.submission && $h(rt.submission.formMethod)) {
      let Te = await bn(tt, Oe, rt.submission, Vn, Ie.active, {
        replace: rt.replace,
        flushSync: Ln
      });
      if (Te.shortCircuited)
        return;
      if (Te.pendingActionResult) {
        let [De, Ee] = Te.pendingActionResult;
        if (LI(Ee) && hw(Ee.error) && Ee.error.status === 404) {
          O = null, Wt(Oe, {
            matches: Te.matches,
            loaderData: {},
            errors: {
              [De]: Ee.error
            }
          });
          return;
        }
      }
      Vn = Te.matches || Vn, At = Te.pendingActionResult, gn = mM(Oe, rt.submission), Ln = !1, Ie.active = !1, tt = vG(r.history, tt.url, tt.signal);
    }
    let {
      shortCircuited: Gt,
      matches: vn,
      loaderData: ae,
      errors: Ne
    } = await en(tt, Oe, Vn, Ie.active, gn, rt && rt.submission, rt && rt.fetcherSubmission, rt && rt.replace, rt && rt.initialHydration === !0, Ln, At);
    Gt || (O = null, Wt(Oe, is({
      matches: vn || Vn
    }, xT(At), {
      loaderData: ae,
      errors: Ne
    })));
  }
  async function bn(Ve, Oe, rt, Et, gn, Vn) {
    Vn === void 0 && (Vn = {}), jt();
    let Ln = hJ(Oe, rt);
    if (ge({
      navigation: Ln
    }, {
      flushSync: Vn.flushSync === !0
    }), gn) {
      let At = await dr(Et, Oe.pathname, Ve.signal);
      if (At.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (At.type === "error") {
        let Gt = rb(At.partialMatches).route.id;
        return {
          matches: At.partialMatches,
          pendingActionResult: [Gt, {
            type: _a.error,
            error: At.error
          }]
        };
      } else if (At.matches)
        Et = At.matches;
      else {
        let {
          notFoundMatches: Gt,
          error: vn,
          route: ae
        } = et(Oe.pathname);
        return {
          matches: Gt,
          pendingActionResult: [ae.id, {
            type: _a.error,
            error: vn
          }]
        };
      }
    }
    let Ie, tt = DZ(Et, Oe);
    if (!tt.route.action && !tt.route.lazy)
      Ie = {
        type: _a.error,
        error: tI(405, {
          method: Ve.method,
          pathname: Oe.pathname,
          routeId: tt.route.id
        })
      };
    else if (Ie = (await Mt("action", L, Ve, [tt], Et, null))[tt.route.id], Ve.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (lb(Ie)) {
      let At;
      return Vn && Vn.replace != null ? At = Vn.replace : At = ST(Ie.response.headers.get("Location"), new URL(Ve.url), I) === L.location.pathname + L.location.search, await Bt(Ve, Ie, !0, {
        submission: rt,
        replace: At
      }), {
        shortCircuited: !0
      };
    }
    if (Iv(Ie))
      throw tI(400, {
        type: "defer-action"
      });
    if (LI(Ie)) {
      let At = rb(Et, tt.route.id);
      return (Vn && Vn.replace) !== !0 && (j = zl.Push), {
        matches: Et,
        pendingActionResult: [At.route.id, Ie]
      };
    }
    return {
      matches: Et,
      pendingActionResult: [tt.route.id, Ie]
    };
  }
  async function en(Ve, Oe, rt, Et, gn, Vn, Ln, Ie, tt, At, Gt) {
    let vn = gn || mM(Oe, Vn), ae = Vn || Ln || NT(vn), Ne = !Ae && (!v.v7_partialHydration || !tt);
    if (Et) {
      if (Ne) {
        let mi = hn(Gt);
        ge(is({
          navigation: vn
        }, mi !== void 0 ? {
          actionData: mi
        } : {}), {
          flushSync: At
        });
      }
      let Tn = await dr(rt, Oe.pathname, Ve.signal);
      if (Tn.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (Tn.type === "error") {
        let mi = rb(Tn.partialMatches).route.id;
        return {
          matches: Tn.partialMatches,
          loaderData: {},
          errors: {
            [mi]: Tn.error
          }
        };
      } else if (Tn.matches)
        rt = Tn.matches;
      else {
        let {
          error: mi,
          notFoundMatches: xn,
          route: un
        } = et(Oe.pathname);
        return {
          matches: xn,
          loaderData: {},
          errors: {
            [un.id]: mi
          }
        };
      }
    }
    let Te = u || l, [De, Ee] = bT(r.history, L, rt, ae, Oe, v.v7_partialHydration && tt === !0, v.v7_skipActionErrorRevalidation, ke, Re, Xe, Je, nt, Ye, Te, I, Gt);
    if (Jt((Tn) => !(rt && rt.some((mi) => mi.route.id === Tn)) || De && De.some((mi) => mi.route.id === Tn)), Be = ++Se, De.length === 0 && Ee.length === 0) {
      let Tn = on();
      return Wt(Oe, is({
        matches: rt,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: Gt && LI(Gt[1]) ? {
          [Gt[0]]: Gt[1].error
        } : null
      }, xT(Gt), Tn ? {
        fetchers: new Map(L.fetchers)
      } : {}), {
        flushSync: At
      }), {
        shortCircuited: !0
      };
    }
    if (Ne) {
      let Tn = {};
      if (!Et) {
        Tn.navigation = vn;
        let mi = hn(Gt);
        mi !== void 0 && (Tn.actionData = mi);
      }
      Ee.length > 0 && (Tn.fetchers = me(Ee)), ge(Tn, {
        flushSync: At
      });
    }
    Ee.forEach((Tn) => {
      xt(Tn.key), Tn.controller && re.set(Tn.key, Tn.controller);
    });
    let Tt = () => Ee.forEach((Tn) => xt(Tn.key));
    O && O.signal.addEventListener("abort", Tt);
    let {
      loaderResults: tn,
      fetcherResults: Bn
    } = await Gn(L, rt, De, Ee, Ve);
    if (Ve.signal.aborted)
      return {
        shortCircuited: !0
      };
    O && O.signal.removeEventListener("abort", Tt), Ee.forEach((Tn) => re.delete(Tn.key));
    let Pt = e1(tn);
    if (Pt)
      return await Bt(Ve, Pt.result, !0, {
        replace: Ie
      }), {
        shortCircuited: !0
      };
    if (Pt = e1(Bn), Pt)
      return Ye.add(Pt.key), await Bt(Ve, Pt.result, !0, {
        replace: Ie
      }), {
        shortCircuited: !0
      };
    let {
      loaderData: Zn,
      errors: rn
    } = wT(L, rt, tn, Gt, Ee, Bn, wt);
    wt.forEach((Tn, mi) => {
      Tn.subscribe((xn) => {
        (xn || Tn.done) && wt.delete(mi);
      });
    }), v.v7_partialHydration && tt && L.errors && (rn = is({}, L.errors, rn));
    let Yn = on(), Fi = we(Be), Ir = Yn || Fi || Ee.length > 0;
    return is({
      matches: rt,
      loaderData: Zn,
      errors: rn
    }, Ir ? {
      fetchers: new Map(L.fetchers)
    } : {});
  }
  function hn(Ve) {
    if (Ve && !LI(Ve[1]))
      return {
        [Ve[0]]: Ve[1].data
      };
    if (L.actionData)
      return Object.keys(L.actionData).length === 0 ? null : L.actionData;
  }
  function me(Ve) {
    return Ve.forEach((Oe) => {
      let rt = L.fetchers.get(Oe.key), Et = vZ(void 0, rt ? rt.data : void 0);
      L.fetchers.set(Oe.key, Et);
    }), new Map(L.fetchers);
  }
  function se(Ve, Oe, rt, Et) {
    if (n)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    xt(Ve);
    let gn = (Et && Et.flushSync) === !0, Vn = u || l, Ln = EH(L.location, L.matches, I, v.v7_prependBasename, rt, v.v7_relativeSplatPath, Oe, Et?.relative), Ie = ib(Vn, Ln, I), tt = Ii(Ie, Vn, Ln);
    if (tt.active && tt.matches && (Ie = tt.matches), !Ie) {
      jn(Ve, Oe, tI(404, {
        pathname: Ln
      }), {
        flushSync: gn
      });
      return;
    }
    let {
      path: At,
      submission: Gt,
      error: vn
    } = vT(v.v7_normalizeFormMethod, !0, Ln, Et);
    if (vn) {
      jn(Ve, Oe, vn, {
        flushSync: gn
      });
      return;
    }
    let ae = DZ(Ie, At), Ne = (Et && Et.preventScrollReset) === !0;
    if (Gt && $h(Gt.formMethod)) {
      $e(Ve, Oe, At, ae, Ie, tt.active, gn, Ne, Gt);
      return;
    }
    nt.set(Ve, {
      routeId: Oe,
      path: At
    }), Vt(Ve, Oe, At, ae, Ie, tt.active, gn, Ne, Gt);
  }
  async function $e(Ve, Oe, rt, Et, gn, Vn, Ln, Ie, tt) {
    jt(), nt.delete(Ve);
    function At(Xn) {
      if (!Xn.route.action && !Xn.route.lazy) {
        let li = tI(405, {
          method: tt.formMethod,
          pathname: rt,
          routeId: Oe
        });
        return jn(Ve, Oe, li, {
          flushSync: Ln
        }), !0;
      }
      return !1;
    }
    if (!Vn && At(Et))
      return;
    let Gt = L.fetchers.get(Ve);
    an(Ve, fJ(tt, Gt), {
      flushSync: Ln
    });
    let vn = new AbortController(), ae = vG(r.history, rt, vn.signal, tt);
    if (Vn) {
      let Xn = await dr(gn, new URL(ae.url).pathname, ae.signal, Ve);
      if (Xn.type === "aborted")
        return;
      if (Xn.type === "error") {
        jn(Ve, Oe, Xn.error, {
          flushSync: Ln
        });
        return;
      } else if (Xn.matches) {
        if (gn = Xn.matches, Et = DZ(gn, rt), At(Et))
          return;
      } else {
        jn(Ve, Oe, tI(404, {
          pathname: rt
        }), {
          flushSync: Ln
        });
        return;
      }
    }
    re.set(Ve, vn);
    let Ne = Se, De = (await Mt("action", L, ae, [Et], gn, Ve))[Et.route.id];
    if (ae.signal.aborted) {
      re.get(Ve) === vn && re.delete(Ve);
      return;
    }
    if (v.v7_fetcherPersist && Je.has(Ve)) {
      if (lb(De) || LI(De)) {
        an(Ve, cv(void 0));
        return;
      }
    } else {
      if (lb(De))
        if (re.delete(Ve), Be > Ne) {
          an(Ve, cv(void 0));
          return;
        } else
          return Ye.add(Ve), an(Ve, vZ(tt)), Bt(ae, De, !1, {
            fetcherSubmission: tt,
            preventScrollReset: Ie
          });
      if (LI(De)) {
        jn(Ve, Oe, De.error);
        return;
      }
    }
    if (Iv(De))
      throw tI(400, {
        type: "defer-action"
      });
    let Ee = L.navigation.location || L.location, Tt = vG(r.history, Ee, vn.signal), tn = u || l, Bn = L.navigation.state !== "idle" ? ib(tn, L.navigation.location, I) : L.matches;
    Mi(Bn, "Didn't find any matches after fetcher action");
    let Pt = ++Se;
    le.set(Ve, Pt);
    let Zn = vZ(tt, De.data);
    L.fetchers.set(Ve, Zn);
    let [rn, Yn] = bT(r.history, L, Bn, tt, Ee, !1, v.v7_skipActionErrorRevalidation, ke, Re, Xe, Je, nt, Ye, tn, I, [Et.route.id, De]);
    Yn.filter((Xn) => Xn.key !== Ve).forEach((Xn) => {
      let li = Xn.key, Wr = L.fetchers.get(li), Xo = vZ(void 0, Wr ? Wr.data : void 0);
      L.fetchers.set(li, Xo), xt(li), Xn.controller && re.set(li, Xn.controller);
    }), ge({
      fetchers: new Map(L.fetchers)
    });
    let Fi = () => Yn.forEach((Xn) => xt(Xn.key));
    vn.signal.addEventListener("abort", Fi);
    let {
      loaderResults: Ir,
      fetcherResults: Tn
    } = await Gn(L, Bn, rn, Yn, Tt);
    if (vn.signal.aborted)
      return;
    vn.signal.removeEventListener("abort", Fi), le.delete(Ve), re.delete(Ve), Yn.forEach((Xn) => re.delete(Xn.key));
    let mi = e1(Ir);
    if (mi)
      return Bt(Tt, mi.result, !1, {
        preventScrollReset: Ie
      });
    if (mi = e1(Tn), mi)
      return Ye.add(mi.key), Bt(Tt, mi.result, !1, {
        preventScrollReset: Ie
      });
    let {
      loaderData: xn,
      errors: un
    } = wT(L, Bn, Ir, void 0, Yn, Tn, wt);
    if (L.fetchers.has(Ve)) {
      let Xn = cv(De.data);
      L.fetchers.set(Ve, Xn);
    }
    we(Pt), L.navigation.state === "loading" && Pt > Be ? (Mi(j, "Expected pending action"), O && O.abort(), Wt(L.navigation.location, {
      matches: Bn,
      loaderData: xn,
      errors: un,
      fetchers: new Map(L.fetchers)
    })) : (ge({
      errors: un,
      loaderData: RT(L.loaderData, xn, Bn, un),
      fetchers: new Map(L.fetchers)
    }), ke = !1);
  }
  async function Vt(Ve, Oe, rt, Et, gn, Vn, Ln, Ie, tt) {
    let At = L.fetchers.get(Ve);
    an(Ve, vZ(tt, At ? At.data : void 0), {
      flushSync: Ln
    });
    let Gt = new AbortController(), vn = vG(r.history, rt, Gt.signal);
    if (Vn) {
      let De = await dr(gn, new URL(vn.url).pathname, vn.signal, Ve);
      if (De.type === "aborted")
        return;
      if (De.type === "error") {
        jn(Ve, Oe, De.error, {
          flushSync: Ln
        });
        return;
      } else if (De.matches)
        gn = De.matches, Et = DZ(gn, rt);
      else {
        jn(Ve, Oe, tI(404, {
          pathname: rt
        }), {
          flushSync: Ln
        });
        return;
      }
    }
    re.set(Ve, Gt);
    let ae = Se, Te = (await Mt("loader", L, vn, [Et], gn, Ve))[Et.route.id];
    if (Iv(Te) && (Te = await KX(Te, vn.signal, !0) || Te), re.get(Ve) === Gt && re.delete(Ve), !vn.signal.aborted) {
      if (Je.has(Ve)) {
        an(Ve, cv(void 0));
        return;
      }
      if (lb(Te))
        if (Be > ae) {
          an(Ve, cv(void 0));
          return;
        } else {
          Ye.add(Ve), await Bt(vn, Te, !1, {
            preventScrollReset: Ie
          });
          return;
        }
      if (LI(Te)) {
        jn(Ve, Oe, Te.error);
        return;
      }
      Mi(!Iv(Te), "Unhandled fetcher deferred data"), an(Ve, cv(Te.data));
    }
  }
  async function Bt(Ve, Oe, rt, Et) {
    let {
      submission: gn,
      fetcherSubmission: Vn,
      preventScrollReset: Ln,
      replace: Ie
    } = Et === void 0 ? {} : Et;
    Oe.response.headers.has("X-Remix-Revalidate") && (ke = !0);
    let tt = Oe.response.headers.get("Location");
    Mi(tt, "Expected a Location header on the redirect Response"), tt = ST(tt, new URL(Ve.url), I);
    let At = Cw(L.location, tt, {
      _isRedirect: !0
    });
    if (t) {
      let De = !1;
      if (Oe.response.headers.has("X-Remix-Reload-Document"))
        De = !0;
      else if (zX.test(tt)) {
        const Ee = r.history.createURL(tt);
        De = // Hard reload if it's an absolute URL to a new origin
        Ee.origin !== e.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        tf(Ee.pathname, I) == null;
      }
      if (De) {
        Ie ? e.location.replace(tt) : e.location.assign(tt);
        return;
      }
    }
    O = null;
    let Gt = Ie === !0 || Oe.response.headers.has("X-Remix-Replace") ? zl.Replace : zl.Push, {
      formMethod: vn,
      formAction: ae,
      formEncType: Ne
    } = L.navigation;
    !gn && !Vn && vn && ae && Ne && (gn = NT(L.navigation));
    let Te = gn || Vn;
    if (QP.has(Oe.response.status) && Te && $h(Te.formMethod))
      await ft(Gt, At, {
        submission: is({}, Te, {
          formAction: tt
        }),
        // Preserve these flags across redirects
        preventScrollReset: Ln || J,
        enableViewTransition: rt ? ne : void 0
      });
    else {
      let De = mM(At, gn);
      await ft(Gt, At, {
        overrideNavigation: De,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: Vn,
        // Preserve these flags across redirects
        preventScrollReset: Ln || J,
        enableViewTransition: rt ? ne : void 0
      });
    }
  }
  async function Mt(Ve, Oe, rt, Et, gn, Vn) {
    let Ln, Ie = {};
    try {
      Ln = await rJ(C, Ve, Oe, rt, Et, gn, Vn, o, i);
    } catch (tt) {
      return Et.forEach((At) => {
        Ie[At.route.id] = {
          type: _a.error,
          error: tt
        };
      }), Ie;
    }
    for (let [tt, At] of Object.entries(Ln))
      if (cJ(At)) {
        let Gt = At.result;
        Ie[tt] = {
          type: _a.redirect,
          response: sJ(Gt, rt, tt, gn, I, v.v7_relativeSplatPath)
        };
      } else
        Ie[tt] = await oJ(At);
    return Ie;
  }
  async function Gn(Ve, Oe, rt, Et, gn) {
    let Vn = Ve.matches, Ln = Mt("loader", Ve, gn, rt, Oe, null), Ie = Promise.all(Et.map(async (Gt) => {
      if (Gt.matches && Gt.match && Gt.controller) {
        let ae = (await Mt("loader", Ve, vG(r.history, Gt.path, Gt.controller.signal), [Gt.match], Gt.matches, Gt.key))[Gt.match.route.id];
        return {
          [Gt.key]: ae
        };
      } else
        return Promise.resolve({
          [Gt.key]: {
            type: _a.error,
            error: tI(404, {
              pathname: Gt.path
            })
          }
        });
    })), tt = await Ln, At = (await Ie).reduce((Gt, vn) => Object.assign(Gt, vn), {});
    return await Promise.all([IJ(Oe, tt, gn.signal, Vn, Ve.loaderData), CJ(Oe, At, Et)]), {
      loaderResults: tt,
      fetcherResults: At
    };
  }
  function jt() {
    ke = !0, Re.push(...Jt()), nt.forEach((Ve, Oe) => {
      re.has(Oe) && Xe.add(Oe), xt(Oe);
    });
  }
  function an(Ve, Oe, rt) {
    rt === void 0 && (rt = {}), L.fetchers.set(Ve, Oe), ge({
      fetchers: new Map(L.fetchers)
    }, {
      flushSync: (rt && rt.flushSync) === !0
    });
  }
  function jn(Ve, Oe, rt, Et) {
    Et === void 0 && (Et = {});
    let gn = rb(L.matches, Oe);
    He(Ve), ge({
      errors: {
        [gn.route.id]: rt
      },
      fetchers: new Map(L.fetchers)
    }, {
      flushSync: (Et && Et.flushSync) === !0
    });
  }
  function Ot(Ve) {
    return ze.set(Ve, (ze.get(Ve) || 0) + 1), Je.has(Ve) && Je.delete(Ve), L.fetchers.get(Ve) || jP;
  }
  function He(Ve) {
    let Oe = L.fetchers.get(Ve);
    re.has(Ve) && !(Oe && Oe.state === "loading" && le.has(Ve)) && xt(Ve), nt.delete(Ve), le.delete(Ve), Ye.delete(Ve), v.v7_fetcherPersist && Je.delete(Ve), Xe.delete(Ve), L.fetchers.delete(Ve);
  }
  function vt(Ve) {
    let Oe = (ze.get(Ve) || 0) - 1;
    Oe <= 0 ? (ze.delete(Ve), Je.add(Ve), v.v7_fetcherPersist || He(Ve)) : ze.set(Ve, Oe), ge({
      fetchers: new Map(L.fetchers)
    });
  }
  function xt(Ve) {
    let Oe = re.get(Ve);
    Oe && (Oe.abort(), re.delete(Ve));
  }
  function ht(Ve) {
    for (let Oe of Ve) {
      let rt = Ot(Oe), Et = cv(rt.data);
      L.fetchers.set(Oe, Et);
    }
  }
  function on() {
    let Ve = [], Oe = !1;
    for (let rt of Ye) {
      let Et = L.fetchers.get(rt);
      Mi(Et, "Expected fetcher: " + rt), Et.state === "loading" && (Ye.delete(rt), Ve.push(rt), Oe = !0);
    }
    return ht(Ve), Oe;
  }
  function we(Ve) {
    let Oe = [];
    for (let [rt, Et] of le)
      if (Et < Ve) {
        let gn = L.fetchers.get(rt);
        Mi(gn, "Expected fetcher: " + rt), gn.state === "loading" && (xt(rt), le.delete(rt), Oe.push(rt));
      }
    return ht(Oe), Oe.length > 0;
  }
  function qe(Ve, Oe) {
    let rt = L.blockers.get(Ve) || AZ;
    return mt.get(Ve) !== Oe && mt.set(Ve, Oe), rt;
  }
  function de(Ve) {
    L.blockers.delete(Ve), mt.delete(Ve);
  }
  function it(Ve, Oe) {
    let rt = L.blockers.get(Ve) || AZ;
    Mi(rt.state === "unblocked" && Oe.state === "blocked" || rt.state === "blocked" && Oe.state === "blocked" || rt.state === "blocked" && Oe.state === "proceeding" || rt.state === "blocked" && Oe.state === "unblocked" || rt.state === "proceeding" && Oe.state === "unblocked", "Invalid blocker state transition: " + rt.state + " -> " + Oe.state);
    let Et = new Map(L.blockers);
    Et.set(Ve, Oe), ge({
      blockers: Et
    });
  }
  function je(Ve) {
    let {
      currentLocation: Oe,
      nextLocation: rt,
      historyAction: Et
    } = Ve;
    if (mt.size === 0)
      return;
    mt.size > 1 && fl(!1, "A router only supports one blocker at a time");
    let gn = Array.from(mt.entries()), [Vn, Ln] = gn[gn.length - 1], Ie = L.blockers.get(Vn);
    if (!(Ie && Ie.state === "proceeding") && Ln({
      currentLocation: Oe,
      nextLocation: rt,
      historyAction: Et
    }))
      return Vn;
  }
  function et(Ve) {
    let Oe = tI(404, {
      pathname: Ve
    }), rt = u || l, {
      matches: Et,
      route: gn
    } = WT(rt);
    return Jt(), {
      notFoundMatches: Et,
      route: gn,
      error: Oe
    };
  }
  function Jt(Ve) {
    let Oe = [];
    return wt.forEach((rt, Et) => {
      (!Ve || Ve(Et)) && (rt.cancel(), Oe.push(Et), wt.delete(Et));
    }), Oe;
  }
  function Kn(Ve, Oe, rt) {
    if (R = Ve, x = Oe, W = rt || null, !N && L.navigation === pM) {
      N = !0;
      let Et = Jn(L.location, L.matches);
      Et != null && ge({
        restoreScrollPosition: Et
      });
    }
    return () => {
      R = null, x = null, W = null;
    };
  }
  function di(Ve, Oe) {
    return W && W(Ve, Oe.map((Et) => RP(Et, L.loaderData))) || Ve.key;
  }
  function Di(Ve, Oe) {
    if (R && x) {
      let rt = di(Ve, Oe);
      R[rt] = x();
    }
  }
  function Jn(Ve, Oe) {
    if (R) {
      let rt = di(Ve, Oe), Et = R[rt];
      if (typeof Et == "number")
        return Et;
    }
    return null;
  }
  function Ii(Ve, Oe, rt) {
    if (f)
      if (Ve) {
        if (Object.keys(Ve[0].params).length > 0)
          return {
            active: !0,
            matches: l2(Oe, rt, I, !0)
          };
      } else
        return {
          active: !0,
          matches: l2(Oe, rt, I, !0) || []
        };
    return {
      active: !1,
      matches: null
    };
  }
  async function dr(Ve, Oe, rt, Et) {
    if (!f)
      return {
        type: "success",
        matches: Ve
      };
    let gn = Ve;
    for (; ; ) {
      let Vn = u == null, Ln = u || l, Ie = o;
      try {
        await f({
          signal: rt,
          path: Oe,
          matches: gn,
          fetcherKey: Et,
          patch: (Gt, vn) => {
            rt.aborted || BT(Gt, vn, Ln, Ie, i);
          }
        });
      } catch (Gt) {
        return {
          type: "error",
          error: Gt,
          partialMatches: gn
        };
      } finally {
        Vn && !rt.aborted && (l = [...l]);
      }
      if (rt.aborted)
        return {
          type: "aborted"
        };
      let tt = ib(Ln, Oe, I);
      if (tt)
        return {
          type: "success",
          matches: tt
        };
      let At = l2(Ln, Oe, I, !0);
      if (!At || gn.length === At.length && gn.every((Gt, vn) => Gt.route.id === At[vn].route.id))
        return {
          type: "success",
          matches: null
        };
      gn = At;
    }
  }
  function xr(Ve) {
    o = {}, u = v2(Ve, i, void 0, o);
  }
  function la(Ve, Oe) {
    let rt = u == null;
    BT(Ve, Oe, u || l, o, i), rt && (l = [...l], ge({}));
  }
  return D = {
    get basename() {
      return I;
    },
    get future() {
      return v;
    },
    get state() {
      return L;
    },
    get routes() {
      return l;
    },
    get window() {
      return e;
    },
    initialize: mn,
    subscribe: Hn,
    enableScrollRestoration: Kn,
    navigate: Nt,
    fetch: se,
    revalidate: $t,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (Ve) => r.history.createHref(Ve),
    encodeLocation: (Ve) => r.history.encodeLocation(Ve),
    getFetcher: Ot,
    deleteFetcher: vt,
    dispose: An,
    getBlocker: qe,
    deleteBlocker: de,
    patchRoutes: la,
    _internalFetchControllers: re,
    _internalActiveDeferreds: wt,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: xr
  }, D;
}
function eJ(r) {
  return r != null && ("formData" in r && r.formData != null || "body" in r && r.body !== void 0);
}
function EH(r, e, t, n, i, o, l, u) {
  let I, C;
  if (l) {
    I = [];
    for (let v of e)
      if (I.push(v), v.route.id === l) {
        C = v;
        break;
      }
  } else
    I = e, C = e[e.length - 1];
  let f = ZW(i || ".", SW(I, o), tf(r.pathname, t) || r.pathname, u === "path");
  if (i == null && (f.search = r.search, f.hash = r.hash), (i == null || i === "" || i === ".") && C) {
    let v = LX(f.search);
    if (C.route.index && !v)
      f.search = f.search ? f.search.replace(/^\?/, "?index&") : "?index";
    else if (!C.route.index && v) {
      let b = new URLSearchParams(f.search), S = b.getAll("index");
      b.delete("index"), S.filter((W) => W).forEach((W) => b.append("index", W));
      let R = b.toString();
      f.search = R ? "?" + R : "";
    }
  }
  return n && t !== "/" && (f.pathname = f.pathname === "/" ? t : up([t, f.pathname])), vv(f);
}
function vT(r, e, t, n) {
  if (!n || !eJ(n))
    return {
      path: t
    };
  if (n.formMethod && !dJ(n.formMethod))
    return {
      path: t,
      error: tI(405, {
        method: n.formMethod
      })
    };
  let i = () => ({
    path: t,
    error: tI(400, {
      type: "invalid-body"
    })
  }), o = n.formMethod || "get", l = r ? o.toUpperCase() : o.toLowerCase(), u = xz(t);
  if (n.body !== void 0) {
    if (n.formEncType === "text/plain") {
      if (!$h(l))
        return i();
      let b = typeof n.body == "string" ? n.body : n.body instanceof FormData || n.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(n.body.entries()).reduce((S, R) => {
          let [W, x] = R;
          return "" + S + W + "=" + x + `
`;
        }, "")
      ) : String(n.body);
      return {
        path: t,
        submission: {
          formMethod: l,
          formAction: u,
          formEncType: n.formEncType,
          formData: void 0,
          json: void 0,
          text: b
        }
      };
    } else if (n.formEncType === "application/json") {
      if (!$h(l))
        return i();
      try {
        let b = typeof n.body == "string" ? JSON.parse(n.body) : n.body;
        return {
          path: t,
          submission: {
            formMethod: l,
            formAction: u,
            formEncType: n.formEncType,
            formData: void 0,
            json: b,
            text: void 0
          }
        };
      } catch {
        return i();
      }
    }
  }
  Mi(typeof FormData == "function", "FormData is not available in this environment");
  let I, C;
  if (n.formData)
    I = _H(n.formData), C = n.formData;
  else if (n.body instanceof FormData)
    I = _H(n.body), C = n.body;
  else if (n.body instanceof URLSearchParams)
    I = n.body, C = ZT(I);
  else if (n.body == null)
    I = new URLSearchParams(), C = new FormData();
  else
    try {
      I = new URLSearchParams(n.body), C = ZT(I);
    } catch {
      return i();
    }
  let f = {
    formMethod: l,
    formAction: u,
    formEncType: n && n.formEncType || "application/x-www-form-urlencoded",
    formData: C,
    json: void 0,
    text: void 0
  };
  if ($h(f.formMethod))
    return {
      path: t,
      submission: f
    };
  let v = qm(t);
  return e && v.search && LX(v.search) && I.append("index", ""), v.search = "?" + I, {
    path: vv(v),
    submission: f
  };
}
function yT(r, e, t) {
  t === void 0 && (t = !1);
  let n = r.findIndex((i) => i.route.id === e);
  return n >= 0 ? r.slice(0, t ? n + 1 : n) : r;
}
function bT(r, e, t, n, i, o, l, u, I, C, f, v, b, S, R, W) {
  let x = W ? LI(W[1]) ? W[1].error : W[1].data : void 0, N = r.createURL(e.location), Y = r.createURL(i), F = t;
  o && e.errors ? F = yT(t, Object.keys(e.errors)[0], !0) : W && LI(W[1]) && (F = yT(t, W[0]));
  let T = W ? W[1].statusCode : void 0, P = l && T && T >= 400, D = F.filter((j, J) => {
    let {
      route: O
    } = j;
    if (O.lazy)
      return !0;
    if (O.loader == null)
      return !1;
    if (o)
      return TH(O, e.loaderData, e.errors);
    if (tJ(e.loaderData, e.matches[J], j) || I.some((pe) => pe === j.route.id))
      return !0;
    let ne = e.matches[J], he = j;
    return GT(j, is({
      currentUrl: N,
      currentParams: ne.params,
      nextUrl: Y,
      nextParams: he.params
    }, n, {
      actionResult: x,
      actionStatus: T,
      defaultShouldRevalidate: P ? !1 : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        u || N.pathname + N.search === Y.pathname + Y.search || // Search params affect all loaders
        N.search !== Y.search || wz(ne, he)
      )
    }));
  }), L = [];
  return v.forEach((j, J) => {
    if (o || !t.some((Ae) => Ae.route.id === j.routeId) || f.has(J))
      return;
    let O = ib(S, j.path, R);
    if (!O) {
      L.push({
        key: J,
        routeId: j.routeId,
        path: j.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let ne = e.fetchers.get(J), he = DZ(O, j.path), pe = !1;
    b.has(J) ? pe = !1 : C.has(J) ? (C.delete(J), pe = !0) : ne && ne.state !== "idle" && ne.data === void 0 ? pe = u : pe = GT(he, is({
      currentUrl: N,
      currentParams: e.matches[e.matches.length - 1].params,
      nextUrl: Y,
      nextParams: t[t.length - 1].params
    }, n, {
      actionResult: x,
      actionStatus: T,
      defaultShouldRevalidate: P ? !1 : u
    })), pe && L.push({
      key: J,
      routeId: j.routeId,
      path: j.path,
      matches: O,
      match: he,
      controller: new AbortController()
    });
  }), [D, L];
}
function TH(r, e, t) {
  if (r.lazy)
    return !0;
  if (!r.loader)
    return !1;
  let n = e != null && e[r.id] !== void 0, i = t != null && t[r.id] !== void 0;
  return !n && i ? !1 : typeof r.loader == "function" && r.loader.hydrate === !0 ? !0 : !n && !i;
}
function tJ(r, e, t) {
  let n = (
    // [a] -> [a, b]
    !e || // [a, b] -> [a, c]
    t.route.id !== e.route.id
  ), i = r[t.route.id] === void 0;
  return n || i;
}
function wz(r, e) {
  let t = r.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    r.pathname !== e.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    t != null && t.endsWith("*") && r.params["*"] !== e.params["*"]
  );
}
function GT(r, e) {
  if (r.route.shouldRevalidate) {
    let t = r.route.shouldRevalidate(e);
    if (typeof t == "boolean")
      return t;
  }
  return e.defaultShouldRevalidate;
}
function BT(r, e, t, n, i) {
  var o;
  let l;
  if (r) {
    let C = n[r];
    Mi(C, "No route found to patch children into: routeId = " + r), C.children || (C.children = []), l = C.children;
  } else
    l = t;
  let u = e.filter((C) => !l.some((f) => Rz(C, f))), I = v2(u, i, [r || "_", "patch", String(((o = l) == null ? void 0 : o.length) || "0")], n);
  l.push(...I);
}
function Rz(r, e) {
  return "id" in r && "id" in e && r.id === e.id ? !0 : r.index === e.index && r.path === e.path && r.caseSensitive === e.caseSensitive ? (!r.children || r.children.length === 0) && (!e.children || e.children.length === 0) ? !0 : r.children.every((t, n) => {
    var i;
    return (i = e.children) == null ? void 0 : i.some((o) => Rz(t, o));
  }) : !1;
}
async function nJ(r, e, t) {
  if (!r.lazy)
    return;
  let n = await r.lazy();
  if (!r.lazy)
    return;
  let i = t[r.id];
  Mi(i, "No route found in manifest");
  let o = {};
  for (let l in n) {
    let I = i[l] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    l !== "hasErrorBoundary";
    fl(!I, 'Route "' + i.id + '" has a static property "' + l + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + l + '" will be ignored.')), !I && !ZP.has(l) && (o[l] = n[l]);
  }
  Object.assign(i, o), Object.assign(i, is({}, e(i), {
    lazy: void 0
  }));
}
async function iJ(r) {
  let {
    matches: e
  } = r, t = e.filter((i) => i.shouldLoad);
  return (await Promise.all(t.map((i) => i.resolve()))).reduce((i, o, l) => Object.assign(i, {
    [t[l].route.id]: o
  }), {});
}
async function rJ(r, e, t, n, i, o, l, u, I, C) {
  let f = o.map((S) => S.route.lazy ? nJ(S.route, I, u) : void 0), v = o.map((S, R) => {
    let W = f[R], x = i.some((Y) => Y.route.id === S.route.id);
    return is({}, S, {
      shouldLoad: x,
      resolve: async (Y) => (Y && n.method === "GET" && (S.route.lazy || S.route.loader) && (x = !0), x ? aJ(e, n, S, W, Y, C) : Promise.resolve({
        type: _a.data,
        result: void 0
      }))
    });
  }), b = await r({
    matches: v,
    request: n,
    params: o[0].params,
    fetcherKey: l,
    context: C
  });
  try {
    await Promise.all(f);
  } catch {
  }
  return b;
}
async function aJ(r, e, t, n, i, o) {
  let l, u, I = (C) => {
    let f, v = new Promise((R, W) => f = W);
    u = () => f(), e.signal.addEventListener("abort", u);
    let b = (R) => typeof C != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + r + '" [routeId: ' + t.route.id + "]"))) : C({
      request: e,
      params: t.params,
      context: o
    }, ...R !== void 0 ? [R] : []), S = (async () => {
      try {
        return {
          type: "data",
          result: await (i ? i((W) => b(W)) : b())
        };
      } catch (R) {
        return {
          type: "error",
          result: R
        };
      }
    })();
    return Promise.race([S, v]);
  };
  try {
    let C = t.route[r];
    if (n)
      if (C) {
        let f, [v] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          I(C).catch((b) => {
            f = b;
          }),
          n
        ]);
        if (f !== void 0)
          throw f;
        l = v;
      } else if (await n, C = t.route[r], C)
        l = await I(C);
      else if (r === "action") {
        let f = new URL(e.url), v = f.pathname + f.search;
        throw tI(405, {
          method: e.method,
          pathname: v,
          routeId: t.route.id
        });
      } else
        return {
          type: _a.data,
          result: void 0
        };
    else if (C)
      l = await I(C);
    else {
      let f = new URL(e.url), v = f.pathname + f.search;
      throw tI(404, {
        pathname: v
      });
    }
    Mi(l.result !== void 0, "You defined " + (r === "action" ? "an action" : "a loader") + " for route " + ('"' + t.route.id + "\" but didn't return anything from your `" + r + "` ") + "function. Please return a value or `null`.");
  } catch (C) {
    return {
      type: _a.error,
      result: C
    };
  } finally {
    u && e.signal.removeEventListener("abort", u);
  }
  return l;
}
async function oJ(r) {
  let {
    result: e,
    type: t
  } = r;
  if (Wz(e)) {
    let v;
    try {
      let b = e.headers.get("Content-Type");
      b && /\bapplication\/json\b/.test(b) ? e.body == null ? v = null : v = await e.json() : v = await e.text();
    } catch (b) {
      return {
        type: _a.error,
        error: b
      };
    }
    return t === _a.error ? {
      type: _a.error,
      error: new b2(e.status, e.statusText, v),
      statusCode: e.status,
      headers: e.headers
    } : {
      type: _a.data,
      data: v,
      statusCode: e.status,
      headers: e.headers
    };
  }
  if (t === _a.error) {
    if (VT(e)) {
      var n, i;
      if (e.data instanceof Error) {
        var o, l;
        return {
          type: _a.error,
          error: e.data,
          statusCode: (o = e.init) == null ? void 0 : o.status,
          headers: (l = e.init) != null && l.headers ? new Headers(e.init.headers) : void 0
        };
      }
      return {
        type: _a.error,
        error: new b2(((n = e.init) == null ? void 0 : n.status) || 500, void 0, e.data),
        statusCode: hw(e) ? e.status : void 0,
        headers: (i = e.init) != null && i.headers ? new Headers(e.init.headers) : void 0
      };
    }
    return {
      type: _a.error,
      error: e,
      statusCode: hw(e) ? e.status : void 0
    };
  }
  if (gJ(e)) {
    var u, I;
    return {
      type: _a.deferred,
      deferredData: e,
      statusCode: (u = e.init) == null ? void 0 : u.status,
      headers: ((I = e.init) == null ? void 0 : I.headers) && new Headers(e.init.headers)
    };
  }
  if (VT(e)) {
    var C, f;
    return {
      type: _a.data,
      data: e.data,
      statusCode: (C = e.init) == null ? void 0 : C.status,
      headers: (f = e.init) != null && f.headers ? new Headers(e.init.headers) : void 0
    };
  }
  return {
    type: _a.data,
    data: e
  };
}
function sJ(r, e, t, n, i, o) {
  let l = r.headers.get("Location");
  if (Mi(l, "Redirects returned/thrown from loaders/actions must have a Location header"), !zX.test(l)) {
    let u = n.slice(0, n.findIndex((I) => I.route.id === t) + 1);
    l = EH(new URL(e.url), u, i, !0, l, o), r.headers.set("Location", l);
  }
  return r;
}
function ST(r, e, t) {
  if (zX.test(r)) {
    let n = r, i = n.startsWith("//") ? new URL(e.protocol + n) : new URL(n), o = tf(i.pathname, t) != null;
    if (i.origin === e.origin && o)
      return i.pathname + i.search + i.hash;
  }
  return r;
}
function vG(r, e, t, n) {
  let i = r.createURL(xz(e)).toString(), o = {
    signal: t
  };
  if (n && $h(n.formMethod)) {
    let {
      formMethod: l,
      formEncType: u
    } = n;
    o.method = l.toUpperCase(), u === "application/json" ? (o.headers = new Headers({
      "Content-Type": u
    }), o.body = JSON.stringify(n.json)) : u === "text/plain" ? o.body = n.text : u === "application/x-www-form-urlencoded" && n.formData ? o.body = _H(n.formData) : o.body = n.formData;
  }
  return new Request(i, o);
}
function _H(r) {
  let e = new URLSearchParams();
  for (let [t, n] of r.entries())
    e.append(t, typeof n == "string" ? n : n.name);
  return e;
}
function ZT(r) {
  let e = new FormData();
  for (let [t, n] of r.entries())
    e.append(t, n);
  return e;
}
function lJ(r, e, t, n, i) {
  let o = {}, l = null, u, I = !1, C = {}, f = t && LI(t[1]) ? t[1].error : void 0;
  return r.forEach((v) => {
    if (!(v.route.id in e))
      return;
    let b = v.route.id, S = e[b];
    if (Mi(!lb(S), "Cannot handle redirect results in processLoaderData"), LI(S)) {
      let R = S.error;
      f !== void 0 && (R = f, f = void 0), l = l || {};
      {
        let W = rb(r, b);
        l[W.route.id] == null && (l[W.route.id] = R);
      }
      o[b] = void 0, I || (I = !0, u = hw(S.error) ? S.error.status : 500), S.headers && (C[b] = S.headers);
    } else
      Iv(S) ? (n.set(b, S.deferredData), o[b] = S.deferredData.data, S.statusCode != null && S.statusCode !== 200 && !I && (u = S.statusCode), S.headers && (C[b] = S.headers)) : (o[b] = S.data, S.statusCode && S.statusCode !== 200 && !I && (u = S.statusCode), S.headers && (C[b] = S.headers));
  }), f !== void 0 && t && (l = {
    [t[0]]: f
  }, o[t[0]] = void 0), {
    loaderData: o,
    errors: l,
    statusCode: u || 200,
    loaderHeaders: C
  };
}
function wT(r, e, t, n, i, o, l) {
  let {
    loaderData: u,
    errors: I
  } = lJ(e, t, n, l);
  return i.forEach((C) => {
    let {
      key: f,
      match: v,
      controller: b
    } = C, S = o[f];
    if (Mi(S, "Did not find corresponding fetcher result"), !(b && b.signal.aborted))
      if (LI(S)) {
        let R = rb(r.matches, v?.route.id);
        I && I[R.route.id] || (I = is({}, I, {
          [R.route.id]: S.error
        })), r.fetchers.delete(f);
      } else if (lb(S))
        Mi(!1, "Unhandled fetcher revalidation redirect");
      else if (Iv(S))
        Mi(!1, "Unhandled fetcher deferred data");
      else {
        let R = cv(S.data);
        r.fetchers.set(f, R);
      }
  }), {
    loaderData: u,
    errors: I
  };
}
function RT(r, e, t, n) {
  let i = is({}, e);
  for (let o of t) {
    let l = o.route.id;
    if (e.hasOwnProperty(l) ? e[l] !== void 0 && (i[l] = e[l]) : r[l] !== void 0 && o.route.loader && (i[l] = r[l]), n && n.hasOwnProperty(l))
      break;
  }
  return i;
}
function xT(r) {
  return r ? LI(r[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [r[0]]: r[1].data
    }
  } : {};
}
function rb(r, e) {
  return (e ? r.slice(0, r.findIndex((n) => n.route.id === e) + 1) : [...r]).reverse().find((n) => n.route.hasErrorBoundary === !0) || r[0];
}
function WT(r) {
  let e = r.length === 1 ? r[0] : r.find((t) => t.index || !t.path || t.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route: e
    }],
    route: e
  };
}
function tI(r, e) {
  let {
    pathname: t,
    routeId: n,
    method: i,
    type: o,
    message: l
  } = e === void 0 ? {} : e, u = "Unknown Server Error", I = "Unknown @remix-run/router error";
  return r === 400 ? (u = "Bad Request", i && t && n ? I = "You made a " + i + ' request to "' + t + '" but ' + ('did not provide a `loader` for route "' + n + '", ') + "so there is no way to handle the request." : o === "defer-action" ? I = "defer() is not supported in actions" : o === "invalid-body" && (I = "Unable to encode submission body")) : r === 403 ? (u = "Forbidden", I = 'Route "' + n + '" does not match URL "' + t + '"') : r === 404 ? (u = "Not Found", I = 'No route matches URL "' + t + '"') : r === 405 && (u = "Method Not Allowed", i && t && n ? I = "You made a " + i.toUpperCase() + ' request to "' + t + '" but ' + ('did not provide an `action` for route "' + n + '", ') + "so there is no way to handle the request." : i && (I = 'Invalid request method "' + i.toUpperCase() + '"')), new b2(r || 500, u, new Error(I), !0);
}
function e1(r) {
  let e = Object.entries(r);
  for (let t = e.length - 1; t >= 0; t--) {
    let [n, i] = e[t];
    if (lb(i))
      return {
        key: n,
        result: i
      };
  }
}
function xz(r) {
  let e = typeof r == "string" ? qm(r) : r;
  return vv(is({}, e, {
    hash: ""
  }));
}
function uJ(r, e) {
  return r.pathname !== e.pathname || r.search !== e.search ? !1 : r.hash === "" ? e.hash !== "" : r.hash === e.hash ? !0 : e.hash !== "";
}
function cJ(r) {
  return Wz(r.result) && JP.has(r.result.status);
}
function Iv(r) {
  return r.type === _a.deferred;
}
function LI(r) {
  return r.type === _a.error;
}
function lb(r) {
  return (r && r.type) === _a.redirect;
}
function VT(r) {
  return typeof r == "object" && r != null && "type" in r && "data" in r && "init" in r && r.type === "DataWithResponseInit";
}
function gJ(r) {
  let e = r;
  return e && typeof e == "object" && typeof e.data == "object" && typeof e.subscribe == "function" && typeof e.cancel == "function" && typeof e.resolveData == "function";
}
function Wz(r) {
  return r != null && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.headers == "object" && typeof r.body < "u";
}
function dJ(r) {
  return PP.has(r.toLowerCase());
}
function $h(r) {
  return UP.has(r.toLowerCase());
}
async function IJ(r, e, t, n, i) {
  let o = Object.entries(e);
  for (let l = 0; l < o.length; l++) {
    let [u, I] = o[l], C = r.find((b) => b?.route.id === u);
    if (!C)
      continue;
    let f = n.find((b) => b.route.id === C.route.id), v = f != null && !wz(f, C) && (i && i[C.route.id]) !== void 0;
    Iv(I) && v && await KX(I, t, !1).then((b) => {
      b && (e[u] = b);
    });
  }
}
async function CJ(r, e, t) {
  for (let n = 0; n < t.length; n++) {
    let {
      key: i,
      routeId: o,
      controller: l
    } = t[n], u = e[i];
    r.find((C) => C?.route.id === o) && Iv(u) && (Mi(l, "Expected an AbortController for revalidating fetcher deferred result"), await KX(u, l.signal, !0).then((C) => {
      C && (e[i] = C);
    }));
  }
}
async function KX(r, e, t) {
  if (t === void 0 && (t = !1), !await r.deferredData.resolveData(e)) {
    if (t)
      try {
        return {
          type: _a.data,
          data: r.deferredData.unwrappedData
        };
      } catch (i) {
        return {
          type: _a.error,
          error: i
        };
      }
    return {
      type: _a.data,
      data: r.deferredData.data
    };
  }
}
function LX(r) {
  return new URLSearchParams(r).getAll("index").some((e) => e === "");
}
function DZ(r, e) {
  let t = typeof e == "string" ? qm(e).search : e.search;
  if (r[r.length - 1].route.index && LX(t || ""))
    return r[r.length - 1];
  let n = Bz(r);
  return n[n.length - 1];
}
function NT(r) {
  let {
    formMethod: e,
    formAction: t,
    formEncType: n,
    text: i,
    formData: o,
    json: l
  } = r;
  if (!(!e || !t || !n)) {
    if (i != null)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: void 0,
        json: void 0,
        text: i
      };
    if (o != null)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: o,
        json: void 0,
        text: void 0
      };
    if (l !== void 0)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: void 0,
        json: l,
        text: void 0
      };
  }
}
function mM(r, e) {
  return e ? {
    state: "loading",
    location: r,
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text
  } : {
    state: "loading",
    location: r,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function hJ(r, e) {
  return {
    state: "submitting",
    location: r,
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text
  };
}
function vZ(r, e) {
  return r ? {
    state: "loading",
    formMethod: r.formMethod,
    formAction: r.formAction,
    formEncType: r.formEncType,
    formData: r.formData,
    json: r.json,
    text: r.text,
    data: e
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function fJ(r, e) {
  return {
    state: "submitting",
    formMethod: r.formMethod,
    formAction: r.formAction,
    formEncType: r.formEncType,
    formData: r.formData,
    json: r.json,
    text: r.text,
    data: e ? e.data : void 0
  };
}
function cv(r) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: r
  };
}
function pJ(r, e) {
  try {
    let t = r.sessionStorage.getItem(Zz);
    if (t) {
      let n = JSON.parse(t);
      for (let [i, o] of Object.entries(n || {}))
        o && Array.isArray(o) && e.set(i, new Set(o || []));
    }
  } catch {
  }
}
function mJ(r, e) {
  if (e.size > 0) {
    let t = {};
    for (let [n, i] of e)
      t[n] = [...i];
    try {
      r.sessionStorage.setItem(Zz, JSON.stringify(t));
    } catch (n) {
      fl(!1, "Failed to save applied view transitions in sessionStorage (" + n + ").");
    }
  }
}
var Qr = {};
function G2() {
  return G2 = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, G2.apply(this, arguments);
}
const wB = /* @__PURE__ */ ye.createContext(null);
Qr.NODE_ENV !== "production" && (wB.displayName = "DataRouter");
const wW = /* @__PURE__ */ ye.createContext(null);
Qr.NODE_ENV !== "production" && (wW.displayName = "DataRouterState");
const AJ = /* @__PURE__ */ ye.createContext(null);
Qr.NODE_ENV !== "production" && (AJ.displayName = "Await");
const jC = /* @__PURE__ */ ye.createContext(null);
Qr.NODE_ENV !== "production" && (jC.displayName = "Navigation");
const RW = /* @__PURE__ */ ye.createContext(null);
Qr.NODE_ENV !== "production" && (RW.displayName = "Location");
const fp = /* @__PURE__ */ ye.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
Qr.NODE_ENV !== "production" && (fp.displayName = "Route");
const kX = /* @__PURE__ */ ye.createContext(null);
Qr.NODE_ENV !== "production" && (kX.displayName = "RouteError");
function vJ(r, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e;
  RB() || (Qr.NODE_ENV !== "production" ? Mi(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : Mi(!1));
  let {
    basename: n,
    navigator: i
  } = ye.useContext(jC), {
    hash: o,
    pathname: l,
    search: u
  } = Jw(r, {
    relative: t
  }), I = l;
  return n !== "/" && (I = l === "/" ? n : up([n, l])), i.createHref({
    pathname: I,
    search: u,
    hash: o
  });
}
function RB() {
  return ye.useContext(RW) != null;
}
function rd() {
  return RB() || (Qr.NODE_ENV !== "production" ? Mi(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : Mi(!1)), ye.useContext(RW).location;
}
const Vz = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function Nz(r) {
  ye.useContext(jC).static || ye.useLayoutEffect(r);
}
function Wb() {
  let {
    isDataRoute: r
  } = ye.useContext(fp);
  return r ? MJ() : yJ();
}
function yJ() {
  RB() || (Qr.NODE_ENV !== "production" ? Mi(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : Mi(!1));
  let r = ye.useContext(wB), {
    basename: e,
    future: t,
    navigator: n
  } = ye.useContext(jC), {
    matches: i
  } = ye.useContext(fp), {
    pathname: o
  } = rd(), l = JSON.stringify(SW(i, t.v7_relativeSplatPath)), u = ye.useRef(!1);
  return Nz(() => {
    u.current = !0;
  }), ye.useCallback(function(C, f) {
    if (f === void 0 && (f = {}), Qr.NODE_ENV !== "production" && fl(u.current, Vz), !u.current) return;
    if (typeof C == "number") {
      n.go(C);
      return;
    }
    let v = ZW(C, JSON.parse(l), o, f.relative === "path");
    r == null && e !== "/" && (v.pathname = v.pathname === "/" ? e : up([e, v.pathname])), (f.replace ? n.replace : n.push)(v, f.state, f);
  }, [e, n, l, o, r]);
}
function Jw(r, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    future: n
  } = ye.useContext(jC), {
    matches: i
  } = ye.useContext(fp), {
    pathname: o
  } = rd(), l = JSON.stringify(SW(i, n.v7_relativeSplatPath));
  return ye.useMemo(() => ZW(r, JSON.parse(l), o, t === "path"), [r, l, o, t]);
}
function bJ(r, e, t, n) {
  RB() || (Qr.NODE_ENV !== "production" ? Mi(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : Mi(!1));
  let {
    navigator: i,
    static: o
  } = ye.useContext(jC), {
    matches: l
  } = ye.useContext(fp), u = l[l.length - 1], I = u ? u.params : {}, C = u ? u.pathname : "/", f = u ? u.pathnameBase : "/", v = u && u.route;
  if (Qr.NODE_ENV !== "production") {
    let Y = v && v.path || "";
    Hz(C, !v || Y.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + C + '" (under <Route path="' + Y + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + Y + '"> to <Route ') + ('path="' + (Y === "/" ? "*" : Y + "/*") + '">.'));
  }
  let b = rd(), S;
  S = b;
  let R = S.pathname || "/", W = R;
  if (f !== "/") {
    let Y = f.replace(/^\//, "").split("/");
    W = "/" + R.replace(/^\//, "").split("/").slice(Y.length).join("/");
  }
  let x = !o && t && t.matches && t.matches.length > 0 ? t.matches : ib(r, {
    pathname: W
  });
  return Qr.NODE_ENV !== "production" && (Qr.NODE_ENV !== "production" && fl(v || x != null, 'No routes matched location "' + S.pathname + S.search + S.hash + '" '), Qr.NODE_ENV !== "production" && fl(x == null || x[x.length - 1].route.element !== void 0 || x[x.length - 1].route.Component !== void 0 || x[x.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + S.pathname + S.search + S.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.')), wJ(x && x.map((Y) => Object.assign({}, Y, {
    params: Object.assign({}, I, Y.params),
    pathname: up([
      f,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(Y.pathname).pathname : Y.pathname
    ]),
    pathnameBase: Y.pathnameBase === "/" ? f : up([
      f,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(Y.pathnameBase).pathname : Y.pathnameBase
    ])
  })), l, t, n);
}
function GJ() {
  let r = NJ(), e = hw(r) ? r.status + " " + r.statusText : r instanceof Error ? r.message : JSON.stringify(r), t = r instanceof Error ? r.stack : null, n = "rgba(200,200,200, 0.5)", i = {
    padding: "0.5rem",
    backgroundColor: n
  }, o = {
    padding: "2px 4px",
    backgroundColor: n
  }, l = null;
  return Qr.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", r), l = /* @__PURE__ */ ye.createElement(ye.Fragment, null, /* @__PURE__ */ ye.createElement("p", null, " Hey developer "), /* @__PURE__ */ ye.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ ye.createElement("code", {
    style: o
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ ye.createElement("code", {
    style: o
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ ye.createElement(ye.Fragment, null, /* @__PURE__ */ ye.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ ye.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, e), t ? /* @__PURE__ */ ye.createElement("pre", {
    style: i
  }, t) : null, l);
}
const BJ = /* @__PURE__ */ ye.createElement(GJ, null);
class SJ extends ye.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return {
      error: e
    };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    console.error("React Router caught the following error during render", e, t);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ ye.createElement(fp.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ ye.createElement(kX.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function ZJ(r) {
  let {
    routeContext: e,
    match: t,
    children: n
  } = r, i = ye.useContext(wB);
  return i && i.static && i.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ ye.createElement(fp.Provider, {
    value: e
  }, n);
}
function wJ(r, e, t, n) {
  var i;
  if (e === void 0 && (e = []), t === void 0 && (t = null), n === void 0 && (n = null), r == null) {
    var o;
    if (!t)
      return null;
    if (t.errors)
      r = t.matches;
    else if ((o = n) != null && o.v7_partialHydration && e.length === 0 && !t.initialized && t.matches.length > 0)
      r = t.matches;
    else
      return null;
  }
  let l = r, u = (i = t) == null ? void 0 : i.errors;
  if (u != null) {
    let f = l.findIndex((v) => v.route.id && u?.[v.route.id] !== void 0);
    f >= 0 || (Qr.NODE_ENV !== "production" ? Mi(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(u).join(",")) : Mi(!1)), l = l.slice(0, Math.min(l.length, f + 1));
  }
  let I = !1, C = -1;
  if (t && n && n.v7_partialHydration)
    for (let f = 0; f < l.length; f++) {
      let v = l[f];
      if ((v.route.HydrateFallback || v.route.hydrateFallbackElement) && (C = f), v.route.id) {
        let {
          loaderData: b,
          errors: S
        } = t, R = v.route.loader && b[v.route.id] === void 0 && (!S || S[v.route.id] === void 0);
        if (v.route.lazy || R) {
          I = !0, C >= 0 ? l = l.slice(0, C + 1) : l = [l[0]];
          break;
        }
      }
    }
  return l.reduceRight((f, v, b) => {
    let S, R = !1, W = null, x = null;
    t && (S = u && v.route.id ? u[v.route.id] : void 0, W = v.route.errorElement || BJ, I && (C < 0 && b === 0 ? (Hz("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), R = !0, x = null) : C === b && (R = !0, x = v.route.hydrateFallbackElement || null)));
    let N = e.concat(l.slice(0, b + 1)), Y = () => {
      let F;
      return S ? F = W : R ? F = x : v.route.Component ? F = /* @__PURE__ */ ye.createElement(v.route.Component, null) : v.route.element ? F = v.route.element : F = f, /* @__PURE__ */ ye.createElement(ZJ, {
        match: v,
        routeContext: {
          outlet: f,
          matches: N,
          isDataRoute: t != null
        },
        children: F
      });
    };
    return t && (v.route.ErrorBoundary || v.route.errorElement || b === 0) ? /* @__PURE__ */ ye.createElement(SJ, {
      location: t.location,
      revalidation: t.revalidation,
      component: W,
      error: S,
      children: Y(),
      routeContext: {
        outlet: null,
        matches: N,
        isDataRoute: !0
      }
    }) : Y();
  }, null);
}
var Mz = /* @__PURE__ */ function(r) {
  return r.UseBlocker = "useBlocker", r.UseRevalidator = "useRevalidator", r.UseNavigateStable = "useNavigate", r;
}(Mz || {}), fw = /* @__PURE__ */ function(r) {
  return r.UseBlocker = "useBlocker", r.UseLoaderData = "useLoaderData", r.UseActionData = "useActionData", r.UseRouteError = "useRouteError", r.UseNavigation = "useNavigation", r.UseRouteLoaderData = "useRouteLoaderData", r.UseMatches = "useMatches", r.UseRevalidator = "useRevalidator", r.UseNavigateStable = "useNavigate", r.UseRouteId = "useRouteId", r;
}(fw || {});
function DX(r) {
  return r + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function RJ(r) {
  let e = ye.useContext(wB);
  return e || (Qr.NODE_ENV !== "production" ? Mi(!1, DX(r)) : Mi(!1)), e;
}
function xJ(r) {
  let e = ye.useContext(wW);
  return e || (Qr.NODE_ENV !== "production" ? Mi(!1, DX(r)) : Mi(!1)), e;
}
function WJ(r) {
  let e = ye.useContext(fp);
  return e || (Qr.NODE_ENV !== "production" ? Mi(!1, DX(r)) : Mi(!1)), e;
}
function UX(r) {
  let e = WJ(r), t = e.matches[e.matches.length - 1];
  return t.route.id || (Qr.NODE_ENV !== "production" ? Mi(!1, r + ' can only be used on routes that contain a unique "id"') : Mi(!1)), t.route.id;
}
function VJ() {
  return UX(fw.UseRouteId);
}
function NJ() {
  var r;
  let e = ye.useContext(kX), t = xJ(fw.UseRouteError), n = UX(fw.UseRouteError);
  return e !== void 0 ? e : (r = t.errors) == null ? void 0 : r[n];
}
function MJ() {
  let {
    router: r
  } = RJ(Mz.UseNavigateStable), e = UX(fw.UseNavigateStable), t = ye.useRef(!1);
  return Nz(() => {
    t.current = !0;
  }), ye.useCallback(function(i, o) {
    o === void 0 && (o = {}), Qr.NODE_ENV !== "production" && fl(t.current, Vz), t.current && (typeof i == "number" ? r.navigate(i) : r.navigate(i, G2({
      fromRouteId: e
    }, o)));
  }, [r, e]);
}
const MT = {};
function Hz(r, e, t) {
  !e && !MT[r] && (MT[r] = !0, Qr.NODE_ENV !== "production" && fl(!1, t));
}
const HT = {};
function HJ(r, e) {
  Qr.NODE_ENV !== "production" && !HT[e] && (HT[e] = !0, console.warn(e));
}
const yG = (r, e, t) => HJ(r, " React Router Future Flag Warning: " + e + ". " + ("You can use the `" + r + "` future flag to opt-in early. ") + ("For more information, see " + t + "."));
function XJ(r, e) {
  r?.v7_startTransition === void 0 && yG("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition"), r?.v7_relativeSplatPath === void 0 && (!e || !e.v7_relativeSplatPath) && yG("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath"), e && (e.v7_fetcherPersist === void 0 && yG("v7_fetcherPersist", "The persistence behavior of fetchers is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist"), e.v7_normalizeFormMethod === void 0 && yG("v7_normalizeFormMethod", "Casing of `formMethod` fields is being normalized to uppercase in v7", "https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod"), e.v7_partialHydration === void 0 && yG("v7_partialHydration", "`RouterProvider` hydration behavior is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_partialhydration"), e.v7_skipActionErrorRevalidation === void 0 && yG("v7_skipActionErrorRevalidation", "The revalidation behavior after 4xx/5xx `action` responses is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation"));
}
function YJ(r) {
  let {
    to: e,
    replace: t,
    state: n,
    relative: i
  } = r;
  RB() || (Qr.NODE_ENV !== "production" ? Mi(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : Mi(!1));
  let {
    future: o,
    static: l
  } = ye.useContext(jC);
  Qr.NODE_ENV !== "production" && fl(!l, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let {
    matches: u
  } = ye.useContext(fp), {
    pathname: I
  } = rd(), C = Wb(), f = ZW(e, SW(u, o.v7_relativeSplatPath), I, i === "path"), v = JSON.stringify(f);
  return ye.useEffect(() => C(JSON.parse(v), {
    replace: t,
    state: n,
    relative: i
  }), [C, v, i, t, n]), null;
}
function FJ(r) {
  let {
    basename: e = "/",
    children: t = null,
    location: n,
    navigationType: i = zl.Pop,
    navigator: o,
    static: l = !1,
    future: u
  } = r;
  RB() && (Qr.NODE_ENV !== "production" ? Mi(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : Mi(!1));
  let I = e.replace(/^\/*/, "/"), C = ye.useMemo(() => ({
    basename: I,
    navigator: o,
    static: l,
    future: G2({
      v7_relativeSplatPath: !1
    }, u)
  }), [I, u, o, l]);
  typeof n == "string" && (n = qm(n));
  let {
    pathname: f = "/",
    search: v = "",
    hash: b = "",
    state: S = null,
    key: R = "default"
  } = n, W = ye.useMemo(() => {
    let x = tf(f, I);
    return x == null ? null : {
      location: {
        pathname: x,
        search: v,
        hash: b,
        state: S,
        key: R
      },
      navigationType: i
    };
  }, [I, f, v, b, S, R, i]);
  return Qr.NODE_ENV !== "production" && fl(W != null, '<Router basename="' + I + '"> is not able to match the URL ' + ('"' + f + v + b + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), W == null ? null : /* @__PURE__ */ ye.createElement(jC.Provider, {
    value: C
  }, /* @__PURE__ */ ye.createElement(RW.Provider, {
    children: t,
    value: W
  }));
}
new Promise(() => {
});
function EJ(r) {
  let e = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: r.ErrorBoundary != null || r.errorElement != null
  };
  return r.Component && (Qr.NODE_ENV !== "production" && r.element && Qr.NODE_ENV !== "production" && fl(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(e, {
    element: /* @__PURE__ */ ye.createElement(r.Component),
    Component: void 0
  })), r.HydrateFallback && (Qr.NODE_ENV !== "production" && r.hydrateFallbackElement && Qr.NODE_ENV !== "production" && fl(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."), Object.assign(e, {
    hydrateFallbackElement: /* @__PURE__ */ ye.createElement(r.HydrateFallback),
    HydrateFallback: void 0
  })), r.ErrorBoundary && (Qr.NODE_ENV !== "production" && r.errorElement && Qr.NODE_ENV !== "production" && fl(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(e, {
    errorElement: /* @__PURE__ */ ye.createElement(r.ErrorBoundary),
    ErrorBoundary: void 0
  })), e;
}
var qC = {};
function yv() {
  return yv = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, yv.apply(this, arguments);
}
function OX(r, e) {
  if (r == null) return {};
  var t = {}, n = Object.keys(r), i, o;
  for (o = 0; o < n.length; o++)
    i = n[o], !(e.indexOf(i) >= 0) && (t[i] = r[i]);
  return t;
}
const u2 = "get", c2 = "application/x-www-form-urlencoded";
function xW(r) {
  return r != null && typeof r.tagName == "string";
}
function TJ(r) {
  return xW(r) && r.tagName.toLowerCase() === "button";
}
function _J(r) {
  return xW(r) && r.tagName.toLowerCase() === "form";
}
function zJ(r) {
  return xW(r) && r.tagName.toLowerCase() === "input";
}
function KJ(r) {
  return !!(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey);
}
function LJ(r, e) {
  return r.button === 0 && // Ignore everything but left clicks
  (!e || e === "_self") && // Let browser handle "target=_blank" etc.
  !KJ(r);
}
function zH(r) {
  return r === void 0 && (r = ""), new URLSearchParams(typeof r == "string" || Array.isArray(r) || r instanceof URLSearchParams ? r : Object.keys(r).reduce((e, t) => {
    let n = r[t];
    return e.concat(Array.isArray(n) ? n.map((i) => [t, i]) : [[t, n]]);
  }, []));
}
function kJ(r, e) {
  let t = zH(r);
  return e && e.forEach((n, i) => {
    t.has(i) || e.getAll(i).forEach((o) => {
      t.append(i, o);
    });
  }), t;
}
let t1 = null;
function DJ() {
  if (t1 === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), t1 = !1;
    } catch {
      t1 = !0;
    }
  return t1;
}
const UJ = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function AM(r) {
  return r != null && !UJ.has(r) ? (qC.NODE_ENV !== "production" && fl(!1, '"' + r + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + c2 + '"')), null) : r;
}
function OJ(r, e) {
  let t, n, i, o, l;
  if (_J(r)) {
    let u = r.getAttribute("action");
    n = u ? tf(u, e) : null, t = r.getAttribute("method") || u2, i = AM(r.getAttribute("enctype")) || c2, o = new FormData(r);
  } else if (TJ(r) || zJ(r) && (r.type === "submit" || r.type === "image")) {
    let u = r.form;
    if (u == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let I = r.getAttribute("formaction") || u.getAttribute("action");
    if (n = I ? tf(I, e) : null, t = r.getAttribute("formmethod") || u.getAttribute("method") || u2, i = AM(r.getAttribute("formenctype")) || AM(u.getAttribute("enctype")) || c2, o = new FormData(u, r), !DJ()) {
      let {
        name: C,
        type: f,
        value: v
      } = r;
      if (f === "image") {
        let b = C ? C + "." : "";
        o.append(b + "x", "0"), o.append(b + "y", "0");
      } else C && o.append(C, v);
    }
  } else {
    if (xW(r))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    t = u2, n = null, i = c2, l = r;
  }
  return o && i === "text/plain" && (l = o, o = void 0), {
    action: n,
    method: t.toLowerCase(),
    encType: i,
    formData: o,
    body: l
  };
}
const PJ = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], JJ = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], QJ = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"], jJ = "6";
try {
  window.__reactRouterVersion = jJ;
} catch {
}
function qJ(r, e) {
  return $P({
    basename: e?.basename,
    future: yv({}, e?.future, {
      v7_prependBasename: !0
    }),
    history: GP({
      window: e?.window
    }),
    hydrationData: e?.hydrationData || $J(),
    routes: r,
    mapRouteProperties: EJ,
    dataStrategy: e?.dataStrategy,
    patchRoutesOnNavigation: e?.patchRoutesOnNavigation,
    window: e?.window
  }).initialize();
}
function $J() {
  var r;
  let e = (r = window) == null ? void 0 : r.__staticRouterHydrationData;
  return e && e.errors && (e = yv({}, e, {
    errors: eQ(e.errors)
  })), e;
}
function eQ(r) {
  if (!r) return null;
  let e = Object.entries(r), t = {};
  for (let [n, i] of e)
    if (i && i.__type === "RouteErrorResponse")
      t[n] = new b2(i.status, i.statusText, i.data, i.internal === !0);
    else if (i && i.__type === "Error") {
      if (i.__subType) {
        let o = window[i.__subType];
        if (typeof o == "function")
          try {
            let l = new o(i.message);
            l.stack = "", t[n] = l;
          } catch {
          }
      }
      if (t[n] == null) {
        let o = new Error(i.message);
        o.stack = "", t[n] = o;
      }
    } else
      t[n] = i;
  return t;
}
const PX = /* @__PURE__ */ ye.createContext({
  isTransitioning: !1
});
qC.NODE_ENV !== "production" && (PX.displayName = "ViewTransition");
const Xz = /* @__PURE__ */ ye.createContext(/* @__PURE__ */ new Map());
qC.NODE_ENV !== "production" && (Xz.displayName = "Fetchers");
const tQ = "startTransition", XT = CP[tQ], nQ = "flushSync", YT = bP[nQ];
function iQ(r) {
  XT ? XT(r) : r();
}
function yZ(r) {
  YT ? YT(r) : r();
}
class rQ {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, t) => {
      this.resolve = (n) => {
        this.status === "pending" && (this.status = "resolved", e(n));
      }, this.reject = (n) => {
        this.status === "pending" && (this.status = "rejected", t(n));
      };
    });
  }
}
function aQ(r) {
  let {
    fallbackElement: e,
    router: t,
    future: n
  } = r, [i, o] = ye.useState(t.state), [l, u] = ye.useState(), [I, C] = ye.useState({
    isTransitioning: !1
  }), [f, v] = ye.useState(), [b, S] = ye.useState(), [R, W] = ye.useState(), x = ye.useRef(/* @__PURE__ */ new Map()), {
    v7_startTransition: N
  } = n || {}, Y = ye.useCallback((j) => {
    N ? iQ(j) : j();
  }, [N]), F = ye.useCallback((j, J) => {
    let {
      deletedFetchers: O,
      flushSync: ne,
      viewTransitionOpts: he
    } = J;
    j.fetchers.forEach((Ae, ke) => {
      Ae.data !== void 0 && x.current.set(ke, Ae.data);
    }), O.forEach((Ae) => x.current.delete(Ae));
    let pe = t.window == null || t.window.document == null || typeof t.window.document.startViewTransition != "function";
    if (!he || pe) {
      ne ? yZ(() => o(j)) : Y(() => o(j));
      return;
    }
    if (ne) {
      yZ(() => {
        b && (f && f.resolve(), b.skipTransition()), C({
          isTransitioning: !0,
          flushSync: !0,
          currentLocation: he.currentLocation,
          nextLocation: he.nextLocation
        });
      });
      let Ae = t.window.document.startViewTransition(() => {
        yZ(() => o(j));
      });
      Ae.finished.finally(() => {
        yZ(() => {
          v(void 0), S(void 0), u(void 0), C({
            isTransitioning: !1
          });
        });
      }), yZ(() => S(Ae));
      return;
    }
    b ? (f && f.resolve(), b.skipTransition(), W({
      state: j,
      currentLocation: he.currentLocation,
      nextLocation: he.nextLocation
    })) : (u(j), C({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: he.currentLocation,
      nextLocation: he.nextLocation
    }));
  }, [t.window, b, f, x, Y]);
  ye.useLayoutEffect(() => t.subscribe(F), [t, F]), ye.useEffect(() => {
    I.isTransitioning && !I.flushSync && v(new rQ());
  }, [I]), ye.useEffect(() => {
    if (f && l && t.window) {
      let j = l, J = f.promise, O = t.window.document.startViewTransition(async () => {
        Y(() => o(j)), await J;
      });
      O.finished.finally(() => {
        v(void 0), S(void 0), u(void 0), C({
          isTransitioning: !1
        });
      }), S(O);
    }
  }, [Y, l, f, t.window]), ye.useEffect(() => {
    f && l && i.location.key === l.location.key && f.resolve();
  }, [f, b, i.location, l]), ye.useEffect(() => {
    !I.isTransitioning && R && (u(R.state), C({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: R.currentLocation,
      nextLocation: R.nextLocation
    }), W(void 0));
  }, [I.isTransitioning, R]), ye.useEffect(() => {
    qC.NODE_ENV !== "production" && fl(e == null || !t.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
  }, []);
  let T = ye.useMemo(() => ({
    createHref: t.createHref,
    encodeLocation: t.encodeLocation,
    go: (j) => t.navigate(j),
    push: (j, J, O) => t.navigate(j, {
      state: J,
      preventScrollReset: O?.preventScrollReset
    }),
    replace: (j, J, O) => t.navigate(j, {
      replace: !0,
      state: J,
      preventScrollReset: O?.preventScrollReset
    })
  }), [t]), P = t.basename || "/", D = ye.useMemo(() => ({
    router: t,
    navigator: T,
    static: !1,
    basename: P
  }), [t, T, P]), L = ye.useMemo(() => ({
    v7_relativeSplatPath: t.future.v7_relativeSplatPath
  }), [t.future.v7_relativeSplatPath]);
  return ye.useEffect(() => XJ(n, t.future), [n, t.future]), /* @__PURE__ */ ye.createElement(ye.Fragment, null, /* @__PURE__ */ ye.createElement(wB.Provider, {
    value: D
  }, /* @__PURE__ */ ye.createElement(wW.Provider, {
    value: i
  }, /* @__PURE__ */ ye.createElement(Xz.Provider, {
    value: x.current
  }, /* @__PURE__ */ ye.createElement(PX.Provider, {
    value: I
  }, /* @__PURE__ */ ye.createElement(FJ, {
    basename: P,
    location: i.location,
    navigationType: i.historyAction,
    navigator: T,
    future: L
  }, i.initialized || t.future.v7_partialHydration ? /* @__PURE__ */ ye.createElement(oQ, {
    routes: t.routes,
    future: t.future,
    state: i
  }) : e))))), null);
}
const oQ = /* @__PURE__ */ ye.memo(sQ);
function sQ(r) {
  let {
    routes: e,
    future: t,
    state: n
  } = r;
  return bJ(e, void 0, n, t);
}
const lQ = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", uQ = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, JX = /* @__PURE__ */ ye.forwardRef(function(e, t) {
  let {
    onClick: n,
    relative: i,
    reloadDocument: o,
    replace: l,
    state: u,
    target: I,
    to: C,
    preventScrollReset: f,
    viewTransition: v
  } = e, b = OX(e, PJ), {
    basename: S
  } = ye.useContext(jC), R, W = !1;
  if (typeof C == "string" && uQ.test(C) && (R = C, lQ))
    try {
      let F = new URL(window.location.href), T = C.startsWith("//") ? new URL(F.protocol + C) : new URL(C), P = tf(T.pathname, S);
      T.origin === F.origin && P != null ? C = P + T.search + T.hash : W = !0;
    } catch {
      qC.NODE_ENV !== "production" && fl(!1, '<Link to="' + C + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let x = vJ(C, {
    relative: i
  }), N = IQ(C, {
    replace: l,
    state: u,
    target: I,
    preventScrollReset: f,
    relative: i,
    viewTransition: v
  });
  function Y(F) {
    n && n(F), F.defaultPrevented || N(F);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ ye.createElement("a", yv({}, b, {
      href: R || x,
      onClick: W || o ? n : Y,
      ref: t,
      target: I
    }))
  );
});
qC.NODE_ENV !== "production" && (JX.displayName = "Link");
const cQ = /* @__PURE__ */ ye.forwardRef(function(e, t) {
  let {
    "aria-current": n = "page",
    caseSensitive: i = !1,
    className: o = "",
    end: l = !1,
    style: u,
    to: I,
    viewTransition: C,
    children: f
  } = e, v = OX(e, JJ), b = Jw(I, {
    relative: v.relative
  }), S = rd(), R = ye.useContext(wW), {
    navigator: W,
    basename: x
  } = ye.useContext(jC), N = R != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  AQ(b) && C === !0, Y = W.encodeLocation ? W.encodeLocation(b).pathname : b.pathname, F = S.pathname, T = R && R.navigation && R.navigation.location ? R.navigation.location.pathname : null;
  i || (F = F.toLowerCase(), T = T ? T.toLowerCase() : null, Y = Y.toLowerCase()), T && x && (T = tf(T, x) || T);
  const P = Y !== "/" && Y.endsWith("/") ? Y.length - 1 : Y.length;
  let D = F === Y || !l && F.startsWith(Y) && F.charAt(P) === "/", L = T != null && (T === Y || !l && T.startsWith(Y) && T.charAt(Y.length) === "/"), j = {
    isActive: D,
    isPending: L,
    isTransitioning: N
  }, J = D ? n : void 0, O;
  typeof o == "function" ? O = o(j) : O = [o, D ? "active" : null, L ? "pending" : null, N ? "transitioning" : null].filter(Boolean).join(" ");
  let ne = typeof u == "function" ? u(j) : u;
  return /* @__PURE__ */ ye.createElement(JX, yv({}, v, {
    "aria-current": J,
    className: O,
    ref: t,
    style: ne,
    to: I,
    viewTransition: C
  }), typeof f == "function" ? f(j) : f);
});
qC.NODE_ENV !== "production" && (cQ.displayName = "NavLink");
const gQ = /* @__PURE__ */ ye.forwardRef((r, e) => {
  let {
    fetcherKey: t,
    navigate: n,
    reloadDocument: i,
    replace: o,
    state: l,
    method: u = u2,
    action: I,
    onSubmit: C,
    relative: f,
    preventScrollReset: v,
    viewTransition: b
  } = r, S = OX(r, QJ), R = pQ(), W = mQ(I, {
    relative: f
  }), x = u.toLowerCase() === "get" ? "get" : "post", N = (Y) => {
    if (C && C(Y), Y.defaultPrevented) return;
    Y.preventDefault();
    let F = Y.nativeEvent.submitter, T = F?.getAttribute("formmethod") || u;
    R(F || Y.currentTarget, {
      fetcherKey: t,
      method: T,
      navigate: n,
      replace: o,
      state: l,
      relative: f,
      preventScrollReset: v,
      viewTransition: b
    });
  };
  return /* @__PURE__ */ ye.createElement("form", yv({
    ref: e,
    method: x,
    action: W,
    onSubmit: i ? C : N
  }, S));
});
qC.NODE_ENV !== "production" && (gQ.displayName = "Form");
var B2;
(function(r) {
  r.UseScrollRestoration = "useScrollRestoration", r.UseSubmit = "useSubmit", r.UseSubmitFetcher = "useSubmitFetcher", r.UseFetcher = "useFetcher", r.useViewTransitionState = "useViewTransitionState";
})(B2 || (B2 = {}));
var FT;
(function(r) {
  r.UseFetcher = "useFetcher", r.UseFetchers = "useFetchers", r.UseScrollRestoration = "useScrollRestoration";
})(FT || (FT = {}));
function dQ(r) {
  return r + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function Yz(r) {
  let e = ye.useContext(wB);
  return e || (qC.NODE_ENV !== "production" ? Mi(!1, dQ(r)) : Mi(!1)), e;
}
function IQ(r, e) {
  let {
    target: t,
    replace: n,
    state: i,
    preventScrollReset: o,
    relative: l,
    viewTransition: u
  } = e === void 0 ? {} : e, I = Wb(), C = rd(), f = Jw(r, {
    relative: l
  });
  return ye.useCallback((v) => {
    if (LJ(v, t)) {
      v.preventDefault();
      let b = n !== void 0 ? n : vv(C) === vv(f);
      I(r, {
        replace: b,
        state: i,
        preventScrollReset: o,
        relative: l,
        viewTransition: u
      });
    }
  }, [C, I, f, n, i, t, r, o, l, u]);
}
function Fz(r) {
  qC.NODE_ENV !== "production" && fl(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.");
  let e = ye.useRef(zH(r)), t = ye.useRef(!1), n = rd(), i = ye.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    kJ(n.search, t.current ? null : e.current)
  ), [n.search]), o = Wb(), l = ye.useCallback((u, I) => {
    const C = zH(typeof u == "function" ? u(i) : u);
    t.current = !0, o("?" + C, I);
  }, [o, i]);
  return [i, l];
}
function CQ() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let hQ = 0, fQ = () => "__" + String(++hQ) + "__";
function pQ() {
  let {
    router: r
  } = Yz(B2.UseSubmit), {
    basename: e
  } = ye.useContext(jC), t = VJ();
  return ye.useCallback(function(n, i) {
    i === void 0 && (i = {}), CQ();
    let {
      action: o,
      method: l,
      encType: u,
      formData: I,
      body: C
    } = OJ(n, e);
    if (i.navigate === !1) {
      let f = i.fetcherKey || fQ();
      r.fetch(f, t, i.action || o, {
        preventScrollReset: i.preventScrollReset,
        formData: I,
        body: C,
        formMethod: i.method || l,
        formEncType: i.encType || u,
        flushSync: i.flushSync
      });
    } else
      r.navigate(i.action || o, {
        preventScrollReset: i.preventScrollReset,
        formData: I,
        body: C,
        formMethod: i.method || l,
        formEncType: i.encType || u,
        replace: i.replace,
        state: i.state,
        fromRouteId: t,
        flushSync: i.flushSync,
        viewTransition: i.viewTransition
      });
  }, [r, e, t]);
}
function mQ(r, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    basename: n
  } = ye.useContext(jC), i = ye.useContext(fp);
  i || (qC.NODE_ENV !== "production" ? Mi(!1, "useFormAction must be used inside a RouteContext") : Mi(!1));
  let [o] = i.matches.slice(-1), l = yv({}, Jw(r || ".", {
    relative: t
  })), u = rd();
  if (r == null) {
    l.search = u.search;
    let I = new URLSearchParams(l.search), C = I.getAll("index");
    if (C.some((v) => v === "")) {
      I.delete("index"), C.filter((b) => b).forEach((b) => I.append("index", b));
      let v = I.toString();
      l.search = v ? "?" + v : "";
    }
  }
  return (!r || r === ".") && o.route.index && (l.search = l.search ? l.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (l.pathname = l.pathname === "/" ? n : up([n, l.pathname])), vv(l);
}
function AQ(r, e) {
  e === void 0 && (e = {});
  let t = ye.useContext(PX);
  t == null && (qC.NODE_ENV !== "production" ? Mi(!1, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : Mi(!1));
  let {
    basename: n
  } = Yz(B2.useViewTransitionState), i = Jw(r, {
    relative: e.relative
  });
  if (!t.isTransitioning)
    return !1;
  let o = tf(t.currentLocation.pathname, n) || t.currentLocation.pathname, l = tf(t.nextLocation.pathname, n) || t.nextLocation.pathname;
  return y2(i.pathname, l) != null || y2(i.pathname, o) != null;
}
function pw() {
  return pw = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, pw.apply(null, arguments);
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const WW = "167", qy = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, $y = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, Ez = 0, KH = 1, Tz = 2, vQ = 3, _z = 0, VW = 1, QZ = 2, qh = 3, Um = 0, td = 1, ip = 2, Dm = 0, Cb = 1, LH = 2, kH = 3, DH = 4, zz = 5, gv = 100, Kz = 101, Lz = 102, kz = 103, Dz = 104, Uz = 200, Oz = 201, Pz = 202, Jz = 203, S2 = 204, Z2 = 205, Qz = 206, jz = 207, qz = 208, $z = 209, eK = 210, tK = 211, nK = 212, iK = 213, rK = 214, aK = 0, oK = 1, sK = 2, mw = 3, lK = 4, uK = 5, cK = 6, gK = 7, Qw = 0, dK = 1, IK = 2, cp = 0, CK = 1, hK = 2, fK = 3, QX = 4, pK = 5, mK = 6, AK = 7, UH = "attached", vK = "detached", NW = 300, Om = 301, bv = 302, Aw = 303, vw = 304, xB = 306, yw = 1e3, PC = 1001, bw = 1002, Lu = 1003, jX = 1004, yQ = 1004, qG = 1005, bQ = 1005, Ks = 1006, jZ = 1007, GQ = 1007, ap = 1008, BQ = 1008, nf = 1009, qX = 1010, $X = 1011, CB = 1012, MW = 1013, Pm = 1014, ed = 1015, Vb = 1016, HW = 1017, XW = 1018, Bb = 1020, eY = 35902, tY = 1021, nY = 1022, cg = 1023, iY = 1024, rY = 1025, hb = 1026, Sb = 1027, YW = 1028, jw = 1029, aY = 1030, FW = 1031, SQ = 1032, EW = 1033, qZ = 33776, $Z = 33777, ew = 33778, tw = 33779, w2 = 35840, R2 = 35841, x2 = 35842, W2 = 35843, V2 = 36196, N2 = 37492, M2 = 37496, H2 = 37808, X2 = 37809, Y2 = 37810, F2 = 37811, E2 = 37812, T2 = 37813, _2 = 37814, z2 = 37815, K2 = 37816, L2 = 37817, k2 = 37818, D2 = 37819, U2 = 37820, O2 = 37821, nw = 36492, P2 = 36494, J2 = 36495, oY = 36283, Q2 = 36284, j2 = 36285, q2 = 36286, yK = 2200, bK = 2201, GK = 2202, Gw = 2300, $2 = 2301, g2 = 2302, ub = 2400, cb = 2401, Bw = 2402, TW = 2500, sY = 2501, ZQ = 0, wQ = 1, RQ = 2, BK = 3200, SK = 3201, xQ = 3202, WQ = 3203, Zv = 0, ZK = 1, _m = "", OC = "srgb", $m = "srgb-linear", _W = "display-p3", qw = "display-p3-linear", Sw = "linear", Ho = "srgb", Zw = "rec709", ww = "p3", VQ = 0, eb = 7680, NQ = 7681, MQ = 7682, HQ = 7683, XQ = 34055, YQ = 34056, FQ = 5386, EQ = 512, TQ = 513, _Q = 514, zQ = 515, KQ = 516, LQ = 517, kQ = 518, OH = 519, wK = 512, RK = 513, xK = 514, lY = 515, WK = 516, VK = 517, NK = 518, MK = 519, Rw = 35044, HK = 35048, DQ = 35040, UQ = 35045, OQ = 35049, PQ = 35041, JQ = 35046, QQ = 35050, jQ = 35042, qQ = "100", PH = "300 es", op = 2e3, xw = 2001;
let eA = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let o = 0, l = i.length; o < l; o++)
        i[o].call(this, e);
      e.target = null;
    }
  }
};
const eg = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let ET = 1234567;
const fb = Math.PI / 180, hB = 180 / Math.PI;
function PI() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (eg[r & 255] + eg[r >> 8 & 255] + eg[r >> 16 & 255] + eg[r >> 24 & 255] + "-" + eg[e & 255] + eg[e >> 8 & 255] + "-" + eg[e >> 16 & 15 | 64] + eg[e >> 24 & 255] + "-" + eg[t & 63 | 128] + eg[t >> 8 & 255] + "-" + eg[t >> 16 & 255] + eg[t >> 24 & 255] + eg[n & 255] + eg[n >> 8 & 255] + eg[n >> 16 & 255] + eg[n >> 24 & 255]).toLowerCase();
}
function zs(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function uY(r, e) {
  return (r % e + e) % e;
}
function $Q(r, e, t, n, i) {
  return n + (r - e) * (i - n) / (t - e);
}
function e4(r, e, t) {
  return r !== e ? (t - r) / (e - r) : 0;
}
function iw(r, e, t) {
  return (1 - t) * r + t * e;
}
function t4(r, e, t, n) {
  return iw(r, e, 1 - Math.exp(-t * n));
}
function n4(r, e = 1) {
  return e - Math.abs(uY(r, e * 2) - e);
}
function i4(r, e, t) {
  return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * (3 - 2 * r));
}
function r4(r, e, t) {
  return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function a4(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function o4(r, e) {
  return r + Math.random() * (e - r);
}
function s4(r) {
  return r * (0.5 - Math.random());
}
function l4(r) {
  r !== void 0 && (ET = r);
  let e = ET += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function u4(r) {
  return r * fb;
}
function c4(r) {
  return r * hB;
}
function g4(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function d4(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function I4(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function C4(r, e, t, n, i) {
  const o = Math.cos, l = Math.sin, u = o(t / 2), I = l(t / 2), C = o((e + n) / 2), f = l((e + n) / 2), v = o((e - n) / 2), b = l((e - n) / 2), S = o((n - e) / 2), R = l((n - e) / 2);
  switch (i) {
    case "XYX":
      r.set(u * f, I * v, I * b, u * C);
      break;
    case "YZY":
      r.set(I * b, u * f, I * v, u * C);
      break;
    case "ZXZ":
      r.set(I * v, I * b, u * f, u * C);
      break;
    case "XZX":
      r.set(u * f, I * R, I * S, u * C);
      break;
    case "YXY":
      r.set(I * S, u * f, I * R, u * C);
      break;
    case "ZYZ":
      r.set(I * R, I * S, u * f, u * C);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function qg(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function hr(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const h4 = {
  DEG2RAD: fb,
  RAD2DEG: hB,
  generateUUID: PI,
  clamp: zs,
  euclideanModulo: uY,
  mapLinear: $Q,
  inverseLerp: e4,
  lerp: iw,
  damp: t4,
  pingpong: n4,
  smoothstep: i4,
  smootherstep: r4,
  randInt: a4,
  randFloat: o4,
  randFloatSpread: s4,
  seededRandom: l4,
  degToRad: u4,
  radToDeg: c4,
  isPowerOfTwo: g4,
  ceilPowerOfTwo: d4,
  floorPowerOfTwo: I4,
  setQuaternionFromProperEuler: C4,
  normalize: hr,
  denormalize: qg
};
class Lt {
  constructor(e = 0, t = 0) {
    Lt.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(zs(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), i = Math.sin(t), o = this.x - e.x, l = this.y - e.y;
    return this.x = o * n - l * i + e.x, this.y = o * i + l * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Cr {
  constructor(e, t, n, i, o, l, u, I, C) {
    Cr.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, o, l, u, I, C);
  }
  set(e, t, n, i, o, l, u, I, C) {
    const f = this.elements;
    return f[0] = e, f[1] = i, f[2] = u, f[3] = t, f[4] = o, f[5] = I, f[6] = n, f[7] = l, f[8] = C, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, o = this.elements, l = n[0], u = n[3], I = n[6], C = n[1], f = n[4], v = n[7], b = n[2], S = n[5], R = n[8], W = i[0], x = i[3], N = i[6], Y = i[1], F = i[4], T = i[7], P = i[2], D = i[5], L = i[8];
    return o[0] = l * W + u * Y + I * P, o[3] = l * x + u * F + I * D, o[6] = l * N + u * T + I * L, o[1] = C * W + f * Y + v * P, o[4] = C * x + f * F + v * D, o[7] = C * N + f * T + v * L, o[2] = b * W + S * Y + R * P, o[5] = b * x + S * F + R * D, o[8] = b * N + S * T + R * L, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], u = e[5], I = e[6], C = e[7], f = e[8];
    return t * l * f - t * u * C - n * o * f + n * u * I + i * o * C - i * l * I;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], u = e[5], I = e[6], C = e[7], f = e[8], v = f * l - u * C, b = u * I - f * o, S = C * o - l * I, R = t * v + n * b + i * S;
    if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const W = 1 / R;
    return e[0] = v * W, e[1] = (i * C - f * n) * W, e[2] = (u * n - i * l) * W, e[3] = b * W, e[4] = (f * t - i * I) * W, e[5] = (i * o - u * t) * W, e[6] = S * W, e[7] = (n * I - C * t) * W, e[8] = (l * t - n * o) * W, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, i, o, l, u) {
    const I = Math.cos(o), C = Math.sin(o);
    return this.set(
      n * I,
      n * C,
      -n * (I * l + C * u) + l + e,
      -i * C,
      i * I,
      -i * (-C * l + I * u) + u + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(vM.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(vM.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(vM.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const vM = /* @__PURE__ */ new Cr();
function XK(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
const f4 = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function $G(r, e) {
  return new f4[r](e);
}
function Ww(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function YK() {
  const r = Ww("canvas");
  return r.style.display = "block", r;
}
const TT = {};
function oB(r) {
  r in TT || (TT[r] = !0, console.warn(r));
}
function p4(r, e, t) {
  return new Promise(function(n, i) {
    function o() {
      switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          i();
          break;
        case r.TIMEOUT_EXPIRED:
          setTimeout(o, t);
          break;
        default:
          n();
      }
    }
    setTimeout(o, t);
  });
}
const _T = /* @__PURE__ */ new Cr().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), zT = /* @__PURE__ */ new Cr().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), bZ = {
  [$m]: {
    transfer: Sw,
    primaries: Zw,
    luminanceCoefficients: [0.2126, 0.7152, 0.0722],
    toReference: (r) => r,
    fromReference: (r) => r
  },
  [OC]: {
    transfer: Ho,
    primaries: Zw,
    luminanceCoefficients: [0.2126, 0.7152, 0.0722],
    toReference: (r) => r.convertSRGBToLinear(),
    fromReference: (r) => r.convertLinearToSRGB()
  },
  [qw]: {
    transfer: Sw,
    primaries: ww,
    luminanceCoefficients: [0.2289, 0.6917, 0.0793],
    toReference: (r) => r.applyMatrix3(zT),
    fromReference: (r) => r.applyMatrix3(_T)
  },
  [_W]: {
    transfer: Ho,
    primaries: ww,
    luminanceCoefficients: [0.2289, 0.6917, 0.0793],
    toReference: (r) => r.convertSRGBToLinear().applyMatrix3(zT),
    fromReference: (r) => r.applyMatrix3(_T).convertLinearToSRGB()
  }
}, m4 = /* @__PURE__ */ new Set([$m, qw]), ya = {
  enabled: !0,
  _workingColorSpace: $m,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(r) {
    if (!m4.has(r))
      throw new Error(`Unsupported working color space, "${r}".`);
    this._workingColorSpace = r;
  },
  convert: function(r, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return r;
    const n = bZ[e].toReference, i = bZ[t].fromReference;
    return i(n(r));
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this._workingColorSpace);
  },
  getPrimaries: function(r) {
    return bZ[r].primaries;
  },
  getTransfer: function(r) {
    return r === _m ? Sw : bZ[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this._workingColorSpace) {
    return r.fromArray(bZ[e].luminanceCoefficients);
  }
};
function sB(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function yM(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
let bG;
class FK {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      bG === void 0 && (bG = Ww("canvas")), bG.width = e.width, bG.height = e.height;
      const n = bG.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = bG;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Ww("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height), o = i.data;
      for (let l = 0; l < o.length; l++)
        o[l] = sB(o[l] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(sB(t[n] / 255) * 255) : t[n] = sB(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let A4 = 0;
class gb {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: A4++ }), this.uuid = PI(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let l = 0, u = i.length; l < u; l++)
          i[l].isDataTexture ? o.push(bM(i[l].image)) : o.push(bM(i[l]));
      } else
        o = bM(i);
      n.url = o;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function bM(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? FK.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let v4 = 0;
class ks extends eA {
  constructor(e = ks.DEFAULT_IMAGE, t = ks.DEFAULT_MAPPING, n = PC, i = PC, o = Ks, l = ap, u = cg, I = nf, C = ks.DEFAULT_ANISOTROPY, f = _m) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: v4++ }), this.uuid = PI(), this.name = "", this.source = new gb(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = o, this.minFilter = l, this.anisotropy = C, this.format = u, this.internalFormat = null, this.type = I, this.offset = new Lt(0, 0), this.repeat = new Lt(1, 1), this.center = new Lt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Cr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = f, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== NW) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case yw:
          e.x = e.x - Math.floor(e.x);
          break;
        case PC:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case bw:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case yw:
          e.y = e.y - Math.floor(e.y);
          break;
        case PC:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case bw:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
ks.DEFAULT_IMAGE = null;
ks.DEFAULT_MAPPING = NW;
ks.DEFAULT_ANISOTROPY = 1;
class Ha {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    Ha.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, o = this.w, l = e.elements;
    return this.x = l[0] * t + l[4] * n + l[8] * i + l[12] * o, this.y = l[1] * t + l[5] * n + l[9] * i + l[13] * o, this.z = l[2] * t + l[6] * n + l[10] * i + l[14] * o, this.w = l[3] * t + l[7] * n + l[11] * i + l[15] * o, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, o;
    const I = e.elements, C = I[0], f = I[4], v = I[8], b = I[1], S = I[5], R = I[9], W = I[2], x = I[6], N = I[10];
    if (Math.abs(f - b) < 0.01 && Math.abs(v - W) < 0.01 && Math.abs(R - x) < 0.01) {
      if (Math.abs(f + b) < 0.1 && Math.abs(v + W) < 0.1 && Math.abs(R + x) < 0.1 && Math.abs(C + S + N - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const F = (C + 1) / 2, T = (S + 1) / 2, P = (N + 1) / 2, D = (f + b) / 4, L = (v + W) / 4, j = (R + x) / 4;
      return F > T && F > P ? F < 0.01 ? (n = 0, i = 0.707106781, o = 0.707106781) : (n = Math.sqrt(F), i = D / n, o = L / n) : T > P ? T < 0.01 ? (n = 0.707106781, i = 0, o = 0.707106781) : (i = Math.sqrt(T), n = D / i, o = j / i) : P < 0.01 ? (n = 0.707106781, i = 0.707106781, o = 0) : (o = Math.sqrt(P), n = L / o, i = j / o), this.set(n, i, o, t), this;
    }
    let Y = Math.sqrt((x - R) * (x - R) + (v - W) * (v - W) + (b - f) * (b - f));
    return Math.abs(Y) < 1e-3 && (Y = 1), this.x = (x - R) / Y, this.y = (v - W) / Y, this.z = (b - f) / Y, this.w = Math.acos((C + S + N - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class EK extends eA {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Ha(0, 0, e, t), this.scissorTest = !1, this.viewport = new Ha(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Ks,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const o = new ks(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    o.flipY = !1, o.generateMipmaps = n.generateMipmaps, o.internalFormat = n.internalFormat, this.textures = [];
    const l = n.count;
    for (let u = 0; u < l; u++)
      this.textures[u] = o.clone(), this.textures[u].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let i = 0, o = this.textures.length; i < o; i++)
        this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, i = e.textures.length; n < i; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new gb(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class QC extends EK {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class zW extends ks {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Lu, this.minFilter = Lu, this.wrapR = PC, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class y4 extends QC {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new zW(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class cY extends ks {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Lu, this.minFilter = Lu, this.wrapR = PC, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class b4 extends QC {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new cY(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
let ku = class {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
  }
  static slerpFlat(e, t, n, i, o, l, u) {
    let I = n[i + 0], C = n[i + 1], f = n[i + 2], v = n[i + 3];
    const b = o[l + 0], S = o[l + 1], R = o[l + 2], W = o[l + 3];
    if (u === 0) {
      e[t + 0] = I, e[t + 1] = C, e[t + 2] = f, e[t + 3] = v;
      return;
    }
    if (u === 1) {
      e[t + 0] = b, e[t + 1] = S, e[t + 2] = R, e[t + 3] = W;
      return;
    }
    if (v !== W || I !== b || C !== S || f !== R) {
      let x = 1 - u;
      const N = I * b + C * S + f * R + v * W, Y = N >= 0 ? 1 : -1, F = 1 - N * N;
      if (F > Number.EPSILON) {
        const P = Math.sqrt(F), D = Math.atan2(P, N * Y);
        x = Math.sin(x * D) / P, u = Math.sin(u * D) / P;
      }
      const T = u * Y;
      if (I = I * x + b * T, C = C * x + S * T, f = f * x + R * T, v = v * x + W * T, x === 1 - u) {
        const P = 1 / Math.sqrt(I * I + C * C + f * f + v * v);
        I *= P, C *= P, f *= P, v *= P;
      }
    }
    e[t] = I, e[t + 1] = C, e[t + 2] = f, e[t + 3] = v;
  }
  static multiplyQuaternionsFlat(e, t, n, i, o, l) {
    const u = n[i], I = n[i + 1], C = n[i + 2], f = n[i + 3], v = o[l], b = o[l + 1], S = o[l + 2], R = o[l + 3];
    return e[t] = u * R + f * v + I * S - C * b, e[t + 1] = I * R + f * b + C * v - u * S, e[t + 2] = C * R + f * S + u * b - I * v, e[t + 3] = f * R - u * v - I * b - C * S, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, i) {
    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const n = e._x, i = e._y, o = e._z, l = e._order, u = Math.cos, I = Math.sin, C = u(n / 2), f = u(i / 2), v = u(o / 2), b = I(n / 2), S = I(i / 2), R = I(o / 2);
    switch (l) {
      case "XYZ":
        this._x = b * f * v + C * S * R, this._y = C * S * v - b * f * R, this._z = C * f * R + b * S * v, this._w = C * f * v - b * S * R;
        break;
      case "YXZ":
        this._x = b * f * v + C * S * R, this._y = C * S * v - b * f * R, this._z = C * f * R - b * S * v, this._w = C * f * v + b * S * R;
        break;
      case "ZXY":
        this._x = b * f * v - C * S * R, this._y = C * S * v + b * f * R, this._z = C * f * R + b * S * v, this._w = C * f * v - b * S * R;
        break;
      case "ZYX":
        this._x = b * f * v - C * S * R, this._y = C * S * v + b * f * R, this._z = C * f * R - b * S * v, this._w = C * f * v + b * S * R;
        break;
      case "YZX":
        this._x = b * f * v + C * S * R, this._y = C * S * v + b * f * R, this._z = C * f * R - b * S * v, this._w = C * f * v - b * S * R;
        break;
      case "XZY":
        this._x = b * f * v - C * S * R, this._y = C * S * v - b * f * R, this._z = C * f * R + b * S * v, this._w = C * f * v + b * S * R;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, i = Math.sin(n);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], i = t[4], o = t[8], l = t[1], u = t[5], I = t[9], C = t[2], f = t[6], v = t[10], b = n + u + v;
    if (b > 0) {
      const S = 0.5 / Math.sqrt(b + 1);
      this._w = 0.25 / S, this._x = (f - I) * S, this._y = (o - C) * S, this._z = (l - i) * S;
    } else if (n > u && n > v) {
      const S = 2 * Math.sqrt(1 + n - u - v);
      this._w = (f - I) / S, this._x = 0.25 * S, this._y = (i + l) / S, this._z = (o + C) / S;
    } else if (u > v) {
      const S = 2 * Math.sqrt(1 + u - n - v);
      this._w = (o - C) / S, this._x = (i + l) / S, this._y = 0.25 * S, this._z = (I + f) / S;
    } else {
      const S = 2 * Math.sqrt(1 + v - n - u);
      this._w = (l - i) / S, this._x = (o + C) / S, this._y = (I + f) / S, this._z = 0.25 * S;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(zs(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, i = e._y, o = e._z, l = e._w, u = t._x, I = t._y, C = t._z, f = t._w;
    return this._x = n * f + l * u + i * C - o * I, this._y = i * f + l * I + o * u - n * C, this._z = o * f + l * C + n * I - i * u, this._w = l * f - n * u - i * I - o * C, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x, i = this._y, o = this._z, l = this._w;
    let u = l * e._w + n * e._x + i * e._y + o * e._z;
    if (u < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, u = -u) : this.copy(e), u >= 1)
      return this._w = l, this._x = n, this._y = i, this._z = o, this;
    const I = 1 - u * u;
    if (I <= Number.EPSILON) {
      const S = 1 - t;
      return this._w = S * l + t * this._w, this._x = S * n + t * this._x, this._y = S * i + t * this._y, this._z = S * o + t * this._z, this.normalize(), this;
    }
    const C = Math.sqrt(I), f = Math.atan2(C, u), v = Math.sin((1 - t) * f) / C, b = Math.sin(t * f) / C;
    return this._w = l * v + this._w * b, this._x = n * v + this._x * b, this._y = i * v + this._y * b, this._z = o * v + this._z * b, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), o = Math.sqrt(n);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      o * Math.sin(t),
      o * Math.cos(t)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
};
class fe {
  constructor(e = 0, t = 0, n = 0) {
    fe.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(KT.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(KT.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[3] * n + o[6] * i, this.y = o[1] * t + o[4] * n + o[7] * i, this.z = o[2] * t + o[5] * n + o[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements, l = 1 / (o[3] * t + o[7] * n + o[11] * i + o[15]);
    return this.x = (o[0] * t + o[4] * n + o[8] * i + o[12]) * l, this.y = (o[1] * t + o[5] * n + o[9] * i + o[13]) * l, this.z = (o[2] * t + o[6] * n + o[10] * i + o[14]) * l, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z, I = e.w, C = 2 * (l * i - u * n), f = 2 * (u * t - o * i), v = 2 * (o * n - l * t);
    return this.x = t + I * C + l * v - u * f, this.y = n + I * f + u * C - o * v, this.z = i + I * v + o * f - l * C, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[4] * n + o[8] * i, this.y = o[1] * t + o[5] * n + o[9] * i, this.z = o[2] * t + o[6] * n + o[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, i = e.y, o = e.z, l = t.x, u = t.y, I = t.z;
    return this.x = i * I - o * u, this.y = o * l - n * I, this.z = n * u - i * l, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return GM.copy(this).projectOnVector(e), this.sub(GM);
  }
  reflect(e) {
    return this.sub(GM.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(zs(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const GM = /* @__PURE__ */ new fe(), KT = /* @__PURE__ */ new ku();
class nd {
  constructor(e = new fe(1 / 0, 1 / 0, 1 / 0), t = new fe(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Oh.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Oh.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Oh.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const o = n.getAttribute("position");
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let l = 0, u = o.count; l < u; l++)
          e.isMesh === !0 ? e.getVertexPosition(l, Oh) : Oh.fromBufferAttribute(o, l), Oh.applyMatrix4(e.matrixWorld), this.expandByPoint(Oh);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), n1.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), n1.copy(n.boundingBox)), n1.applyMatrix4(e.matrixWorld), this.union(n1);
    }
    const i = e.children;
    for (let o = 0, l = i.length; o < l; o++)
      this.expandByObject(i[o], t);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Oh), Oh.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(GZ), i1.subVectors(this.max, GZ), GG.subVectors(e.a, GZ), BG.subVectors(e.b, GZ), SG.subVectors(e.c, GZ), ev.subVectors(BG, GG), tv.subVectors(SG, BG), Fy.subVectors(GG, SG);
    let t = [
      0,
      -ev.z,
      ev.y,
      0,
      -tv.z,
      tv.y,
      0,
      -Fy.z,
      Fy.y,
      ev.z,
      0,
      -ev.x,
      tv.z,
      0,
      -tv.x,
      Fy.z,
      0,
      -Fy.x,
      -ev.y,
      ev.x,
      0,
      -tv.y,
      tv.x,
      0,
      -Fy.y,
      Fy.x,
      0
    ];
    return !BM(t, GG, BG, SG, i1) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !BM(t, GG, BG, SG, i1)) ? !1 : (r1.crossVectors(ev, tv), t = [r1.x, r1.y, r1.z], BM(t, GG, BG, SG, i1));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Oh).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Oh).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (wm[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), wm[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), wm[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), wm[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), wm[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), wm[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), wm[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), wm[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(wm), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const wm = [
  /* @__PURE__ */ new fe(),
  /* @__PURE__ */ new fe(),
  /* @__PURE__ */ new fe(),
  /* @__PURE__ */ new fe(),
  /* @__PURE__ */ new fe(),
  /* @__PURE__ */ new fe(),
  /* @__PURE__ */ new fe(),
  /* @__PURE__ */ new fe()
], Oh = /* @__PURE__ */ new fe(), n1 = /* @__PURE__ */ new nd(), GG = /* @__PURE__ */ new fe(), BG = /* @__PURE__ */ new fe(), SG = /* @__PURE__ */ new fe(), ev = /* @__PURE__ */ new fe(), tv = /* @__PURE__ */ new fe(), Fy = /* @__PURE__ */ new fe(), GZ = /* @__PURE__ */ new fe(), i1 = /* @__PURE__ */ new fe(), r1 = /* @__PURE__ */ new fe(), Ey = /* @__PURE__ */ new fe();
function BM(r, e, t, n, i) {
  for (let o = 0, l = r.length - 3; o <= l; o += 3) {
    Ey.fromArray(r, o);
    const u = i.x * Math.abs(Ey.x) + i.y * Math.abs(Ey.y) + i.z * Math.abs(Ey.z), I = e.dot(Ey), C = t.dot(Ey), f = n.dot(Ey);
    if (Math.max(-Math.max(I, C, f), Math.min(I, C, f)) > u)
      return !1;
  }
  return !0;
}
const G4 = /* @__PURE__ */ new nd(), BZ = /* @__PURE__ */ new fe(), SM = /* @__PURE__ */ new fe();
class dg {
  constructor(e = new fe(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : G4.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let o = 0, l = e.length; o < l; o++)
      i = Math.max(i, n.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    BZ.subVectors(e, this.center);
    const t = BZ.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(BZ, i / n), this.radius += i;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (SM.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(BZ.copy(e.center).add(SM)), this.expandByPoint(BZ.copy(e.center).sub(SM))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Rm = /* @__PURE__ */ new fe(), ZM = /* @__PURE__ */ new fe(), a1 = /* @__PURE__ */ new fe(), nv = /* @__PURE__ */ new fe(), wM = /* @__PURE__ */ new fe(), o1 = /* @__PURE__ */ new fe(), RM = /* @__PURE__ */ new fe();
let Nb = class {
  constructor(e = new fe(), t = new fe(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Rm)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Rm.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Rm.copy(this.origin).addScaledVector(this.direction, t), Rm.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    ZM.copy(e).add(t).multiplyScalar(0.5), a1.copy(t).sub(e).normalize(), nv.copy(this.origin).sub(ZM);
    const o = e.distanceTo(t) * 0.5, l = -this.direction.dot(a1), u = nv.dot(this.direction), I = -nv.dot(a1), C = nv.lengthSq(), f = Math.abs(1 - l * l);
    let v, b, S, R;
    if (f > 0)
      if (v = l * I - u, b = l * u - I, R = o * f, v >= 0)
        if (b >= -R)
          if (b <= R) {
            const W = 1 / f;
            v *= W, b *= W, S = v * (v + l * b + 2 * u) + b * (l * v + b + 2 * I) + C;
          } else
            b = o, v = Math.max(0, -(l * b + u)), S = -v * v + b * (b + 2 * I) + C;
        else
          b = -o, v = Math.max(0, -(l * b + u)), S = -v * v + b * (b + 2 * I) + C;
      else
        b <= -R ? (v = Math.max(0, -(-l * o + u)), b = v > 0 ? -o : Math.min(Math.max(-o, -I), o), S = -v * v + b * (b + 2 * I) + C) : b <= R ? (v = 0, b = Math.min(Math.max(-o, -I), o), S = b * (b + 2 * I) + C) : (v = Math.max(0, -(l * o + u)), b = v > 0 ? o : Math.min(Math.max(-o, -I), o), S = -v * v + b * (b + 2 * I) + C);
    else
      b = l > 0 ? -o : o, v = Math.max(0, -(l * b + u)), S = -v * v + b * (b + 2 * I) + C;
    return n && n.copy(this.origin).addScaledVector(this.direction, v), i && i.copy(ZM).addScaledVector(a1, b), S;
  }
  intersectSphere(e, t) {
    Rm.subVectors(e.center, this.origin);
    const n = Rm.dot(this.direction), i = Rm.dot(Rm) - n * n, o = e.radius * e.radius;
    if (i > o) return null;
    const l = Math.sqrt(o - i), u = n - l, I = n + l;
    return I < 0 ? null : u < 0 ? this.at(I, t) : this.at(u, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, o, l, u, I;
    const C = 1 / this.direction.x, f = 1 / this.direction.y, v = 1 / this.direction.z, b = this.origin;
    return C >= 0 ? (n = (e.min.x - b.x) * C, i = (e.max.x - b.x) * C) : (n = (e.max.x - b.x) * C, i = (e.min.x - b.x) * C), f >= 0 ? (o = (e.min.y - b.y) * f, l = (e.max.y - b.y) * f) : (o = (e.max.y - b.y) * f, l = (e.min.y - b.y) * f), n > l || o > i || ((o > n || isNaN(n)) && (n = o), (l < i || isNaN(i)) && (i = l), v >= 0 ? (u = (e.min.z - b.z) * v, I = (e.max.z - b.z) * v) : (u = (e.max.z - b.z) * v, I = (e.min.z - b.z) * v), n > I || u > i) || ((u > n || n !== n) && (n = u), (I < i || i !== i) && (i = I), i < 0) ? null : this.at(n >= 0 ? n : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Rm) !== null;
  }
  intersectTriangle(e, t, n, i, o) {
    wM.subVectors(t, e), o1.subVectors(n, e), RM.crossVectors(wM, o1);
    let l = this.direction.dot(RM), u;
    if (l > 0) {
      if (i) return null;
      u = 1;
    } else if (l < 0)
      u = -1, l = -l;
    else
      return null;
    nv.subVectors(this.origin, e);
    const I = u * this.direction.dot(o1.crossVectors(nv, o1));
    if (I < 0)
      return null;
    const C = u * this.direction.dot(wM.cross(nv));
    if (C < 0 || I + C > l)
      return null;
    const f = -u * nv.dot(RM);
    return f < 0 ? null : this.at(f / l, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
class _i {
  constructor(e, t, n, i, o, l, u, I, C, f, v, b, S, R, W, x) {
    _i.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, o, l, u, I, C, f, v, b, S, R, W, x);
  }
  set(e, t, n, i, o, l, u, I, C, f, v, b, S, R, W, x) {
    const N = this.elements;
    return N[0] = e, N[4] = t, N[8] = n, N[12] = i, N[1] = o, N[5] = l, N[9] = u, N[13] = I, N[2] = C, N[6] = f, N[10] = v, N[14] = b, N[3] = S, N[7] = R, N[11] = W, N[15] = x, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new _i().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, i = 1 / ZG.setFromMatrixColumn(e, 0).length(), o = 1 / ZG.setFromMatrixColumn(e, 1).length(), l = 1 / ZG.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * o, t[5] = n[5] * o, t[6] = n[6] * o, t[7] = 0, t[8] = n[8] * l, t[9] = n[9] * l, t[10] = n[10] * l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, i = e.y, o = e.z, l = Math.cos(n), u = Math.sin(n), I = Math.cos(i), C = Math.sin(i), f = Math.cos(o), v = Math.sin(o);
    if (e.order === "XYZ") {
      const b = l * f, S = l * v, R = u * f, W = u * v;
      t[0] = I * f, t[4] = -I * v, t[8] = C, t[1] = S + R * C, t[5] = b - W * C, t[9] = -u * I, t[2] = W - b * C, t[6] = R + S * C, t[10] = l * I;
    } else if (e.order === "YXZ") {
      const b = I * f, S = I * v, R = C * f, W = C * v;
      t[0] = b + W * u, t[4] = R * u - S, t[8] = l * C, t[1] = l * v, t[5] = l * f, t[9] = -u, t[2] = S * u - R, t[6] = W + b * u, t[10] = l * I;
    } else if (e.order === "ZXY") {
      const b = I * f, S = I * v, R = C * f, W = C * v;
      t[0] = b - W * u, t[4] = -l * v, t[8] = R + S * u, t[1] = S + R * u, t[5] = l * f, t[9] = W - b * u, t[2] = -l * C, t[6] = u, t[10] = l * I;
    } else if (e.order === "ZYX") {
      const b = l * f, S = l * v, R = u * f, W = u * v;
      t[0] = I * f, t[4] = R * C - S, t[8] = b * C + W, t[1] = I * v, t[5] = W * C + b, t[9] = S * C - R, t[2] = -C, t[6] = u * I, t[10] = l * I;
    } else if (e.order === "YZX") {
      const b = l * I, S = l * C, R = u * I, W = u * C;
      t[0] = I * f, t[4] = W - b * v, t[8] = R * v + S, t[1] = v, t[5] = l * f, t[9] = -u * f, t[2] = -C * f, t[6] = S * v + R, t[10] = b - W * v;
    } else if (e.order === "XZY") {
      const b = l * I, S = l * C, R = u * I, W = u * C;
      t[0] = I * f, t[4] = -v, t[8] = C * f, t[1] = b * v + W, t[5] = l * f, t[9] = S * v - R, t[2] = R * v - S, t[6] = u * f, t[10] = W * v + b;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(B4, e, S4);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return zI.subVectors(e, t), zI.lengthSq() === 0 && (zI.z = 1), zI.normalize(), iv.crossVectors(n, zI), iv.lengthSq() === 0 && (Math.abs(n.z) === 1 ? zI.x += 1e-4 : zI.z += 1e-4, zI.normalize(), iv.crossVectors(n, zI)), iv.normalize(), s1.crossVectors(zI, iv), i[0] = iv.x, i[4] = s1.x, i[8] = zI.x, i[1] = iv.y, i[5] = s1.y, i[9] = zI.y, i[2] = iv.z, i[6] = s1.z, i[10] = zI.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, o = this.elements, l = n[0], u = n[4], I = n[8], C = n[12], f = n[1], v = n[5], b = n[9], S = n[13], R = n[2], W = n[6], x = n[10], N = n[14], Y = n[3], F = n[7], T = n[11], P = n[15], D = i[0], L = i[4], j = i[8], J = i[12], O = i[1], ne = i[5], he = i[9], pe = i[13], Ae = i[2], ke = i[6], Re = i[10], Xe = i[14], re = i[3], Se = i[7], Be = i[11], le = i[15];
    return o[0] = l * D + u * O + I * Ae + C * re, o[4] = l * L + u * ne + I * ke + C * Se, o[8] = l * j + u * he + I * Re + C * Be, o[12] = l * J + u * pe + I * Xe + C * le, o[1] = f * D + v * O + b * Ae + S * re, o[5] = f * L + v * ne + b * ke + S * Se, o[9] = f * j + v * he + b * Re + S * Be, o[13] = f * J + v * pe + b * Xe + S * le, o[2] = R * D + W * O + x * Ae + N * re, o[6] = R * L + W * ne + x * ke + N * Se, o[10] = R * j + W * he + x * Re + N * Be, o[14] = R * J + W * pe + x * Xe + N * le, o[3] = Y * D + F * O + T * Ae + P * re, o[7] = Y * L + F * ne + T * ke + P * Se, o[11] = Y * j + F * he + T * Re + P * Be, o[15] = Y * J + F * pe + T * Xe + P * le, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], i = e[8], o = e[12], l = e[1], u = e[5], I = e[9], C = e[13], f = e[2], v = e[6], b = e[10], S = e[14], R = e[3], W = e[7], x = e[11], N = e[15];
    return R * (+o * I * v - i * C * v - o * u * b + n * C * b + i * u * S - n * I * S) + W * (+t * I * S - t * C * b + o * l * b - i * l * S + i * C * f - o * I * f) + x * (+t * C * v - t * u * S - o * l * v + n * l * S + o * u * f - n * C * f) + N * (-i * u * f - t * I * v + t * u * b + i * l * v - n * l * b + n * I * f);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], u = e[5], I = e[6], C = e[7], f = e[8], v = e[9], b = e[10], S = e[11], R = e[12], W = e[13], x = e[14], N = e[15], Y = v * x * C - W * b * C + W * I * S - u * x * S - v * I * N + u * b * N, F = R * b * C - f * x * C - R * I * S + l * x * S + f * I * N - l * b * N, T = f * W * C - R * v * C + R * u * S - l * W * S - f * u * N + l * v * N, P = R * v * I - f * W * I - R * u * b + l * W * b + f * u * x - l * v * x, D = t * Y + n * F + i * T + o * P;
    if (D === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const L = 1 / D;
    return e[0] = Y * L, e[1] = (W * b * o - v * x * o - W * i * S + n * x * S + v * i * N - n * b * N) * L, e[2] = (u * x * o - W * I * o + W * i * C - n * x * C - u * i * N + n * I * N) * L, e[3] = (v * I * o - u * b * o - v * i * C + n * b * C + u * i * S - n * I * S) * L, e[4] = F * L, e[5] = (f * x * o - R * b * o + R * i * S - t * x * S - f * i * N + t * b * N) * L, e[6] = (R * I * o - l * x * o - R * i * C + t * x * C + l * i * N - t * I * N) * L, e[7] = (l * b * o - f * I * o + f * i * C - t * b * C - l * i * S + t * I * S) * L, e[8] = T * L, e[9] = (R * v * o - f * W * o - R * n * S + t * W * S + f * n * N - t * v * N) * L, e[10] = (l * W * o - R * u * o + R * n * C - t * W * C - l * n * N + t * u * N) * L, e[11] = (f * u * o - l * v * o - f * n * C + t * v * C + l * n * S - t * u * S) * L, e[12] = P * L, e[13] = (f * W * i - R * v * i + R * n * b - t * W * b - f * n * x + t * v * x) * L, e[14] = (R * u * i - l * W * i - R * n * I + t * W * I + l * n * x - t * u * x) * L, e[15] = (l * v * i - f * u * i + f * n * I - t * v * I - l * n * b + t * u * b) * L, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, i = e.y, o = e.z;
    return t[0] *= n, t[4] *= i, t[8] *= o, t[1] *= n, t[5] *= i, t[9] *= o, t[2] *= n, t[6] *= i, t[10] *= o, t[3] *= n, t[7] *= i, t[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), i = Math.sin(t), o = 1 - n, l = e.x, u = e.y, I = e.z, C = o * l, f = o * u;
    return this.set(
      C * l + n,
      C * u - i * I,
      C * I + i * u,
      0,
      C * u + i * I,
      f * u + n,
      f * I - i * l,
      0,
      C * I - i * u,
      f * I + i * l,
      o * I * I + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, i, o, l) {
    return this.set(
      1,
      n,
      o,
      0,
      e,
      1,
      l,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const i = this.elements, o = t._x, l = t._y, u = t._z, I = t._w, C = o + o, f = l + l, v = u + u, b = o * C, S = o * f, R = o * v, W = l * f, x = l * v, N = u * v, Y = I * C, F = I * f, T = I * v, P = n.x, D = n.y, L = n.z;
    return i[0] = (1 - (W + N)) * P, i[1] = (S + T) * P, i[2] = (R - F) * P, i[3] = 0, i[4] = (S - T) * D, i[5] = (1 - (b + N)) * D, i[6] = (x + Y) * D, i[7] = 0, i[8] = (R + F) * L, i[9] = (x - Y) * L, i[10] = (1 - (b + W)) * L, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, n) {
    const i = this.elements;
    let o = ZG.set(i[0], i[1], i[2]).length();
    const l = ZG.set(i[4], i[5], i[6]).length(), u = ZG.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o), e.x = i[12], e.y = i[13], e.z = i[14], Ph.copy(this);
    const C = 1 / o, f = 1 / l, v = 1 / u;
    return Ph.elements[0] *= C, Ph.elements[1] *= C, Ph.elements[2] *= C, Ph.elements[4] *= f, Ph.elements[5] *= f, Ph.elements[6] *= f, Ph.elements[8] *= v, Ph.elements[9] *= v, Ph.elements[10] *= v, t.setFromRotationMatrix(Ph), n.x = o, n.y = l, n.z = u, this;
  }
  makePerspective(e, t, n, i, o, l, u = op) {
    const I = this.elements, C = 2 * o / (t - e), f = 2 * o / (n - i), v = (t + e) / (t - e), b = (n + i) / (n - i);
    let S, R;
    if (u === op)
      S = -(l + o) / (l - o), R = -2 * l * o / (l - o);
    else if (u === xw)
      S = -l / (l - o), R = -l * o / (l - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + u);
    return I[0] = C, I[4] = 0, I[8] = v, I[12] = 0, I[1] = 0, I[5] = f, I[9] = b, I[13] = 0, I[2] = 0, I[6] = 0, I[10] = S, I[14] = R, I[3] = 0, I[7] = 0, I[11] = -1, I[15] = 0, this;
  }
  makeOrthographic(e, t, n, i, o, l, u = op) {
    const I = this.elements, C = 1 / (t - e), f = 1 / (n - i), v = 1 / (l - o), b = (t + e) * C, S = (n + i) * f;
    let R, W;
    if (u === op)
      R = (l + o) * v, W = -2 * v;
    else if (u === xw)
      R = o * v, W = -1 * v;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + u);
    return I[0] = 2 * C, I[4] = 0, I[8] = 0, I[12] = -b, I[1] = 0, I[5] = 2 * f, I[9] = 0, I[13] = -S, I[2] = 0, I[6] = 0, I[10] = W, I[14] = -R, I[3] = 0, I[7] = 0, I[11] = 0, I[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const ZG = /* @__PURE__ */ new fe(), Ph = /* @__PURE__ */ new _i(), B4 = /* @__PURE__ */ new fe(0, 0, 0), S4 = /* @__PURE__ */ new fe(1, 1, 1), iv = /* @__PURE__ */ new fe(), s1 = /* @__PURE__ */ new fe(), zI = /* @__PURE__ */ new fe(), LT = /* @__PURE__ */ new _i(), kT = /* @__PURE__ */ new ku();
class uI {
  constructor(e = 0, t = 0, n = 0, i = uI.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements, o = i[0], l = i[4], u = i[8], I = i[1], C = i[5], f = i[9], v = i[2], b = i[6], S = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(zs(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-f, S), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(b, C), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-zs(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(u, S), this._z = Math.atan2(I, C)) : (this._y = Math.atan2(-v, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(zs(b, -1, 1)), Math.abs(b) < 0.9999999 ? (this._y = Math.atan2(-v, S), this._z = Math.atan2(-l, C)) : (this._y = 0, this._z = Math.atan2(I, o));
        break;
      case "ZYX":
        this._y = Math.asin(-zs(v, -1, 1)), Math.abs(v) < 0.9999999 ? (this._x = Math.atan2(b, S), this._z = Math.atan2(I, o)) : (this._x = 0, this._z = Math.atan2(-l, C));
        break;
      case "YZX":
        this._z = Math.asin(zs(I, -1, 1)), Math.abs(I) < 0.9999999 ? (this._x = Math.atan2(-f, C), this._y = Math.atan2(-v, o)) : (this._x = 0, this._y = Math.atan2(u, S));
        break;
      case "XZY":
        this._z = Math.asin(-zs(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(b, C), this._y = Math.atan2(u, o)) : (this._x = Math.atan2(-f, S), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return LT.makeRotationFromQuaternion(e), this.setFromRotationMatrix(LT, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return kT.setFromEuler(this), this.setFromQuaternion(kT, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
uI.DEFAULT_ORDER = "XYZ";
class pb {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let Z4 = 0;
const DT = /* @__PURE__ */ new fe(), wG = /* @__PURE__ */ new ku(), xm = /* @__PURE__ */ new _i(), l1 = /* @__PURE__ */ new fe(), SZ = /* @__PURE__ */ new fe(), w4 = /* @__PURE__ */ new fe(), R4 = /* @__PURE__ */ new ku(), UT = /* @__PURE__ */ new fe(1, 0, 0), OT = /* @__PURE__ */ new fe(0, 1, 0), PT = /* @__PURE__ */ new fe(0, 0, 1), JT = { type: "added" }, x4 = { type: "removed" }, RG = { type: "childadded", child: null }, xM = { type: "childremoved", child: null };
class qr extends eA {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Z4++ }), this.uuid = PI(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = qr.DEFAULT_UP.clone();
    const e = new fe(), t = new uI(), n = new ku(), i = new fe(1, 1, 1);
    function o() {
      n.setFromEuler(t, !1);
    }
    function l() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(o), n._onChange(l), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new _i()
      },
      normalMatrix: {
        value: new Cr()
      }
    }), this.matrix = new _i(), this.matrixWorld = new _i(), this.matrixAutoUpdate = qr.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = qr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new pb(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return wG.setFromAxisAngle(e, t), this.quaternion.multiply(wG), this;
  }
  rotateOnWorldAxis(e, t) {
    return wG.setFromAxisAngle(e, t), this.quaternion.premultiply(wG), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(UT, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(OT, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(PT, e);
  }
  translateOnAxis(e, t) {
    return DT.copy(e).applyQuaternion(this.quaternion), this.position.add(DT.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(UT, e);
  }
  translateY(e) {
    return this.translateOnAxis(OT, e);
  }
  translateZ(e) {
    return this.translateOnAxis(PT, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(xm.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? l1.copy(e) : l1.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), SZ.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? xm.lookAt(SZ, l1, this.up) : xm.lookAt(l1, SZ, this.up), this.quaternion.setFromRotationMatrix(xm), i && (xm.extractRotation(i.matrixWorld), wG.setFromRotationMatrix(xm), this.quaternion.premultiply(wG.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(JT), RG.child = e, this.dispatchEvent(RG), RG.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(x4), xM.child = e, this.dispatchEvent(xM), xM.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), xm.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), xm.multiply(e.parent.matrixWorld)), e.applyMatrix4(xm), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(JT), RG.child = e, this.dispatchEvent(RG), RG.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const l = this.children[n].getObjectByProperty(e, t);
      if (l !== void 0)
        return l;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let o = 0, l = i.length; o < l; o++)
      i[o].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(SZ, e, w4), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(SZ, R4, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
      const i = this.children;
      for (let o = 0, l = i.length; o < l; o++)
        i[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((u) => ({
      boxInitialized: u.boxInitialized,
      boxMin: u.box.min.toArray(),
      boxMax: u.box.max.toArray(),
      sphereInitialized: u.sphereInitialized,
      sphereRadius: u.sphere.radius,
      sphereCenter: u.sphere.center.toArray()
    })), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function o(u, I) {
      return u[I.uuid] === void 0 && (u[I.uuid] = I.toJSON(e)), I.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const u = this.geometry.parameters;
      if (u !== void 0 && u.shapes !== void 0) {
        const I = u.shapes;
        if (Array.isArray(I))
          for (let C = 0, f = I.length; C < f; C++) {
            const v = I[C];
            o(e.shapes, v);
          }
        else
          o(e.shapes, I);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const u = [];
        for (let I = 0, C = this.material.length; I < C; I++)
          u.push(o(e.materials, this.material[I]));
        i.material = u;
      } else
        i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let u = 0; u < this.children.length; u++)
        i.children.push(this.children[u].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let u = 0; u < this.animations.length; u++) {
        const I = this.animations[u];
        i.animations.push(o(e.animations, I));
      }
    }
    if (t) {
      const u = l(e.geometries), I = l(e.materials), C = l(e.textures), f = l(e.images), v = l(e.shapes), b = l(e.skeletons), S = l(e.animations), R = l(e.nodes);
      u.length > 0 && (n.geometries = u), I.length > 0 && (n.materials = I), C.length > 0 && (n.textures = C), f.length > 0 && (n.images = f), v.length > 0 && (n.shapes = v), b.length > 0 && (n.skeletons = b), S.length > 0 && (n.animations = S), R.length > 0 && (n.nodes = R);
    }
    return n.object = i, n;
    function l(u) {
      const I = [];
      for (const C in u) {
        const f = u[C];
        delete f.metadata, I.push(f);
      }
      return I;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
qr.DEFAULT_UP = /* @__PURE__ */ new fe(0, 1, 0);
qr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
qr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Jh = /* @__PURE__ */ new fe(), Wm = /* @__PURE__ */ new fe(), WM = /* @__PURE__ */ new fe(), Vm = /* @__PURE__ */ new fe(), xG = /* @__PURE__ */ new fe(), WG = /* @__PURE__ */ new fe(), QT = /* @__PURE__ */ new fe(), VM = /* @__PURE__ */ new fe(), NM = /* @__PURE__ */ new fe(), MM = /* @__PURE__ */ new fe();
class DI {
  constructor(e = new fe(), t = new fe(), n = new fe()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Jh.subVectors(e, t), i.cross(Jh);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, i, o) {
    Jh.subVectors(i, t), Wm.subVectors(n, t), WM.subVectors(e, t);
    const l = Jh.dot(Jh), u = Jh.dot(Wm), I = Jh.dot(WM), C = Wm.dot(Wm), f = Wm.dot(WM), v = l * C - u * u;
    if (v === 0)
      return o.set(0, 0, 0), null;
    const b = 1 / v, S = (C * I - u * f) * b, R = (l * f - u * I) * b;
    return o.set(1 - S - R, R, S);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, Vm) === null ? !1 : Vm.x >= 0 && Vm.y >= 0 && Vm.x + Vm.y <= 1;
  }
  static getInterpolation(e, t, n, i, o, l, u, I) {
    return this.getBarycoord(e, t, n, i, Vm) === null ? (I.x = 0, I.y = 0, "z" in I && (I.z = 0), "w" in I && (I.w = 0), null) : (I.setScalar(0), I.addScaledVector(o, Vm.x), I.addScaledVector(l, Vm.y), I.addScaledVector(u, Vm.z), I);
  }
  static isFrontFacing(e, t, n, i) {
    return Jh.subVectors(n, t), Wm.subVectors(e, t), Jh.cross(Wm).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Jh.subVectors(this.c, this.b), Wm.subVectors(this.a, this.b), Jh.cross(Wm).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return DI.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return DI.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, i, o) {
    return DI.getInterpolation(e, this.a, this.b, this.c, t, n, i, o);
  }
  containsPoint(e) {
    return DI.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return DI.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, i = this.b, o = this.c;
    let l, u;
    xG.subVectors(i, n), WG.subVectors(o, n), VM.subVectors(e, n);
    const I = xG.dot(VM), C = WG.dot(VM);
    if (I <= 0 && C <= 0)
      return t.copy(n);
    NM.subVectors(e, i);
    const f = xG.dot(NM), v = WG.dot(NM);
    if (f >= 0 && v <= f)
      return t.copy(i);
    const b = I * v - f * C;
    if (b <= 0 && I >= 0 && f <= 0)
      return l = I / (I - f), t.copy(n).addScaledVector(xG, l);
    MM.subVectors(e, o);
    const S = xG.dot(MM), R = WG.dot(MM);
    if (R >= 0 && S <= R)
      return t.copy(o);
    const W = S * C - I * R;
    if (W <= 0 && C >= 0 && R <= 0)
      return u = C / (C - R), t.copy(n).addScaledVector(WG, u);
    const x = f * R - S * v;
    if (x <= 0 && v - f >= 0 && S - R >= 0)
      return QT.subVectors(o, i), u = (v - f) / (v - f + (S - R)), t.copy(i).addScaledVector(QT, u);
    const N = 1 / (x + W + b);
    return l = W * N, u = b * N, t.copy(n).addScaledVector(xG, l).addScaledVector(WG, u);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const TK = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, rv = { h: 0, s: 0, l: 0 }, u1 = { h: 0, s: 0, l: 0 };
function HM(r, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r;
}
class ai {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = OC) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ya.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, i = ya.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, ya.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, n, i = ya.workingColorSpace) {
    if (e = uY(e, 1), t = zs(t, 0, 1), n = zs(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const o = n <= 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - o;
      this.r = HM(l, o, e + 1 / 3), this.g = HM(l, o, e), this.b = HM(l, o, e - 1 / 3);
    }
    return ya.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = OC) {
    function n(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const l = i[1], u = i[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              t
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = i[1], l = o.length;
      if (l === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (l === 6)
        return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = OC) {
    const n = TK[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = sB(e.r), this.g = sB(e.g), this.b = sB(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = yM(e.r), this.g = yM(e.g), this.b = yM(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = OC) {
    return ya.fromWorkingColorSpace(tg.copy(this), e), Math.round(zs(tg.r * 255, 0, 255)) * 65536 + Math.round(zs(tg.g * 255, 0, 255)) * 256 + Math.round(zs(tg.b * 255, 0, 255));
  }
  getHexString(e = OC) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = ya.workingColorSpace) {
    ya.fromWorkingColorSpace(tg.copy(this), t);
    const n = tg.r, i = tg.g, o = tg.b, l = Math.max(n, i, o), u = Math.min(n, i, o);
    let I, C;
    const f = (u + l) / 2;
    if (u === l)
      I = 0, C = 0;
    else {
      const v = l - u;
      switch (C = f <= 0.5 ? v / (l + u) : v / (2 - l - u), l) {
        case n:
          I = (i - o) / v + (i < o ? 6 : 0);
          break;
        case i:
          I = (o - n) / v + 2;
          break;
        case o:
          I = (n - i) / v + 4;
          break;
      }
      I /= 6;
    }
    return e.h = I, e.s = C, e.l = f, e;
  }
  getRGB(e, t = ya.workingColorSpace) {
    return ya.fromWorkingColorSpace(tg.copy(this), t), e.r = tg.r, e.g = tg.g, e.b = tg.b, e;
  }
  getStyle(e = OC) {
    ya.fromWorkingColorSpace(tg.copy(this), e);
    const t = tg.r, n = tg.g, i = tg.b;
    return e !== OC ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(rv), this.setHSL(rv.h + e, rv.s + t, rv.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(rv), e.getHSL(u1);
    const n = iw(rv.h, u1.h, t), i = iw(rv.s, u1.s, t), o = iw(rv.l, u1.l, t);
    return this.setHSL(n, i, o), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, i = this.b, o = e.elements;
    return this.r = o[0] * t + o[3] * n + o[6] * i, this.g = o[1] * t + o[4] * n + o[7] * i, this.b = o[2] * t + o[5] * n + o[8] * i, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const tg = /* @__PURE__ */ new ai();
ai.NAMES = TK;
let W4 = 0;
class Cg extends eA {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: W4++ }), this.uuid = PI(), this.name = "", this.type = "Material", this.blending = Cb, this.side = Um, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = S2, this.blendDst = Z2, this.blendEquation = gv, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new ai(0, 0, 0), this.blendAlpha = 0, this.depthFunc = mw, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = OH, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = eb, this.stencilZFail = eb, this.stencilZPass = eb, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Cb && (n.blending = this.blending), this.side !== Um && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== S2 && (n.blendSrc = this.blendSrc), this.blendDst !== Z2 && (n.blendDst = this.blendDst), this.blendEquation !== gv && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== mw && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== OH && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== eb && (n.stencilFail = this.stencilFail), this.stencilZFail !== eb && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== eb && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(o) {
      const l = [];
      for (const u in o) {
        const I = o[u];
        delete I.metadata, l.push(I);
      }
      return l;
    }
    if (t) {
      const o = i(e.textures), l = i(e.images);
      o.length > 0 && (n.textures = o), l.length > 0 && (n.images = l);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let o = 0; o !== i; ++o)
        n[o] = t[o].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
  onBeforeRender() {
    console.warn("Material: onBeforeRender() has been removed.");
  }
}
class wv extends Cg {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new ai(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new uI(), this.combine = Qw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const zm = /* @__PURE__ */ V4();
function V4() {
  const r = new ArrayBuffer(4), e = new Float32Array(r), t = new Uint32Array(r), n = new Uint32Array(512), i = new Uint32Array(512);
  for (let I = 0; I < 256; ++I) {
    const C = I - 127;
    C < -27 ? (n[I] = 0, n[I | 256] = 32768, i[I] = 24, i[I | 256] = 24) : C < -14 ? (n[I] = 1024 >> -C - 14, n[I | 256] = 1024 >> -C - 14 | 32768, i[I] = -C - 1, i[I | 256] = -C - 1) : C <= 15 ? (n[I] = C + 15 << 10, n[I | 256] = C + 15 << 10 | 32768, i[I] = 13, i[I | 256] = 13) : C < 128 ? (n[I] = 31744, n[I | 256] = 64512, i[I] = 24, i[I | 256] = 24) : (n[I] = 31744, n[I | 256] = 64512, i[I] = 13, i[I | 256] = 13);
  }
  const o = new Uint32Array(2048), l = new Uint32Array(64), u = new Uint32Array(64);
  for (let I = 1; I < 1024; ++I) {
    let C = I << 13, f = 0;
    for (; (C & 8388608) === 0; )
      C <<= 1, f -= 8388608;
    C &= -8388609, f += 947912704, o[I] = C | f;
  }
  for (let I = 1024; I < 2048; ++I)
    o[I] = 939524096 + (I - 1024 << 13);
  for (let I = 1; I < 31; ++I)
    l[I] = I << 23;
  l[31] = 1199570944, l[32] = 2147483648;
  for (let I = 33; I < 63; ++I)
    l[I] = 2147483648 + (I - 32 << 23);
  l[63] = 3347054592;
  for (let I = 1; I < 64; ++I)
    I !== 32 && (u[I] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: l,
    offsetTable: u
  };
}
function eI(r) {
  Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), r = zs(r, -65504, 65504), zm.floatView[0] = r;
  const e = zm.uint32View[0], t = e >> 23 & 511;
  return zm.baseTable[t] + ((e & 8388607) >> zm.shiftTable[t]);
}
function UZ(r) {
  const e = r >> 10;
  return zm.uint32View[0] = zm.mantissaTable[zm.offsetTable[e] + (r & 1023)] + zm.exponentTable[e], zm.floatView[0];
}
const N4 = {
  toHalfFloat: eI,
  fromHalfFloat: UZ
}, _l = /* @__PURE__ */ new fe(), c1 = /* @__PURE__ */ new Lt();
class ja {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = Rw, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = ed, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return oB("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        c1.fromBufferAttribute(this, t), c1.applyMatrix3(e), this.setXY(t, c1.x, c1.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        _l.fromBufferAttribute(this, t), _l.applyMatrix3(e), this.setXYZ(t, _l.x, _l.y, _l.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      _l.fromBufferAttribute(this, t), _l.applyMatrix4(e), this.setXYZ(t, _l.x, _l.y, _l.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      _l.fromBufferAttribute(this, t), _l.applyNormalMatrix(e), this.setXYZ(t, _l.x, _l.y, _l.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      _l.fromBufferAttribute(this, t), _l.transformDirection(e), this.setXYZ(t, _l.x, _l.y, _l.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = qg(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = hr(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = hr(t, this.array), n = hr(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = hr(t, this.array), n = hr(n, this.array), i = hr(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, o) {
    return e *= this.itemSize, this.normalized && (t = hr(t, this.array), n = hr(n, this.array), i = hr(i, this.array), o = hr(o, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Rw && (e.usage = this.usage), e;
  }
}
class M4 extends ja {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class H4 extends ja {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class X4 extends ja {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class Y4 extends ja {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class gY extends ja {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class F4 extends ja {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class dY extends ja {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class E4 extends ja {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = UZ(this.array[e * this.itemSize]);
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.array[e * this.itemSize] = eI(t), this;
  }
  getY(e) {
    let t = UZ(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.array[e * this.itemSize + 1] = eI(t), this;
  }
  getZ(e) {
    let t = UZ(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.array[e * this.itemSize + 2] = eI(t), this;
  }
  getW(e) {
    let t = UZ(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.array[e * this.itemSize + 3] = eI(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = hr(t, this.array), n = hr(n, this.array)), this.array[e + 0] = eI(t), this.array[e + 1] = eI(n), this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = hr(t, this.array), n = hr(n, this.array), i = hr(i, this.array)), this.array[e + 0] = eI(t), this.array[e + 1] = eI(n), this.array[e + 2] = eI(i), this;
  }
  setXYZW(e, t, n, i, o) {
    return e *= this.itemSize, this.normalized && (t = hr(t, this.array), n = hr(n, this.array), i = hr(i, this.array), o = hr(o, this.array)), this.array[e + 0] = eI(t), this.array[e + 1] = eI(n), this.array[e + 2] = eI(i), this.array[e + 3] = eI(o), this;
  }
}
class fi extends ja {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let T4 = 0;
const DC = /* @__PURE__ */ new _i(), XM = /* @__PURE__ */ new qr(), VG = /* @__PURE__ */ new fe(), KI = /* @__PURE__ */ new nd(), ZZ = /* @__PURE__ */ new nd(), Ku = /* @__PURE__ */ new fe();
class Br extends eA {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: T4++ }), this.uuid = PI(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (XK(e) ? dY : gY)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const o = new Cr().getNormalMatrix(e);
      n.applyNormalMatrix(o), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return DC.makeRotationFromQuaternion(e), this.applyMatrix4(DC), this;
  }
  rotateX(e) {
    return DC.makeRotationX(e), this.applyMatrix4(DC), this;
  }
  rotateY(e) {
    return DC.makeRotationY(e), this.applyMatrix4(DC), this;
  }
  rotateZ(e) {
    return DC.makeRotationZ(e), this.applyMatrix4(DC), this;
  }
  translate(e, t, n) {
    return DC.makeTranslation(e, t, n), this.applyMatrix4(DC), this;
  }
  scale(e, t, n) {
    return DC.makeScale(e, t, n), this.applyMatrix4(DC), this;
  }
  lookAt(e) {
    return XM.lookAt(e), XM.updateMatrix(), this.applyMatrix4(XM.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(VG).negate(), this.translate(VG.x, VG.y, VG.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const o = e[n];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new fi(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new nd());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new fe(-1 / 0, -1 / 0, -1 / 0),
        new fe(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, i = t.length; n < i; n++) {
          const o = t[n];
          KI.setFromBufferAttribute(o), this.morphTargetsRelative ? (Ku.addVectors(this.boundingBox.min, KI.min), this.boundingBox.expandByPoint(Ku), Ku.addVectors(this.boundingBox.max, KI.max), this.boundingBox.expandByPoint(Ku)) : (this.boundingBox.expandByPoint(KI.min), this.boundingBox.expandByPoint(KI.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new dg());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new fe(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (KI.setFromBufferAttribute(e), t)
        for (let o = 0, l = t.length; o < l; o++) {
          const u = t[o];
          ZZ.setFromBufferAttribute(u), this.morphTargetsRelative ? (Ku.addVectors(KI.min, ZZ.min), KI.expandByPoint(Ku), Ku.addVectors(KI.max, ZZ.max), KI.expandByPoint(Ku)) : (KI.expandByPoint(ZZ.min), KI.expandByPoint(ZZ.max));
        }
      KI.getCenter(n);
      let i = 0;
      for (let o = 0, l = e.count; o < l; o++)
        Ku.fromBufferAttribute(e, o), i = Math.max(i, n.distanceToSquared(Ku));
      if (t)
        for (let o = 0, l = t.length; o < l; o++) {
          const u = t[o], I = this.morphTargetsRelative;
          for (let C = 0, f = u.count; C < f; C++)
            Ku.fromBufferAttribute(u, C), I && (VG.fromBufferAttribute(e, C), Ku.add(VG)), i = Math.max(i, n.distanceToSquared(Ku));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = t.position, i = t.normal, o = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ja(new Float32Array(4 * n.count), 4));
    const l = this.getAttribute("tangent"), u = [], I = [];
    for (let j = 0; j < n.count; j++)
      u[j] = new fe(), I[j] = new fe();
    const C = new fe(), f = new fe(), v = new fe(), b = new Lt(), S = new Lt(), R = new Lt(), W = new fe(), x = new fe();
    function N(j, J, O) {
      C.fromBufferAttribute(n, j), f.fromBufferAttribute(n, J), v.fromBufferAttribute(n, O), b.fromBufferAttribute(o, j), S.fromBufferAttribute(o, J), R.fromBufferAttribute(o, O), f.sub(C), v.sub(C), S.sub(b), R.sub(b);
      const ne = 1 / (S.x * R.y - R.x * S.y);
      isFinite(ne) && (W.copy(f).multiplyScalar(R.y).addScaledVector(v, -S.y).multiplyScalar(ne), x.copy(v).multiplyScalar(S.x).addScaledVector(f, -R.x).multiplyScalar(ne), u[j].add(W), u[J].add(W), u[O].add(W), I[j].add(x), I[J].add(x), I[O].add(x));
    }
    let Y = this.groups;
    Y.length === 0 && (Y = [{
      start: 0,
      count: e.count
    }]);
    for (let j = 0, J = Y.length; j < J; ++j) {
      const O = Y[j], ne = O.start, he = O.count;
      for (let pe = ne, Ae = ne + he; pe < Ae; pe += 3)
        N(
          e.getX(pe + 0),
          e.getX(pe + 1),
          e.getX(pe + 2)
        );
    }
    const F = new fe(), T = new fe(), P = new fe(), D = new fe();
    function L(j) {
      P.fromBufferAttribute(i, j), D.copy(P);
      const J = u[j];
      F.copy(J), F.sub(P.multiplyScalar(P.dot(J))).normalize(), T.crossVectors(D, J);
      const ne = T.dot(I[j]) < 0 ? -1 : 1;
      l.setXYZW(j, F.x, F.y, F.z, ne);
    }
    for (let j = 0, J = Y.length; j < J; ++j) {
      const O = Y[j], ne = O.start, he = O.count;
      for (let pe = ne, Ae = ne + he; pe < Ae; pe += 3)
        L(e.getX(pe + 0)), L(e.getX(pe + 1)), L(e.getX(pe + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new ja(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let b = 0, S = n.count; b < S; b++)
          n.setXYZ(b, 0, 0, 0);
      const i = new fe(), o = new fe(), l = new fe(), u = new fe(), I = new fe(), C = new fe(), f = new fe(), v = new fe();
      if (e)
        for (let b = 0, S = e.count; b < S; b += 3) {
          const R = e.getX(b + 0), W = e.getX(b + 1), x = e.getX(b + 2);
          i.fromBufferAttribute(t, R), o.fromBufferAttribute(t, W), l.fromBufferAttribute(t, x), f.subVectors(l, o), v.subVectors(i, o), f.cross(v), u.fromBufferAttribute(n, R), I.fromBufferAttribute(n, W), C.fromBufferAttribute(n, x), u.add(f), I.add(f), C.add(f), n.setXYZ(R, u.x, u.y, u.z), n.setXYZ(W, I.x, I.y, I.z), n.setXYZ(x, C.x, C.y, C.z);
        }
      else
        for (let b = 0, S = t.count; b < S; b += 3)
          i.fromBufferAttribute(t, b + 0), o.fromBufferAttribute(t, b + 1), l.fromBufferAttribute(t, b + 2), f.subVectors(l, o), v.subVectors(i, o), f.cross(v), n.setXYZ(b + 0, f.x, f.y, f.z), n.setXYZ(b + 1, f.x, f.y, f.z), n.setXYZ(b + 2, f.x, f.y, f.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Ku.fromBufferAttribute(e, t), Ku.normalize(), e.setXYZ(t, Ku.x, Ku.y, Ku.z);
  }
  toNonIndexed() {
    function e(u, I) {
      const C = u.array, f = u.itemSize, v = u.normalized, b = new C.constructor(I.length * f);
      let S = 0, R = 0;
      for (let W = 0, x = I.length; W < x; W++) {
        u.isInterleavedBufferAttribute ? S = I[W] * u.data.stride + u.offset : S = I[W] * f;
        for (let N = 0; N < f; N++)
          b[R++] = C[S++];
      }
      return new ja(b, f, v);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Br(), n = this.index.array, i = this.attributes;
    for (const u in i) {
      const I = i[u], C = e(I, n);
      t.setAttribute(u, C);
    }
    const o = this.morphAttributes;
    for (const u in o) {
      const I = [], C = o[u];
      for (let f = 0, v = C.length; f < v; f++) {
        const b = C[f], S = e(b, n);
        I.push(S);
      }
      t.morphAttributes[u] = I;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let u = 0, I = l.length; u < I; u++) {
      const C = l[u];
      t.addGroup(C.start, C.count, C.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const I = this.parameters;
      for (const C in I)
        I[C] !== void 0 && (e[C] = I[C]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const I in n) {
      const C = n[I];
      e.data.attributes[I] = C.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const I in this.morphAttributes) {
      const C = this.morphAttributes[I], f = [];
      for (let v = 0, b = C.length; v < b; v++) {
        const S = C[v];
        f.push(S.toJSON(e.data));
      }
      f.length > 0 && (i[I] = f, o = !0);
    }
    o && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const l = this.groups;
    l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
    const u = this.boundingSphere;
    return u !== null && (e.data.boundingSphere = {
      center: u.center.toArray(),
      radius: u.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const C in i) {
      const f = i[C];
      this.setAttribute(C, f.clone(t));
    }
    const o = e.morphAttributes;
    for (const C in o) {
      const f = [], v = o[C];
      for (let b = 0, S = v.length; b < S; b++)
        f.push(v[b].clone(t));
      this.morphAttributes[C] = f;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const l = e.groups;
    for (let C = 0, f = l.length; C < f; C++) {
      const v = l[C];
      this.addGroup(v.start, v.count, v.materialIndex);
    }
    const u = e.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    const I = e.boundingSphere;
    return I !== null && (this.boundingSphere = I.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const jT = /* @__PURE__ */ new _i(), Ty = /* @__PURE__ */ new Nb(), g1 = /* @__PURE__ */ new dg(), qT = /* @__PURE__ */ new fe(), NG = /* @__PURE__ */ new fe(), MG = /* @__PURE__ */ new fe(), HG = /* @__PURE__ */ new fe(), YM = /* @__PURE__ */ new fe(), d1 = /* @__PURE__ */ new fe(), I1 = /* @__PURE__ */ new Lt(), C1 = /* @__PURE__ */ new Lt(), h1 = /* @__PURE__ */ new Lt(), $T = /* @__PURE__ */ new fe(), e3 = /* @__PURE__ */ new fe(), t3 = /* @__PURE__ */ new fe(), f1 = /* @__PURE__ */ new fe(), p1 = /* @__PURE__ */ new fe();
class kl extends qr {
  constructor(e = new Br(), t = new wv()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, i = n.attributes.position, o = n.morphAttributes.position, l = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const u = this.morphTargetInfluences;
    if (o && u) {
      d1.set(0, 0, 0);
      for (let I = 0, C = o.length; I < C; I++) {
        const f = u[I], v = o[I];
        f !== 0 && (YM.fromBufferAttribute(v, e), l ? d1.addScaledVector(YM, f) : d1.addScaledVector(YM.sub(t), f));
      }
      t.add(d1);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.material, o = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), g1.copy(n.boundingSphere), g1.applyMatrix4(o), Ty.copy(e.ray).recast(e.near), !(g1.containsPoint(Ty.origin) === !1 && (Ty.intersectSphere(g1, qT) === null || Ty.origin.distanceToSquared(qT) > (e.far - e.near) ** 2)) && (jT.copy(o).invert(), Ty.copy(e.ray).applyMatrix4(jT), !(n.boundingBox !== null && Ty.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Ty)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const o = this.geometry, l = this.material, u = o.index, I = o.attributes.position, C = o.attributes.uv, f = o.attributes.uv1, v = o.attributes.normal, b = o.groups, S = o.drawRange;
    if (u !== null)
      if (Array.isArray(l))
        for (let R = 0, W = b.length; R < W; R++) {
          const x = b[R], N = l[x.materialIndex], Y = Math.max(x.start, S.start), F = Math.min(u.count, Math.min(x.start + x.count, S.start + S.count));
          for (let T = Y, P = F; T < P; T += 3) {
            const D = u.getX(T), L = u.getX(T + 1), j = u.getX(T + 2);
            i = m1(this, N, e, n, C, f, v, D, L, j), i && (i.faceIndex = Math.floor(T / 3), i.face.materialIndex = x.materialIndex, t.push(i));
          }
        }
      else {
        const R = Math.max(0, S.start), W = Math.min(u.count, S.start + S.count);
        for (let x = R, N = W; x < N; x += 3) {
          const Y = u.getX(x), F = u.getX(x + 1), T = u.getX(x + 2);
          i = m1(this, l, e, n, C, f, v, Y, F, T), i && (i.faceIndex = Math.floor(x / 3), t.push(i));
        }
      }
    else if (I !== void 0)
      if (Array.isArray(l))
        for (let R = 0, W = b.length; R < W; R++) {
          const x = b[R], N = l[x.materialIndex], Y = Math.max(x.start, S.start), F = Math.min(I.count, Math.min(x.start + x.count, S.start + S.count));
          for (let T = Y, P = F; T < P; T += 3) {
            const D = T, L = T + 1, j = T + 2;
            i = m1(this, N, e, n, C, f, v, D, L, j), i && (i.faceIndex = Math.floor(T / 3), i.face.materialIndex = x.materialIndex, t.push(i));
          }
        }
      else {
        const R = Math.max(0, S.start), W = Math.min(I.count, S.start + S.count);
        for (let x = R, N = W; x < N; x += 3) {
          const Y = x, F = x + 1, T = x + 2;
          i = m1(this, l, e, n, C, f, v, Y, F, T), i && (i.faceIndex = Math.floor(x / 3), t.push(i));
        }
      }
  }
}
function _4(r, e, t, n, i, o, l, u) {
  let I;
  if (e.side === td ? I = n.intersectTriangle(l, o, i, !0, u) : I = n.intersectTriangle(i, o, l, e.side === Um, u), I === null) return null;
  p1.copy(u), p1.applyMatrix4(r.matrixWorld);
  const C = t.ray.origin.distanceTo(p1);
  return C < t.near || C > t.far ? null : {
    distance: C,
    point: p1.clone(),
    object: r
  };
}
function m1(r, e, t, n, i, o, l, u, I, C) {
  r.getVertexPosition(u, NG), r.getVertexPosition(I, MG), r.getVertexPosition(C, HG);
  const f = _4(r, e, t, n, NG, MG, HG, f1);
  if (f) {
    i && (I1.fromBufferAttribute(i, u), C1.fromBufferAttribute(i, I), h1.fromBufferAttribute(i, C), f.uv = DI.getInterpolation(f1, NG, MG, HG, I1, C1, h1, new Lt())), o && (I1.fromBufferAttribute(o, u), C1.fromBufferAttribute(o, I), h1.fromBufferAttribute(o, C), f.uv1 = DI.getInterpolation(f1, NG, MG, HG, I1, C1, h1, new Lt())), l && ($T.fromBufferAttribute(l, u), e3.fromBufferAttribute(l, I), t3.fromBufferAttribute(l, C), f.normal = DI.getInterpolation(f1, NG, MG, HG, $T, e3, t3, new fe()), f.normal.dot(n.direction) > 0 && f.normal.multiplyScalar(-1));
    const v = {
      a: u,
      b: I,
      c: C,
      normal: new fe(),
      materialIndex: 0
    };
    DI.getNormal(NG, MG, HG, v.normal), f.face = v;
  }
  return f;
}
class Mb extends Br {
  constructor(e = 1, t = 1, n = 1, i = 1, o = 1, l = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: i,
      heightSegments: o,
      depthSegments: l
    };
    const u = this;
    i = Math.floor(i), o = Math.floor(o), l = Math.floor(l);
    const I = [], C = [], f = [], v = [];
    let b = 0, S = 0;
    R("z", "y", "x", -1, -1, n, t, e, l, o, 0), R("z", "y", "x", 1, -1, n, t, -e, l, o, 1), R("x", "z", "y", 1, 1, e, n, t, i, l, 2), R("x", "z", "y", 1, -1, e, n, -t, i, l, 3), R("x", "y", "z", 1, -1, e, t, n, i, o, 4), R("x", "y", "z", -1, -1, e, t, -n, i, o, 5), this.setIndex(I), this.setAttribute("position", new fi(C, 3)), this.setAttribute("normal", new fi(f, 3)), this.setAttribute("uv", new fi(v, 2));
    function R(W, x, N, Y, F, T, P, D, L, j, J) {
      const O = T / L, ne = P / j, he = T / 2, pe = P / 2, Ae = D / 2, ke = L + 1, Re = j + 1;
      let Xe = 0, re = 0;
      const Se = new fe();
      for (let Be = 0; Be < Re; Be++) {
        const le = Be * ne - pe;
        for (let Ye = 0; Ye < ke; Ye++) {
          const nt = Ye * O - he;
          Se[W] = nt * Y, Se[x] = le * F, Se[N] = Ae, C.push(Se.x, Se.y, Se.z), Se[W] = 0, Se[x] = 0, Se[N] = D > 0 ? 1 : -1, f.push(Se.x, Se.y, Se.z), v.push(Ye / L), v.push(1 - Be / j), Xe += 1;
        }
      }
      for (let Be = 0; Be < j; Be++)
        for (let le = 0; le < L; le++) {
          const Ye = b + le + ke * Be, nt = b + le + ke * (Be + 1), ze = b + (le + 1) + ke * (Be + 1), Je = b + (le + 1) + ke * Be;
          I.push(Ye, nt, Je), I.push(nt, ze, Je), re += 6;
        }
      u.addGroup(S, re, J), S += re, b += Xe;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mb(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function fB(r) {
  const e = {};
  for (const t in r) {
    e[t] = {};
    for (const n in r[t]) {
      const i = r[t][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
    }
  }
  return e;
}
function Pg(r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const n = fB(r[t]);
    for (const i in n)
      e[i] = n[i];
  }
  return e;
}
function z4(r) {
  const e = [];
  for (let t = 0; t < r.length; t++)
    e.push(r[t].clone());
  return e;
}
function _K(r) {
  const e = r.getRenderTarget();
  return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : ya.workingColorSpace;
}
const zK = { clone: fB, merge: Pg };
var K4 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, L4 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class rf extends Cg {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = K4, this.fragmentShader = L4, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = fB(e.uniforms), this.uniformsGroups = z4(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const l = this.uniforms[i].value;
      l && l.isTexture ? t.uniforms[i] = {
        type: "t",
        value: l.toJSON(e).uuid
      } : l && l.isColor ? t.uniforms[i] = {
        type: "c",
        value: l.getHex()
      } : l && l.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: l.toArray()
      } : l && l.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: l.toArray()
      } : l && l.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: l.toArray()
      } : l && l.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: l.toArray()
      } : l && l.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: l.toArray()
      } : t.uniforms[i] = {
        value: l
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class $w extends qr {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new _i(), this.projectionMatrix = new _i(), this.projectionMatrixInverse = new _i(), this.coordinateSystem = op;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const av = /* @__PURE__ */ new fe(), n3 = /* @__PURE__ */ new Lt(), i3 = /* @__PURE__ */ new Lt();
let hl = class extends $w {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = hB * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(fb * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return hB * 2 * Math.atan(
      Math.tan(fb * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, t, n) {
    av.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(av.x, av.y).multiplyScalar(-e / av.z), av.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(av.x, av.y).multiplyScalar(-e / av.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, n3, i3), t.subVectors(i3, n3);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, i, o, l) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(fb * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, o = -0.5 * i;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const I = l.fullWidth, C = l.fullHeight;
      o += l.offsetX * i / I, t -= l.offsetY * n / C, i *= l.width / I, n *= l.height / C;
    }
    const u = this.filmOffset;
    u !== 0 && (o += e * u / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
};
const XG = -90, YG = 1;
class KK extends qr {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new hl(XG, YG, e, t);
    i.layers = this.layers, this.add(i);
    const o = new hl(XG, YG, e, t);
    o.layers = this.layers, this.add(o);
    const l = new hl(XG, YG, e, t);
    l.layers = this.layers, this.add(l);
    const u = new hl(XG, YG, e, t);
    u.layers = this.layers, this.add(u);
    const I = new hl(XG, YG, e, t);
    I.layers = this.layers, this.add(I);
    const C = new hl(XG, YG, e, t);
    C.layers = this.layers, this.add(C);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, i, o, l, u, I] = t;
    for (const C of t) this.remove(C);
    if (e === op)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), l.up.set(0, 0, 1), l.lookAt(0, -1, 0), u.up.set(0, 1, 0), u.lookAt(0, 0, 1), I.up.set(0, 1, 0), I.lookAt(0, 0, -1);
    else if (e === xw)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), l.up.set(0, 0, -1), l.lookAt(0, -1, 0), u.up.set(0, -1, 0), u.lookAt(0, 0, 1), I.up.set(0, -1, 0), I.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const C of t)
      this.add(C), C.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, l, u, I, C, f] = this.children, v = e.getRenderTarget(), b = e.getActiveCubeFace(), S = e.getActiveMipmapLevel(), R = e.xr.enabled;
    e.xr.enabled = !1;
    const W = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, o), e.setRenderTarget(n, 1, i), e.render(t, l), e.setRenderTarget(n, 2, i), e.render(t, u), e.setRenderTarget(n, 3, i), e.render(t, I), e.setRenderTarget(n, 4, i), e.render(t, C), n.texture.generateMipmaps = W, e.setRenderTarget(n, 5, i), e.render(t, f), e.setRenderTarget(v, b, S), e.xr.enabled = R, n.texture.needsPMREMUpdate = !0;
  }
}
class eR extends ks {
  constructor(e, t, n, i, o, l, u, I, C, f) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Om, super(e, t, n, i, o, l, u, I, C, f), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class LK extends QC {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
    this.texture = new eR(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ks;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new Mb(5, 5, 5), o = new rf({
      name: "CubemapFromEquirect",
      uniforms: fB(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: td,
      blending: Dm
    });
    o.uniforms.tEquirect.value = t;
    const l = new kl(i, o), u = t.minFilter;
    return t.minFilter === ap && (t.minFilter = Ks), new KK(1, 10, this).update(e, l), t.minFilter = u, l.geometry.dispose(), l.material.dispose(), this;
  }
  clear(e, t, n, i) {
    const o = e.getRenderTarget();
    for (let l = 0; l < 6; l++)
      e.setRenderTarget(this, l), e.clear(t, n, i);
    e.setRenderTarget(o);
  }
}
const FM = /* @__PURE__ */ new fe(), k4 = /* @__PURE__ */ new fe(), D4 = /* @__PURE__ */ new Cr();
class Em {
  constructor(e = new fe(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = FM.subVectors(n, t).cross(k4.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(FM), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(n, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || D4.getNormalMatrix(e), i = this.coplanarPoint(FM).applyMatrix4(e), o = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _y = /* @__PURE__ */ new dg(), A1 = /* @__PURE__ */ new fe();
class tR {
  constructor(e = new Em(), t = new Em(), n = new Em(), i = new Em(), o = new Em(), l = new Em()) {
    this.planes = [e, t, n, i, o, l];
  }
  set(e, t, n, i, o, l) {
    const u = this.planes;
    return u[0].copy(e), u[1].copy(t), u[2].copy(n), u[3].copy(i), u[4].copy(o), u[5].copy(l), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = op) {
    const n = this.planes, i = e.elements, o = i[0], l = i[1], u = i[2], I = i[3], C = i[4], f = i[5], v = i[6], b = i[7], S = i[8], R = i[9], W = i[10], x = i[11], N = i[12], Y = i[13], F = i[14], T = i[15];
    if (n[0].setComponents(I - o, b - C, x - S, T - N).normalize(), n[1].setComponents(I + o, b + C, x + S, T + N).normalize(), n[2].setComponents(I + l, b + f, x + R, T + Y).normalize(), n[3].setComponents(I - l, b - f, x - R, T - Y).normalize(), n[4].setComponents(I - u, b - v, x - W, T - F).normalize(), t === op)
      n[5].setComponents(I + u, b + v, x + W, T + F).normalize();
    else if (t === xw)
      n[5].setComponents(u, v, W, F).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), _y.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), _y.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(_y);
  }
  intersectsSprite(e) {
    return _y.center.set(0, 0, 0), _y.radius = 0.7071067811865476, _y.applyMatrix4(e.matrixWorld), this.intersectsSphere(_y);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, i = -e.radius;
    for (let o = 0; o < 6; o++)
      if (t[o].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (A1.x = i.normal.x > 0 ? e.max.x : e.min.x, A1.y = i.normal.y > 0 ? e.max.y : e.min.y, A1.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(A1) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function kK() {
  let r = null, e = !1, t = null, n = null;
  function i(o, l) {
    t(o, l), n = r.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = r.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      r.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(o) {
      t = o;
    },
    setContext: function(o) {
      r = o;
    }
  };
}
function U4(r) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(u, I) {
    const C = u.array, f = u.usage, v = C.byteLength, b = r.createBuffer();
    r.bindBuffer(I, b), r.bufferData(I, C, f), u.onUploadCallback();
    let S;
    if (C instanceof Float32Array)
      S = r.FLOAT;
    else if (C instanceof Uint16Array)
      u.isFloat16BufferAttribute ? S = r.HALF_FLOAT : S = r.UNSIGNED_SHORT;
    else if (C instanceof Int16Array)
      S = r.SHORT;
    else if (C instanceof Uint32Array)
      S = r.UNSIGNED_INT;
    else if (C instanceof Int32Array)
      S = r.INT;
    else if (C instanceof Int8Array)
      S = r.BYTE;
    else if (C instanceof Uint8Array)
      S = r.UNSIGNED_BYTE;
    else if (C instanceof Uint8ClampedArray)
      S = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + C);
    return {
      buffer: b,
      type: S,
      bytesPerElement: C.BYTES_PER_ELEMENT,
      version: u.version,
      size: v
    };
  }
  function n(u, I, C) {
    const f = I.array, v = I._updateRange, b = I.updateRanges;
    if (r.bindBuffer(C, u), v.count === -1 && b.length === 0 && r.bufferSubData(C, 0, f), b.length !== 0) {
      for (let S = 0, R = b.length; S < R; S++) {
        const W = b[S];
        r.bufferSubData(
          C,
          W.start * f.BYTES_PER_ELEMENT,
          f,
          W.start,
          W.count
        );
      }
      I.clearUpdateRanges();
    }
    v.count !== -1 && (r.bufferSubData(
      C,
      v.offset * f.BYTES_PER_ELEMENT,
      f,
      v.offset,
      v.count
    ), v.count = -1), I.onUploadCallback();
  }
  function i(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), e.get(u);
  }
  function o(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const I = e.get(u);
    I && (r.deleteBuffer(I.buffer), e.delete(u));
  }
  function l(u, I) {
    if (u.isInterleavedBufferAttribute && (u = u.data), u.isGLBufferAttribute) {
      const f = e.get(u);
      (!f || f.version < u.version) && e.set(u, {
        buffer: u.buffer,
        type: u.type,
        bytesPerElement: u.elementSize,
        version: u.version
      });
      return;
    }
    const C = e.get(u);
    if (C === void 0)
      e.set(u, t(u, I));
    else if (C.version < u.version) {
      if (C.size !== u.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(C.buffer, u, I), C.version = u.version;
    }
  }
  return {
    get: i,
    remove: o,
    update: l
  };
}
class WB extends Br {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: i
    };
    const o = e / 2, l = t / 2, u = Math.floor(n), I = Math.floor(i), C = u + 1, f = I + 1, v = e / u, b = t / I, S = [], R = [], W = [], x = [];
    for (let N = 0; N < f; N++) {
      const Y = N * b - l;
      for (let F = 0; F < C; F++) {
        const T = F * v - o;
        R.push(T, -Y, 0), W.push(0, 0, 1), x.push(F / u), x.push(1 - N / I);
      }
    }
    for (let N = 0; N < I; N++)
      for (let Y = 0; Y < u; Y++) {
        const F = Y + C * N, T = Y + C * (N + 1), P = Y + 1 + C * (N + 1), D = Y + 1 + C * N;
        S.push(F, T, D), S.push(T, P, D);
      }
    this.setIndex(S), this.setAttribute("position", new fi(R, 3)), this.setAttribute("normal", new fi(W, 3)), this.setAttribute("uv", new fi(x, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new WB(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var O4 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, P4 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, J4 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Q4 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, j4 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, q4 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, $4 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, ej = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, tj = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, nj = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, ij = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, rj = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, aj = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, oj = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, sj = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, lj = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, uj = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, cj = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, gj = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, dj = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Ij = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Cj = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, hj = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, fj = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, pj = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, mj = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Aj = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, vj = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, yj = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, bj = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Gj = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Bj = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Sj = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Zj = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, wj = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Rj = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, xj = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Wj = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Vj = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Nj = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Mj = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Hj = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Xj = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Yj = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Fj = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Ej = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Tj = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, _j = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, zj = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Kj = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Lj = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, kj = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Dj = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Uj = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Oj = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Pj = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Jj = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Qj = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, jj = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, qj = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, $j = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, e7 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, t7 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, n7 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, i7 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, r7 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, a7 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, o7 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, s7 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, l7 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, u7 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, c7 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, g7 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, d7 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, I7 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, C7 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, h7 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, f7 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, p7 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, m7 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, A7 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, v7 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, y7 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, b7 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, G7 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, B7 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, S7 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Z7 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, w7 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, R7 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, x7 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, W7 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, V7 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, N7 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, M7 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, H7 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, X7 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Y7 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, F7 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, E7 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, T7 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, _7 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, z7 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, K7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, L7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, k7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, D7 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const U7 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, O7 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, P7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, J7 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Q7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, j7 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, q7 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, $7 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, e8 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, t8 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, n8 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, i8 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, r8 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, a8 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, o8 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, s8 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, l8 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, u8 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, c8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, g8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, d8 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, I8 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, C8 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, h8 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, f8 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, p8 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, m8 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, A8 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, v8 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, y8 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, b8 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, G8 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, B8 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, S8 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ar = {
  alphahash_fragment: O4,
  alphahash_pars_fragment: P4,
  alphamap_fragment: J4,
  alphamap_pars_fragment: Q4,
  alphatest_fragment: j4,
  alphatest_pars_fragment: q4,
  aomap_fragment: $4,
  aomap_pars_fragment: ej,
  batching_pars_vertex: tj,
  batching_vertex: nj,
  begin_vertex: ij,
  beginnormal_vertex: rj,
  bsdfs: aj,
  iridescence_fragment: oj,
  bumpmap_pars_fragment: sj,
  clipping_planes_fragment: lj,
  clipping_planes_pars_fragment: uj,
  clipping_planes_pars_vertex: cj,
  clipping_planes_vertex: gj,
  color_fragment: dj,
  color_pars_fragment: Ij,
  color_pars_vertex: Cj,
  color_vertex: hj,
  common: fj,
  cube_uv_reflection_fragment: pj,
  defaultnormal_vertex: mj,
  displacementmap_pars_vertex: Aj,
  displacementmap_vertex: vj,
  emissivemap_fragment: yj,
  emissivemap_pars_fragment: bj,
  colorspace_fragment: Gj,
  colorspace_pars_fragment: Bj,
  envmap_fragment: Sj,
  envmap_common_pars_fragment: Zj,
  envmap_pars_fragment: wj,
  envmap_pars_vertex: Rj,
  envmap_physical_pars_fragment: Tj,
  envmap_vertex: xj,
  fog_vertex: Wj,
  fog_pars_vertex: Vj,
  fog_fragment: Nj,
  fog_pars_fragment: Mj,
  gradientmap_pars_fragment: Hj,
  lightmap_pars_fragment: Xj,
  lights_lambert_fragment: Yj,
  lights_lambert_pars_fragment: Fj,
  lights_pars_begin: Ej,
  lights_toon_fragment: _j,
  lights_toon_pars_fragment: zj,
  lights_phong_fragment: Kj,
  lights_phong_pars_fragment: Lj,
  lights_physical_fragment: kj,
  lights_physical_pars_fragment: Dj,
  lights_fragment_begin: Uj,
  lights_fragment_maps: Oj,
  lights_fragment_end: Pj,
  logdepthbuf_fragment: Jj,
  logdepthbuf_pars_fragment: Qj,
  logdepthbuf_pars_vertex: jj,
  logdepthbuf_vertex: qj,
  map_fragment: $j,
  map_pars_fragment: e7,
  map_particle_fragment: t7,
  map_particle_pars_fragment: n7,
  metalnessmap_fragment: i7,
  metalnessmap_pars_fragment: r7,
  morphinstance_vertex: a7,
  morphcolor_vertex: o7,
  morphnormal_vertex: s7,
  morphtarget_pars_vertex: l7,
  morphtarget_vertex: u7,
  normal_fragment_begin: c7,
  normal_fragment_maps: g7,
  normal_pars_fragment: d7,
  normal_pars_vertex: I7,
  normal_vertex: C7,
  normalmap_pars_fragment: h7,
  clearcoat_normal_fragment_begin: f7,
  clearcoat_normal_fragment_maps: p7,
  clearcoat_pars_fragment: m7,
  iridescence_pars_fragment: A7,
  opaque_fragment: v7,
  packing: y7,
  premultiplied_alpha_fragment: b7,
  project_vertex: G7,
  dithering_fragment: B7,
  dithering_pars_fragment: S7,
  roughnessmap_fragment: Z7,
  roughnessmap_pars_fragment: w7,
  shadowmap_pars_fragment: R7,
  shadowmap_pars_vertex: x7,
  shadowmap_vertex: W7,
  shadowmask_pars_fragment: V7,
  skinbase_vertex: N7,
  skinning_pars_vertex: M7,
  skinning_vertex: H7,
  skinnormal_vertex: X7,
  specularmap_fragment: Y7,
  specularmap_pars_fragment: F7,
  tonemapping_fragment: E7,
  tonemapping_pars_fragment: T7,
  transmission_fragment: _7,
  transmission_pars_fragment: z7,
  uv_pars_fragment: K7,
  uv_pars_vertex: L7,
  uv_vertex: k7,
  worldpos_vertex: D7,
  background_vert: U7,
  background_frag: O7,
  backgroundCube_vert: P7,
  backgroundCube_frag: J7,
  cube_vert: Q7,
  cube_frag: j7,
  depth_vert: q7,
  depth_frag: $7,
  distanceRGBA_vert: e8,
  distanceRGBA_frag: t8,
  equirect_vert: n8,
  equirect_frag: i8,
  linedashed_vert: r8,
  linedashed_frag: a8,
  meshbasic_vert: o8,
  meshbasic_frag: s8,
  meshlambert_vert: l8,
  meshlambert_frag: u8,
  meshmatcap_vert: c8,
  meshmatcap_frag: g8,
  meshnormal_vert: d8,
  meshnormal_frag: I8,
  meshphong_vert: C8,
  meshphong_frag: h8,
  meshphysical_vert: f8,
  meshphysical_frag: p8,
  meshtoon_vert: m8,
  meshtoon_frag: A8,
  points_vert: v8,
  points_frag: y8,
  shadow_vert: b8,
  shadow_frag: G8,
  sprite_vert: B8,
  sprite_frag: S8
}, Pn = {
  common: {
    diffuse: { value: /* @__PURE__ */ new ai(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Cr() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Cr() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Cr() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Cr() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Cr() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Cr() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Cr() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Cr() },
    normalScale: { value: /* @__PURE__ */ new Lt(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Cr() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Cr() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Cr() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Cr() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new ai(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new ai(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Cr() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Cr() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new ai(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Lt(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Cr() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Cr() },
    alphaTest: { value: 0 }
  }
}, ef = {
  basic: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.specularmap,
      Pn.envmap,
      Pn.aomap,
      Pn.lightmap,
      Pn.fog
    ]),
    vertexShader: Ar.meshbasic_vert,
    fragmentShader: Ar.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.specularmap,
      Pn.envmap,
      Pn.aomap,
      Pn.lightmap,
      Pn.emissivemap,
      Pn.bumpmap,
      Pn.normalmap,
      Pn.displacementmap,
      Pn.fog,
      Pn.lights,
      {
        emissive: { value: /* @__PURE__ */ new ai(0) }
      }
    ]),
    vertexShader: Ar.meshlambert_vert,
    fragmentShader: Ar.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.specularmap,
      Pn.envmap,
      Pn.aomap,
      Pn.lightmap,
      Pn.emissivemap,
      Pn.bumpmap,
      Pn.normalmap,
      Pn.displacementmap,
      Pn.fog,
      Pn.lights,
      {
        emissive: { value: /* @__PURE__ */ new ai(0) },
        specular: { value: /* @__PURE__ */ new ai(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Ar.meshphong_vert,
    fragmentShader: Ar.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.envmap,
      Pn.aomap,
      Pn.lightmap,
      Pn.emissivemap,
      Pn.bumpmap,
      Pn.normalmap,
      Pn.displacementmap,
      Pn.roughnessmap,
      Pn.metalnessmap,
      Pn.fog,
      Pn.lights,
      {
        emissive: { value: /* @__PURE__ */ new ai(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Ar.meshphysical_vert,
    fragmentShader: Ar.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.aomap,
      Pn.lightmap,
      Pn.emissivemap,
      Pn.bumpmap,
      Pn.normalmap,
      Pn.displacementmap,
      Pn.gradientmap,
      Pn.fog,
      Pn.lights,
      {
        emissive: { value: /* @__PURE__ */ new ai(0) }
      }
    ]),
    vertexShader: Ar.meshtoon_vert,
    fragmentShader: Ar.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.bumpmap,
      Pn.normalmap,
      Pn.displacementmap,
      Pn.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Ar.meshmatcap_vert,
    fragmentShader: Ar.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.points,
      Pn.fog
    ]),
    vertexShader: Ar.points_vert,
    fragmentShader: Ar.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Ar.linedashed_vert,
    fragmentShader: Ar.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.displacementmap
    ]),
    vertexShader: Ar.depth_vert,
    fragmentShader: Ar.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.bumpmap,
      Pn.normalmap,
      Pn.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ar.meshnormal_vert,
    fragmentShader: Ar.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.sprite,
      Pn.fog
    ]),
    vertexShader: Ar.sprite_vert,
    fragmentShader: Ar.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Cr() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Ar.background_vert,
    fragmentShader: Ar.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Cr() }
    },
    vertexShader: Ar.backgroundCube_vert,
    fragmentShader: Ar.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Ar.cube_vert,
    fragmentShader: Ar.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Ar.equirect_vert,
    fragmentShader: Ar.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.common,
      Pn.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new fe() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Ar.distanceRGBA_vert,
    fragmentShader: Ar.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Pg([
      Pn.lights,
      Pn.fog,
      {
        color: { value: /* @__PURE__ */ new ai(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ar.shadow_vert,
    fragmentShader: Ar.shadow_frag
  }
};
ef.physical = {
  uniforms: /* @__PURE__ */ Pg([
    ef.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Cr() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Cr() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Lt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Cr() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Cr() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Cr() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new ai(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Cr() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Cr() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Cr() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Lt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Cr() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new ai(0) },
      specularColor: { value: /* @__PURE__ */ new ai(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Cr() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Cr() },
      anisotropyVector: { value: /* @__PURE__ */ new Lt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Cr() }
    }
  ]),
  vertexShader: Ar.meshphysical_vert,
  fragmentShader: Ar.meshphysical_frag
};
const v1 = { r: 0, b: 0, g: 0 }, zy = /* @__PURE__ */ new uI(), Z8 = /* @__PURE__ */ new _i();
function w8(r, e, t, n, i, o, l) {
  const u = new ai(0);
  let I = o === !0 ? 0 : 1, C, f, v = null, b = 0, S = null;
  function R(Y) {
    let F = Y.isScene === !0 ? Y.background : null;
    return F && F.isTexture && (F = (Y.backgroundBlurriness > 0 ? t : e).get(F)), F;
  }
  function W(Y) {
    let F = !1;
    const T = R(Y);
    T === null ? N(u, I) : T && T.isColor && (N(T, 1), F = !0);
    const P = r.xr.getEnvironmentBlendMode();
    P === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, l) : P === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, l), (r.autoClear || F) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
  }
  function x(Y, F) {
    const T = R(F);
    T && (T.isCubeTexture || T.mapping === xB) ? (f === void 0 && (f = new kl(
      new Mb(1, 1, 1),
      new rf({
        name: "BackgroundCubeMaterial",
        uniforms: fB(ef.backgroundCube.uniforms),
        vertexShader: ef.backgroundCube.vertexShader,
        fragmentShader: ef.backgroundCube.fragmentShader,
        side: td,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), f.geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function(P, D, L) {
      this.matrixWorld.copyPosition(L.matrixWorld);
    }, Object.defineProperty(f.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(f)), zy.copy(F.backgroundRotation), zy.x *= -1, zy.y *= -1, zy.z *= -1, T.isCubeTexture && T.isRenderTargetTexture === !1 && (zy.y *= -1, zy.z *= -1), f.material.uniforms.envMap.value = T, f.material.uniforms.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === !1 ? -1 : 1, f.material.uniforms.backgroundBlurriness.value = F.backgroundBlurriness, f.material.uniforms.backgroundIntensity.value = F.backgroundIntensity, f.material.uniforms.backgroundRotation.value.setFromMatrix4(Z8.makeRotationFromEuler(zy)), f.material.toneMapped = ya.getTransfer(T.colorSpace) !== Ho, (v !== T || b !== T.version || S !== r.toneMapping) && (f.material.needsUpdate = !0, v = T, b = T.version, S = r.toneMapping), f.layers.enableAll(), Y.unshift(f, f.geometry, f.material, 0, 0, null)) : T && T.isTexture && (C === void 0 && (C = new kl(
      new WB(2, 2),
      new rf({
        name: "BackgroundMaterial",
        uniforms: fB(ef.background.uniforms),
        vertexShader: ef.background.vertexShader,
        fragmentShader: ef.background.fragmentShader,
        side: Um,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), C.geometry.deleteAttribute("normal"), Object.defineProperty(C.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(C)), C.material.uniforms.t2D.value = T, C.material.uniforms.backgroundIntensity.value = F.backgroundIntensity, C.material.toneMapped = ya.getTransfer(T.colorSpace) !== Ho, T.matrixAutoUpdate === !0 && T.updateMatrix(), C.material.uniforms.uvTransform.value.copy(T.matrix), (v !== T || b !== T.version || S !== r.toneMapping) && (C.material.needsUpdate = !0, v = T, b = T.version, S = r.toneMapping), C.layers.enableAll(), Y.unshift(C, C.geometry, C.material, 0, 0, null));
  }
  function N(Y, F) {
    Y.getRGB(v1, _K(r)), n.buffers.color.setClear(v1.r, v1.g, v1.b, F, l);
  }
  return {
    getClearColor: function() {
      return u;
    },
    setClearColor: function(Y, F = 1) {
      u.set(Y), I = F, N(u, I);
    },
    getClearAlpha: function() {
      return I;
    },
    setClearAlpha: function(Y) {
      I = Y, N(u, I);
    },
    render: W,
    addToRenderList: x
  };
}
function R8(r, e) {
  const t = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, i = b(null);
  let o = i, l = !1;
  function u(O, ne, he, pe, Ae) {
    let ke = !1;
    const Re = v(pe, he, ne);
    o !== Re && (o = Re, C(o.object)), ke = S(O, pe, he, Ae), ke && R(O, pe, he, Ae), Ae !== null && e.update(Ae, r.ELEMENT_ARRAY_BUFFER), (ke || l) && (l = !1, T(O, ne, he, pe), Ae !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(Ae).buffer));
  }
  function I() {
    return r.createVertexArray();
  }
  function C(O) {
    return r.bindVertexArray(O);
  }
  function f(O) {
    return r.deleteVertexArray(O);
  }
  function v(O, ne, he) {
    const pe = he.wireframe === !0;
    let Ae = n[O.id];
    Ae === void 0 && (Ae = {}, n[O.id] = Ae);
    let ke = Ae[ne.id];
    ke === void 0 && (ke = {}, Ae[ne.id] = ke);
    let Re = ke[pe];
    return Re === void 0 && (Re = b(I()), ke[pe] = Re), Re;
  }
  function b(O) {
    const ne = [], he = [], pe = [];
    for (let Ae = 0; Ae < t; Ae++)
      ne[Ae] = 0, he[Ae] = 0, pe[Ae] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: ne,
      enabledAttributes: he,
      attributeDivisors: pe,
      object: O,
      attributes: {},
      index: null
    };
  }
  function S(O, ne, he, pe) {
    const Ae = o.attributes, ke = ne.attributes;
    let Re = 0;
    const Xe = he.getAttributes();
    for (const re in Xe)
      if (Xe[re].location >= 0) {
        const Be = Ae[re];
        let le = ke[re];
        if (le === void 0 && (re === "instanceMatrix" && O.instanceMatrix && (le = O.instanceMatrix), re === "instanceColor" && O.instanceColor && (le = O.instanceColor)), Be === void 0 || Be.attribute !== le || le && Be.data !== le.data) return !0;
        Re++;
      }
    return o.attributesNum !== Re || o.index !== pe;
  }
  function R(O, ne, he, pe) {
    const Ae = {}, ke = ne.attributes;
    let Re = 0;
    const Xe = he.getAttributes();
    for (const re in Xe)
      if (Xe[re].location >= 0) {
        let Be = ke[re];
        Be === void 0 && (re === "instanceMatrix" && O.instanceMatrix && (Be = O.instanceMatrix), re === "instanceColor" && O.instanceColor && (Be = O.instanceColor));
        const le = {};
        le.attribute = Be, Be && Be.data && (le.data = Be.data), Ae[re] = le, Re++;
      }
    o.attributes = Ae, o.attributesNum = Re, o.index = pe;
  }
  function W() {
    const O = o.newAttributes;
    for (let ne = 0, he = O.length; ne < he; ne++)
      O[ne] = 0;
  }
  function x(O) {
    N(O, 0);
  }
  function N(O, ne) {
    const he = o.newAttributes, pe = o.enabledAttributes, Ae = o.attributeDivisors;
    he[O] = 1, pe[O] === 0 && (r.enableVertexAttribArray(O), pe[O] = 1), Ae[O] !== ne && (r.vertexAttribDivisor(O, ne), Ae[O] = ne);
  }
  function Y() {
    const O = o.newAttributes, ne = o.enabledAttributes;
    for (let he = 0, pe = ne.length; he < pe; he++)
      ne[he] !== O[he] && (r.disableVertexAttribArray(he), ne[he] = 0);
  }
  function F(O, ne, he, pe, Ae, ke, Re) {
    Re === !0 ? r.vertexAttribIPointer(O, ne, he, Ae, ke) : r.vertexAttribPointer(O, ne, he, pe, Ae, ke);
  }
  function T(O, ne, he, pe) {
    W();
    const Ae = pe.attributes, ke = he.getAttributes(), Re = ne.defaultAttributeValues;
    for (const Xe in ke) {
      const re = ke[Xe];
      if (re.location >= 0) {
        let Se = Ae[Xe];
        if (Se === void 0 && (Xe === "instanceMatrix" && O.instanceMatrix && (Se = O.instanceMatrix), Xe === "instanceColor" && O.instanceColor && (Se = O.instanceColor)), Se !== void 0) {
          const Be = Se.normalized, le = Se.itemSize, Ye = e.get(Se);
          if (Ye === void 0) continue;
          const nt = Ye.buffer, ze = Ye.type, Je = Ye.bytesPerElement, wt = ze === r.INT || ze === r.UNSIGNED_INT || Se.gpuType === MW;
          if (Se.isInterleavedBufferAttribute) {
            const mt = Se.data, Dt = mt.stride, mn = Se.offset;
            if (mt.isInstancedInterleavedBuffer) {
              for (let An = 0; An < re.locationSize; An++)
                N(re.location + An, mt.meshPerAttribute);
              O.isInstancedMesh !== !0 && pe._maxInstanceCount === void 0 && (pe._maxInstanceCount = mt.meshPerAttribute * mt.count);
            } else
              for (let An = 0; An < re.locationSize; An++)
                x(re.location + An);
            r.bindBuffer(r.ARRAY_BUFFER, nt);
            for (let An = 0; An < re.locationSize; An++)
              F(
                re.location + An,
                le / re.locationSize,
                ze,
                Be,
                Dt * Je,
                (mn + le / re.locationSize * An) * Je,
                wt
              );
          } else {
            if (Se.isInstancedBufferAttribute) {
              for (let mt = 0; mt < re.locationSize; mt++)
                N(re.location + mt, Se.meshPerAttribute);
              O.isInstancedMesh !== !0 && pe._maxInstanceCount === void 0 && (pe._maxInstanceCount = Se.meshPerAttribute * Se.count);
            } else
              for (let mt = 0; mt < re.locationSize; mt++)
                x(re.location + mt);
            r.bindBuffer(r.ARRAY_BUFFER, nt);
            for (let mt = 0; mt < re.locationSize; mt++)
              F(
                re.location + mt,
                le / re.locationSize,
                ze,
                Be,
                le * Je,
                le / re.locationSize * mt * Je,
                wt
              );
          }
        } else if (Re !== void 0) {
          const Be = Re[Xe];
          if (Be !== void 0)
            switch (Be.length) {
              case 2:
                r.vertexAttrib2fv(re.location, Be);
                break;
              case 3:
                r.vertexAttrib3fv(re.location, Be);
                break;
              case 4:
                r.vertexAttrib4fv(re.location, Be);
                break;
              default:
                r.vertexAttrib1fv(re.location, Be);
            }
        }
      }
    }
    Y();
  }
  function P() {
    j();
    for (const O in n) {
      const ne = n[O];
      for (const he in ne) {
        const pe = ne[he];
        for (const Ae in pe)
          f(pe[Ae].object), delete pe[Ae];
        delete ne[he];
      }
      delete n[O];
    }
  }
  function D(O) {
    if (n[O.id] === void 0) return;
    const ne = n[O.id];
    for (const he in ne) {
      const pe = ne[he];
      for (const Ae in pe)
        f(pe[Ae].object), delete pe[Ae];
      delete ne[he];
    }
    delete n[O.id];
  }
  function L(O) {
    for (const ne in n) {
      const he = n[ne];
      if (he[O.id] === void 0) continue;
      const pe = he[O.id];
      for (const Ae in pe)
        f(pe[Ae].object), delete pe[Ae];
      delete he[O.id];
    }
  }
  function j() {
    J(), l = !0, o !== i && (o = i, C(o.object));
  }
  function J() {
    i.geometry = null, i.program = null, i.wireframe = !1;
  }
  return {
    setup: u,
    reset: j,
    resetDefaultState: J,
    dispose: P,
    releaseStatesOfGeometry: D,
    releaseStatesOfProgram: L,
    initAttributes: W,
    enableAttribute: x,
    disableUnusedAttributes: Y
  };
}
function x8(r, e, t) {
  let n;
  function i(C) {
    n = C;
  }
  function o(C, f) {
    r.drawArrays(n, C, f), t.update(f, n, 1);
  }
  function l(C, f, v) {
    v !== 0 && (r.drawArraysInstanced(n, C, f, v), t.update(f, n, v));
  }
  function u(C, f, v) {
    if (v === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, C, 0, f, 0, v);
    let S = 0;
    for (let R = 0; R < v; R++)
      S += f[R];
    t.update(S, n, 1);
  }
  function I(C, f, v, b) {
    if (v === 0) return;
    const S = e.get("WEBGL_multi_draw");
    if (S === null)
      for (let R = 0; R < C.length; R++)
        l(C[R], f[R], b[R]);
    else {
      S.multiDrawArraysInstancedWEBGL(n, C, 0, f, 0, b, 0, v);
      let R = 0;
      for (let W = 0; W < v; W++)
        R += f[W];
      for (let W = 0; W < b.length; W++)
        t.update(R, n, b[W]);
    }
  }
  this.setMode = i, this.render = o, this.renderInstances = l, this.renderMultiDraw = u, this.renderMultiDrawInstances = I;
}
function W8(r, e, t, n) {
  let i;
  function o() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const D = e.get("EXT_texture_filter_anisotropic");
      i = r.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function l(D) {
    return !(D !== cg && n.convert(D) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function u(D) {
    const L = D === Vb && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(D !== nf && n.convert(D) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    D !== ed && !L);
  }
  function I(D) {
    if (D === "highp") {
      if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
        return "highp";
      D = "mediump";
    }
    return D === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let C = t.precision !== void 0 ? t.precision : "highp";
  const f = I(C);
  f !== C && (console.warn("THREE.WebGLRenderer:", C, "not supported, using", f, "instead."), C = f);
  const v = t.logarithmicDepthBuffer === !0, b = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), S = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), R = r.getParameter(r.MAX_TEXTURE_SIZE), W = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), x = r.getParameter(r.MAX_VERTEX_ATTRIBS), N = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), Y = r.getParameter(r.MAX_VARYING_VECTORS), F = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), T = S > 0, P = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: o,
    getMaxPrecision: I,
    textureFormatReadable: l,
    textureTypeReadable: u,
    precision: C,
    logarithmicDepthBuffer: v,
    maxTextures: b,
    maxVertexTextures: S,
    maxTextureSize: R,
    maxCubemapSize: W,
    maxAttributes: x,
    maxVertexUniforms: N,
    maxVaryings: Y,
    maxFragmentUniforms: F,
    vertexTextures: T,
    maxSamples: P
  };
}
function V8(r) {
  const e = this;
  let t = null, n = 0, i = !1, o = !1;
  const l = new Em(), u = new Cr(), I = { value: null, needsUpdate: !1 };
  this.uniform = I, this.numPlanes = 0, this.numIntersection = 0, this.init = function(v, b) {
    const S = v.length !== 0 || b || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || i;
    return i = b, n = v.length, S;
  }, this.beginShadows = function() {
    o = !0, f(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(v, b) {
    t = f(v, b, 0);
  }, this.setState = function(v, b, S) {
    const R = v.clippingPlanes, W = v.clipIntersection, x = v.clipShadows, N = r.get(v);
    if (!i || R === null || R.length === 0 || o && !x)
      o ? f(null) : C();
    else {
      const Y = o ? 0 : n, F = Y * 4;
      let T = N.clippingState || null;
      I.value = T, T = f(R, b, F, S);
      for (let P = 0; P !== F; ++P)
        T[P] = t[P];
      N.clippingState = T, this.numIntersection = W ? this.numPlanes : 0, this.numPlanes += Y;
    }
  };
  function C() {
    I.value !== t && (I.value = t, I.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function f(v, b, S, R) {
    const W = v !== null ? v.length : 0;
    let x = null;
    if (W !== 0) {
      if (x = I.value, R !== !0 || x === null) {
        const N = S + W * 4, Y = b.matrixWorldInverse;
        u.getNormalMatrix(Y), (x === null || x.length < N) && (x = new Float32Array(N));
        for (let F = 0, T = S; F !== W; ++F, T += 4)
          l.copy(v[F]).applyMatrix4(Y, u), l.normal.toArray(x, T), x[T + 3] = l.constant;
      }
      I.value = x, I.needsUpdate = !0;
    }
    return e.numPlanes = W, e.numIntersection = 0, x;
  }
}
function N8(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(l, u) {
    return u === Aw ? l.mapping = Om : u === vw && (l.mapping = bv), l;
  }
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping;
      if (u === Aw || u === vw)
        if (e.has(l)) {
          const I = e.get(l).texture;
          return t(I, l.mapping);
        } else {
          const I = l.image;
          if (I && I.height > 0) {
            const C = new LK(I.height);
            return C.fromEquirectangularTexture(r, l), e.set(l, C), l.addEventListener("dispose", i), t(C.texture, l.mapping);
          } else
            return null;
        }
    }
    return l;
  }
  function i(l) {
    const u = l.target;
    u.removeEventListener("dispose", i);
    const I = e.get(u);
    I !== void 0 && (e.delete(u), I.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: o
  };
}
class pv extends $w {
  constructor(e = -1, t = 1, n = 1, i = -1, o = 0.1, l = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = o, this.far = l, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, i, o, l) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let o = n - e, l = n + e, u = i + t, I = i - t;
    if (this.view !== null && this.view.enabled) {
      const C = (this.right - this.left) / this.view.fullWidth / this.zoom, f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += C * this.view.offsetX, l = o + C * this.view.width, u -= f * this.view.offsetY, I = u - f * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, l, u, I, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const eB = 4, r3 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], ab = 20, EM = /* @__PURE__ */ new pv(), a3 = /* @__PURE__ */ new ai();
let TM = null, _M = 0, zM = 0, KM = !1;
const tb = (1 + Math.sqrt(5)) / 2, FG = 1 / tb, o3 = [
  /* @__PURE__ */ new fe(-tb, FG, 0),
  /* @__PURE__ */ new fe(tb, FG, 0),
  /* @__PURE__ */ new fe(-FG, 0, tb),
  /* @__PURE__ */ new fe(FG, 0, tb),
  /* @__PURE__ */ new fe(0, tb, -FG),
  /* @__PURE__ */ new fe(0, tb, FG),
  /* @__PURE__ */ new fe(-1, 1, -1),
  /* @__PURE__ */ new fe(1, 1, -1),
  /* @__PURE__ */ new fe(-1, 1, 1),
  /* @__PURE__ */ new fe(1, 1, 1)
];
class JH {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, i = 100) {
    TM = this._renderer.getRenderTarget(), _M = this._renderer.getActiveCubeFace(), zM = this._renderer.getActiveMipmapLevel(), KM = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, n, i, o), t > 0 && this._blur(o, 0, 0, t), this._applyPMREM(o), this._cleanup(o), o;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = u3(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = l3(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(TM, _M, zM), this._renderer.xr.enabled = KM, e.scissorTest = !1, y1(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Om || e.mapping === bv ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), TM = this._renderer.getRenderTarget(), _M = this._renderer.getActiveCubeFace(), zM = this._renderer.getActiveMipmapLevel(), KM = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: Ks,
      minFilter: Ks,
      generateMipmaps: !1,
      type: Vb,
      format: cg,
      colorSpace: $m,
      depthBuffer: !1
    }, i = s3(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = s3(e, t, n);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = M8(o)), this._blurMaterial = H8(o, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new kl(this._lodPlanes[0], e);
    this._renderer.compile(t, EM);
  }
  _sceneToCubeUV(e, t, n, i) {
    const u = new hl(90, 1, t, n), I = [1, -1, 1, 1, 1, 1], C = [1, 1, 1, -1, -1, -1], f = this._renderer, v = f.autoClear, b = f.toneMapping;
    f.getClearColor(a3), f.toneMapping = cp, f.autoClear = !1;
    const S = new wv({
      name: "PMREM.Background",
      side: td,
      depthWrite: !1,
      depthTest: !1
    }), R = new kl(new Mb(), S);
    let W = !1;
    const x = e.background;
    x ? x.isColor && (S.color.copy(x), e.background = null, W = !0) : (S.color.copy(a3), W = !0);
    for (let N = 0; N < 6; N++) {
      const Y = N % 3;
      Y === 0 ? (u.up.set(0, I[N], 0), u.lookAt(C[N], 0, 0)) : Y === 1 ? (u.up.set(0, 0, I[N]), u.lookAt(0, C[N], 0)) : (u.up.set(0, I[N], 0), u.lookAt(0, 0, C[N]));
      const F = this._cubeSize;
      y1(i, Y * F, N > 2 ? F : 0, F, F), f.setRenderTarget(i), W && f.render(R, u), f.render(e, u);
    }
    R.geometry.dispose(), R.material.dispose(), f.toneMapping = b, f.autoClear = v, e.background = x;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, i = e.mapping === Om || e.mapping === bv;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = u3()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = l3());
    const o = i ? this._cubemapMaterial : this._equirectMaterial, l = new kl(this._lodPlanes[0], o), u = o.uniforms;
    u.envMap.value = e;
    const I = this._cubeSize;
    y1(t, 0, 0, 3 * I, 2 * I), n.setRenderTarget(t), n.render(l, EM);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const l = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), u = o3[(i - o - 1) % o3.length];
      this._blur(e, o - 1, o, l, u);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, i, o) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      l,
      t,
      n,
      i,
      "latitudinal",
      o
    ), this._halfBlur(
      l,
      e,
      n,
      n,
      i,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, t, n, i, o, l, u) {
    const I = this._renderer, C = this._blurMaterial;
    l !== "latitudinal" && l !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const f = 3, v = new kl(this._lodPlanes[i], C), b = C.uniforms, S = this._sizeLods[n] - 1, R = isFinite(o) ? Math.PI / (2 * S) : 2 * Math.PI / (2 * ab - 1), W = o / R, x = isFinite(o) ? 1 + Math.floor(f * W) : ab;
    x > ab && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${ab}`);
    const N = [];
    let Y = 0;
    for (let L = 0; L < ab; ++L) {
      const j = L / W, J = Math.exp(-j * j / 2);
      N.push(J), L === 0 ? Y += J : L < x && (Y += 2 * J);
    }
    for (let L = 0; L < N.length; L++)
      N[L] = N[L] / Y;
    b.envMap.value = e.texture, b.samples.value = x, b.weights.value = N, b.latitudinal.value = l === "latitudinal", u && (b.poleAxis.value = u);
    const { _lodMax: F } = this;
    b.dTheta.value = R, b.mipInt.value = F - n;
    const T = this._sizeLods[i], P = 3 * T * (i > F - eB ? i - F + eB : 0), D = 4 * (this._cubeSize - T);
    y1(t, P, D, 3 * T, 2 * T), I.setRenderTarget(t), I.render(v, EM);
  }
}
function M8(r) {
  const e = [], t = [], n = [];
  let i = r;
  const o = r - eB + 1 + r3.length;
  for (let l = 0; l < o; l++) {
    const u = Math.pow(2, i);
    t.push(u);
    let I = 1 / u;
    l > r - eB ? I = r3[l - r + eB - 1] : l === 0 && (I = 0), n.push(I);
    const C = 1 / (u - 2), f = -C, v = 1 + C, b = [f, f, v, f, v, v, f, f, v, v, f, v], S = 6, R = 6, W = 3, x = 2, N = 1, Y = new Float32Array(W * R * S), F = new Float32Array(x * R * S), T = new Float32Array(N * R * S);
    for (let D = 0; D < S; D++) {
      const L = D % 3 * 2 / 3 - 1, j = D > 2 ? 0 : -1, J = [
        L,
        j,
        0,
        L + 2 / 3,
        j,
        0,
        L + 2 / 3,
        j + 1,
        0,
        L,
        j,
        0,
        L + 2 / 3,
        j + 1,
        0,
        L,
        j + 1,
        0
      ];
      Y.set(J, W * R * D), F.set(b, x * R * D);
      const O = [D, D, D, D, D, D];
      T.set(O, N * R * D);
    }
    const P = new Br();
    P.setAttribute("position", new ja(Y, W)), P.setAttribute("uv", new ja(F, x)), P.setAttribute("faceIndex", new ja(T, N)), e.push(P), i > eB && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function s3(r, e, t) {
  const n = new QC(r, e, t);
  return n.texture.mapping = xB, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function y1(r, e, t, n, i) {
  r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
}
function H8(r, e, t) {
  const n = new Float32Array(ab), i = new fe(0, 1, 0);
  return new rf({
    name: "SphericalGaussianBlur",
    defines: {
      n: ab,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: IY(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Dm,
    depthTest: !1,
    depthWrite: !1
  });
}
function l3() {
  return new rf({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: IY(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Dm,
    depthTest: !1,
    depthWrite: !1
  });
}
function u3() {
  return new rf({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: IY(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Dm,
    depthTest: !1,
    depthWrite: !1
  });
}
function IY() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function X8(r) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(u) {
    if (u && u.isTexture) {
      const I = u.mapping, C = I === Aw || I === vw, f = I === Om || I === bv;
      if (C || f) {
        let v = e.get(u);
        const b = v !== void 0 ? v.texture.pmremVersion : 0;
        if (u.isRenderTargetTexture && u.pmremVersion !== b)
          return t === null && (t = new JH(r)), v = C ? t.fromEquirectangular(u, v) : t.fromCubemap(u, v), v.texture.pmremVersion = u.pmremVersion, e.set(u, v), v.texture;
        if (v !== void 0)
          return v.texture;
        {
          const S = u.image;
          return C && S && S.height > 0 || f && S && i(S) ? (t === null && (t = new JH(r)), v = C ? t.fromEquirectangular(u) : t.fromCubemap(u), v.texture.pmremVersion = u.pmremVersion, e.set(u, v), u.addEventListener("dispose", o), v.texture) : null;
        }
      }
    }
    return u;
  }
  function i(u) {
    let I = 0;
    const C = 6;
    for (let f = 0; f < C; f++)
      u[f] !== void 0 && I++;
    return I === C;
  }
  function o(u) {
    const I = u.target;
    I.removeEventListener("dispose", o);
    const C = e.get(I);
    C !== void 0 && (e.delete(I), C.dispose());
  }
  function l() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: l
  };
}
function Y8(r) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = r.getExtension(n);
    }
    return e[n] = i, i;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function() {
      t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const i = t(n);
      return i === null && oB("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function F8(r, e, t, n) {
  const i = {}, o = /* @__PURE__ */ new WeakMap();
  function l(v) {
    const b = v.target;
    b.index !== null && e.remove(b.index);
    for (const R in b.attributes)
      e.remove(b.attributes[R]);
    for (const R in b.morphAttributes) {
      const W = b.morphAttributes[R];
      for (let x = 0, N = W.length; x < N; x++)
        e.remove(W[x]);
    }
    b.removeEventListener("dispose", l), delete i[b.id];
    const S = o.get(b);
    S && (e.remove(S), o.delete(b)), n.releaseStatesOfGeometry(b), b.isInstancedBufferGeometry === !0 && delete b._maxInstanceCount, t.memory.geometries--;
  }
  function u(v, b) {
    return i[b.id] === !0 || (b.addEventListener("dispose", l), i[b.id] = !0, t.memory.geometries++), b;
  }
  function I(v) {
    const b = v.attributes;
    for (const R in b)
      e.update(b[R], r.ARRAY_BUFFER);
    const S = v.morphAttributes;
    for (const R in S) {
      const W = S[R];
      for (let x = 0, N = W.length; x < N; x++)
        e.update(W[x], r.ARRAY_BUFFER);
    }
  }
  function C(v) {
    const b = [], S = v.index, R = v.attributes.position;
    let W = 0;
    if (S !== null) {
      const Y = S.array;
      W = S.version;
      for (let F = 0, T = Y.length; F < T; F += 3) {
        const P = Y[F + 0], D = Y[F + 1], L = Y[F + 2];
        b.push(P, D, D, L, L, P);
      }
    } else if (R !== void 0) {
      const Y = R.array;
      W = R.version;
      for (let F = 0, T = Y.length / 3 - 1; F < T; F += 3) {
        const P = F + 0, D = F + 1, L = F + 2;
        b.push(P, D, D, L, L, P);
      }
    } else
      return;
    const x = new (XK(b) ? dY : gY)(b, 1);
    x.version = W;
    const N = o.get(v);
    N && e.remove(N), o.set(v, x);
  }
  function f(v) {
    const b = o.get(v);
    if (b) {
      const S = v.index;
      S !== null && b.version < S.version && C(v);
    } else
      C(v);
    return o.get(v);
  }
  return {
    get: u,
    update: I,
    getWireframeAttribute: f
  };
}
function E8(r, e, t) {
  let n;
  function i(b) {
    n = b;
  }
  let o, l;
  function u(b) {
    o = b.type, l = b.bytesPerElement;
  }
  function I(b, S) {
    r.drawElements(n, S, o, b * l), t.update(S, n, 1);
  }
  function C(b, S, R) {
    R !== 0 && (r.drawElementsInstanced(n, S, o, b * l, R), t.update(S, n, R));
  }
  function f(b, S, R) {
    if (R === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, S, 0, o, b, 0, R);
    let x = 0;
    for (let N = 0; N < R; N++)
      x += S[N];
    t.update(x, n, 1);
  }
  function v(b, S, R, W) {
    if (R === 0) return;
    const x = e.get("WEBGL_multi_draw");
    if (x === null)
      for (let N = 0; N < b.length; N++)
        C(b[N] / l, S[N], W[N]);
    else {
      x.multiDrawElementsInstancedWEBGL(n, S, 0, o, b, 0, W, 0, R);
      let N = 0;
      for (let Y = 0; Y < R; Y++)
        N += S[Y];
      for (let Y = 0; Y < W.length; Y++)
        t.update(N, n, W[Y]);
    }
  }
  this.setMode = i, this.setIndex = u, this.render = I, this.renderInstances = C, this.renderMultiDraw = f, this.renderMultiDrawInstances = v;
}
function T8(r) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(o, l, u) {
    switch (t.calls++, l) {
      case r.TRIANGLES:
        t.triangles += u * (o / 3);
        break;
      case r.LINES:
        t.lines += u * (o / 2);
        break;
      case r.LINE_STRIP:
        t.lines += u * (o - 1);
        break;
      case r.LINE_LOOP:
        t.lines += u * o;
        break;
      case r.POINTS:
        t.points += u * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", l);
        break;
    }
  }
  function i() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function _8(r, e, t) {
  const n = /* @__PURE__ */ new WeakMap(), i = new Ha();
  function o(l, u, I) {
    const C = l.morphTargetInfluences, f = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color, v = f !== void 0 ? f.length : 0;
    let b = n.get(u);
    if (b === void 0 || b.count !== v) {
      let J = function() {
        L.dispose(), n.delete(u), u.removeEventListener("dispose", J);
      };
      b !== void 0 && b.texture.dispose();
      const S = u.morphAttributes.position !== void 0, R = u.morphAttributes.normal !== void 0, W = u.morphAttributes.color !== void 0, x = u.morphAttributes.position || [], N = u.morphAttributes.normal || [], Y = u.morphAttributes.color || [];
      let F = 0;
      S === !0 && (F = 1), R === !0 && (F = 2), W === !0 && (F = 3);
      let T = u.attributes.position.count * F, P = 1;
      T > e.maxTextureSize && (P = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
      const D = new Float32Array(T * P * 4 * v), L = new zW(D, T, P, v);
      L.type = ed, L.needsUpdate = !0;
      const j = F * 4;
      for (let O = 0; O < v; O++) {
        const ne = x[O], he = N[O], pe = Y[O], Ae = T * P * 4 * O;
        for (let ke = 0; ke < ne.count; ke++) {
          const Re = ke * j;
          S === !0 && (i.fromBufferAttribute(ne, ke), D[Ae + Re + 0] = i.x, D[Ae + Re + 1] = i.y, D[Ae + Re + 2] = i.z, D[Ae + Re + 3] = 0), R === !0 && (i.fromBufferAttribute(he, ke), D[Ae + Re + 4] = i.x, D[Ae + Re + 5] = i.y, D[Ae + Re + 6] = i.z, D[Ae + Re + 7] = 0), W === !0 && (i.fromBufferAttribute(pe, ke), D[Ae + Re + 8] = i.x, D[Ae + Re + 9] = i.y, D[Ae + Re + 10] = i.z, D[Ae + Re + 11] = pe.itemSize === 4 ? i.w : 1);
        }
      }
      b = {
        count: v,
        texture: L,
        size: new Lt(T, P)
      }, n.set(u, b), u.addEventListener("dispose", J);
    }
    if (l.isInstancedMesh === !0 && l.morphTexture !== null)
      I.getUniforms().setValue(r, "morphTexture", l.morphTexture, t);
    else {
      let S = 0;
      for (let W = 0; W < C.length; W++)
        S += C[W];
      const R = u.morphTargetsRelative ? 1 : 1 - S;
      I.getUniforms().setValue(r, "morphTargetBaseInfluence", R), I.getUniforms().setValue(r, "morphTargetInfluences", C);
    }
    I.getUniforms().setValue(r, "morphTargetsTexture", b.texture, t), I.getUniforms().setValue(r, "morphTargetsTextureSize", b.size);
  }
  return {
    update: o
  };
}
function z8(r, e, t, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function o(I) {
    const C = n.render.frame, f = I.geometry, v = e.get(I, f);
    if (i.get(v) !== C && (e.update(v), i.set(v, C)), I.isInstancedMesh && (I.hasEventListener("dispose", u) === !1 && I.addEventListener("dispose", u), i.get(I) !== C && (t.update(I.instanceMatrix, r.ARRAY_BUFFER), I.instanceColor !== null && t.update(I.instanceColor, r.ARRAY_BUFFER), i.set(I, C))), I.isSkinnedMesh) {
      const b = I.skeleton;
      i.get(b) !== C && (b.update(), i.set(b, C));
    }
    return v;
  }
  function l() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function u(I) {
    const C = I.target;
    C.removeEventListener("dispose", u), t.remove(C.instanceMatrix), C.instanceColor !== null && t.remove(C.instanceColor);
  }
  return {
    update: o,
    dispose: l
  };
}
class KW extends ks {
  constructor(e, t, n, i, o, l, u, I, C, f = hb) {
    if (f !== hb && f !== Sb)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && f === hb && (n = Pm), n === void 0 && f === Sb && (n = Bb), super(null, i, o, l, u, I, f, n, C), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = u !== void 0 ? u : Lu, this.minFilter = I !== void 0 ? I : Lu, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const DK = /* @__PURE__ */ new ks(), c3 = /* @__PURE__ */ new KW(1, 1), UK = /* @__PURE__ */ new zW(), OK = /* @__PURE__ */ new cY(), PK = /* @__PURE__ */ new eR(), g3 = [], d3 = [], I3 = new Float32Array(16), C3 = new Float32Array(9), h3 = new Float32Array(4);
function VB(r, e, t) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const i = e * t;
  let o = g3[i];
  if (o === void 0 && (o = new Float32Array(i), g3[i] = o), e !== 0) {
    n.toArray(o, 0);
    for (let l = 1, u = 0; l !== e; ++l)
      u += t, r[l].toArray(o, u);
  }
  return o;
}
function du(r, e) {
  if (r.length !== e.length) return !1;
  for (let t = 0, n = r.length; t < n; t++)
    if (r[t] !== e[t]) return !1;
  return !0;
}
function Iu(r, e) {
  for (let t = 0, n = e.length; t < n; t++)
    r[t] = e[t];
}
function LW(r, e) {
  let t = d3[e];
  t === void 0 && (t = new Int32Array(e), d3[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = r.allocateTextureUnit();
  return t;
}
function K8(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e);
}
function L8(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (du(t, e)) return;
    r.uniform2fv(this.addr, e), Iu(t, e);
  }
}
function k8(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (du(t, e)) return;
    r.uniform3fv(this.addr, e), Iu(t, e);
  }
}
function D8(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (du(t, e)) return;
    r.uniform4fv(this.addr, e), Iu(t, e);
  }
}
function U8(r, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (du(t, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Iu(t, e);
  } else {
    if (du(t, n)) return;
    h3.set(n), r.uniformMatrix2fv(this.addr, !1, h3), Iu(t, n);
  }
}
function O8(r, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (du(t, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Iu(t, e);
  } else {
    if (du(t, n)) return;
    C3.set(n), r.uniformMatrix3fv(this.addr, !1, C3), Iu(t, n);
  }
}
function P8(r, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (du(t, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Iu(t, e);
  } else {
    if (du(t, n)) return;
    I3.set(n), r.uniformMatrix4fv(this.addr, !1, I3), Iu(t, n);
  }
}
function J8(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e);
}
function Q8(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (du(t, e)) return;
    r.uniform2iv(this.addr, e), Iu(t, e);
  }
}
function j8(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (du(t, e)) return;
    r.uniform3iv(this.addr, e), Iu(t, e);
  }
}
function q8(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (du(t, e)) return;
    r.uniform4iv(this.addr, e), Iu(t, e);
  }
}
function $8(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e);
}
function eq(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (du(t, e)) return;
    r.uniform2uiv(this.addr, e), Iu(t, e);
  }
}
function tq(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (du(t, e)) return;
    r.uniform3uiv(this.addr, e), Iu(t, e);
  }
}
function nq(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (du(t, e)) return;
    r.uniform4uiv(this.addr, e), Iu(t, e);
  }
}
function iq(r, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
  let o;
  this.type === r.SAMPLER_2D_SHADOW ? (c3.compareFunction = lY, o = c3) : o = DK, t.setTexture2D(e || o, i);
}
function rq(r, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || OK, i);
}
function aq(r, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || PK, i);
}
function oq(r, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || UK, i);
}
function sq(r) {
  switch (r) {
    case 5126:
      return K8;
    // FLOAT
    case 35664:
      return L8;
    // _VEC2
    case 35665:
      return k8;
    // _VEC3
    case 35666:
      return D8;
    // _VEC4
    case 35674:
      return U8;
    // _MAT2
    case 35675:
      return O8;
    // _MAT3
    case 35676:
      return P8;
    // _MAT4
    case 5124:
    case 35670:
      return J8;
    // INT, BOOL
    case 35667:
    case 35671:
      return Q8;
    // _VEC2
    case 35668:
    case 35672:
      return j8;
    // _VEC3
    case 35669:
    case 35673:
      return q8;
    // _VEC4
    case 5125:
      return $8;
    // UINT
    case 36294:
      return eq;
    // _VEC2
    case 36295:
      return tq;
    // _VEC3
    case 36296:
      return nq;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return iq;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return rq;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return aq;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return oq;
  }
}
function lq(r, e) {
  r.uniform1fv(this.addr, e);
}
function uq(r, e) {
  const t = VB(e, this.size, 2);
  r.uniform2fv(this.addr, t);
}
function cq(r, e) {
  const t = VB(e, this.size, 3);
  r.uniform3fv(this.addr, t);
}
function gq(r, e) {
  const t = VB(e, this.size, 4);
  r.uniform4fv(this.addr, t);
}
function dq(r, e) {
  const t = VB(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, t);
}
function Iq(r, e) {
  const t = VB(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, t);
}
function Cq(r, e) {
  const t = VB(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, t);
}
function hq(r, e) {
  r.uniform1iv(this.addr, e);
}
function fq(r, e) {
  r.uniform2iv(this.addr, e);
}
function pq(r, e) {
  r.uniform3iv(this.addr, e);
}
function mq(r, e) {
  r.uniform4iv(this.addr, e);
}
function Aq(r, e) {
  r.uniform1uiv(this.addr, e);
}
function vq(r, e) {
  r.uniform2uiv(this.addr, e);
}
function yq(r, e) {
  r.uniform3uiv(this.addr, e);
}
function bq(r, e) {
  r.uniform4uiv(this.addr, e);
}
function Gq(r, e, t) {
  const n = this.cache, i = e.length, o = LW(t, i);
  du(n, o) || (r.uniform1iv(this.addr, o), Iu(n, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture2D(e[l] || DK, o[l]);
}
function Bq(r, e, t) {
  const n = this.cache, i = e.length, o = LW(t, i);
  du(n, o) || (r.uniform1iv(this.addr, o), Iu(n, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture3D(e[l] || OK, o[l]);
}
function Sq(r, e, t) {
  const n = this.cache, i = e.length, o = LW(t, i);
  du(n, o) || (r.uniform1iv(this.addr, o), Iu(n, o));
  for (let l = 0; l !== i; ++l)
    t.setTextureCube(e[l] || PK, o[l]);
}
function Zq(r, e, t) {
  const n = this.cache, i = e.length, o = LW(t, i);
  du(n, o) || (r.uniform1iv(this.addr, o), Iu(n, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture2DArray(e[l] || UK, o[l]);
}
function wq(r) {
  switch (r) {
    case 5126:
      return lq;
    // FLOAT
    case 35664:
      return uq;
    // _VEC2
    case 35665:
      return cq;
    // _VEC3
    case 35666:
      return gq;
    // _VEC4
    case 35674:
      return dq;
    // _MAT2
    case 35675:
      return Iq;
    // _MAT3
    case 35676:
      return Cq;
    // _MAT4
    case 5124:
    case 35670:
      return hq;
    // INT, BOOL
    case 35667:
    case 35671:
      return fq;
    // _VEC2
    case 35668:
    case 35672:
      return pq;
    // _VEC3
    case 35669:
    case 35673:
      return mq;
    // _VEC4
    case 5125:
      return Aq;
    // UINT
    case 36294:
      return vq;
    // _VEC2
    case 36295:
      return yq;
    // _VEC3
    case 36296:
      return bq;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return Gq;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return Bq;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return Sq;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return Zq;
  }
}
class Rq {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = sq(t.type);
  }
}
class xq {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = wq(t.type);
  }
}
class Wq {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let o = 0, l = i.length; o !== l; ++o) {
      const u = i[o];
      u.setValue(e, t[u.id], n);
    }
  }
}
const LM = /(\w+)(\])?(\[|\.)?/g;
function f3(r, e) {
  r.seq.push(e), r.map[e.id] = e;
}
function Vq(r, e, t) {
  const n = r.name, i = n.length;
  for (LM.lastIndex = 0; ; ) {
    const o = LM.exec(n), l = LM.lastIndex;
    let u = o[1];
    const I = o[2] === "]", C = o[3];
    if (I && (u = u | 0), C === void 0 || C === "[" && l + 2 === i) {
      f3(t, C === void 0 ? new Rq(u, r, e) : new xq(u, r, e));
      break;
    } else {
      let v = t.map[u];
      v === void 0 && (v = new Wq(u), f3(t, v)), t = v;
    }
  }
}
class d2 {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const o = e.getActiveUniform(t, i), l = e.getUniformLocation(t, o.name);
      Vq(o, l, this);
    }
  }
  setValue(e, t, n, i) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let o = 0, l = t.length; o !== l; ++o) {
      const u = t[o], I = n[u.id];
      I.needsUpdate !== !1 && u.setValue(e, I.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const l = e[i];
      l.id in t && n.push(l);
    }
    return n;
  }
}
function p3(r, e, t) {
  const n = r.createShader(e);
  return r.shaderSource(n, t), r.compileShader(n), n;
}
const Nq = 37297;
let Mq = 0;
function Hq(r, e) {
  const t = r.split(`
`), n = [], i = Math.max(e - 6, 0), o = Math.min(e + 6, t.length);
  for (let l = i; l < o; l++) {
    const u = l + 1;
    n.push(`${u === e ? ">" : " "} ${u}: ${t[l]}`);
  }
  return n.join(`
`);
}
function Xq(r) {
  const e = ya.getPrimaries(ya.workingColorSpace), t = ya.getPrimaries(r);
  let n;
  switch (e === t ? n = "" : e === ww && t === Zw ? n = "LinearDisplayP3ToLinearSRGB" : e === Zw && t === ww && (n = "LinearSRGBToLinearDisplayP3"), r) {
    case $m:
    case qw:
      return [n, "LinearTransferOETF"];
    case OC:
    case _W:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", r), [n, "LinearTransferOETF"];
  }
}
function m3(r, e, t) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS), i = r.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const l = parseInt(o[1]);
    return t.toUpperCase() + `

` + i + `

` + Hq(r.getShaderSource(e), l);
  } else
    return i;
}
function Yq(r, e) {
  const t = Xq(e);
  return `vec4 ${r}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function Fq(r, e) {
  let t;
  switch (e) {
    case CK:
      t = "Linear";
      break;
    case hK:
      t = "Reinhard";
      break;
    case fK:
      t = "OptimizedCineon";
      break;
    case QX:
      t = "ACESFilmic";
      break;
    case mK:
      t = "AgX";
      break;
    case AK:
      t = "Neutral";
      break;
    case pK:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
const b1 = /* @__PURE__ */ new fe();
function Eq() {
  ya.getLuminanceCoefficients(b1);
  const r = b1.x.toFixed(4), e = b1.y.toFixed(4), t = b1.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function Tq(r) {
  return [
    r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(OZ).join(`
`);
}
function _q(r) {
  const e = [];
  for (const t in r) {
    const n = r[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function zq(r, e) {
  const t = {}, n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const o = r.getActiveAttrib(e, i), l = o.name;
    let u = 1;
    o.type === r.FLOAT_MAT2 && (u = 2), o.type === r.FLOAT_MAT3 && (u = 3), o.type === r.FLOAT_MAT4 && (u = 4), t[l] = {
      type: o.type,
      location: r.getAttribLocation(e, l),
      locationSize: u
    };
  }
  return t;
}
function OZ(r) {
  return r !== "";
}
function A3(r, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function v3(r, e) {
  return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const Kq = /^[ \t]*#include +<([\w\d./]+)>/gm;
function QH(r) {
  return r.replace(Kq, kq);
}
const Lq = /* @__PURE__ */ new Map();
function kq(r, e) {
  let t = Ar[e];
  if (t === void 0) {
    const n = Lq.get(e);
    if (n !== void 0)
      t = Ar[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return QH(t);
}
const Dq = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function y3(r) {
  return r.replace(Dq, Uq);
}
function Uq(r, e, t, n) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function b3(r) {
  let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function Oq(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return r.shadowMapType === VW ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === QZ ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === qh && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Pq(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case Om:
      case bv:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case xB:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function Jq(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case bv:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Qq(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case Qw:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case dK:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case IK:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function jq(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function qq(r, e, t, n) {
  const i = r.getContext(), o = t.defines;
  let l = t.vertexShader, u = t.fragmentShader;
  const I = Oq(t), C = Pq(t), f = Jq(t), v = Qq(t), b = jq(t), S = Tq(t), R = _q(o), W = i.createProgram();
  let x, N, Y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (x = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R
  ].filter(OZ).join(`
`), x.length > 0 && (x += `
`), N = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R
  ].filter(OZ).join(`
`), N.length > 0 && (N += `
`)) : (x = [
    b3(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + f : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + I : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(OZ).join(`
`), N = [
    b3(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + C : "",
    t.envMap ? "#define " + f : "",
    t.envMap ? "#define " + v : "",
    b ? "#define CUBEUV_TEXEL_WIDTH " + b.texelWidth : "",
    b ? "#define CUBEUV_TEXEL_HEIGHT " + b.texelHeight : "",
    b ? "#define CUBEUV_MAX_MIP " + b.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.dispersion ? "#define USE_DISPERSION" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + I : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== cp ? "#define TONE_MAPPING" : "",
    t.toneMapping !== cp ? Ar.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== cp ? Fq("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Ar.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    Yq("linearToOutputTexel", t.outputColorSpace),
    Eq(),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(OZ).join(`
`)), l = QH(l), l = A3(l, t), l = v3(l, t), u = QH(u), u = A3(u, t), u = v3(u, t), l = y3(l), u = y3(u), t.isRawShaderMaterial !== !0 && (Y = `#version 300 es
`, x = [
    S,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + x, N = [
    "#define varying in",
    t.glslVersion === PH ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === PH ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + N);
  const F = Y + x + l, T = Y + N + u, P = p3(i, i.VERTEX_SHADER, F), D = p3(i, i.FRAGMENT_SHADER, T);
  i.attachShader(W, P), i.attachShader(W, D), t.index0AttributeName !== void 0 ? i.bindAttribLocation(W, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(W, 0, "position"), i.linkProgram(W);
  function L(ne) {
    if (r.debug.checkShaderErrors) {
      const he = i.getProgramInfoLog(W).trim(), pe = i.getShaderInfoLog(P).trim(), Ae = i.getShaderInfoLog(D).trim();
      let ke = !0, Re = !0;
      if (i.getProgramParameter(W, i.LINK_STATUS) === !1)
        if (ke = !1, typeof r.debug.onShaderError == "function")
          r.debug.onShaderError(i, W, P, D);
        else {
          const Xe = m3(i, P, "vertex"), re = m3(i, D, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(W, i.VALIDATE_STATUS) + `

Material Name: ` + ne.name + `
Material Type: ` + ne.type + `

Program Info Log: ` + he + `
` + Xe + `
` + re
          );
        }
      else he !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", he) : (pe === "" || Ae === "") && (Re = !1);
      Re && (ne.diagnostics = {
        runnable: ke,
        programLog: he,
        vertexShader: {
          log: pe,
          prefix: x
        },
        fragmentShader: {
          log: Ae,
          prefix: N
        }
      });
    }
    i.deleteShader(P), i.deleteShader(D), j = new d2(i, W), J = zq(i, W);
  }
  let j;
  this.getUniforms = function() {
    return j === void 0 && L(this), j;
  };
  let J;
  this.getAttributes = function() {
    return J === void 0 && L(this), J;
  };
  let O = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return O === !1 && (O = i.getProgramParameter(W, Nq)), O;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(W), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = Mq++, this.cacheKey = e, this.usedTimes = 1, this.program = W, this.vertexShader = P, this.fragmentShader = D, this;
}
let $q = 0;
class e6 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), o = this._getShaderStage(n), l = this._getShaderCacheForMaterial(e);
    return l.has(i) === !1 && (l.add(i), i.usedTimes++), l.has(o) === !1 && (l.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new t6(e), t.set(e, n)), n;
  }
}
class t6 {
  constructor(e) {
    this.id = $q++, this.code = e, this.usedTimes = 0;
  }
}
function n6(r, e, t, n, i, o, l) {
  const u = new pb(), I = new e6(), C = /* @__PURE__ */ new Set(), f = [], v = i.logarithmicDepthBuffer, b = i.vertexTextures;
  let S = i.precision;
  const R = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function W(J) {
    return C.add(J), J === 0 ? "uv" : `uv${J}`;
  }
  function x(J, O, ne, he, pe) {
    const Ae = he.fog, ke = pe.geometry, Re = J.isMeshStandardMaterial ? he.environment : null, Xe = (J.isMeshStandardMaterial ? t : e).get(J.envMap || Re), re = Xe && Xe.mapping === xB ? Xe.image.height : null, Se = R[J.type];
    J.precision !== null && (S = i.getMaxPrecision(J.precision), S !== J.precision && console.warn("THREE.WebGLProgram.getParameters:", J.precision, "not supported, using", S, "instead."));
    const Be = ke.morphAttributes.position || ke.morphAttributes.normal || ke.morphAttributes.color, le = Be !== void 0 ? Be.length : 0;
    let Ye = 0;
    ke.morphAttributes.position !== void 0 && (Ye = 1), ke.morphAttributes.normal !== void 0 && (Ye = 2), ke.morphAttributes.color !== void 0 && (Ye = 3);
    let nt, ze, Je, wt;
    if (Se) {
      const Ii = ef[Se];
      nt = Ii.vertexShader, ze = Ii.fragmentShader;
    } else
      nt = J.vertexShader, ze = J.fragmentShader, I.update(J), Je = I.getVertexShaderID(J), wt = I.getFragmentShaderID(J);
    const mt = r.getRenderTarget(), Dt = pe.isInstancedMesh === !0, mn = pe.isBatchedMesh === !0, An = !!J.map, Hn = !!J.matcap, ge = !!Xe, Wt = !!J.aoMap, Nt = !!J.lightMap, $t = !!J.bumpMap, ft = !!J.normalMap, bn = !!J.displacementMap, en = !!J.emissiveMap, hn = !!J.metalnessMap, me = !!J.roughnessMap, se = J.anisotropy > 0, $e = J.clearcoat > 0, Vt = J.dispersion > 0, Bt = J.iridescence > 0, Mt = J.sheen > 0, Gn = J.transmission > 0, jt = se && !!J.anisotropyMap, an = $e && !!J.clearcoatMap, jn = $e && !!J.clearcoatNormalMap, Ot = $e && !!J.clearcoatRoughnessMap, He = Bt && !!J.iridescenceMap, vt = Bt && !!J.iridescenceThicknessMap, xt = Mt && !!J.sheenColorMap, ht = Mt && !!J.sheenRoughnessMap, on = !!J.specularMap, we = !!J.specularColorMap, qe = !!J.specularIntensityMap, de = Gn && !!J.transmissionMap, it = Gn && !!J.thicknessMap, je = !!J.gradientMap, et = !!J.alphaMap, Jt = J.alphaTest > 0, Kn = !!J.alphaHash, di = !!J.extensions;
    let Di = cp;
    J.toneMapped && (mt === null || mt.isXRRenderTarget === !0) && (Di = r.toneMapping);
    const Jn = {
      shaderID: Se,
      shaderType: J.type,
      shaderName: J.name,
      vertexShader: nt,
      fragmentShader: ze,
      defines: J.defines,
      customVertexShaderID: Je,
      customFragmentShaderID: wt,
      isRawShaderMaterial: J.isRawShaderMaterial === !0,
      glslVersion: J.glslVersion,
      precision: S,
      batching: mn,
      batchingColor: mn && pe._colorsTexture !== null,
      instancing: Dt,
      instancingColor: Dt && pe.instanceColor !== null,
      instancingMorph: Dt && pe.morphTexture !== null,
      supportsVertexTextures: b,
      outputColorSpace: mt === null ? r.outputColorSpace : mt.isXRRenderTarget === !0 ? mt.texture.colorSpace : $m,
      alphaToCoverage: !!J.alphaToCoverage,
      map: An,
      matcap: Hn,
      envMap: ge,
      envMapMode: ge && Xe.mapping,
      envMapCubeUVHeight: re,
      aoMap: Wt,
      lightMap: Nt,
      bumpMap: $t,
      normalMap: ft,
      displacementMap: b && bn,
      emissiveMap: en,
      normalMapObjectSpace: ft && J.normalMapType === ZK,
      normalMapTangentSpace: ft && J.normalMapType === Zv,
      metalnessMap: hn,
      roughnessMap: me,
      anisotropy: se,
      anisotropyMap: jt,
      clearcoat: $e,
      clearcoatMap: an,
      clearcoatNormalMap: jn,
      clearcoatRoughnessMap: Ot,
      dispersion: Vt,
      iridescence: Bt,
      iridescenceMap: He,
      iridescenceThicknessMap: vt,
      sheen: Mt,
      sheenColorMap: xt,
      sheenRoughnessMap: ht,
      specularMap: on,
      specularColorMap: we,
      specularIntensityMap: qe,
      transmission: Gn,
      transmissionMap: de,
      thicknessMap: it,
      gradientMap: je,
      opaque: J.transparent === !1 && J.blending === Cb && J.alphaToCoverage === !1,
      alphaMap: et,
      alphaTest: Jt,
      alphaHash: Kn,
      combine: J.combine,
      //
      mapUv: An && W(J.map.channel),
      aoMapUv: Wt && W(J.aoMap.channel),
      lightMapUv: Nt && W(J.lightMap.channel),
      bumpMapUv: $t && W(J.bumpMap.channel),
      normalMapUv: ft && W(J.normalMap.channel),
      displacementMapUv: bn && W(J.displacementMap.channel),
      emissiveMapUv: en && W(J.emissiveMap.channel),
      metalnessMapUv: hn && W(J.metalnessMap.channel),
      roughnessMapUv: me && W(J.roughnessMap.channel),
      anisotropyMapUv: jt && W(J.anisotropyMap.channel),
      clearcoatMapUv: an && W(J.clearcoatMap.channel),
      clearcoatNormalMapUv: jn && W(J.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ot && W(J.clearcoatRoughnessMap.channel),
      iridescenceMapUv: He && W(J.iridescenceMap.channel),
      iridescenceThicknessMapUv: vt && W(J.iridescenceThicknessMap.channel),
      sheenColorMapUv: xt && W(J.sheenColorMap.channel),
      sheenRoughnessMapUv: ht && W(J.sheenRoughnessMap.channel),
      specularMapUv: on && W(J.specularMap.channel),
      specularColorMapUv: we && W(J.specularColorMap.channel),
      specularIntensityMapUv: qe && W(J.specularIntensityMap.channel),
      transmissionMapUv: de && W(J.transmissionMap.channel),
      thicknessMapUv: it && W(J.thicknessMap.channel),
      alphaMapUv: et && W(J.alphaMap.channel),
      //
      vertexTangents: !!ke.attributes.tangent && (ft || se),
      vertexColors: J.vertexColors,
      vertexAlphas: J.vertexColors === !0 && !!ke.attributes.color && ke.attributes.color.itemSize === 4,
      pointsUvs: pe.isPoints === !0 && !!ke.attributes.uv && (An || et),
      fog: !!Ae,
      useFog: J.fog === !0,
      fogExp2: !!Ae && Ae.isFogExp2,
      flatShading: J.flatShading === !0,
      sizeAttenuation: J.sizeAttenuation === !0,
      logarithmicDepthBuffer: v,
      skinning: pe.isSkinnedMesh === !0,
      morphTargets: ke.morphAttributes.position !== void 0,
      morphNormals: ke.morphAttributes.normal !== void 0,
      morphColors: ke.morphAttributes.color !== void 0,
      morphTargetsCount: le,
      morphTextureStride: Ye,
      numDirLights: O.directional.length,
      numPointLights: O.point.length,
      numSpotLights: O.spot.length,
      numSpotLightMaps: O.spotLightMap.length,
      numRectAreaLights: O.rectArea.length,
      numHemiLights: O.hemi.length,
      numDirLightShadows: O.directionalShadowMap.length,
      numPointLightShadows: O.pointShadowMap.length,
      numSpotLightShadows: O.spotShadowMap.length,
      numSpotLightShadowsWithMaps: O.numSpotLightShadowsWithMaps,
      numLightProbes: O.numLightProbes,
      numClippingPlanes: l.numPlanes,
      numClipIntersection: l.numIntersection,
      dithering: J.dithering,
      shadowMapEnabled: r.shadowMap.enabled && ne.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: Di,
      decodeVideoTexture: An && J.map.isVideoTexture === !0 && ya.getTransfer(J.map.colorSpace) === Ho,
      premultipliedAlpha: J.premultipliedAlpha,
      doubleSided: J.side === ip,
      flipSided: J.side === td,
      useDepthPacking: J.depthPacking >= 0,
      depthPacking: J.depthPacking || 0,
      index0AttributeName: J.index0AttributeName,
      extensionClipCullDistance: di && J.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (di && J.extensions.multiDraw === !0 || mn) && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: J.customProgramCacheKey()
    };
    return Jn.vertexUv1s = C.has(1), Jn.vertexUv2s = C.has(2), Jn.vertexUv3s = C.has(3), C.clear(), Jn;
  }
  function N(J) {
    const O = [];
    if (J.shaderID ? O.push(J.shaderID) : (O.push(J.customVertexShaderID), O.push(J.customFragmentShaderID)), J.defines !== void 0)
      for (const ne in J.defines)
        O.push(ne), O.push(J.defines[ne]);
    return J.isRawShaderMaterial === !1 && (Y(O, J), F(O, J), O.push(r.outputColorSpace)), O.push(J.customProgramCacheKey), O.join();
  }
  function Y(J, O) {
    J.push(O.precision), J.push(O.outputColorSpace), J.push(O.envMapMode), J.push(O.envMapCubeUVHeight), J.push(O.mapUv), J.push(O.alphaMapUv), J.push(O.lightMapUv), J.push(O.aoMapUv), J.push(O.bumpMapUv), J.push(O.normalMapUv), J.push(O.displacementMapUv), J.push(O.emissiveMapUv), J.push(O.metalnessMapUv), J.push(O.roughnessMapUv), J.push(O.anisotropyMapUv), J.push(O.clearcoatMapUv), J.push(O.clearcoatNormalMapUv), J.push(O.clearcoatRoughnessMapUv), J.push(O.iridescenceMapUv), J.push(O.iridescenceThicknessMapUv), J.push(O.sheenColorMapUv), J.push(O.sheenRoughnessMapUv), J.push(O.specularMapUv), J.push(O.specularColorMapUv), J.push(O.specularIntensityMapUv), J.push(O.transmissionMapUv), J.push(O.thicknessMapUv), J.push(O.combine), J.push(O.fogExp2), J.push(O.sizeAttenuation), J.push(O.morphTargetsCount), J.push(O.morphAttributeCount), J.push(O.numDirLights), J.push(O.numPointLights), J.push(O.numSpotLights), J.push(O.numSpotLightMaps), J.push(O.numHemiLights), J.push(O.numRectAreaLights), J.push(O.numDirLightShadows), J.push(O.numPointLightShadows), J.push(O.numSpotLightShadows), J.push(O.numSpotLightShadowsWithMaps), J.push(O.numLightProbes), J.push(O.shadowMapType), J.push(O.toneMapping), J.push(O.numClippingPlanes), J.push(O.numClipIntersection), J.push(O.depthPacking);
  }
  function F(J, O) {
    u.disableAll(), O.supportsVertexTextures && u.enable(0), O.instancing && u.enable(1), O.instancingColor && u.enable(2), O.instancingMorph && u.enable(3), O.matcap && u.enable(4), O.envMap && u.enable(5), O.normalMapObjectSpace && u.enable(6), O.normalMapTangentSpace && u.enable(7), O.clearcoat && u.enable(8), O.iridescence && u.enable(9), O.alphaTest && u.enable(10), O.vertexColors && u.enable(11), O.vertexAlphas && u.enable(12), O.vertexUv1s && u.enable(13), O.vertexUv2s && u.enable(14), O.vertexUv3s && u.enable(15), O.vertexTangents && u.enable(16), O.anisotropy && u.enable(17), O.alphaHash && u.enable(18), O.batching && u.enable(19), O.dispersion && u.enable(20), O.batchingColor && u.enable(21), J.push(u.mask), u.disableAll(), O.fog && u.enable(0), O.useFog && u.enable(1), O.flatShading && u.enable(2), O.logarithmicDepthBuffer && u.enable(3), O.skinning && u.enable(4), O.morphTargets && u.enable(5), O.morphNormals && u.enable(6), O.morphColors && u.enable(7), O.premultipliedAlpha && u.enable(8), O.shadowMapEnabled && u.enable(9), O.doubleSided && u.enable(10), O.flipSided && u.enable(11), O.useDepthPacking && u.enable(12), O.dithering && u.enable(13), O.transmission && u.enable(14), O.sheen && u.enable(15), O.opaque && u.enable(16), O.pointsUvs && u.enable(17), O.decodeVideoTexture && u.enable(18), O.alphaToCoverage && u.enable(19), J.push(u.mask);
  }
  function T(J) {
    const O = R[J.type];
    let ne;
    if (O) {
      const he = ef[O];
      ne = zK.clone(he.uniforms);
    } else
      ne = J.uniforms;
    return ne;
  }
  function P(J, O) {
    let ne;
    for (let he = 0, pe = f.length; he < pe; he++) {
      const Ae = f[he];
      if (Ae.cacheKey === O) {
        ne = Ae, ++ne.usedTimes;
        break;
      }
    }
    return ne === void 0 && (ne = new qq(r, O, J, o), f.push(ne)), ne;
  }
  function D(J) {
    if (--J.usedTimes === 0) {
      const O = f.indexOf(J);
      f[O] = f[f.length - 1], f.pop(), J.destroy();
    }
  }
  function L(J) {
    I.remove(J);
  }
  function j() {
    I.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: N,
    getUniforms: T,
    acquireProgram: P,
    releaseProgram: D,
    releaseShaderCache: L,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: f,
    dispose: j
  };
}
function i6() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(o) {
    let l = r.get(o);
    return l === void 0 && (l = {}, r.set(o, l)), l;
  }
  function t(o) {
    r.delete(o);
  }
  function n(o, l, u) {
    r.get(o)[l] = u;
  }
  function i() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: i
  };
}
function r6(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function G3(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function B3() {
  const r = [];
  let e = 0;
  const t = [], n = [], i = [];
  function o() {
    e = 0, t.length = 0, n.length = 0, i.length = 0;
  }
  function l(v, b, S, R, W, x) {
    let N = r[e];
    return N === void 0 ? (N = {
      id: v.id,
      object: v,
      geometry: b,
      material: S,
      groupOrder: R,
      renderOrder: v.renderOrder,
      z: W,
      group: x
    }, r[e] = N) : (N.id = v.id, N.object = v, N.geometry = b, N.material = S, N.groupOrder = R, N.renderOrder = v.renderOrder, N.z = W, N.group = x), e++, N;
  }
  function u(v, b, S, R, W, x) {
    const N = l(v, b, S, R, W, x);
    S.transmission > 0 ? n.push(N) : S.transparent === !0 ? i.push(N) : t.push(N);
  }
  function I(v, b, S, R, W, x) {
    const N = l(v, b, S, R, W, x);
    S.transmission > 0 ? n.unshift(N) : S.transparent === !0 ? i.unshift(N) : t.unshift(N);
  }
  function C(v, b) {
    t.length > 1 && t.sort(v || r6), n.length > 1 && n.sort(b || G3), i.length > 1 && i.sort(b || G3);
  }
  function f() {
    for (let v = e, b = r.length; v < b; v++) {
      const S = r[v];
      if (S.id === null) break;
      S.id = null, S.object = null, S.geometry = null, S.material = null, S.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: o,
    push: u,
    unshift: I,
    finish: f,
    sort: C
  };
}
function a6() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(n, i) {
    const o = r.get(n);
    let l;
    return o === void 0 ? (l = new B3(), r.set(n, [l])) : i >= o.length ? (l = new B3(), o.push(l)) : l = o[i], l;
  }
  function t() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function o6() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new fe(),
            color: new ai()
          };
          break;
        case "SpotLight":
          t = {
            position: new fe(),
            direction: new fe(),
            color: new ai(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new fe(),
            color: new ai(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new fe(),
            skyColor: new ai(),
            groundColor: new ai()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new ai(),
            position: new fe(),
            halfWidth: new fe(),
            halfHeight: new fe()
          };
          break;
      }
      return r[e.id] = t, t;
    }
  };
}
function s6() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Lt()
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Lt()
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Lt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return r[e.id] = t, t;
    }
  };
}
let l6 = 0;
function u6(r, e) {
  return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
}
function c6(r) {
  const e = new o6(), t = s6(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let C = 0; C < 9; C++) n.probe.push(new fe());
  const i = new fe(), o = new _i(), l = new _i();
  function u(C) {
    let f = 0, v = 0, b = 0;
    for (let J = 0; J < 9; J++) n.probe[J].set(0, 0, 0);
    let S = 0, R = 0, W = 0, x = 0, N = 0, Y = 0, F = 0, T = 0, P = 0, D = 0, L = 0;
    C.sort(u6);
    for (let J = 0, O = C.length; J < O; J++) {
      const ne = C[J], he = ne.color, pe = ne.intensity, Ae = ne.distance, ke = ne.shadow && ne.shadow.map ? ne.shadow.map.texture : null;
      if (ne.isAmbientLight)
        f += he.r * pe, v += he.g * pe, b += he.b * pe;
      else if (ne.isLightProbe) {
        for (let Re = 0; Re < 9; Re++)
          n.probe[Re].addScaledVector(ne.sh.coefficients[Re], pe);
        L++;
      } else if (ne.isDirectionalLight) {
        const Re = e.get(ne);
        if (Re.color.copy(ne.color).multiplyScalar(ne.intensity), ne.castShadow) {
          const Xe = ne.shadow, re = t.get(ne);
          re.shadowIntensity = Xe.intensity, re.shadowBias = Xe.bias, re.shadowNormalBias = Xe.normalBias, re.shadowRadius = Xe.radius, re.shadowMapSize = Xe.mapSize, n.directionalShadow[S] = re, n.directionalShadowMap[S] = ke, n.directionalShadowMatrix[S] = ne.shadow.matrix, Y++;
        }
        n.directional[S] = Re, S++;
      } else if (ne.isSpotLight) {
        const Re = e.get(ne);
        Re.position.setFromMatrixPosition(ne.matrixWorld), Re.color.copy(he).multiplyScalar(pe), Re.distance = Ae, Re.coneCos = Math.cos(ne.angle), Re.penumbraCos = Math.cos(ne.angle * (1 - ne.penumbra)), Re.decay = ne.decay, n.spot[W] = Re;
        const Xe = ne.shadow;
        if (ne.map && (n.spotLightMap[P] = ne.map, P++, Xe.updateMatrices(ne), ne.castShadow && D++), n.spotLightMatrix[W] = Xe.matrix, ne.castShadow) {
          const re = t.get(ne);
          re.shadowIntensity = Xe.intensity, re.shadowBias = Xe.bias, re.shadowNormalBias = Xe.normalBias, re.shadowRadius = Xe.radius, re.shadowMapSize = Xe.mapSize, n.spotShadow[W] = re, n.spotShadowMap[W] = ke, T++;
        }
        W++;
      } else if (ne.isRectAreaLight) {
        const Re = e.get(ne);
        Re.color.copy(he).multiplyScalar(pe), Re.halfWidth.set(ne.width * 0.5, 0, 0), Re.halfHeight.set(0, ne.height * 0.5, 0), n.rectArea[x] = Re, x++;
      } else if (ne.isPointLight) {
        const Re = e.get(ne);
        if (Re.color.copy(ne.color).multiplyScalar(ne.intensity), Re.distance = ne.distance, Re.decay = ne.decay, ne.castShadow) {
          const Xe = ne.shadow, re = t.get(ne);
          re.shadowIntensity = Xe.intensity, re.shadowBias = Xe.bias, re.shadowNormalBias = Xe.normalBias, re.shadowRadius = Xe.radius, re.shadowMapSize = Xe.mapSize, re.shadowCameraNear = Xe.camera.near, re.shadowCameraFar = Xe.camera.far, n.pointShadow[R] = re, n.pointShadowMap[R] = ke, n.pointShadowMatrix[R] = ne.shadow.matrix, F++;
        }
        n.point[R] = Re, R++;
      } else if (ne.isHemisphereLight) {
        const Re = e.get(ne);
        Re.skyColor.copy(ne.color).multiplyScalar(pe), Re.groundColor.copy(ne.groundColor).multiplyScalar(pe), n.hemi[N] = Re, N++;
      }
    }
    x > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Pn.LTC_FLOAT_1, n.rectAreaLTC2 = Pn.LTC_FLOAT_2) : (n.rectAreaLTC1 = Pn.LTC_HALF_1, n.rectAreaLTC2 = Pn.LTC_HALF_2)), n.ambient[0] = f, n.ambient[1] = v, n.ambient[2] = b;
    const j = n.hash;
    (j.directionalLength !== S || j.pointLength !== R || j.spotLength !== W || j.rectAreaLength !== x || j.hemiLength !== N || j.numDirectionalShadows !== Y || j.numPointShadows !== F || j.numSpotShadows !== T || j.numSpotMaps !== P || j.numLightProbes !== L) && (n.directional.length = S, n.spot.length = W, n.rectArea.length = x, n.point.length = R, n.hemi.length = N, n.directionalShadow.length = Y, n.directionalShadowMap.length = Y, n.pointShadow.length = F, n.pointShadowMap.length = F, n.spotShadow.length = T, n.spotShadowMap.length = T, n.directionalShadowMatrix.length = Y, n.pointShadowMatrix.length = F, n.spotLightMatrix.length = T + P - D, n.spotLightMap.length = P, n.numSpotLightShadowsWithMaps = D, n.numLightProbes = L, j.directionalLength = S, j.pointLength = R, j.spotLength = W, j.rectAreaLength = x, j.hemiLength = N, j.numDirectionalShadows = Y, j.numPointShadows = F, j.numSpotShadows = T, j.numSpotMaps = P, j.numLightProbes = L, n.version = l6++);
  }
  function I(C, f) {
    let v = 0, b = 0, S = 0, R = 0, W = 0;
    const x = f.matrixWorldInverse;
    for (let N = 0, Y = C.length; N < Y; N++) {
      const F = C[N];
      if (F.isDirectionalLight) {
        const T = n.directional[v];
        T.direction.setFromMatrixPosition(F.matrixWorld), i.setFromMatrixPosition(F.target.matrixWorld), T.direction.sub(i), T.direction.transformDirection(x), v++;
      } else if (F.isSpotLight) {
        const T = n.spot[S];
        T.position.setFromMatrixPosition(F.matrixWorld), T.position.applyMatrix4(x), T.direction.setFromMatrixPosition(F.matrixWorld), i.setFromMatrixPosition(F.target.matrixWorld), T.direction.sub(i), T.direction.transformDirection(x), S++;
      } else if (F.isRectAreaLight) {
        const T = n.rectArea[R];
        T.position.setFromMatrixPosition(F.matrixWorld), T.position.applyMatrix4(x), l.identity(), o.copy(F.matrixWorld), o.premultiply(x), l.extractRotation(o), T.halfWidth.set(F.width * 0.5, 0, 0), T.halfHeight.set(0, F.height * 0.5, 0), T.halfWidth.applyMatrix4(l), T.halfHeight.applyMatrix4(l), R++;
      } else if (F.isPointLight) {
        const T = n.point[b];
        T.position.setFromMatrixPosition(F.matrixWorld), T.position.applyMatrix4(x), b++;
      } else if (F.isHemisphereLight) {
        const T = n.hemi[W];
        T.direction.setFromMatrixPosition(F.matrixWorld), T.direction.transformDirection(x), W++;
      }
    }
  }
  return {
    setup: u,
    setupView: I,
    state: n
  };
}
function S3(r) {
  const e = new c6(r), t = [], n = [];
  function i(f) {
    C.camera = f, t.length = 0, n.length = 0;
  }
  function o(f) {
    t.push(f);
  }
  function l(f) {
    n.push(f);
  }
  function u() {
    e.setup(t);
  }
  function I(f) {
    e.setupView(t, f);
  }
  const C = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: i,
    state: C,
    setupLights: u,
    setupLightsView: I,
    pushLight: o,
    pushShadow: l
  };
}
function g6(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(i, o = 0) {
    const l = e.get(i);
    let u;
    return l === void 0 ? (u = new S3(r), e.set(i, [u])) : o >= l.length ? (u = new S3(r), l.push(u)) : u = l[o], u;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: n
  };
}
class CY extends Cg {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = BK, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class hY extends Cg {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const d6 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, I6 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function C6(r, e, t) {
  let n = new tR();
  const i = new Lt(), o = new Lt(), l = new Ha(), u = new CY({ depthPacking: SK }), I = new hY(), C = {}, f = t.maxTextureSize, v = { [Um]: td, [td]: Um, [ip]: ip }, b = new rf({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Lt() },
      radius: { value: 4 }
    },
    vertexShader: d6,
    fragmentShader: I6
  }), S = b.clone();
  S.defines.HORIZONTAL_PASS = 1;
  const R = new Br();
  R.setAttribute(
    "position",
    new ja(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const W = new kl(R, b), x = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = VW;
  let N = this.type;
  this.render = function(D, L, j) {
    if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || D.length === 0) return;
    const J = r.getRenderTarget(), O = r.getActiveCubeFace(), ne = r.getActiveMipmapLevel(), he = r.state;
    he.setBlending(Dm), he.buffers.color.setClear(1, 1, 1, 1), he.buffers.depth.setTest(!0), he.setScissorTest(!1);
    const pe = N !== qh && this.type === qh, Ae = N === qh && this.type !== qh;
    for (let ke = 0, Re = D.length; ke < Re; ke++) {
      const Xe = D[ke], re = Xe.shadow;
      if (re === void 0) {
        console.warn("THREE.WebGLShadowMap:", Xe, "has no shadow.");
        continue;
      }
      if (re.autoUpdate === !1 && re.needsUpdate === !1) continue;
      i.copy(re.mapSize);
      const Se = re.getFrameExtents();
      if (i.multiply(Se), o.copy(re.mapSize), (i.x > f || i.y > f) && (i.x > f && (o.x = Math.floor(f / Se.x), i.x = o.x * Se.x, re.mapSize.x = o.x), i.y > f && (o.y = Math.floor(f / Se.y), i.y = o.y * Se.y, re.mapSize.y = o.y)), re.map === null || pe === !0 || Ae === !0) {
        const le = this.type !== qh ? { minFilter: Lu, magFilter: Lu } : {};
        re.map !== null && re.map.dispose(), re.map = new QC(i.x, i.y, le), re.map.texture.name = Xe.name + ".shadowMap", re.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(re.map), r.clear();
      const Be = re.getViewportCount();
      for (let le = 0; le < Be; le++) {
        const Ye = re.getViewport(le);
        l.set(
          o.x * Ye.x,
          o.y * Ye.y,
          o.x * Ye.z,
          o.y * Ye.w
        ), he.viewport(l), re.updateMatrices(Xe, le), n = re.getFrustum(), T(L, j, re.camera, Xe, this.type);
      }
      re.isPointLightShadow !== !0 && this.type === qh && Y(re, j), re.needsUpdate = !1;
    }
    N = this.type, x.needsUpdate = !1, r.setRenderTarget(J, O, ne);
  };
  function Y(D, L) {
    const j = e.update(W);
    b.defines.VSM_SAMPLES !== D.blurSamples && (b.defines.VSM_SAMPLES = D.blurSamples, S.defines.VSM_SAMPLES = D.blurSamples, b.needsUpdate = !0, S.needsUpdate = !0), D.mapPass === null && (D.mapPass = new QC(i.x, i.y)), b.uniforms.shadow_pass.value = D.map.texture, b.uniforms.resolution.value = D.mapSize, b.uniforms.radius.value = D.radius, r.setRenderTarget(D.mapPass), r.clear(), r.renderBufferDirect(L, null, j, b, W, null), S.uniforms.shadow_pass.value = D.mapPass.texture, S.uniforms.resolution.value = D.mapSize, S.uniforms.radius.value = D.radius, r.setRenderTarget(D.map), r.clear(), r.renderBufferDirect(L, null, j, S, W, null);
  }
  function F(D, L, j, J) {
    let O = null;
    const ne = j.isPointLight === !0 ? D.customDistanceMaterial : D.customDepthMaterial;
    if (ne !== void 0)
      O = ne;
    else if (O = j.isPointLight === !0 ? I : u, r.localClippingEnabled && L.clipShadows === !0 && Array.isArray(L.clippingPlanes) && L.clippingPlanes.length !== 0 || L.displacementMap && L.displacementScale !== 0 || L.alphaMap && L.alphaTest > 0 || L.map && L.alphaTest > 0) {
      const he = O.uuid, pe = L.uuid;
      let Ae = C[he];
      Ae === void 0 && (Ae = {}, C[he] = Ae);
      let ke = Ae[pe];
      ke === void 0 && (ke = O.clone(), Ae[pe] = ke, L.addEventListener("dispose", P)), O = ke;
    }
    if (O.visible = L.visible, O.wireframe = L.wireframe, J === qh ? O.side = L.shadowSide !== null ? L.shadowSide : L.side : O.side = L.shadowSide !== null ? L.shadowSide : v[L.side], O.alphaMap = L.alphaMap, O.alphaTest = L.alphaTest, O.map = L.map, O.clipShadows = L.clipShadows, O.clippingPlanes = L.clippingPlanes, O.clipIntersection = L.clipIntersection, O.displacementMap = L.displacementMap, O.displacementScale = L.displacementScale, O.displacementBias = L.displacementBias, O.wireframeLinewidth = L.wireframeLinewidth, O.linewidth = L.linewidth, j.isPointLight === !0 && O.isMeshDistanceMaterial === !0) {
      const he = r.properties.get(O);
      he.light = j;
    }
    return O;
  }
  function T(D, L, j, J, O) {
    if (D.visible === !1) return;
    if (D.layers.test(L.layers) && (D.isMesh || D.isLine || D.isPoints) && (D.castShadow || D.receiveShadow && O === qh) && (!D.frustumCulled || n.intersectsObject(D))) {
      D.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse, D.matrixWorld);
      const pe = e.update(D), Ae = D.material;
      if (Array.isArray(Ae)) {
        const ke = pe.groups;
        for (let Re = 0, Xe = ke.length; Re < Xe; Re++) {
          const re = ke[Re], Se = Ae[re.materialIndex];
          if (Se && Se.visible) {
            const Be = F(D, Se, J, O);
            D.onBeforeShadow(r, D, L, j, pe, Be, re), r.renderBufferDirect(j, null, pe, Be, D, re), D.onAfterShadow(r, D, L, j, pe, Be, re);
          }
        }
      } else if (Ae.visible) {
        const ke = F(D, Ae, J, O);
        D.onBeforeShadow(r, D, L, j, pe, ke, null), r.renderBufferDirect(j, null, pe, ke, D, null), D.onAfterShadow(r, D, L, j, pe, ke, null);
      }
    }
    const he = D.children;
    for (let pe = 0, Ae = he.length; pe < Ae; pe++)
      T(he[pe], L, j, J, O);
  }
  function P(D) {
    D.target.removeEventListener("dispose", P);
    for (const j in C) {
      const J = C[j], O = D.target.uuid;
      O in J && (J[O].dispose(), delete J[O]);
    }
  }
}
function h6(r) {
  function e() {
    let de = !1;
    const it = new Ha();
    let je = null;
    const et = new Ha(0, 0, 0, 0);
    return {
      setMask: function(Jt) {
        je !== Jt && !de && (r.colorMask(Jt, Jt, Jt, Jt), je = Jt);
      },
      setLocked: function(Jt) {
        de = Jt;
      },
      setClear: function(Jt, Kn, di, Di, Jn) {
        Jn === !0 && (Jt *= Di, Kn *= Di, di *= Di), it.set(Jt, Kn, di, Di), et.equals(it) === !1 && (r.clearColor(Jt, Kn, di, Di), et.copy(it));
      },
      reset: function() {
        de = !1, je = null, et.set(-1, 0, 0, 0);
      }
    };
  }
  function t() {
    let de = !1, it = null, je = null, et = null;
    return {
      setTest: function(Jt) {
        Jt ? wt(r.DEPTH_TEST) : mt(r.DEPTH_TEST);
      },
      setMask: function(Jt) {
        it !== Jt && !de && (r.depthMask(Jt), it = Jt);
      },
      setFunc: function(Jt) {
        if (je !== Jt) {
          switch (Jt) {
            case aK:
              r.depthFunc(r.NEVER);
              break;
            case oK:
              r.depthFunc(r.ALWAYS);
              break;
            case sK:
              r.depthFunc(r.LESS);
              break;
            case mw:
              r.depthFunc(r.LEQUAL);
              break;
            case lK:
              r.depthFunc(r.EQUAL);
              break;
            case uK:
              r.depthFunc(r.GEQUAL);
              break;
            case cK:
              r.depthFunc(r.GREATER);
              break;
            case gK:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          je = Jt;
        }
      },
      setLocked: function(Jt) {
        de = Jt;
      },
      setClear: function(Jt) {
        et !== Jt && (r.clearDepth(Jt), et = Jt);
      },
      reset: function() {
        de = !1, it = null, je = null, et = null;
      }
    };
  }
  function n() {
    let de = !1, it = null, je = null, et = null, Jt = null, Kn = null, di = null, Di = null, Jn = null;
    return {
      setTest: function(Ii) {
        de || (Ii ? wt(r.STENCIL_TEST) : mt(r.STENCIL_TEST));
      },
      setMask: function(Ii) {
        it !== Ii && !de && (r.stencilMask(Ii), it = Ii);
      },
      setFunc: function(Ii, dr, xr) {
        (je !== Ii || et !== dr || Jt !== xr) && (r.stencilFunc(Ii, dr, xr), je = Ii, et = dr, Jt = xr);
      },
      setOp: function(Ii, dr, xr) {
        (Kn !== Ii || di !== dr || Di !== xr) && (r.stencilOp(Ii, dr, xr), Kn = Ii, di = dr, Di = xr);
      },
      setLocked: function(Ii) {
        de = Ii;
      },
      setClear: function(Ii) {
        Jn !== Ii && (r.clearStencil(Ii), Jn = Ii);
      },
      reset: function() {
        de = !1, it = null, je = null, et = null, Jt = null, Kn = null, di = null, Di = null, Jn = null;
      }
    };
  }
  const i = new e(), o = new t(), l = new n(), u = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap();
  let C = {}, f = {}, v = /* @__PURE__ */ new WeakMap(), b = [], S = null, R = !1, W = null, x = null, N = null, Y = null, F = null, T = null, P = null, D = new ai(0, 0, 0), L = 0, j = !1, J = null, O = null, ne = null, he = null, pe = null;
  const Ae = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let ke = !1, Re = 0;
  const Xe = r.getParameter(r.VERSION);
  Xe.indexOf("WebGL") !== -1 ? (Re = parseFloat(/^WebGL (\d)/.exec(Xe)[1]), ke = Re >= 1) : Xe.indexOf("OpenGL ES") !== -1 && (Re = parseFloat(/^OpenGL ES (\d)/.exec(Xe)[1]), ke = Re >= 2);
  let re = null, Se = {};
  const Be = r.getParameter(r.SCISSOR_BOX), le = r.getParameter(r.VIEWPORT), Ye = new Ha().fromArray(Be), nt = new Ha().fromArray(le);
  function ze(de, it, je, et) {
    const Jt = new Uint8Array(4), Kn = r.createTexture();
    r.bindTexture(de, Kn), r.texParameteri(de, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(de, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let di = 0; di < je; di++)
      de === r.TEXTURE_3D || de === r.TEXTURE_2D_ARRAY ? r.texImage3D(it, 0, r.RGBA, 1, 1, et, 0, r.RGBA, r.UNSIGNED_BYTE, Jt) : r.texImage2D(it + di, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Jt);
    return Kn;
  }
  const Je = {};
  Je[r.TEXTURE_2D] = ze(r.TEXTURE_2D, r.TEXTURE_2D, 1), Je[r.TEXTURE_CUBE_MAP] = ze(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Je[r.TEXTURE_2D_ARRAY] = ze(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), Je[r.TEXTURE_3D] = ze(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), o.setClear(1), l.setClear(0), wt(r.DEPTH_TEST), o.setFunc(mw), $t(!1), ft(KH), wt(r.CULL_FACE), Wt(Dm);
  function wt(de) {
    C[de] !== !0 && (r.enable(de), C[de] = !0);
  }
  function mt(de) {
    C[de] !== !1 && (r.disable(de), C[de] = !1);
  }
  function Dt(de, it) {
    return f[de] !== it ? (r.bindFramebuffer(de, it), f[de] = it, de === r.DRAW_FRAMEBUFFER && (f[r.FRAMEBUFFER] = it), de === r.FRAMEBUFFER && (f[r.DRAW_FRAMEBUFFER] = it), !0) : !1;
  }
  function mn(de, it) {
    let je = b, et = !1;
    if (de) {
      je = v.get(it), je === void 0 && (je = [], v.set(it, je));
      const Jt = de.textures;
      if (je.length !== Jt.length || je[0] !== r.COLOR_ATTACHMENT0) {
        for (let Kn = 0, di = Jt.length; Kn < di; Kn++)
          je[Kn] = r.COLOR_ATTACHMENT0 + Kn;
        je.length = Jt.length, et = !0;
      }
    } else
      je[0] !== r.BACK && (je[0] = r.BACK, et = !0);
    et && r.drawBuffers(je);
  }
  function An(de) {
    return S !== de ? (r.useProgram(de), S = de, !0) : !1;
  }
  const Hn = {
    [gv]: r.FUNC_ADD,
    [Kz]: r.FUNC_SUBTRACT,
    [Lz]: r.FUNC_REVERSE_SUBTRACT
  };
  Hn[kz] = r.MIN, Hn[Dz] = r.MAX;
  const ge = {
    [Uz]: r.ZERO,
    [Oz]: r.ONE,
    [Pz]: r.SRC_COLOR,
    [S2]: r.SRC_ALPHA,
    [eK]: r.SRC_ALPHA_SATURATE,
    [qz]: r.DST_COLOR,
    [Qz]: r.DST_ALPHA,
    [Jz]: r.ONE_MINUS_SRC_COLOR,
    [Z2]: r.ONE_MINUS_SRC_ALPHA,
    [$z]: r.ONE_MINUS_DST_COLOR,
    [jz]: r.ONE_MINUS_DST_ALPHA,
    [tK]: r.CONSTANT_COLOR,
    [nK]: r.ONE_MINUS_CONSTANT_COLOR,
    [iK]: r.CONSTANT_ALPHA,
    [rK]: r.ONE_MINUS_CONSTANT_ALPHA
  };
  function Wt(de, it, je, et, Jt, Kn, di, Di, Jn, Ii) {
    if (de === Dm) {
      R === !0 && (mt(r.BLEND), R = !1);
      return;
    }
    if (R === !1 && (wt(r.BLEND), R = !0), de !== zz) {
      if (de !== W || Ii !== j) {
        if ((x !== gv || F !== gv) && (r.blendEquation(r.FUNC_ADD), x = gv, F = gv), Ii)
          switch (de) {
            case Cb:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case LH:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case kH:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case DH:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", de);
              break;
          }
        else
          switch (de) {
            case Cb:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case LH:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case kH:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case DH:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", de);
              break;
          }
        N = null, Y = null, T = null, P = null, D.set(0, 0, 0), L = 0, W = de, j = Ii;
      }
      return;
    }
    Jt = Jt || it, Kn = Kn || je, di = di || et, (it !== x || Jt !== F) && (r.blendEquationSeparate(Hn[it], Hn[Jt]), x = it, F = Jt), (je !== N || et !== Y || Kn !== T || di !== P) && (r.blendFuncSeparate(ge[je], ge[et], ge[Kn], ge[di]), N = je, Y = et, T = Kn, P = di), (Di.equals(D) === !1 || Jn !== L) && (r.blendColor(Di.r, Di.g, Di.b, Jn), D.copy(Di), L = Jn), W = de, j = !1;
  }
  function Nt(de, it) {
    de.side === ip ? mt(r.CULL_FACE) : wt(r.CULL_FACE);
    let je = de.side === td;
    it && (je = !je), $t(je), de.blending === Cb && de.transparent === !1 ? Wt(Dm) : Wt(de.blending, de.blendEquation, de.blendSrc, de.blendDst, de.blendEquationAlpha, de.blendSrcAlpha, de.blendDstAlpha, de.blendColor, de.blendAlpha, de.premultipliedAlpha), o.setFunc(de.depthFunc), o.setTest(de.depthTest), o.setMask(de.depthWrite), i.setMask(de.colorWrite);
    const et = de.stencilWrite;
    l.setTest(et), et && (l.setMask(de.stencilWriteMask), l.setFunc(de.stencilFunc, de.stencilRef, de.stencilFuncMask), l.setOp(de.stencilFail, de.stencilZFail, de.stencilZPass)), en(de.polygonOffset, de.polygonOffsetFactor, de.polygonOffsetUnits), de.alphaToCoverage === !0 ? wt(r.SAMPLE_ALPHA_TO_COVERAGE) : mt(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function $t(de) {
    J !== de && (de ? r.frontFace(r.CW) : r.frontFace(r.CCW), J = de);
  }
  function ft(de) {
    de !== Ez ? (wt(r.CULL_FACE), de !== O && (de === KH ? r.cullFace(r.BACK) : de === Tz ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : mt(r.CULL_FACE), O = de;
  }
  function bn(de) {
    de !== ne && (ke && r.lineWidth(de), ne = de);
  }
  function en(de, it, je) {
    de ? (wt(r.POLYGON_OFFSET_FILL), (he !== it || pe !== je) && (r.polygonOffset(it, je), he = it, pe = je)) : mt(r.POLYGON_OFFSET_FILL);
  }
  function hn(de) {
    de ? wt(r.SCISSOR_TEST) : mt(r.SCISSOR_TEST);
  }
  function me(de) {
    de === void 0 && (de = r.TEXTURE0 + Ae - 1), re !== de && (r.activeTexture(de), re = de);
  }
  function se(de, it, je) {
    je === void 0 && (re === null ? je = r.TEXTURE0 + Ae - 1 : je = re);
    let et = Se[je];
    et === void 0 && (et = { type: void 0, texture: void 0 }, Se[je] = et), (et.type !== de || et.texture !== it) && (re !== je && (r.activeTexture(je), re = je), r.bindTexture(de, it || Je[de]), et.type = de, et.texture = it);
  }
  function $e() {
    const de = Se[re];
    de !== void 0 && de.type !== void 0 && (r.bindTexture(de.type, null), de.type = void 0, de.texture = void 0);
  }
  function Vt() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function Bt() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function Mt() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function Gn() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function jt() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function an() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function jn() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function Ot() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function He() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function vt() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (de) {
      console.error("THREE.WebGLState:", de);
    }
  }
  function xt(de) {
    Ye.equals(de) === !1 && (r.scissor(de.x, de.y, de.z, de.w), Ye.copy(de));
  }
  function ht(de) {
    nt.equals(de) === !1 && (r.viewport(de.x, de.y, de.z, de.w), nt.copy(de));
  }
  function on(de, it) {
    let je = I.get(it);
    je === void 0 && (je = /* @__PURE__ */ new WeakMap(), I.set(it, je));
    let et = je.get(de);
    et === void 0 && (et = r.getUniformBlockIndex(it, de.name), je.set(de, et));
  }
  function we(de, it) {
    const et = I.get(it).get(de);
    u.get(it) !== et && (r.uniformBlockBinding(it, et, de.__bindingPointIndex), u.set(it, et));
  }
  function qe() {
    r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), C = {}, re = null, Se = {}, f = {}, v = /* @__PURE__ */ new WeakMap(), b = [], S = null, R = !1, W = null, x = null, N = null, Y = null, F = null, T = null, P = null, D = new ai(0, 0, 0), L = 0, j = !1, J = null, O = null, ne = null, he = null, pe = null, Ye.set(0, 0, r.canvas.width, r.canvas.height), nt.set(0, 0, r.canvas.width, r.canvas.height), i.reset(), o.reset(), l.reset();
  }
  return {
    buffers: {
      color: i,
      depth: o,
      stencil: l
    },
    enable: wt,
    disable: mt,
    bindFramebuffer: Dt,
    drawBuffers: mn,
    useProgram: An,
    setBlending: Wt,
    setMaterial: Nt,
    setFlipSided: $t,
    setCullFace: ft,
    setLineWidth: bn,
    setPolygonOffset: en,
    setScissorTest: hn,
    activeTexture: me,
    bindTexture: se,
    unbindTexture: $e,
    compressedTexImage2D: Vt,
    compressedTexImage3D: Bt,
    texImage2D: He,
    texImage3D: vt,
    updateUBOMapping: on,
    uniformBlockBinding: we,
    texStorage2D: jn,
    texStorage3D: Ot,
    texSubImage2D: Mt,
    texSubImage3D: Gn,
    compressedTexSubImage2D: jt,
    compressedTexSubImage3D: an,
    scissor: xt,
    viewport: ht,
    reset: qe
  };
}
function f6(r, e) {
  const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
  return t > e ? (r.repeat.x = 1, r.repeat.y = t / e, r.offset.x = 0, r.offset.y = (1 - r.repeat.y) / 2) : (r.repeat.x = e / t, r.repeat.y = 1, r.offset.x = (1 - r.repeat.x) / 2, r.offset.y = 0), r;
}
function p6(r, e) {
  const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
  return t > e ? (r.repeat.x = e / t, r.repeat.y = 1, r.offset.x = (1 - r.repeat.x) / 2, r.offset.y = 0) : (r.repeat.x = 1, r.repeat.y = t / e, r.offset.x = 0, r.offset.y = (1 - r.repeat.y) / 2), r;
}
function m6(r) {
  return r.repeat.x = 1, r.repeat.y = 1, r.offset.x = 0, r.offset.y = 0, r;
}
function jH(r, e, t, n) {
  const i = A6(n);
  switch (t) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case tY:
      return r * e;
    case iY:
      return r * e;
    case rY:
      return r * e * 2;
    case YW:
      return r * e / i.components * i.byteLength;
    case jw:
      return r * e / i.components * i.byteLength;
    case aY:
      return r * e * 2 / i.components * i.byteLength;
    case FW:
      return r * e * 2 / i.components * i.byteLength;
    case nY:
      return r * e * 3 / i.components * i.byteLength;
    case cg:
      return r * e * 4 / i.components * i.byteLength;
    case EW:
      return r * e * 4 / i.components * i.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case qZ:
    case $Z:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case ew:
    case tw:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case R2:
    case W2:
      return Math.max(r, 16) * Math.max(e, 8) / 4;
    case w2:
    case x2:
      return Math.max(r, 8) * Math.max(e, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case V2:
    case N2:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case M2:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case H2:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case X2:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Y2:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case F2:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case E2:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case T2:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case _2:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case z2:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case K2:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case L2:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case k2:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case D2:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case U2:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case O2:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case nw:
    case P2:
    case J2:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case oY:
    case Q2:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case j2:
    case q2:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${t} format.`
  );
}
function A6(r) {
  switch (r) {
    case nf:
    case qX:
      return { byteLength: 1, components: 1 };
    case CB:
    case $X:
    case Vb:
      return { byteLength: 2, components: 1 };
    case HW:
    case XW:
      return { byteLength: 2, components: 4 };
    case Pm:
    case MW:
    case ed:
      return { byteLength: 4, components: 1 };
    case eY:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
const v6 = {
  contain: f6,
  cover: p6,
  fill: m6,
  getByteLength: jH
};
function y6(r, e, t, n, i, o, l) {
  const u = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, I = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), C = new Lt(), f = /* @__PURE__ */ new WeakMap();
  let v;
  const b = /* @__PURE__ */ new WeakMap();
  let S = !1;
  try {
    S = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function R(me, se) {
    return S ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(me, se)
    ) : Ww("canvas");
  }
  function W(me, se, $e) {
    let Vt = 1;
    const Bt = hn(me);
    if ((Bt.width > $e || Bt.height > $e) && (Vt = $e / Math.max(Bt.width, Bt.height)), Vt < 1)
      if (typeof HTMLImageElement < "u" && me instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && me instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && me instanceof ImageBitmap || typeof VideoFrame < "u" && me instanceof VideoFrame) {
        const Mt = Math.floor(Vt * Bt.width), Gn = Math.floor(Vt * Bt.height);
        v === void 0 && (v = R(Mt, Gn));
        const jt = se ? R(Mt, Gn) : v;
        return jt.width = Mt, jt.height = Gn, jt.getContext("2d").drawImage(me, 0, 0, Mt, Gn), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Bt.width + "x" + Bt.height + ") to (" + Mt + "x" + Gn + ")."), jt;
      } else
        return "data" in me && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Bt.width + "x" + Bt.height + ")."), me;
    return me;
  }
  function x(me) {
    return me.generateMipmaps && me.minFilter !== Lu && me.minFilter !== Ks;
  }
  function N(me) {
    r.generateMipmap(me);
  }
  function Y(me, se, $e, Vt, Bt = !1) {
    if (me !== null) {
      if (r[me] !== void 0) return r[me];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + me + "'");
    }
    let Mt = se;
    if (se === r.RED && ($e === r.FLOAT && (Mt = r.R32F), $e === r.HALF_FLOAT && (Mt = r.R16F), $e === r.UNSIGNED_BYTE && (Mt = r.R8)), se === r.RED_INTEGER && ($e === r.UNSIGNED_BYTE && (Mt = r.R8UI), $e === r.UNSIGNED_SHORT && (Mt = r.R16UI), $e === r.UNSIGNED_INT && (Mt = r.R32UI), $e === r.BYTE && (Mt = r.R8I), $e === r.SHORT && (Mt = r.R16I), $e === r.INT && (Mt = r.R32I)), se === r.RG && ($e === r.FLOAT && (Mt = r.RG32F), $e === r.HALF_FLOAT && (Mt = r.RG16F), $e === r.UNSIGNED_BYTE && (Mt = r.RG8)), se === r.RG_INTEGER && ($e === r.UNSIGNED_BYTE && (Mt = r.RG8UI), $e === r.UNSIGNED_SHORT && (Mt = r.RG16UI), $e === r.UNSIGNED_INT && (Mt = r.RG32UI), $e === r.BYTE && (Mt = r.RG8I), $e === r.SHORT && (Mt = r.RG16I), $e === r.INT && (Mt = r.RG32I)), se === r.RGB && $e === r.UNSIGNED_INT_5_9_9_9_REV && (Mt = r.RGB9_E5), se === r.RGBA) {
      const Gn = Bt ? Sw : ya.getTransfer(Vt);
      $e === r.FLOAT && (Mt = r.RGBA32F), $e === r.HALF_FLOAT && (Mt = r.RGBA16F), $e === r.UNSIGNED_BYTE && (Mt = Gn === Ho ? r.SRGB8_ALPHA8 : r.RGBA8), $e === r.UNSIGNED_SHORT_4_4_4_4 && (Mt = r.RGBA4), $e === r.UNSIGNED_SHORT_5_5_5_1 && (Mt = r.RGB5_A1);
    }
    return (Mt === r.R16F || Mt === r.R32F || Mt === r.RG16F || Mt === r.RG32F || Mt === r.RGBA16F || Mt === r.RGBA32F) && e.get("EXT_color_buffer_float"), Mt;
  }
  function F(me, se) {
    let $e;
    return me ? se === null || se === Pm || se === Bb ? $e = r.DEPTH24_STENCIL8 : se === ed ? $e = r.DEPTH32F_STENCIL8 : se === CB && ($e = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : se === null || se === Pm || se === Bb ? $e = r.DEPTH_COMPONENT24 : se === ed ? $e = r.DEPTH_COMPONENT32F : se === CB && ($e = r.DEPTH_COMPONENT16), $e;
  }
  function T(me, se) {
    return x(me) === !0 || me.isFramebufferTexture && me.minFilter !== Lu && me.minFilter !== Ks ? Math.log2(Math.max(se.width, se.height)) + 1 : me.mipmaps !== void 0 && me.mipmaps.length > 0 ? me.mipmaps.length : me.isCompressedTexture && Array.isArray(me.image) ? se.mipmaps.length : 1;
  }
  function P(me) {
    const se = me.target;
    se.removeEventListener("dispose", P), L(se), se.isVideoTexture && f.delete(se);
  }
  function D(me) {
    const se = me.target;
    se.removeEventListener("dispose", D), J(se);
  }
  function L(me) {
    const se = n.get(me);
    if (se.__webglInit === void 0) return;
    const $e = me.source, Vt = b.get($e);
    if (Vt) {
      const Bt = Vt[se.__cacheKey];
      Bt.usedTimes--, Bt.usedTimes === 0 && j(me), Object.keys(Vt).length === 0 && b.delete($e);
    }
    n.remove(me);
  }
  function j(me) {
    const se = n.get(me);
    r.deleteTexture(se.__webglTexture);
    const $e = me.source, Vt = b.get($e);
    delete Vt[se.__cacheKey], l.memory.textures--;
  }
  function J(me) {
    const se = n.get(me);
    if (me.depthTexture && me.depthTexture.dispose(), me.isWebGLCubeRenderTarget)
      for (let Vt = 0; Vt < 6; Vt++) {
        if (Array.isArray(se.__webglFramebuffer[Vt]))
          for (let Bt = 0; Bt < se.__webglFramebuffer[Vt].length; Bt++) r.deleteFramebuffer(se.__webglFramebuffer[Vt][Bt]);
        else
          r.deleteFramebuffer(se.__webglFramebuffer[Vt]);
        se.__webglDepthbuffer && r.deleteRenderbuffer(se.__webglDepthbuffer[Vt]);
      }
    else {
      if (Array.isArray(se.__webglFramebuffer))
        for (let Vt = 0; Vt < se.__webglFramebuffer.length; Vt++) r.deleteFramebuffer(se.__webglFramebuffer[Vt]);
      else
        r.deleteFramebuffer(se.__webglFramebuffer);
      if (se.__webglDepthbuffer && r.deleteRenderbuffer(se.__webglDepthbuffer), se.__webglMultisampledFramebuffer && r.deleteFramebuffer(se.__webglMultisampledFramebuffer), se.__webglColorRenderbuffer)
        for (let Vt = 0; Vt < se.__webglColorRenderbuffer.length; Vt++)
          se.__webglColorRenderbuffer[Vt] && r.deleteRenderbuffer(se.__webglColorRenderbuffer[Vt]);
      se.__webglDepthRenderbuffer && r.deleteRenderbuffer(se.__webglDepthRenderbuffer);
    }
    const $e = me.textures;
    for (let Vt = 0, Bt = $e.length; Vt < Bt; Vt++) {
      const Mt = n.get($e[Vt]);
      Mt.__webglTexture && (r.deleteTexture(Mt.__webglTexture), l.memory.textures--), n.remove($e[Vt]);
    }
    n.remove(me);
  }
  let O = 0;
  function ne() {
    O = 0;
  }
  function he() {
    const me = O;
    return me >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + me + " texture units while this GPU supports only " + i.maxTextures), O += 1, me;
  }
  function pe(me) {
    const se = [];
    return se.push(me.wrapS), se.push(me.wrapT), se.push(me.wrapR || 0), se.push(me.magFilter), se.push(me.minFilter), se.push(me.anisotropy), se.push(me.internalFormat), se.push(me.format), se.push(me.type), se.push(me.generateMipmaps), se.push(me.premultiplyAlpha), se.push(me.flipY), se.push(me.unpackAlignment), se.push(me.colorSpace), se.join();
  }
  function Ae(me, se) {
    const $e = n.get(me);
    if (me.isVideoTexture && bn(me), me.isRenderTargetTexture === !1 && me.version > 0 && $e.__version !== me.version) {
      const Vt = me.image;
      if (Vt === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Vt.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        nt($e, me, se);
        return;
      }
    }
    t.bindTexture(r.TEXTURE_2D, $e.__webglTexture, r.TEXTURE0 + se);
  }
  function ke(me, se) {
    const $e = n.get(me);
    if (me.version > 0 && $e.__version !== me.version) {
      nt($e, me, se);
      return;
    }
    t.bindTexture(r.TEXTURE_2D_ARRAY, $e.__webglTexture, r.TEXTURE0 + se);
  }
  function Re(me, se) {
    const $e = n.get(me);
    if (me.version > 0 && $e.__version !== me.version) {
      nt($e, me, se);
      return;
    }
    t.bindTexture(r.TEXTURE_3D, $e.__webglTexture, r.TEXTURE0 + se);
  }
  function Xe(me, se) {
    const $e = n.get(me);
    if (me.version > 0 && $e.__version !== me.version) {
      ze($e, me, se);
      return;
    }
    t.bindTexture(r.TEXTURE_CUBE_MAP, $e.__webglTexture, r.TEXTURE0 + se);
  }
  const re = {
    [yw]: r.REPEAT,
    [PC]: r.CLAMP_TO_EDGE,
    [bw]: r.MIRRORED_REPEAT
  }, Se = {
    [Lu]: r.NEAREST,
    [jX]: r.NEAREST_MIPMAP_NEAREST,
    [qG]: r.NEAREST_MIPMAP_LINEAR,
    [Ks]: r.LINEAR,
    [jZ]: r.LINEAR_MIPMAP_NEAREST,
    [ap]: r.LINEAR_MIPMAP_LINEAR
  }, Be = {
    [wK]: r.NEVER,
    [MK]: r.ALWAYS,
    [RK]: r.LESS,
    [lY]: r.LEQUAL,
    [xK]: r.EQUAL,
    [NK]: r.GEQUAL,
    [WK]: r.GREATER,
    [VK]: r.NOTEQUAL
  };
  function le(me, se) {
    if (se.type === ed && e.has("OES_texture_float_linear") === !1 && (se.magFilter === Ks || se.magFilter === jZ || se.magFilter === qG || se.magFilter === ap || se.minFilter === Ks || se.minFilter === jZ || se.minFilter === qG || se.minFilter === ap) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(me, r.TEXTURE_WRAP_S, re[se.wrapS]), r.texParameteri(me, r.TEXTURE_WRAP_T, re[se.wrapT]), (me === r.TEXTURE_3D || me === r.TEXTURE_2D_ARRAY) && r.texParameteri(me, r.TEXTURE_WRAP_R, re[se.wrapR]), r.texParameteri(me, r.TEXTURE_MAG_FILTER, Se[se.magFilter]), r.texParameteri(me, r.TEXTURE_MIN_FILTER, Se[se.minFilter]), se.compareFunction && (r.texParameteri(me, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(me, r.TEXTURE_COMPARE_FUNC, Be[se.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (se.magFilter === Lu || se.minFilter !== qG && se.minFilter !== ap || se.type === ed && e.has("OES_texture_float_linear") === !1) return;
      if (se.anisotropy > 1 || n.get(se).__currentAnisotropy) {
        const $e = e.get("EXT_texture_filter_anisotropic");
        r.texParameterf(me, $e.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(se.anisotropy, i.getMaxAnisotropy())), n.get(se).__currentAnisotropy = se.anisotropy;
      }
    }
  }
  function Ye(me, se) {
    let $e = !1;
    me.__webglInit === void 0 && (me.__webglInit = !0, se.addEventListener("dispose", P));
    const Vt = se.source;
    let Bt = b.get(Vt);
    Bt === void 0 && (Bt = {}, b.set(Vt, Bt));
    const Mt = pe(se);
    if (Mt !== me.__cacheKey) {
      Bt[Mt] === void 0 && (Bt[Mt] = {
        texture: r.createTexture(),
        usedTimes: 0
      }, l.memory.textures++, $e = !0), Bt[Mt].usedTimes++;
      const Gn = Bt[me.__cacheKey];
      Gn !== void 0 && (Bt[me.__cacheKey].usedTimes--, Gn.usedTimes === 0 && j(se)), me.__cacheKey = Mt, me.__webglTexture = Bt[Mt].texture;
    }
    return $e;
  }
  function nt(me, se, $e) {
    let Vt = r.TEXTURE_2D;
    (se.isDataArrayTexture || se.isCompressedArrayTexture) && (Vt = r.TEXTURE_2D_ARRAY), se.isData3DTexture && (Vt = r.TEXTURE_3D);
    const Bt = Ye(me, se), Mt = se.source;
    t.bindTexture(Vt, me.__webglTexture, r.TEXTURE0 + $e);
    const Gn = n.get(Mt);
    if (Mt.version !== Gn.__version || Bt === !0) {
      t.activeTexture(r.TEXTURE0 + $e);
      const jt = ya.getPrimaries(ya.workingColorSpace), an = se.colorSpace === _m ? null : ya.getPrimaries(se.colorSpace), jn = se.colorSpace === _m || jt === an ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, se.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, se.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, se.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, jn);
      let Ot = W(se.image, !1, i.maxTextureSize);
      Ot = en(se, Ot);
      const He = o.convert(se.format, se.colorSpace), vt = o.convert(se.type);
      let xt = Y(se.internalFormat, He, vt, se.colorSpace, se.isVideoTexture);
      le(Vt, se);
      let ht;
      const on = se.mipmaps, we = se.isVideoTexture !== !0, qe = Gn.__version === void 0 || Bt === !0, de = Mt.dataReady, it = T(se, Ot);
      if (se.isDepthTexture)
        xt = F(se.format === Sb, se.type), qe && (we ? t.texStorage2D(r.TEXTURE_2D, 1, xt, Ot.width, Ot.height) : t.texImage2D(r.TEXTURE_2D, 0, xt, Ot.width, Ot.height, 0, He, vt, null));
      else if (se.isDataTexture)
        if (on.length > 0) {
          we && qe && t.texStorage2D(r.TEXTURE_2D, it, xt, on[0].width, on[0].height);
          for (let je = 0, et = on.length; je < et; je++)
            ht = on[je], we ? de && t.texSubImage2D(r.TEXTURE_2D, je, 0, 0, ht.width, ht.height, He, vt, ht.data) : t.texImage2D(r.TEXTURE_2D, je, xt, ht.width, ht.height, 0, He, vt, ht.data);
          se.generateMipmaps = !1;
        } else
          we ? (qe && t.texStorage2D(r.TEXTURE_2D, it, xt, Ot.width, Ot.height), de && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ot.width, Ot.height, He, vt, Ot.data)) : t.texImage2D(r.TEXTURE_2D, 0, xt, Ot.width, Ot.height, 0, He, vt, Ot.data);
      else if (se.isCompressedTexture)
        if (se.isCompressedArrayTexture) {
          we && qe && t.texStorage3D(r.TEXTURE_2D_ARRAY, it, xt, on[0].width, on[0].height, Ot.depth);
          for (let je = 0, et = on.length; je < et; je++)
            if (ht = on[je], se.format !== cg)
              if (He !== null)
                if (we) {
                  if (de)
                    if (se.layerUpdates.size > 0) {
                      const Jt = jH(ht.width, ht.height, se.format, se.type);
                      for (const Kn of se.layerUpdates) {
                        const di = ht.data.subarray(
                          Kn * Jt / ht.data.BYTES_PER_ELEMENT,
                          (Kn + 1) * Jt / ht.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, je, 0, 0, Kn, ht.width, ht.height, 1, He, di, 0, 0);
                      }
                      se.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, je, 0, 0, 0, ht.width, ht.height, Ot.depth, He, ht.data, 0, 0);
                } else
                  t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, je, xt, ht.width, ht.height, Ot.depth, 0, ht.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              we ? de && t.texSubImage3D(r.TEXTURE_2D_ARRAY, je, 0, 0, 0, ht.width, ht.height, Ot.depth, He, vt, ht.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, je, xt, ht.width, ht.height, Ot.depth, 0, He, vt, ht.data);
        } else {
          we && qe && t.texStorage2D(r.TEXTURE_2D, it, xt, on[0].width, on[0].height);
          for (let je = 0, et = on.length; je < et; je++)
            ht = on[je], se.format !== cg ? He !== null ? we ? de && t.compressedTexSubImage2D(r.TEXTURE_2D, je, 0, 0, ht.width, ht.height, He, ht.data) : t.compressedTexImage2D(r.TEXTURE_2D, je, xt, ht.width, ht.height, 0, ht.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : we ? de && t.texSubImage2D(r.TEXTURE_2D, je, 0, 0, ht.width, ht.height, He, vt, ht.data) : t.texImage2D(r.TEXTURE_2D, je, xt, ht.width, ht.height, 0, He, vt, ht.data);
        }
      else if (se.isDataArrayTexture)
        if (we) {
          if (qe && t.texStorage3D(r.TEXTURE_2D_ARRAY, it, xt, Ot.width, Ot.height, Ot.depth), de)
            if (se.layerUpdates.size > 0) {
              const je = jH(Ot.width, Ot.height, se.format, se.type);
              for (const et of se.layerUpdates) {
                const Jt = Ot.data.subarray(
                  et * je / Ot.data.BYTES_PER_ELEMENT,
                  (et + 1) * je / Ot.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, et, Ot.width, Ot.height, 1, He, vt, Jt);
              }
              se.clearLayerUpdates();
            } else
              t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ot.width, Ot.height, Ot.depth, He, vt, Ot.data);
        } else
          t.texImage3D(r.TEXTURE_2D_ARRAY, 0, xt, Ot.width, Ot.height, Ot.depth, 0, He, vt, Ot.data);
      else if (se.isData3DTexture)
        we ? (qe && t.texStorage3D(r.TEXTURE_3D, it, xt, Ot.width, Ot.height, Ot.depth), de && t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, Ot.width, Ot.height, Ot.depth, He, vt, Ot.data)) : t.texImage3D(r.TEXTURE_3D, 0, xt, Ot.width, Ot.height, Ot.depth, 0, He, vt, Ot.data);
      else if (se.isFramebufferTexture) {
        if (qe)
          if (we)
            t.texStorage2D(r.TEXTURE_2D, it, xt, Ot.width, Ot.height);
          else {
            let je = Ot.width, et = Ot.height;
            for (let Jt = 0; Jt < it; Jt++)
              t.texImage2D(r.TEXTURE_2D, Jt, xt, je, et, 0, He, vt, null), je >>= 1, et >>= 1;
          }
      } else if (on.length > 0) {
        if (we && qe) {
          const je = hn(on[0]);
          t.texStorage2D(r.TEXTURE_2D, it, xt, je.width, je.height);
        }
        for (let je = 0, et = on.length; je < et; je++)
          ht = on[je], we ? de && t.texSubImage2D(r.TEXTURE_2D, je, 0, 0, He, vt, ht) : t.texImage2D(r.TEXTURE_2D, je, xt, He, vt, ht);
        se.generateMipmaps = !1;
      } else if (we) {
        if (qe) {
          const je = hn(Ot);
          t.texStorage2D(r.TEXTURE_2D, it, xt, je.width, je.height);
        }
        de && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, He, vt, Ot);
      } else
        t.texImage2D(r.TEXTURE_2D, 0, xt, He, vt, Ot);
      x(se) && N(Vt), Gn.__version = Mt.version, se.onUpdate && se.onUpdate(se);
    }
    me.__version = se.version;
  }
  function ze(me, se, $e) {
    if (se.image.length !== 6) return;
    const Vt = Ye(me, se), Bt = se.source;
    t.bindTexture(r.TEXTURE_CUBE_MAP, me.__webglTexture, r.TEXTURE0 + $e);
    const Mt = n.get(Bt);
    if (Bt.version !== Mt.__version || Vt === !0) {
      t.activeTexture(r.TEXTURE0 + $e);
      const Gn = ya.getPrimaries(ya.workingColorSpace), jt = se.colorSpace === _m ? null : ya.getPrimaries(se.colorSpace), an = se.colorSpace === _m || Gn === jt ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, se.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, se.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, se.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, an);
      const jn = se.isCompressedTexture || se.image[0].isCompressedTexture, Ot = se.image[0] && se.image[0].isDataTexture, He = [];
      for (let et = 0; et < 6; et++)
        !jn && !Ot ? He[et] = W(se.image[et], !0, i.maxCubemapSize) : He[et] = Ot ? se.image[et].image : se.image[et], He[et] = en(se, He[et]);
      const vt = He[0], xt = o.convert(se.format, se.colorSpace), ht = o.convert(se.type), on = Y(se.internalFormat, xt, ht, se.colorSpace), we = se.isVideoTexture !== !0, qe = Mt.__version === void 0 || Vt === !0, de = Bt.dataReady;
      let it = T(se, vt);
      le(r.TEXTURE_CUBE_MAP, se);
      let je;
      if (jn) {
        we && qe && t.texStorage2D(r.TEXTURE_CUBE_MAP, it, on, vt.width, vt.height);
        for (let et = 0; et < 6; et++) {
          je = He[et].mipmaps;
          for (let Jt = 0; Jt < je.length; Jt++) {
            const Kn = je[Jt];
            se.format !== cg ? xt !== null ? we ? de && t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, Jt, 0, 0, Kn.width, Kn.height, xt, Kn.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, Jt, on, Kn.width, Kn.height, 0, Kn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : we ? de && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, Jt, 0, 0, Kn.width, Kn.height, xt, ht, Kn.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, Jt, on, Kn.width, Kn.height, 0, xt, ht, Kn.data);
          }
        }
      } else {
        if (je = se.mipmaps, we && qe) {
          je.length > 0 && it++;
          const et = hn(He[0]);
          t.texStorage2D(r.TEXTURE_CUBE_MAP, it, on, et.width, et.height);
        }
        for (let et = 0; et < 6; et++)
          if (Ot) {
            we ? de && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, 0, 0, 0, He[et].width, He[et].height, xt, ht, He[et].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, 0, on, He[et].width, He[et].height, 0, xt, ht, He[et].data);
            for (let Jt = 0; Jt < je.length; Jt++) {
              const di = je[Jt].image[et].image;
              we ? de && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, Jt + 1, 0, 0, di.width, di.height, xt, ht, di.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, Jt + 1, on, di.width, di.height, 0, xt, ht, di.data);
            }
          } else {
            we ? de && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, 0, 0, 0, xt, ht, He[et]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, 0, on, xt, ht, He[et]);
            for (let Jt = 0; Jt < je.length; Jt++) {
              const Kn = je[Jt];
              we ? de && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, Jt + 1, 0, 0, xt, ht, Kn.image[et]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + et, Jt + 1, on, xt, ht, Kn.image[et]);
            }
          }
      }
      x(se) && N(r.TEXTURE_CUBE_MAP), Mt.__version = Bt.version, se.onUpdate && se.onUpdate(se);
    }
    me.__version = se.version;
  }
  function Je(me, se, $e, Vt, Bt, Mt) {
    const Gn = o.convert($e.format, $e.colorSpace), jt = o.convert($e.type), an = Y($e.internalFormat, Gn, jt, $e.colorSpace);
    if (!n.get(se).__hasExternalTextures) {
      const Ot = Math.max(1, se.width >> Mt), He = Math.max(1, se.height >> Mt);
      Bt === r.TEXTURE_3D || Bt === r.TEXTURE_2D_ARRAY ? t.texImage3D(Bt, Mt, an, Ot, He, se.depth, 0, Gn, jt, null) : t.texImage2D(Bt, Mt, an, Ot, He, 0, Gn, jt, null);
    }
    t.bindFramebuffer(r.FRAMEBUFFER, me), ft(se) ? u.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, Vt, Bt, n.get($e).__webglTexture, 0, $t(se)) : (Bt === r.TEXTURE_2D || Bt >= r.TEXTURE_CUBE_MAP_POSITIVE_X && Bt <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, Vt, Bt, n.get($e).__webglTexture, Mt), t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function wt(me, se, $e) {
    if (r.bindRenderbuffer(r.RENDERBUFFER, me), se.depthBuffer) {
      const Vt = se.depthTexture, Bt = Vt && Vt.isDepthTexture ? Vt.type : null, Mt = F(se.stencilBuffer, Bt), Gn = se.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, jt = $t(se);
      ft(se) ? u.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, jt, Mt, se.width, se.height) : $e ? r.renderbufferStorageMultisample(r.RENDERBUFFER, jt, Mt, se.width, se.height) : r.renderbufferStorage(r.RENDERBUFFER, Mt, se.width, se.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, Gn, r.RENDERBUFFER, me);
    } else {
      const Vt = se.textures;
      for (let Bt = 0; Bt < Vt.length; Bt++) {
        const Mt = Vt[Bt], Gn = o.convert(Mt.format, Mt.colorSpace), jt = o.convert(Mt.type), an = Y(Mt.internalFormat, Gn, jt, Mt.colorSpace), jn = $t(se);
        $e && ft(se) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, jn, an, se.width, se.height) : ft(se) ? u.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, jn, an, se.width, se.height) : r.renderbufferStorage(r.RENDERBUFFER, an, se.width, se.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function mt(me, se) {
    if (se && se.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(r.FRAMEBUFFER, me), !(se.depthTexture && se.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(se.depthTexture).__webglTexture || se.depthTexture.image.width !== se.width || se.depthTexture.image.height !== se.height) && (se.depthTexture.image.width = se.width, se.depthTexture.image.height = se.height, se.depthTexture.needsUpdate = !0), Ae(se.depthTexture, 0);
    const Vt = n.get(se.depthTexture).__webglTexture, Bt = $t(se);
    if (se.depthTexture.format === hb)
      ft(se) ? u.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Vt, 0, Bt) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Vt, 0);
    else if (se.depthTexture.format === Sb)
      ft(se) ? u.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Vt, 0, Bt) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Vt, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Dt(me) {
    const se = n.get(me), $e = me.isWebGLCubeRenderTarget === !0;
    if (me.depthTexture && !se.__autoAllocateDepthBuffer) {
      if ($e) throw new Error("target.depthTexture not supported in Cube render targets");
      mt(se.__webglFramebuffer, me);
    } else if ($e) {
      se.__webglDepthbuffer = [];
      for (let Vt = 0; Vt < 6; Vt++)
        t.bindFramebuffer(r.FRAMEBUFFER, se.__webglFramebuffer[Vt]), se.__webglDepthbuffer[Vt] = r.createRenderbuffer(), wt(se.__webglDepthbuffer[Vt], me, !1);
    } else
      t.bindFramebuffer(r.FRAMEBUFFER, se.__webglFramebuffer), se.__webglDepthbuffer = r.createRenderbuffer(), wt(se.__webglDepthbuffer, me, !1);
    t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function mn(me, se, $e) {
    const Vt = n.get(me);
    se !== void 0 && Je(Vt.__webglFramebuffer, me, me.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), $e !== void 0 && Dt(me);
  }
  function An(me) {
    const se = me.texture, $e = n.get(me), Vt = n.get(se);
    me.addEventListener("dispose", D);
    const Bt = me.textures, Mt = me.isWebGLCubeRenderTarget === !0, Gn = Bt.length > 1;
    if (Gn || (Vt.__webglTexture === void 0 && (Vt.__webglTexture = r.createTexture()), Vt.__version = se.version, l.memory.textures++), Mt) {
      $e.__webglFramebuffer = [];
      for (let jt = 0; jt < 6; jt++)
        if (se.mipmaps && se.mipmaps.length > 0) {
          $e.__webglFramebuffer[jt] = [];
          for (let an = 0; an < se.mipmaps.length; an++)
            $e.__webglFramebuffer[jt][an] = r.createFramebuffer();
        } else
          $e.__webglFramebuffer[jt] = r.createFramebuffer();
    } else {
      if (se.mipmaps && se.mipmaps.length > 0) {
        $e.__webglFramebuffer = [];
        for (let jt = 0; jt < se.mipmaps.length; jt++)
          $e.__webglFramebuffer[jt] = r.createFramebuffer();
      } else
        $e.__webglFramebuffer = r.createFramebuffer();
      if (Gn)
        for (let jt = 0, an = Bt.length; jt < an; jt++) {
          const jn = n.get(Bt[jt]);
          jn.__webglTexture === void 0 && (jn.__webglTexture = r.createTexture(), l.memory.textures++);
        }
      if (me.samples > 0 && ft(me) === !1) {
        $e.__webglMultisampledFramebuffer = r.createFramebuffer(), $e.__webglColorRenderbuffer = [], t.bindFramebuffer(r.FRAMEBUFFER, $e.__webglMultisampledFramebuffer);
        for (let jt = 0; jt < Bt.length; jt++) {
          const an = Bt[jt];
          $e.__webglColorRenderbuffer[jt] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, $e.__webglColorRenderbuffer[jt]);
          const jn = o.convert(an.format, an.colorSpace), Ot = o.convert(an.type), He = Y(an.internalFormat, jn, Ot, an.colorSpace, me.isXRRenderTarget === !0), vt = $t(me);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, vt, He, me.width, me.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + jt, r.RENDERBUFFER, $e.__webglColorRenderbuffer[jt]);
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null), me.depthBuffer && ($e.__webglDepthRenderbuffer = r.createRenderbuffer(), wt($e.__webglDepthRenderbuffer, me, !0)), t.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (Mt) {
      t.bindTexture(r.TEXTURE_CUBE_MAP, Vt.__webglTexture), le(r.TEXTURE_CUBE_MAP, se);
      for (let jt = 0; jt < 6; jt++)
        if (se.mipmaps && se.mipmaps.length > 0)
          for (let an = 0; an < se.mipmaps.length; an++)
            Je($e.__webglFramebuffer[jt][an], me, se, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + jt, an);
        else
          Je($e.__webglFramebuffer[jt], me, se, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + jt, 0);
      x(se) && N(r.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Gn) {
      for (let jt = 0, an = Bt.length; jt < an; jt++) {
        const jn = Bt[jt], Ot = n.get(jn);
        t.bindTexture(r.TEXTURE_2D, Ot.__webglTexture), le(r.TEXTURE_2D, jn), Je($e.__webglFramebuffer, me, jn, r.COLOR_ATTACHMENT0 + jt, r.TEXTURE_2D, 0), x(jn) && N(r.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let jt = r.TEXTURE_2D;
      if ((me.isWebGL3DRenderTarget || me.isWebGLArrayRenderTarget) && (jt = me.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), t.bindTexture(jt, Vt.__webglTexture), le(jt, se), se.mipmaps && se.mipmaps.length > 0)
        for (let an = 0; an < se.mipmaps.length; an++)
          Je($e.__webglFramebuffer[an], me, se, r.COLOR_ATTACHMENT0, jt, an);
      else
        Je($e.__webglFramebuffer, me, se, r.COLOR_ATTACHMENT0, jt, 0);
      x(se) && N(jt), t.unbindTexture();
    }
    me.depthBuffer && Dt(me);
  }
  function Hn(me) {
    const se = me.textures;
    for (let $e = 0, Vt = se.length; $e < Vt; $e++) {
      const Bt = se[$e];
      if (x(Bt)) {
        const Mt = me.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D, Gn = n.get(Bt).__webglTexture;
        t.bindTexture(Mt, Gn), N(Mt), t.unbindTexture();
      }
    }
  }
  const ge = [], Wt = [];
  function Nt(me) {
    if (me.samples > 0) {
      if (ft(me) === !1) {
        const se = me.textures, $e = me.width, Vt = me.height;
        let Bt = r.COLOR_BUFFER_BIT;
        const Mt = me.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Gn = n.get(me), jt = se.length > 1;
        if (jt)
          for (let an = 0; an < se.length; an++)
            t.bindFramebuffer(r.FRAMEBUFFER, Gn.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + an, r.RENDERBUFFER, null), t.bindFramebuffer(r.FRAMEBUFFER, Gn.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + an, r.TEXTURE_2D, null, 0);
        t.bindFramebuffer(r.READ_FRAMEBUFFER, Gn.__webglMultisampledFramebuffer), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Gn.__webglFramebuffer);
        for (let an = 0; an < se.length; an++) {
          if (me.resolveDepthBuffer && (me.depthBuffer && (Bt |= r.DEPTH_BUFFER_BIT), me.stencilBuffer && me.resolveStencilBuffer && (Bt |= r.STENCIL_BUFFER_BIT)), jt) {
            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Gn.__webglColorRenderbuffer[an]);
            const jn = n.get(se[an]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, jn, 0);
          }
          r.blitFramebuffer(0, 0, $e, Vt, 0, 0, $e, Vt, Bt, r.NEAREST), I === !0 && (ge.length = 0, Wt.length = 0, ge.push(r.COLOR_ATTACHMENT0 + an), me.depthBuffer && me.resolveDepthBuffer === !1 && (ge.push(Mt), Wt.push(Mt), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Wt)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, ge));
        }
        if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), jt)
          for (let an = 0; an < se.length; an++) {
            t.bindFramebuffer(r.FRAMEBUFFER, Gn.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + an, r.RENDERBUFFER, Gn.__webglColorRenderbuffer[an]);
            const jn = n.get(se[an]).__webglTexture;
            t.bindFramebuffer(r.FRAMEBUFFER, Gn.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + an, r.TEXTURE_2D, jn, 0);
          }
        t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Gn.__webglMultisampledFramebuffer);
      } else if (me.depthBuffer && me.resolveDepthBuffer === !1 && I) {
        const se = me.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [se]);
      }
    }
  }
  function $t(me) {
    return Math.min(i.maxSamples, me.samples);
  }
  function ft(me) {
    const se = n.get(me);
    return me.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && se.__useRenderToTexture !== !1;
  }
  function bn(me) {
    const se = l.render.frame;
    f.get(me) !== se && (f.set(me, se), me.update());
  }
  function en(me, se) {
    const $e = me.colorSpace, Vt = me.format, Bt = me.type;
    return me.isCompressedTexture === !0 || me.isVideoTexture === !0 || $e !== $m && $e !== _m && (ya.getTransfer($e) === Ho ? (Vt !== cg || Bt !== nf) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", $e)), se;
  }
  function hn(me) {
    return typeof HTMLImageElement < "u" && me instanceof HTMLImageElement ? (C.width = me.naturalWidth || me.width, C.height = me.naturalHeight || me.height) : typeof VideoFrame < "u" && me instanceof VideoFrame ? (C.width = me.displayWidth, C.height = me.displayHeight) : (C.width = me.width, C.height = me.height), C;
  }
  this.allocateTextureUnit = he, this.resetTextureUnits = ne, this.setTexture2D = Ae, this.setTexture2DArray = ke, this.setTexture3D = Re, this.setTextureCube = Xe, this.rebindTextures = mn, this.setupRenderTarget = An, this.updateRenderTargetMipmap = Hn, this.updateMultisampleRenderTarget = Nt, this.setupDepthRenderbuffer = Dt, this.setupFrameBufferTexture = Je, this.useMultisampledRTT = ft;
}
function JK(r, e) {
  function t(n, i = _m) {
    let o;
    const l = ya.getTransfer(i);
    if (n === nf) return r.UNSIGNED_BYTE;
    if (n === HW) return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === XW) return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === eY) return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === qX) return r.BYTE;
    if (n === $X) return r.SHORT;
    if (n === CB) return r.UNSIGNED_SHORT;
    if (n === MW) return r.INT;
    if (n === Pm) return r.UNSIGNED_INT;
    if (n === ed) return r.FLOAT;
    if (n === Vb) return r.HALF_FLOAT;
    if (n === tY) return r.ALPHA;
    if (n === nY) return r.RGB;
    if (n === cg) return r.RGBA;
    if (n === iY) return r.LUMINANCE;
    if (n === rY) return r.LUMINANCE_ALPHA;
    if (n === hb) return r.DEPTH_COMPONENT;
    if (n === Sb) return r.DEPTH_STENCIL;
    if (n === YW) return r.RED;
    if (n === jw) return r.RED_INTEGER;
    if (n === aY) return r.RG;
    if (n === FW) return r.RG_INTEGER;
    if (n === EW) return r.RGBA_INTEGER;
    if (n === qZ || n === $Z || n === ew || n === tw)
      if (l === Ho)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (n === qZ) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === $Z) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === ew) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === tw) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (n === qZ) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === $Z) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === ew) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === tw) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === w2 || n === R2 || n === x2 || n === W2)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (n === w2) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === R2) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === x2) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === W2) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === V2 || n === N2 || n === M2)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (n === V2 || n === N2) return l === Ho ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (n === M2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === H2 || n === X2 || n === Y2 || n === F2 || n === E2 || n === T2 || n === _2 || n === z2 || n === K2 || n === L2 || n === k2 || n === D2 || n === U2 || n === O2)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (n === H2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === X2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === Y2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === F2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === E2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === T2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === _2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === z2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === K2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === L2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === k2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === D2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === U2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === O2) return l === Ho ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === nw || n === P2 || n === J2)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (n === nw) return l === Ho ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === P2) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === J2) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === oY || n === Q2 || n === j2 || n === q2)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (n === nw) return o.COMPRESSED_RED_RGTC1_EXT;
        if (n === Q2) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === j2) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === q2) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === Bb ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: t };
}
class QK extends hl {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class tB extends qr {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const b6 = { type: "move" };
class kM {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new tB(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new tB(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new fe(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new fe()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new tB(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new fe(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new fe()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let i = null, o = null, l = null;
    const u = this._targetRay, I = this._grip, C = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (C && e.hand) {
        l = !0;
        for (const W of e.hand.values()) {
          const x = t.getJointPose(W, n), N = this._getHandJoint(C, W);
          x !== null && (N.matrix.fromArray(x.transform.matrix), N.matrix.decompose(N.position, N.rotation, N.scale), N.matrixWorldNeedsUpdate = !0, N.jointRadius = x.radius), N.visible = x !== null;
        }
        const f = C.joints["index-finger-tip"], v = C.joints["thumb-tip"], b = f.position.distanceTo(v.position), S = 0.02, R = 5e-3;
        C.inputState.pinching && b > S + R ? (C.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !C.inputState.pinching && b <= S - R && (C.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        I !== null && e.gripSpace && (o = t.getPose(e.gripSpace, n), o !== null && (I.matrix.fromArray(o.transform.matrix), I.matrix.decompose(I.position, I.rotation, I.scale), I.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (I.hasLinearVelocity = !0, I.linearVelocity.copy(o.linearVelocity)) : I.hasLinearVelocity = !1, o.angularVelocity ? (I.hasAngularVelocity = !0, I.angularVelocity.copy(o.angularVelocity)) : I.hasAngularVelocity = !1));
      u !== null && (i = t.getPose(e.targetRaySpace, n), i === null && o !== null && (i = o), i !== null && (u.matrix.fromArray(i.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(i.linearVelocity)) : u.hasLinearVelocity = !1, i.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(i.angularVelocity)) : u.hasAngularVelocity = !1, this.dispatchEvent(b6)));
    }
    return u !== null && (u.visible = i !== null), I !== null && (I.visible = o !== null), C !== null && (C.visible = l !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new tB();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
const G6 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, B6 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class S6 {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, n) {
    if (this.texture === null) {
      const i = new ks(), o = e.properties.get(i);
      o.__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, n = new rf({
        vertexShader: G6,
        fragmentShader: B6,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: t.z },
          depthHeight: { value: t.w }
        }
      });
      this.mesh = new kl(new WB(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class Z6 extends eA {
  constructor(e, t) {
    super();
    const n = this;
    let i = null, o = 1, l = null, u = "local-floor", I = 1, C = null, f = null, v = null, b = null, S = null, R = null;
    const W = new S6(), x = t.getContextAttributes();
    let N = null, Y = null;
    const F = [], T = [], P = new Lt();
    let D = null;
    const L = new hl();
    L.layers.enable(1), L.viewport = new Ha();
    const j = new hl();
    j.layers.enable(2), j.viewport = new Ha();
    const J = [L, j], O = new QK();
    O.layers.enable(1), O.layers.enable(2);
    let ne = null, he = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(ze) {
      let Je = F[ze];
      return Je === void 0 && (Je = new kM(), F[ze] = Je), Je.getTargetRaySpace();
    }, this.getControllerGrip = function(ze) {
      let Je = F[ze];
      return Je === void 0 && (Je = new kM(), F[ze] = Je), Je.getGripSpace();
    }, this.getHand = function(ze) {
      let Je = F[ze];
      return Je === void 0 && (Je = new kM(), F[ze] = Je), Je.getHandSpace();
    };
    function pe(ze) {
      const Je = T.indexOf(ze.inputSource);
      if (Je === -1)
        return;
      const wt = F[Je];
      wt !== void 0 && (wt.update(ze.inputSource, ze.frame, C || l), wt.dispatchEvent({ type: ze.type, data: ze.inputSource }));
    }
    function Ae() {
      i.removeEventListener("select", pe), i.removeEventListener("selectstart", pe), i.removeEventListener("selectend", pe), i.removeEventListener("squeeze", pe), i.removeEventListener("squeezestart", pe), i.removeEventListener("squeezeend", pe), i.removeEventListener("end", Ae), i.removeEventListener("inputsourceschange", ke);
      for (let ze = 0; ze < F.length; ze++) {
        const Je = T[ze];
        Je !== null && (T[ze] = null, F[ze].disconnect(Je));
      }
      ne = null, he = null, W.reset(), e.setRenderTarget(N), S = null, b = null, v = null, i = null, Y = null, nt.stop(), n.isPresenting = !1, e.setPixelRatio(D), e.setSize(P.width, P.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(ze) {
      o = ze, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(ze) {
      u = ze, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return C || l;
    }, this.setReferenceSpace = function(ze) {
      C = ze;
    }, this.getBaseLayer = function() {
      return b !== null ? b : S;
    }, this.getBinding = function() {
      return v;
    }, this.getFrame = function() {
      return R;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(ze) {
      if (i = ze, i !== null) {
        if (N = e.getRenderTarget(), i.addEventListener("select", pe), i.addEventListener("selectstart", pe), i.addEventListener("selectend", pe), i.addEventListener("squeeze", pe), i.addEventListener("squeezestart", pe), i.addEventListener("squeezeend", pe), i.addEventListener("end", Ae), i.addEventListener("inputsourceschange", ke), x.xrCompatible !== !0 && await t.makeXRCompatible(), D = e.getPixelRatio(), e.getSize(P), i.renderState.layers === void 0) {
          const Je = {
            antialias: x.antialias,
            alpha: !0,
            depth: x.depth,
            stencil: x.stencil,
            framebufferScaleFactor: o
          };
          S = new XRWebGLLayer(i, t, Je), i.updateRenderState({ baseLayer: S }), e.setPixelRatio(1), e.setSize(S.framebufferWidth, S.framebufferHeight, !1), Y = new QC(
            S.framebufferWidth,
            S.framebufferHeight,
            {
              format: cg,
              type: nf,
              colorSpace: e.outputColorSpace,
              stencilBuffer: x.stencil
            }
          );
        } else {
          let Je = null, wt = null, mt = null;
          x.depth && (mt = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, Je = x.stencil ? Sb : hb, wt = x.stencil ? Bb : Pm);
          const Dt = {
            colorFormat: t.RGBA8,
            depthFormat: mt,
            scaleFactor: o
          };
          v = new XRWebGLBinding(i, t), b = v.createProjectionLayer(Dt), i.updateRenderState({ layers: [b] }), e.setPixelRatio(1), e.setSize(b.textureWidth, b.textureHeight, !1), Y = new QC(
            b.textureWidth,
            b.textureHeight,
            {
              format: cg,
              type: nf,
              depthTexture: new KW(b.textureWidth, b.textureHeight, wt, void 0, void 0, void 0, void 0, void 0, void 0, Je),
              stencilBuffer: x.stencil,
              colorSpace: e.outputColorSpace,
              samples: x.antialias ? 4 : 0,
              resolveDepthBuffer: b.ignoreDepthValues === !1
            }
          );
        }
        Y.isXRRenderTarget = !0, this.setFoveation(I), C = null, l = await i.requestReferenceSpace(u), nt.setContext(i), nt.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return W.getDepthTexture();
    };
    function ke(ze) {
      for (let Je = 0; Je < ze.removed.length; Je++) {
        const wt = ze.removed[Je], mt = T.indexOf(wt);
        mt >= 0 && (T[mt] = null, F[mt].disconnect(wt));
      }
      for (let Je = 0; Je < ze.added.length; Je++) {
        const wt = ze.added[Je];
        let mt = T.indexOf(wt);
        if (mt === -1) {
          for (let mn = 0; mn < F.length; mn++)
            if (mn >= T.length) {
              T.push(wt), mt = mn;
              break;
            } else if (T[mn] === null) {
              T[mn] = wt, mt = mn;
              break;
            }
          if (mt === -1) break;
        }
        const Dt = F[mt];
        Dt && Dt.connect(wt);
      }
    }
    const Re = new fe(), Xe = new fe();
    function re(ze, Je, wt) {
      Re.setFromMatrixPosition(Je.matrixWorld), Xe.setFromMatrixPosition(wt.matrixWorld);
      const mt = Re.distanceTo(Xe), Dt = Je.projectionMatrix.elements, mn = wt.projectionMatrix.elements, An = Dt[14] / (Dt[10] - 1), Hn = Dt[14] / (Dt[10] + 1), ge = (Dt[9] + 1) / Dt[5], Wt = (Dt[9] - 1) / Dt[5], Nt = (Dt[8] - 1) / Dt[0], $t = (mn[8] + 1) / mn[0], ft = An * Nt, bn = An * $t, en = mt / (-Nt + $t), hn = en * -Nt;
      Je.matrixWorld.decompose(ze.position, ze.quaternion, ze.scale), ze.translateX(hn), ze.translateZ(en), ze.matrixWorld.compose(ze.position, ze.quaternion, ze.scale), ze.matrixWorldInverse.copy(ze.matrixWorld).invert();
      const me = An + en, se = Hn + en, $e = ft - hn, Vt = bn + (mt - hn), Bt = ge * Hn / se * me, Mt = Wt * Hn / se * me;
      ze.projectionMatrix.makePerspective($e, Vt, Bt, Mt, me, se), ze.projectionMatrixInverse.copy(ze.projectionMatrix).invert();
    }
    function Se(ze, Je) {
      Je === null ? ze.matrixWorld.copy(ze.matrix) : ze.matrixWorld.multiplyMatrices(Je.matrixWorld, ze.matrix), ze.matrixWorldInverse.copy(ze.matrixWorld).invert();
    }
    this.updateCamera = function(ze) {
      if (i === null) return;
      W.texture !== null && (ze.near = W.depthNear, ze.far = W.depthFar), O.near = j.near = L.near = ze.near, O.far = j.far = L.far = ze.far, (ne !== O.near || he !== O.far) && (i.updateRenderState({
        depthNear: O.near,
        depthFar: O.far
      }), ne = O.near, he = O.far, L.near = ne, L.far = he, j.near = ne, j.far = he, L.updateProjectionMatrix(), j.updateProjectionMatrix(), ze.updateProjectionMatrix());
      const Je = ze.parent, wt = O.cameras;
      Se(O, Je);
      for (let mt = 0; mt < wt.length; mt++)
        Se(wt[mt], Je);
      wt.length === 2 ? re(O, L, j) : O.projectionMatrix.copy(L.projectionMatrix), Be(ze, O, Je);
    };
    function Be(ze, Je, wt) {
      wt === null ? ze.matrix.copy(Je.matrixWorld) : (ze.matrix.copy(wt.matrixWorld), ze.matrix.invert(), ze.matrix.multiply(Je.matrixWorld)), ze.matrix.decompose(ze.position, ze.quaternion, ze.scale), ze.updateMatrixWorld(!0), ze.projectionMatrix.copy(Je.projectionMatrix), ze.projectionMatrixInverse.copy(Je.projectionMatrixInverse), ze.isPerspectiveCamera && (ze.fov = hB * 2 * Math.atan(1 / ze.projectionMatrix.elements[5]), ze.zoom = 1);
    }
    this.getCamera = function() {
      return O;
    }, this.getFoveation = function() {
      if (!(b === null && S === null))
        return I;
    }, this.setFoveation = function(ze) {
      I = ze, b !== null && (b.fixedFoveation = ze), S !== null && S.fixedFoveation !== void 0 && (S.fixedFoveation = ze);
    }, this.hasDepthSensing = function() {
      return W.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return W.getMesh(O);
    };
    let le = null;
    function Ye(ze, Je) {
      if (f = Je.getViewerPose(C || l), R = Je, f !== null) {
        const wt = f.views;
        S !== null && (e.setRenderTargetFramebuffer(Y, S.framebuffer), e.setRenderTarget(Y));
        let mt = !1;
        wt.length !== O.cameras.length && (O.cameras.length = 0, mt = !0);
        for (let mn = 0; mn < wt.length; mn++) {
          const An = wt[mn];
          let Hn = null;
          if (S !== null)
            Hn = S.getViewport(An);
          else {
            const Wt = v.getViewSubImage(b, An);
            Hn = Wt.viewport, mn === 0 && (e.setRenderTargetTextures(
              Y,
              Wt.colorTexture,
              b.ignoreDepthValues ? void 0 : Wt.depthStencilTexture
            ), e.setRenderTarget(Y));
          }
          let ge = J[mn];
          ge === void 0 && (ge = new hl(), ge.layers.enable(mn), ge.viewport = new Ha(), J[mn] = ge), ge.matrix.fromArray(An.transform.matrix), ge.matrix.decompose(ge.position, ge.quaternion, ge.scale), ge.projectionMatrix.fromArray(An.projectionMatrix), ge.projectionMatrixInverse.copy(ge.projectionMatrix).invert(), ge.viewport.set(Hn.x, Hn.y, Hn.width, Hn.height), mn === 0 && (O.matrix.copy(ge.matrix), O.matrix.decompose(O.position, O.quaternion, O.scale)), mt === !0 && O.cameras.push(ge);
        }
        const Dt = i.enabledFeatures;
        if (Dt && Dt.includes("depth-sensing")) {
          const mn = v.getDepthInformation(wt[0]);
          mn && mn.isValid && mn.texture && W.init(e, mn, i.renderState);
        }
      }
      for (let wt = 0; wt < F.length; wt++) {
        const mt = T[wt], Dt = F[wt];
        mt !== null && Dt !== void 0 && Dt.update(mt, Je, C || l);
      }
      le && le(ze, Je), Je.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: Je }), R = null;
    }
    const nt = new kK();
    nt.setAnimationLoop(Ye), this.setAnimationLoop = function(ze) {
      le = ze;
    }, this.dispose = function() {
    };
  }
}
const Ky = /* @__PURE__ */ new uI(), w6 = /* @__PURE__ */ new _i();
function R6(r, e) {
  function t(x, N) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), N.value.copy(x.matrix);
  }
  function n(x, N) {
    N.color.getRGB(x.fogColor.value, _K(r)), N.isFog ? (x.fogNear.value = N.near, x.fogFar.value = N.far) : N.isFogExp2 && (x.fogDensity.value = N.density);
  }
  function i(x, N, Y, F, T) {
    N.isMeshBasicMaterial || N.isMeshLambertMaterial ? o(x, N) : N.isMeshToonMaterial ? (o(x, N), v(x, N)) : N.isMeshPhongMaterial ? (o(x, N), f(x, N)) : N.isMeshStandardMaterial ? (o(x, N), b(x, N), N.isMeshPhysicalMaterial && S(x, N, T)) : N.isMeshMatcapMaterial ? (o(x, N), R(x, N)) : N.isMeshDepthMaterial ? o(x, N) : N.isMeshDistanceMaterial ? (o(x, N), W(x, N)) : N.isMeshNormalMaterial ? o(x, N) : N.isLineBasicMaterial ? (l(x, N), N.isLineDashedMaterial && u(x, N)) : N.isPointsMaterial ? I(x, N, Y, F) : N.isSpriteMaterial ? C(x, N) : N.isShadowMaterial ? (x.color.value.copy(N.color), x.opacity.value = N.opacity) : N.isShaderMaterial && (N.uniformsNeedUpdate = !1);
  }
  function o(x, N) {
    x.opacity.value = N.opacity, N.color && x.diffuse.value.copy(N.color), N.emissive && x.emissive.value.copy(N.emissive).multiplyScalar(N.emissiveIntensity), N.map && (x.map.value = N.map, t(N.map, x.mapTransform)), N.alphaMap && (x.alphaMap.value = N.alphaMap, t(N.alphaMap, x.alphaMapTransform)), N.bumpMap && (x.bumpMap.value = N.bumpMap, t(N.bumpMap, x.bumpMapTransform), x.bumpScale.value = N.bumpScale, N.side === td && (x.bumpScale.value *= -1)), N.normalMap && (x.normalMap.value = N.normalMap, t(N.normalMap, x.normalMapTransform), x.normalScale.value.copy(N.normalScale), N.side === td && x.normalScale.value.negate()), N.displacementMap && (x.displacementMap.value = N.displacementMap, t(N.displacementMap, x.displacementMapTransform), x.displacementScale.value = N.displacementScale, x.displacementBias.value = N.displacementBias), N.emissiveMap && (x.emissiveMap.value = N.emissiveMap, t(N.emissiveMap, x.emissiveMapTransform)), N.specularMap && (x.specularMap.value = N.specularMap, t(N.specularMap, x.specularMapTransform)), N.alphaTest > 0 && (x.alphaTest.value = N.alphaTest);
    const Y = e.get(N), F = Y.envMap, T = Y.envMapRotation;
    F && (x.envMap.value = F, Ky.copy(T), Ky.x *= -1, Ky.y *= -1, Ky.z *= -1, F.isCubeTexture && F.isRenderTargetTexture === !1 && (Ky.y *= -1, Ky.z *= -1), x.envMapRotation.value.setFromMatrix4(w6.makeRotationFromEuler(Ky)), x.flipEnvMap.value = F.isCubeTexture && F.isRenderTargetTexture === !1 ? -1 : 1, x.reflectivity.value = N.reflectivity, x.ior.value = N.ior, x.refractionRatio.value = N.refractionRatio), N.lightMap && (x.lightMap.value = N.lightMap, x.lightMapIntensity.value = N.lightMapIntensity, t(N.lightMap, x.lightMapTransform)), N.aoMap && (x.aoMap.value = N.aoMap, x.aoMapIntensity.value = N.aoMapIntensity, t(N.aoMap, x.aoMapTransform));
  }
  function l(x, N) {
    x.diffuse.value.copy(N.color), x.opacity.value = N.opacity, N.map && (x.map.value = N.map, t(N.map, x.mapTransform));
  }
  function u(x, N) {
    x.dashSize.value = N.dashSize, x.totalSize.value = N.dashSize + N.gapSize, x.scale.value = N.scale;
  }
  function I(x, N, Y, F) {
    x.diffuse.value.copy(N.color), x.opacity.value = N.opacity, x.size.value = N.size * Y, x.scale.value = F * 0.5, N.map && (x.map.value = N.map, t(N.map, x.uvTransform)), N.alphaMap && (x.alphaMap.value = N.alphaMap, t(N.alphaMap, x.alphaMapTransform)), N.alphaTest > 0 && (x.alphaTest.value = N.alphaTest);
  }
  function C(x, N) {
    x.diffuse.value.copy(N.color), x.opacity.value = N.opacity, x.rotation.value = N.rotation, N.map && (x.map.value = N.map, t(N.map, x.mapTransform)), N.alphaMap && (x.alphaMap.value = N.alphaMap, t(N.alphaMap, x.alphaMapTransform)), N.alphaTest > 0 && (x.alphaTest.value = N.alphaTest);
  }
  function f(x, N) {
    x.specular.value.copy(N.specular), x.shininess.value = Math.max(N.shininess, 1e-4);
  }
  function v(x, N) {
    N.gradientMap && (x.gradientMap.value = N.gradientMap);
  }
  function b(x, N) {
    x.metalness.value = N.metalness, N.metalnessMap && (x.metalnessMap.value = N.metalnessMap, t(N.metalnessMap, x.metalnessMapTransform)), x.roughness.value = N.roughness, N.roughnessMap && (x.roughnessMap.value = N.roughnessMap, t(N.roughnessMap, x.roughnessMapTransform)), N.envMap && (x.envMapIntensity.value = N.envMapIntensity);
  }
  function S(x, N, Y) {
    x.ior.value = N.ior, N.sheen > 0 && (x.sheenColor.value.copy(N.sheenColor).multiplyScalar(N.sheen), x.sheenRoughness.value = N.sheenRoughness, N.sheenColorMap && (x.sheenColorMap.value = N.sheenColorMap, t(N.sheenColorMap, x.sheenColorMapTransform)), N.sheenRoughnessMap && (x.sheenRoughnessMap.value = N.sheenRoughnessMap, t(N.sheenRoughnessMap, x.sheenRoughnessMapTransform))), N.clearcoat > 0 && (x.clearcoat.value = N.clearcoat, x.clearcoatRoughness.value = N.clearcoatRoughness, N.clearcoatMap && (x.clearcoatMap.value = N.clearcoatMap, t(N.clearcoatMap, x.clearcoatMapTransform)), N.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = N.clearcoatRoughnessMap, t(N.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)), N.clearcoatNormalMap && (x.clearcoatNormalMap.value = N.clearcoatNormalMap, t(N.clearcoatNormalMap, x.clearcoatNormalMapTransform), x.clearcoatNormalScale.value.copy(N.clearcoatNormalScale), N.side === td && x.clearcoatNormalScale.value.negate())), N.dispersion > 0 && (x.dispersion.value = N.dispersion), N.iridescence > 0 && (x.iridescence.value = N.iridescence, x.iridescenceIOR.value = N.iridescenceIOR, x.iridescenceThicknessMinimum.value = N.iridescenceThicknessRange[0], x.iridescenceThicknessMaximum.value = N.iridescenceThicknessRange[1], N.iridescenceMap && (x.iridescenceMap.value = N.iridescenceMap, t(N.iridescenceMap, x.iridescenceMapTransform)), N.iridescenceThicknessMap && (x.iridescenceThicknessMap.value = N.iridescenceThicknessMap, t(N.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))), N.transmission > 0 && (x.transmission.value = N.transmission, x.transmissionSamplerMap.value = Y.texture, x.transmissionSamplerSize.value.set(Y.width, Y.height), N.transmissionMap && (x.transmissionMap.value = N.transmissionMap, t(N.transmissionMap, x.transmissionMapTransform)), x.thickness.value = N.thickness, N.thicknessMap && (x.thicknessMap.value = N.thicknessMap, t(N.thicknessMap, x.thicknessMapTransform)), x.attenuationDistance.value = N.attenuationDistance, x.attenuationColor.value.copy(N.attenuationColor)), N.anisotropy > 0 && (x.anisotropyVector.value.set(N.anisotropy * Math.cos(N.anisotropyRotation), N.anisotropy * Math.sin(N.anisotropyRotation)), N.anisotropyMap && (x.anisotropyMap.value = N.anisotropyMap, t(N.anisotropyMap, x.anisotropyMapTransform))), x.specularIntensity.value = N.specularIntensity, x.specularColor.value.copy(N.specularColor), N.specularColorMap && (x.specularColorMap.value = N.specularColorMap, t(N.specularColorMap, x.specularColorMapTransform)), N.specularIntensityMap && (x.specularIntensityMap.value = N.specularIntensityMap, t(N.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function R(x, N) {
    N.matcap && (x.matcap.value = N.matcap);
  }
  function W(x, N) {
    const Y = e.get(N).light;
    x.referencePosition.value.setFromMatrixPosition(Y.matrixWorld), x.nearDistance.value = Y.shadow.camera.near, x.farDistance.value = Y.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i
  };
}
function x6(r, e, t, n) {
  let i = {}, o = {}, l = [];
  const u = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function I(Y, F) {
    const T = F.program;
    n.uniformBlockBinding(Y, T);
  }
  function C(Y, F) {
    let T = i[Y.id];
    T === void 0 && (R(Y), T = f(Y), i[Y.id] = T, Y.addEventListener("dispose", x));
    const P = F.program;
    n.updateUBOMapping(Y, P);
    const D = e.render.frame;
    o[Y.id] !== D && (b(Y), o[Y.id] = D);
  }
  function f(Y) {
    const F = v();
    Y.__bindingPointIndex = F;
    const T = r.createBuffer(), P = Y.__size, D = Y.usage;
    return r.bindBuffer(r.UNIFORM_BUFFER, T), r.bufferData(r.UNIFORM_BUFFER, P, D), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, F, T), T;
  }
  function v() {
    for (let Y = 0; Y < u; Y++)
      if (l.indexOf(Y) === -1)
        return l.push(Y), Y;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function b(Y) {
    const F = i[Y.id], T = Y.uniforms, P = Y.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, F);
    for (let D = 0, L = T.length; D < L; D++) {
      const j = Array.isArray(T[D]) ? T[D] : [T[D]];
      for (let J = 0, O = j.length; J < O; J++) {
        const ne = j[J];
        if (S(ne, D, J, P) === !0) {
          const he = ne.__offset, pe = Array.isArray(ne.value) ? ne.value : [ne.value];
          let Ae = 0;
          for (let ke = 0; ke < pe.length; ke++) {
            const Re = pe[ke], Xe = W(Re);
            typeof Re == "number" || typeof Re == "boolean" ? (ne.__data[0] = Re, r.bufferSubData(r.UNIFORM_BUFFER, he + Ae, ne.__data)) : Re.isMatrix3 ? (ne.__data[0] = Re.elements[0], ne.__data[1] = Re.elements[1], ne.__data[2] = Re.elements[2], ne.__data[3] = 0, ne.__data[4] = Re.elements[3], ne.__data[5] = Re.elements[4], ne.__data[6] = Re.elements[5], ne.__data[7] = 0, ne.__data[8] = Re.elements[6], ne.__data[9] = Re.elements[7], ne.__data[10] = Re.elements[8], ne.__data[11] = 0) : (Re.toArray(ne.__data, Ae), Ae += Xe.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          r.bufferSubData(r.UNIFORM_BUFFER, he, ne.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function S(Y, F, T, P) {
    const D = Y.value, L = F + "_" + T;
    if (P[L] === void 0)
      return typeof D == "number" || typeof D == "boolean" ? P[L] = D : P[L] = D.clone(), !0;
    {
      const j = P[L];
      if (typeof D == "number" || typeof D == "boolean") {
        if (j !== D)
          return P[L] = D, !0;
      } else if (j.equals(D) === !1)
        return j.copy(D), !0;
    }
    return !1;
  }
  function R(Y) {
    const F = Y.uniforms;
    let T = 0;
    const P = 16;
    for (let L = 0, j = F.length; L < j; L++) {
      const J = Array.isArray(F[L]) ? F[L] : [F[L]];
      for (let O = 0, ne = J.length; O < ne; O++) {
        const he = J[O], pe = Array.isArray(he.value) ? he.value : [he.value];
        for (let Ae = 0, ke = pe.length; Ae < ke; Ae++) {
          const Re = pe[Ae], Xe = W(Re), re = T % P, Se = re % Xe.boundary, Be = re + Se;
          T += Se, Be !== 0 && P - Be < Xe.storage && (T += P - Be), he.__data = new Float32Array(Xe.storage / Float32Array.BYTES_PER_ELEMENT), he.__offset = T, T += Xe.storage;
        }
      }
    }
    const D = T % P;
    return D > 0 && (T += P - D), Y.__size = T, Y.__cache = {}, this;
  }
  function W(Y) {
    const F = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof Y == "number" || typeof Y == "boolean" ? (F.boundary = 4, F.storage = 4) : Y.isVector2 ? (F.boundary = 8, F.storage = 8) : Y.isVector3 || Y.isColor ? (F.boundary = 16, F.storage = 12) : Y.isVector4 ? (F.boundary = 16, F.storage = 16) : Y.isMatrix3 ? (F.boundary = 48, F.storage = 48) : Y.isMatrix4 ? (F.boundary = 64, F.storage = 64) : Y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", Y), F;
  }
  function x(Y) {
    const F = Y.target;
    F.removeEventListener("dispose", x);
    const T = l.indexOf(F.__bindingPointIndex);
    l.splice(T, 1), r.deleteBuffer(i[F.id]), delete i[F.id], delete o[F.id];
  }
  function N() {
    for (const Y in i)
      r.deleteBuffer(i[Y]);
    l = [], i = {}, o = {};
  }
  return {
    bind: I,
    update: C,
    dispose: N
  };
}
class jK {
  constructor(e = {}) {
    const {
      canvas: t = YK(),
      context: n = null,
      depth: i = !0,
      stencil: o = !1,
      alpha: l = !1,
      antialias: u = !1,
      premultipliedAlpha: I = !0,
      preserveDrawingBuffer: C = !1,
      powerPreference: f = "default",
      failIfMajorPerformanceCaveat: v = !1
    } = e;
    this.isWebGLRenderer = !0;
    let b;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      b = n.getContextAttributes().alpha;
    } else
      b = l;
    const S = new Uint32Array(4), R = new Int32Array(4);
    let W = null, x = null;
    const N = [], Y = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = OC, this.toneMapping = cp, this.toneMappingExposure = 1;
    const F = this;
    let T = !1, P = 0, D = 0, L = null, j = -1, J = null;
    const O = new Ha(), ne = new Ha();
    let he = null;
    const pe = new ai(0);
    let Ae = 0, ke = t.width, Re = t.height, Xe = 1, re = null, Se = null;
    const Be = new Ha(0, 0, ke, Re), le = new Ha(0, 0, ke, Re);
    let Ye = !1;
    const nt = new tR();
    let ze = !1, Je = !1;
    const wt = new _i(), mt = new fe(), Dt = new Ha(), mn = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let An = !1;
    function Hn() {
      return L === null ? Xe : 1;
    }
    let ge = n;
    function Wt(ae, Ne) {
      return t.getContext(ae, Ne);
    }
    try {
      const ae = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: u,
        premultipliedAlpha: I,
        preserveDrawingBuffer: C,
        powerPreference: f,
        failIfMajorPerformanceCaveat: v
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${WW}`), t.addEventListener("webglcontextlost", je, !1), t.addEventListener("webglcontextrestored", et, !1), t.addEventListener("webglcontextcreationerror", Jt, !1), ge === null) {
        const Ne = "webgl2";
        if (ge = Wt(Ne, ae), ge === null)
          throw Wt(Ne) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (ae) {
      throw console.error("THREE.WebGLRenderer: " + ae.message), ae;
    }
    let Nt, $t, ft, bn, en, hn, me, se, $e, Vt, Bt, Mt, Gn, jt, an, jn, Ot, He, vt, xt, ht, on, we, qe;
    function de() {
      Nt = new Y8(ge), Nt.init(), on = new JK(ge, Nt), $t = new W8(ge, Nt, e, on), ft = new h6(ge), bn = new T8(ge), en = new i6(), hn = new y6(ge, Nt, ft, en, $t, on, bn), me = new N8(F), se = new X8(F), $e = new U4(ge), we = new R8(ge, $e), Vt = new F8(ge, $e, bn, we), Bt = new z8(ge, Vt, $e, bn), vt = new _8(ge, $t, hn), jn = new V8(en), Mt = new n6(F, me, se, Nt, $t, we, jn), Gn = new R6(F, en), jt = new a6(), an = new g6(Nt), He = new w8(F, me, se, ft, Bt, b, I), Ot = new C6(F, Bt, $t), qe = new x6(ge, bn, $t, ft), xt = new x8(ge, Nt, bn), ht = new E8(ge, Nt, bn), bn.programs = Mt.programs, F.capabilities = $t, F.extensions = Nt, F.properties = en, F.renderLists = jt, F.shadowMap = Ot, F.state = ft, F.info = bn;
    }
    de();
    const it = new Z6(F, ge);
    this.xr = it, this.getContext = function() {
      return ge;
    }, this.getContextAttributes = function() {
      return ge.getContextAttributes();
    }, this.forceContextLoss = function() {
      const ae = Nt.get("WEBGL_lose_context");
      ae && ae.loseContext();
    }, this.forceContextRestore = function() {
      const ae = Nt.get("WEBGL_lose_context");
      ae && ae.restoreContext();
    }, this.getPixelRatio = function() {
      return Xe;
    }, this.setPixelRatio = function(ae) {
      ae !== void 0 && (Xe = ae, this.setSize(ke, Re, !1));
    }, this.getSize = function(ae) {
      return ae.set(ke, Re);
    }, this.setSize = function(ae, Ne, Te = !0) {
      if (it.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      ke = ae, Re = Ne, t.width = Math.floor(ae * Xe), t.height = Math.floor(Ne * Xe), Te === !0 && (t.style.width = ae + "px", t.style.height = Ne + "px"), this.setViewport(0, 0, ae, Ne);
    }, this.getDrawingBufferSize = function(ae) {
      return ae.set(ke * Xe, Re * Xe).floor();
    }, this.setDrawingBufferSize = function(ae, Ne, Te) {
      ke = ae, Re = Ne, Xe = Te, t.width = Math.floor(ae * Te), t.height = Math.floor(Ne * Te), this.setViewport(0, 0, ae, Ne);
    }, this.getCurrentViewport = function(ae) {
      return ae.copy(O);
    }, this.getViewport = function(ae) {
      return ae.copy(Be);
    }, this.setViewport = function(ae, Ne, Te, De) {
      ae.isVector4 ? Be.set(ae.x, ae.y, ae.z, ae.w) : Be.set(ae, Ne, Te, De), ft.viewport(O.copy(Be).multiplyScalar(Xe).round());
    }, this.getScissor = function(ae) {
      return ae.copy(le);
    }, this.setScissor = function(ae, Ne, Te, De) {
      ae.isVector4 ? le.set(ae.x, ae.y, ae.z, ae.w) : le.set(ae, Ne, Te, De), ft.scissor(ne.copy(le).multiplyScalar(Xe).round());
    }, this.getScissorTest = function() {
      return Ye;
    }, this.setScissorTest = function(ae) {
      ft.setScissorTest(Ye = ae);
    }, this.setOpaqueSort = function(ae) {
      re = ae;
    }, this.setTransparentSort = function(ae) {
      Se = ae;
    }, this.getClearColor = function(ae) {
      return ae.copy(He.getClearColor());
    }, this.setClearColor = function() {
      He.setClearColor.apply(He, arguments);
    }, this.getClearAlpha = function() {
      return He.getClearAlpha();
    }, this.setClearAlpha = function() {
      He.setClearAlpha.apply(He, arguments);
    }, this.clear = function(ae = !0, Ne = !0, Te = !0) {
      let De = 0;
      if (ae) {
        let Ee = !1;
        if (L !== null) {
          const Tt = L.texture.format;
          Ee = Tt === EW || Tt === FW || Tt === jw;
        }
        if (Ee) {
          const Tt = L.texture.type, tn = Tt === nf || Tt === Pm || Tt === CB || Tt === Bb || Tt === HW || Tt === XW, Bn = He.getClearColor(), Pt = He.getClearAlpha(), Zn = Bn.r, rn = Bn.g, Yn = Bn.b;
          tn ? (S[0] = Zn, S[1] = rn, S[2] = Yn, S[3] = Pt, ge.clearBufferuiv(ge.COLOR, 0, S)) : (R[0] = Zn, R[1] = rn, R[2] = Yn, R[3] = Pt, ge.clearBufferiv(ge.COLOR, 0, R));
        } else
          De |= ge.COLOR_BUFFER_BIT;
      }
      Ne && (De |= ge.DEPTH_BUFFER_BIT), Te && (De |= ge.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ge.clear(De);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", je, !1), t.removeEventListener("webglcontextrestored", et, !1), t.removeEventListener("webglcontextcreationerror", Jt, !1), jt.dispose(), an.dispose(), en.dispose(), me.dispose(), se.dispose(), Bt.dispose(), we.dispose(), qe.dispose(), Mt.dispose(), it.dispose(), it.removeEventListener("sessionstart", xr), it.removeEventListener("sessionend", la), Ve.stop();
    };
    function je(ae) {
      ae.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = !0;
    }
    function et() {
      console.log("THREE.WebGLRenderer: Context Restored."), T = !1;
      const ae = bn.autoReset, Ne = Ot.enabled, Te = Ot.autoUpdate, De = Ot.needsUpdate, Ee = Ot.type;
      de(), bn.autoReset = ae, Ot.enabled = Ne, Ot.autoUpdate = Te, Ot.needsUpdate = De, Ot.type = Ee;
    }
    function Jt(ae) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ae.statusMessage);
    }
    function Kn(ae) {
      const Ne = ae.target;
      Ne.removeEventListener("dispose", Kn), di(Ne);
    }
    function di(ae) {
      Di(ae), en.remove(ae);
    }
    function Di(ae) {
      const Ne = en.get(ae).programs;
      Ne !== void 0 && (Ne.forEach(function(Te) {
        Mt.releaseProgram(Te);
      }), ae.isShaderMaterial && Mt.releaseShaderCache(ae));
    }
    this.renderBufferDirect = function(ae, Ne, Te, De, Ee, Tt) {
      Ne === null && (Ne = mn);
      const tn = Ee.isMesh && Ee.matrixWorld.determinant() < 0, Bn = At(ae, Ne, Te, De, Ee);
      ft.setMaterial(De, tn);
      let Pt = Te.index, Zn = 1;
      if (De.wireframe === !0) {
        if (Pt = Vt.getWireframeAttribute(Te), Pt === void 0) return;
        Zn = 2;
      }
      const rn = Te.drawRange, Yn = Te.attributes.position;
      let Fi = rn.start * Zn, Ir = (rn.start + rn.count) * Zn;
      Tt !== null && (Fi = Math.max(Fi, Tt.start * Zn), Ir = Math.min(Ir, (Tt.start + Tt.count) * Zn)), Pt !== null ? (Fi = Math.max(Fi, 0), Ir = Math.min(Ir, Pt.count)) : Yn != null && (Fi = Math.max(Fi, 0), Ir = Math.min(Ir, Yn.count));
      const Tn = Ir - Fi;
      if (Tn < 0 || Tn === 1 / 0) return;
      we.setup(Ee, De, Bn, Te, Pt);
      let mi, xn = xt;
      if (Pt !== null && (mi = $e.get(Pt), xn = ht, xn.setIndex(mi)), Ee.isMesh)
        De.wireframe === !0 ? (ft.setLineWidth(De.wireframeLinewidth * Hn()), xn.setMode(ge.LINES)) : xn.setMode(ge.TRIANGLES);
      else if (Ee.isLine) {
        let un = De.linewidth;
        un === void 0 && (un = 1), ft.setLineWidth(un * Hn()), Ee.isLineSegments ? xn.setMode(ge.LINES) : Ee.isLineLoop ? xn.setMode(ge.LINE_LOOP) : xn.setMode(ge.LINE_STRIP);
      } else Ee.isPoints ? xn.setMode(ge.POINTS) : Ee.isSprite && xn.setMode(ge.TRIANGLES);
      if (Ee.isBatchedMesh)
        if (Ee._multiDrawInstances !== null)
          xn.renderMultiDrawInstances(Ee._multiDrawStarts, Ee._multiDrawCounts, Ee._multiDrawCount, Ee._multiDrawInstances);
        else if (Nt.get("WEBGL_multi_draw"))
          xn.renderMultiDraw(Ee._multiDrawStarts, Ee._multiDrawCounts, Ee._multiDrawCount);
        else {
          const un = Ee._multiDrawStarts, Xn = Ee._multiDrawCounts, li = Ee._multiDrawCount, Wr = Pt ? $e.get(Pt).bytesPerElement : 1, Xo = en.get(De).currentProgram.getUniforms();
          for (let $r = 0; $r < li; $r++)
            Xo.setValue(ge, "_gl_DrawID", $r), xn.render(un[$r] / Wr, Xn[$r]);
        }
      else if (Ee.isInstancedMesh)
        xn.renderInstances(Fi, Tn, Ee.count);
      else if (Te.isInstancedBufferGeometry) {
        const un = Te._maxInstanceCount !== void 0 ? Te._maxInstanceCount : 1 / 0, Xn = Math.min(Te.instanceCount, un);
        xn.renderInstances(Fi, Tn, Xn);
      } else
        xn.render(Fi, Tn);
    };
    function Jn(ae, Ne, Te) {
      ae.transparent === !0 && ae.side === ip && ae.forceSinglePass === !1 ? (ae.side = td, ae.needsUpdate = !0, Ln(ae, Ne, Te), ae.side = Um, ae.needsUpdate = !0, Ln(ae, Ne, Te), ae.side = ip) : Ln(ae, Ne, Te);
    }
    this.compile = function(ae, Ne, Te = null) {
      Te === null && (Te = ae), x = an.get(Te), x.init(Ne), Y.push(x), Te.traverseVisible(function(Ee) {
        Ee.isLight && Ee.layers.test(Ne.layers) && (x.pushLight(Ee), Ee.castShadow && x.pushShadow(Ee));
      }), ae !== Te && ae.traverseVisible(function(Ee) {
        Ee.isLight && Ee.layers.test(Ne.layers) && (x.pushLight(Ee), Ee.castShadow && x.pushShadow(Ee));
      }), x.setupLights();
      const De = /* @__PURE__ */ new Set();
      return ae.traverse(function(Ee) {
        const Tt = Ee.material;
        if (Tt)
          if (Array.isArray(Tt))
            for (let tn = 0; tn < Tt.length; tn++) {
              const Bn = Tt[tn];
              Jn(Bn, Te, Ee), De.add(Bn);
            }
          else
            Jn(Tt, Te, Ee), De.add(Tt);
      }), Y.pop(), x = null, De;
    }, this.compileAsync = function(ae, Ne, Te = null) {
      const De = this.compile(ae, Ne, Te);
      return new Promise((Ee) => {
        function Tt() {
          if (De.forEach(function(tn) {
            en.get(tn).currentProgram.isReady() && De.delete(tn);
          }), De.size === 0) {
            Ee(ae);
            return;
          }
          setTimeout(Tt, 10);
        }
        Nt.get("KHR_parallel_shader_compile") !== null ? Tt() : setTimeout(Tt, 10);
      });
    };
    let Ii = null;
    function dr(ae) {
      Ii && Ii(ae);
    }
    function xr() {
      Ve.stop();
    }
    function la() {
      Ve.start();
    }
    const Ve = new kK();
    Ve.setAnimationLoop(dr), typeof self < "u" && Ve.setContext(self), this.setAnimationLoop = function(ae) {
      Ii = ae, it.setAnimationLoop(ae), ae === null ? Ve.stop() : Ve.start();
    }, it.addEventListener("sessionstart", xr), it.addEventListener("sessionend", la), this.render = function(ae, Ne) {
      if (Ne !== void 0 && Ne.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (T === !0) return;
      if (ae.matrixWorldAutoUpdate === !0 && ae.updateMatrixWorld(), Ne.parent === null && Ne.matrixWorldAutoUpdate === !0 && Ne.updateMatrixWorld(), it.enabled === !0 && it.isPresenting === !0 && (it.cameraAutoUpdate === !0 && it.updateCamera(Ne), Ne = it.getCamera()), ae.isScene === !0 && ae.onBeforeRender(F, ae, Ne, L), x = an.get(ae, Y.length), x.init(Ne), Y.push(x), wt.multiplyMatrices(Ne.projectionMatrix, Ne.matrixWorldInverse), nt.setFromProjectionMatrix(wt), Je = this.localClippingEnabled, ze = jn.init(this.clippingPlanes, Je), W = jt.get(ae, N.length), W.init(), N.push(W), it.enabled === !0 && it.isPresenting === !0) {
        const Tt = F.xr.getDepthSensingMesh();
        Tt !== null && Oe(Tt, Ne, -1 / 0, F.sortObjects);
      }
      Oe(ae, Ne, 0, F.sortObjects), W.finish(), F.sortObjects === !0 && W.sort(re, Se), An = it.enabled === !1 || it.isPresenting === !1 || it.hasDepthSensing() === !1, An && He.addToRenderList(W, ae), this.info.render.frame++, ze === !0 && jn.beginShadows();
      const Te = x.state.shadowsArray;
      Ot.render(Te, ae, Ne), ze === !0 && jn.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const De = W.opaque, Ee = W.transmissive;
      if (x.setupLights(), Ne.isArrayCamera) {
        const Tt = Ne.cameras;
        if (Ee.length > 0)
          for (let tn = 0, Bn = Tt.length; tn < Bn; tn++) {
            const Pt = Tt[tn];
            Et(De, Ee, ae, Pt);
          }
        An && He.render(ae);
        for (let tn = 0, Bn = Tt.length; tn < Bn; tn++) {
          const Pt = Tt[tn];
          rt(W, ae, Pt, Pt.viewport);
        }
      } else
        Ee.length > 0 && Et(De, Ee, ae, Ne), An && He.render(ae), rt(W, ae, Ne);
      L !== null && (hn.updateMultisampleRenderTarget(L), hn.updateRenderTargetMipmap(L)), ae.isScene === !0 && ae.onAfterRender(F, ae, Ne), we.resetDefaultState(), j = -1, J = null, Y.pop(), Y.length > 0 ? (x = Y[Y.length - 1], ze === !0 && jn.setGlobalState(F.clippingPlanes, x.state.camera)) : x = null, N.pop(), N.length > 0 ? W = N[N.length - 1] : W = null;
    };
    function Oe(ae, Ne, Te, De) {
      if (ae.visible === !1) return;
      if (ae.layers.test(Ne.layers)) {
        if (ae.isGroup)
          Te = ae.renderOrder;
        else if (ae.isLOD)
          ae.autoUpdate === !0 && ae.update(Ne);
        else if (ae.isLight)
          x.pushLight(ae), ae.castShadow && x.pushShadow(ae);
        else if (ae.isSprite) {
          if (!ae.frustumCulled || nt.intersectsSprite(ae)) {
            De && Dt.setFromMatrixPosition(ae.matrixWorld).applyMatrix4(wt);
            const tn = Bt.update(ae), Bn = ae.material;
            Bn.visible && W.push(ae, tn, Bn, Te, Dt.z, null);
          }
        } else if ((ae.isMesh || ae.isLine || ae.isPoints) && (!ae.frustumCulled || nt.intersectsObject(ae))) {
          const tn = Bt.update(ae), Bn = ae.material;
          if (De && (ae.boundingSphere !== void 0 ? (ae.boundingSphere === null && ae.computeBoundingSphere(), Dt.copy(ae.boundingSphere.center)) : (tn.boundingSphere === null && tn.computeBoundingSphere(), Dt.copy(tn.boundingSphere.center)), Dt.applyMatrix4(ae.matrixWorld).applyMatrix4(wt)), Array.isArray(Bn)) {
            const Pt = tn.groups;
            for (let Zn = 0, rn = Pt.length; Zn < rn; Zn++) {
              const Yn = Pt[Zn], Fi = Bn[Yn.materialIndex];
              Fi && Fi.visible && W.push(ae, tn, Fi, Te, Dt.z, Yn);
            }
          } else Bn.visible && W.push(ae, tn, Bn, Te, Dt.z, null);
        }
      }
      const Tt = ae.children;
      for (let tn = 0, Bn = Tt.length; tn < Bn; tn++)
        Oe(Tt[tn], Ne, Te, De);
    }
    function rt(ae, Ne, Te, De) {
      const Ee = ae.opaque, Tt = ae.transmissive, tn = ae.transparent;
      x.setupLightsView(Te), ze === !0 && jn.setGlobalState(F.clippingPlanes, Te), De && ft.viewport(O.copy(De)), Ee.length > 0 && gn(Ee, Ne, Te), Tt.length > 0 && gn(Tt, Ne, Te), tn.length > 0 && gn(tn, Ne, Te), ft.buffers.depth.setTest(!0), ft.buffers.depth.setMask(!0), ft.buffers.color.setMask(!0), ft.setPolygonOffset(!1);
    }
    function Et(ae, Ne, Te, De) {
      if ((Te.isScene === !0 ? Te.overrideMaterial : null) !== null)
        return;
      x.state.transmissionRenderTarget[De.id] === void 0 && (x.state.transmissionRenderTarget[De.id] = new QC(1, 1, {
        generateMipmaps: !0,
        type: Nt.has("EXT_color_buffer_half_float") || Nt.has("EXT_color_buffer_float") ? Vb : nf,
        minFilter: ap,
        samples: 4,
        stencilBuffer: o,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: ya.workingColorSpace
      }));
      const Tt = x.state.transmissionRenderTarget[De.id], tn = De.viewport || O;
      Tt.setSize(tn.z, tn.w);
      const Bn = F.getRenderTarget();
      F.setRenderTarget(Tt), F.getClearColor(pe), Ae = F.getClearAlpha(), Ae < 1 && F.setClearColor(16777215, 0.5), F.clear(), An && He.render(Te);
      const Pt = F.toneMapping;
      F.toneMapping = cp;
      const Zn = De.viewport;
      if (De.viewport !== void 0 && (De.viewport = void 0), x.setupLightsView(De), ze === !0 && jn.setGlobalState(F.clippingPlanes, De), gn(ae, Te, De), hn.updateMultisampleRenderTarget(Tt), hn.updateRenderTargetMipmap(Tt), Nt.has("WEBGL_multisampled_render_to_texture") === !1) {
        let rn = !1;
        for (let Yn = 0, Fi = Ne.length; Yn < Fi; Yn++) {
          const Ir = Ne[Yn], Tn = Ir.object, mi = Ir.geometry, xn = Ir.material, un = Ir.group;
          if (xn.side === ip && Tn.layers.test(De.layers)) {
            const Xn = xn.side;
            xn.side = td, xn.needsUpdate = !0, Vn(Tn, Te, De, mi, xn, un), xn.side = Xn, xn.needsUpdate = !0, rn = !0;
          }
        }
        rn === !0 && (hn.updateMultisampleRenderTarget(Tt), hn.updateRenderTargetMipmap(Tt));
      }
      F.setRenderTarget(Bn), F.setClearColor(pe, Ae), Zn !== void 0 && (De.viewport = Zn), F.toneMapping = Pt;
    }
    function gn(ae, Ne, Te) {
      const De = Ne.isScene === !0 ? Ne.overrideMaterial : null;
      for (let Ee = 0, Tt = ae.length; Ee < Tt; Ee++) {
        const tn = ae[Ee], Bn = tn.object, Pt = tn.geometry, Zn = De === null ? tn.material : De, rn = tn.group;
        Bn.layers.test(Te.layers) && Vn(Bn, Ne, Te, Pt, Zn, rn);
      }
    }
    function Vn(ae, Ne, Te, De, Ee, Tt) {
      ae.onBeforeRender(F, Ne, Te, De, Ee, Tt), ae.modelViewMatrix.multiplyMatrices(Te.matrixWorldInverse, ae.matrixWorld), ae.normalMatrix.getNormalMatrix(ae.modelViewMatrix), Ee.transparent === !0 && Ee.side === ip && Ee.forceSinglePass === !1 ? (Ee.side = td, Ee.needsUpdate = !0, F.renderBufferDirect(Te, Ne, De, Ee, ae, Tt), Ee.side = Um, Ee.needsUpdate = !0, F.renderBufferDirect(Te, Ne, De, Ee, ae, Tt), Ee.side = ip) : F.renderBufferDirect(Te, Ne, De, Ee, ae, Tt), ae.onAfterRender(F, Ne, Te, De, Ee, Tt);
    }
    function Ln(ae, Ne, Te) {
      Ne.isScene !== !0 && (Ne = mn);
      const De = en.get(ae), Ee = x.state.lights, Tt = x.state.shadowsArray, tn = Ee.state.version, Bn = Mt.getParameters(ae, Ee.state, Tt, Ne, Te), Pt = Mt.getProgramCacheKey(Bn);
      let Zn = De.programs;
      De.environment = ae.isMeshStandardMaterial ? Ne.environment : null, De.fog = Ne.fog, De.envMap = (ae.isMeshStandardMaterial ? se : me).get(ae.envMap || De.environment), De.envMapRotation = De.environment !== null && ae.envMap === null ? Ne.environmentRotation : ae.envMapRotation, Zn === void 0 && (ae.addEventListener("dispose", Kn), Zn = /* @__PURE__ */ new Map(), De.programs = Zn);
      let rn = Zn.get(Pt);
      if (rn !== void 0) {
        if (De.currentProgram === rn && De.lightsStateVersion === tn)
          return tt(ae, Bn), rn;
      } else
        Bn.uniforms = Mt.getUniforms(ae), ae.onBeforeCompile(Bn, F), rn = Mt.acquireProgram(Bn, Pt), Zn.set(Pt, rn), De.uniforms = Bn.uniforms;
      const Yn = De.uniforms;
      return (!ae.isShaderMaterial && !ae.isRawShaderMaterial || ae.clipping === !0) && (Yn.clippingPlanes = jn.uniform), tt(ae, Bn), De.needsLights = vn(ae), De.lightsStateVersion = tn, De.needsLights && (Yn.ambientLightColor.value = Ee.state.ambient, Yn.lightProbe.value = Ee.state.probe, Yn.directionalLights.value = Ee.state.directional, Yn.directionalLightShadows.value = Ee.state.directionalShadow, Yn.spotLights.value = Ee.state.spot, Yn.spotLightShadows.value = Ee.state.spotShadow, Yn.rectAreaLights.value = Ee.state.rectArea, Yn.ltc_1.value = Ee.state.rectAreaLTC1, Yn.ltc_2.value = Ee.state.rectAreaLTC2, Yn.pointLights.value = Ee.state.point, Yn.pointLightShadows.value = Ee.state.pointShadow, Yn.hemisphereLights.value = Ee.state.hemi, Yn.directionalShadowMap.value = Ee.state.directionalShadowMap, Yn.directionalShadowMatrix.value = Ee.state.directionalShadowMatrix, Yn.spotShadowMap.value = Ee.state.spotShadowMap, Yn.spotLightMatrix.value = Ee.state.spotLightMatrix, Yn.spotLightMap.value = Ee.state.spotLightMap, Yn.pointShadowMap.value = Ee.state.pointShadowMap, Yn.pointShadowMatrix.value = Ee.state.pointShadowMatrix), De.currentProgram = rn, De.uniformsList = null, rn;
    }
    function Ie(ae) {
      if (ae.uniformsList === null) {
        const Ne = ae.currentProgram.getUniforms();
        ae.uniformsList = d2.seqWithValue(Ne.seq, ae.uniforms);
      }
      return ae.uniformsList;
    }
    function tt(ae, Ne) {
      const Te = en.get(ae);
      Te.outputColorSpace = Ne.outputColorSpace, Te.batching = Ne.batching, Te.batchingColor = Ne.batchingColor, Te.instancing = Ne.instancing, Te.instancingColor = Ne.instancingColor, Te.instancingMorph = Ne.instancingMorph, Te.skinning = Ne.skinning, Te.morphTargets = Ne.morphTargets, Te.morphNormals = Ne.morphNormals, Te.morphColors = Ne.morphColors, Te.morphTargetsCount = Ne.morphTargetsCount, Te.numClippingPlanes = Ne.numClippingPlanes, Te.numIntersection = Ne.numClipIntersection, Te.vertexAlphas = Ne.vertexAlphas, Te.vertexTangents = Ne.vertexTangents, Te.toneMapping = Ne.toneMapping;
    }
    function At(ae, Ne, Te, De, Ee) {
      Ne.isScene !== !0 && (Ne = mn), hn.resetTextureUnits();
      const Tt = Ne.fog, tn = De.isMeshStandardMaterial ? Ne.environment : null, Bn = L === null ? F.outputColorSpace : L.isXRRenderTarget === !0 ? L.texture.colorSpace : $m, Pt = (De.isMeshStandardMaterial ? se : me).get(De.envMap || tn), Zn = De.vertexColors === !0 && !!Te.attributes.color && Te.attributes.color.itemSize === 4, rn = !!Te.attributes.tangent && (!!De.normalMap || De.anisotropy > 0), Yn = !!Te.morphAttributes.position, Fi = !!Te.morphAttributes.normal, Ir = !!Te.morphAttributes.color;
      let Tn = cp;
      De.toneMapped && (L === null || L.isXRRenderTarget === !0) && (Tn = F.toneMapping);
      const mi = Te.morphAttributes.position || Te.morphAttributes.normal || Te.morphAttributes.color, xn = mi !== void 0 ? mi.length : 0, un = en.get(De), Xn = x.state.lights;
      if (ze === !0 && (Je === !0 || ae !== J)) {
        const Xa = ae === J && De.id === j;
        jn.setState(De, ae, Xa);
      }
      let li = !1;
      De.version === un.__version ? (un.needsLights && un.lightsStateVersion !== Xn.state.version || un.outputColorSpace !== Bn || Ee.isBatchedMesh && un.batching === !1 || !Ee.isBatchedMesh && un.batching === !0 || Ee.isBatchedMesh && un.batchingColor === !0 && Ee.colorTexture === null || Ee.isBatchedMesh && un.batchingColor === !1 && Ee.colorTexture !== null || Ee.isInstancedMesh && un.instancing === !1 || !Ee.isInstancedMesh && un.instancing === !0 || Ee.isSkinnedMesh && un.skinning === !1 || !Ee.isSkinnedMesh && un.skinning === !0 || Ee.isInstancedMesh && un.instancingColor === !0 && Ee.instanceColor === null || Ee.isInstancedMesh && un.instancingColor === !1 && Ee.instanceColor !== null || Ee.isInstancedMesh && un.instancingMorph === !0 && Ee.morphTexture === null || Ee.isInstancedMesh && un.instancingMorph === !1 && Ee.morphTexture !== null || un.envMap !== Pt || De.fog === !0 && un.fog !== Tt || un.numClippingPlanes !== void 0 && (un.numClippingPlanes !== jn.numPlanes || un.numIntersection !== jn.numIntersection) || un.vertexAlphas !== Zn || un.vertexTangents !== rn || un.morphTargets !== Yn || un.morphNormals !== Fi || un.morphColors !== Ir || un.toneMapping !== Tn || un.morphTargetsCount !== xn) && (li = !0) : (li = !0, un.__version = De.version);
      let Wr = un.currentProgram;
      li === !0 && (Wr = Ln(De, Ne, Ee));
      let Xo = !1, $r = !1, ba = !1;
      const or = Wr.getUniforms(), za = un.uniforms;
      if (ft.useProgram(Wr.program) && (Xo = !0, $r = !0, ba = !0), De.id !== j && (j = De.id, $r = !0), Xo || J !== ae) {
        or.setValue(ge, "projectionMatrix", ae.projectionMatrix), or.setValue(ge, "viewMatrix", ae.matrixWorldInverse);
        const Xa = or.map.cameraPosition;
        Xa !== void 0 && Xa.setValue(ge, mt.setFromMatrixPosition(ae.matrixWorld)), $t.logarithmicDepthBuffer && or.setValue(
          ge,
          "logDepthBufFC",
          2 / (Math.log(ae.far + 1) / Math.LN2)
        ), (De.isMeshPhongMaterial || De.isMeshToonMaterial || De.isMeshLambertMaterial || De.isMeshBasicMaterial || De.isMeshStandardMaterial || De.isShaderMaterial) && or.setValue(ge, "isOrthographic", ae.isOrthographicCamera === !0), J !== ae && (J = ae, $r = !0, ba = !0);
      }
      if (Ee.isSkinnedMesh) {
        or.setOptional(ge, Ee, "bindMatrix"), or.setOptional(ge, Ee, "bindMatrixInverse");
        const Xa = Ee.skeleton;
        Xa && (Xa.boneTexture === null && Xa.computeBoneTexture(), or.setValue(ge, "boneTexture", Xa.boneTexture, hn));
      }
      Ee.isBatchedMesh && (or.setOptional(ge, Ee, "batchingTexture"), or.setValue(ge, "batchingTexture", Ee._matricesTexture, hn), or.setOptional(ge, Ee, "batchingIdTexture"), or.setValue(ge, "batchingIdTexture", Ee._indirectTexture, hn), or.setOptional(ge, Ee, "batchingColorTexture"), Ee._colorsTexture !== null && or.setValue(ge, "batchingColorTexture", Ee._colorsTexture, hn));
      const pl = Te.morphAttributes;
      if ((pl.position !== void 0 || pl.normal !== void 0 || pl.color !== void 0) && vt.update(Ee, Te, Wr), ($r || un.receiveShadow !== Ee.receiveShadow) && (un.receiveShadow = Ee.receiveShadow, or.setValue(ge, "receiveShadow", Ee.receiveShadow)), De.isMeshGouraudMaterial && De.envMap !== null && (za.envMap.value = Pt, za.flipEnvMap.value = Pt.isCubeTexture && Pt.isRenderTargetTexture === !1 ? -1 : 1), De.isMeshStandardMaterial && De.envMap === null && Ne.environment !== null && (za.envMapIntensity.value = Ne.environmentIntensity), $r && (or.setValue(ge, "toneMappingExposure", F.toneMappingExposure), un.needsLights && Gt(za, ba), Tt && De.fog === !0 && Gn.refreshFogUniforms(za, Tt), Gn.refreshMaterialUniforms(za, De, Xe, Re, x.state.transmissionRenderTarget[ae.id]), d2.upload(ge, Ie(un), za, hn)), De.isShaderMaterial && De.uniformsNeedUpdate === !0 && (d2.upload(ge, Ie(un), za, hn), De.uniformsNeedUpdate = !1), De.isSpriteMaterial && or.setValue(ge, "center", Ee.center), or.setValue(ge, "modelViewMatrix", Ee.modelViewMatrix), or.setValue(ge, "normalMatrix", Ee.normalMatrix), or.setValue(ge, "modelMatrix", Ee.matrixWorld), De.isShaderMaterial || De.isRawShaderMaterial) {
        const Xa = De.uniformsGroups;
        for (let bs = 0, Ao = Xa.length; bs < Ao; bs++) {
          const Ou = Xa[bs];
          qe.update(Ou, Wr), qe.bind(Ou, Wr);
        }
      }
      return Wr;
    }
    function Gt(ae, Ne) {
      ae.ambientLightColor.needsUpdate = Ne, ae.lightProbe.needsUpdate = Ne, ae.directionalLights.needsUpdate = Ne, ae.directionalLightShadows.needsUpdate = Ne, ae.pointLights.needsUpdate = Ne, ae.pointLightShadows.needsUpdate = Ne, ae.spotLights.needsUpdate = Ne, ae.spotLightShadows.needsUpdate = Ne, ae.rectAreaLights.needsUpdate = Ne, ae.hemisphereLights.needsUpdate = Ne;
    }
    function vn(ae) {
      return ae.isMeshLambertMaterial || ae.isMeshToonMaterial || ae.isMeshPhongMaterial || ae.isMeshStandardMaterial || ae.isShadowMaterial || ae.isShaderMaterial && ae.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return P;
    }, this.getActiveMipmapLevel = function() {
      return D;
    }, this.getRenderTarget = function() {
      return L;
    }, this.setRenderTargetTextures = function(ae, Ne, Te) {
      en.get(ae.texture).__webglTexture = Ne, en.get(ae.depthTexture).__webglTexture = Te;
      const De = en.get(ae);
      De.__hasExternalTextures = !0, De.__autoAllocateDepthBuffer = Te === void 0, De.__autoAllocateDepthBuffer || Nt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), De.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(ae, Ne) {
      const Te = en.get(ae);
      Te.__webglFramebuffer = Ne, Te.__useDefaultFramebuffer = Ne === void 0;
    }, this.setRenderTarget = function(ae, Ne = 0, Te = 0) {
      L = ae, P = Ne, D = Te;
      let De = !0, Ee = null, Tt = !1, tn = !1;
      if (ae) {
        const Pt = en.get(ae);
        Pt.__useDefaultFramebuffer !== void 0 ? (ft.bindFramebuffer(ge.FRAMEBUFFER, null), De = !1) : Pt.__webglFramebuffer === void 0 ? hn.setupRenderTarget(ae) : Pt.__hasExternalTextures && hn.rebindTextures(ae, en.get(ae.texture).__webglTexture, en.get(ae.depthTexture).__webglTexture);
        const Zn = ae.texture;
        (Zn.isData3DTexture || Zn.isDataArrayTexture || Zn.isCompressedArrayTexture) && (tn = !0);
        const rn = en.get(ae).__webglFramebuffer;
        ae.isWebGLCubeRenderTarget ? (Array.isArray(rn[Ne]) ? Ee = rn[Ne][Te] : Ee = rn[Ne], Tt = !0) : ae.samples > 0 && hn.useMultisampledRTT(ae) === !1 ? Ee = en.get(ae).__webglMultisampledFramebuffer : Array.isArray(rn) ? Ee = rn[Te] : Ee = rn, O.copy(ae.viewport), ne.copy(ae.scissor), he = ae.scissorTest;
      } else
        O.copy(Be).multiplyScalar(Xe).floor(), ne.copy(le).multiplyScalar(Xe).floor(), he = Ye;
      if (ft.bindFramebuffer(ge.FRAMEBUFFER, Ee) && De && ft.drawBuffers(ae, Ee), ft.viewport(O), ft.scissor(ne), ft.setScissorTest(he), Tt) {
        const Pt = en.get(ae.texture);
        ge.framebufferTexture2D(ge.FRAMEBUFFER, ge.COLOR_ATTACHMENT0, ge.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Pt.__webglTexture, Te);
      } else if (tn) {
        const Pt = en.get(ae.texture), Zn = Ne || 0;
        ge.framebufferTextureLayer(ge.FRAMEBUFFER, ge.COLOR_ATTACHMENT0, Pt.__webglTexture, Te || 0, Zn);
      }
      j = -1;
    }, this.readRenderTargetPixels = function(ae, Ne, Te, De, Ee, Tt, tn) {
      if (!(ae && ae.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Bn = en.get(ae).__webglFramebuffer;
      if (ae.isWebGLCubeRenderTarget && tn !== void 0 && (Bn = Bn[tn]), Bn) {
        ft.bindFramebuffer(ge.FRAMEBUFFER, Bn);
        try {
          const Pt = ae.texture, Zn = Pt.format, rn = Pt.type;
          if (!$t.textureFormatReadable(Zn)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!$t.textureTypeReadable(rn)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          Ne >= 0 && Ne <= ae.width - De && Te >= 0 && Te <= ae.height - Ee && ge.readPixels(Ne, Te, De, Ee, on.convert(Zn), on.convert(rn), Tt);
        } finally {
          const Pt = L !== null ? en.get(L).__webglFramebuffer : null;
          ft.bindFramebuffer(ge.FRAMEBUFFER, Pt);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(ae, Ne, Te, De, Ee, Tt, tn) {
      if (!(ae && ae.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Bn = en.get(ae).__webglFramebuffer;
      if (ae.isWebGLCubeRenderTarget && tn !== void 0 && (Bn = Bn[tn]), Bn) {
        ft.bindFramebuffer(ge.FRAMEBUFFER, Bn);
        try {
          const Pt = ae.texture, Zn = Pt.format, rn = Pt.type;
          if (!$t.textureFormatReadable(Zn))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          if (!$t.textureTypeReadable(rn))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          if (Ne >= 0 && Ne <= ae.width - De && Te >= 0 && Te <= ae.height - Ee) {
            const Yn = ge.createBuffer();
            ge.bindBuffer(ge.PIXEL_PACK_BUFFER, Yn), ge.bufferData(ge.PIXEL_PACK_BUFFER, Tt.byteLength, ge.STREAM_READ), ge.readPixels(Ne, Te, De, Ee, on.convert(Zn), on.convert(rn), 0), ge.flush();
            const Fi = ge.fenceSync(ge.SYNC_GPU_COMMANDS_COMPLETE, 0);
            await p4(ge, Fi, 4);
            try {
              ge.bindBuffer(ge.PIXEL_PACK_BUFFER, Yn), ge.getBufferSubData(ge.PIXEL_PACK_BUFFER, 0, Tt);
            } finally {
              ge.deleteBuffer(Yn), ge.deleteSync(Fi);
            }
            return Tt;
          }
        } finally {
          const Pt = L !== null ? en.get(L).__webglFramebuffer : null;
          ft.bindFramebuffer(ge.FRAMEBUFFER, Pt);
        }
      }
    }, this.copyFramebufferToTexture = function(ae, Ne = null, Te = 0) {
      ae.isTexture !== !0 && (oB("WebGLRenderer: copyFramebufferToTexture function signature has changed."), Ne = arguments[0] || null, ae = arguments[1]);
      const De = Math.pow(2, -Te), Ee = Math.floor(ae.image.width * De), Tt = Math.floor(ae.image.height * De), tn = Ne !== null ? Ne.x : 0, Bn = Ne !== null ? Ne.y : 0;
      hn.setTexture2D(ae, 0), ge.copyTexSubImage2D(ge.TEXTURE_2D, Te, 0, 0, tn, Bn, Ee, Tt), ft.unbindTexture();
    }, this.copyTextureToTexture = function(ae, Ne, Te = null, De = null, Ee = 0) {
      ae.isTexture !== !0 && (oB("WebGLRenderer: copyTextureToTexture function signature has changed."), De = arguments[0] || null, ae = arguments[1], Ne = arguments[2], Ee = arguments[3] || 0, Te = null);
      let Tt, tn, Bn, Pt, Zn, rn;
      Te !== null ? (Tt = Te.max.x - Te.min.x, tn = Te.max.y - Te.min.y, Bn = Te.min.x, Pt = Te.min.y) : (Tt = ae.image.width, tn = ae.image.height, Bn = 0, Pt = 0), De !== null ? (Zn = De.x, rn = De.y) : (Zn = 0, rn = 0);
      const Yn = on.convert(Ne.format), Fi = on.convert(Ne.type);
      hn.setTexture2D(Ne, 0), ge.pixelStorei(ge.UNPACK_FLIP_Y_WEBGL, Ne.flipY), ge.pixelStorei(ge.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ne.premultiplyAlpha), ge.pixelStorei(ge.UNPACK_ALIGNMENT, Ne.unpackAlignment);
      const Ir = ge.getParameter(ge.UNPACK_ROW_LENGTH), Tn = ge.getParameter(ge.UNPACK_IMAGE_HEIGHT), mi = ge.getParameter(ge.UNPACK_SKIP_PIXELS), xn = ge.getParameter(ge.UNPACK_SKIP_ROWS), un = ge.getParameter(ge.UNPACK_SKIP_IMAGES), Xn = ae.isCompressedTexture ? ae.mipmaps[Ee] : ae.image;
      ge.pixelStorei(ge.UNPACK_ROW_LENGTH, Xn.width), ge.pixelStorei(ge.UNPACK_IMAGE_HEIGHT, Xn.height), ge.pixelStorei(ge.UNPACK_SKIP_PIXELS, Bn), ge.pixelStorei(ge.UNPACK_SKIP_ROWS, Pt), ae.isDataTexture ? ge.texSubImage2D(ge.TEXTURE_2D, Ee, Zn, rn, Tt, tn, Yn, Fi, Xn.data) : ae.isCompressedTexture ? ge.compressedTexSubImage2D(ge.TEXTURE_2D, Ee, Zn, rn, Xn.width, Xn.height, Yn, Xn.data) : ge.texSubImage2D(ge.TEXTURE_2D, Ee, Zn, rn, Tt, tn, Yn, Fi, Xn), ge.pixelStorei(ge.UNPACK_ROW_LENGTH, Ir), ge.pixelStorei(ge.UNPACK_IMAGE_HEIGHT, Tn), ge.pixelStorei(ge.UNPACK_SKIP_PIXELS, mi), ge.pixelStorei(ge.UNPACK_SKIP_ROWS, xn), ge.pixelStorei(ge.UNPACK_SKIP_IMAGES, un), Ee === 0 && Ne.generateMipmaps && ge.generateMipmap(ge.TEXTURE_2D), ft.unbindTexture();
    }, this.copyTextureToTexture3D = function(ae, Ne, Te = null, De = null, Ee = 0) {
      ae.isTexture !== !0 && (oB("WebGLRenderer: copyTextureToTexture3D function signature has changed."), Te = arguments[0] || null, De = arguments[1] || null, ae = arguments[2], Ne = arguments[3], Ee = arguments[4] || 0);
      let Tt, tn, Bn, Pt, Zn, rn, Yn, Fi, Ir;
      const Tn = ae.isCompressedTexture ? ae.mipmaps[Ee] : ae.image;
      Te !== null ? (Tt = Te.max.x - Te.min.x, tn = Te.max.y - Te.min.y, Bn = Te.max.z - Te.min.z, Pt = Te.min.x, Zn = Te.min.y, rn = Te.min.z) : (Tt = Tn.width, tn = Tn.height, Bn = Tn.depth, Pt = 0, Zn = 0, rn = 0), De !== null ? (Yn = De.x, Fi = De.y, Ir = De.z) : (Yn = 0, Fi = 0, Ir = 0);
      const mi = on.convert(Ne.format), xn = on.convert(Ne.type);
      let un;
      if (Ne.isData3DTexture)
        hn.setTexture3D(Ne, 0), un = ge.TEXTURE_3D;
      else if (Ne.isDataArrayTexture || Ne.isCompressedArrayTexture)
        hn.setTexture2DArray(Ne, 0), un = ge.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      ge.pixelStorei(ge.UNPACK_FLIP_Y_WEBGL, Ne.flipY), ge.pixelStorei(ge.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ne.premultiplyAlpha), ge.pixelStorei(ge.UNPACK_ALIGNMENT, Ne.unpackAlignment);
      const Xn = ge.getParameter(ge.UNPACK_ROW_LENGTH), li = ge.getParameter(ge.UNPACK_IMAGE_HEIGHT), Wr = ge.getParameter(ge.UNPACK_SKIP_PIXELS), Xo = ge.getParameter(ge.UNPACK_SKIP_ROWS), $r = ge.getParameter(ge.UNPACK_SKIP_IMAGES);
      ge.pixelStorei(ge.UNPACK_ROW_LENGTH, Tn.width), ge.pixelStorei(ge.UNPACK_IMAGE_HEIGHT, Tn.height), ge.pixelStorei(ge.UNPACK_SKIP_PIXELS, Pt), ge.pixelStorei(ge.UNPACK_SKIP_ROWS, Zn), ge.pixelStorei(ge.UNPACK_SKIP_IMAGES, rn), ae.isDataTexture || ae.isData3DTexture ? ge.texSubImage3D(un, Ee, Yn, Fi, Ir, Tt, tn, Bn, mi, xn, Tn.data) : Ne.isCompressedArrayTexture ? ge.compressedTexSubImage3D(un, Ee, Yn, Fi, Ir, Tt, tn, Bn, mi, Tn.data) : ge.texSubImage3D(un, Ee, Yn, Fi, Ir, Tt, tn, Bn, mi, xn, Tn), ge.pixelStorei(ge.UNPACK_ROW_LENGTH, Xn), ge.pixelStorei(ge.UNPACK_IMAGE_HEIGHT, li), ge.pixelStorei(ge.UNPACK_SKIP_PIXELS, Wr), ge.pixelStorei(ge.UNPACK_SKIP_ROWS, Xo), ge.pixelStorei(ge.UNPACK_SKIP_IMAGES, $r), Ee === 0 && Ne.generateMipmaps && ge.generateMipmap(un), ft.unbindTexture();
    }, this.initRenderTarget = function(ae) {
      en.get(ae).__webglFramebuffer === void 0 && hn.setupRenderTarget(ae);
    }, this.initTexture = function(ae) {
      ae.isCubeTexture ? hn.setTextureCube(ae, 0) : ae.isData3DTexture ? hn.setTexture3D(ae, 0) : ae.isDataArrayTexture || ae.isCompressedArrayTexture ? hn.setTexture2DArray(ae, 0) : hn.setTexture2D(ae, 0), ft.unbindTexture();
    }, this.resetState = function() {
      P = 0, D = 0, L = null, ft.reset(), we.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return op;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === _W ? "display-p3" : "srgb", t.unpackColorSpace = ya.workingColorSpace === qw ? "display-p3" : "srgb";
  }
}
class kW {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new ai(e), this.density = t;
  }
  clone() {
    return new kW(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class DW {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new ai(e), this.near = t, this.far = n;
  }
  clone() {
    return new DW(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
let fY = class extends qr {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new uI(), this.environmentIntensity = 1, this.environmentRotation = new uI(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
};
class UW {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Rw, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = PI();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return oB("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = PI()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = PI()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Og = /* @__PURE__ */ new fe();
class Zb {
  constructor(e, t, n, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Og.fromBufferAttribute(this, t), Og.applyMatrix4(e), this.setXYZ(t, Og.x, Og.y, Og.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Og.fromBufferAttribute(this, t), Og.applyNormalMatrix(e), this.setXYZ(t, Og.x, Og.y, Og.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Og.fromBufferAttribute(this, t), Og.transformDirection(e), this.setXYZ(t, Og.x, Og.y, Og.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = qg(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = hr(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
  }
  setX(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = hr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = qg(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = qg(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = qg(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = qg(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = hr(t, this.array), n = hr(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = hr(t, this.array), n = hr(n, this.array), i = hr(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, o) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = hr(t, this.array), n = hr(n, this.array), i = hr(i, this.array), o = hr(o, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = o, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return new ja(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Zb(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class pY extends Cg {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new ai(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let EG;
const wZ = /* @__PURE__ */ new fe(), TG = /* @__PURE__ */ new fe(), _G = /* @__PURE__ */ new fe(), zG = /* @__PURE__ */ new Lt(), RZ = /* @__PURE__ */ new Lt(), qK = /* @__PURE__ */ new _i(), G1 = /* @__PURE__ */ new fe(), xZ = /* @__PURE__ */ new fe(), B1 = /* @__PURE__ */ new fe(), Z3 = /* @__PURE__ */ new Lt(), DM = /* @__PURE__ */ new Lt(), w3 = /* @__PURE__ */ new Lt();
class $K extends qr {
  constructor(e = new pY()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", EG === void 0) {
      EG = new Br();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new UW(t, 5);
      EG.setIndex([0, 1, 2, 0, 2, 3]), EG.setAttribute("position", new Zb(n, 3, 0, !1)), EG.setAttribute("uv", new Zb(n, 2, 3, !1));
    }
    this.geometry = EG, this.material = e, this.center = new Lt(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), TG.setFromMatrixScale(this.matrixWorld), qK.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), _G.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && TG.multiplyScalar(-_G.z);
    const n = this.material.rotation;
    let i, o;
    n !== 0 && (o = Math.cos(n), i = Math.sin(n));
    const l = this.center;
    S1(G1.set(-0.5, -0.5, 0), _G, l, TG, i, o), S1(xZ.set(0.5, -0.5, 0), _G, l, TG, i, o), S1(B1.set(0.5, 0.5, 0), _G, l, TG, i, o), Z3.set(0, 0), DM.set(1, 0), w3.set(1, 1);
    let u = e.ray.intersectTriangle(G1, xZ, B1, !1, wZ);
    if (u === null && (S1(xZ.set(-0.5, 0.5, 0), _G, l, TG, i, o), DM.set(0, 1), u = e.ray.intersectTriangle(G1, B1, xZ, !1, wZ), u === null))
      return;
    const I = e.ray.origin.distanceTo(wZ);
    I < e.near || I > e.far || t.push({
      distance: I,
      point: wZ.clone(),
      uv: DI.getInterpolation(wZ, G1, xZ, B1, Z3, DM, w3, new Lt()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function S1(r, e, t, n, i, o) {
  zG.subVectors(r, t).addScalar(0.5).multiply(n), i !== void 0 ? (RZ.x = o * zG.x - i * zG.y, RZ.y = i * zG.x + o * zG.y) : RZ.copy(zG), r.copy(e), r.x += RZ.x, r.y += RZ.y, r.applyMatrix4(qK);
}
const Z1 = /* @__PURE__ */ new fe(), R3 = /* @__PURE__ */ new fe();
class eL extends qr {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const o = t[n];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(t < i[o].distance); o++)
      ;
    return i.splice(o, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let o = t[n].distance;
        if (t[n].object.visible && (o -= o * t[n].hysteresis), e < o)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Z1.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(Z1);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Z1.setFromMatrixPosition(e.matrixWorld), R3.setFromMatrixPosition(this.matrixWorld);
      const n = Z1.distanceTo(R3) / e.zoom;
      t[0].object.visible = !0;
      let i, o;
      for (i = 1, o = t.length; i < o; i++) {
        let l = t[i].distance;
        if (t[i].object.visible && (l -= l * t[i].hysteresis), n >= l)
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < o; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let i = 0, o = n.length; i < o; i++) {
      const l = n[i];
      t.object.levels.push({
        object: l.object.uuid,
        distance: l.distance,
        hysteresis: l.hysteresis
      });
    }
    return t;
  }
}
const x3 = /* @__PURE__ */ new fe(), W3 = /* @__PURE__ */ new Ha(), V3 = /* @__PURE__ */ new Ha(), W6 = /* @__PURE__ */ new fe(), N3 = /* @__PURE__ */ new _i(), w1 = /* @__PURE__ */ new fe(), UM = /* @__PURE__ */ new dg(), M3 = /* @__PURE__ */ new _i(), OM = /* @__PURE__ */ new Nb();
class tL extends kl {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = UH, this.bindMatrix = new _i(), this.bindMatrixInverse = new _i(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new nd()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, w1), this.boundingBox.expandByPoint(w1);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new dg()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, w1), this.boundingSphere.expandByPoint(w1);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, i = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), UM.copy(this.boundingSphere), UM.applyMatrix4(i), e.ray.intersectsSphere(UM) !== !1 && (M3.copy(i).invert(), OM.copy(e.ray).applyMatrix4(M3), !(this.boundingBox !== null && OM.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, OM)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Ha(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === UH ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === vK ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, i = this.geometry;
    W3.fromBufferAttribute(i.attributes.skinIndex, e), V3.fromBufferAttribute(i.attributes.skinWeight, e), x3.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const l = V3.getComponent(o);
      if (l !== 0) {
        const u = W3.getComponent(o);
        N3.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]), t.addScaledVector(W6.copy(x3).applyMatrix4(N3), l);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class mY extends qr {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class gp extends ks {
  constructor(e = null, t = 1, n = 1, i, o, l, u, I, C = Lu, f = Lu, v, b) {
    super(null, l, u, I, C, f, i, o, v, b), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const H3 = /* @__PURE__ */ new _i(), V6 = /* @__PURE__ */ new _i();
class OW {
  constructor(e = [], t = []) {
    this.uuid = PI(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new _i());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new _i();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o] ? e[o].matrixWorld : V6;
      H3.multiplyMatrices(u, t[o]), H3.toArray(n, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new OW(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new gp(t, e, e, cg, ed);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const o = e.bones[n];
      let l = t[o];
      l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", o), l = new mY()), this.bones.push(l), this.boneInverses.push(new _i().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let i = 0, o = t.length; i < o; i++) {
      const l = t[i];
      e.bones.push(l.uuid);
      const u = n[i];
      e.boneInverses.push(u.toArray());
    }
    return e;
  }
}
class pB extends ja {
  constructor(e, t, n, i = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const KG = /* @__PURE__ */ new _i(), X3 = /* @__PURE__ */ new _i(), R1 = [], Y3 = /* @__PURE__ */ new nd(), N6 = /* @__PURE__ */ new _i(), WZ = /* @__PURE__ */ new kl(), VZ = /* @__PURE__ */ new dg();
class lB extends kl {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new pB(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n; i++)
      this.setMatrixAt(i, N6);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new nd()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, KG), Y3.copy(e.boundingBox).applyMatrix4(KG), this.boundingBox.union(Y3);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new dg()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, KG), VZ.copy(e.boundingSphere).applyMatrix4(KG), this.boundingSphere.union(VZ);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, o = n.length + 1, l = e * o + 1;
    for (let u = 0; u < n.length; u++)
      n[u] = i[l + u];
  }
  raycast(e, t) {
    const n = this.matrixWorld, i = this.count;
    if (WZ.geometry = this.geometry, WZ.material = this.material, WZ.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), VZ.copy(this.boundingSphere), VZ.applyMatrix4(n), e.ray.intersectsSphere(VZ) !== !1))
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, KG), X3.multiplyMatrices(n, KG), WZ.matrixWorld = X3, WZ.raycast(e, R1);
        for (let l = 0, u = R1.length; l < u; l++) {
          const I = R1[l];
          I.instanceId = o, I.object = this, t.push(I);
        }
        R1.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new pB(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences, i = n.length + 1;
    this.morphTexture === null && (this.morphTexture = new gp(new Float32Array(i * this.count), i, this.count, YW, ed));
    const o = this.morphTexture.source.data.data;
    let l = 0;
    for (let C = 0; C < n.length; C++)
      l += n[C];
    const u = this.geometry.morphTargetsRelative ? 1 : 1 - l, I = i * e;
    o[I] = u, o.set(n, I + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
function M6(r, e) {
  return r.z - e.z;
}
function H6(r, e) {
  return e.z - r.z;
}
class X6 {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t, n) {
    const i = this.pool, o = this.list;
    this.index >= i.length && i.push({
      start: -1,
      count: -1,
      z: -1,
      index: -1
    });
    const l = i[this.index];
    o.push(l), this.index++, l.start = e.start, l.count = e.count, l.z = t, l.index = n;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const ov = /* @__PURE__ */ new _i(), PM = /* @__PURE__ */ new _i(), Y6 = /* @__PURE__ */ new _i(), F6 = /* @__PURE__ */ new ai(1, 1, 1), F3 = /* @__PURE__ */ new _i(), JM = /* @__PURE__ */ new tR(), x1 = /* @__PURE__ */ new nd(), Ly = /* @__PURE__ */ new dg(), NZ = /* @__PURE__ */ new fe(), E3 = /* @__PURE__ */ new fe(), E6 = /* @__PURE__ */ new fe(), QM = /* @__PURE__ */ new X6(), ng = /* @__PURE__ */ new kl(), W1 = [];
function T6(r, e, t = 0) {
  const n = e.itemSize;
  if (r.isInterleavedBufferAttribute || r.array.constructor !== e.array.constructor) {
    const i = r.count;
    for (let o = 0; o < i; o++)
      for (let l = 0; l < n; l++)
        e.setComponent(o + t, l, r.getComponent(o, l));
  } else
    e.array.set(r.array, t * n);
  e.needsUpdate = !0;
}
class nL extends kl {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  constructor(e, t, n = t * 2, i) {
    super(new Br(), i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawInfo = [], this._drawRanges = [], this._reservedRanges = [], this._bounds = [], this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new gp(t, e, e, cg, ed);
    this._matricesTexture = n;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e), n = new gp(t, e, e, jw, Pm);
    this._indirectTexture = n;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxIndexCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1), n = new gp(t, e, e, cg, ed);
    n.colorSpace = ya.workingColorSpace, this._colorsTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const l = e.getAttribute(o), { array: u, itemSize: I, normalized: C } = l, f = new u.constructor(n * I), v = new ja(f, I, C);
        t.setAttribute(o, v);
      }
      if (e.getIndex() !== null) {
        const o = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new ja(o, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (!e.hasAttribute(n))
        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const i = e.getAttribute(n), o = t.getAttribute(n);
      if (i.itemSize !== o.itemSize || i.normalized !== o.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new nd());
    const e = this._geometryCount, t = this.boundingBox, n = this._drawInfo;
    t.makeEmpty();
    for (let i = 0; i < e; i++) {
      if (n[i].active === !1) continue;
      const o = n[i].geometryIndex;
      this.getMatrixAt(i, ov), this.getBoundingBoxAt(o, x1).applyMatrix4(ov), t.union(x1);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new dg());
    const e = this.boundingSphere, t = this._drawInfo;
    e.makeEmpty();
    for (let n = 0, i = t.length; n < i; n++) {
      if (t[n].active === !1) continue;
      const o = t[n].geometryIndex;
      this.getMatrixAt(n, ov), this.getBoundingSphereAt(o, Ly).applyMatrix4(ov), e.union(Ly);
    }
  }
  addInstance(e) {
    if (this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    this._drawInfo.push({
      visible: !0,
      active: !0,
      geometryIndex: e
    });
    const t = this._drawInfo.length - 1, n = this._matricesTexture, i = n.image.data;
    Y6.toArray(i, t * 16), n.needsUpdate = !0;
    const o = this._colorsTexture;
    return o && (F6.toArray(o.image.data, t * 4), o.needsUpdate = !0), t;
  }
  addGeometry(e, t = -1, n = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1
    };
    let o = null;
    const l = this._reservedRanges, u = this._drawRanges, I = this._bounds;
    this._geometryCount !== 0 && (o = l[l.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, o === null ? i.vertexStart = 0 : i.vertexStart = o.vertexStart + o.vertexCount;
    const C = e.getIndex(), f = C !== null;
    if (f && (n === -1 ? i.indexCount = C.count : i.indexCount = n, o === null ? i.indexStart = 0 : i.indexStart = o.indexStart + o.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const v = this._geometryCount;
    return this._geometryCount++, l.push(i), u.push({
      start: f ? i.indexStart : i.vertexStart,
      count: -1
    }), I.push({
      boxInitialized: !1,
      box: new nd(),
      sphereInitialized: !1,
      sphere: new dg()
    }), this.setGeometryAt(v, e), v;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, i = n.getIndex() !== null, o = n.getIndex(), l = t.getIndex(), u = this._reservedRanges[e];
    if (i && l.count > u.indexCount || t.attributes.position.count > u.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const I = u.vertexStart, C = u.vertexCount;
    for (const S in n.attributes) {
      const R = t.getAttribute(S), W = n.getAttribute(S);
      T6(R, W, I);
      const x = R.itemSize;
      for (let N = R.count, Y = C; N < Y; N++) {
        const F = I + N;
        for (let T = 0; T < x; T++)
          W.setComponent(F, T, 0);
      }
      W.needsUpdate = !0, W.addUpdateRange(I * x, C * x);
    }
    if (i) {
      const S = u.indexStart;
      for (let R = 0; R < l.count; R++)
        o.setX(S + R, I + l.getX(R));
      for (let R = l.count, W = u.indexCount; R < W; R++)
        o.setX(S + R, I);
      o.needsUpdate = !0, o.addUpdateRange(S, u.indexCount);
    }
    const f = this._bounds[e];
    t.boundingBox !== null ? (f.box.copy(t.boundingBox), f.boxInitialized = !0) : f.boxInitialized = !1, t.boundingSphere !== null ? (f.sphere.copy(t.boundingSphere), f.sphereInitialized = !0) : f.sphereInitialized = !1;
    const v = this._drawRanges[e], b = t.getAttribute("position");
    return v.count = i ? l.count : b.count, this._visibilityChanged = !0, e;
  }
  /*
  	deleteGeometry( geometryId ) {
  
  		// TODO: delete geometry and associated instances
  
  	}
  	*/
  /*
  	deleteInstance( instanceId ) {
  
  		// Note: User needs to call optimize() afterward to pack the data.
  
  		const drawInfo = this._drawInfo;
  		if ( instanceId >= drawInfo.length || drawInfo[ instanceId ].active === false ) {
  
  			return this;
  
  		}
  
  		drawInfo[ instanceId ].active = false;
  		this._visibilityChanged = true;
  
  		return this;
  
  	}
  	*/
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const n = this._bounds[e], i = n.box, o = this.geometry;
    if (n.boxInitialized === !1) {
      i.makeEmpty();
      const l = o.index, u = o.attributes.position, I = this._drawRanges[e];
      for (let C = I.start, f = I.start + I.count; C < f; C++) {
        let v = C;
        l && (v = l.getX(v)), i.expandByPoint(NZ.fromBufferAttribute(u, v));
      }
      n.boxInitialized = !0;
    }
    return t.copy(i), t;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const n = this._bounds[e], i = n.sphere, o = this.geometry;
    if (n.sphereInitialized === !1) {
      i.makeEmpty(), this.getBoundingBoxAt(e, x1), x1.getCenter(i.center);
      const l = o.index, u = o.attributes.position, I = this._drawRanges[e];
      let C = 0;
      for (let f = I.start, v = I.start + I.count; f < v; f++) {
        let b = f;
        l && (b = l.getX(b)), NZ.fromBufferAttribute(u, b), C = Math.max(C, i.center.distanceToSquared(NZ));
      }
      i.radius = Math.sqrt(C), n.sphereInitialized = !0;
    }
    return t.copy(i), t;
  }
  setMatrixAt(e, t) {
    const n = this._drawInfo, i = this._matricesTexture, o = this._matricesTexture.image.data;
    return e >= n.length || n[e].active === !1 ? this : (t.toArray(o, e * 16), i.needsUpdate = !0, this);
  }
  getMatrixAt(e, t) {
    const n = this._drawInfo, i = this._matricesTexture.image.data;
    return e >= n.length || n[e].active === !1 ? null : t.fromArray(i, e * 16);
  }
  setColorAt(e, t) {
    this._colorsTexture === null && this._initColorsTexture();
    const n = this._colorsTexture, i = this._colorsTexture.image.data, o = this._drawInfo;
    return e >= o.length || o[e].active === !1 ? this : (t.toArray(i, e * 4), n.needsUpdate = !0, this);
  }
  getColorAt(e, t) {
    const n = this._colorsTexture.image.data, i = this._drawInfo;
    return e >= i.length || i[e].active === !1 ? null : t.fromArray(n, e * 4);
  }
  setVisibleAt(e, t) {
    const n = this._drawInfo;
    return e >= n.length || n[e].active === !1 || n[e].visible === t ? this : (n[e].visible = t, this._visibilityChanged = !0, this);
  }
  getVisibleAt(e) {
    const t = this._drawInfo;
    return e >= t.length || t[e].active === !1 ? !1 : t[e].visible;
  }
  raycast(e, t) {
    const n = this._drawInfo, i = this._drawRanges, o = this.matrixWorld, l = this.geometry;
    ng.material = this.material, ng.geometry.index = l.index, ng.geometry.attributes = l.attributes, ng.geometry.boundingBox === null && (ng.geometry.boundingBox = new nd()), ng.geometry.boundingSphere === null && (ng.geometry.boundingSphere = new dg());
    for (let u = 0, I = n.length; u < I; u++) {
      if (!n[u].visible || !n[u].active)
        continue;
      const C = n[u].geometryIndex, f = i[C];
      ng.geometry.setDrawRange(f.start, f.count), this.getMatrixAt(u, ng.matrixWorld).premultiply(o), this.getBoundingBoxAt(C, ng.geometry.boundingBox), this.getBoundingSphereAt(C, ng.geometry.boundingSphere), ng.raycast(e, W1);
      for (let v = 0, b = W1.length; v < b; v++) {
        const S = W1[v];
        S.object = this, S.batchId = u, t.push(S);
      }
      W1.length = 0;
    }
    ng.material = null, ng.geometry.index = null, ng.geometry.attributes = {}, ng.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._drawInfo = e._drawInfo.map((t) => ({ ...t })), this._bounds = e._bounds.map((t) => ({
      boxInitialized: t.boxInitialized,
      box: t.box.clone(),
      sphereInitialized: t.sphereInitialized,
      sphere: t.sphere.clone()
    })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null), this;
  }
  onBeforeRender(e, t, n, i, o) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const l = i.getIndex(), u = l === null ? 1 : l.array.BYTES_PER_ELEMENT, I = this._drawInfo, C = this._multiDrawStarts, f = this._multiDrawCounts, v = this._drawRanges, b = this.perObjectFrustumCulled, S = this._indirectTexture, R = S.image.data;
    b && (F3.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), JM.setFromProjectionMatrix(
      F3,
      e.coordinateSystem
    ));
    let W = 0;
    if (this.sortObjects) {
      PM.copy(this.matrixWorld).invert(), NZ.setFromMatrixPosition(n.matrixWorld).applyMatrix4(PM), E3.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(PM);
      for (let Y = 0, F = I.length; Y < F; Y++)
        if (I[Y].visible && I[Y].active) {
          const T = I[Y].geometryIndex;
          this.getMatrixAt(Y, ov), this.getBoundingSphereAt(T, Ly).applyMatrix4(ov);
          let P = !1;
          if (b && (P = !JM.intersectsSphere(Ly)), !P) {
            const D = E6.subVectors(Ly.center, NZ).dot(E3);
            QM.push(v[T], D, Y);
          }
        }
      const x = QM.list, N = this.customSort;
      N === null ? x.sort(o.transparent ? H6 : M6) : N.call(this, x, n);
      for (let Y = 0, F = x.length; Y < F; Y++) {
        const T = x[Y];
        C[W] = T.start * u, f[W] = T.count, R[W] = T.index, W++;
      }
      QM.reset();
    } else
      for (let x = 0, N = I.length; x < N; x++)
        if (I[x].visible && I[x].active) {
          const Y = I[x].geometryIndex;
          let F = !1;
          if (b && (this.getMatrixAt(x, ov), this.getBoundingSphereAt(Y, Ly).applyMatrix4(ov), F = !JM.intersectsSphere(Ly)), !F) {
            const T = v[Y];
            C[W] = T.start * u, f[W] = T.count, R[W] = x, W++;
          }
        }
    S.needsUpdate = !0, this._multiDrawCount = W, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, i, o, l) {
    this.onBeforeRender(e, null, i, o, l);
  }
}
class ad extends Cg {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new ai(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const eW = /* @__PURE__ */ new fe(), tW = /* @__PURE__ */ new fe(), T3 = /* @__PURE__ */ new _i(), MZ = /* @__PURE__ */ new Nb(), V1 = /* @__PURE__ */ new dg(), jM = /* @__PURE__ */ new fe(), _3 = /* @__PURE__ */ new fe();
class Gv extends qr {
  constructor(e = new Br(), t = new ad()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let i = 1, o = t.count; i < o; i++)
        eW.fromBufferAttribute(t, i - 1), tW.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += eW.distanceTo(tW);
      e.setAttribute("lineDistance", new fi(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, o = e.params.Line.threshold, l = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), V1.copy(n.boundingSphere), V1.applyMatrix4(i), V1.radius += o, e.ray.intersectsSphere(V1) === !1) return;
    T3.copy(i).invert(), MZ.copy(e.ray).applyMatrix4(T3);
    const u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), I = u * u, C = this.isLineSegments ? 2 : 1, f = n.index, b = n.attributes.position;
    if (f !== null) {
      const S = Math.max(0, l.start), R = Math.min(f.count, l.start + l.count);
      for (let W = S, x = R - 1; W < x; W += C) {
        const N = f.getX(W), Y = f.getX(W + 1), F = N1(this, e, MZ, I, N, Y);
        F && t.push(F);
      }
      if (this.isLineLoop) {
        const W = f.getX(R - 1), x = f.getX(S), N = N1(this, e, MZ, I, W, x);
        N && t.push(N);
      }
    } else {
      const S = Math.max(0, l.start), R = Math.min(b.count, l.start + l.count);
      for (let W = S, x = R - 1; W < x; W += C) {
        const N = N1(this, e, MZ, I, W, W + 1);
        N && t.push(N);
      }
      if (this.isLineLoop) {
        const W = N1(this, e, MZ, I, R - 1, S);
        W && t.push(W);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
}
function N1(r, e, t, n, i, o) {
  const l = r.geometry.attributes.position;
  if (eW.fromBufferAttribute(l, i), tW.fromBufferAttribute(l, o), t.distanceSqToSegment(eW, tW, jM, _3) > n) return;
  jM.applyMatrix4(r.matrixWorld);
  const I = e.ray.origin.distanceTo(jM);
  if (!(I < e.near || I > e.far))
    return {
      distance: I,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: _3.clone().applyMatrix4(r.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: r
    };
}
const z3 = /* @__PURE__ */ new fe(), K3 = /* @__PURE__ */ new fe();
class pp extends Gv {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let i = 0, o = t.count; i < o; i += 2)
        z3.fromBufferAttribute(t, i), K3.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + z3.distanceTo(K3);
      e.setAttribute("lineDistance", new fi(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class iL extends Gv {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class AY extends Cg {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new ai(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const L3 = /* @__PURE__ */ new _i(), qH = /* @__PURE__ */ new Nb(), M1 = /* @__PURE__ */ new dg(), H1 = /* @__PURE__ */ new fe();
class rL extends qr {
  constructor(e = new Br(), t = new AY()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, o = e.params.Points.threshold, l = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), M1.copy(n.boundingSphere), M1.applyMatrix4(i), M1.radius += o, e.ray.intersectsSphere(M1) === !1) return;
    L3.copy(i).invert(), qH.copy(e.ray).applyMatrix4(L3);
    const u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), I = u * u, C = n.index, v = n.attributes.position;
    if (C !== null) {
      const b = Math.max(0, l.start), S = Math.min(C.count, l.start + l.count);
      for (let R = b, W = S; R < W; R++) {
        const x = C.getX(R);
        H1.fromBufferAttribute(v, x), k3(H1, x, I, i, e, t, this);
      }
    } else {
      const b = Math.max(0, l.start), S = Math.min(v.count, l.start + l.count);
      for (let R = b, W = S; R < W; R++)
        H1.fromBufferAttribute(v, R), k3(H1, R, I, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
}
function k3(r, e, t, n, i, o, l) {
  const u = qH.distanceSqToPoint(r);
  if (u < t) {
    const I = new fe();
    qH.closestPointToPoint(r, I), I.applyMatrix4(n);
    const C = i.ray.origin.distanceTo(I);
    if (C < i.near || C > i.far) return;
    o.push({
      distance: C,
      distanceToRay: Math.sqrt(u),
      point: I,
      index: e,
      face: null,
      object: l
    });
  }
}
class _6 extends ks {
  constructor(e, t, n, i, o, l, u, I, C) {
    super(e, t, n, i, o, l, u, I, C), this.isVideoTexture = !0, this.minFilter = l !== void 0 ? l : Ks, this.magFilter = o !== void 0 ? o : Ks, this.generateMipmaps = !1;
    const f = this;
    function v() {
      f.needsUpdate = !0, e.requestVideoFrameCallback(v);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(v);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class z6 extends ks {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = Lu, this.minFilter = Lu, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class PW extends ks {
  constructor(e, t, n, i, o, l, u, I, C, f, v, b) {
    super(null, l, u, I, C, f, i, o, v, b), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class K6 extends PW {
  constructor(e, t, n, i, o, l) {
    super(e, t, n, o, l), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = PC, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class L6 extends PW {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, Om), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class k6 extends ks {
  constructor(e, t, n, i, o, l, u, I, C) {
    super(e, t, n, i, o, l, u, I, C), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class af {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, i = this.getPoint(0), o = 0;
    t.push(0);
    for (let l = 1; l <= e; l++)
      n = this.getPoint(l / e), o += n.distanceTo(i), t.push(o), i = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const o = n.length;
    let l;
    t ? l = t : l = e * n[o - 1];
    let u = 0, I = o - 1, C;
    for (; u <= I; )
      if (i = Math.floor(u + (I - u) / 2), C = n[i] - l, C < 0)
        u = i + 1;
      else if (C > 0)
        I = i - 1;
      else {
        I = i;
        break;
      }
    if (i = I, n[i] === l)
      return i / (o - 1);
    const f = n[i], b = n[i + 1] - f, S = (l - f) / b;
    return (i + S) / (o - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let i = e - 1e-4, o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const l = this.getPoint(i), u = this.getPoint(o), I = t || (l.isVector2 ? new Lt() : new fe());
    return I.copy(u).sub(l).normalize(), I;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new fe(), i = [], o = [], l = [], u = new fe(), I = new _i();
    for (let S = 0; S <= e; S++) {
      const R = S / e;
      i[S] = this.getTangentAt(R, new fe());
    }
    o[0] = new fe(), l[0] = new fe();
    let C = Number.MAX_VALUE;
    const f = Math.abs(i[0].x), v = Math.abs(i[0].y), b = Math.abs(i[0].z);
    f <= C && (C = f, n.set(1, 0, 0)), v <= C && (C = v, n.set(0, 1, 0)), b <= C && n.set(0, 0, 1), u.crossVectors(i[0], n).normalize(), o[0].crossVectors(i[0], u), l[0].crossVectors(i[0], o[0]);
    for (let S = 1; S <= e; S++) {
      if (o[S] = o[S - 1].clone(), l[S] = l[S - 1].clone(), u.crossVectors(i[S - 1], i[S]), u.length() > Number.EPSILON) {
        u.normalize();
        const R = Math.acos(zs(i[S - 1].dot(i[S]), -1, 1));
        o[S].applyMatrix4(I.makeRotationAxis(u, R));
      }
      l[S].crossVectors(i[S], o[S]);
    }
    if (t === !0) {
      let S = Math.acos(zs(o[0].dot(o[e]), -1, 1));
      S /= e, i[0].dot(u.crossVectors(o[0], o[e])) > 0 && (S = -S);
      for (let R = 1; R <= e; R++)
        o[R].applyMatrix4(I.makeRotationAxis(i[R], S * R)), l[R].crossVectors(i[R], o[R]);
    }
    return {
      tangents: i,
      normals: o,
      binormals: l
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class JW extends af {
  constructor(e = 0, t = 0, n = 1, i = 1, o = 0, l = Math.PI * 2, u = !1, I = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = o, this.aEndAngle = l, this.aClockwise = u, this.aRotation = I;
  }
  getPoint(e, t = new Lt()) {
    const n = t, i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const l = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += i;
    for (; o > i; ) o -= i;
    o < Number.EPSILON && (l ? o = 0 : o = i), this.aClockwise === !0 && !l && (o === i ? o = -i : o = o - i);
    const u = this.aStartAngle + e * o;
    let I = this.aX + this.xRadius * Math.cos(u), C = this.aY + this.yRadius * Math.sin(u);
    if (this.aRotation !== 0) {
      const f = Math.cos(this.aRotation), v = Math.sin(this.aRotation), b = I - this.aX, S = C - this.aY;
      I = b * f - S * v + this.aX, C = b * v + S * f + this.aY;
    }
    return n.set(I, C);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class aL extends JW {
  constructor(e, t, n, i, o, l) {
    super(e, t, n, n, i, o, l), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function vY() {
  let r = 0, e = 0, t = 0, n = 0;
  function i(o, l, u, I) {
    r = o, e = u, t = -3 * o + 3 * l - 2 * u - I, n = 2 * o - 2 * l + u + I;
  }
  return {
    initCatmullRom: function(o, l, u, I, C) {
      i(l, u, C * (u - o), C * (I - l));
    },
    initNonuniformCatmullRom: function(o, l, u, I, C, f, v) {
      let b = (l - o) / C - (u - o) / (C + f) + (u - l) / f, S = (u - l) / f - (I - l) / (f + v) + (I - u) / v;
      b *= f, S *= f, i(l, u, b, S);
    },
    calc: function(o) {
      const l = o * o, u = l * o;
      return r + e * o + t * l + n * u;
    }
  };
}
const X1 = /* @__PURE__ */ new fe(), qM = /* @__PURE__ */ new vY(), $M = /* @__PURE__ */ new vY(), eH = /* @__PURE__ */ new vY();
class oL extends af {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
  }
  getPoint(e, t = new fe()) {
    const n = t, i = this.points, o = i.length, l = (o - (this.closed ? 0 : 1)) * e;
    let u = Math.floor(l), I = l - u;
    this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / o) + 1) * o : I === 0 && u === o - 1 && (u = o - 2, I = 1);
    let C, f;
    this.closed || u > 0 ? C = i[(u - 1) % o] : (X1.subVectors(i[0], i[1]).add(i[0]), C = X1);
    const v = i[u % o], b = i[(u + 1) % o];
    if (this.closed || u + 2 < o ? f = i[(u + 2) % o] : (X1.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), f = X1), this.curveType === "centripetal" || this.curveType === "chordal") {
      const S = this.curveType === "chordal" ? 0.5 : 0.25;
      let R = Math.pow(C.distanceToSquared(v), S), W = Math.pow(v.distanceToSquared(b), S), x = Math.pow(b.distanceToSquared(f), S);
      W < 1e-4 && (W = 1), R < 1e-4 && (R = W), x < 1e-4 && (x = W), qM.initNonuniformCatmullRom(C.x, v.x, b.x, f.x, R, W, x), $M.initNonuniformCatmullRom(C.y, v.y, b.y, f.y, R, W, x), eH.initNonuniformCatmullRom(C.z, v.z, b.z, f.z, R, W, x);
    } else this.curveType === "catmullrom" && (qM.initCatmullRom(C.x, v.x, b.x, f.x, this.tension), $M.initCatmullRom(C.y, v.y, b.y, f.y, this.tension), eH.initCatmullRom(C.z, v.z, b.z, f.z, this.tension));
    return n.set(
      qM.calc(I),
      $M.calc(I),
      eH.calc(I)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new fe().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function D3(r, e, t, n, i) {
  const o = (n - e) * 0.5, l = (i - t) * 0.5, u = r * r, I = r * u;
  return (2 * t - 2 * n + o + l) * I + (-3 * t + 3 * n - 2 * o - l) * u + o * r + t;
}
function D6(r, e) {
  const t = 1 - r;
  return t * t * e;
}
function U6(r, e) {
  return 2 * (1 - r) * r * e;
}
function O6(r, e) {
  return r * r * e;
}
function rw(r, e, t, n) {
  return D6(r, e) + U6(r, t) + O6(r, n);
}
function P6(r, e) {
  const t = 1 - r;
  return t * t * t * e;
}
function J6(r, e) {
  const t = 1 - r;
  return 3 * t * t * r * e;
}
function Q6(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function j6(r, e) {
  return r * r * r * e;
}
function aw(r, e, t, n, i) {
  return P6(r, e) + J6(r, t) + Q6(r, n) + j6(r, i);
}
class yY extends af {
  constructor(e = new Lt(), t = new Lt(), n = new Lt(), i = new Lt()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new Lt()) {
    const n = t, i = this.v0, o = this.v1, l = this.v2, u = this.v3;
    return n.set(
      aw(e, i.x, o.x, l.x, u.x),
      aw(e, i.y, o.y, l.y, u.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class sL extends af {
  constructor(e = new fe(), t = new fe(), n = new fe(), i = new fe()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new fe()) {
    const n = t, i = this.v0, o = this.v1, l = this.v2, u = this.v3;
    return n.set(
      aw(e, i.x, o.x, l.x, u.x),
      aw(e, i.y, o.y, l.y, u.y),
      aw(e, i.z, o.z, l.z, u.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class bY extends af {
  constructor(e = new Lt(), t = new Lt()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Lt()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Lt()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class lL extends af {
  constructor(e = new fe(), t = new fe()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new fe()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new fe()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class GY extends af {
  constructor(e = new Lt(), t = new Lt(), n = new Lt()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new Lt()) {
    const n = t, i = this.v0, o = this.v1, l = this.v2;
    return n.set(
      rw(e, i.x, o.x, l.x),
      rw(e, i.y, o.y, l.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class BY extends af {
  constructor(e = new fe(), t = new fe(), n = new fe()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new fe()) {
    const n = t, i = this.v0, o = this.v1, l = this.v2;
    return n.set(
      rw(e, i.x, o.x, l.x),
      rw(e, i.y, o.y, l.y),
      rw(e, i.z, o.z, l.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class SY extends af {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Lt()) {
    const n = t, i = this.points, o = (i.length - 1) * e, l = Math.floor(o), u = o - l, I = i[l === 0 ? l : l - 1], C = i[l], f = i[l > i.length - 2 ? i.length - 1 : l + 1], v = i[l > i.length - 3 ? i.length - 1 : l + 2];
    return n.set(
      D3(u, I.x, C.x, f.x, v.x),
      D3(u, I.y, C.y, f.y, v.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new Lt().fromArray(i));
    }
    return this;
  }
}
var nW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: aL,
  CatmullRomCurve3: oL,
  CubicBezierCurve: yY,
  CubicBezierCurve3: sL,
  EllipseCurve: JW,
  LineCurve: bY,
  LineCurve3: lL,
  QuadraticBezierCurve: GY,
  QuadraticBezierCurve3: BY,
  SplineCurve: SY
});
class uL extends af {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new nW[n](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= n) {
        const l = i[o] - n, u = this.curves[o], I = u.getLength(), C = I === 0 ? 0 : 1 - l / I;
        return u.getPointAt(C, t);
      }
      o++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const l = o[i], u = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e, I = l.getPoints(u);
      for (let C = 0; C < I.length; C++) {
        const f = I[C];
        n && n.equals(f) || (t.push(f), n = f);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new nW[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Vw extends uL {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Lt(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new bY(this.currentPoint.clone(), new Lt(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const o = new GY(
      this.currentPoint.clone(),
      new Lt(e, t),
      new Lt(n, i)
    );
    return this.curves.push(o), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, o, l) {
    const u = new yY(
      this.currentPoint.clone(),
      new Lt(e, t),
      new Lt(n, i),
      new Lt(o, l)
    );
    return this.curves.push(u), this.currentPoint.set(o, l), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new SY(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, o, l) {
    const u = this.currentPoint.x, I = this.currentPoint.y;
    return this.absarc(
      e + u,
      t + I,
      n,
      i,
      o,
      l
    ), this;
  }
  absarc(e, t, n, i, o, l) {
    return this.absellipse(e, t, n, n, i, o, l), this;
  }
  ellipse(e, t, n, i, o, l, u, I) {
    const C = this.currentPoint.x, f = this.currentPoint.y;
    return this.absellipse(e + C, t + f, n, i, o, l, u, I), this;
  }
  absellipse(e, t, n, i, o, l, u, I) {
    const C = new JW(e, t, n, i, o, l, u, I);
    if (this.curves.length > 0) {
      const v = C.getPoint(0);
      v.equals(this.currentPoint) || this.lineTo(v.x, v.y);
    }
    this.curves.push(C);
    const f = C.getPoint(1);
    return this.currentPoint.copy(f), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class nR extends Br {
  constructor(e = [new Lt(0, -0.5), new Lt(0.5, 0), new Lt(0, 0.5)], t = 12, n = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: i
    }, t = Math.floor(t), i = zs(i, 0, Math.PI * 2);
    const o = [], l = [], u = [], I = [], C = [], f = 1 / t, v = new fe(), b = new Lt(), S = new fe(), R = new fe(), W = new fe();
    let x = 0, N = 0;
    for (let Y = 0; Y <= e.length - 1; Y++)
      switch (Y) {
        case 0:
          x = e[Y + 1].x - e[Y].x, N = e[Y + 1].y - e[Y].y, S.x = N * 1, S.y = -x, S.z = N * 0, W.copy(S), S.normalize(), I.push(S.x, S.y, S.z);
          break;
        case e.length - 1:
          I.push(W.x, W.y, W.z);
          break;
        default:
          x = e[Y + 1].x - e[Y].x, N = e[Y + 1].y - e[Y].y, S.x = N * 1, S.y = -x, S.z = N * 0, R.copy(S), S.x += W.x, S.y += W.y, S.z += W.z, S.normalize(), I.push(S.x, S.y, S.z), W.copy(R);
      }
    for (let Y = 0; Y <= t; Y++) {
      const F = n + Y * f * i, T = Math.sin(F), P = Math.cos(F);
      for (let D = 0; D <= e.length - 1; D++) {
        v.x = e[D].x * T, v.y = e[D].y, v.z = e[D].x * P, l.push(v.x, v.y, v.z), b.x = Y / t, b.y = D / (e.length - 1), u.push(b.x, b.y);
        const L = I[3 * D + 0] * T, j = I[3 * D + 1], J = I[3 * D + 0] * P;
        C.push(L, j, J);
      }
    }
    for (let Y = 0; Y < t; Y++)
      for (let F = 0; F < e.length - 1; F++) {
        const T = F + Y * e.length, P = T, D = T + e.length, L = T + e.length + 1, j = T + 1;
        o.push(P, D, j), o.push(L, j, D);
      }
    this.setIndex(o), this.setAttribute("position", new fi(l, 3)), this.setAttribute("uv", new fi(u, 2)), this.setAttribute("normal", new fi(C, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new nR(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class QW extends nR {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const o = new Vw();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0), o.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(o.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: n,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new QW(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class jW extends Br {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: i
    }, t = Math.max(3, t);
    const o = [], l = [], u = [], I = [], C = new fe(), f = new Lt();
    l.push(0, 0, 0), u.push(0, 0, 1), I.push(0.5, 0.5);
    for (let v = 0, b = 3; v <= t; v++, b += 3) {
      const S = n + v / t * i;
      C.x = e * Math.cos(S), C.y = e * Math.sin(S), l.push(C.x, C.y, C.z), u.push(0, 0, 1), f.x = (l[b] / e + 1) / 2, f.y = (l[b + 1] / e + 1) / 2, I.push(f.x, f.y);
    }
    for (let v = 1; v <= t; v++)
      o.push(v, v + 1, 0);
    this.setIndex(o), this.setAttribute("position", new fi(l, 3)), this.setAttribute("normal", new fi(u, 3)), this.setAttribute("uv", new fi(I, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new jW(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class NB extends Br {
  constructor(e = 1, t = 1, n = 1, i = 32, o = 1, l = !1, u = 0, I = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: i,
      heightSegments: o,
      openEnded: l,
      thetaStart: u,
      thetaLength: I
    };
    const C = this;
    i = Math.floor(i), o = Math.floor(o);
    const f = [], v = [], b = [], S = [];
    let R = 0;
    const W = [], x = n / 2;
    let N = 0;
    Y(), l === !1 && (e > 0 && F(!0), t > 0 && F(!1)), this.setIndex(f), this.setAttribute("position", new fi(v, 3)), this.setAttribute("normal", new fi(b, 3)), this.setAttribute("uv", new fi(S, 2));
    function Y() {
      const T = new fe(), P = new fe();
      let D = 0;
      const L = (t - e) / n;
      for (let j = 0; j <= o; j++) {
        const J = [], O = j / o, ne = O * (t - e) + e;
        for (let he = 0; he <= i; he++) {
          const pe = he / i, Ae = pe * I + u, ke = Math.sin(Ae), Re = Math.cos(Ae);
          P.x = ne * ke, P.y = -O * n + x, P.z = ne * Re, v.push(P.x, P.y, P.z), T.set(ke, L, Re).normalize(), b.push(T.x, T.y, T.z), S.push(pe, 1 - O), J.push(R++);
        }
        W.push(J);
      }
      for (let j = 0; j < i; j++)
        for (let J = 0; J < o; J++) {
          const O = W[J][j], ne = W[J + 1][j], he = W[J + 1][j + 1], pe = W[J][j + 1];
          f.push(O, ne, pe), f.push(ne, he, pe), D += 6;
        }
      C.addGroup(N, D, 0), N += D;
    }
    function F(T) {
      const P = R, D = new Lt(), L = new fe();
      let j = 0;
      const J = T === !0 ? e : t, O = T === !0 ? 1 : -1;
      for (let he = 1; he <= i; he++)
        v.push(0, x * O, 0), b.push(0, O, 0), S.push(0.5, 0.5), R++;
      const ne = R;
      for (let he = 0; he <= i; he++) {
        const Ae = he / i * I + u, ke = Math.cos(Ae), Re = Math.sin(Ae);
        L.x = J * Re, L.y = x * O, L.z = J * ke, v.push(L.x, L.y, L.z), b.push(0, O, 0), D.x = ke * 0.5 + 0.5, D.y = Re * 0.5 * O + 0.5, S.push(D.x, D.y), R++;
      }
      for (let he = 0; he < i; he++) {
        const pe = P + he, Ae = ne + he;
        T === !0 ? f.push(Ae, Ae + 1, pe) : f.push(Ae + 1, Ae, pe), j += 3;
      }
      C.addGroup(N, j, T === !0 ? 1 : 2), N += j;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new NB(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class qW extends NB {
  constructor(e = 1, t = 1, n = 32, i = 1, o = !1, l = 0, u = Math.PI * 2) {
    super(0, e, t, n, i, o, l, u), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: i,
      openEnded: o,
      thetaStart: l,
      thetaLength: u
    };
  }
  static fromJSON(e) {
    return new qW(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Rv extends Br {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: i
    };
    const o = [], l = [];
    u(i), C(n), f(), this.setAttribute("position", new fi(o, 3)), this.setAttribute("normal", new fi(o.slice(), 3)), this.setAttribute("uv", new fi(l, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function u(Y) {
      const F = new fe(), T = new fe(), P = new fe();
      for (let D = 0; D < t.length; D += 3)
        S(t[D + 0], F), S(t[D + 1], T), S(t[D + 2], P), I(F, T, P, Y);
    }
    function I(Y, F, T, P) {
      const D = P + 1, L = [];
      for (let j = 0; j <= D; j++) {
        L[j] = [];
        const J = Y.clone().lerp(T, j / D), O = F.clone().lerp(T, j / D), ne = D - j;
        for (let he = 0; he <= ne; he++)
          he === 0 && j === D ? L[j][he] = J : L[j][he] = J.clone().lerp(O, he / ne);
      }
      for (let j = 0; j < D; j++)
        for (let J = 0; J < 2 * (D - j) - 1; J++) {
          const O = Math.floor(J / 2);
          J % 2 === 0 ? (b(L[j][O + 1]), b(L[j + 1][O]), b(L[j][O])) : (b(L[j][O + 1]), b(L[j + 1][O + 1]), b(L[j + 1][O]));
        }
    }
    function C(Y) {
      const F = new fe();
      for (let T = 0; T < o.length; T += 3)
        F.x = o[T + 0], F.y = o[T + 1], F.z = o[T + 2], F.normalize().multiplyScalar(Y), o[T + 0] = F.x, o[T + 1] = F.y, o[T + 2] = F.z;
    }
    function f() {
      const Y = new fe();
      for (let F = 0; F < o.length; F += 3) {
        Y.x = o[F + 0], Y.y = o[F + 1], Y.z = o[F + 2];
        const T = x(Y) / 2 / Math.PI + 0.5, P = N(Y) / Math.PI + 0.5;
        l.push(T, 1 - P);
      }
      R(), v();
    }
    function v() {
      for (let Y = 0; Y < l.length; Y += 6) {
        const F = l[Y + 0], T = l[Y + 2], P = l[Y + 4], D = Math.max(F, T, P), L = Math.min(F, T, P);
        D > 0.9 && L < 0.1 && (F < 0.2 && (l[Y + 0] += 1), T < 0.2 && (l[Y + 2] += 1), P < 0.2 && (l[Y + 4] += 1));
      }
    }
    function b(Y) {
      o.push(Y.x, Y.y, Y.z);
    }
    function S(Y, F) {
      const T = Y * 3;
      F.x = e[T + 0], F.y = e[T + 1], F.z = e[T + 2];
    }
    function R() {
      const Y = new fe(), F = new fe(), T = new fe(), P = new fe(), D = new Lt(), L = new Lt(), j = new Lt();
      for (let J = 0, O = 0; J < o.length; J += 9, O += 6) {
        Y.set(o[J + 0], o[J + 1], o[J + 2]), F.set(o[J + 3], o[J + 4], o[J + 5]), T.set(o[J + 6], o[J + 7], o[J + 8]), D.set(l[O + 0], l[O + 1]), L.set(l[O + 2], l[O + 3]), j.set(l[O + 4], l[O + 5]), P.copy(Y).add(F).add(T).divideScalar(3);
        const ne = x(P);
        W(D, O + 0, Y, ne), W(L, O + 2, F, ne), W(j, O + 4, T, ne);
      }
    }
    function W(Y, F, T, P) {
      P < 0 && Y.x === 1 && (l[F] = Y.x - 1), T.x === 0 && T.z === 0 && (l[F] = P / 2 / Math.PI + 0.5);
    }
    function x(Y) {
      return Math.atan2(Y.z, -Y.x);
    }
    function N(Y) {
      return Math.atan2(-Y.y, Math.sqrt(Y.x * Y.x + Y.z * Y.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Rv(e.vertices, e.indices, e.radius, e.details);
  }
}
class $W extends Rv {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, o = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      // (1/, , 0)
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      0,
      // (, 0, 1/)
      -n,
      0,
      -i,
      n,
      0,
      -i,
      -n,
      0,
      i,
      n,
      0,
      i
    ], l = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(o, l, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new $W(e.radius, e.detail);
  }
}
const Y1 = /* @__PURE__ */ new fe(), F1 = /* @__PURE__ */ new fe(), tH = /* @__PURE__ */ new fe(), E1 = /* @__PURE__ */ new DI();
class cL extends Br {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), o = Math.cos(fb * t), l = e.getIndex(), u = e.getAttribute("position"), I = l ? l.count : u.count, C = [0, 0, 0], f = ["a", "b", "c"], v = new Array(3), b = {}, S = [];
      for (let R = 0; R < I; R += 3) {
        l ? (C[0] = l.getX(R), C[1] = l.getX(R + 1), C[2] = l.getX(R + 2)) : (C[0] = R, C[1] = R + 1, C[2] = R + 2);
        const { a: W, b: x, c: N } = E1;
        if (W.fromBufferAttribute(u, C[0]), x.fromBufferAttribute(u, C[1]), N.fromBufferAttribute(u, C[2]), E1.getNormal(tH), v[0] = `${Math.round(W.x * i)},${Math.round(W.y * i)},${Math.round(W.z * i)}`, v[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(x.z * i)}`, v[2] = `${Math.round(N.x * i)},${Math.round(N.y * i)},${Math.round(N.z * i)}`, !(v[0] === v[1] || v[1] === v[2] || v[2] === v[0]))
          for (let Y = 0; Y < 3; Y++) {
            const F = (Y + 1) % 3, T = v[Y], P = v[F], D = E1[f[Y]], L = E1[f[F]], j = `${T}_${P}`, J = `${P}_${T}`;
            J in b && b[J] ? (tH.dot(b[J].normal) <= o && (S.push(D.x, D.y, D.z), S.push(L.x, L.y, L.z)), b[J] = null) : j in b || (b[j] = {
              index0: C[Y],
              index1: C[F],
              normal: tH.clone()
            });
          }
      }
      for (const R in b)
        if (b[R]) {
          const { index0: W, index1: x } = b[R];
          Y1.fromBufferAttribute(u, W), F1.fromBufferAttribute(u, x), S.push(Y1.x, Y1.y, Y1.z), S.push(F1.x, F1.y, F1.z);
        }
      this.setAttribute("position", new fi(S, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
let mb = class extends Vw {
  constructor(e) {
    super(e), this.uuid = PI(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new Vw().fromJSON(i));
    }
    return this;
  }
};
const q6 = {
  triangulate: function(r, e, t = 2) {
    const n = e && e.length, i = n ? e[0] * t : r.length;
    let o = gL(r, 0, i, t, !0);
    const l = [];
    if (!o || o.next === o.prev) return l;
    let u, I, C, f, v, b, S;
    if (n && (o = i$(r, e, o, t)), r.length > 80 * t) {
      u = C = r[0], I = f = r[1];
      for (let R = t; R < i; R += t)
        v = r[R], b = r[R + 1], v < u && (u = v), b < I && (I = b), v > C && (C = v), b > f && (f = b);
      S = Math.max(C - u, f - I), S = S !== 0 ? 32767 / S : 0;
    }
    return Nw(o, l, t, u, I, S, 0), l;
  }
};
function gL(r, e, t, n, i) {
  let o, l;
  if (i === C$(r, e, t, n) > 0)
    for (o = e; o < t; o += n) l = U3(o, r[o], r[o + 1], l);
  else
    for (o = t - n; o >= e; o -= n) l = U3(o, r[o], r[o + 1], l);
  return l && eV(l, l.next) && (Hw(l), l = l.next), l;
}
function wb(r, e) {
  if (!r) return r;
  e || (e = r);
  let t = r, n;
  do
    if (n = !1, !t.steiner && (eV(t, t.next) || vs(t.prev, t, t.next) === 0)) {
      if (Hw(t), t = e = t.prev, t === t.next) break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function Nw(r, e, t, n, i, o, l) {
  if (!r) return;
  !l && o && l$(r, n, i, o);
  let u = r, I, C;
  for (; r.prev !== r.next; ) {
    if (I = r.prev, C = r.next, o ? e$(r, n, i, o) : $6(r)) {
      e.push(I.i / t | 0), e.push(r.i / t | 0), e.push(C.i / t | 0), Hw(r), r = C.next, u = C.next;
      continue;
    }
    if (r = C, r === u) {
      l ? l === 1 ? (r = t$(wb(r), e, t), Nw(r, e, t, n, i, o, 2)) : l === 2 && n$(r, e, t, n, i, o) : Nw(wb(r), e, t, n, i, o, 1);
      break;
    }
  }
}
function $6(r) {
  const e = r.prev, t = r, n = r.next;
  if (vs(e, t, n) >= 0) return !1;
  const i = e.x, o = t.x, l = n.x, u = e.y, I = t.y, C = n.y, f = i < o ? i < l ? i : l : o < l ? o : l, v = u < I ? u < C ? u : C : I < C ? I : C, b = i > o ? i > l ? i : l : o > l ? o : l, S = u > I ? u > C ? u : C : I > C ? I : C;
  let R = n.next;
  for (; R !== e; ) {
    if (R.x >= f && R.x <= b && R.y >= v && R.y <= S && nB(i, u, o, I, l, C, R.x, R.y) && vs(R.prev, R, R.next) >= 0) return !1;
    R = R.next;
  }
  return !0;
}
function e$(r, e, t, n) {
  const i = r.prev, o = r, l = r.next;
  if (vs(i, o, l) >= 0) return !1;
  const u = i.x, I = o.x, C = l.x, f = i.y, v = o.y, b = l.y, S = u < I ? u < C ? u : C : I < C ? I : C, R = f < v ? f < b ? f : b : v < b ? v : b, W = u > I ? u > C ? u : C : I > C ? I : C, x = f > v ? f > b ? f : b : v > b ? v : b, N = $H(S, R, e, t, n), Y = $H(W, x, e, t, n);
  let F = r.prevZ, T = r.nextZ;
  for (; F && F.z >= N && T && T.z <= Y; ) {
    if (F.x >= S && F.x <= W && F.y >= R && F.y <= x && F !== i && F !== l && nB(u, f, I, v, C, b, F.x, F.y) && vs(F.prev, F, F.next) >= 0 || (F = F.prevZ, T.x >= S && T.x <= W && T.y >= R && T.y <= x && T !== i && T !== l && nB(u, f, I, v, C, b, T.x, T.y) && vs(T.prev, T, T.next) >= 0)) return !1;
    T = T.nextZ;
  }
  for (; F && F.z >= N; ) {
    if (F.x >= S && F.x <= W && F.y >= R && F.y <= x && F !== i && F !== l && nB(u, f, I, v, C, b, F.x, F.y) && vs(F.prev, F, F.next) >= 0) return !1;
    F = F.prevZ;
  }
  for (; T && T.z <= Y; ) {
    if (T.x >= S && T.x <= W && T.y >= R && T.y <= x && T !== i && T !== l && nB(u, f, I, v, C, b, T.x, T.y) && vs(T.prev, T, T.next) >= 0) return !1;
    T = T.nextZ;
  }
  return !0;
}
function t$(r, e, t) {
  let n = r;
  do {
    const i = n.prev, o = n.next.next;
    !eV(i, o) && dL(i, n, n.next, o) && Mw(i, o) && Mw(o, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(o.i / t | 0), Hw(n), Hw(n.next), n = r = o), n = n.next;
  } while (n !== r);
  return wb(n);
}
function n$(r, e, t, n, i, o) {
  let l = r;
  do {
    let u = l.next.next;
    for (; u !== l.prev; ) {
      if (l.i !== u.i && g$(l, u)) {
        let I = IL(l, u);
        l = wb(l, l.next), I = wb(I, I.next), Nw(l, e, t, n, i, o, 0), Nw(I, e, t, n, i, o, 0);
        return;
      }
      u = u.next;
    }
    l = l.next;
  } while (l !== r);
}
function i$(r, e, t, n) {
  const i = [];
  let o, l, u, I, C;
  for (o = 0, l = e.length; o < l; o++)
    u = e[o] * n, I = o < l - 1 ? e[o + 1] * n : r.length, C = gL(r, u, I, n, !1), C === C.next && (C.steiner = !0), i.push(c$(C));
  for (i.sort(r$), o = 0; o < i.length; o++)
    t = a$(i[o], t);
  return t;
}
function r$(r, e) {
  return r.x - e.x;
}
function a$(r, e) {
  const t = o$(r, e);
  if (!t)
    return e;
  const n = IL(t, r);
  return wb(n, n.next), wb(t, t.next);
}
function o$(r, e) {
  let t = e, n = -1 / 0, i;
  const o = r.x, l = r.y;
  do {
    if (l <= t.y && l >= t.next.y && t.next.y !== t.y) {
      const b = t.x + (l - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (b <= o && b > n && (n = b, i = t.x < t.next.x ? t : t.next, b === o))
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const u = i, I = i.x, C = i.y;
  let f = 1 / 0, v;
  t = i;
  do
    o >= t.x && t.x >= I && o !== t.x && nB(l < C ? o : n, l, I, C, l < C ? n : o, l, t.x, t.y) && (v = Math.abs(l - t.y) / (o - t.x), Mw(t, r) && (v < f || v === f && (t.x > i.x || t.x === i.x && s$(i, t))) && (i = t, f = v)), t = t.next;
  while (t !== u);
  return i;
}
function s$(r, e) {
  return vs(r.prev, r, e.prev) < 0 && vs(e.next, r, r.next) < 0;
}
function l$(r, e, t, n) {
  let i = r;
  do
    i.z === 0 && (i.z = $H(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== r);
  i.prevZ.nextZ = null, i.prevZ = null, u$(i);
}
function u$(r) {
  let e, t, n, i, o, l, u, I, C = 1;
  do {
    for (t = r, r = null, o = null, l = 0; t; ) {
      for (l++, n = t, u = 0, e = 0; e < C && (u++, n = n.nextZ, !!n); e++)
        ;
      for (I = C; u > 0 || I > 0 && n; )
        u !== 0 && (I === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, u--) : (i = n, n = n.nextZ, I--), o ? o.nextZ = i : r = i, i.prevZ = o, o = i;
      t = n;
    }
    o.nextZ = null, C *= 2;
  } while (l > 1);
  return r;
}
function $H(r, e, t, n, i) {
  return r = (r - t) * i | 0, e = (e - n) * i | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1;
}
function c$(r) {
  let e = r, t = r;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== r);
  return t;
}
function nB(r, e, t, n, i, o, l, u) {
  return (i - l) * (e - u) >= (r - l) * (o - u) && (r - l) * (n - u) >= (t - l) * (e - u) && (t - l) * (o - u) >= (i - l) * (n - u);
}
function g$(r, e) {
  return r.next.i !== e.i && r.prev.i !== e.i && !d$(r, e) && // dones't intersect other edges
  (Mw(r, e) && Mw(e, r) && I$(r, e) && // locally visible
  (vs(r.prev, r, e.prev) || vs(r, e.prev, e)) || // does not create opposite-facing sectors
  eV(r, e) && vs(r.prev, r, r.next) > 0 && vs(e.prev, e, e.next) > 0);
}
function vs(r, e, t) {
  return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
}
function eV(r, e) {
  return r.x === e.x && r.y === e.y;
}
function dL(r, e, t, n) {
  const i = _1(vs(r, e, t)), o = _1(vs(r, e, n)), l = _1(vs(t, n, r)), u = _1(vs(t, n, e));
  return !!(i !== o && l !== u || i === 0 && T1(r, t, e) || o === 0 && T1(r, n, e) || l === 0 && T1(t, r, n) || u === 0 && T1(t, e, n));
}
function T1(r, e, t) {
  return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y);
}
function _1(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function d$(r, e) {
  let t = r;
  do {
    if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && dL(t, t.next, r, e)) return !0;
    t = t.next;
  } while (t !== r);
  return !1;
}
function Mw(r, e) {
  return vs(r.prev, r, r.next) < 0 ? vs(r, e, r.next) >= 0 && vs(r, r.prev, e) >= 0 : vs(r, e, r.prev) < 0 || vs(r, r.next, e) < 0;
}
function I$(r, e) {
  let t = r, n = !1;
  const i = (r.x + e.x) / 2, o = (r.y + e.y) / 2;
  do
    t.y > o != t.next.y > o && t.next.y !== t.y && i < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== r);
  return n;
}
function IL(r, e) {
  const t = new eX(r.i, r.x, r.y), n = new eX(e.i, e.x, e.y), i = r.next, o = e.prev;
  return r.next = e, e.prev = r, t.next = i, i.prev = t, n.next = t, t.prev = n, o.next = n, n.prev = o, n;
}
function U3(r, e, t, n) {
  const i = new eX(r, e, t);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function Hw(r) {
  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function eX(r, e, t) {
  this.i = r, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function C$(r, e, t, n) {
  let i = 0;
  for (let o = e, l = t - n; o < t; o += n)
    i += (r[l] - r[o]) * (r[o + 1] + r[l + 1]), l = o;
  return i;
}
class dp {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, o = 0; o < t; i = o++)
      n += e[i].x * e[o].y - e[o].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return dp.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], i = [], o = [];
    O3(e), P3(n, e);
    let l = e.length;
    t.forEach(O3);
    for (let I = 0; I < t.length; I++)
      i.push(l), l += t[I].length, P3(n, t[I]);
    const u = q6.triangulate(n, i);
    for (let I = 0; I < u.length; I += 3)
      o.push(u.slice(I, I + 3));
    return o;
  }
}
function O3(r) {
  const e = r.length;
  e > 2 && r[e - 1].equals(r[0]) && r.pop();
}
function P3(r, e) {
  for (let t = 0; t < e.length; t++)
    r.push(e[t].x), r.push(e[t].y);
}
class tV extends Br {
  constructor(e = new mb([new Lt(0.5, 0.5), new Lt(-0.5, 0.5), new Lt(-0.5, -0.5), new Lt(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, i = [], o = [];
    for (let u = 0, I = e.length; u < I; u++) {
      const C = e[u];
      l(C);
    }
    this.setAttribute("position", new fi(i, 3)), this.setAttribute("uv", new fi(o, 2)), this.computeVertexNormals();
    function l(u) {
      const I = [], C = t.curveSegments !== void 0 ? t.curveSegments : 12, f = t.steps !== void 0 ? t.steps : 1, v = t.depth !== void 0 ? t.depth : 1;
      let b = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, S = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, R = t.bevelSize !== void 0 ? t.bevelSize : S - 0.1, W = t.bevelOffset !== void 0 ? t.bevelOffset : 0, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const N = t.extrudePath, Y = t.UVGenerator !== void 0 ? t.UVGenerator : h$;
      let F, T = !1, P, D, L, j;
      N && (F = N.getSpacedPoints(f), T = !0, b = !1, P = N.computeFrenetFrames(f, !1), D = new fe(), L = new fe(), j = new fe()), b || (x = 0, S = 0, R = 0, W = 0);
      const J = u.extractPoints(C);
      let O = J.shape;
      const ne = J.holes;
      if (!dp.isClockWise(O)) {
        O = O.reverse();
        for (let ge = 0, Wt = ne.length; ge < Wt; ge++) {
          const Nt = ne[ge];
          dp.isClockWise(Nt) && (ne[ge] = Nt.reverse());
        }
      }
      const pe = dp.triangulateShape(O, ne), Ae = O;
      for (let ge = 0, Wt = ne.length; ge < Wt; ge++) {
        const Nt = ne[ge];
        O = O.concat(Nt);
      }
      function ke(ge, Wt, Nt) {
        return Wt || console.error("THREE.ExtrudeGeometry: vec does not exist"), ge.clone().addScaledVector(Wt, Nt);
      }
      const Re = O.length, Xe = pe.length;
      function re(ge, Wt, Nt) {
        let $t, ft, bn;
        const en = ge.x - Wt.x, hn = ge.y - Wt.y, me = Nt.x - ge.x, se = Nt.y - ge.y, $e = en * en + hn * hn, Vt = en * se - hn * me;
        if (Math.abs(Vt) > Number.EPSILON) {
          const Bt = Math.sqrt($e), Mt = Math.sqrt(me * me + se * se), Gn = Wt.x - hn / Bt, jt = Wt.y + en / Bt, an = Nt.x - se / Mt, jn = Nt.y + me / Mt, Ot = ((an - Gn) * se - (jn - jt) * me) / (en * se - hn * me);
          $t = Gn + en * Ot - ge.x, ft = jt + hn * Ot - ge.y;
          const He = $t * $t + ft * ft;
          if (He <= 2)
            return new Lt($t, ft);
          bn = Math.sqrt(He / 2);
        } else {
          let Bt = !1;
          en > Number.EPSILON ? me > Number.EPSILON && (Bt = !0) : en < -Number.EPSILON ? me < -Number.EPSILON && (Bt = !0) : Math.sign(hn) === Math.sign(se) && (Bt = !0), Bt ? ($t = -hn, ft = en, bn = Math.sqrt($e)) : ($t = en, ft = hn, bn = Math.sqrt($e / 2));
        }
        return new Lt($t / bn, ft / bn);
      }
      const Se = [];
      for (let ge = 0, Wt = Ae.length, Nt = Wt - 1, $t = ge + 1; ge < Wt; ge++, Nt++, $t++)
        Nt === Wt && (Nt = 0), $t === Wt && ($t = 0), Se[ge] = re(Ae[ge], Ae[Nt], Ae[$t]);
      const Be = [];
      let le, Ye = Se.concat();
      for (let ge = 0, Wt = ne.length; ge < Wt; ge++) {
        const Nt = ne[ge];
        le = [];
        for (let $t = 0, ft = Nt.length, bn = ft - 1, en = $t + 1; $t < ft; $t++, bn++, en++)
          bn === ft && (bn = 0), en === ft && (en = 0), le[$t] = re(Nt[$t], Nt[bn], Nt[en]);
        Be.push(le), Ye = Ye.concat(le);
      }
      for (let ge = 0; ge < x; ge++) {
        const Wt = ge / x, Nt = S * Math.cos(Wt * Math.PI / 2), $t = R * Math.sin(Wt * Math.PI / 2) + W;
        for (let ft = 0, bn = Ae.length; ft < bn; ft++) {
          const en = ke(Ae[ft], Se[ft], $t);
          mt(en.x, en.y, -Nt);
        }
        for (let ft = 0, bn = ne.length; ft < bn; ft++) {
          const en = ne[ft];
          le = Be[ft];
          for (let hn = 0, me = en.length; hn < me; hn++) {
            const se = ke(en[hn], le[hn], $t);
            mt(se.x, se.y, -Nt);
          }
        }
      }
      const nt = R + W;
      for (let ge = 0; ge < Re; ge++) {
        const Wt = b ? ke(O[ge], Ye[ge], nt) : O[ge];
        T ? (L.copy(P.normals[0]).multiplyScalar(Wt.x), D.copy(P.binormals[0]).multiplyScalar(Wt.y), j.copy(F[0]).add(L).add(D), mt(j.x, j.y, j.z)) : mt(Wt.x, Wt.y, 0);
      }
      for (let ge = 1; ge <= f; ge++)
        for (let Wt = 0; Wt < Re; Wt++) {
          const Nt = b ? ke(O[Wt], Ye[Wt], nt) : O[Wt];
          T ? (L.copy(P.normals[ge]).multiplyScalar(Nt.x), D.copy(P.binormals[ge]).multiplyScalar(Nt.y), j.copy(F[ge]).add(L).add(D), mt(j.x, j.y, j.z)) : mt(Nt.x, Nt.y, v / f * ge);
        }
      for (let ge = x - 1; ge >= 0; ge--) {
        const Wt = ge / x, Nt = S * Math.cos(Wt * Math.PI / 2), $t = R * Math.sin(Wt * Math.PI / 2) + W;
        for (let ft = 0, bn = Ae.length; ft < bn; ft++) {
          const en = ke(Ae[ft], Se[ft], $t);
          mt(en.x, en.y, v + Nt);
        }
        for (let ft = 0, bn = ne.length; ft < bn; ft++) {
          const en = ne[ft];
          le = Be[ft];
          for (let hn = 0, me = en.length; hn < me; hn++) {
            const se = ke(en[hn], le[hn], $t);
            T ? mt(se.x, se.y + F[f - 1].y, F[f - 1].x + Nt) : mt(se.x, se.y, v + Nt);
          }
        }
      }
      ze(), Je();
      function ze() {
        const ge = i.length / 3;
        if (b) {
          let Wt = 0, Nt = Re * Wt;
          for (let $t = 0; $t < Xe; $t++) {
            const ft = pe[$t];
            Dt(ft[2] + Nt, ft[1] + Nt, ft[0] + Nt);
          }
          Wt = f + x * 2, Nt = Re * Wt;
          for (let $t = 0; $t < Xe; $t++) {
            const ft = pe[$t];
            Dt(ft[0] + Nt, ft[1] + Nt, ft[2] + Nt);
          }
        } else {
          for (let Wt = 0; Wt < Xe; Wt++) {
            const Nt = pe[Wt];
            Dt(Nt[2], Nt[1], Nt[0]);
          }
          for (let Wt = 0; Wt < Xe; Wt++) {
            const Nt = pe[Wt];
            Dt(Nt[0] + Re * f, Nt[1] + Re * f, Nt[2] + Re * f);
          }
        }
        n.addGroup(ge, i.length / 3 - ge, 0);
      }
      function Je() {
        const ge = i.length / 3;
        let Wt = 0;
        wt(Ae, Wt), Wt += Ae.length;
        for (let Nt = 0, $t = ne.length; Nt < $t; Nt++) {
          const ft = ne[Nt];
          wt(ft, Wt), Wt += ft.length;
        }
        n.addGroup(ge, i.length / 3 - ge, 1);
      }
      function wt(ge, Wt) {
        let Nt = ge.length;
        for (; --Nt >= 0; ) {
          const $t = Nt;
          let ft = Nt - 1;
          ft < 0 && (ft = ge.length - 1);
          for (let bn = 0, en = f + x * 2; bn < en; bn++) {
            const hn = Re * bn, me = Re * (bn + 1), se = Wt + $t + hn, $e = Wt + ft + hn, Vt = Wt + ft + me, Bt = Wt + $t + me;
            mn(se, $e, Vt, Bt);
          }
        }
      }
      function mt(ge, Wt, Nt) {
        I.push(ge), I.push(Wt), I.push(Nt);
      }
      function Dt(ge, Wt, Nt) {
        An(ge), An(Wt), An(Nt);
        const $t = i.length / 3, ft = Y.generateTopUV(n, i, $t - 3, $t - 2, $t - 1);
        Hn(ft[0]), Hn(ft[1]), Hn(ft[2]);
      }
      function mn(ge, Wt, Nt, $t) {
        An(ge), An(Wt), An($t), An(Wt), An(Nt), An($t);
        const ft = i.length / 3, bn = Y.generateSideWallUV(n, i, ft - 6, ft - 3, ft - 2, ft - 1);
        Hn(bn[0]), Hn(bn[1]), Hn(bn[3]), Hn(bn[1]), Hn(bn[2]), Hn(bn[3]);
      }
      function An(ge) {
        i.push(I[ge * 3 + 0]), i.push(I[ge * 3 + 1]), i.push(I[ge * 3 + 2]);
      }
      function Hn(ge) {
        o.push(ge.x), o.push(ge.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return f$(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let o = 0, l = e.shapes.length; o < l; o++) {
      const u = t[e.shapes[o]];
      n.push(u);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new nW[i.type]().fromJSON(i)), new tV(n, e.options);
  }
}
const h$ = {
  generateTopUV: function(r, e, t, n, i) {
    const o = e[t * 3], l = e[t * 3 + 1], u = e[n * 3], I = e[n * 3 + 1], C = e[i * 3], f = e[i * 3 + 1];
    return [
      new Lt(o, l),
      new Lt(u, I),
      new Lt(C, f)
    ];
  },
  generateSideWallUV: function(r, e, t, n, i, o) {
    const l = e[t * 3], u = e[t * 3 + 1], I = e[t * 3 + 2], C = e[n * 3], f = e[n * 3 + 1], v = e[n * 3 + 2], b = e[i * 3], S = e[i * 3 + 1], R = e[i * 3 + 2], W = e[o * 3], x = e[o * 3 + 1], N = e[o * 3 + 2];
    return Math.abs(u - f) < Math.abs(l - C) ? [
      new Lt(l, 1 - I),
      new Lt(C, 1 - v),
      new Lt(b, 1 - R),
      new Lt(W, 1 - N)
    ] : [
      new Lt(u, 1 - I),
      new Lt(f, 1 - v),
      new Lt(S, 1 - R),
      new Lt(x, 1 - N)
    ];
  }
};
function f$(r, e, t) {
  if (t.shapes = [], Array.isArray(r))
    for (let n = 0, i = r.length; n < i; n++) {
      const o = r[n];
      t.shapes.push(o.uuid);
    }
  else
    t.shapes.push(r.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class nV extends Rv {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], o = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, o, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new nV(e.radius, e.detail);
  }
}
class iR extends Rv {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new iR(e.radius, e.detail);
  }
}
class iV extends Br {
  constructor(e = 0.5, t = 1, n = 32, i = 1, o = 0, l = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: o,
      thetaLength: l
    }, n = Math.max(3, n), i = Math.max(1, i);
    const u = [], I = [], C = [], f = [];
    let v = e;
    const b = (t - e) / i, S = new fe(), R = new Lt();
    for (let W = 0; W <= i; W++) {
      for (let x = 0; x <= n; x++) {
        const N = o + x / n * l;
        S.x = v * Math.cos(N), S.y = v * Math.sin(N), I.push(S.x, S.y, S.z), C.push(0, 0, 1), R.x = (S.x / t + 1) / 2, R.y = (S.y / t + 1) / 2, f.push(R.x, R.y);
      }
      v += b;
    }
    for (let W = 0; W < i; W++) {
      const x = W * (n + 1);
      for (let N = 0; N < n; N++) {
        const Y = N + x, F = Y, T = Y + n + 1, P = Y + n + 2, D = Y + 1;
        u.push(F, T, D), u.push(T, P, D);
      }
    }
    this.setIndex(u), this.setAttribute("position", new fi(I, 3)), this.setAttribute("normal", new fi(C, 3)), this.setAttribute("uv", new fi(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new iV(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class rV extends Br {
  constructor(e = new mb([new Lt(0, 0.5), new Lt(-0.5, -0.5), new Lt(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], i = [], o = [], l = [];
    let u = 0, I = 0;
    if (Array.isArray(e) === !1)
      C(e);
    else
      for (let f = 0; f < e.length; f++)
        C(e[f]), this.addGroup(u, I, f), u += I, I = 0;
    this.setIndex(n), this.setAttribute("position", new fi(i, 3)), this.setAttribute("normal", new fi(o, 3)), this.setAttribute("uv", new fi(l, 2));
    function C(f) {
      const v = i.length / 3, b = f.extractPoints(t);
      let S = b.shape;
      const R = b.holes;
      dp.isClockWise(S) === !1 && (S = S.reverse());
      for (let x = 0, N = R.length; x < N; x++) {
        const Y = R[x];
        dp.isClockWise(Y) === !0 && (R[x] = Y.reverse());
      }
      const W = dp.triangulateShape(S, R);
      for (let x = 0, N = R.length; x < N; x++) {
        const Y = R[x];
        S = S.concat(Y);
      }
      for (let x = 0, N = S.length; x < N; x++) {
        const Y = S[x];
        i.push(Y.x, Y.y, 0), o.push(0, 0, 1), l.push(Y.x, Y.y);
      }
      for (let x = 0, N = W.length; x < N; x++) {
        const Y = W[x], F = Y[0] + v, T = Y[1] + v, P = Y[2] + v;
        n.push(F, T, P), I += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return p$(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const l = t[e.shapes[i]];
      n.push(l);
    }
    return new rV(n, e.curveSegments);
  }
}
function p$(r, e) {
  if (e.shapes = [], Array.isArray(r))
    for (let t = 0, n = r.length; t < n; t++) {
      const i = r[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(r.uuid);
  return e;
}
class rR extends Br {
  constructor(e = 1, t = 32, n = 16, i = 0, o = Math.PI * 2, l = 0, u = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: i,
      phiLength: o,
      thetaStart: l,
      thetaLength: u
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const I = Math.min(l + u, Math.PI);
    let C = 0;
    const f = [], v = new fe(), b = new fe(), S = [], R = [], W = [], x = [];
    for (let N = 0; N <= n; N++) {
      const Y = [], F = N / n;
      let T = 0;
      N === 0 && l === 0 ? T = 0.5 / t : N === n && I === Math.PI && (T = -0.5 / t);
      for (let P = 0; P <= t; P++) {
        const D = P / t;
        v.x = -e * Math.cos(i + D * o) * Math.sin(l + F * u), v.y = e * Math.cos(l + F * u), v.z = e * Math.sin(i + D * o) * Math.sin(l + F * u), R.push(v.x, v.y, v.z), b.copy(v).normalize(), W.push(b.x, b.y, b.z), x.push(D + T, 1 - F), Y.push(C++);
      }
      f.push(Y);
    }
    for (let N = 0; N < n; N++)
      for (let Y = 0; Y < t; Y++) {
        const F = f[N][Y + 1], T = f[N][Y], P = f[N + 1][Y], D = f[N + 1][Y + 1];
        (N !== 0 || l > 0) && S.push(F, T, D), (N !== n - 1 || I < Math.PI) && S.push(T, P, D);
      }
    this.setIndex(S), this.setAttribute("position", new fi(R, 3)), this.setAttribute("normal", new fi(W, 3)), this.setAttribute("uv", new fi(x, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new rR(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class aV extends Rv {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new aV(e.radius, e.detail);
  }
}
class oV extends Br {
  constructor(e = 1, t = 0.4, n = 12, i = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: i,
      arc: o
    }, n = Math.floor(n), i = Math.floor(i);
    const l = [], u = [], I = [], C = [], f = new fe(), v = new fe(), b = new fe();
    for (let S = 0; S <= n; S++)
      for (let R = 0; R <= i; R++) {
        const W = R / i * o, x = S / n * Math.PI * 2;
        v.x = (e + t * Math.cos(x)) * Math.cos(W), v.y = (e + t * Math.cos(x)) * Math.sin(W), v.z = t * Math.sin(x), u.push(v.x, v.y, v.z), f.x = e * Math.cos(W), f.y = e * Math.sin(W), b.subVectors(v, f).normalize(), I.push(b.x, b.y, b.z), C.push(R / i), C.push(S / n);
      }
    for (let S = 1; S <= n; S++)
      for (let R = 1; R <= i; R++) {
        const W = (i + 1) * S + R - 1, x = (i + 1) * (S - 1) + R - 1, N = (i + 1) * (S - 1) + R, Y = (i + 1) * S + R;
        l.push(W, x, Y), l.push(x, N, Y);
      }
    this.setIndex(l), this.setAttribute("position", new fi(u, 3)), this.setAttribute("normal", new fi(I, 3)), this.setAttribute("uv", new fi(C, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new oV(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class sV extends Br {
  constructor(e = 1, t = 0.4, n = 64, i = 8, o = 2, l = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: i,
      p: o,
      q: l
    }, n = Math.floor(n), i = Math.floor(i);
    const u = [], I = [], C = [], f = [], v = new fe(), b = new fe(), S = new fe(), R = new fe(), W = new fe(), x = new fe(), N = new fe();
    for (let F = 0; F <= n; ++F) {
      const T = F / n * o * Math.PI * 2;
      Y(T, o, l, e, S), Y(T + 0.01, o, l, e, R), x.subVectors(R, S), N.addVectors(R, S), W.crossVectors(x, N), N.crossVectors(W, x), W.normalize(), N.normalize();
      for (let P = 0; P <= i; ++P) {
        const D = P / i * Math.PI * 2, L = -t * Math.cos(D), j = t * Math.sin(D);
        v.x = S.x + (L * N.x + j * W.x), v.y = S.y + (L * N.y + j * W.y), v.z = S.z + (L * N.z + j * W.z), I.push(v.x, v.y, v.z), b.subVectors(v, S).normalize(), C.push(b.x, b.y, b.z), f.push(F / n), f.push(P / i);
      }
    }
    for (let F = 1; F <= n; F++)
      for (let T = 1; T <= i; T++) {
        const P = (i + 1) * (F - 1) + (T - 1), D = (i + 1) * F + (T - 1), L = (i + 1) * F + T, j = (i + 1) * (F - 1) + T;
        u.push(P, D, j), u.push(D, L, j);
      }
    this.setIndex(u), this.setAttribute("position", new fi(I, 3)), this.setAttribute("normal", new fi(C, 3)), this.setAttribute("uv", new fi(f, 2));
    function Y(F, T, P, D, L) {
      const j = Math.cos(F), J = Math.sin(F), O = P / T * F, ne = Math.cos(O);
      L.x = D * (2 + ne) * 0.5 * j, L.y = D * (2 + ne) * J * 0.5, L.z = D * Math.sin(O) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new sV(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class lV extends Br {
  constructor(e = new BY(new fe(-1, -1, 0), new fe(-1, 1, 0), new fe(1, 1, 0)), t = 64, n = 1, i = 8, o = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: i,
      closed: o
    };
    const l = e.computeFrenetFrames(t, o);
    this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
    const u = new fe(), I = new fe(), C = new Lt();
    let f = new fe();
    const v = [], b = [], S = [], R = [];
    W(), this.setIndex(R), this.setAttribute("position", new fi(v, 3)), this.setAttribute("normal", new fi(b, 3)), this.setAttribute("uv", new fi(S, 2));
    function W() {
      for (let F = 0; F < t; F++)
        x(F);
      x(o === !1 ? t : 0), Y(), N();
    }
    function x(F) {
      f = e.getPointAt(F / t, f);
      const T = l.normals[F], P = l.binormals[F];
      for (let D = 0; D <= i; D++) {
        const L = D / i * Math.PI * 2, j = Math.sin(L), J = -Math.cos(L);
        I.x = J * T.x + j * P.x, I.y = J * T.y + j * P.y, I.z = J * T.z + j * P.z, I.normalize(), b.push(I.x, I.y, I.z), u.x = f.x + n * I.x, u.y = f.y + n * I.y, u.z = f.z + n * I.z, v.push(u.x, u.y, u.z);
      }
    }
    function N() {
      for (let F = 1; F <= t; F++)
        for (let T = 1; T <= i; T++) {
          const P = (i + 1) * (F - 1) + (T - 1), D = (i + 1) * F + (T - 1), L = (i + 1) * F + T, j = (i + 1) * (F - 1) + T;
          R.push(P, D, j), R.push(D, L, j);
        }
    }
    function Y() {
      for (let F = 0; F <= t; F++)
        for (let T = 0; T <= i; T++)
          C.x = F / t, C.y = T / i, S.push(C.x, C.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new lV(
      new nW[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class CL extends Br {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), i = new fe(), o = new fe();
      if (e.index !== null) {
        const l = e.attributes.position, u = e.index;
        let I = e.groups;
        I.length === 0 && (I = [{ start: 0, count: u.count, materialIndex: 0 }]);
        for (let C = 0, f = I.length; C < f; ++C) {
          const v = I[C], b = v.start, S = v.count;
          for (let R = b, W = b + S; R < W; R += 3)
            for (let x = 0; x < 3; x++) {
              const N = u.getX(R + x), Y = u.getX(R + (x + 1) % 3);
              i.fromBufferAttribute(l, N), o.fromBufferAttribute(l, Y), J3(i, o, n) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const l = e.attributes.position;
        for (let u = 0, I = l.count / 3; u < I; u++)
          for (let C = 0; C < 3; C++) {
            const f = 3 * u + C, v = 3 * u + (C + 1) % 3;
            i.fromBufferAttribute(l, f), o.fromBufferAttribute(l, v), J3(i, o, n) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new fi(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function J3(r, e, t) {
  const n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var Q3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Mb,
  CapsuleGeometry: QW,
  CircleGeometry: jW,
  ConeGeometry: qW,
  CylinderGeometry: NB,
  DodecahedronGeometry: $W,
  EdgesGeometry: cL,
  ExtrudeGeometry: tV,
  IcosahedronGeometry: nV,
  LatheGeometry: nR,
  OctahedronGeometry: iR,
  PlaneGeometry: WB,
  PolyhedronGeometry: Rv,
  RingGeometry: iV,
  ShapeGeometry: rV,
  SphereGeometry: rR,
  TetrahedronGeometry: aV,
  TorusGeometry: oV,
  TorusKnotGeometry: sV,
  TubeGeometry: lV,
  WireframeGeometry: CL
});
class hL extends Cg {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new ai(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class fL extends rf {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class ZY extends Cg {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new ai(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ai(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zv, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new uI(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class pL extends ZY {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Lt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return zs(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ai(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ai(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ai(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class mL extends Cg {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new ai(16777215), this.specular = new ai(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ai(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zv, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new uI(), this.combine = Qw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class AL extends Cg {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new ai(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ai(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zv, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class vL extends Cg {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zv, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class yL extends Cg {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new ai(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ai(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zv, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new uI(), this.combine = Qw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class bL extends Cg {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new ai(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zv, this.normalScale = new Lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class GL extends ad {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function db(r, e, t) {
  return !r || // let 'undefined' and 'null' pass
  !t && r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r);
}
function BL(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function SL(r) {
  function e(i, o) {
    return r[i] - r[o];
  }
  const t = r.length, n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function tX(r, e, t) {
  const n = r.length, i = new r.constructor(n);
  for (let o = 0, l = 0; l !== n; ++o) {
    const u = t[o] * e;
    for (let I = 0; I !== e; ++I)
      i[l++] = r[u + I];
  }
  return i;
}
function wY(r, e, t, n) {
  let i = 1, o = r[0];
  for (; o !== void 0 && o[n] === void 0; )
    o = r[i++];
  if (o === void 0) return;
  let l = o[n];
  if (l !== void 0)
    if (Array.isArray(l))
      do
        l = o[n], l !== void 0 && (e.push(o.time), t.push.apply(t, l)), o = r[i++];
      while (o !== void 0);
    else if (l.toArray !== void 0)
      do
        l = o[n], l !== void 0 && (e.push(o.time), l.toArray(t, t.length)), o = r[i++];
      while (o !== void 0);
    else
      do
        l = o[n], l !== void 0 && (e.push(o.time), t.push(l)), o = r[i++];
      while (o !== void 0);
}
function m$(r, e, t, n, i = 30) {
  const o = r.clone();
  o.name = e;
  const l = [];
  for (let I = 0; I < o.tracks.length; ++I) {
    const C = o.tracks[I], f = C.getValueSize(), v = [], b = [];
    for (let S = 0; S < C.times.length; ++S) {
      const R = C.times[S] * i;
      if (!(R < t || R >= n)) {
        v.push(C.times[S]);
        for (let W = 0; W < f; ++W)
          b.push(C.values[S * f + W]);
      }
    }
    v.length !== 0 && (C.times = db(v, C.times.constructor), C.values = db(b, C.values.constructor), l.push(C));
  }
  o.tracks = l;
  let u = 1 / 0;
  for (let I = 0; I < o.tracks.length; ++I)
    u > o.tracks[I].times[0] && (u = o.tracks[I].times[0]);
  for (let I = 0; I < o.tracks.length; ++I)
    o.tracks[I].shift(-1 * u);
  return o.resetDuration(), o;
}
function A$(r, e = 0, t = r, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length, o = e / n;
  for (let l = 0; l < i; ++l) {
    const u = t.tracks[l], I = u.ValueTypeName;
    if (I === "bool" || I === "string") continue;
    const C = r.tracks.find(function(N) {
      return N.name === u.name && N.ValueTypeName === I;
    });
    if (C === void 0) continue;
    let f = 0;
    const v = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = v / 3);
    let b = 0;
    const S = C.getValueSize();
    C.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (b = S / 3);
    const R = u.times.length - 1;
    let W;
    if (o <= u.times[0]) {
      const N = f, Y = v - f;
      W = u.values.slice(N, Y);
    } else if (o >= u.times[R]) {
      const N = R * v + f, Y = N + v - f;
      W = u.values.slice(N, Y);
    } else {
      const N = u.createInterpolant(), Y = f, F = v - f;
      N.evaluate(o), W = N.resultBuffer.slice(Y, F);
    }
    I === "quaternion" && new ku().fromArray(W).normalize().conjugate().toArray(W);
    const x = C.times.length;
    for (let N = 0; N < x; ++N) {
      const Y = N * S + b;
      if (I === "quaternion")
        ku.multiplyQuaternionsFlat(
          C.values,
          Y,
          W,
          0,
          C.values,
          Y
        );
      else {
        const F = S - b * 2;
        for (let T = 0; T < F; ++T)
          C.values[Y + T] -= W[T];
      }
    }
  }
  return r.blendMode = sY, r;
}
const v$ = {
  convertArray: db,
  isTypedArray: BL,
  getKeyframeOrder: SL,
  sortedArray: tX,
  flattenJSON: wY,
  subclip: m$,
  makeClipAdditive: A$
};
class aR {
  constructor(e, t, n, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, i = t[n], o = t[n - 1];
    e: {
      t: {
        let l;
        n: {
          i: if (!(e < i)) {
            for (let u = n + 2; ; ) {
              if (i === void 0) {
                if (e < o) break i;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === u) break;
              if (o = i, i = t[++n], e < i)
                break t;
            }
            l = t.length;
            break n;
          }
          if (!(e >= o)) {
            const u = t[1];
            e < u && (n = 2, o = u);
            for (let I = n - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === I) break;
              if (i = o, o = t[--n - 1], e >= o)
                break t;
            }
            l = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < l; ) {
          const u = n + l >>> 1;
          e < t[u] ? l = u : n = u + 1;
        }
        if (i = t[n], o = t[n - 1], o === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, o, i);
    }
    return this.interpolate_(n, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, o = e * i;
    for (let l = 0; l !== i; ++l)
      t[l] = n[o + l];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class ZL extends aR {
  constructor(e, t, n, i) {
    super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: ub,
      endingEnd: ub
    };
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let o = e - 2, l = e + 1, u = i[o], I = i[l];
    if (u === void 0)
      switch (this.getSettings_().endingStart) {
        case cb:
          o = e, u = 2 * t - n;
          break;
        case Bw:
          o = i.length - 2, u = t + i[o] - i[o + 1];
          break;
        default:
          o = e, u = n;
      }
    if (I === void 0)
      switch (this.getSettings_().endingEnd) {
        case cb:
          l = e, I = 2 * n - t;
          break;
        case Bw:
          l = 1, I = n + i[1] - i[0];
          break;
        default:
          l = e - 1, I = t;
      }
    const C = (n - t) * 0.5, f = this.valueSize;
    this._weightPrev = C / (t - u), this._weightNext = C / (I - n), this._offsetPrev = o * f, this._offsetNext = l * f;
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, I = e * u, C = I - u, f = this._offsetPrev, v = this._offsetNext, b = this._weightPrev, S = this._weightNext, R = (n - t) / (i - t), W = R * R, x = W * R, N = -b * x + 2 * b * W - b * R, Y = (1 + b) * x + (-1.5 - 2 * b) * W + (-0.5 + b) * R + 1, F = (-1 - S) * x + (1.5 + S) * W + 0.5 * R, T = S * x - S * W;
    for (let P = 0; P !== u; ++P)
      o[P] = N * l[f + P] + Y * l[C + P] + F * l[I + P] + T * l[v + P];
    return o;
  }
}
class RY extends aR {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, I = e * u, C = I - u, f = (n - t) / (i - t), v = 1 - f;
    for (let b = 0; b !== u; ++b)
      o[b] = l[C + b] * v + l[I + b] * f;
    return o;
  }
}
class wL extends aR {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class of {
  constructor(e, t, n, i) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = db(t, this.TimeBufferType), this.values = db(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: db(e.times, Array),
        values: db(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new wL(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new RY(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new ZL(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Gw:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case $2:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case g2:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Gw;
      case this.InterpolantFactoryMethodLinear:
        return $2;
      case this.InterpolantFactoryMethodSmooth:
        return g2;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, i = n.length;
    let o = 0, l = i - 1;
    for (; o !== i && n[o] < e; )
      ++o;
    for (; l !== -1 && n[l] > t; )
      --l;
    if (++l, o !== 0 || l !== i) {
      o >= l && (l = Math.max(l, 1), o = l - 1);
      const u = this.getValueSize();
      this.times = n.slice(o, l), this.values = this.values.slice(o * u, l * u);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, i = this.values, o = n.length;
    o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let l = null;
    for (let u = 0; u !== o; u++) {
      const I = n[u];
      if (typeof I == "number" && isNaN(I)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, u, I), e = !1;
        break;
      }
      if (l !== null && l > I) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, u, I, l), e = !1;
        break;
      }
      l = I;
    }
    if (i !== void 0 && BL(i))
      for (let u = 0, I = i.length; u !== I; ++u) {
        const C = i[u];
        if (isNaN(C)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, u, C), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === g2, o = e.length - 1;
    let l = 1;
    for (let u = 1; u < o; ++u) {
      let I = !1;
      const C = e[u], f = e[u + 1];
      if (C !== f && (u !== 1 || C !== e[0]))
        if (i)
          I = !0;
        else {
          const v = u * n, b = v - n, S = v + n;
          for (let R = 0; R !== n; ++R) {
            const W = t[v + R];
            if (W !== t[b + R] || W !== t[S + R]) {
              I = !0;
              break;
            }
          }
        }
      if (I) {
        if (u !== l) {
          e[l] = e[u];
          const v = u * n, b = l * n;
          for (let S = 0; S !== n; ++S)
            t[b + S] = t[v + S];
        }
        ++l;
      }
    }
    if (o > 0) {
      e[l] = e[o];
      for (let u = o * n, I = l * n, C = 0; C !== n; ++C)
        t[I + C] = t[u + C];
      ++l;
    }
    return l !== e.length ? (this.times = e.slice(0, l), this.values = t.slice(0, l * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
of.prototype.TimeBufferType = Float32Array;
of.prototype.ValueBufferType = Float32Array;
of.prototype.DefaultInterpolation = $2;
class Hb extends of {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, n) {
    super(e, t, n);
  }
}
Hb.prototype.ValueTypeName = "bool";
Hb.prototype.ValueBufferType = Array;
Hb.prototype.DefaultInterpolation = Gw;
Hb.prototype.InterpolantFactoryMethodLinear = void 0;
Hb.prototype.InterpolantFactoryMethodSmooth = void 0;
class xY extends of {
}
xY.prototype.ValueTypeName = "color";
class Xw extends of {
}
Xw.prototype.ValueTypeName = "number";
class RL extends aR {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, I = (n - t) / (i - t);
    let C = e * u;
    for (let f = C + u; C !== f; C += 4)
      ku.slerpFlat(o, 0, l, C - u, l, C, I);
    return o;
  }
}
class oR extends of {
  InterpolantFactoryMethodLinear(e) {
    return new RL(this.times, this.values, this.getValueSize(), e);
  }
}
oR.prototype.ValueTypeName = "quaternion";
oR.prototype.InterpolantFactoryMethodSmooth = void 0;
class Xb extends of {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, n) {
    super(e, t, n);
  }
}
Xb.prototype.ValueTypeName = "string";
Xb.prototype.ValueBufferType = Array;
Xb.prototype.DefaultInterpolation = Gw;
Xb.prototype.InterpolantFactoryMethodLinear = void 0;
Xb.prototype.InterpolantFactoryMethodSmooth = void 0;
class Yw extends of {
}
Yw.prototype.ValueTypeName = "vector";
class Fw {
  constructor(e = "", t = -1, n = [], i = TW) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = PI(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, i = 1 / (e.fps || 1);
    for (let l = 0, u = n.length; l !== u; ++l)
      t.push(b$(n[l]).scale(i));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return o.uuid = e.uuid, o;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let o = 0, l = n.length; o !== l; ++o)
      t.push(of.toJSON(n[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const o = t.length, l = [];
    for (let u = 0; u < o; u++) {
      let I = [], C = [];
      I.push(
        (u + o - 1) % o,
        u,
        (u + 1) % o
      ), C.push(0, 1, 0);
      const f = SL(I);
      I = tX(I, 1, f), C = tX(C, 1, f), !i && I[0] === 0 && (I.push(o), C.push(C[0])), l.push(
        new Xw(
          ".morphTargetInfluences[" + t[u].name + "]",
          I,
          C
        ).scale(1 / n)
      );
    }
    return new this(e, -1, l);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < n.length; i++)
      if (n[i].name === t)
        return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {}, o = /^([\w-]*?)([\d]+)$/;
    for (let u = 0, I = e.length; u < I; u++) {
      const C = e[u], f = C.name.match(o);
      if (f && f.length > 1) {
        const v = f[1];
        let b = i[v];
        b || (i[v] = b = []), b.push(C);
      }
    }
    const l = [];
    for (const u in i)
      l.push(this.CreateFromMorphTargetSequence(u, i[u], t, n));
    return l;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(v, b, S, R, W) {
      if (S.length !== 0) {
        const x = [], N = [];
        wY(S, x, N, R), x.length !== 0 && W.push(new v(b, x, N));
      }
    }, i = [], o = e.name || "default", l = e.fps || 30, u = e.blendMode;
    let I = e.length || -1;
    const C = e.hierarchy || [];
    for (let v = 0; v < C.length; v++) {
      const b = C[v].keys;
      if (!(!b || b.length === 0))
        if (b[0].morphTargets) {
          const S = {};
          let R;
          for (R = 0; R < b.length; R++)
            if (b[R].morphTargets)
              for (let W = 0; W < b[R].morphTargets.length; W++)
                S[b[R].morphTargets[W]] = -1;
          for (const W in S) {
            const x = [], N = [];
            for (let Y = 0; Y !== b[R].morphTargets.length; ++Y) {
              const F = b[R];
              x.push(F.time), N.push(F.morphTarget === W ? 1 : 0);
            }
            i.push(new Xw(".morphTargetInfluence[" + W + "]", x, N));
          }
          I = S.length * l;
        } else {
          const S = ".bones[" + t[v].name + "]";
          n(
            Yw,
            S + ".position",
            b,
            "pos",
            i
          ), n(
            oR,
            S + ".quaternion",
            b,
            "rot",
            i
          ), n(
            Yw,
            S + ".scale",
            b,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(o, I, i, u);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const o = this.tracks[n];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function y$(r) {
  switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Xw;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Yw;
    case "color":
      return xY;
    case "quaternion":
      return oR;
    case "bool":
    case "boolean":
      return Hb;
    case "string":
      return Xb;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
}
function b$(r) {
  if (r.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = y$(r.type);
  if (r.times === void 0) {
    const t = [], n = [];
    wY(r.keys, t, n, "value"), r.times = t, r.values = n;
  }
  return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation);
}
const Km = {
  enabled: !1,
  files: {},
  add: function(r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function(r) {
    if (this.enabled !== !1)
      return this.files[r];
  },
  remove: function(r) {
    delete this.files[r];
  },
  clear: function() {
    this.files = {};
  }
};
class WY {
  constructor(e, t, n) {
    const i = this;
    let o = !1, l = 0, u = 0, I;
    const C = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(f) {
      u++, o === !1 && i.onStart !== void 0 && i.onStart(f, l, u), o = !0;
    }, this.itemEnd = function(f) {
      l++, i.onProgress !== void 0 && i.onProgress(f, l, u), l === u && (o = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(f) {
      i.onError !== void 0 && i.onError(f);
    }, this.resolveURL = function(f) {
      return I ? I(f) : f;
    }, this.setURLModifier = function(f) {
      return I = f, this;
    }, this.addHandler = function(f, v) {
      return C.push(f, v), this;
    }, this.removeHandler = function(f) {
      const v = C.indexOf(f);
      return v !== -1 && C.splice(v, 2), this;
    }, this.getHandler = function(f) {
      for (let v = 0, b = C.length; v < b; v += 2) {
        const S = C[v], R = C[v + 1];
        if (S.global && (S.lastIndex = 0), S.test(f))
          return R;
      }
      return null;
    };
  }
}
const xL = /* @__PURE__ */ new WY();
class gI {
  constructor(e) {
    this.manager = e !== void 0 ? e : xL, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(i, o) {
      n.load(e, i, t, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
gI.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Nm = {};
class G$ extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class Jm extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = Km.get(e);
    if (o !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(o), this.manager.itemEnd(e);
      }, 0), o;
    if (Nm[e] !== void 0) {
      Nm[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      return;
    }
    Nm[e] = [], Nm[e].push({
      onLoad: t,
      onProgress: n,
      onError: i
    });
    const l = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), u = this.mimeType, I = this.responseType;
    fetch(l).then((C) => {
      if (C.status === 200 || C.status === 0) {
        if (C.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || C.body === void 0 || C.body.getReader === void 0)
          return C;
        const f = Nm[e], v = C.body.getReader(), b = C.headers.get("X-File-Size") || C.headers.get("Content-Length"), S = b ? parseInt(b) : 0, R = S !== 0;
        let W = 0;
        const x = new ReadableStream({
          start(N) {
            Y();
            function Y() {
              v.read().then(({ done: F, value: T }) => {
                if (F)
                  N.close();
                else {
                  W += T.byteLength;
                  const P = new ProgressEvent("progress", { lengthComputable: R, loaded: W, total: S });
                  for (let D = 0, L = f.length; D < L; D++) {
                    const j = f[D];
                    j.onProgress && j.onProgress(P);
                  }
                  N.enqueue(T), Y();
                }
              }, (F) => {
                N.error(F);
              });
            }
          }
        });
        return new Response(x);
      } else
        throw new G$(`fetch for "${C.url}" responded with ${C.status}: ${C.statusText}`, C);
    }).then((C) => {
      switch (I) {
        case "arraybuffer":
          return C.arrayBuffer();
        case "blob":
          return C.blob();
        case "document":
          return C.text().then((f) => new DOMParser().parseFromString(f, u));
        case "json":
          return C.json();
        default:
          if (u === void 0)
            return C.text();
          {
            const v = /charset="?([^;"\s]*)"?/i.exec(u), b = v && v[1] ? v[1].toLowerCase() : void 0, S = new TextDecoder(b);
            return C.arrayBuffer().then((R) => S.decode(R));
          }
      }
    }).then((C) => {
      Km.add(e, C);
      const f = Nm[e];
      delete Nm[e];
      for (let v = 0, b = f.length; v < b; v++) {
        const S = f[v];
        S.onLoad && S.onLoad(C);
      }
    }).catch((C) => {
      const f = Nm[e];
      if (f === void 0)
        throw this.manager.itemError(e), C;
      delete Nm[e];
      for (let v = 0, b = f.length; v < b; v++) {
        const S = f[v];
        S.onError && S.onError(C);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class B$ extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = new Jm(this.manager);
    l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (I) {
        i ? i(I) : console.error(I), o.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = Fw.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class S$ extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = [], u = new PW(), I = new Jm(this.manager);
    I.setPath(this.path), I.setResponseType("arraybuffer"), I.setRequestHeader(this.requestHeader), I.setWithCredentials(o.withCredentials);
    let C = 0;
    function f(v) {
      I.load(e[v], function(b) {
        const S = o.parse(b, !0);
        l[v] = {
          width: S.width,
          height: S.height,
          format: S.format,
          mipmaps: S.mipmaps
        }, C += 1, C === 6 && (S.mipmapCount === 1 && (u.minFilter = Ks), u.image = l, u.format = S.format, u.needsUpdate = !0, t && t(u));
      }, n, i);
    }
    if (Array.isArray(e))
      for (let v = 0, b = e.length; v < b; ++v)
        f(v);
    else
      I.load(e, function(v) {
        const b = o.parse(v, !0);
        if (b.isCubemap) {
          const S = b.mipmaps.length / b.mipmapCount;
          for (let R = 0; R < S; R++) {
            l[R] = { mipmaps: [] };
            for (let W = 0; W < b.mipmapCount; W++)
              l[R].mipmaps.push(b.mipmaps[R * b.mipmapCount + W]), l[R].format = b.format, l[R].width = b.width, l[R].height = b.height;
          }
          u.image = l;
        } else
          u.image.width = b.width, u.image.height = b.height, u.mipmaps = b.mipmaps;
        b.mipmapCount === 1 && (u.minFilter = Ks), u.format = b.format, u.needsUpdate = !0, t && t(u);
      }, n, i);
    return u;
  }
}
class Ew extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = Km.get(e);
    if (l !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    const u = Ww("img");
    function I() {
      f(), Km.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function C(v) {
      f(), i && i(v), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function f() {
      u.removeEventListener("load", I, !1), u.removeEventListener("error", C, !1);
    }
    return u.addEventListener("load", I, !1), u.addEventListener("error", C, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (u.crossOrigin = this.crossOrigin), o.manager.itemStart(e), u.src = e, u;
  }
}
class Z$ extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = new eR();
    o.colorSpace = OC;
    const l = new Ew(this.manager);
    l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
    let u = 0;
    function I(C) {
      l.load(e[C], function(f) {
        o.images[C] = f, u++, u === 6 && (o.needsUpdate = !0, t && t(o));
      }, void 0, i);
    }
    for (let C = 0; C < e.length; ++C)
      I(C);
    return o;
  }
}
class w$ extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = new gp(), u = new Jm(this.manager);
    return u.setResponseType("arraybuffer"), u.setRequestHeader(this.requestHeader), u.setPath(this.path), u.setWithCredentials(o.withCredentials), u.load(e, function(I) {
      let C;
      try {
        C = o.parse(I);
      } catch (f) {
        if (i !== void 0)
          i(f);
        else {
          console.error(f);
          return;
        }
      }
      C.image !== void 0 ? l.image = C.image : C.data !== void 0 && (l.image.width = C.width, l.image.height = C.height, l.image.data = C.data), l.wrapS = C.wrapS !== void 0 ? C.wrapS : PC, l.wrapT = C.wrapT !== void 0 ? C.wrapT : PC, l.magFilter = C.magFilter !== void 0 ? C.magFilter : Ks, l.minFilter = C.minFilter !== void 0 ? C.minFilter : Ks, l.anisotropy = C.anisotropy !== void 0 ? C.anisotropy : 1, C.colorSpace !== void 0 && (l.colorSpace = C.colorSpace), C.flipY !== void 0 && (l.flipY = C.flipY), C.format !== void 0 && (l.format = C.format), C.type !== void 0 && (l.type = C.type), C.mipmaps !== void 0 && (l.mipmaps = C.mipmaps, l.minFilter = ap), C.mipmapCount === 1 && (l.minFilter = Ks), C.generateMipmaps !== void 0 && (l.generateMipmaps = C.generateMipmaps), l.needsUpdate = !0, t && t(l, C);
    }, n, i), l;
  }
}
class R$ extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = new ks(), l = new Ew(this.manager);
    return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(e, function(u) {
      o.image = u, o.needsUpdate = !0, t !== void 0 && t(o);
    }, n, i), o;
  }
}
class xv extends qr {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new ai(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
  }
}
class WL extends xv {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(qr.DEFAULT_UP), this.updateMatrix(), this.groundColor = new ai(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const nH = /* @__PURE__ */ new _i(), j3 = /* @__PURE__ */ new fe(), q3 = /* @__PURE__ */ new fe();
class VY {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Lt(512, 512), this.map = null, this.mapPass = null, this.matrix = new _i(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new tR(), this._frameExtents = new Lt(1, 1), this._viewportCount = 1, this._viewports = [
      new Ha(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    j3.setFromMatrixPosition(e.matrixWorld), t.position.copy(j3), q3.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(q3), t.updateMatrixWorld(), nH.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(nH), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(nH);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class x$ extends VY {
  constructor() {
    super(new hl(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = hB * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, o = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || o !== t.far) && (t.fov = n, t.aspect = i, t.far = o, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class VL extends xv {
  constructor(e, t, n = 0, i = Math.PI / 3, o = 0, l = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(qr.DEFAULT_UP), this.updateMatrix(), this.target = new qr(), this.distance = n, this.angle = i, this.penumbra = o, this.decay = l, this.map = null, this.shadow = new x$();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const $3 = /* @__PURE__ */ new _i(), HZ = /* @__PURE__ */ new fe(), iH = /* @__PURE__ */ new fe();
class W$ extends VY {
  constructor() {
    super(new hl(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Lt(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Ha(2, 1, 1, 1),
      // negative X
      new Ha(0, 1, 1, 1),
      // positive Z
      new Ha(3, 1, 1, 1),
      // negative Z
      new Ha(1, 1, 1, 1),
      // positive Y
      new Ha(3, 0, 1, 1),
      // negative Y
      new Ha(1, 0, 1, 1)
    ], this._cubeDirections = [
      new fe(1, 0, 0),
      new fe(-1, 0, 0),
      new fe(0, 0, 1),
      new fe(0, 0, -1),
      new fe(0, 1, 0),
      new fe(0, -1, 0)
    ], this._cubeUps = [
      new fe(0, 1, 0),
      new fe(0, 1, 0),
      new fe(0, 1, 0),
      new fe(0, 1, 0),
      new fe(0, 0, 1),
      new fe(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, i = this.matrix, o = e.distance || n.far;
    o !== n.far && (n.far = o, n.updateProjectionMatrix()), HZ.setFromMatrixPosition(e.matrixWorld), n.position.copy(HZ), iH.copy(n.position), iH.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(iH), n.updateMatrixWorld(), i.makeTranslation(-HZ.x, -HZ.y, -HZ.z), $3.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix($3);
  }
}
class NL extends xv {
  constructor(e, t, n = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new W$();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class V$ extends VY {
  constructor() {
    super(new pv(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class ML extends xv {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(qr.DEFAULT_UP), this.updateMatrix(), this.target = new qr(), this.shadow = new V$();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class HL extends xv {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class XL extends xv {
  constructor(e, t, n = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class YL {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new fe());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.282095), t.addScaledVector(l[1], 0.488603 * i), t.addScaledVector(l[2], 0.488603 * o), t.addScaledVector(l[3], 0.488603 * n), t.addScaledVector(l[4], 1.092548 * (n * i)), t.addScaledVector(l[5], 1.092548 * (i * o)), t.addScaledVector(l[6], 0.315392 * (3 * o * o - 1)), t.addScaledVector(l[7], 1.092548 * (n * o)), t.addScaledVector(l[8], 0.546274 * (n * n - i * i)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.886227), t.addScaledVector(l[1], 2 * 0.511664 * i), t.addScaledVector(l[2], 2 * 0.511664 * o), t.addScaledVector(l[3], 2 * 0.511664 * n), t.addScaledVector(l[4], 2 * 0.429043 * n * i), t.addScaledVector(l[5], 2 * 0.429043 * i * o), t.addScaledVector(l[6], 0.743125 * o * o - 0.247708), t.addScaledVector(l[7], 2 * 0.429043 * n * o), t.addScaledVector(l[8], 0.429043 * (n * n - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].toArray(e, t + i * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, i = e.y, o = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * o, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * o, t[6] = 0.315392 * (3 * o * o - 1), t[7] = 1.092548 * n * o, t[8] = 0.546274 * (n * n - i * i);
  }
}
class FL extends xv {
  constructor(e = new YL(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class uV extends gI {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, i) {
    const o = this, l = new Jm(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (I) {
        i ? i(I) : console.error(I), o.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = this.textures;
    function n(o) {
      return t[o] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", o), t[o];
    }
    const i = uV.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new ai().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const o in e.uniforms) {
        const l = e.uniforms[o];
        switch (i.uniforms[o] = {}, l.type) {
          case "t":
            i.uniforms[o].value = n(l.value);
            break;
          case "c":
            i.uniforms[o].value = new ai().setHex(l.value);
            break;
          case "v2":
            i.uniforms[o].value = new Lt().fromArray(l.value);
            break;
          case "v3":
            i.uniforms[o].value = new fe().fromArray(l.value);
            break;
          case "v4":
            i.uniforms[o].value = new Ha().fromArray(l.value);
            break;
          case "m3":
            i.uniforms[o].value = new Cr().fromArray(l.value);
            break;
          case "m4":
            i.uniforms[o].value = new _i().fromArray(l.value);
            break;
          default:
            i.uniforms[o].value = l.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const o in e.extensions)
        i.extensions[o] = e.extensions[o];
    if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]), i.normalScale = new Lt().fromArray(o);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new Lt().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: hL,
      SpriteMaterial: pY,
      RawShaderMaterial: fL,
      ShaderMaterial: rf,
      PointsMaterial: AY,
      MeshPhysicalMaterial: pL,
      MeshStandardMaterial: ZY,
      MeshPhongMaterial: mL,
      MeshToonMaterial: AL,
      MeshNormalMaterial: vL,
      MeshLambertMaterial: yL,
      MeshDepthMaterial: CY,
      MeshDistanceMaterial: hY,
      MeshBasicMaterial: wv,
      MeshMatcapMaterial: bL,
      LineDashedMaterial: GL,
      LineBasicMaterial: ad,
      Material: Cg
    };
    return new t[e]();
  }
}
class nX {
  static decodeText(e) {
    if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class EL extends Br {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class TL extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = new Jm(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (I) {
        i ? i(I) : console.error(I), o.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = {}, n = {};
    function i(S, R) {
      if (t[R] !== void 0) return t[R];
      const x = S.interleavedBuffers[R], N = o(S, x.buffer), Y = $G(x.type, N), F = new UW(Y, x.stride);
      return F.uuid = x.uuid, t[R] = F, F;
    }
    function o(S, R) {
      if (n[R] !== void 0) return n[R];
      const x = S.arrayBuffers[R], N = new Uint32Array(x).buffer;
      return n[R] = N, N;
    }
    const l = e.isInstancedBufferGeometry ? new EL() : new Br(), u = e.data.index;
    if (u !== void 0) {
      const S = $G(u.type, u.array);
      l.setIndex(new ja(S, 1));
    }
    const I = e.data.attributes;
    for (const S in I) {
      const R = I[S];
      let W;
      if (R.isInterleavedBufferAttribute) {
        const x = i(e.data, R.data);
        W = new Zb(x, R.itemSize, R.offset, R.normalized);
      } else {
        const x = $G(R.type, R.array), N = R.isInstancedBufferAttribute ? pB : ja;
        W = new N(x, R.itemSize, R.normalized);
      }
      R.name !== void 0 && (W.name = R.name), R.usage !== void 0 && W.setUsage(R.usage), l.setAttribute(S, W);
    }
    const C = e.data.morphAttributes;
    if (C)
      for (const S in C) {
        const R = C[S], W = [];
        for (let x = 0, N = R.length; x < N; x++) {
          const Y = R[x];
          let F;
          if (Y.isInterleavedBufferAttribute) {
            const T = i(e.data, Y.data);
            F = new Zb(T, Y.itemSize, Y.offset, Y.normalized);
          } else {
            const T = $G(Y.type, Y.array);
            F = new ja(T, Y.itemSize, Y.normalized);
          }
          Y.name !== void 0 && (F.name = Y.name), W.push(F);
        }
        l.morphAttributes[S] = W;
      }
    e.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
    const v = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (v !== void 0)
      for (let S = 0, R = v.length; S !== R; ++S) {
        const W = v[S];
        l.addGroup(W.start, W.count, W.materialIndex);
      }
    const b = e.data.boundingSphere;
    if (b !== void 0) {
      const S = new fe();
      b.center !== void 0 && S.fromArray(b.center), l.boundingSphere = new dg(S, b.radius);
    }
    return e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l;
  }
}
class N$ extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = this.path === "" ? nX.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || l;
    const u = new Jm(this.manager);
    u.setPath(this.path), u.setRequestHeader(this.requestHeader), u.setWithCredentials(this.withCredentials), u.load(e, function(I) {
      let C = null;
      try {
        C = JSON.parse(I);
      } catch (v) {
        i !== void 0 && i(v), console.error("THREE:ObjectLoader: Can't parse " + e + ".", v.message);
        return;
      }
      const f = C.metadata;
      if (f === void 0 || f.type === void 0 || f.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      o.parse(C, t);
    }, n, i);
  }
  async loadAsync(e, t) {
    const n = this, i = this.path === "" ? nX.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new Jm(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const l = await o.loadAsync(e, t), u = JSON.parse(l), I = u.metadata;
    if (I === void 0 || I.type === void 0 || I.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(u);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), o = this.parseGeometries(e.geometries, i), l = this.parseImages(e.images, function() {
      t !== void 0 && t(C);
    }), u = this.parseTextures(e.textures, l), I = this.parseMaterials(e.materials, u), C = this.parseObject(e.object, o, I, u, n), f = this.parseSkeletons(e.skeletons, C);
    if (this.bindSkeletons(C, f), this.bindLightTargets(C), t !== void 0) {
      let v = !1;
      for (const b in l)
        if (l[b].data instanceof HTMLImageElement) {
          v = !0;
          break;
        }
      v === !1 && t(C);
    }
    return C;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), o = await this.parseImagesAsync(e.images), l = this.parseTextures(e.textures, o), u = this.parseMaterials(e.materials, l), I = this.parseObject(e.object, i, u, l, t), C = this.parseSkeletons(e.skeletons, I);
    return this.bindSkeletons(I, C), this.bindLightTargets(I), I;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const o = new mb().fromJSON(e[n]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, i = {};
    if (t.traverse(function(o) {
      o.isBone && (i[o.uuid] = o);
    }), e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const u = new OW().fromJSON(e[o], i);
        n[u.uuid] = u;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new TL();
      for (let o = 0, l = e.length; o < l; o++) {
        let u;
        const I = e[o];
        switch (I.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            u = i.parse(I);
            break;
          default:
            I.type in Q3 ? u = Q3[I.type].fromJSON(I, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${I.type}"`);
        }
        u.uuid = I.uuid, I.name !== void 0 && (u.name = I.name), I.userData !== void 0 && (u.userData = I.userData), n[I.uuid] = u;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, i = {};
    if (e !== void 0) {
      const o = new uV();
      o.setTextures(t);
      for (let l = 0, u = e.length; l < u; l++) {
        const I = e[l];
        n[I.uuid] === void 0 && (n[I.uuid] = o.parse(I)), i[I.uuid] = n[I.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n], o = Fw.parse(i);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, i = {};
    let o;
    function l(I) {
      return n.manager.itemStart(I), o.load(I, function() {
        n.manager.itemEnd(I);
      }, void 0, function() {
        n.manager.itemError(I), n.manager.itemEnd(I);
      });
    }
    function u(I) {
      if (typeof I == "string") {
        const C = I, f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(C) ? C : n.resourcePath + C;
        return l(f);
      } else
        return I.data ? {
          data: $G(I.type, I.data),
          width: I.width,
          height: I.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const I = new WY(t);
      o = new Ew(I), o.setCrossOrigin(this.crossOrigin);
      for (let C = 0, f = e.length; C < f; C++) {
        const v = e[C], b = v.url;
        if (Array.isArray(b)) {
          const S = [];
          for (let R = 0, W = b.length; R < W; R++) {
            const x = b[R], N = u(x);
            N !== null && (N instanceof HTMLImageElement ? S.push(N) : S.push(new gp(N.data, N.width, N.height)));
          }
          i[v.uuid] = new gb(S);
        } else {
          const S = u(v.url);
          i[v.uuid] = new gb(S);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let i;
    async function o(l) {
      if (typeof l == "string") {
        const u = l, I = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : t.resourcePath + u;
        return await i.loadAsync(I);
      } else
        return l.data ? {
          data: $G(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new Ew(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let l = 0, u = e.length; l < u; l++) {
        const I = e[l], C = I.url;
        if (Array.isArray(C)) {
          const f = [];
          for (let v = 0, b = C.length; v < b; v++) {
            const S = C[v], R = await o(S);
            R !== null && (R instanceof HTMLImageElement ? f.push(R) : f.push(new gp(R.data, R.width, R.height)));
          }
          n[I.uuid] = new gb(f);
        } else {
          const f = await o(I.url);
          n[I.uuid] = new gb(f);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(o, l) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), l[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const u = e[o];
        u.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', u.uuid), t[u.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", u.image);
        const I = t[u.image], C = I.data;
        let f;
        Array.isArray(C) ? (f = new eR(), C.length === 6 && (f.needsUpdate = !0)) : (C && C.data ? f = new gp() : f = new ks(), C && (f.needsUpdate = !0)), f.source = I, f.uuid = u.uuid, u.name !== void 0 && (f.name = u.name), u.mapping !== void 0 && (f.mapping = n(u.mapping, M$)), u.channel !== void 0 && (f.channel = u.channel), u.offset !== void 0 && f.offset.fromArray(u.offset), u.repeat !== void 0 && f.repeat.fromArray(u.repeat), u.center !== void 0 && f.center.fromArray(u.center), u.rotation !== void 0 && (f.rotation = u.rotation), u.wrap !== void 0 && (f.wrapS = n(u.wrap[0], e5), f.wrapT = n(u.wrap[1], e5)), u.format !== void 0 && (f.format = u.format), u.internalFormat !== void 0 && (f.internalFormat = u.internalFormat), u.type !== void 0 && (f.type = u.type), u.colorSpace !== void 0 && (f.colorSpace = u.colorSpace), u.minFilter !== void 0 && (f.minFilter = n(u.minFilter, t5)), u.magFilter !== void 0 && (f.magFilter = n(u.magFilter, t5)), u.anisotropy !== void 0 && (f.anisotropy = u.anisotropy), u.flipY !== void 0 && (f.flipY = u.flipY), u.generateMipmaps !== void 0 && (f.generateMipmaps = u.generateMipmaps), u.premultiplyAlpha !== void 0 && (f.premultiplyAlpha = u.premultiplyAlpha), u.unpackAlignment !== void 0 && (f.unpackAlignment = u.unpackAlignment), u.compareFunction !== void 0 && (f.compareFunction = u.compareFunction), u.userData !== void 0 && (f.userData = u.userData), i[u.uuid] = f;
      }
    return i;
  }
  parseObject(e, t, n, i, o) {
    let l;
    function u(b) {
      return t[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", b), t[b];
    }
    function I(b) {
      if (b !== void 0) {
        if (Array.isArray(b)) {
          const S = [];
          for (let R = 0, W = b.length; R < W; R++) {
            const x = b[R];
            n[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), S.push(n[x]);
          }
          return S;
        }
        return n[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", b), n[b];
      }
    }
    function C(b) {
      return i[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", b), i[b];
    }
    let f, v;
    switch (e.type) {
      case "Scene":
        l = new fY(), e.background !== void 0 && (Number.isInteger(e.background) ? l.background = new ai(e.background) : l.background = C(e.background)), e.environment !== void 0 && (l.environment = C(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? l.fog = new DW(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (l.fog = new kW(e.fog.color, e.fog.density)), e.fog.name !== "" && (l.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (l.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (l.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && l.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (l.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && l.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        l = new hl(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (l.focus = e.focus), e.zoom !== void 0 && (l.zoom = e.zoom), e.filmGauge !== void 0 && (l.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (l.filmOffset = e.filmOffset), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        l = new pv(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (l.zoom = e.zoom), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        l = new HL(e.color, e.intensity);
        break;
      case "DirectionalLight":
        l = new ML(e.color, e.intensity), l.target = e.target || "";
        break;
      case "PointLight":
        l = new NL(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        l = new XL(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        l = new VL(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), l.target = e.target || "";
        break;
      case "HemisphereLight":
        l = new WL(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        l = new FL().fromJSON(e);
        break;
      case "SkinnedMesh":
        f = u(e.geometry), v = I(e.material), l = new tL(f, v), e.bindMode !== void 0 && (l.bindMode = e.bindMode), e.bindMatrix !== void 0 && l.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (l.skeleton = e.skeleton);
        break;
      case "Mesh":
        f = u(e.geometry), v = I(e.material), l = new kl(f, v);
        break;
      case "InstancedMesh":
        f = u(e.geometry), v = I(e.material);
        const b = e.count, S = e.instanceMatrix, R = e.instanceColor;
        l = new lB(f, v, b), l.instanceMatrix = new pB(new Float32Array(S.array), 16), R !== void 0 && (l.instanceColor = new pB(new Float32Array(R.array), R.itemSize));
        break;
      case "BatchedMesh":
        f = u(e.geometry), v = I(e.material), l = new nL(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, v), l.geometry = f, l.perObjectFrustumCulled = e.perObjectFrustumCulled, l.sortObjects = e.sortObjects, l._drawRanges = e.drawRanges, l._reservedRanges = e.reservedRanges, l._visibility = e.visibility, l._active = e.active, l._bounds = e.bounds.map((W) => {
          const x = new nd();
          x.min.fromArray(W.boxMin), x.max.fromArray(W.boxMax);
          const N = new dg();
          return N.radius = W.sphereRadius, N.center.fromArray(W.sphereCenter), {
            boxInitialized: W.boxInitialized,
            box: x,
            sphereInitialized: W.sphereInitialized,
            sphere: N
          };
        }), l._maxInstanceCount = e.maxInstanceCount, l._maxVertexCount = e.maxVertexCount, l._maxIndexCount = e.maxIndexCount, l._geometryInitialized = e.geometryInitialized, l._geometryCount = e.geometryCount, l._matricesTexture = C(e.matricesTexture.uuid), e.colorsTexture !== void 0 && (l._colorsTexture = C(e.colorsTexture.uuid));
        break;
      case "LOD":
        l = new eL();
        break;
      case "Line":
        l = new Gv(u(e.geometry), I(e.material));
        break;
      case "LineLoop":
        l = new iL(u(e.geometry), I(e.material));
        break;
      case "LineSegments":
        l = new pp(u(e.geometry), I(e.material));
        break;
      case "PointCloud":
      case "Points":
        l = new rL(u(e.geometry), I(e.material));
        break;
      case "Sprite":
        l = new $K(I(e.material));
        break;
      case "Group":
        l = new tB();
        break;
      case "Bone":
        l = new mY();
        break;
      default:
        l = new qr();
    }
    if (l.uuid = e.uuid, e.name !== void 0 && (l.name = e.name), e.matrix !== void 0 ? (l.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (l.matrixAutoUpdate = e.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (e.position !== void 0 && l.position.fromArray(e.position), e.rotation !== void 0 && l.rotation.fromArray(e.rotation), e.quaternion !== void 0 && l.quaternion.fromArray(e.quaternion), e.scale !== void 0 && l.scale.fromArray(e.scale)), e.up !== void 0 && l.up.fromArray(e.up), e.castShadow !== void 0 && (l.castShadow = e.castShadow), e.receiveShadow !== void 0 && (l.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (l.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (l.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (l.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (l.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && l.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (l.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (l.visible = e.visible), e.frustumCulled !== void 0 && (l.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (l.renderOrder = e.renderOrder), e.userData !== void 0 && (l.userData = e.userData), e.layers !== void 0 && (l.layers.mask = e.layers), e.children !== void 0) {
      const b = e.children;
      for (let S = 0; S < b.length; S++)
        l.add(this.parseObject(b[S], t, n, i, o));
    }
    if (e.animations !== void 0) {
      const b = e.animations;
      for (let S = 0; S < b.length; S++) {
        const R = b[S];
        l.animations.push(o[R]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (l.autoUpdate = e.autoUpdate);
      const b = e.levels;
      for (let S = 0; S < b.length; S++) {
        const R = b[S], W = l.getObjectByProperty("uuid", R.object);
        W !== void 0 && l.addLevel(W, R.distance, R.hysteresis);
      }
    }
    return l;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const i = t[n.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
      }
    });
  }
  bindLightTargets(e) {
    e.traverse(function(t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const n = t.target, i = e.getObjectByProperty("uuid", n);
        i !== void 0 ? t.target = i : t.target = new qr();
      }
    });
  }
}
const M$ = {
  UVMapping: NW,
  CubeReflectionMapping: Om,
  CubeRefractionMapping: bv,
  EquirectangularReflectionMapping: Aw,
  EquirectangularRefractionMapping: vw,
  CubeUVReflectionMapping: xB
}, e5 = {
  RepeatWrapping: yw,
  ClampToEdgeWrapping: PC,
  MirroredRepeatWrapping: bw
}, t5 = {
  NearestFilter: Lu,
  NearestMipmapNearestFilter: jX,
  NearestMipmapLinearFilter: qG,
  LinearFilter: Ks,
  LinearMipmapNearestFilter: jZ,
  LinearMipmapLinearFilter: ap
};
class H$ extends gI {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = Km.get(e);
    if (l !== void 0) {
      if (o.manager.itemStart(e), l.then) {
        l.then((C) => {
          t && t(C), o.manager.itemEnd(e);
        }).catch((C) => {
          i && i(C);
        });
        return;
      }
      return setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    }
    const u = {};
    u.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", u.headers = this.requestHeader;
    const I = fetch(e, u).then(function(C) {
      return C.blob();
    }).then(function(C) {
      return createImageBitmap(C, Object.assign(o.options, { colorSpaceConversion: "none" }));
    }).then(function(C) {
      return Km.add(e, C), t && t(C), o.manager.itemEnd(e), C;
    }).catch(function(C) {
      i && i(C), Km.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
    });
    Km.add(e, I), o.manager.itemStart(e);
  }
}
let z1;
class NY {
  static getContext() {
    return z1 === void 0 && (z1 = new (window.AudioContext || window.webkitAudioContext)()), z1;
  }
  static setContext(e) {
    z1 = e;
  }
}
class X$ extends gI {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = new Jm(this.manager);
    l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(I) {
      try {
        const C = I.slice(0);
        NY.getContext().decodeAudioData(C, function(v) {
          t(v);
        }).catch(u);
      } catch (C) {
        u(C);
      }
    }, n, i);
    function u(I) {
      i ? i(I) : console.error(I), o.manager.itemError(e);
    }
  }
}
const n5 = /* @__PURE__ */ new _i(), i5 = /* @__PURE__ */ new _i(), ky = /* @__PURE__ */ new _i();
class Y$ {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new hl(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new hl(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ky.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, o = i * t.near / t.focus, l = t.near * Math.tan(fb * t.fov * 0.5) / t.zoom;
      let u, I;
      i5.elements[12] = -i, n5.elements[12] = i, u = -l * t.aspect + o, I = l * t.aspect + o, ky.elements[0] = 2 * t.near / (I - u), ky.elements[8] = (I + u) / (I - u), this.cameraL.projectionMatrix.copy(ky), u = -l * t.aspect - o, I = l * t.aspect - o, ky.elements[0] = 2 * t.near / (I - u), ky.elements[8] = (I + u) / (I - u), this.cameraR.projectionMatrix.copy(ky);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(i5), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(n5);
  }
}
class MY {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = r5(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = r5();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function r5() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Dy = /* @__PURE__ */ new fe(), a5 = /* @__PURE__ */ new ku(), F$ = /* @__PURE__ */ new fe(), Uy = /* @__PURE__ */ new fe();
class E$ extends qr {
  constructor() {
    super(), this.type = "AudioListener", this.context = NY.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new MY();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Dy, a5, F$), Uy.set(0, 0, -1).applyQuaternion(a5), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Dy.x, i), t.positionY.linearRampToValueAtTime(Dy.y, i), t.positionZ.linearRampToValueAtTime(Dy.z, i), t.forwardX.linearRampToValueAtTime(Uy.x, i), t.forwardY.linearRampToValueAtTime(Uy.y, i), t.forwardZ.linearRampToValueAtTime(Uy.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition(Dy.x, Dy.y, Dy.z), t.setOrientation(Uy.x, Uy.y, Uy.z, n.x, n.y, n.z);
  }
}
class _L extends qr {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const Oy = /* @__PURE__ */ new fe(), o5 = /* @__PURE__ */ new ku(), T$ = /* @__PURE__ */ new fe(), Py = /* @__PURE__ */ new fe();
class _$ extends _L {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(Oy, o5, T$), Py.set(0, 0, 1).applyQuaternion(o5);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Oy.x, n), t.positionY.linearRampToValueAtTime(Oy.y, n), t.positionZ.linearRampToValueAtTime(Oy.z, n), t.orientationX.linearRampToValueAtTime(Py.x, n), t.orientationY.linearRampToValueAtTime(Py.y, n), t.orientationZ.linearRampToValueAtTime(Py.z, n);
    } else
      t.setPosition(Oy.x, Oy.y, Oy.z), t.setOrientation(Py.x, Py.y, Py.z);
  }
}
class z$ {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class zL {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let i, o, l;
    switch (t) {
      case "quaternion":
        i = this._slerp, o = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, o = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        i = this._lerp, o = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = o, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, i = this.valueSize, o = e * i + i;
    let l = this.cumulativeWeight;
    if (l === 0) {
      for (let u = 0; u !== i; ++u)
        n[o + u] = n[u];
      l = t;
    } else {
      l += t;
      const u = t / l;
      this._mixBufferRegion(n, o, 0, u, i);
    }
    this.cumulativeWeight = l;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, i = e * t + t, o = this.cumulativeWeight, l = this.cumulativeWeightAdditive, u = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
      const I = t * this._origIndex;
      this._mixBufferRegion(
        n,
        i,
        I,
        1 - o,
        t
      );
    }
    l > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let I = t, C = t + t; I !== C; ++I)
      if (n[I] !== n[I + t]) {
        u.setValue(n, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
    e.getValue(t, i);
    for (let o = n, l = i; o !== l; ++o)
      t[o] = t[i + o % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, i, o) {
    if (i >= 0.5)
      for (let l = 0; l !== o; ++l)
        e[t + l] = e[n + l];
  }
  _slerp(e, t, n, i) {
    ku.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, o) {
    const l = this._workIndex * o;
    ku.multiplyQuaternionsFlat(e, l, e, t, e, n), ku.slerpFlat(e, t, e, t, e, l, i);
  }
  _lerp(e, t, n, i, o) {
    const l = 1 - i;
    for (let u = 0; u !== o; ++u) {
      const I = t + u;
      e[I] = e[I] * l + e[n + u] * i;
    }
  }
  _lerpAdditive(e, t, n, i, o) {
    for (let l = 0; l !== o; ++l) {
      const u = t + l;
      e[u] = e[u] + e[n + l] * i;
    }
  }
}
const HY = "\\[\\]\\.:\\/", K$ = new RegExp("[" + HY + "]", "g"), XY = "[^" + HY + "]", L$ = "[^" + HY.replace("\\.", "") + "]", k$ = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", XY), D$ = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", L$), U$ = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", XY), O$ = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", XY), P$ = new RegExp(
  "^" + k$ + D$ + U$ + O$ + "$"
), J$ = ["material", "materials", "bones", "map"];
class Q$ {
  constructor(e, t, n) {
    const i = n || Ca.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = n.length; i !== o; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Ca {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || Ca.parseTrackName(t), this.node = Ca.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Ca.Composite(e, t, n) : new Ca(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(K$, "");
  }
  static parseTrackName(e) {
    const t = P$.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = n.nodeName.substring(i + 1);
      J$.indexOf(o) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = o);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(o) {
        for (let l = 0; l < o.length; l++) {
          const u = o[l];
          if (u.name === t || u.uuid === t)
            return u;
          const I = n(u.children);
          if (I) return I;
        }
        return null;
      }, i = n(e.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i)
      e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i)
      n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i)
      n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i)
      n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, i = t.propertyName;
    let o = t.propertyIndex;
    if (e || (e = Ca.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let C = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let f = 0; f < e.length; f++)
            if (e[f].name === C) {
              C = f;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (C !== void 0) {
        if (e[C] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[C];
      }
    }
    const l = e[i];
    if (l === void 0) {
      const C = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + C + "." + i + " but it wasn't found.", e);
      return;
    }
    let u = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? u = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (u = this.Versioning.MatrixWorldNeedsUpdate);
    let I = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]);
      }
      I = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o;
    } else l.fromArray !== void 0 && l.toArray !== void 0 ? (I = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (I = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[I], this.setValue = this.SetterByBindingTypeAndVersioning[I][u];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Ca.Composite = Q$;
Ca.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Ca.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Ca.prototype.GetterByBindingType = [
  Ca.prototype._getValue_direct,
  Ca.prototype._getValue_array,
  Ca.prototype._getValue_arrayElement,
  Ca.prototype._getValue_toArray
];
Ca.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Ca.prototype._setValue_direct,
    Ca.prototype._setValue_direct_setNeedsUpdate,
    Ca.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Ca.prototype._setValue_array,
    Ca.prototype._setValue_array_setNeedsUpdate,
    Ca.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Ca.prototype._setValue_arrayElement,
    Ca.prototype._setValue_arrayElement_setNeedsUpdate,
    Ca.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Ca.prototype._setValue_fromArray,
    Ca.prototype._setValue_fromArray_setNeedsUpdate,
    Ca.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class j$ {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = PI(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, o = this._bindings, l = o.length;
    let u, I = e.length, C = this.nCachedObjects_;
    for (let f = 0, v = arguments.length; f !== v; ++f) {
      const b = arguments[f], S = b.uuid;
      let R = t[S];
      if (R === void 0) {
        R = I++, t[S] = R, e.push(b);
        for (let W = 0, x = l; W !== x; ++W)
          o[W].push(new Ca(b, n[W], i[W]));
      } else if (R < C) {
        u = e[R];
        const W = --C, x = e[W];
        t[x.uuid] = R, e[R] = x, t[S] = W, e[W] = b;
        for (let N = 0, Y = l; N !== Y; ++N) {
          const F = o[N], T = F[W];
          let P = F[R];
          F[R] = T, P === void 0 && (P = new Ca(b, n[N], i[N])), F[W] = P;
        }
      } else e[R] !== u && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = C;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let o = this.nCachedObjects_;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const I = arguments[l], C = I.uuid, f = t[C];
      if (f !== void 0 && f >= o) {
        const v = o++, b = e[v];
        t[b.uuid] = f, e[f] = b, t[C] = v, e[v] = I;
        for (let S = 0, R = i; S !== R; ++S) {
          const W = n[S], x = W[v], N = W[f];
          W[f] = x, W[v] = N;
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let o = this.nCachedObjects_, l = e.length;
    for (let u = 0, I = arguments.length; u !== I; ++u) {
      const C = arguments[u], f = C.uuid, v = t[f];
      if (v !== void 0)
        if (delete t[f], v < o) {
          const b = --o, S = e[b], R = --l, W = e[R];
          t[S.uuid] = v, e[v] = S, t[W.uuid] = b, e[b] = W, e.pop();
          for (let x = 0, N = i; x !== N; ++x) {
            const Y = n[x], F = Y[b], T = Y[R];
            Y[v] = F, Y[b] = T, Y.pop();
          }
        } else {
          const b = --l, S = e[b];
          b > 0 && (t[S.uuid] = v), e[v] = S, e.pop();
          for (let R = 0, W = i; R !== W; ++R) {
            const x = n[R];
            x[v] = x[b], x.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const o = this._bindings;
    if (i !== void 0) return o[i];
    const l = this._paths, u = this._parsedPaths, I = this._objects, C = I.length, f = this.nCachedObjects_, v = new Array(C);
    i = o.length, n[e] = i, l.push(e), u.push(t), o.push(v);
    for (let b = f, S = I.length; b !== S; ++b) {
      const R = I[b];
      v[b] = new Ca(R, e, t);
    }
    return v;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const i = this._paths, o = this._parsedPaths, l = this._bindings, u = l.length - 1, I = l[u], C = e[u];
      t[C] = n, l[n] = I, l.pop(), o[n] = o[u], o.pop(), i[n] = i[u], i.pop();
    }
  }
}
class KL {
  constructor(e, t, n = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
    const o = t.tracks, l = o.length, u = new Array(l), I = {
      endingStart: ub,
      endingEnd: ub
    };
    for (let C = 0; C !== l; ++C) {
      const f = o[C].createInterpolant(null);
      u[C] = f, f.settings = I;
    }
    this._interpolantSettings = I, this._interpolants = u, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = bK, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const i = this._clip.duration, o = e._clip.duration, l = o / i, u = i / o;
      e.warp(1, l, t), this.warp(u, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer, o = i.time, l = this.timeScale;
    let u = this._timeScaleInterpolant;
    u === null && (u = i._lendControlInterpolant(), this._timeScaleInterpolant = u);
    const I = u.parameterPositions, C = u.sampleValues;
    return I[0] = o, I[1] = o + n, C[0] = e / l, C[1] = t / l, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const I = (e - o) * n;
      I < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * I);
    }
    t *= this._updateTimeScale(e);
    const l = this._updateTime(t), u = this._updateWeight(e);
    if (u > 0) {
      const I = this._interpolants, C = this._propertyBindings;
      switch (this.blendMode) {
        case sY:
          for (let f = 0, v = I.length; f !== v; ++f)
            I[f].evaluate(l), C[f].accumulateAdditive(u);
          break;
        case TW:
        default:
          for (let f = 0, v = I.length; f !== v; ++f)
            I[f].evaluate(l), C[f].accumulate(i, u);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let i = this.time + e, o = this._loopCount;
    const l = n === GK;
    if (e === 0)
      return o === -1 ? i : l && (o & 1) === 1 ? t - i : i;
    if (n === yK) {
      o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), i >= t || i < 0) {
        const u = Math.floor(i / t);
        i -= t * u, o += Math.abs(u);
        const I = this.repetitions - o;
        if (I <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (I === 1) {
            const C = e < 0;
            this._setEndings(C, !C, l);
          } else
            this._setEndings(!1, !1, l);
          this._loopCount = o, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: u
          });
        }
      } else
        this.time = i;
      if (l && (o & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n ? (i.endingStart = cb, i.endingEnd = cb) : (e ? i.endingStart = this.zeroSlopeAtStart ? cb : ub : i.endingStart = Bw, t ? i.endingEnd = this.zeroSlopeAtEnd ? cb : ub : i.endingEnd = Bw);
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer, o = i.time;
    let l = this._weightInterpolant;
    l === null && (l = i._lendControlInterpolant(), this._weightInterpolant = l);
    const u = l.parameterPositions, I = l.sampleValues;
    return u[0] = o, I[0] = t, u[1] = o + e, I[1] = n, this;
  }
}
const q$ = new Float32Array(1);
class $$ extends eA {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, i = e._clip.tracks, o = i.length, l = e._propertyBindings, u = e._interpolants, I = n.uuid, C = this._bindingsByRootAndName;
    let f = C[I];
    f === void 0 && (f = {}, C[I] = f);
    for (let v = 0; v !== o; ++v) {
      const b = i[v], S = b.name;
      let R = f[S];
      if (R !== void 0)
        ++R.referenceCount, l[v] = R;
      else {
        if (R = l[v], R !== void 0) {
          R._cacheIndex === null && (++R.referenceCount, this._addInactiveBinding(R, I, S));
          continue;
        }
        const W = t && t._propertyBindings[v].binding.parsedPath;
        R = new zL(
          Ca.create(n, S, W),
          b.ValueTypeName,
          b.getValueSize()
        ), ++R.referenceCount, this._addInactiveBinding(R, I, S), l[v] = R;
      }
      u[v].resultBuffer = R.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, o = this._actionsByClip[i];
        this._bindAction(
          e,
          o && o.knownActions[0]
        ), this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const o = t[n];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const o = t[n];
        --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions, o = this._actionsByClip;
    let l = o[t];
    if (l === void 0)
      l = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, o[t] = l;
    else {
      const u = l.knownActions;
      e._byClipCacheIndex = u.length, u.push(e);
    }
    e._cacheIndex = i.length, i.push(e), l.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
    const o = e._clip.uuid, l = this._actionsByClip, u = l[o], I = u.knownActions, C = I[I.length - 1], f = e._byClipCacheIndex;
    C._byClipCacheIndex = f, I[f] = C, I.pop(), e._byClipCacheIndex = null;
    const v = u.actionByRoot, b = (e._localRoot || this._root).uuid;
    delete v[b], I.length === 0 && delete l[o], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const o = t[n];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = n, t[n] = o;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = n, t[n] = o;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName, o = this._bindings;
    let l = i[t];
    l === void 0 && (l = {}, i[t] = l), l[n] = e, e._cacheIndex = o.length, o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, i = n.rootNode.uuid, o = n.path, l = this._bindingsByRootAndName, u = l[i], I = t[t.length - 1], C = e._cacheIndex;
    I._cacheIndex = C, t[C] = I, t.pop(), delete u[o], Object.keys(u).length === 0 && delete l[i];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = n, t[n] = o;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = n, t[n] = o;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new RY(
      new Float32Array(2),
      new Float32Array(2),
      1,
      q$
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, o = t[i];
    e.__cacheIndex = i, t[i] = e, o.__cacheIndex = n, t[n] = o;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const i = t || this._root, o = i.uuid;
    let l = typeof e == "string" ? Fw.findByName(i, e) : e;
    const u = l !== null ? l.uuid : e, I = this._actionsByClip[u];
    let C = null;
    if (n === void 0 && (l !== null ? n = l.blendMode : n = TW), I !== void 0) {
      const v = I.actionByRoot[o];
      if (v !== void 0 && v.blendMode === n)
        return v;
      C = I.knownActions[0], l === null && (l = C._clip);
    }
    if (l === null) return null;
    const f = new KL(this, l, t, n);
    return this._bindAction(f, C), this._addInactiveAction(f, u, o), f;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, i = n.uuid, o = typeof e == "string" ? Fw.findByName(n, e) : e, l = o ? o.uuid : e, u = this._actionsByClip[l];
    return u !== void 0 && u.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, i = this.time += e, o = Math.sign(e), l = this._accuIndex ^= 1;
    for (let C = 0; C !== n; ++C)
      t[C]._update(i, e, o, l);
    const u = this._bindings, I = this._nActiveBindings;
    for (let C = 0; C !== I; ++C)
      u[C].apply(l);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, i = this._actionsByClip, o = i[n];
    if (o !== void 0) {
      const l = o.knownActions;
      for (let u = 0, I = l.length; u !== I; ++u) {
        const C = l[u];
        this._deactivateAction(C);
        const f = C._cacheIndex, v = t[t.length - 1];
        C._cacheIndex = null, C._byClipCacheIndex = null, v._cacheIndex = f, t[f] = v, t.pop(), this._removeInactiveBindingsForAction(C);
      }
      delete i[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const l in n) {
      const u = n[l].actionByRoot, I = u[t];
      I !== void 0 && (this._deactivateAction(I), this._removeInactiveAction(I));
    }
    const i = this._bindingsByRootAndName, o = i[t];
    if (o !== void 0)
      for (const l in o) {
        const u = o[l];
        u.restoreOriginalState(), this._removeInactiveBinding(u);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class YY {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new YY(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let eee = 0;
class tee extends eA {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: eee++ }), this.name = "", this.usage = Rw, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) {
      const o = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let l = 0; l < o.length; l++)
        this.uniforms.push(o[l].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class nee extends UW {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class iee {
  constructor(e, t, n, i, o) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = o, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
const s5 = /* @__PURE__ */ new _i();
class FY {
  constructor(e, t, n = 0, i = 1 / 0) {
    this.ray = new Nb(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new pb(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return s5.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(s5), this;
  }
  intersectObject(e, t = !0, n = []) {
    return iX(e, this, n, t), n.sort(l5), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, o = e.length; i < o; i++)
      iX(e[i], this, n, t);
    return n.sort(l5), n;
  }
}
function l5(r, e) {
  return r.distance - e.distance;
}
function iX(r, e, t, n) {
  let i = !0;
  if (r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1), i === !0 && n === !0) {
    const o = r.children;
    for (let l = 0, u = o.length; l < u; l++)
      iX(o[l], e, t, !0);
  }
}
class rX {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(zs(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ree {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class EY {
  constructor(e, t, n, i) {
    EY.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i);
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 4; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  set(e, t, n, i) {
    const o = this.elements;
    return o[0] = e, o[2] = t, o[1] = n, o[3] = i, this;
  }
}
const u5 = /* @__PURE__ */ new Lt();
class aee {
  constructor(e = new Lt(1 / 0, 1 / 0), t = new Lt(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = u5.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y;
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, u5).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const c5 = /* @__PURE__ */ new fe(), K1 = /* @__PURE__ */ new fe();
class oee {
  constructor(e = new fe(), t = new fe()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    c5.subVectors(e, this.start), K1.subVectors(this.end, this.start);
    const n = K1.dot(K1);
    let o = K1.dot(c5) / n;
    return t && (o = zs(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const g5 = /* @__PURE__ */ new fe();
class see extends qr {
  constructor(e, t) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new Br(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let l = 0, u = 1, I = 32; l < I; l++, u++) {
      const C = l / I * Math.PI * 2, f = u / I * Math.PI * 2;
      i.push(
        Math.cos(C),
        Math.sin(C),
        1,
        Math.cos(f),
        Math.sin(f),
        1
      );
    }
    n.setAttribute("position", new fi(i, 3));
    const o = new ad({ fog: !1, toneMapped: !1 });
    this.cone = new pp(n, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), g5.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(g5), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const sv = /* @__PURE__ */ new fe(), L1 = /* @__PURE__ */ new _i(), rH = /* @__PURE__ */ new _i();
class lee extends pp {
  constructor(e) {
    const t = LL(e), n = new Br(), i = [], o = [], l = new ai(0, 0, 1), u = new ai(0, 1, 0);
    for (let C = 0; C < t.length; C++) {
      const f = t[C];
      f.parent && f.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), o.push(l.r, l.g, l.b), o.push(u.r, u.g, u.b));
    }
    n.setAttribute("position", new fi(i, 3)), n.setAttribute("color", new fi(o, 3));
    const I = new ad({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, I), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, i = n.getAttribute("position");
    rH.copy(this.root.matrixWorld).invert();
    for (let o = 0, l = 0; o < t.length; o++) {
      const u = t[o];
      u.parent && u.parent.isBone && (L1.multiplyMatrices(rH, u.matrixWorld), sv.setFromMatrixPosition(L1), i.setXYZ(l, sv.x, sv.y, sv.z), L1.multiplyMatrices(rH, u.parent.matrixWorld), sv.setFromMatrixPosition(L1), i.setXYZ(l + 1, sv.x, sv.y, sv.z), l += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function LL(r) {
  const e = [];
  r.isBone === !0 && e.push(r);
  for (let t = 0; t < r.children.length; t++)
    e.push.apply(e, LL(r.children[t]));
  return e;
}
class uee extends kl {
  constructor(e, t, n) {
    const i = new rR(t, 4, 2), o = new wv({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const cee = /* @__PURE__ */ new fe(), d5 = /* @__PURE__ */ new ai(), I5 = /* @__PURE__ */ new ai();
class gee extends qr {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const i = new iR(t);
    i.rotateY(Math.PI * 0.5), this.material = new wv({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"), l = new Float32Array(o.count * 3);
    i.setAttribute("color", new ja(l, 3)), this.add(new kl(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      d5.copy(this.light.color), I5.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const o = n < i / 2 ? d5 : I5;
        t.setXYZ(n, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(cee.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class dee extends pp {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    n = new ai(n), i = new ai(i);
    const o = t / 2, l = e / t, u = e / 2, I = [], C = [];
    for (let b = 0, S = 0, R = -u; b <= t; b++, R += l) {
      I.push(-u, 0, R, u, 0, R), I.push(R, 0, -u, R, 0, u);
      const W = b === o ? n : i;
      W.toArray(C, S), S += 3, W.toArray(C, S), S += 3, W.toArray(C, S), S += 3, W.toArray(C, S), S += 3;
    }
    const f = new Br();
    f.setAttribute("position", new fi(I, 3)), f.setAttribute("color", new fi(C, 3));
    const v = new ad({ vertexColors: !0, toneMapped: !1 });
    super(f, v), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Iee extends pp {
  constructor(e = 10, t = 16, n = 8, i = 64, o = 4473924, l = 8947848) {
    o = new ai(o), l = new ai(l);
    const u = [], I = [];
    if (t > 1)
      for (let v = 0; v < t; v++) {
        const b = v / t * (Math.PI * 2), S = Math.sin(b) * e, R = Math.cos(b) * e;
        u.push(0, 0, 0), u.push(S, 0, R);
        const W = v & 1 ? o : l;
        I.push(W.r, W.g, W.b), I.push(W.r, W.g, W.b);
      }
    for (let v = 0; v < n; v++) {
      const b = v & 1 ? o : l, S = e - e / n * v;
      for (let R = 0; R < i; R++) {
        let W = R / i * (Math.PI * 2), x = Math.sin(W) * S, N = Math.cos(W) * S;
        u.push(x, 0, N), I.push(b.r, b.g, b.b), W = (R + 1) / i * (Math.PI * 2), x = Math.sin(W) * S, N = Math.cos(W) * S, u.push(x, 0, N), I.push(b.r, b.g, b.b);
      }
    }
    const C = new Br();
    C.setAttribute("position", new fi(u, 3)), C.setAttribute("color", new fi(I, 3));
    const f = new ad({ vertexColors: !0, toneMapped: !1 });
    super(C, f), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const C5 = /* @__PURE__ */ new fe(), k1 = /* @__PURE__ */ new fe(), h5 = /* @__PURE__ */ new fe();
class Cee extends qr {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let i = new Br();
    i.setAttribute("position", new fi([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const o = new ad({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Gv(i, o), this.add(this.lightPlane), i = new Br(), i.setAttribute("position", new fi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Gv(i, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), C5.setFromMatrixPosition(this.light.matrixWorld), k1.setFromMatrixPosition(this.light.target.matrixWorld), h5.subVectors(k1, C5), this.lightPlane.lookAt(k1), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(k1), this.targetLine.scale.z = h5.length();
  }
}
const D1 = /* @__PURE__ */ new fe(), _s = /* @__PURE__ */ new $w();
class hee extends pp {
  constructor(e) {
    const t = new Br(), n = new ad({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], o = [], l = {};
    u("n1", "n2"), u("n2", "n4"), u("n4", "n3"), u("n3", "n1"), u("f1", "f2"), u("f2", "f4"), u("f4", "f3"), u("f3", "f1"), u("n1", "f1"), u("n2", "f2"), u("n3", "f3"), u("n4", "f4"), u("p", "n1"), u("p", "n2"), u("p", "n3"), u("p", "n4"), u("u1", "u2"), u("u2", "u3"), u("u3", "u1"), u("c", "t"), u("p", "c"), u("cn1", "cn2"), u("cn3", "cn4"), u("cf1", "cf2"), u("cf3", "cf4");
    function u(R, W) {
      I(R), I(W);
    }
    function I(R) {
      i.push(0, 0, 0), o.push(0, 0, 0), l[R] === void 0 && (l[R] = []), l[R].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new fi(i, 3)), t.setAttribute("color", new fi(o, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = l, this.update();
    const C = new ai(16755200), f = new ai(16711680), v = new ai(43775), b = new ai(16777215), S = new ai(3355443);
    this.setColors(C, f, v, b, S);
  }
  setColors(e, t, n, i, o) {
    const u = this.geometry.getAttribute("color");
    u.setXYZ(0, e.r, e.g, e.b), u.setXYZ(1, e.r, e.g, e.b), u.setXYZ(2, e.r, e.g, e.b), u.setXYZ(3, e.r, e.g, e.b), u.setXYZ(4, e.r, e.g, e.b), u.setXYZ(5, e.r, e.g, e.b), u.setXYZ(6, e.r, e.g, e.b), u.setXYZ(7, e.r, e.g, e.b), u.setXYZ(8, e.r, e.g, e.b), u.setXYZ(9, e.r, e.g, e.b), u.setXYZ(10, e.r, e.g, e.b), u.setXYZ(11, e.r, e.g, e.b), u.setXYZ(12, e.r, e.g, e.b), u.setXYZ(13, e.r, e.g, e.b), u.setXYZ(14, e.r, e.g, e.b), u.setXYZ(15, e.r, e.g, e.b), u.setXYZ(16, e.r, e.g, e.b), u.setXYZ(17, e.r, e.g, e.b), u.setXYZ(18, e.r, e.g, e.b), u.setXYZ(19, e.r, e.g, e.b), u.setXYZ(20, e.r, e.g, e.b), u.setXYZ(21, e.r, e.g, e.b), u.setXYZ(22, e.r, e.g, e.b), u.setXYZ(23, e.r, e.g, e.b), u.setXYZ(24, t.r, t.g, t.b), u.setXYZ(25, t.r, t.g, t.b), u.setXYZ(26, t.r, t.g, t.b), u.setXYZ(27, t.r, t.g, t.b), u.setXYZ(28, t.r, t.g, t.b), u.setXYZ(29, t.r, t.g, t.b), u.setXYZ(30, t.r, t.g, t.b), u.setXYZ(31, t.r, t.g, t.b), u.setXYZ(32, n.r, n.g, n.b), u.setXYZ(33, n.r, n.g, n.b), u.setXYZ(34, n.r, n.g, n.b), u.setXYZ(35, n.r, n.g, n.b), u.setXYZ(36, n.r, n.g, n.b), u.setXYZ(37, n.r, n.g, n.b), u.setXYZ(38, i.r, i.g, i.b), u.setXYZ(39, i.r, i.g, i.b), u.setXYZ(40, o.r, o.g, o.b), u.setXYZ(41, o.r, o.g, o.b), u.setXYZ(42, o.r, o.g, o.b), u.setXYZ(43, o.r, o.g, o.b), u.setXYZ(44, o.r, o.g, o.b), u.setXYZ(45, o.r, o.g, o.b), u.setXYZ(46, o.r, o.g, o.b), u.setXYZ(47, o.r, o.g, o.b), u.setXYZ(48, o.r, o.g, o.b), u.setXYZ(49, o.r, o.g, o.b), u.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, i = 1;
    _s.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Il("c", t, e, _s, 0, 0, -1), Il("t", t, e, _s, 0, 0, 1), Il("n1", t, e, _s, -1, -1, -1), Il("n2", t, e, _s, n, -1, -1), Il("n3", t, e, _s, -1, i, -1), Il("n4", t, e, _s, n, i, -1), Il("f1", t, e, _s, -1, -1, 1), Il("f2", t, e, _s, n, -1, 1), Il("f3", t, e, _s, -1, i, 1), Il("f4", t, e, _s, n, i, 1), Il("u1", t, e, _s, n * 0.7, i * 1.1, -1), Il("u2", t, e, _s, -1 * 0.7, i * 1.1, -1), Il("u3", t, e, _s, 0, i * 2, -1), Il("cf1", t, e, _s, -1, 0, 1), Il("cf2", t, e, _s, n, 0, 1), Il("cf3", t, e, _s, 0, -1, 1), Il("cf4", t, e, _s, 0, i, 1), Il("cn1", t, e, _s, -1, 0, -1), Il("cn2", t, e, _s, n, 0, -1), Il("cn3", t, e, _s, 0, -1, -1), Il("cn4", t, e, _s, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Il(r, e, t, n, i, o, l) {
  D1.set(i, o, l).unproject(n);
  const u = e[r];
  if (u !== void 0) {
    const I = t.getAttribute("position");
    for (let C = 0, f = u.length; C < f; C++)
      I.setXYZ(u[C], D1.x, D1.y, D1.z);
  }
}
const U1 = /* @__PURE__ */ new nd();
class fee extends pp {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), o = new Br();
    o.setIndex(new ja(n, 1)), o.setAttribute("position", new ja(i, 3)), super(o, new ad({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && U1.setFromObject(this.object), U1.isEmpty()) return;
    const t = U1.min, n = U1.max, i = this.geometry.attributes.position, o = i.array;
    o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = t.x, o[4] = n.y, o[5] = n.z, o[6] = t.x, o[7] = t.y, o[8] = n.z, o[9] = n.x, o[10] = t.y, o[11] = n.z, o[12] = n.x, o[13] = n.y, o[14] = t.z, o[15] = t.x, o[16] = n.y, o[17] = t.z, o[18] = t.x, o[19] = t.y, o[20] = t.z, o[21] = n.x, o[22] = t.y, o[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class pee extends pp {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], o = new Br();
    o.setIndex(new ja(n, 1)), o.setAttribute("position", new fi(i, 3)), super(o, new ad({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class mee extends Gv {
  constructor(e, t = 1, n = 16776960) {
    const i = n, o = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], l = new Br();
    l.setAttribute("position", new fi(o, 3)), l.computeBoundingSphere(), super(l, new ad({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], I = new Br();
    I.setAttribute("position", new fi(u, 3)), I.computeBoundingSphere(), this.add(new kl(I, new wv({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const f5 = /* @__PURE__ */ new fe();
let O1, aH;
class Aee extends qr {
  // dir is assumed to be normalized
  constructor(e = new fe(0, 0, 1), t = new fe(0, 0, 0), n = 1, i = 16776960, o = n * 0.2, l = o * 0.2) {
    super(), this.type = "ArrowHelper", O1 === void 0 && (O1 = new Br(), O1.setAttribute("position", new fi([0, 0, 0, 0, 1, 0], 3)), aH = new NB(0, 0.5, 1, 5, 1), aH.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Gv(O1, new ad({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new kl(aH, new wv({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, o, l);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      f5.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(f5, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class vee extends pp {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new Br();
    i.setAttribute("position", new fi(t, 3)), i.setAttribute("color", new fi(n, 3));
    const o = new ad({ vertexColors: !0, toneMapped: !1 });
    super(i, o), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const i = new ai(), o = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(o, 0), i.toArray(o, 3), i.set(t), i.toArray(o, 6), i.toArray(o, 9), i.set(n), i.toArray(o, 12), i.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class yee {
  constructor() {
    this.type = "ShapePath", this.color = new ai(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new Vw(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, o, l) {
    return this.currentPath.bezierCurveTo(e, t, n, i, o, l), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(N) {
      const Y = [];
      for (let F = 0, T = N.length; F < T; F++) {
        const P = N[F], D = new mb();
        D.curves = P.curves, Y.push(D);
      }
      return Y;
    }
    function n(N, Y) {
      const F = Y.length;
      let T = !1;
      for (let P = F - 1, D = 0; D < F; P = D++) {
        let L = Y[P], j = Y[D], J = j.x - L.x, O = j.y - L.y;
        if (Math.abs(O) > Number.EPSILON) {
          if (O < 0 && (L = Y[D], J = -J, j = Y[P], O = -O), N.y < L.y || N.y > j.y) continue;
          if (N.y === L.y) {
            if (N.x === L.x) return !0;
          } else {
            const ne = O * (N.x - L.x) - J * (N.y - L.y);
            if (ne === 0) return !0;
            if (ne < 0) continue;
            T = !T;
          }
        } else {
          if (N.y !== L.y) continue;
          if (j.x <= N.x && N.x <= L.x || L.x <= N.x && N.x <= j.x) return !0;
        }
      }
      return T;
    }
    const i = dp.isClockWise, o = this.subPaths;
    if (o.length === 0) return [];
    let l, u, I;
    const C = [];
    if (o.length === 1)
      return u = o[0], I = new mb(), I.curves = u.curves, C.push(I), C;
    let f = !i(o[0].getPoints());
    f = e ? !f : f;
    const v = [], b = [];
    let S = [], R = 0, W;
    b[R] = void 0, S[R] = [];
    for (let N = 0, Y = o.length; N < Y; N++)
      u = o[N], W = u.getPoints(), l = i(W), l = e ? !l : l, l ? (!f && b[R] && R++, b[R] = { s: new mb(), p: W }, b[R].s.curves = u.curves, f && R++, S[R] = []) : S[R].push({ h: u, p: W[0] });
    if (!b[0]) return t(o);
    if (b.length > 1) {
      let N = !1, Y = 0;
      for (let F = 0, T = b.length; F < T; F++)
        v[F] = [];
      for (let F = 0, T = b.length; F < T; F++) {
        const P = S[F];
        for (let D = 0; D < P.length; D++) {
          const L = P[D];
          let j = !0;
          for (let J = 0; J < b.length; J++)
            n(L.p, b[J].p) && (F !== J && Y++, j ? (j = !1, v[J].push(L)) : N = !0);
          j && v[F].push(L);
        }
      }
      Y > 0 && N === !1 && (S = v);
    }
    let x;
    for (let N = 0, Y = b.length; N < Y; N++) {
      I = b[N].s, C.push(I), x = S[N];
      for (let F = 0, T = x.length; F < T; F++)
        I.holes.push(x[F].h);
    }
    return C;
  }
}
class bee extends QC {
  // @deprecated, r162
  constructor(e = 1, t = 1, n = 1, i = {}) {
    console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, { ...i, count: n }), this.isWebGLMultipleRenderTargets = !0;
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: WW
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = WW);
const Gee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: QX,
  AddEquation: gv,
  AddOperation: IK,
  AdditiveAnimationBlendMode: sY,
  AdditiveBlending: LH,
  AgXToneMapping: mK,
  AlphaFormat: tY,
  AlwaysCompare: MK,
  AlwaysDepth: oK,
  AlwaysStencilFunc: OH,
  AmbientLight: HL,
  AnimationAction: KL,
  AnimationClip: Fw,
  AnimationLoader: B$,
  AnimationMixer: $$,
  AnimationObjectGroup: j$,
  AnimationUtils: v$,
  ArcCurve: aL,
  ArrayCamera: QK,
  ArrowHelper: Aee,
  AttachedBindMode: UH,
  Audio: _L,
  AudioAnalyser: z$,
  AudioContext: NY,
  AudioListener: E$,
  AudioLoader: X$,
  AxesHelper: vee,
  BackSide: td,
  BasicDepthPacking: BK,
  BasicShadowMap: _z,
  BatchedMesh: nL,
  Bone: mY,
  BooleanKeyframeTrack: Hb,
  Box2: aee,
  Box3: nd,
  Box3Helper: pee,
  BoxGeometry: Mb,
  BoxHelper: fee,
  BufferAttribute: ja,
  BufferGeometry: Br,
  BufferGeometryLoader: TL,
  ByteType: qX,
  Cache: Km,
  Camera: $w,
  CameraHelper: hee,
  CanvasTexture: k6,
  CapsuleGeometry: QW,
  CatmullRomCurve3: oL,
  CineonToneMapping: fK,
  CircleGeometry: jW,
  ClampToEdgeWrapping: PC,
  Clock: MY,
  Color: ai,
  ColorKeyframeTrack: xY,
  ColorManagement: ya,
  CompressedArrayTexture: K6,
  CompressedCubeTexture: L6,
  CompressedTexture: PW,
  CompressedTextureLoader: S$,
  ConeGeometry: qW,
  ConstantAlphaFactor: iK,
  ConstantColorFactor: tK,
  CubeCamera: KK,
  CubeReflectionMapping: Om,
  CubeRefractionMapping: bv,
  CubeTexture: eR,
  CubeTextureLoader: Z$,
  CubeUVReflectionMapping: xB,
  CubicBezierCurve: yY,
  CubicBezierCurve3: sL,
  CubicInterpolant: ZL,
  CullFaceBack: KH,
  CullFaceFront: Tz,
  CullFaceFrontBack: vQ,
  CullFaceNone: Ez,
  Curve: af,
  CurvePath: uL,
  CustomBlending: zz,
  CustomToneMapping: pK,
  CylinderGeometry: NB,
  Cylindrical: ree,
  Data3DTexture: cY,
  DataArrayTexture: zW,
  DataTexture: gp,
  DataTextureLoader: w$,
  DataUtils: N4,
  DecrementStencilOp: HQ,
  DecrementWrapStencilOp: YQ,
  DefaultLoadingManager: xL,
  DepthFormat: hb,
  DepthStencilFormat: Sb,
  DepthTexture: KW,
  DetachedBindMode: vK,
  DirectionalLight: ML,
  DirectionalLightHelper: Cee,
  DiscreteInterpolant: wL,
  DisplayP3ColorSpace: _W,
  DodecahedronGeometry: $W,
  DoubleSide: ip,
  DstAlphaFactor: Qz,
  DstColorFactor: qz,
  DynamicCopyUsage: QQ,
  DynamicDrawUsage: HK,
  DynamicReadUsage: OQ,
  EdgesGeometry: cL,
  EllipseCurve: JW,
  EqualCompare: xK,
  EqualDepth: lK,
  EqualStencilFunc: _Q,
  EquirectangularReflectionMapping: Aw,
  EquirectangularRefractionMapping: vw,
  Euler: uI,
  EventDispatcher: eA,
  ExtrudeGeometry: tV,
  FileLoader: Jm,
  Float16BufferAttribute: E4,
  Float32BufferAttribute: fi,
  FloatType: ed,
  Fog: DW,
  FogExp2: kW,
  FramebufferTexture: z6,
  FrontSide: Um,
  Frustum: tR,
  GLBufferAttribute: iee,
  GLSL1: qQ,
  GLSL3: PH,
  GreaterCompare: WK,
  GreaterDepth: cK,
  GreaterEqualCompare: NK,
  GreaterEqualDepth: uK,
  GreaterEqualStencilFunc: kQ,
  GreaterStencilFunc: KQ,
  GridHelper: dee,
  Group: tB,
  HalfFloatType: Vb,
  HemisphereLight: WL,
  HemisphereLightHelper: gee,
  IcosahedronGeometry: nV,
  ImageBitmapLoader: H$,
  ImageLoader: Ew,
  ImageUtils: FK,
  IncrementStencilOp: MQ,
  IncrementWrapStencilOp: XQ,
  InstancedBufferAttribute: pB,
  InstancedBufferGeometry: EL,
  InstancedInterleavedBuffer: nee,
  InstancedMesh: lB,
  Int16BufferAttribute: Y4,
  Int32BufferAttribute: F4,
  Int8BufferAttribute: M4,
  IntType: MW,
  InterleavedBuffer: UW,
  InterleavedBufferAttribute: Zb,
  Interpolant: aR,
  InterpolateDiscrete: Gw,
  InterpolateLinear: $2,
  InterpolateSmooth: g2,
  InvertStencilOp: FQ,
  KeepStencilOp: eb,
  KeyframeTrack: of,
  LOD: eL,
  LatheGeometry: nR,
  Layers: pb,
  LessCompare: RK,
  LessDepth: sK,
  LessEqualCompare: lY,
  LessEqualDepth: mw,
  LessEqualStencilFunc: zQ,
  LessStencilFunc: TQ,
  Light: xv,
  LightProbe: FL,
  Line: Gv,
  Line3: oee,
  LineBasicMaterial: ad,
  LineCurve: bY,
  LineCurve3: lL,
  LineDashedMaterial: GL,
  LineLoop: iL,
  LineSegments: pp,
  LinearDisplayP3ColorSpace: qw,
  LinearFilter: Ks,
  LinearInterpolant: RY,
  LinearMipMapLinearFilter: BQ,
  LinearMipMapNearestFilter: GQ,
  LinearMipmapLinearFilter: ap,
  LinearMipmapNearestFilter: jZ,
  LinearSRGBColorSpace: $m,
  LinearToneMapping: CK,
  LinearTransfer: Sw,
  Loader: gI,
  LoaderUtils: nX,
  LoadingManager: WY,
  LoopOnce: yK,
  LoopPingPong: GK,
  LoopRepeat: bK,
  LuminanceAlphaFormat: rY,
  LuminanceFormat: iY,
  MOUSE: qy,
  Material: Cg,
  MaterialLoader: uV,
  MathUtils: h4,
  Matrix2: EY,
  Matrix3: Cr,
  Matrix4: _i,
  MaxEquation: Dz,
  Mesh: kl,
  MeshBasicMaterial: wv,
  MeshDepthMaterial: CY,
  MeshDistanceMaterial: hY,
  MeshLambertMaterial: yL,
  MeshMatcapMaterial: bL,
  MeshNormalMaterial: vL,
  MeshPhongMaterial: mL,
  MeshPhysicalMaterial: pL,
  MeshStandardMaterial: ZY,
  MeshToonMaterial: AL,
  MinEquation: kz,
  MirroredRepeatWrapping: bw,
  MixOperation: dK,
  MultiplyBlending: DH,
  MultiplyOperation: Qw,
  NearestFilter: Lu,
  NearestMipMapLinearFilter: bQ,
  NearestMipMapNearestFilter: yQ,
  NearestMipmapLinearFilter: qG,
  NearestMipmapNearestFilter: jX,
  NeutralToneMapping: AK,
  NeverCompare: wK,
  NeverDepth: aK,
  NeverStencilFunc: EQ,
  NoBlending: Dm,
  NoColorSpace: _m,
  NoToneMapping: cp,
  NormalAnimationBlendMode: TW,
  NormalBlending: Cb,
  NotEqualCompare: VK,
  NotEqualDepth: gK,
  NotEqualStencilFunc: LQ,
  NumberKeyframeTrack: Xw,
  Object3D: qr,
  ObjectLoader: N$,
  ObjectSpaceNormalMap: ZK,
  OctahedronGeometry: iR,
  OneFactor: Oz,
  OneMinusConstantAlphaFactor: rK,
  OneMinusConstantColorFactor: nK,
  OneMinusDstAlphaFactor: jz,
  OneMinusDstColorFactor: $z,
  OneMinusSrcAlphaFactor: Z2,
  OneMinusSrcColorFactor: Jz,
  OrthographicCamera: pv,
  P3Primaries: ww,
  PCFShadowMap: VW,
  PCFSoftShadowMap: QZ,
  PMREMGenerator: JH,
  Path: Vw,
  PerspectiveCamera: hl,
  Plane: Em,
  PlaneGeometry: WB,
  PlaneHelper: mee,
  PointLight: NL,
  PointLightHelper: uee,
  Points: rL,
  PointsMaterial: AY,
  PolarGridHelper: Iee,
  PolyhedronGeometry: Rv,
  PositionalAudio: _$,
  PropertyBinding: Ca,
  PropertyMixer: zL,
  QuadraticBezierCurve: GY,
  QuadraticBezierCurve3: BY,
  Quaternion: ku,
  QuaternionKeyframeTrack: oR,
  QuaternionLinearInterpolant: RL,
  RED_GREEN_RGTC2_Format: j2,
  RED_RGTC1_Format: oY,
  REVISION: WW,
  RGBADepthPacking: SK,
  RGBAFormat: cg,
  RGBAIntegerFormat: EW,
  RGBA_ASTC_10x10_Format: D2,
  RGBA_ASTC_10x5_Format: K2,
  RGBA_ASTC_10x6_Format: L2,
  RGBA_ASTC_10x8_Format: k2,
  RGBA_ASTC_12x10_Format: U2,
  RGBA_ASTC_12x12_Format: O2,
  RGBA_ASTC_4x4_Format: H2,
  RGBA_ASTC_5x4_Format: X2,
  RGBA_ASTC_5x5_Format: Y2,
  RGBA_ASTC_6x5_Format: F2,
  RGBA_ASTC_6x6_Format: E2,
  RGBA_ASTC_8x5_Format: T2,
  RGBA_ASTC_8x6_Format: _2,
  RGBA_ASTC_8x8_Format: z2,
  RGBA_BPTC_Format: nw,
  RGBA_ETC2_EAC_Format: M2,
  RGBA_PVRTC_2BPPV1_Format: W2,
  RGBA_PVRTC_4BPPV1_Format: x2,
  RGBA_S3TC_DXT1_Format: $Z,
  RGBA_S3TC_DXT3_Format: ew,
  RGBA_S3TC_DXT5_Format: tw,
  RGBDepthPacking: xQ,
  RGBFormat: nY,
  RGBIntegerFormat: SQ,
  RGB_BPTC_SIGNED_Format: P2,
  RGB_BPTC_UNSIGNED_Format: J2,
  RGB_ETC1_Format: V2,
  RGB_ETC2_Format: N2,
  RGB_PVRTC_2BPPV1_Format: R2,
  RGB_PVRTC_4BPPV1_Format: w2,
  RGB_S3TC_DXT1_Format: qZ,
  RGDepthPacking: WQ,
  RGFormat: aY,
  RGIntegerFormat: FW,
  RawShaderMaterial: fL,
  Ray: Nb,
  Raycaster: FY,
  Rec709Primaries: Zw,
  RectAreaLight: XL,
  RedFormat: YW,
  RedIntegerFormat: jw,
  ReinhardToneMapping: hK,
  RenderTarget: EK,
  RepeatWrapping: yw,
  ReplaceStencilOp: NQ,
  ReverseSubtractEquation: Lz,
  RingGeometry: iV,
  SIGNED_RED_GREEN_RGTC2_Format: q2,
  SIGNED_RED_RGTC1_Format: Q2,
  SRGBColorSpace: OC,
  SRGBTransfer: Ho,
  Scene: fY,
  ShaderChunk: Ar,
  ShaderLib: ef,
  ShaderMaterial: rf,
  ShadowMaterial: hL,
  Shape: mb,
  ShapeGeometry: rV,
  ShapePath: yee,
  ShapeUtils: dp,
  ShortType: $X,
  Skeleton: OW,
  SkeletonHelper: lee,
  SkinnedMesh: tL,
  Source: gb,
  Sphere: dg,
  SphereGeometry: rR,
  Spherical: rX,
  SphericalHarmonics3: YL,
  SplineCurve: SY,
  SpotLight: VL,
  SpotLightHelper: see,
  Sprite: $K,
  SpriteMaterial: pY,
  SrcAlphaFactor: S2,
  SrcAlphaSaturateFactor: eK,
  SrcColorFactor: Pz,
  StaticCopyUsage: JQ,
  StaticDrawUsage: Rw,
  StaticReadUsage: UQ,
  StereoCamera: Y$,
  StreamCopyUsage: jQ,
  StreamDrawUsage: DQ,
  StreamReadUsage: PQ,
  StringKeyframeTrack: Xb,
  SubtractEquation: Kz,
  SubtractiveBlending: kH,
  TOUCH: $y,
  TangentSpaceNormalMap: Zv,
  TetrahedronGeometry: aV,
  Texture: ks,
  TextureLoader: R$,
  TextureUtils: v6,
  TorusGeometry: oV,
  TorusKnotGeometry: sV,
  Triangle: DI,
  TriangleFanDrawMode: RQ,
  TriangleStripDrawMode: wQ,
  TrianglesDrawMode: ZQ,
  TubeGeometry: lV,
  UVMapping: NW,
  Uint16BufferAttribute: gY,
  Uint32BufferAttribute: dY,
  Uint8BufferAttribute: H4,
  Uint8ClampedBufferAttribute: X4,
  Uniform: YY,
  UniformsGroup: tee,
  UniformsLib: Pn,
  UniformsUtils: zK,
  UnsignedByteType: nf,
  UnsignedInt248Type: Bb,
  UnsignedInt5999Type: eY,
  UnsignedIntType: Pm,
  UnsignedShort4444Type: HW,
  UnsignedShort5551Type: XW,
  UnsignedShortType: CB,
  VSMShadowMap: qh,
  Vector2: Lt,
  Vector3: fe,
  Vector4: Ha,
  VectorKeyframeTrack: Yw,
  VideoTexture: _6,
  WebGL3DRenderTarget: b4,
  WebGLArrayRenderTarget: y4,
  WebGLCoordinateSystem: op,
  WebGLCubeRenderTarget: LK,
  WebGLMultipleRenderTargets: bee,
  WebGLRenderTarget: QC,
  WebGLRenderer: jK,
  WebGLUtils: JK,
  WebGPUCoordinateSystem: xw,
  WireframeGeometry: CL,
  WrapAroundEnding: Bw,
  ZeroCurvatureEnding: ub,
  ZeroFactor: Uz,
  ZeroSlopeEnding: cb,
  ZeroStencilOp: VQ,
  createCanvasElement: YK
}, Symbol.toStringTag, { value: "Module" }));
var P1 = { exports: {} }, lv = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var p5;
function Bee() {
  return p5 || (p5 = 1, lv.ConcurrentRoot = 1, lv.ContinuousEventPriority = 4, lv.DefaultEventPriority = 16, lv.DiscreteEventPriority = 1, lv.IdleEventPriority = 536870912, lv.LegacyRoot = 0), lv;
}
var uv = {}, m5;
function See() {
  if (m5) return uv;
  m5 = 1;
  var r = {};
  /**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return r.NODE_ENV !== "production" && function() {
    var e = (
      /*                        */
      1
    ), t = (
      /*            */
      4
    ), n = (
      /*                    */
      16
    ), i = (
      /*                       */
      536870912
    ), o = e, l = t, u = n, I = i, C = 0, f = 1;
    uv.ConcurrentRoot = f, uv.ContinuousEventPriority = l, uv.DefaultEventPriority = u, uv.DiscreteEventPriority = o, uv.IdleEventPriority = I, uv.LegacyRoot = C;
  }(), uv;
}
var A5;
function Zee() {
  if (A5) return P1.exports;
  A5 = 1;
  var r = {};
  return r.NODE_ENV === "production" ? P1.exports = Bee() : P1.exports = See(), P1.exports;
}
var iB = Zee();
function wee(r) {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (C, f) => {
    const v = typeof C == "function" ? C(e) : C;
    if (v !== e) {
      const b = e;
      e = f ? v : Object.assign({}, e, v), t.forEach((S) => S(e, b));
    }
  }, i = () => e, o = (C, f = i, v = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let b = f(e);
    function S() {
      const R = f(e);
      if (!v(b, R)) {
        const W = b;
        C(b = R, W);
      }
    }
    return t.add(S), () => t.delete(S);
  }, I = { setState: n, getState: i, subscribe: (C, f, v) => f || v ? o(C, f, v) : (t.add(C), () => t.delete(C)), destroy: () => t.clear() };
  return e = r(n, i, I), I;
}
const Ree = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), v5 = Ree ? ye.useEffect : ye.useLayoutEffect;
function xee(r) {
  const e = typeof r == "function" ? wee(r) : r, t = (n = e.getState, i = Object.is) => {
    const [, o] = ye.useReducer((x) => x + 1, 0), l = e.getState(), u = ye.useRef(l), I = ye.useRef(n), C = ye.useRef(i), f = ye.useRef(!1), v = ye.useRef();
    v.current === void 0 && (v.current = n(l));
    let b, S = !1;
    (u.current !== l || I.current !== n || C.current !== i || f.current) && (b = n(l), S = !i(v.current, b)), v5(() => {
      S && (v.current = b), u.current = l, I.current = n, C.current = i, f.current = !1;
    });
    const R = ye.useRef(l);
    v5(() => {
      const x = () => {
        try {
          const Y = e.getState(), F = I.current(Y);
          C.current(v.current, F) || (u.current = Y, v.current = F, o());
        } catch {
          f.current = !0, o();
        }
      }, N = e.subscribe(x);
      return e.getState() !== R.current && x(), N;
    }, []);
    const W = S ? b : v.current;
    return ye.useDebugValue(W), W;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const n = [t, e];
    return {
      next() {
        const i = n.length <= 0;
        return { value: n.shift(), done: i };
      }
    };
  }, t;
}
var J1 = { exports: {} }, Q1 = { exports: {} }, oH = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var y5;
function Wee() {
  return y5 || (y5 = 1, function(r) {
    function e(re, Se) {
      var Be = re.length;
      re.push(Se);
      e: for (; 0 < Be; ) {
        var le = Be - 1 >>> 1, Ye = re[le];
        if (0 < i(Ye, Se)) re[le] = Se, re[Be] = Ye, Be = le;
        else break e;
      }
    }
    function t(re) {
      return re.length === 0 ? null : re[0];
    }
    function n(re) {
      if (re.length === 0) return null;
      var Se = re[0], Be = re.pop();
      if (Be !== Se) {
        re[0] = Be;
        e: for (var le = 0, Ye = re.length, nt = Ye >>> 1; le < nt; ) {
          var ze = 2 * (le + 1) - 1, Je = re[ze], wt = ze + 1, mt = re[wt];
          if (0 > i(Je, Be)) wt < Ye && 0 > i(mt, Je) ? (re[le] = mt, re[wt] = Be, le = wt) : (re[le] = Je, re[ze] = Be, le = ze);
          else if (wt < Ye && 0 > i(mt, Be)) re[le] = mt, re[wt] = Be, le = wt;
          else break e;
        }
      }
      return Se;
    }
    function i(re, Se) {
      var Be = re.sortIndex - Se.sortIndex;
      return Be !== 0 ? Be : re.id - Se.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      r.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, u = l.now();
      r.unstable_now = function() {
        return l.now() - u;
      };
    }
    var I = [], C = [], f = 1, v = null, b = 3, S = !1, R = !1, W = !1, x = typeof setTimeout == "function" ? setTimeout : null, N = typeof clearTimeout == "function" ? clearTimeout : null, Y = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function F(re) {
      for (var Se = t(C); Se !== null; ) {
        if (Se.callback === null) n(C);
        else if (Se.startTime <= re) n(C), Se.sortIndex = Se.expirationTime, e(I, Se);
        else break;
        Se = t(C);
      }
    }
    function T(re) {
      if (W = !1, F(re), !R) if (t(I) !== null) R = !0, Re(P);
      else {
        var Se = t(C);
        Se !== null && Xe(T, Se.startTime - re);
      }
    }
    function P(re, Se) {
      R = !1, W && (W = !1, N(j), j = -1), S = !0;
      var Be = b;
      try {
        for (F(Se), v = t(I); v !== null && (!(v.expirationTime > Se) || re && !ne()); ) {
          var le = v.callback;
          if (typeof le == "function") {
            v.callback = null, b = v.priorityLevel;
            var Ye = le(v.expirationTime <= Se);
            Se = r.unstable_now(), typeof Ye == "function" ? v.callback = Ye : v === t(I) && n(I), F(Se);
          } else n(I);
          v = t(I);
        }
        if (v !== null) var nt = !0;
        else {
          var ze = t(C);
          ze !== null && Xe(T, ze.startTime - Se), nt = !1;
        }
        return nt;
      } finally {
        v = null, b = Be, S = !1;
      }
    }
    var D = !1, L = null, j = -1, J = 5, O = -1;
    function ne() {
      return !(r.unstable_now() - O < J);
    }
    function he() {
      if (L !== null) {
        var re = r.unstable_now();
        O = re;
        var Se = !0;
        try {
          Se = L(!0, re);
        } finally {
          Se ? pe() : (D = !1, L = null);
        }
      } else D = !1;
    }
    var pe;
    if (typeof Y == "function") pe = function() {
      Y(he);
    };
    else if (typeof MessageChannel < "u") {
      var Ae = new MessageChannel(), ke = Ae.port2;
      Ae.port1.onmessage = he, pe = function() {
        ke.postMessage(null);
      };
    } else pe = function() {
      x(he, 0);
    };
    function Re(re) {
      L = re, D || (D = !0, pe());
    }
    function Xe(re, Se) {
      j = x(function() {
        re(r.unstable_now());
      }, Se);
    }
    r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function(re) {
      re.callback = null;
    }, r.unstable_continueExecution = function() {
      R || S || (R = !0, Re(P));
    }, r.unstable_forceFrameRate = function(re) {
      0 > re || 125 < re ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : J = 0 < re ? Math.floor(1e3 / re) : 5;
    }, r.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, r.unstable_getFirstCallbackNode = function() {
      return t(I);
    }, r.unstable_next = function(re) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var Se = 3;
          break;
        default:
          Se = b;
      }
      var Be = b;
      b = Se;
      try {
        return re();
      } finally {
        b = Be;
      }
    }, r.unstable_pauseExecution = function() {
    }, r.unstable_requestPaint = function() {
    }, r.unstable_runWithPriority = function(re, Se) {
      switch (re) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          re = 3;
      }
      var Be = b;
      b = re;
      try {
        return Se();
      } finally {
        b = Be;
      }
    }, r.unstable_scheduleCallback = function(re, Se, Be) {
      var le = r.unstable_now();
      switch (typeof Be == "object" && Be !== null ? (Be = Be.delay, Be = typeof Be == "number" && 0 < Be ? le + Be : le) : Be = le, re) {
        case 1:
          var Ye = -1;
          break;
        case 2:
          Ye = 250;
          break;
        case 5:
          Ye = 1073741823;
          break;
        case 4:
          Ye = 1e4;
          break;
        default:
          Ye = 5e3;
      }
      return Ye = Be + Ye, re = { id: f++, callback: Se, priorityLevel: re, startTime: Be, expirationTime: Ye, sortIndex: -1 }, Be > le ? (re.sortIndex = Be, e(C, re), t(I) === null && re === t(C) && (W ? (N(j), j = -1) : W = !0, Xe(T, Be - le))) : (re.sortIndex = Ye, e(I, re), R || S || (R = !0, Re(P))), re;
    }, r.unstable_shouldYield = ne, r.unstable_wrapCallback = function(re) {
      var Se = b;
      return function() {
        var Be = b;
        b = Se;
        try {
          return re.apply(this, arguments);
        } finally {
          b = Be;
        }
      };
    };
  }(oH)), oH;
}
var sH = {}, b5;
function Vee() {
  return b5 || (b5 = 1, function(r) {
    var e = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    e.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = 5;
      function i(He, vt) {
        var xt = He.length;
        He.push(vt), u(He, vt, xt);
      }
      function o(He) {
        return He.length === 0 ? null : He[0];
      }
      function l(He) {
        if (He.length === 0)
          return null;
        var vt = He[0], xt = He.pop();
        return xt !== vt && (He[0] = xt, I(He, xt, 0)), vt;
      }
      function u(He, vt, xt) {
        for (var ht = xt; ht > 0; ) {
          var on = ht - 1 >>> 1, we = He[on];
          if (C(we, vt) > 0)
            He[on] = vt, He[ht] = we, ht = on;
          else
            return;
        }
      }
      function I(He, vt, xt) {
        for (var ht = xt, on = He.length, we = on >>> 1; ht < we; ) {
          var qe = (ht + 1) * 2 - 1, de = He[qe], it = qe + 1, je = He[it];
          if (C(de, vt) < 0)
            it < on && C(je, de) < 0 ? (He[ht] = je, He[it] = vt, ht = it) : (He[ht] = de, He[qe] = vt, ht = qe);
          else if (it < on && C(je, vt) < 0)
            He[ht] = je, He[it] = vt, ht = it;
          else
            return;
        }
      }
      function C(He, vt) {
        var xt = He.sortIndex - vt.sortIndex;
        return xt !== 0 ? xt : He.id - vt.id;
      }
      var f = 1, v = 2, b = 3, S = 4, R = 5;
      function W(He, vt) {
      }
      var x = typeof performance == "object" && typeof performance.now == "function";
      if (x) {
        var N = performance;
        r.unstable_now = function() {
          return N.now();
        };
      } else {
        var Y = Date, F = Y.now();
        r.unstable_now = function() {
          return Y.now() - F;
        };
      }
      var T = 1073741823, P = -1, D = 250, L = 5e3, j = 1e4, J = T, O = [], ne = [], he = 1, pe = null, Ae = b, ke = !1, Re = !1, Xe = !1, re = typeof setTimeout == "function" ? setTimeout : null, Se = typeof clearTimeout == "function" ? clearTimeout : null, Be = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function le(He) {
        for (var vt = o(ne); vt !== null; ) {
          if (vt.callback === null)
            l(ne);
          else if (vt.startTime <= He)
            l(ne), vt.sortIndex = vt.expirationTime, i(O, vt);
          else
            return;
          vt = o(ne);
        }
      }
      function Ye(He) {
        if (Xe = !1, le(He), !Re)
          if (o(O) !== null)
            Re = !0, Gn(nt);
          else {
            var vt = o(ne);
            vt !== null && jt(Ye, vt.startTime - He);
          }
      }
      function nt(He, vt) {
        Re = !1, Xe && (Xe = !1, an()), ke = !0;
        var xt = Ae;
        try {
          var ht;
          if (!t) return ze(He, vt);
        } finally {
          pe = null, Ae = xt, ke = !1;
        }
      }
      function ze(He, vt) {
        var xt = vt;
        for (le(xt), pe = o(O); pe !== null && !(pe.expirationTime > xt && (!He || hn())); ) {
          var ht = pe.callback;
          if (typeof ht == "function") {
            pe.callback = null, Ae = pe.priorityLevel;
            var on = pe.expirationTime <= xt, we = ht(on);
            xt = r.unstable_now(), typeof we == "function" ? pe.callback = we : pe === o(O) && l(O), le(xt);
          } else
            l(O);
          pe = o(O);
        }
        if (pe !== null)
          return !0;
        var qe = o(ne);
        return qe !== null && jt(Ye, qe.startTime - xt), !1;
      }
      function Je(He, vt) {
        switch (He) {
          case f:
          case v:
          case b:
          case S:
          case R:
            break;
          default:
            He = b;
        }
        var xt = Ae;
        Ae = He;
        try {
          return vt();
        } finally {
          Ae = xt;
        }
      }
      function wt(He) {
        var vt;
        switch (Ae) {
          case f:
          case v:
          case b:
            vt = b;
            break;
          default:
            vt = Ae;
            break;
        }
        var xt = Ae;
        Ae = vt;
        try {
          return He();
        } finally {
          Ae = xt;
        }
      }
      function mt(He) {
        var vt = Ae;
        return function() {
          var xt = Ae;
          Ae = vt;
          try {
            return He.apply(this, arguments);
          } finally {
            Ae = xt;
          }
        };
      }
      function Dt(He, vt, xt) {
        var ht = r.unstable_now(), on;
        if (typeof xt == "object" && xt !== null) {
          var we = xt.delay;
          typeof we == "number" && we > 0 ? on = ht + we : on = ht;
        } else
          on = ht;
        var qe;
        switch (He) {
          case f:
            qe = P;
            break;
          case v:
            qe = D;
            break;
          case R:
            qe = J;
            break;
          case S:
            qe = j;
            break;
          case b:
          default:
            qe = L;
            break;
        }
        var de = on + qe, it = {
          id: he++,
          callback: vt,
          priorityLevel: He,
          startTime: on,
          expirationTime: de,
          sortIndex: -1
        };
        return on > ht ? (it.sortIndex = on, i(ne, it), o(O) === null && it === o(ne) && (Xe ? an() : Xe = !0, jt(Ye, on - ht))) : (it.sortIndex = de, i(O, it), !Re && !ke && (Re = !0, Gn(nt))), it;
      }
      function mn() {
      }
      function An() {
        !Re && !ke && (Re = !0, Gn(nt));
      }
      function Hn() {
        return o(O);
      }
      function ge(He) {
        He.callback = null;
      }
      function Wt() {
        return Ae;
      }
      var Nt = !1, $t = null, ft = -1, bn = n, en = -1;
      function hn() {
        var He = r.unstable_now() - en;
        return !(He < bn);
      }
      function me() {
      }
      function se(He) {
        if (He < 0 || He > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        He > 0 ? bn = Math.floor(1e3 / He) : bn = n;
      }
      var $e = function() {
        if ($t !== null) {
          var He = r.unstable_now();
          en = He;
          var vt = !0, xt = !0;
          try {
            xt = $t(vt, He);
          } finally {
            xt ? Vt() : (Nt = !1, $t = null);
          }
        } else
          Nt = !1;
      }, Vt;
      if (typeof Be == "function")
        Vt = function() {
          Be($e);
        };
      else if (typeof MessageChannel < "u") {
        var Bt = new MessageChannel(), Mt = Bt.port2;
        Bt.port1.onmessage = $e, Vt = function() {
          Mt.postMessage(null);
        };
      } else
        Vt = function() {
          re($e, 0);
        };
      function Gn(He) {
        $t = He, Nt || (Nt = !0, Vt());
      }
      function jt(He, vt) {
        ft = re(function() {
          He(r.unstable_now());
        }, vt);
      }
      function an() {
        Se(ft), ft = -1;
      }
      var jn = me, Ot = null;
      r.unstable_IdlePriority = R, r.unstable_ImmediatePriority = f, r.unstable_LowPriority = S, r.unstable_NormalPriority = b, r.unstable_Profiling = Ot, r.unstable_UserBlockingPriority = v, r.unstable_cancelCallback = ge, r.unstable_continueExecution = An, r.unstable_forceFrameRate = se, r.unstable_getCurrentPriorityLevel = Wt, r.unstable_getFirstCallbackNode = Hn, r.unstable_next = wt, r.unstable_pauseExecution = mn, r.unstable_requestPaint = jn, r.unstable_runWithPriority = Je, r.unstable_scheduleCallback = Dt, r.unstable_shouldYield = hn, r.unstable_wrapCallback = mt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(sH)), sH;
}
var G5;
function TY() {
  if (G5) return Q1.exports;
  G5 = 1;
  var r = {};
  return r.NODE_ENV === "production" ? Q1.exports = Wee() : Q1.exports = Vee(), Q1.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lH, B5;
function Nee() {
  return B5 || (B5 = 1, lH = function(e) {
    var t = {}, n = xb(), i = TY(), o = Object.assign;
    function l(m) {
      for (var A = "https://reactjs.org/docs/error-decoder.html?invariant=" + m, V = 1; V < arguments.length; V++) A += "&args[]=" + encodeURIComponent(arguments[V]);
      return "Minified React error #" + m + "; visit " + A + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var u = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, I = Symbol.for("react.element"), C = Symbol.for("react.portal"), f = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), b = Symbol.for("react.profiler"), S = Symbol.for("react.provider"), R = Symbol.for("react.context"), W = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), N = Symbol.for("react.suspense_list"), Y = Symbol.for("react.memo"), F = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), P = Symbol.iterator;
    function D(m) {
      return m === null || typeof m != "object" ? null : (m = P && m[P] || m["@@iterator"], typeof m == "function" ? m : null);
    }
    function L(m) {
      if (m == null) return null;
      if (typeof m == "function") return m.displayName || m.name || null;
      if (typeof m == "string") return m;
      switch (m) {
        case f:
          return "Fragment";
        case C:
          return "Portal";
        case b:
          return "Profiler";
        case v:
          return "StrictMode";
        case x:
          return "Suspense";
        case N:
          return "SuspenseList";
      }
      if (typeof m == "object") switch (m.$$typeof) {
        case R:
          return (m.displayName || "Context") + ".Consumer";
        case S:
          return (m._context.displayName || "Context") + ".Provider";
        case W:
          var A = m.render;
          return m = m.displayName, m || (m = A.displayName || A.name || "", m = m !== "" ? "ForwardRef(" + m + ")" : "ForwardRef"), m;
        case Y:
          return A = m.displayName || null, A !== null ? A : L(m.type) || "Memo";
        case F:
          A = m._payload, m = m._init;
          try {
            return L(m(A));
          } catch {
          }
      }
      return null;
    }
    function j(m) {
      var A = m.type;
      switch (m.tag) {
        case 24:
          return "Cache";
        case 9:
          return (A.displayName || "Context") + ".Consumer";
        case 10:
          return (A._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return m = A.render, m = m.displayName || m.name || "", A.displayName || (m !== "" ? "ForwardRef(" + m + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return A;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return L(A);
        case 8:
          return A === v ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof A == "function") return A.displayName || A.name || null;
          if (typeof A == "string") return A;
      }
      return null;
    }
    function J(m) {
      var A = m, V = m;
      if (m.alternate) for (; A.return; ) A = A.return;
      else {
        m = A;
        do
          A = m, (A.flags & 4098) !== 0 && (V = A.return), m = A.return;
        while (m);
      }
      return A.tag === 3 ? V : null;
    }
    function O(m) {
      if (J(m) !== m) throw Error(l(188));
    }
    function ne(m) {
      var A = m.alternate;
      if (!A) {
        if (A = J(m), A === null) throw Error(l(188));
        return A !== m ? null : m;
      }
      for (var V = m, E = A; ; ) {
        var k = V.return;
        if (k === null) break;
        var $ = k.alternate;
        if ($ === null) {
          if (E = k.return, E !== null) {
            V = E;
            continue;
          }
          break;
        }
        if (k.child === $.child) {
          for ($ = k.child; $; ) {
            if ($ === V) return O(k), m;
            if ($ === E) return O(k), A;
            $ = $.sibling;
          }
          throw Error(l(188));
        }
        if (V.return !== E.return) V = k, E = $;
        else {
          for (var ve = !1, Ke = k.child; Ke; ) {
            if (Ke === V) {
              ve = !0, V = k, E = $;
              break;
            }
            if (Ke === E) {
              ve = !0, E = k, V = $;
              break;
            }
            Ke = Ke.sibling;
          }
          if (!ve) {
            for (Ke = $.child; Ke; ) {
              if (Ke === V) {
                ve = !0, V = $, E = k;
                break;
              }
              if (Ke === E) {
                ve = !0, E = $, V = k;
                break;
              }
              Ke = Ke.sibling;
            }
            if (!ve) throw Error(l(189));
          }
        }
        if (V.alternate !== E) throw Error(l(190));
      }
      if (V.tag !== 3) throw Error(l(188));
      return V.stateNode.current === V ? m : A;
    }
    function he(m) {
      return m = ne(m), m !== null ? pe(m) : null;
    }
    function pe(m) {
      if (m.tag === 5 || m.tag === 6) return m;
      for (m = m.child; m !== null; ) {
        var A = pe(m);
        if (A !== null) return A;
        m = m.sibling;
      }
      return null;
    }
    function Ae(m) {
      if (m.tag === 5 || m.tag === 6) return m;
      for (m = m.child; m !== null; ) {
        if (m.tag !== 4) {
          var A = Ae(m);
          if (A !== null) return A;
        }
        m = m.sibling;
      }
      return null;
    }
    var ke = Array.isArray, Re = e.getPublicInstance, Xe = e.getRootHostContext, re = e.getChildHostContext, Se = e.prepareForCommit, Be = e.resetAfterCommit, le = e.createInstance, Ye = e.appendInitialChild, nt = e.finalizeInitialChildren, ze = e.prepareUpdate, Je = e.shouldSetTextContent, wt = e.createTextInstance, mt = e.scheduleTimeout, Dt = e.cancelTimeout, mn = e.noTimeout, An = e.isPrimaryRenderer, Hn = e.supportsMutation, ge = e.supportsPersistence, Wt = e.supportsHydration, Nt = e.getInstanceFromNode, $t = e.preparePortalMount, ft = e.getCurrentEventPriority, bn = e.detachDeletedInstance, en = e.supportsMicrotasks, hn = e.scheduleMicrotask, me = e.supportsTestSelectors, se = e.findFiberRoot, $e = e.getBoundingRect, Vt = e.getTextContent, Bt = e.isHiddenSubtree, Mt = e.matchAccessibilityRole, Gn = e.setFocusIfFocusable, jt = e.setupIntersectionObserver, an = e.appendChild, jn = e.appendChildToContainer, Ot = e.commitTextUpdate, He = e.commitMount, vt = e.commitUpdate, xt = e.insertBefore, ht = e.insertInContainerBefore, on = e.removeChild, we = e.removeChildFromContainer, qe = e.resetTextContent, de = e.hideInstance, it = e.hideTextInstance, je = e.unhideInstance, et = e.unhideTextInstance, Jt = e.clearContainer, Kn = e.cloneInstance, di = e.createContainerChildSet, Di = e.appendChildToContainerChildSet, Jn = e.finalizeContainerChildren, Ii = e.replaceContainerChildren, dr = e.cloneHiddenInstance, xr = e.cloneHiddenTextInstance, la = e.canHydrateInstance, Ve = e.canHydrateTextInstance, Oe = e.canHydrateSuspenseInstance, rt = e.isSuspenseInstancePending, Et = e.isSuspenseInstanceFallback, gn = e.registerSuspenseInstanceRetry, Vn = e.getNextHydratableSibling, Ln = e.getFirstHydratableChild, Ie = e.getFirstHydratableChildWithinContainer, tt = e.getFirstHydratableChildWithinSuspenseInstance, At = e.hydrateInstance, Gt = e.hydrateTextInstance, vn = e.hydrateSuspenseInstance, ae = e.getNextHydratableInstanceAfterSuspenseInstance, Ne = e.commitHydratedContainer, Te = e.commitHydratedSuspenseInstance, De = e.clearSuspenseBoundary, Ee = e.clearSuspenseBoundaryFromContainer, Tt = e.shouldDeleteUnhydratedTailInstances, tn = e.didNotMatchHydratedContainerTextInstance, Bn = e.didNotMatchHydratedTextInstance, Pt;
    function Zn(m) {
      if (Pt === void 0) try {
        throw Error();
      } catch (V) {
        var A = V.stack.trim().match(/\n( *(at )?)/);
        Pt = A && A[1] || "";
      }
      return `
` + Pt + m;
    }
    var rn = !1;
    function Yn(m, A) {
      if (!m || rn) return "";
      rn = !0;
      var V = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (A) if (A = function() {
          throw Error();
        }, Object.defineProperty(A.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(A, []);
          } catch (In) {
            var E = In;
          }
          Reflect.construct(m, [], A);
        } else {
          try {
            A.call();
          } catch (In) {
            E = In;
          }
          m.call(A.prototype);
        }
        else {
          try {
            throw Error();
          } catch (In) {
            E = In;
          }
          m();
        }
      } catch (In) {
        if (In && E && typeof In.stack == "string") {
          for (var k = In.stack.split(`
`), $ = E.stack.split(`
`), ve = k.length - 1, Ke = $.length - 1; 1 <= ve && 0 <= Ke && k[ve] !== $[Ke]; ) Ke--;
          for (; 1 <= ve && 0 <= Ke; ve--, Ke--) if (k[ve] !== $[Ke]) {
            if (ve !== 1 || Ke !== 1)
              do
                if (ve--, Ke--, 0 > Ke || k[ve] !== $[Ke]) {
                  var Rt = `
` + k[ve].replace(" at new ", " at ");
                  return m.displayName && Rt.includes("<anonymous>") && (Rt = Rt.replace("<anonymous>", m.displayName)), Rt;
                }
              while (1 <= ve && 0 <= Ke);
            break;
          }
        }
      } finally {
        rn = !1, Error.prepareStackTrace = V;
      }
      return (m = m ? m.displayName || m.name : "") ? Zn(m) : "";
    }
    var Fi = Object.prototype.hasOwnProperty, Ir = [], Tn = -1;
    function mi(m) {
      return { current: m };
    }
    function xn(m) {
      0 > Tn || (m.current = Ir[Tn], Ir[Tn] = null, Tn--);
    }
    function un(m, A) {
      Tn++, Ir[Tn] = m.current, m.current = A;
    }
    var Xn = {}, li = mi(Xn), Wr = mi(!1), Xo = Xn;
    function $r(m, A) {
      var V = m.type.contextTypes;
      if (!V) return Xn;
      var E = m.stateNode;
      if (E && E.__reactInternalMemoizedUnmaskedChildContext === A) return E.__reactInternalMemoizedMaskedChildContext;
      var k = {}, $;
      for ($ in V) k[$] = A[$];
      return E && (m = m.stateNode, m.__reactInternalMemoizedUnmaskedChildContext = A, m.__reactInternalMemoizedMaskedChildContext = k), k;
    }
    function ba(m) {
      return m = m.childContextTypes, m != null;
    }
    function or() {
      xn(Wr), xn(li);
    }
    function za(m, A, V) {
      if (li.current !== Xn) throw Error(l(168));
      un(li, A), un(Wr, V);
    }
    function pl(m, A, V) {
      var E = m.stateNode;
      if (A = A.childContextTypes, typeof E.getChildContext != "function") return V;
      E = E.getChildContext();
      for (var k in E) if (!(k in A)) throw Error(l(108, j(m) || "Unknown", k));
      return o({}, V, E);
    }
    function Xa(m) {
      return m = (m = m.stateNode) && m.__reactInternalMemoizedMergedChildContext || Xn, Xo = li.current, un(li, m), un(Wr, Wr.current), !0;
    }
    function bs(m, A, V) {
      var E = m.stateNode;
      if (!E) throw Error(l(169));
      V ? (m = pl(m, A, Xo), E.__reactInternalMemoizedMergedChildContext = m, xn(Wr), xn(li), un(li, m)) : xn(Wr), un(Wr, V);
    }
    var Ao = Math.clz32 ? Math.clz32 : dI, Ou = Math.log, od = Math.LN2;
    function dI(m) {
      return m >>>= 0, m === 0 ? 32 : 31 - (Ou(m) / od | 0) | 0;
    }
    var Pu = 64, sr = 4194304;
    function Yo(m) {
      switch (m & -m) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return m & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return m & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return m;
      }
    }
    function Cu(m, A) {
      var V = m.pendingLanes;
      if (V === 0) return 0;
      var E = 0, k = m.suspendedLanes, $ = m.pingedLanes, ve = V & 268435455;
      if (ve !== 0) {
        var Ke = ve & ~k;
        Ke !== 0 ? E = Yo(Ke) : ($ &= ve, $ !== 0 && (E = Yo($)));
      } else ve = V & ~k, ve !== 0 ? E = Yo(ve) : $ !== 0 && (E = Yo($));
      if (E === 0) return 0;
      if (A !== 0 && A !== E && (A & k) === 0 && (k = E & -E, $ = A & -A, k >= $ || k === 16 && ($ & 4194240) !== 0)) return A;
      if ((E & 4) !== 0 && (E |= V & 16), A = m.entangledLanes, A !== 0) for (m = m.entanglements, A &= E; 0 < A; ) V = 31 - Ao(A), k = 1 << V, E |= m[V], A &= ~k;
      return E;
    }
    function Hi(m, A) {
      switch (m) {
        case 1:
        case 2:
        case 4:
          return A + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return A + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function sf(m, A) {
      for (var V = m.suspendedLanes, E = m.pingedLanes, k = m.expirationTimes, $ = m.pendingLanes; 0 < $; ) {
        var ve = 31 - Ao($), Ke = 1 << ve, Rt = k[ve];
        Rt === -1 ? ((Ke & V) === 0 || (Ke & E) !== 0) && (k[ve] = Hi(Ke, A)) : Rt <= A && (m.expiredLanes |= Ke), $ &= ~Ke;
      }
    }
    function hu(m) {
      return m = m.pendingLanes & -1073741825, m !== 0 ? m : m & 1073741824 ? 1073741824 : 0;
    }
    function xi(m) {
      for (var A = [], V = 0; 31 > V; V++) A.push(m);
      return A;
    }
    function Ju(m, A, V) {
      m.pendingLanes |= A, A !== 536870912 && (m.suspendedLanes = 0, m.pingedLanes = 0), m = m.eventTimes, A = 31 - Ao(A), m[A] = V;
    }
    function Po(m, A) {
      var V = m.pendingLanes & ~A;
      m.pendingLanes = A, m.suspendedLanes = 0, m.pingedLanes = 0, m.expiredLanes &= A, m.mutableReadLanes &= A, m.entangledLanes &= A, A = m.entanglements;
      var E = m.eventTimes;
      for (m = m.expirationTimes; 0 < V; ) {
        var k = 31 - Ao(V), $ = 1 << k;
        A[k] = 0, E[k] = -1, m[k] = -1, V &= ~$;
      }
    }
    function Gs(m, A) {
      var V = m.entangledLanes |= A;
      for (m = m.entanglements; V; ) {
        var E = 31 - Ao(V), k = 1 << E;
        k & A | m[E] & A && (m[E] |= A), V &= ~k;
      }
    }
    var Bi = 0;
    function Qu(m) {
      return m &= -m, 1 < m ? 4 < m ? (m & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
    }
    var Ra = i.unstable_scheduleCallback, Lr = i.unstable_cancelCallback, Ds = i.unstable_shouldYield, fu = i.unstable_requestPaint, Sr = i.unstable_now, as = i.unstable_ImmediatePriority, Ap = i.unstable_UserBlockingPriority, sd = i.unstable_NormalPriority, II = i.unstable_IdlePriority, hg = null, Us = null;
    function CI(m) {
      if (Us && typeof Us.onCommitFiberRoot == "function") try {
        Us.onCommitFiberRoot(hg, m, void 0, (m.current.flags & 128) === 128);
      } catch {
      }
    }
    function pu(m, A) {
      return m === A && (m !== 0 || 1 / m === 1 / A) || m !== m && A !== A;
    }
    var $a = typeof Object.is == "function" ? Object.is : pu, Bs = null, Ul = !1, ld = !1;
    function fg(m) {
      Bs === null ? Bs = [m] : Bs.push(m);
    }
    function pg(m) {
      Ul = !0, fg(m);
    }
    function Os() {
      if (!ld && Bs !== null) {
        ld = !0;
        var m = 0, A = Bi;
        try {
          var V = Bs;
          for (Bi = 1; m < V.length; m++) {
            var E = V[m];
            do
              E = E(!0);
            while (E !== null);
          }
          Bs = null, Ul = !1;
        } catch (k) {
          throw Bs !== null && (Bs = Bs.slice(m + 1)), Ra(as, Os), k;
        } finally {
          Bi = A, ld = !1;
        }
      }
      return null;
    }
    var th = u.ReactCurrentBatchConfig;
    function Ps(m, A) {
      if ($a(m, A)) return !0;
      if (typeof m != "object" || m === null || typeof A != "object" || A === null) return !1;
      var V = Object.keys(m), E = Object.keys(A);
      if (V.length !== E.length) return !1;
      for (E = 0; E < V.length; E++) {
        var k = V[E];
        if (!Fi.call(A, k) || !$a(m[k], A[k])) return !1;
      }
      return !0;
    }
    function hI(m) {
      switch (m.tag) {
        case 5:
          return Zn(m.type);
        case 16:
          return Zn("Lazy");
        case 13:
          return Zn("Suspense");
        case 19:
          return Zn("SuspenseList");
        case 0:
        case 2:
        case 15:
          return m = Yn(m.type, !1), m;
        case 11:
          return m = Yn(m.type.render, !1), m;
        case 1:
          return m = Yn(m.type, !0), m;
        default:
          return "";
      }
    }
    function ie(m, A) {
      if (m && m.defaultProps) {
        A = o({}, A), m = m.defaultProps;
        for (var V in m) A[V] === void 0 && (A[V] = m[V]);
        return A;
      }
      return A;
    }
    var Me = mi(null), gt = null, St = null, dn = null;
    function qn() {
      dn = St = gt = null;
    }
    function _n(m, A, V) {
      An ? (un(Me, A._currentValue), A._currentValue = V) : (un(Me, A._currentValue2), A._currentValue2 = V);
    }
    function Si(m) {
      var A = Me.current;
      xn(Me), An ? m._currentValue = A : m._currentValue2 = A;
    }
    function Ui(m, A, V) {
      for (; m !== null; ) {
        var E = m.alternate;
        if ((m.childLanes & A) !== A ? (m.childLanes |= A, E !== null && (E.childLanes |= A)) : E !== null && (E.childLanes & A) !== A && (E.childLanes |= A), m === V) break;
        m = m.return;
      }
    }
    function ur(m, A) {
      gt = m, dn = St = null, m = m.dependencies, m !== null && m.firstContext !== null && ((m.lanes & A) !== 0 && (pi = !0), m.firstContext = null);
    }
    function nr(m) {
      var A = An ? m._currentValue : m._currentValue2;
      if (dn !== m) if (m = { context: m, memoizedValue: A, next: null }, St === null) {
        if (gt === null) throw Error(l(308));
        St = m, gt.dependencies = { lanes: 0, firstContext: m };
      } else St = St.next = m;
      return A;
    }
    var $i = null, Zi = !1;
    function kr(m) {
      m.updateQueue = { baseState: m.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Ka(m, A) {
      m = m.updateQueue, A.updateQueue === m && (A.updateQueue = { baseState: m.baseState, firstBaseUpdate: m.firstBaseUpdate, lastBaseUpdate: m.lastBaseUpdate, shared: m.shared, effects: m.effects });
    }
    function Js(m, A) {
      return { eventTime: m, lane: A, tag: 0, payload: null, callback: null, next: null };
    }
    function mu(m, A) {
      var V = m.updateQueue;
      V !== null && (V = V.shared, oo !== null && (m.mode & 1) !== 0 && (ri & 2) === 0 ? (m = V.interleaved, m === null ? (A.next = A, $i === null ? $i = [V] : $i.push(V)) : (A.next = m.next, m.next = A), V.interleaved = A) : (m = V.pending, m === null ? A.next = A : (A.next = m.next, m.next = A), V.pending = A));
    }
    function Au(m, A, V) {
      if (A = A.updateQueue, A !== null && (A = A.shared, (V & 4194240) !== 0)) {
        var E = A.lanes;
        E &= m.pendingLanes, V |= E, A.lanes = V, Gs(m, V);
      }
    }
    function ud(m, A) {
      var V = m.updateQueue, E = m.alternate;
      if (E !== null && (E = E.updateQueue, V === E)) {
        var k = null, $ = null;
        if (V = V.firstBaseUpdate, V !== null) {
          do {
            var ve = { eventTime: V.eventTime, lane: V.lane, tag: V.tag, payload: V.payload, callback: V.callback, next: null };
            $ === null ? k = $ = ve : $ = $.next = ve, V = V.next;
          } while (V !== null);
          $ === null ? k = $ = A : $ = $.next = A;
        } else k = $ = A;
        V = { baseState: E.baseState, firstBaseUpdate: k, lastBaseUpdate: $, shared: E.shared, effects: E.effects }, m.updateQueue = V;
        return;
      }
      m = V.lastBaseUpdate, m === null ? V.firstBaseUpdate = A : m.next = A, V.lastBaseUpdate = A;
    }
    function mg(m, A, V, E) {
      var k = m.updateQueue;
      Zi = !1;
      var $ = k.firstBaseUpdate, ve = k.lastBaseUpdate, Ke = k.shared.pending;
      if (Ke !== null) {
        k.shared.pending = null;
        var Rt = Ke, In = Rt.next;
        Rt.next = null, ve === null ? $ = In : ve.next = In, ve = Rt;
        var $n = m.alternate;
        $n !== null && ($n = $n.updateQueue, Ke = $n.lastBaseUpdate, Ke !== ve && (Ke === null ? $n.firstBaseUpdate = In : Ke.next = In, $n.lastBaseUpdate = Rt));
      }
      if ($ !== null) {
        var zi = k.baseState;
        ve = 0, $n = In = Rt = null, Ke = $;
        do {
          var ci = Ke.lane, Yi = Ke.eventTime;
          if ((E & ci) === ci) {
            $n !== null && ($n = $n.next = {
              eventTime: Yi,
              lane: 0,
              tag: Ke.tag,
              payload: Ke.payload,
              callback: Ke.callback,
              next: null
            });
            e: {
              var wn = m, Oa = Ke;
              switch (ci = A, Yi = V, Oa.tag) {
                case 1:
                  if (wn = Oa.payload, typeof wn == "function") {
                    zi = wn.call(Yi, zi, ci);
                    break e;
                  }
                  zi = wn;
                  break e;
                case 3:
                  wn.flags = wn.flags & -65537 | 128;
                case 0:
                  if (wn = Oa.payload, ci = typeof wn == "function" ? wn.call(Yi, zi, ci) : wn, ci == null) break e;
                  zi = o({}, zi, ci);
                  break e;
                case 2:
                  Zi = !0;
              }
            }
            Ke.callback !== null && Ke.lane !== 0 && (m.flags |= 64, ci = k.effects, ci === null ? k.effects = [Ke] : ci.push(Ke));
          } else Yi = { eventTime: Yi, lane: ci, tag: Ke.tag, payload: Ke.payload, callback: Ke.callback, next: null }, $n === null ? (In = $n = Yi, Rt = zi) : $n = $n.next = Yi, ve |= ci;
          if (Ke = Ke.next, Ke === null) {
            if (Ke = k.shared.pending, Ke === null) break;
            ci = Ke, Ke = ci.next, ci.next = null, k.lastBaseUpdate = ci, k.shared.pending = null;
          }
        } while (!0);
        if ($n === null && (Rt = zi), k.baseState = Rt, k.firstBaseUpdate = In, k.lastBaseUpdate = $n, A = k.shared.interleaved, A !== null) {
          k = A;
          do
            ve |= k.lane, k = k.next;
          while (k !== A);
        } else $ === null && (k.shared.lanes = 0);
        ic |= ve, m.lanes = ve, m.memoizedState = zi;
      }
    }
    function lf(m, A, V) {
      if (m = A.effects, A.effects = null, m !== null) for (A = 0; A < m.length; A++) {
        var E = m[A], k = E.callback;
        if (k !== null) {
          if (E.callback = null, E = V, typeof k != "function") throw Error(l(191, k));
          k.call(E);
        }
      }
    }
    var nh = new n.Component().refs;
    function ih(m, A, V, E) {
      A = m.memoizedState, V = V(E, A), V = V == null ? A : o({}, A, V), m.memoizedState = V, m.lanes === 0 && (m.updateQueue.baseState = V);
    }
    var rh = { isMounted: function(m) {
      return (m = m._reactInternals) ? J(m) === m : !1;
    }, enqueueSetState: function(m, A, V) {
      m = m._reactInternals;
      var E = fr(), k = ac(m), $ = Js(E, k);
      $.payload = A, V != null && ($.callback = V), mu(m, $), A = ca(m, k, E), A !== null && Au(A, m, k);
    }, enqueueReplaceState: function(m, A, V) {
      m = m._reactInternals;
      var E = fr(), k = ac(m), $ = Js(E, k);
      $.tag = 1, $.payload = A, V != null && ($.callback = V), mu(m, $), A = ca(m, k, E), A !== null && Au(A, m, k);
    }, enqueueForceUpdate: function(m, A) {
      m = m._reactInternals;
      var V = fr(), E = ac(m), k = Js(
        V,
        E
      );
      k.tag = 2, A != null && (k.callback = A), mu(m, k), A = ca(m, E, V), A !== null && Au(A, m, E);
    } };
    function ah(m, A, V, E, k, $, ve) {
      return m = m.stateNode, typeof m.shouldComponentUpdate == "function" ? m.shouldComponentUpdate(E, $, ve) : A.prototype && A.prototype.isPureReactComponent ? !Ps(V, E) || !Ps(k, $) : !0;
    }
    function vp(m, A, V) {
      var E = !1, k = Xn, $ = A.contextType;
      return typeof $ == "object" && $ !== null ? $ = nr($) : (k = ba(A) ? Xo : li.current, E = A.contextTypes, $ = (E = E != null) ? $r(m, k) : Xn), A = new A(V, $), m.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null, A.updater = rh, m.stateNode = A, A._reactInternals = m, E && (m = m.stateNode, m.__reactInternalMemoizedUnmaskedChildContext = k, m.__reactInternalMemoizedMaskedChildContext = $), A;
    }
    function yp(m, A, V, E) {
      m = A.state, typeof A.componentWillReceiveProps == "function" && A.componentWillReceiveProps(V, E), typeof A.UNSAFE_componentWillReceiveProps == "function" && A.UNSAFE_componentWillReceiveProps(V, E), A.state !== m && rh.enqueueReplaceState(A, A.state, null);
    }
    function uf(m, A, V, E) {
      var k = m.stateNode;
      k.props = V, k.state = m.memoizedState, k.refs = nh, kr(m);
      var $ = A.contextType;
      typeof $ == "object" && $ !== null ? k.context = nr($) : ($ = ba(A) ? Xo : li.current, k.context = $r(m, $)), k.state = m.memoizedState, $ = A.getDerivedStateFromProps, typeof $ == "function" && (ih(m, A, $, V), k.state = m.memoizedState), typeof A.getDerivedStateFromProps == "function" || typeof k.getSnapshotBeforeUpdate == "function" || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (A = k.state, typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount(), A !== k.state && rh.enqueueReplaceState(k, k.state, null), mg(m, V, k, E), k.state = m.memoizedState), typeof k.componentDidMount == "function" && (m.flags |= 4194308);
    }
    var qI = [], Ss = 0, cf = null, $I = 0, ml = [], Qs = 0, fI = null, vu = 1, xc = "";
    function vo(m, A) {
      qI[Ss++] = $I, qI[Ss++] = cf, cf = m, $I = A;
    }
    function Wc(m, A, V) {
      ml[Qs++] = vu, ml[Qs++] = xc, ml[Qs++] = fI, fI = m;
      var E = vu;
      m = xc;
      var k = 32 - Ao(E) - 1;
      E &= ~(1 << k), V += 1;
      var $ = 32 - Ao(A) + k;
      if (30 < $) {
        var ve = k - k % 5;
        $ = (E & (1 << ve) - 1).toString(32), E >>= ve, k -= ve, vu = 1 << 32 - Ao(A) + k | V << k | E, xc = $ + m;
      } else vu = 1 << $ | V << k | E, xc = m;
    }
    function ha(m) {
      m.return !== null && (vo(m, 1), Wc(m, 1, 0));
    }
    function yu(m) {
      for (; m === cf; ) cf = qI[--Ss], qI[Ss] = null, $I = qI[--Ss], qI[Ss] = null;
      for (; m === fI; ) fI = ml[--Qs], ml[Qs] = null, xc = ml[--Qs], ml[Qs] = null, vu = ml[--Qs], ml[Qs] = null;
    }
    var Jo = null, eo = null, Ga = !1, ju = !1, Ol = null;
    function gf(m, A) {
      var V = uo(5, null, null, 0);
      V.elementType = "DELETED", V.stateNode = A, V.return = m, A = m.deletions, A === null ? (m.deletions = [V], m.flags |= 16) : A.push(V);
    }
    function eC(m, A) {
      switch (m.tag) {
        case 5:
          return A = la(A, m.type, m.pendingProps), A !== null ? (m.stateNode = A, Jo = m, eo = Ln(A), !0) : !1;
        case 6:
          return A = Ve(A, m.pendingProps), A !== null ? (m.stateNode = A, Jo = m, eo = null, !0) : !1;
        case 13:
          if (A = Oe(A), A !== null) {
            var V = fI !== null ? { id: vu, overflow: xc } : null;
            return m.memoizedState = { dehydrated: A, treeContext: V, retryLane: 1073741824 }, V = uo(18, null, null, 0), V.stateNode = A, V.return = m, m.child = V, Jo = m, eo = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function df(m) {
      return (m.mode & 1) !== 0 && (m.flags & 128) === 0;
    }
    function cd(m) {
      if (Ga) {
        var A = eo;
        if (A) {
          var V = A;
          if (!eC(m, A)) {
            if (df(m)) throw Error(l(418));
            A = Vn(V);
            var E = Jo;
            A && eC(m, A) ? gf(E, V) : (m.flags = m.flags & -4097 | 2, Ga = !1, Jo = m);
          }
        } else {
          if (df(m)) throw Error(l(418));
          m.flags = m.flags & -4097 | 2, Ga = !1, Jo = m;
        }
      }
    }
    function If(m) {
      for (m = m.return; m !== null && m.tag !== 5 && m.tag !== 3 && m.tag !== 13; ) m = m.return;
      Jo = m;
    }
    function gd(m) {
      if (!Wt || m !== Jo) return !1;
      if (!Ga) return If(m), Ga = !0, !1;
      if (m.tag !== 3 && (m.tag !== 5 || Tt(m.type) && !Je(m.type, m.memoizedProps))) {
        var A = eo;
        if (A) {
          if (df(m)) {
            for (m = eo; m; ) m = Vn(m);
            throw Error(l(418));
          }
          for (; A; ) gf(m, A), A = Vn(A);
        }
      }
      if (If(m), m.tag === 13) {
        if (!Wt) throw Error(l(316));
        if (m = m.memoizedState, m = m !== null ? m.dehydrated : null, !m) throw Error(l(317));
        eo = ae(m);
      } else eo = Jo ? Vn(m.stateNode) : null;
      return !0;
    }
    function Pl() {
      Wt && (eo = Jo = null, ju = Ga = !1);
    }
    function tC(m) {
      Ol === null ? Ol = [m] : Ol.push(m);
    }
    function Ag(m, A, V) {
      if (m = V.ref, m !== null && typeof m != "function" && typeof m != "object") {
        if (V._owner) {
          if (V = V._owner, V) {
            if (V.tag !== 1) throw Error(l(309));
            var E = V.stateNode;
          }
          if (!E) throw Error(l(147, m));
          var k = E, $ = "" + m;
          return A !== null && A.ref !== null && typeof A.ref == "function" && A.ref._stringRef === $ ? A.ref : (A = function(ve) {
            var Ke = k.refs;
            Ke === nh && (Ke = k.refs = {}), ve === null ? delete Ke[$] : Ke[$] = ve;
          }, A._stringRef = $, A);
        }
        if (typeof m != "string") throw Error(l(284));
        if (!V._owner) throw Error(l(290, m));
      }
      return m;
    }
    function vg(m, A) {
      throw m = Object.prototype.toString.call(A), Error(l(31, m === "[object Object]" ? "object with keys {" + Object.keys(A).join(", ") + "}" : m));
    }
    function Jl(m) {
      var A = m._init;
      return A(m._payload);
    }
    function Cf(m) {
      function A(ot, Fe) {
        if (m) {
          var bt = ot.deletions;
          bt === null ? (ot.deletions = [Fe], ot.flags |= 16) : bt.push(Fe);
        }
      }
      function V(ot, Fe) {
        if (!m) return null;
        for (; Fe !== null; ) A(ot, Fe), Fe = Fe.sibling;
        return null;
      }
      function E(ot, Fe) {
        for (ot = /* @__PURE__ */ new Map(); Fe !== null; ) Fe.key !== null ? ot.set(Fe.key, Fe) : ot.set(Fe.index, Fe), Fe = Fe.sibling;
        return ot;
      }
      function k(ot, Fe) {
        return ot = xl(ot, Fe), ot.index = 0, ot.sibling = null, ot;
      }
      function $(ot, Fe, bt) {
        return ot.index = bt, m ? (bt = ot.alternate, bt !== null ? (bt = bt.index, bt < Fe ? (ot.flags |= 2, Fe) : bt) : (ot.flags |= 2, Fe)) : (ot.flags |= 1048576, Fe);
      }
      function ve(ot) {
        return m && ot.alternate === null && (ot.flags |= 2), ot;
      }
      function Ke(ot, Fe, bt, Sn) {
        return Fe === null || Fe.tag !== 6 ? (Fe = il(bt, ot.mode, Sn), Fe.return = ot, Fe) : (Fe = k(Fe, bt), Fe.return = ot, Fe);
      }
      function Rt(ot, Fe, bt, Sn) {
        var ei = bt.type;
        return ei === f ? $n(ot, Fe, bt.props.children, Sn, bt.key) : Fe !== null && (Fe.elementType === ei || typeof ei == "object" && ei !== null && ei.$$typeof === F && Jl(ei) === Fe.type) ? (Sn = k(Fe, bt.props), Sn.ref = Ag(ot, Fe, bt), Sn.return = ot, Sn) : (Sn = dC(bt.type, bt.key, bt.props, null, ot.mode, Sn), Sn.ref = Ag(ot, Fe, bt), Sn.return = ot, Sn);
      }
      function In(ot, Fe, bt, Sn) {
        return Fe === null || Fe.tag !== 4 || Fe.stateNode.containerInfo !== bt.containerInfo || Fe.stateNode.implementation !== bt.implementation ? (Fe = Wl(bt, ot.mode, Sn), Fe.return = ot, Fe) : (Fe = k(Fe, bt.children || []), Fe.return = ot, Fe);
      }
      function $n(ot, Fe, bt, Sn, ei) {
        return Fe === null || Fe.tag !== 7 ? (Fe = iu(bt, ot.mode, Sn, ei), Fe.return = ot, Fe) : (Fe = k(Fe, bt), Fe.return = ot, Fe);
      }
      function zi(ot, Fe, bt) {
        if (typeof Fe == "string" && Fe !== "" || typeof Fe == "number") return Fe = il("" + Fe, ot.mode, bt), Fe.return = ot, Fe;
        if (typeof Fe == "object" && Fe !== null) {
          switch (Fe.$$typeof) {
            case I:
              return bt = dC(Fe.type, Fe.key, Fe.props, null, ot.mode, bt), bt.ref = Ag(ot, null, Fe), bt.return = ot, bt;
            case C:
              return Fe = Wl(Fe, ot.mode, bt), Fe.return = ot, Fe;
            case F:
              var Sn = Fe._init;
              return zi(ot, Sn(Fe._payload), bt);
          }
          if (ke(Fe) || D(Fe)) return Fe = iu(Fe, ot.mode, bt, null), Fe.return = ot, Fe;
          vg(ot, Fe);
        }
        return null;
      }
      function ci(ot, Fe, bt, Sn) {
        var ei = Fe !== null ? Fe.key : null;
        if (typeof bt == "string" && bt !== "" || typeof bt == "number") return ei !== null ? null : Ke(ot, Fe, "" + bt, Sn);
        if (typeof bt == "object" && bt !== null) {
          switch (bt.$$typeof) {
            case I:
              return bt.key === ei ? Rt(ot, Fe, bt, Sn) : null;
            case C:
              return bt.key === ei ? In(ot, Fe, bt, Sn) : null;
            case F:
              return ei = bt._init, ci(
                ot,
                Fe,
                ei(bt._payload),
                Sn
              );
          }
          if (ke(bt) || D(bt)) return ei !== null ? null : $n(ot, Fe, bt, Sn, null);
          vg(ot, bt);
        }
        return null;
      }
      function Yi(ot, Fe, bt, Sn, ei) {
        if (typeof Sn == "string" && Sn !== "" || typeof Sn == "number") return ot = ot.get(bt) || null, Ke(Fe, ot, "" + Sn, ei);
        if (typeof Sn == "object" && Sn !== null) {
          switch (Sn.$$typeof) {
            case I:
              return ot = ot.get(Sn.key === null ? bt : Sn.key) || null, Rt(Fe, ot, Sn, ei);
            case C:
              return ot = ot.get(Sn.key === null ? bt : Sn.key) || null, In(Fe, ot, Sn, ei);
            case F:
              var Ki = Sn._init;
              return Yi(ot, Fe, bt, Ki(Sn._payload), ei);
          }
          if (ke(Sn) || D(Sn)) return ot = ot.get(bt) || null, $n(Fe, ot, Sn, ei, null);
          vg(Fe, Sn);
        }
        return null;
      }
      function wn(ot, Fe, bt, Sn) {
        for (var ei = null, Ki = null, Vi = Fe, cr = Fe = 0, Ea = null; Vi !== null && cr < bt.length; cr++) {
          Vi.index > cr ? (Ea = Vi, Vi = null) : Ea = Vi.sibling;
          var pr = ci(ot, Vi, bt[cr], Sn);
          if (pr === null) {
            Vi === null && (Vi = Ea);
            break;
          }
          m && Vi && pr.alternate === null && A(ot, Vi), Fe = $(pr, Fe, cr), Ki === null ? ei = pr : Ki.sibling = pr, Ki = pr, Vi = Ea;
        }
        if (cr === bt.length) return V(ot, Vi), Ga && vo(ot, cr), ei;
        if (Vi === null) {
          for (; cr < bt.length; cr++) Vi = zi(ot, bt[cr], Sn), Vi !== null && (Fe = $(Vi, Fe, cr), Ki === null ? ei = Vi : Ki.sibling = Vi, Ki = Vi);
          return Ga && vo(ot, cr), ei;
        }
        for (Vi = E(ot, Vi); cr < bt.length; cr++) Ea = Yi(Vi, ot, cr, bt[cr], Sn), Ea !== null && (m && Ea.alternate !== null && Vi.delete(Ea.key === null ? cr : Ea.key), Fe = $(Ea, Fe, cr), Ki === null ? ei = Ea : Ki.sibling = Ea, Ki = Ea);
        return m && Vi.forEach(function(_c) {
          return A(ot, _c);
        }), Ga && vo(ot, cr), ei;
      }
      function Oa(ot, Fe, bt, Sn) {
        var ei = D(bt);
        if (typeof ei != "function") throw Error(l(150));
        if (bt = ei.call(bt), bt == null) throw Error(l(151));
        for (var Ki = ei = null, Vi = Fe, cr = Fe = 0, Ea = null, pr = bt.next(); Vi !== null && !pr.done; cr++, pr = bt.next()) {
          Vi.index > cr ? (Ea = Vi, Vi = null) : Ea = Vi.sibling;
          var _c = ci(ot, Vi, pr.value, Sn);
          if (_c === null) {
            Vi === null && (Vi = Ea);
            break;
          }
          m && Vi && _c.alternate === null && A(ot, Vi), Fe = $(_c, Fe, cr), Ki === null ? ei = _c : Ki.sibling = _c, Ki = _c, Vi = Ea;
        }
        if (pr.done) return V(
          ot,
          Vi
        ), Ga && vo(ot, cr), ei;
        if (Vi === null) {
          for (; !pr.done; cr++, pr = bt.next()) pr = zi(ot, pr.value, Sn), pr !== null && (Fe = $(pr, Fe, cr), Ki === null ? ei = pr : Ki.sibling = pr, Ki = pr);
          return Ga && vo(ot, cr), ei;
        }
        for (Vi = E(ot, Vi); !pr.done; cr++, pr = bt.next()) pr = Yi(Vi, ot, cr, pr.value, Sn), pr !== null && (m && pr.alternate !== null && Vi.delete(pr.key === null ? cr : pr.key), Fe = $(pr, Fe, cr), Ki === null ? ei = pr : Ki.sibling = pr, Ki = pr);
        return m && Vi.forEach(function(Vd) {
          return A(ot, Vd);
        }), Ga && vo(ot, cr), ei;
      }
      function ga(ot, Fe, bt, Sn) {
        if (typeof bt == "object" && bt !== null && bt.type === f && bt.key === null && (bt = bt.props.children), typeof bt == "object" && bt !== null) {
          switch (bt.$$typeof) {
            case I:
              e: {
                for (var ei = bt.key, Ki = Fe; Ki !== null; ) {
                  if (Ki.key === ei) {
                    if (ei = bt.type, ei === f) {
                      if (Ki.tag === 7) {
                        V(ot, Ki.sibling), Fe = k(Ki, bt.props.children), Fe.return = ot, ot = Fe;
                        break e;
                      }
                    } else if (Ki.elementType === ei || typeof ei == "object" && ei !== null && ei.$$typeof === F && Jl(ei) === Ki.type) {
                      V(ot, Ki.sibling), Fe = k(Ki, bt.props), Fe.ref = Ag(ot, Ki, bt), Fe.return = ot, ot = Fe;
                      break e;
                    }
                    V(ot, Ki);
                    break;
                  } else A(ot, Ki);
                  Ki = Ki.sibling;
                }
                bt.type === f ? (Fe = iu(bt.props.children, ot.mode, Sn, bt.key), Fe.return = ot, ot = Fe) : (Sn = dC(bt.type, bt.key, bt.props, null, ot.mode, Sn), Sn.ref = Ag(ot, Fe, bt), Sn.return = ot, ot = Sn);
              }
              return ve(ot);
            case C:
              e: {
                for (Ki = bt.key; Fe !== null; ) {
                  if (Fe.key === Ki) if (Fe.tag === 4 && Fe.stateNode.containerInfo === bt.containerInfo && Fe.stateNode.implementation === bt.implementation) {
                    V(ot, Fe.sibling), Fe = k(Fe, bt.children || []), Fe.return = ot, ot = Fe;
                    break e;
                  } else {
                    V(ot, Fe);
                    break;
                  }
                  else A(ot, Fe);
                  Fe = Fe.sibling;
                }
                Fe = Wl(bt, ot.mode, Sn), Fe.return = ot, ot = Fe;
              }
              return ve(ot);
            case F:
              return Ki = bt._init, ga(ot, Fe, Ki(bt._payload), Sn);
          }
          if (ke(bt)) return wn(ot, Fe, bt, Sn);
          if (D(bt)) return Oa(ot, Fe, bt, Sn);
          vg(ot, bt);
        }
        return typeof bt == "string" && bt !== "" || typeof bt == "number" ? (bt = "" + bt, Fe !== null && Fe.tag === 6 ? (V(ot, Fe.sibling), Fe = k(Fe, bt), Fe.return = ot, ot = Fe) : (V(ot, Fe), Fe = il(bt, ot.mode, Sn), Fe.return = ot, ot = Fe), ve(ot)) : V(ot, Fe);
      }
      return ga;
    }
    var bu = Cf(!0), bp = Cf(!1), dd = {}, js = mi(dd), Id = mi(dd), Cd = mi(dd);
    function Al(m) {
      if (m === dd) throw Error(l(174));
      return m;
    }
    function vl(m, A) {
      un(Cd, A), un(Id, m), un(js, dd), m = Xe(A), xn(js), un(js, m);
    }
    function hd() {
      xn(js), xn(Id), xn(Cd);
    }
    function oh(m) {
      var A = Al(Cd.current), V = Al(js.current);
      A = re(V, m.type, A), V !== A && (un(Id, m), un(js, A));
    }
    function Gu(m) {
      Id.current === m && (xn(js), xn(Id));
    }
    var Tr = mi(0);
    function yo(m) {
      for (var A = m; A !== null; ) {
        if (A.tag === 13) {
          var V = A.memoizedState;
          if (V !== null && (V = V.dehydrated, V === null || rt(V) || Et(V))) return A;
        } else if (A.tag === 19 && A.memoizedProps.revealOrder !== void 0) {
          if ((A.flags & 128) !== 0) return A;
        } else if (A.child !== null) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === m) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === m) return null;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      }
      return null;
    }
    var Dr = [];
    function yg() {
      for (var m = 0; m < Dr.length; m++) {
        var A = Dr[m];
        An ? A._workInProgressVersionPrimary = null : A._workInProgressVersionSecondary = null;
      }
      Dr.length = 0;
    }
    var os = u.ReactCurrentDispatcher, to = u.ReactCurrentBatchConfig, Qo = 0, Hr = null, fa = null, bo = null, yl = !1, Ql = !1, Zs = 0, fd = 0;
    function Go() {
      throw Error(l(321));
    }
    function sh(m, A) {
      if (A === null) return !1;
      for (var V = 0; V < A.length && V < m.length; V++) if (!$a(m[V], A[V])) return !1;
      return !0;
    }
    function pd(m, A, V, E, k, $) {
      if (Qo = $, Hr = A, A.memoizedState = null, A.updateQueue = null, A.lanes = 0, os.current = m === null || m.memoizedState === null ? vI : Bg, m = V(E, k), Ql) {
        $ = 0;
        do {
          if (Ql = !1, Zs = 0, 25 <= $) throw Error(l(301));
          $ += 1, bo = fa = null, A.updateQueue = null, os.current = rC, m = V(E, k);
        } while (Ql);
      }
      if (os.current = Su, A = fa !== null && fa.next !== null, Qo = 0, bo = fa = Hr = null, yl = !1, A) throw Error(l(300));
      return m;
    }
    function qu() {
      var m = Zs !== 0;
      return Zs = 0, m;
    }
    function jl() {
      var m = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return bo === null ? Hr.memoizedState = bo = m : bo = bo.next = m, bo;
    }
    function Ba() {
      if (fa === null) {
        var m = Hr.alternate;
        m = m !== null ? m.memoizedState : null;
      } else m = fa.next;
      var A = bo === null ? Hr.memoizedState : bo.next;
      if (A !== null) bo = A, fa = m;
      else {
        if (m === null) throw Error(l(310));
        fa = m, m = { memoizedState: fa.memoizedState, baseState: fa.baseState, baseQueue: fa.baseQueue, queue: fa.queue, next: null }, bo === null ? Hr.memoizedState = bo = m : bo = bo.next = m;
      }
      return bo;
    }
    function ws(m, A) {
      return typeof A == "function" ? A(m) : A;
    }
    function nC(m) {
      var A = Ba(), V = A.queue;
      if (V === null) throw Error(l(311));
      V.lastRenderedReducer = m;
      var E = fa, k = E.baseQueue, $ = V.pending;
      if ($ !== null) {
        if (k !== null) {
          var ve = k.next;
          k.next = $.next, $.next = ve;
        }
        E.baseQueue = k = $, V.pending = null;
      }
      if (k !== null) {
        $ = k.next, E = E.baseState;
        var Ke = ve = null, Rt = null, In = $;
        do {
          var $n = In.lane;
          if ((Qo & $n) === $n) Rt !== null && (Rt = Rt.next = { lane: 0, action: In.action, hasEagerState: In.hasEagerState, eagerState: In.eagerState, next: null }), E = In.hasEagerState ? In.eagerState : m(E, In.action);
          else {
            var zi = {
              lane: $n,
              action: In.action,
              hasEagerState: In.hasEagerState,
              eagerState: In.eagerState,
              next: null
            };
            Rt === null ? (Ke = Rt = zi, ve = E) : Rt = Rt.next = zi, Hr.lanes |= $n, ic |= $n;
          }
          In = In.next;
        } while (In !== null && In !== $);
        Rt === null ? ve = E : Rt.next = Ke, $a(E, A.memoizedState) || (pi = !0), A.memoizedState = E, A.baseState = ve, A.baseQueue = Rt, V.lastRenderedState = E;
      }
      if (m = V.interleaved, m !== null) {
        k = m;
        do
          $ = k.lane, Hr.lanes |= $, ic |= $, k = k.next;
        while (k !== m);
      } else k === null && (V.lanes = 0);
      return [A.memoizedState, V.dispatch];
    }
    function wi(m) {
      var A = Ba(), V = A.queue;
      if (V === null) throw Error(l(311));
      V.lastRenderedReducer = m;
      var E = V.dispatch, k = V.pending, $ = A.memoizedState;
      if (k !== null) {
        V.pending = null;
        var ve = k = k.next;
        do
          $ = m($, ve.action), ve = ve.next;
        while (ve !== k);
        $a($, A.memoizedState) || (pi = !0), A.memoizedState = $, A.baseQueue === null && (A.baseState = $), V.lastRenderedState = $;
      }
      return [$, E];
    }
    function _r() {
    }
    function vr(m, A) {
      var V = Hr, E = Ba(), k = A(), $ = !$a(E.memoizedState, k);
      if ($ && (E.memoizedState = k, pi = !0), E = E.queue, $l(Bu.bind(null, V, E, m), [m]), E.getSnapshot !== A || $ || bo !== null && bo.memoizedState.tag & 1) {
        if (V.flags |= 2048, bg(9, ql.bind(null, V, E, k, A), void 0, null), oo === null) throw Error(l(349));
        (Qo & 30) !== 0 || La(V, A, k);
      }
      return k;
    }
    function La(m, A, V) {
      m.flags |= 16384, m = { getSnapshot: A, value: V }, A = Hr.updateQueue, A === null ? (A = { lastEffect: null, stores: null }, Hr.updateQueue = A, A.stores = [m]) : (V = A.stores, V === null ? A.stores = [m] : V.push(m));
    }
    function ql(m, A, V, E) {
      A.value = V, A.getSnapshot = E, md(A) && ca(m, 1, -1);
    }
    function Bu(m, A, V) {
      return V(function() {
        md(A) && ca(m, 1, -1);
      });
    }
    function md(m) {
      var A = m.getSnapshot;
      m = m.value;
      try {
        var V = A();
        return !$a(m, V);
      } catch {
        return !0;
      }
    }
    function lh(m) {
      var A = jl();
      return typeof m == "function" && (m = m()), A.memoizedState = A.baseState = m, m = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ws, lastRenderedState: m }, A.queue = m, m = m.dispatch = Gp.bind(null, Hr, m), [A.memoizedState, m];
    }
    function bg(m, A, V, E) {
      return m = { tag: m, create: A, destroy: V, deps: E, next: null }, A = Hr.updateQueue, A === null ? (A = { lastEffect: null, stores: null }, Hr.updateQueue = A, A.lastEffect = m.next = m) : (V = A.lastEffect, V === null ? A.lastEffect = m.next = m : (E = V.next, V.next = m, m.next = E, A.lastEffect = m)), m;
    }
    function hf() {
      return Ba().memoizedState;
    }
    function Qt(m, A, V, E) {
      var k = jl();
      Hr.flags |= m, k.memoizedState = bg(1 | A, V, void 0, E === void 0 ? null : E);
    }
    function no(m, A, V, E) {
      var k = Ba();
      E = E === void 0 ? null : E;
      var $ = void 0;
      if (fa !== null) {
        var ve = fa.memoizedState;
        if ($ = ve.destroy, E !== null && sh(E, ve.deps)) {
          k.memoizedState = bg(A, V, $, E);
          return;
        }
      }
      Hr.flags |= m, k.memoizedState = bg(1 | A, V, $, E);
    }
    function ji(m, A) {
      return Qt(8390656, 8, m, A);
    }
    function $l(m, A) {
      return no(2048, 8, m, A);
    }
    function lr(m, A) {
      return no(4, 2, m, A);
    }
    function qs(m, A) {
      return no(4, 4, m, A);
    }
    function bl(m, A) {
      if (typeof A == "function") return m = m(), A(m), function() {
        A(null);
      };
      if (A != null) return m = m(), A.current = m, function() {
        A.current = null;
      };
    }
    function Vc(m, A, V) {
      return V = V != null ? V.concat([m]) : null, no(4, 4, bl.bind(null, A, m), V);
    }
    function Nc() {
    }
    function Ad(m, A) {
      var V = Ba();
      A = A === void 0 ? null : A;
      var E = V.memoizedState;
      return E !== null && A !== null && sh(A, E[1]) ? E[0] : (V.memoizedState = [m, A], m);
    }
    function Gg(m, A) {
      var V = Ba();
      A = A === void 0 ? null : A;
      var E = V.memoizedState;
      return E !== null && A !== null && sh(A, E[1]) ? E[0] : (m = m(), V.memoizedState = [m, A], m);
    }
    function pI(m, A) {
      var V = Bi;
      Bi = V !== 0 && 4 > V ? V : 4, m(!0);
      var E = to.transition;
      to.transition = {};
      try {
        m(!1), A();
      } finally {
        Bi = V, to.transition = E;
      }
    }
    function Mc() {
      return Ba().memoizedState;
    }
    function iC(m, A, V) {
      var E = ac(m);
      V = { lane: E, action: V, hasEagerState: !1, eagerState: null, next: null }, uh(m) ? ch(A, V) : (mI(m, A, V), V = fr(), m = ca(m, E, V), m !== null && AI(m, A, E));
    }
    function Gp(m, A, V) {
      var E = ac(m), k = { lane: E, action: V, hasEagerState: !1, eagerState: null, next: null };
      if (uh(m)) ch(A, k);
      else {
        mI(m, A, k);
        var $ = m.alternate;
        if (m.lanes === 0 && ($ === null || $.lanes === 0) && ($ = A.lastRenderedReducer, $ !== null)) try {
          var ve = A.lastRenderedState, Ke = $(ve, V);
          if (k.hasEagerState = !0, k.eagerState = Ke, $a(Ke, ve)) return;
        } catch {
        } finally {
        }
        V = fr(), m = ca(m, E, V), m !== null && AI(m, A, E);
      }
    }
    function uh(m) {
      var A = m.alternate;
      return m === Hr || A !== null && A === Hr;
    }
    function ch(m, A) {
      Ql = yl = !0;
      var V = m.pending;
      V === null ? A.next = A : (A.next = V.next, V.next = A), m.pending = A;
    }
    function mI(m, A, V) {
      oo !== null && (m.mode & 1) !== 0 && (ri & 2) === 0 ? (m = A.interleaved, m === null ? (V.next = V, $i === null ? $i = [A] : $i.push(A)) : (V.next = m.next, m.next = V), A.interleaved = V) : (m = A.pending, m === null ? V.next = V : (V.next = m.next, m.next = V), A.pending = V);
    }
    function AI(m, A, V) {
      if ((V & 4194240) !== 0) {
        var E = A.lanes;
        E &= m.pendingLanes, V |= E, A.lanes = V, Gs(m, V);
      }
    }
    var Su = { readContext: nr, useCallback: Go, useContext: Go, useEffect: Go, useImperativeHandle: Go, useInsertionEffect: Go, useLayoutEffect: Go, useMemo: Go, useReducer: Go, useRef: Go, useState: Go, useDebugValue: Go, useDeferredValue: Go, useTransition: Go, useMutableSource: Go, useSyncExternalStore: Go, useId: Go, unstable_isNewReconciler: !1 }, vI = { readContext: nr, useCallback: function(m, A) {
      return jl().memoizedState = [m, A === void 0 ? null : A], m;
    }, useContext: nr, useEffect: ji, useImperativeHandle: function(m, A, V) {
      return V = V != null ? V.concat([m]) : null, Qt(
        4194308,
        4,
        bl.bind(null, A, m),
        V
      );
    }, useLayoutEffect: function(m, A) {
      return Qt(4194308, 4, m, A);
    }, useInsertionEffect: function(m, A) {
      return Qt(4, 2, m, A);
    }, useMemo: function(m, A) {
      var V = jl();
      return A = A === void 0 ? null : A, m = m(), V.memoizedState = [m, A], m;
    }, useReducer: function(m, A, V) {
      var E = jl();
      return A = V !== void 0 ? V(A) : A, E.memoizedState = E.baseState = A, m = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: m, lastRenderedState: A }, E.queue = m, m = m.dispatch = iC.bind(null, Hr, m), [E.memoizedState, m];
    }, useRef: function(m) {
      var A = jl();
      return m = { current: m }, A.memoizedState = m;
    }, useState: lh, useDebugValue: Nc, useDeferredValue: function(m) {
      var A = lh(m), V = A[0], E = A[1];
      return ji(function() {
        var k = to.transition;
        to.transition = {};
        try {
          E(m);
        } finally {
          to.transition = k;
        }
      }, [m]), V;
    }, useTransition: function() {
      var m = lh(!1), A = m[0];
      return m = pI.bind(null, m[1]), jl().memoizedState = m, [A, m];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(m, A, V) {
      var E = Hr, k = jl();
      if (Ga) {
        if (V === void 0) throw Error(l(407));
        V = V();
      } else {
        if (V = A(), oo === null) throw Error(l(349));
        (Qo & 30) !== 0 || La(E, A, V);
      }
      k.memoizedState = V;
      var $ = { value: V, getSnapshot: A };
      return k.queue = $, ji(Bu.bind(null, E, $, m), [m]), E.flags |= 2048, bg(9, ql.bind(null, E, $, V, A), void 0, null), V;
    }, useId: function() {
      var m = jl(), A = oo.identifierPrefix;
      if (Ga) {
        var V = xc, E = vu;
        V = (E & ~(1 << 32 - Ao(E) - 1)).toString(32) + V, A = ":" + A + "R" + V, V = Zs++, 0 < V && (A += "H" + V.toString(32)), A += ":";
      } else V = fd++, A = ":" + A + "r" + V.toString(32) + ":";
      return m.memoizedState = A;
    }, unstable_isNewReconciler: !1 }, Bg = {
      readContext: nr,
      useCallback: Ad,
      useContext: nr,
      useEffect: $l,
      useImperativeHandle: Vc,
      useInsertionEffect: lr,
      useLayoutEffect: qs,
      useMemo: Gg,
      useReducer: nC,
      useRef: hf,
      useState: function() {
        return nC(ws);
      },
      useDebugValue: Nc,
      useDeferredValue: function(m) {
        var A = nC(ws), V = A[0], E = A[1];
        return $l(function() {
          var k = to.transition;
          to.transition = {};
          try {
            E(m);
          } finally {
            to.transition = k;
          }
        }, [m]), V;
      },
      useTransition: function() {
        var m = nC(ws)[0], A = Ba().memoizedState;
        return [m, A];
      },
      useMutableSource: _r,
      useSyncExternalStore: vr,
      useId: Mc,
      unstable_isNewReconciler: !1
    }, rC = {
      readContext: nr,
      useCallback: Ad,
      useContext: nr,
      useEffect: $l,
      useImperativeHandle: Vc,
      useInsertionEffect: lr,
      useLayoutEffect: qs,
      useMemo: Gg,
      useReducer: wi,
      useRef: hf,
      useState: function() {
        return wi(ws);
      },
      useDebugValue: Nc,
      useDeferredValue: function(m) {
        var A = wi(ws), V = A[0], E = A[1];
        return $l(function() {
          var k = to.transition;
          to.transition = {};
          try {
            E(m);
          } finally {
            to.transition = k;
          }
        }, [m]), V;
      },
      useTransition: function() {
        var m = wi(ws)[0], A = Ba().memoizedState;
        return [m, A];
      },
      useMutableSource: _r,
      useSyncExternalStore: vr,
      useId: Mc,
      unstable_isNewReconciler: !1
    };
    function aC(m, A) {
      try {
        var V = "", E = A;
        do
          V += hI(E), E = E.return;
        while (E);
        var k = V;
      } catch ($) {
        k = `
Error generating stack: ` + $.message + `
` + $.stack;
      }
      return { value: m, source: A, stack: k };
    }
    function vd(m, A) {
      try {
        console.error(A.value);
      } catch (V) {
        setTimeout(function() {
          throw V;
        });
      }
    }
    var ff = typeof WeakMap == "function" ? WeakMap : Map;
    function Zu(m, A, V) {
      V = Js(-1, V), V.tag = 3, V.payload = { element: null };
      var E = A.value;
      return V.callback = function() {
        cC || (cC = !0, pa = E), vd(m, A);
      }, V;
    }
    function Sg(m, A, V) {
      V = Js(-1, V), V.tag = 3;
      var E = m.type.getDerivedStateFromError;
      if (typeof E == "function") {
        var k = A.value;
        V.payload = function() {
          return E(k);
        }, V.callback = function() {
          vd(m, A);
        };
      }
      var $ = m.stateNode;
      return $ !== null && typeof $.componentDidCatch == "function" && (V.callback = function() {
        vd(m, A), typeof E != "function" && (rc === null ? rc = /* @__PURE__ */ new Set([this]) : rc.add(this));
        var ve = A.stack;
        this.componentDidCatch(A.value, { componentStack: ve !== null ? ve : "" });
      }), V;
    }
    function Gl(m, A, V) {
      var E = m.pingCache;
      if (E === null) {
        E = m.pingCache = new ff();
        var k = /* @__PURE__ */ new Set();
        E.set(A, k);
      } else k = E.get(A), k === void 0 && (k = /* @__PURE__ */ new Set(), E.set(A, k));
      k.has(V) || (k.add(V), m = oc.bind(null, m, A, V), A.then(m, m));
    }
    function yI(m) {
      do {
        var A;
        if ((A = m.tag === 13) && (A = m.memoizedState, A = A !== null ? A.dehydrated !== null : !0), A) return m;
        m = m.return;
      } while (m !== null);
      return null;
    }
    function Zg(m, A, V, E, k) {
      return (m.mode & 1) === 0 ? (m === A ? m.flags |= 65536 : (m.flags |= 128, V.flags |= 131072, V.flags &= -52805, V.tag === 1 && (V.alternate === null ? V.tag = 17 : (A = Js(-1, 1), A.tag = 2, mu(V, A))), V.lanes |= 1), m) : (m.flags |= 65536, m.lanes = k, m);
    }
    function ka(m) {
      m.flags |= 4;
    }
    function Hc(m, A) {
      if (m !== null && m.child === A.child) return !0;
      if ((A.flags & 16) !== 0) return !1;
      for (m = A.child; m !== null; ) {
        if ((m.flags & 12854) !== 0 || (m.subtreeFlags & 12854) !== 0) return !1;
        m = m.sibling;
      }
      return !0;
    }
    var Bl, $u, wu, Bo;
    if (Hn) Bl = function(m, A) {
      for (var V = A.child; V !== null; ) {
        if (V.tag === 5 || V.tag === 6) Ye(m, V.stateNode);
        else if (V.tag !== 4 && V.child !== null) {
          V.child.return = V, V = V.child;
          continue;
        }
        if (V === A) break;
        for (; V.sibling === null; ) {
          if (V.return === null || V.return === A) return;
          V = V.return;
        }
        V.sibling.return = V.return, V = V.sibling;
      }
    }, $u = function() {
    }, wu = function(m, A, V, E, k) {
      if (m = m.memoizedProps, m !== E) {
        var $ = A.stateNode, ve = Al(js.current);
        V = ze($, V, m, E, k, ve), (A.updateQueue = V) && ka(A);
      }
    }, Bo = function(m, A, V, E) {
      V !== E && ka(A);
    };
    else if (ge) {
      Bl = function(m, A, V, E) {
        for (var k = A.child; k !== null; ) {
          if (k.tag === 5) {
            var $ = k.stateNode;
            V && E && ($ = dr($, k.type, k.memoizedProps, k)), Ye(m, $);
          } else if (k.tag === 6) $ = k.stateNode, V && E && ($ = xr($, k.memoizedProps, k)), Ye(m, $);
          else if (k.tag !== 4) {
            if (k.tag === 22 && k.memoizedState !== null) $ = k.child, $ !== null && ($.return = k), Bl(m, k, !0, !0);
            else if (k.child !== null) {
              k.child.return = k, k = k.child;
              continue;
            }
          }
          if (k === A) break;
          for (; k.sibling === null; ) {
            if (k.return === null || k.return === A) return;
            k = k.return;
          }
          k.sibling.return = k.return, k = k.sibling;
        }
      };
      var yd = function(m, A, V, E) {
        for (var k = A.child; k !== null; ) {
          if (k.tag === 5) {
            var $ = k.stateNode;
            V && E && ($ = dr($, k.type, k.memoizedProps, k)), Di(m, $);
          } else if (k.tag === 6) $ = k.stateNode, V && E && ($ = xr($, k.memoizedProps, k)), Di(m, $);
          else if (k.tag !== 4) {
            if (k.tag === 22 && k.memoizedState !== null) $ = k.child, $ !== null && ($.return = k), yd(m, k, !0, !0);
            else if (k.child !== null) {
              k.child.return = k, k = k.child;
              continue;
            }
          }
          if (k === A) break;
          for (; k.sibling === null; ) {
            if (k.return === null || k.return === A) return;
            k = k.return;
          }
          k.sibling.return = k.return, k = k.sibling;
        }
      };
      $u = function(m, A) {
        var V = A.stateNode;
        if (!Hc(m, A)) {
          m = V.containerInfo;
          var E = di(m);
          yd(E, A, !1, !1), V.pendingChildren = E, ka(A), Jn(m, E);
        }
      }, wu = function(m, A, V, E, k) {
        var $ = m.stateNode, ve = m.memoizedProps;
        if ((m = Hc(m, A)) && ve === E) A.stateNode = $;
        else {
          var Ke = A.stateNode, Rt = Al(js.current), In = null;
          ve !== E && (In = ze(Ke, V, ve, E, k, Rt)), m && In === null ? A.stateNode = $ : ($ = Kn($, In, V, ve, E, A, m, Ke), nt($, V, E, k, Rt) && ka(A), A.stateNode = $, m ? ka(A) : Bl($, A, !1, !1));
        }
      }, Bo = function(m, A, V, E) {
        V !== E ? (m = Al(Cd.current), V = Al(js.current), A.stateNode = wt(E, m, V, A), ka(A)) : A.stateNode = m.stateNode;
      };
    } else $u = function() {
    }, wu = function() {
    }, Bo = function() {
    };
    function yr(m, A) {
      if (!Ga) switch (m.tailMode) {
        case "hidden":
          A = m.tail;
          for (var V = null; A !== null; ) A.alternate !== null && (V = A), A = A.sibling;
          V === null ? m.tail = null : V.sibling = null;
          break;
        case "collapsed":
          V = m.tail;
          for (var E = null; V !== null; ) V.alternate !== null && (E = V), V = V.sibling;
          E === null ? A || m.tail === null ? m.tail = null : m.tail.sibling = null : E.sibling = null;
      }
    }
    function Nn(m) {
      var A = m.alternate !== null && m.alternate.child === m.child, V = 0, E = 0;
      if (A) for (var k = m.child; k !== null; ) V |= k.lanes | k.childLanes, E |= k.subtreeFlags & 14680064, E |= k.flags & 14680064, k.return = m, k = k.sibling;
      else for (k = m.child; k !== null; ) V |= k.lanes | k.childLanes, E |= k.subtreeFlags, E |= k.flags, k.return = m, k = k.sibling;
      return m.subtreeFlags |= E, m.childLanes = V, A;
    }
    function Ru(m, A, V) {
      var E = A.pendingProps;
      switch (yu(A), A.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Nn(A), null;
        case 1:
          return ba(A.type) && or(), Nn(A), null;
        case 3:
          return E = A.stateNode, hd(), xn(Wr), xn(li), yg(), E.pendingContext && (E.context = E.pendingContext, E.pendingContext = null), (m === null || m.child === null) && (gd(A) ? ka(A) : m === null || m.memoizedState.isDehydrated && (A.flags & 256) === 0 || (A.flags |= 1024, Ol !== null && (Ai(Ol), Ol = null))), $u(m, A), Nn(A), null;
        case 5:
          Gu(A), V = Al(Cd.current);
          var k = A.type;
          if (m !== null && A.stateNode != null) wu(m, A, k, E, V), m.ref !== A.ref && (A.flags |= 512, A.flags |= 2097152);
          else {
            if (!E) {
              if (A.stateNode === null) throw Error(l(166));
              return Nn(A), null;
            }
            if (m = Al(js.current), gd(A)) {
              if (!Wt) throw Error(l(175));
              m = At(A.stateNode, A.type, A.memoizedProps, V, m, A, !ju), A.updateQueue = m, m !== null && ka(A);
            } else {
              var $ = le(k, E, V, m, A);
              Bl($, A, !1, !1), A.stateNode = $, nt($, k, E, V, m) && ka(A);
            }
            A.ref !== null && (A.flags |= 512, A.flags |= 2097152);
          }
          return Nn(A), null;
        case 6:
          if (m && A.stateNode != null) Bo(m, A, m.memoizedProps, E);
          else {
            if (typeof E != "string" && A.stateNode === null) throw Error(l(166));
            if (m = Al(Cd.current), V = Al(js.current), gd(A)) {
              if (!Wt) throw Error(l(176));
              if (m = A.stateNode, E = A.memoizedProps, (V = Gt(m, E, A, !ju)) && (k = Jo, k !== null)) switch ($ = (k.mode & 1) !== 0, k.tag) {
                case 3:
                  tn(k.stateNode.containerInfo, m, E, $);
                  break;
                case 5:
                  Bn(k.type, k.memoizedProps, k.stateNode, m, E, $);
              }
              V && ka(A);
            } else A.stateNode = wt(E, m, V, A);
          }
          return Nn(A), null;
        case 13:
          if (xn(Tr), E = A.memoizedState, Ga && eo !== null && (A.mode & 1) !== 0 && (A.flags & 128) === 0) {
            for (m = eo; m; ) m = Vn(m);
            return Pl(), A.flags |= 98560, A;
          }
          if (E !== null && E.dehydrated !== null) {
            if (E = gd(A), m === null) {
              if (!E) throw Error(l(318));
              if (!Wt) throw Error(l(344));
              if (m = A.memoizedState, m = m !== null ? m.dehydrated : null, !m) throw Error(l(317));
              vn(m, A);
            } else Pl(), (A.flags & 128) === 0 && (A.memoizedState = null), A.flags |= 4;
            return Nn(A), null;
          }
          return Ol !== null && (Ai(Ol), Ol = null), (A.flags & 128) !== 0 ? (A.lanes = V, A) : (E = E !== null, V = !1, m === null ? gd(A) : V = m.memoizedState !== null, E && !V && (A.child.flags |= 8192, (A.mode & 1) !== 0 && (m === null || (Tr.current & 1) !== 0 ? ua === 0 && (ua = 3) : wI())), A.updateQueue !== null && (A.flags |= 4), Nn(A), null);
        case 4:
          return hd(), $u(m, A), m === null && $t(A.stateNode.containerInfo), Nn(A), null;
        case 10:
          return Si(A.type._context), Nn(A), null;
        case 17:
          return ba(A.type) && or(), Nn(A), null;
        case 19:
          if (xn(Tr), k = A.memoizedState, k === null) return Nn(A), null;
          if (E = (A.flags & 128) !== 0, $ = k.rendering, $ === null) if (E) yr(k, !1);
          else {
            if (ua !== 0 || m !== null && (m.flags & 128) !== 0) for (m = A.child; m !== null; ) {
              if ($ = yo(m), $ !== null) {
                for (A.flags |= 128, yr(k, !1), m = $.updateQueue, m !== null && (A.updateQueue = m, A.flags |= 4), A.subtreeFlags = 0, m = V, E = A.child; E !== null; ) V = E, k = m, V.flags &= 14680066, $ = V.alternate, $ === null ? (V.childLanes = 0, V.lanes = k, V.child = null, V.subtreeFlags = 0, V.memoizedProps = null, V.memoizedState = null, V.updateQueue = null, V.dependencies = null, V.stateNode = null) : (V.childLanes = $.childLanes, V.lanes = $.lanes, V.child = $.child, V.subtreeFlags = 0, V.deletions = null, V.memoizedProps = $.memoizedProps, V.memoizedState = $.memoizedState, V.updateQueue = $.updateQueue, V.type = $.type, k = $.dependencies, V.dependencies = k === null ? null : { lanes: k.lanes, firstContext: k.firstContext }), E = E.sibling;
                return un(Tr, Tr.current & 1 | 2), A.child;
              }
              m = m.sibling;
            }
            k.tail !== null && Sr() > Wg && (A.flags |= 128, E = !0, yr(k, !1), A.lanes = 4194304);
          }
          else {
            if (!E) if (m = yo($), m !== null) {
              if (A.flags |= 128, E = !0, m = m.updateQueue, m !== null && (A.updateQueue = m, A.flags |= 4), yr(k, !0), k.tail === null && k.tailMode === "hidden" && !$.alternate && !Ga) return Nn(A), null;
            } else 2 * Sr() - k.renderingStartTime > Wg && V !== 1073741824 && (A.flags |= 128, E = !0, yr(k, !1), A.lanes = 4194304);
            k.isBackwards ? ($.sibling = A.child, A.child = $) : (m = k.last, m !== null ? m.sibling = $ : A.child = $, k.last = $);
          }
          return k.tail !== null ? (A = k.tail, k.rendering = A, k.tail = A.sibling, k.renderingStartTime = Sr(), A.sibling = null, m = Tr.current, un(Tr, E ? m & 1 | 2 : m & 1), A) : (Nn(A), null);
        case 22:
        case 23:
          return Ng(), E = A.memoizedState !== null, m !== null && m.memoizedState !== null !== E && (A.flags |= 8192), E && (A.mode & 1) !== 0 ? (us & 1073741824) !== 0 && (Nn(A), Hn && A.subtreeFlags & 6 && (A.flags |= 8192)) : Nn(A), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(l(156, A.tag));
    }
    var xa = u.ReactCurrentOwner, pi = !1;
    function ea(m, A, V, E) {
      A.child = m === null ? bp(A, null, V, E) : bu(A, m.child, V, E);
    }
    function Ur(m, A, V, E, k) {
      V = V.render;
      var $ = A.ref;
      return ur(A, k), E = pd(m, A, V, E, $, k), V = qu(), m !== null && !pi ? (A.updateQueue = m.updateQueue, A.flags &= -2053, m.lanes &= ~k, Eo(m, A, k)) : (Ga && V && ha(A), A.flags |= 1, ea(m, A, E, k), A.child);
    }
    function ta(m, A, V, E, k) {
      if (m === null) {
        var $ = V.type;
        return typeof $ == "function" && !Xg($) && $.defaultProps === void 0 && V.compare === null && V.defaultProps === void 0 ? (A.tag = 15, A.type = $, er(m, A, $, E, k)) : (m = dC(V.type, null, E, A, A.mode, k), m.ref = A.ref, m.return = A, A.child = m);
      }
      if ($ = m.child, (m.lanes & k) === 0) {
        var ve = $.memoizedProps;
        if (V = V.compare, V = V !== null ? V : Ps, V(ve, E) && m.ref === A.ref) return Eo(m, A, k);
      }
      return A.flags |= 1, m = xl($, E), m.ref = A.ref, m.return = A, A.child = m;
    }
    function er(m, A, V, E, k) {
      if (m !== null && Ps(m.memoizedProps, E) && m.ref === A.ref) if (pi = !1, (m.lanes & k) !== 0) (m.flags & 131072) !== 0 && (pi = !0);
      else return A.lanes = m.lanes, Eo(m, A, k);
      return Rs(m, A, V, E, k);
    }
    function Sa(m, A, V) {
      var E = A.pendingProps, k = E.children, $ = m !== null ? m.memoizedState : null;
      if (E.mode === "hidden") if ((A.mode & 1) === 0) A.memoizedState = { baseLanes: 0, cachePool: null }, un(nc, us), us |= V;
      else if ((V & 1073741824) !== 0) A.memoizedState = { baseLanes: 0, cachePool: null }, E = $ !== null ? $.baseLanes : V, un(nc, us), us |= E;
      else return m = $ !== null ? $.baseLanes | V : V, A.lanes = A.childLanes = 1073741824, A.memoizedState = { baseLanes: m, cachePool: null }, A.updateQueue = null, un(nc, us), us |= m, null;
      else $ !== null ? (E = $.baseLanes | V, A.memoizedState = null) : E = V, un(nc, us), us |= E;
      return ea(m, A, k, V), A.child;
    }
    function io(m, A) {
      var V = A.ref;
      (m === null && V !== null || m !== null && m.ref !== V) && (A.flags |= 512, A.flags |= 2097152);
    }
    function Rs(m, A, V, E, k) {
      var $ = ba(V) ? Xo : li.current;
      return $ = $r(A, $), ur(A, k), V = pd(m, A, V, E, $, k), E = qu(), m !== null && !pi ? (A.updateQueue = m.updateQueue, A.flags &= -2053, m.lanes &= ~k, Eo(m, A, k)) : (Ga && E && ha(A), A.flags |= 1, ea(m, A, V, k), A.child);
    }
    function $s(m, A, V, E, k) {
      if (ba(V)) {
        var $ = !0;
        Xa(A);
      } else $ = !1;
      if (ur(A, k), A.stateNode === null) m !== null && (m.alternate = null, A.alternate = null, A.flags |= 2), vp(A, V, E), uf(A, V, E, k), E = !0;
      else if (m === null) {
        var ve = A.stateNode, Ke = A.memoizedProps;
        ve.props = Ke;
        var Rt = ve.context, In = V.contextType;
        typeof In == "object" && In !== null ? In = nr(In) : (In = ba(V) ? Xo : li.current, In = $r(A, In));
        var $n = V.getDerivedStateFromProps, zi = typeof $n == "function" || typeof ve.getSnapshotBeforeUpdate == "function";
        zi || typeof ve.UNSAFE_componentWillReceiveProps != "function" && typeof ve.componentWillReceiveProps != "function" || (Ke !== E || Rt !== In) && yp(A, ve, E, In), Zi = !1;
        var ci = A.memoizedState;
        ve.state = ci, mg(A, E, ve, k), Rt = A.memoizedState, Ke !== E || ci !== Rt || Wr.current || Zi ? (typeof $n == "function" && (ih(A, V, $n, E), Rt = A.memoizedState), (Ke = Zi || ah(A, V, Ke, E, ci, Rt, In)) ? (zi || typeof ve.UNSAFE_componentWillMount != "function" && typeof ve.componentWillMount != "function" || (typeof ve.componentWillMount == "function" && ve.componentWillMount(), typeof ve.UNSAFE_componentWillMount == "function" && ve.UNSAFE_componentWillMount()), typeof ve.componentDidMount == "function" && (A.flags |= 4194308)) : (typeof ve.componentDidMount == "function" && (A.flags |= 4194308), A.memoizedProps = E, A.memoizedState = Rt), ve.props = E, ve.state = Rt, ve.context = In, E = Ke) : (typeof ve.componentDidMount == "function" && (A.flags |= 4194308), E = !1);
      } else {
        ve = A.stateNode, Ka(m, A), Ke = A.memoizedProps, In = A.type === A.elementType ? Ke : ie(A.type, Ke), ve.props = In, zi = A.pendingProps, ci = ve.context, Rt = V.contextType, typeof Rt == "object" && Rt !== null ? Rt = nr(Rt) : (Rt = ba(V) ? Xo : li.current, Rt = $r(A, Rt));
        var Yi = V.getDerivedStateFromProps;
        ($n = typeof Yi == "function" || typeof ve.getSnapshotBeforeUpdate == "function") || typeof ve.UNSAFE_componentWillReceiveProps != "function" && typeof ve.componentWillReceiveProps != "function" || (Ke !== zi || ci !== Rt) && yp(A, ve, E, Rt), Zi = !1, ci = A.memoizedState, ve.state = ci, mg(A, E, ve, k);
        var wn = A.memoizedState;
        Ke !== zi || ci !== wn || Wr.current || Zi ? (typeof Yi == "function" && (ih(A, V, Yi, E), wn = A.memoizedState), (In = Zi || ah(A, V, In, E, ci, wn, Rt) || !1) ? ($n || typeof ve.UNSAFE_componentWillUpdate != "function" && typeof ve.componentWillUpdate != "function" || (typeof ve.componentWillUpdate == "function" && ve.componentWillUpdate(
          E,
          wn,
          Rt
        ), typeof ve.UNSAFE_componentWillUpdate == "function" && ve.UNSAFE_componentWillUpdate(E, wn, Rt)), typeof ve.componentDidUpdate == "function" && (A.flags |= 4), typeof ve.getSnapshotBeforeUpdate == "function" && (A.flags |= 1024)) : (typeof ve.componentDidUpdate != "function" || Ke === m.memoizedProps && ci === m.memoizedState || (A.flags |= 4), typeof ve.getSnapshotBeforeUpdate != "function" || Ke === m.memoizedProps && ci === m.memoizedState || (A.flags |= 1024), A.memoizedProps = E, A.memoizedState = wn), ve.props = E, ve.state = wn, ve.context = Rt, E = In) : (typeof ve.componentDidUpdate != "function" || Ke === m.memoizedProps && ci === m.memoizedState || (A.flags |= 4), typeof ve.getSnapshotBeforeUpdate != "function" || Ke === m.memoizedProps && ci === m.memoizedState || (A.flags |= 1024), E = !1);
      }
      return Da(m, A, V, E, $, k);
    }
    function Da(m, A, V, E, k, $) {
      io(m, A);
      var ve = (A.flags & 128) !== 0;
      if (!E && !ve) return k && bs(A, V, !1), Eo(m, A, $);
      E = A.stateNode, xa.current = A;
      var Ke = ve && typeof V.getDerivedStateFromError != "function" ? null : E.render();
      return A.flags |= 1, m !== null && ve ? (A.child = bu(A, m.child, null, $), A.child = bu(A, null, Ke, $)) : ea(m, A, Ke, $), A.memoizedState = E.state, k && bs(A, V, !0), A.child;
    }
    function Sl(m) {
      var A = m.stateNode;
      A.pendingContext ? za(m, A.pendingContext, A.pendingContext !== A.context) : A.context && za(m, A.context, !1), vl(m, A.containerInfo);
    }
    function gh(m, A, V, E, k) {
      return Pl(), tC(k), A.flags |= 256, ea(m, A, V, E), A.child;
    }
    var oC = { dehydrated: null, treeContext: null, retryLane: 0 };
    function Xc(m) {
      return { baseLanes: m, cachePool: null };
    }
    function eu(m, A, V) {
      var E = A.pendingProps, k = Tr.current, $ = !1, ve = (A.flags & 128) !== 0, Ke;
      if ((Ke = ve) || (Ke = m !== null && m.memoizedState === null ? !1 : (k & 2) !== 0), Ke ? ($ = !0, A.flags &= -129) : (m === null || m.memoizedState !== null) && (k |= 1), un(Tr, k & 1), m === null)
        return cd(A), m = A.memoizedState, m !== null && (m = m.dehydrated, m !== null) ? ((A.mode & 1) === 0 ? A.lanes = 1 : Et(m) ? A.lanes = 8 : A.lanes = 1073741824, null) : (k = E.children, m = E.fallback, $ ? (E = A.mode, $ = A.child, k = { mode: "hidden", children: k }, (E & 1) === 0 && $ !== null ? ($.childLanes = 0, $.pendingProps = k) : $ = sc(k, E, 0, null), m = iu(m, E, V, null), $.return = A, m.return = A, $.sibling = m, A.child = $, A.child.memoizedState = Xc(V), A.memoizedState = oC, m) : Fo(A, k));
      if (k = m.memoizedState, k !== null) {
        if (Ke = k.dehydrated, Ke !== null) {
          if (ve)
            return A.flags & 256 ? (A.flags &= -257, tu(m, A, V, Error(l(422)))) : A.memoizedState !== null ? (A.child = m.child, A.flags |= 128, null) : ($ = E.fallback, k = A.mode, E = sc({ mode: "visible", children: E.children }, k, 0, null), $ = iu($, k, V, null), $.flags |= 2, E.return = A, $.return = A, E.sibling = $, A.child = E, (A.mode & 1) !== 0 && bu(
              A,
              m.child,
              null,
              V
            ), A.child.memoizedState = Xc(V), A.memoizedState = oC, $);
          if ((A.mode & 1) === 0) A = tu(m, A, V, null);
          else if (Et(Ke)) A = tu(m, A, V, Error(l(419)));
          else if (E = (V & m.childLanes) !== 0, pi || E) {
            if (E = oo, E !== null) {
              switch (V & -V) {
                case 4:
                  $ = 2;
                  break;
                case 16:
                  $ = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  $ = 32;
                  break;
                case 536870912:
                  $ = 268435456;
                  break;
                default:
                  $ = 0;
              }
              E = ($ & (E.suspendedLanes | V)) !== 0 ? 0 : $, E !== 0 && E !== k.retryLane && (k.retryLane = E, ca(m, E, -1));
            }
            wI(), A = tu(m, A, V, Error(l(421)));
          } else rt(Ke) ? (A.flags |= 128, A.child = m.child, A = wd.bind(null, m), gn(Ke, A), A = null) : (V = k.treeContext, Wt && (eo = tt(Ke), Jo = A, Ga = !0, Ol = null, ju = !1, V !== null && (ml[Qs++] = vu, ml[Qs++] = xc, ml[Qs++] = fI, vu = V.id, xc = V.overflow, fI = A)), A = Fo(A, A.pendingProps.children), A.flags |= 4096);
          return A;
        }
        return $ ? (E = xu(m, A, E.children, E.fallback, V), $ = A.child, k = m.child.memoizedState, $.memoizedState = k === null ? Xc(V) : { baseLanes: k.baseLanes | V, cachePool: null }, $.childLanes = m.childLanes & ~V, A.memoizedState = oC, E) : (V = Yc(m, A, E.children, V), A.memoizedState = null, V);
      }
      return $ ? (E = xu(m, A, E.children, E.fallback, V), $ = A.child, k = m.child.memoizedState, $.memoizedState = k === null ? Xc(V) : { baseLanes: k.baseLanes | V, cachePool: null }, $.childLanes = m.childLanes & ~V, A.memoizedState = oC, E) : (V = Yc(m, A, E.children, V), A.memoizedState = null, V);
    }
    function Fo(m, A) {
      return A = sc({ mode: "visible", children: A }, m.mode, 0, null), A.return = m, m.child = A;
    }
    function Yc(m, A, V, E) {
      var k = m.child;
      return m = k.sibling, V = xl(k, { mode: "visible", children: V }), (A.mode & 1) === 0 && (V.lanes = E), V.return = A, V.sibling = null, m !== null && (E = A.deletions, E === null ? (A.deletions = [m], A.flags |= 16) : E.push(m)), A.child = V;
    }
    function xu(m, A, V, E, k) {
      var $ = A.mode;
      m = m.child;
      var ve = m.sibling, Ke = { mode: "hidden", children: V };
      return ($ & 1) === 0 && A.child !== m ? (V = A.child, V.childLanes = 0, V.pendingProps = Ke, A.deletions = null) : (V = xl(m, Ke), V.subtreeFlags = m.subtreeFlags & 14680064), ve !== null ? E = xl(ve, E) : (E = iu(E, $, k, null), E.flags |= 2), E.return = A, V.return = A, V.sibling = E, A.child = V, E;
    }
    function tu(m, A, V, E) {
      return E !== null && tC(E), bu(A, m.child, null, V), m = Fo(A, A.pendingProps.children), m.flags |= 2, A.memoizedState = null, m;
    }
    function xs(m, A, V) {
      m.lanes |= A;
      var E = m.alternate;
      E !== null && (E.lanes |= A), Ui(m.return, A, V);
    }
    function Ua(m, A, V, E, k) {
      var $ = m.memoizedState;
      $ === null ? m.memoizedState = { isBackwards: A, rendering: null, renderingStartTime: 0, last: E, tail: V, tailMode: k } : ($.isBackwards = A, $.rendering = null, $.renderingStartTime = 0, $.last = E, $.tail = V, $.tailMode = k);
    }
    function Wi(m, A, V) {
      var E = A.pendingProps, k = E.revealOrder, $ = E.tail;
      if (ea(m, A, E.children, V), E = Tr.current, (E & 2) !== 0) E = E & 1 | 2, A.flags |= 128;
      else {
        if (m !== null && (m.flags & 128) !== 0) e: for (m = A.child; m !== null; ) {
          if (m.tag === 13) m.memoizedState !== null && xs(m, V, A);
          else if (m.tag === 19) xs(m, V, A);
          else if (m.child !== null) {
            m.child.return = m, m = m.child;
            continue;
          }
          if (m === A) break e;
          for (; m.sibling === null; ) {
            if (m.return === null || m.return === A) break e;
            m = m.return;
          }
          m.sibling.return = m.return, m = m.sibling;
        }
        E &= 1;
      }
      if (un(Tr, E), (A.mode & 1) === 0) A.memoizedState = null;
      else switch (k) {
        case "forwards":
          for (V = A.child, k = null; V !== null; ) m = V.alternate, m !== null && yo(m) === null && (k = V), V = V.sibling;
          V = k, V === null ? (k = A.child, A.child = null) : (k = V.sibling, V.sibling = null), Ua(A, !1, k, V, $);
          break;
        case "backwards":
          for (V = null, k = A.child, A.child = null; k !== null; ) {
            if (m = k.alternate, m !== null && yo(m) === null) {
              A.child = k;
              break;
            }
            m = k.sibling, k.sibling = V, V = k, k = m;
          }
          Ua(A, !0, V, null, $);
          break;
        case "together":
          Ua(A, !1, null, null, void 0);
          break;
        default:
          A.memoizedState = null;
      }
      return A.child;
    }
    function Eo(m, A, V) {
      if (m !== null && (A.dependencies = m.dependencies), ic |= A.lanes, (V & A.childLanes) === 0) return null;
      if (m !== null && A.child !== m.child) throw Error(l(153));
      if (A.child !== null) {
        for (m = A.child, V = xl(m, m.pendingProps), A.child = V, V.return = A; m.sibling !== null; ) m = m.sibling, V = V.sibling = xl(m, m.pendingProps), V.return = A;
        V.sibling = null;
      }
      return A.child;
    }
    function bI(m, A, V) {
      switch (A.tag) {
        case 3:
          Sl(A), Pl();
          break;
        case 5:
          oh(A);
          break;
        case 1:
          ba(A.type) && Xa(A);
          break;
        case 4:
          vl(A, A.stateNode.containerInfo);
          break;
        case 10:
          _n(A, A.type._context, A.memoizedProps.value);
          break;
        case 13:
          var E = A.memoizedState;
          if (E !== null)
            return E.dehydrated !== null ? (un(Tr, Tr.current & 1), A.flags |= 128, null) : (V & A.child.childLanes) !== 0 ? eu(m, A, V) : (un(Tr, Tr.current & 1), m = Eo(m, A, V), m !== null ? m.sibling : null);
          un(Tr, Tr.current & 1);
          break;
        case 19:
          if (E = (V & A.childLanes) !== 0, (m.flags & 128) !== 0) {
            if (E) return Wi(
              m,
              A,
              V
            );
            A.flags |= 128;
          }
          var k = A.memoizedState;
          if (k !== null && (k.rendering = null, k.tail = null, k.lastEffect = null), un(Tr, Tr.current), E) break;
          return null;
        case 22:
        case 23:
          return A.lanes = 0, Sa(m, A, V);
      }
      return Eo(m, A, V);
    }
    function GI(m, A) {
      switch (yu(A), A.tag) {
        case 1:
          return ba(A.type) && or(), m = A.flags, m & 65536 ? (A.flags = m & -65537 | 128, A) : null;
        case 3:
          return hd(), xn(Wr), xn(li), yg(), m = A.flags, (m & 65536) !== 0 && (m & 128) === 0 ? (A.flags = m & -65537 | 128, A) : null;
        case 5:
          return Gu(A), null;
        case 13:
          if (xn(Tr), m = A.memoizedState, m !== null && m.dehydrated !== null) {
            if (A.alternate === null) throw Error(l(340));
            Pl();
          }
          return m = A.flags, m & 65536 ? (A.flags = m & -65537 | 128, A) : null;
        case 19:
          return xn(Tr), null;
        case 4:
          return hd(), null;
        case 10:
          return Si(A.type._context), null;
        case 22:
        case 23:
          return Ng(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var So = !1, na = !1, ec = typeof WeakSet == "function" ? WeakSet : Set, fn = null;
    function Zl(m, A) {
      var V = m.ref;
      if (V !== null) if (typeof V == "function") try {
        V(null);
      } catch (E) {
        gs(m, A, E);
      }
      else V.current = null;
    }
    function Fc(m, A, V) {
      try {
        V();
      } catch (E) {
        gs(m, A, E);
      }
    }
    var dh = !1;
    function Bp(m, A) {
      for (Se(m.containerInfo), fn = A; fn !== null; ) if (m = fn, A = m.child, (m.subtreeFlags & 1028) !== 0 && A !== null) A.return = m, fn = A;
      else for (; fn !== null; ) {
        m = fn;
        try {
          var V = m.alternate;
          if ((m.flags & 1024) !== 0) switch (m.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (V !== null) {
                var E = V.memoizedProps, k = V.memoizedState, $ = m.stateNode, ve = $.getSnapshotBeforeUpdate(m.elementType === m.type ? E : ie(m.type, E), k);
                $.__reactInternalSnapshotBeforeUpdate = ve;
              }
              break;
            case 3:
              Hn && Jt(m.stateNode.containerInfo);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(l(163));
          }
        } catch (Ke) {
          gs(m, m.return, Ke);
        }
        if (A = m.sibling, A !== null) {
          A.return = m.return, fn = A;
          break;
        }
        fn = m.return;
      }
      return V = dh, dh = !1, V;
    }
    function tc(m, A, V) {
      var E = A.updateQueue;
      if (E = E !== null ? E.lastEffect : null, E !== null) {
        var k = E = E.next;
        do {
          if ((k.tag & m) === m) {
            var $ = k.destroy;
            k.destroy = void 0, $ !== void 0 && Fc(A, V, $);
          }
          k = k.next;
        } while (k !== E);
      }
    }
    function To(m, A) {
      if (A = A.updateQueue, A = A !== null ? A.lastEffect : null, A !== null) {
        var V = A = A.next;
        do {
          if ((V.tag & m) === m) {
            var E = V.create;
            V.destroy = E();
          }
          V = V.next;
        } while (V !== A);
      }
    }
    function Za(m) {
      var A = m.ref;
      if (A !== null) {
        var V = m.stateNode;
        switch (m.tag) {
          case 5:
            m = Re(V);
            break;
          default:
            m = V;
        }
        typeof A == "function" ? A(m) : A.current = m;
      }
    }
    function zr(m, A, V) {
      if (Us && typeof Us.onCommitFiberUnmount == "function") try {
        Us.onCommitFiberUnmount(hg, A);
      } catch {
      }
      switch (A.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (m = A.updateQueue, m !== null && (m = m.lastEffect, m !== null)) {
            var E = m = m.next;
            do {
              var k = E, $ = k.destroy;
              k = k.tag, $ !== void 0 && ((k & 2) !== 0 || (k & 4) !== 0) && Fc(A, V, $), E = E.next;
            } while (E !== m);
          }
          break;
        case 1:
          if (Zl(A, V), m = A.stateNode, typeof m.componentWillUnmount == "function") try {
            m.props = A.memoizedProps, m.state = A.memoizedState, m.componentWillUnmount();
          } catch (ve) {
            gs(
              A,
              V,
              ve
            );
          }
          break;
        case 5:
          Zl(A, V);
          break;
        case 4:
          Hn ? Sp(m, A, V) : ge && ge && (A = A.stateNode.containerInfo, V = di(A), Ii(A, V));
      }
    }
    function Ws(m, A, V) {
      for (var E = A; ; ) if (zr(m, E, V), E.child === null || Hn && E.tag === 4) {
        if (E === A) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === A) return;
          E = E.return;
        }
        E.sibling.return = E.return, E = E.sibling;
      } else E.child.return = E, E = E.child;
    }
    function sC(m) {
      var A = m.alternate;
      A !== null && (m.alternate = null, sC(A)), m.child = null, m.deletions = null, m.sibling = null, m.tag === 5 && (A = m.stateNode, A !== null && bn(A)), m.stateNode = null, m.return = null, m.dependencies = null, m.memoizedProps = null, m.memoizedState = null, m.pendingProps = null, m.stateNode = null, m.updateQueue = null;
    }
    function bd(m) {
      return m.tag === 5 || m.tag === 3 || m.tag === 4;
    }
    function wl(m) {
      e: for (; ; ) {
        for (; m.sibling === null; ) {
          if (m.return === null || bd(m.return)) return null;
          m = m.return;
        }
        for (m.sibling.return = m.return, m = m.sibling; m.tag !== 5 && m.tag !== 6 && m.tag !== 18; ) {
          if (m.flags & 2 || m.child === null || m.tag === 4) continue e;
          m.child.return = m, m = m.child;
        }
        if (!(m.flags & 2)) return m.stateNode;
      }
    }
    function ro(m) {
      if (Hn) {
        e: {
          for (var A = m.return; A !== null; ) {
            if (bd(A)) break e;
            A = A.return;
          }
          throw Error(l(160));
        }
        var V = A;
        switch (V.tag) {
          case 5:
            A = V.stateNode, V.flags & 32 && (qe(A), V.flags &= -33), V = wl(m), Ya(m, V, A);
            break;
          case 3:
          case 4:
            A = V.stateNode.containerInfo, V = wl(m), pf(m, V, A);
            break;
          default:
            throw Error(l(161));
        }
      }
    }
    function pf(m, A, V) {
      var E = m.tag;
      if (E === 5 || E === 6) m = m.stateNode, A ? ht(V, m, A) : jn(V, m);
      else if (E !== 4 && (m = m.child, m !== null)) for (pf(m, A, V), m = m.sibling; m !== null; ) pf(m, A, V), m = m.sibling;
    }
    function Ya(m, A, V) {
      var E = m.tag;
      if (E === 5 || E === 6) m = m.stateNode, A ? xt(V, m, A) : an(V, m);
      else if (E !== 4 && (m = m.child, m !== null)) for (Ya(m, A, V), m = m.sibling; m !== null; ) Ya(m, A, V), m = m.sibling;
    }
    function Sp(m, A, V) {
      for (var E = A, k = !1, $, ve; ; ) {
        if (!k) {
          k = E.return;
          e: for (; ; ) {
            if (k === null) throw Error(l(160));
            switch ($ = k.stateNode, k.tag) {
              case 5:
                ve = !1;
                break e;
              case 3:
                $ = $.containerInfo, ve = !0;
                break e;
              case 4:
                $ = $.containerInfo, ve = !0;
                break e;
            }
            k = k.return;
          }
          k = !0;
        }
        if (E.tag === 5 || E.tag === 6) Ws(m, E, V), ve ? we($, E.stateNode) : on($, E.stateNode);
        else if (E.tag === 18) ve ? Ee($, E.stateNode) : De($, E.stateNode);
        else if (E.tag === 4) {
          if (E.child !== null) {
            $ = E.stateNode.containerInfo, ve = !0, E.child.return = E, E = E.child;
            continue;
          }
        } else if (zr(m, E, V), E.child !== null) {
          E.child.return = E, E = E.child;
          continue;
        }
        if (E === A) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === A) return;
          E = E.return, E.tag === 4 && (k = !1);
        }
        E.sibling.return = E.return, E = E.sibling;
      }
    }
    function Wu(m, A) {
      if (Hn) {
        switch (A.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            tc(3, A, A.return), To(3, A), tc(5, A, A.return);
            return;
          case 1:
            return;
          case 5:
            var V = A.stateNode;
            if (V != null) {
              var E = A.memoizedProps;
              m = m !== null ? m.memoizedProps : E;
              var k = A.type, $ = A.updateQueue;
              A.updateQueue = null, $ !== null && vt(V, $, k, m, E, A);
            }
            return;
          case 6:
            if (A.stateNode === null) throw Error(l(162));
            V = A.memoizedProps, Ot(A.stateNode, m !== null ? m.memoizedProps : V, V);
            return;
          case 3:
            Wt && m !== null && m.memoizedState.isDehydrated && Ne(A.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            wg(A);
            return;
          case 19:
            wg(A);
            return;
          case 17:
            return;
        }
        throw Error(l(163));
      }
      switch (A.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          tc(3, A, A.return), To(3, A), tc(5, A, A.return);
          return;
        case 12:
          return;
        case 13:
          wg(A);
          return;
        case 19:
          wg(A);
          return;
        case 3:
          Wt && m !== null && m.memoizedState.isDehydrated && Ne(A.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e: if (ge) {
        switch (A.tag) {
          case 1:
          case 5:
          case 6:
            break e;
          case 3:
          case 4:
            A = A.stateNode, Ii(A.containerInfo, A.pendingChildren);
            break e;
        }
        throw Error(l(163));
      }
    }
    function wg(m) {
      var A = m.updateQueue;
      if (A !== null) {
        m.updateQueue = null;
        var V = m.stateNode;
        V === null && (V = m.stateNode = new ec()), A.forEach(function(E) {
          var k = Hg.bind(null, m, E);
          V.has(E) || (V.add(E), E.then(k, k));
        });
      }
    }
    function Gd(m, A) {
      for (fn = A; fn !== null; ) {
        A = fn;
        var V = A.deletions;
        if (V !== null) for (var E = 0; E < V.length; E++) {
          var k = V[E];
          try {
            var $ = m;
            Hn ? Sp($, k, A) : Ws($, k, A);
            var ve = k.alternate;
            ve !== null && (ve.return = null), k.return = null;
          } catch (ei) {
            gs(k, A, ei);
          }
        }
        if (V = A.child, (A.subtreeFlags & 12854) !== 0 && V !== null) V.return = A, fn = V;
        else for (; fn !== null; ) {
          A = fn;
          try {
            var Ke = A.flags;
            if (Ke & 32 && Hn && qe(A.stateNode), Ke & 512) {
              var Rt = A.alternate;
              if (Rt !== null) {
                var In = Rt.ref;
                In !== null && (typeof In == "function" ? In(null) : In.current = null);
              }
            }
            if (Ke & 8192) switch (A.tag) {
              case 13:
                if (A.memoizedState !== null) {
                  var $n = A.alternate;
                  ($n === null || $n.memoizedState === null) && (uC = Sr());
                }
                break;
              case 22:
                var zi = A.memoizedState !== null, ci = A.alternate, Yi = ci !== null && ci.memoizedState !== null;
                if (V = A, Hn) {
                  e: if (E = V, k = zi, $ = null, Hn) for (var wn = E; ; ) {
                    if (wn.tag === 5) {
                      if ($ === null) {
                        $ = wn;
                        var Oa = wn.stateNode;
                        k ? de(Oa) : je(wn.stateNode, wn.memoizedProps);
                      }
                    } else if (wn.tag === 6) {
                      if ($ === null) {
                        var ga = wn.stateNode;
                        k ? it(ga) : et(ga, wn.memoizedProps);
                      }
                    } else if ((wn.tag !== 22 && wn.tag !== 23 || wn.memoizedState === null || wn === E) && wn.child !== null) {
                      wn.child.return = wn, wn = wn.child;
                      continue;
                    }
                    if (wn === E) break;
                    for (; wn.sibling === null; ) {
                      if (wn.return === null || wn.return === E) break e;
                      $ === wn && ($ = null), wn = wn.return;
                    }
                    $ === wn && ($ = null), wn.sibling.return = wn.return, wn = wn.sibling;
                  }
                }
                if (zi && !Yi && (V.mode & 1) !== 0) {
                  fn = V;
                  for (var ot = V.child; ot !== null; ) {
                    for (V = fn = ot; fn !== null; ) {
                      E = fn;
                      var Fe = E.child;
                      switch (E.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          tc(4, E, E.return);
                          break;
                        case 1:
                          Zl(E, E.return);
                          var bt = E.stateNode;
                          if (typeof bt.componentWillUnmount == "function") {
                            var Sn = E.return;
                            try {
                              bt.props = E.memoizedProps, bt.state = E.memoizedState, bt.componentWillUnmount();
                            } catch (ei) {
                              gs(
                                E,
                                Sn,
                                ei
                              );
                            }
                          }
                          break;
                        case 5:
                          Zl(E, E.return);
                          break;
                        case 22:
                          if (E.memoizedState !== null) {
                            Zo(V);
                            continue;
                          }
                      }
                      Fe !== null ? (Fe.return = E, fn = Fe) : Zo(V);
                    }
                    ot = ot.sibling;
                  }
                }
            }
            switch (Ke & 4102) {
              case 2:
                ro(A), A.flags &= -3;
                break;
              case 6:
                ro(A), A.flags &= -3, Wu(A.alternate, A);
                break;
              case 4096:
                A.flags &= -4097;
                break;
              case 4100:
                A.flags &= -4097, Wu(A.alternate, A);
                break;
              case 4:
                Wu(A.alternate, A);
            }
          } catch (ei) {
            gs(A, A.return, ei);
          }
          if (V = A.sibling, V !== null) {
            V.return = A.return, fn = V;
            break;
          }
          fn = A.return;
        }
      }
    }
    function Ih(m, A, V) {
      fn = m, BI(m);
    }
    function BI(m, A, V) {
      for (var E = (m.mode & 1) !== 0; fn !== null; ) {
        var k = fn, $ = k.child;
        if (k.tag === 22 && E) {
          var ve = k.memoizedState !== null || So;
          if (!ve) {
            var Ke = k.alternate, Rt = Ke !== null && Ke.memoizedState !== null || na;
            Ke = So;
            var In = na;
            if (So = ve, (na = Rt) && !In) for (fn = k; fn !== null; ) ve = fn, Rt = ve.child, ve.tag === 22 && ve.memoizedState !== null ? el(k) : Rt !== null ? (Rt.return = ve, fn = Rt) : el(k);
            for (; $ !== null; ) fn = $, BI($), $ = $.sibling;
            fn = k, So = Ke, na = In;
          }
          Zp(m);
        } else (k.subtreeFlags & 8772) !== 0 && $ !== null ? ($.return = k, fn = $) : Zp(m);
      }
    }
    function Zp(m) {
      for (; fn !== null; ) {
        var A = fn;
        if ((A.flags & 8772) !== 0) {
          var V = A.alternate;
          try {
            if ((A.flags & 8772) !== 0) switch (A.tag) {
              case 0:
              case 11:
              case 15:
                na || To(5, A);
                break;
              case 1:
                var E = A.stateNode;
                if (A.flags & 4 && !na) if (V === null) E.componentDidMount();
                else {
                  var k = A.elementType === A.type ? V.memoizedProps : ie(A.type, V.memoizedProps);
                  E.componentDidUpdate(k, V.memoizedState, E.__reactInternalSnapshotBeforeUpdate);
                }
                var $ = A.updateQueue;
                $ !== null && lf(A, $, E);
                break;
              case 3:
                var ve = A.updateQueue;
                if (ve !== null) {
                  if (V = null, A.child !== null) switch (A.child.tag) {
                    case 5:
                      V = Re(A.child.stateNode);
                      break;
                    case 1:
                      V = A.child.stateNode;
                  }
                  lf(A, ve, V);
                }
                break;
              case 5:
                var Ke = A.stateNode;
                V === null && A.flags & 4 && He(Ke, A.type, A.memoizedProps, A);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (Wt && A.memoizedState === null) {
                  var Rt = A.alternate;
                  if (Rt !== null) {
                    var In = Rt.memoizedState;
                    if (In !== null) {
                      var $n = In.dehydrated;
                      $n !== null && Te($n);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(l(163));
            }
            na || A.flags & 512 && Za(A);
          } catch (zi) {
            gs(A, A.return, zi);
          }
        }
        if (A === m) {
          fn = null;
          break;
        }
        if (V = A.sibling, V !== null) {
          V.return = A.return, fn = V;
          break;
        }
        fn = A.return;
      }
    }
    function Zo(m) {
      for (; fn !== null; ) {
        var A = fn;
        if (A === m) {
          fn = null;
          break;
        }
        var V = A.sibling;
        if (V !== null) {
          V.return = A.return, fn = V;
          break;
        }
        fn = A.return;
      }
    }
    function el(m) {
      for (; fn !== null; ) {
        var A = fn;
        try {
          switch (A.tag) {
            case 0:
            case 11:
            case 15:
              var V = A.return;
              try {
                To(4, A);
              } catch (Rt) {
                gs(A, V, Rt);
              }
              break;
            case 1:
              var E = A.stateNode;
              if (typeof E.componentDidMount == "function") {
                var k = A.return;
                try {
                  E.componentDidMount();
                } catch (Rt) {
                  gs(A, k, Rt);
                }
              }
              var $ = A.return;
              try {
                Za(A);
              } catch (Rt) {
                gs(A, $, Rt);
              }
              break;
            case 5:
              var ve = A.return;
              try {
                Za(A);
              } catch (Rt) {
                gs(A, ve, Rt);
              }
          }
        } catch (Rt) {
          gs(A, A.return, Rt);
        }
        if (A === m) {
          fn = null;
          break;
        }
        var Ke = A.sibling;
        if (Ke !== null) {
          Ke.return = A.return, fn = Ke;
          break;
        }
        fn = A.return;
      }
    }
    var ao = 0, yn = 1, ss = 2, _o = 3, lC = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Vu = Symbol.for;
      ao = Vu("selector.component"), yn = Vu("selector.has_pseudo_class"), ss = Vu("selector.role"), _o = Vu("selector.test_id"), lC = Vu("selector.text");
    }
    function wo(m) {
      var A = Nt(m);
      if (A != null) {
        if (typeof A.memoizedProps["data-testname"] != "string") throw Error(l(364));
        return A;
      }
      if (m = se(m), m === null) throw Error(l(362));
      return m.stateNode.current;
    }
    function Wn(m, A) {
      switch (A.$$typeof) {
        case ao:
          if (m.type === A.value) return !0;
          break;
        case yn:
          e: {
            A = A.value, m = [m, 0];
            for (var V = 0; V < m.length; ) {
              var E = m[V++], k = m[V++], $ = A[k];
              if (E.tag !== 5 || !Bt(E)) {
                for (; $ != null && Wn(E, $); ) k++, $ = A[k];
                if (k === A.length) {
                  A = !0;
                  break e;
                } else for (E = E.child; E !== null; ) m.push(E, k), E = E.sibling;
              }
            }
            A = !1;
          }
          return A;
        case ss:
          if (m.tag === 5 && Mt(m.stateNode, A.value)) return !0;
          break;
        case lC:
          if ((m.tag === 5 || m.tag === 6) && (m = Vt(m), m !== null && 0 <= m.indexOf(A.value))) return !0;
          break;
        case _o:
          if (m.tag === 5 && (m = m.memoizedProps["data-testname"], typeof m == "string" && m.toLowerCase() === A.value.toLowerCase())) return !0;
          break;
        default:
          throw Error(l(365));
      }
      return !1;
    }
    function ls(m) {
      switch (m.$$typeof) {
        case ao:
          return "<" + (L(m.value) || "Unknown") + ">";
        case yn:
          return ":has(" + (ls(m) || "") + ")";
        case ss:
          return '[role="' + m.value + '"]';
        case lC:
          return '"' + m.value + '"';
        case _o:
          return '[data-testname="' + m.value + '"]';
        default:
          throw Error(l(365));
      }
    }
    function tr(m, A) {
      var V = [];
      m = [m, 0];
      for (var E = 0; E < m.length; ) {
        var k = m[E++], $ = m[E++], ve = A[$];
        if (k.tag !== 5 || !Bt(k)) {
          for (; ve != null && Wn(k, ve); ) $++, ve = A[$];
          if ($ === A.length) V.push(k);
          else for (k = k.child; k !== null; ) m.push(k, $), k = k.sibling;
        }
      }
      return V;
    }
    function Rg(m, A) {
      if (!me) throw Error(l(363));
      m = wo(m), m = tr(m, A), A = [], m = Array.from(m);
      for (var V = 0; V < m.length; ) {
        var E = m[V++];
        if (E.tag === 5) Bt(E) || A.push(E.stateNode);
        else for (E = E.child; E !== null; ) m.push(E), E = E.sibling;
      }
      return A;
    }
    var wp = Math.ceil, Ch = u.ReactCurrentDispatcher, Nu = u.ReactCurrentOwner, Vr = u.ReactCurrentBatchConfig, ri = 0, oo = null, ia = null, Wa = 0, us = 0, nc = mi(0), ua = 0, SI = null, ic = 0, nu = 0, ZI = 0, xg = null, Ro = null, uC = 0, Wg = 1 / 0;
    function Bd() {
      Wg = Sr() + 500;
    }
    var cC = !1, pa = null, rc = null, gC = !1, Mu = null, si = 0, Oi = 0, ir = null, Xi = -1, Xr = 0;
    function fr() {
      return (ri & 6) !== 0 ? Sr() : Xi !== -1 ? Xi : Xi = Sr();
    }
    function ac(m) {
      return (m.mode & 1) === 0 ? 1 : (ri & 2) !== 0 && Wa !== 0 ? Wa & -Wa : th.transition !== null ? (Xr === 0 && (m = Pu, Pu <<= 1, (Pu & 4194240) === 0 && (Pu = 64), Xr = m), Xr) : (m = Bi, m !== 0 ? m : ft());
    }
    function ca(m, A, V) {
      if (50 < Oi) throw Oi = 0, ir = null, Error(l(185));
      var E = Vs(m, A);
      return E === null ? null : (Ju(E, A, V), ((ri & 2) === 0 || E !== oo) && (E === oo && ((ri & 2) === 0 && (nu |= A), ua === 4 && br(E, Wa)), jo(E, V), A === 1 && ri === 0 && (m.mode & 1) === 0 && (Bd(), Ul && Os())), E);
    }
    function Vs(m, A) {
      m.lanes |= A;
      var V = m.alternate;
      for (V !== null && (V.lanes |= A), V = m, m = m.return; m !== null; ) m.childLanes |= A, V = m.alternate, V !== null && (V.childLanes |= A), V = m, m = m.return;
      return V.tag === 3 ? V.stateNode : null;
    }
    function jo(m, A) {
      var V = m.callbackNode;
      sf(m, A);
      var E = Cu(m, m === oo ? Wa : 0);
      if (E === 0) V !== null && Lr(V), m.callbackNode = null, m.callbackPriority = 0;
      else if (A = E & -E, m.callbackPriority !== A) {
        if (V != null && Lr(V), A === 1) m.tag === 0 ? pg(xo.bind(null, m)) : fg(xo.bind(null, m)), en ? hn(function() {
          ri === 0 && Os();
        }) : Ra(as, Os), V = null;
        else {
          switch (Qu(E)) {
            case 1:
              V = as;
              break;
            case 4:
              V = Ap;
              break;
            case 16:
              V = sd;
              break;
            case 536870912:
              V = II;
              break;
            default:
              V = sd;
          }
          V = Tc(V, Ht.bind(null, m));
        }
        m.callbackPriority = A, m.callbackNode = V;
      }
    }
    function Ht(m, A) {
      if (Xi = -1, Xr = 0, (ri & 6) !== 0) throw Error(l(327));
      var V = m.callbackNode;
      if (lo() && m.callbackNode !== V) return null;
      var E = Cu(m, m === oo ? Wa : 0);
      if (E === 0) return null;
      if ((E & 30) !== 0 || (E & m.expiredLanes) !== 0 || A) A = Sd(m, E);
      else {
        A = E;
        var k = ri;
        ri |= 2;
        var $ = hh();
        (oo !== m || Wa !== A) && (Bd(), Rl(m, A));
        do
          try {
            Zd();
            break;
          } catch (Ke) {
            Ec(m, Ke);
          }
        while (!0);
        qn(), Ch.current = $, ri = k, ia !== null ? A = 0 : (oo = null, Wa = 0, A = ua);
      }
      if (A !== 0) {
        if (A === 2 && (k = hu(m), k !== 0 && (E = k, A = Fa(m, k))), A === 1) throw V = SI, Rl(m, 0), br(m, E), jo(m, Sr()), V;
        if (A === 6) br(m, E);
        else {
          if (k = m.current.alternate, (E & 30) === 0 && !Vg(k) && (A = Sd(m, E), A === 2 && ($ = hu(m), $ !== 0 && (E = $, A = Fa(m, $))), A === 1)) throw V = SI, Rl(m, 0), br(m, E), jo(m, Sr()), V;
          switch (m.finishedWork = k, m.finishedLanes = E, A) {
            case 0:
            case 1:
              throw Error(l(345));
            case 2:
              ra(m, Ro);
              break;
            case 3:
              if (br(m, E), (E & 130023424) === E && (A = uC + 500 - Sr(), 10 < A)) {
                if (Cu(m, 0) !== 0) break;
                if (k = m.suspendedLanes, (k & E) !== E) {
                  fr(), m.pingedLanes |= m.suspendedLanes & k;
                  break;
                }
                m.timeoutHandle = mt(ra.bind(null, m, Ro), A);
                break;
              }
              ra(m, Ro);
              break;
            case 4:
              if (br(m, E), (E & 4194240) === E) break;
              for (A = m.eventTimes, k = -1; 0 < E; ) {
                var ve = 31 - Ao(E);
                $ = 1 << ve, ve = A[ve], ve > k && (k = ve), E &= ~$;
              }
              if (E = k, E = Sr() - E, E = (120 > E ? 120 : 480 > E ? 480 : 1080 > E ? 1080 : 1920 > E ? 1920 : 3e3 > E ? 3e3 : 4320 > E ? 4320 : 1960 * wp(E / 1960)) - E, 10 < E) {
                m.timeoutHandle = mt(ra.bind(null, m, Ro), E);
                break;
              }
              ra(m, Ro);
              break;
            case 5:
              ra(m, Ro);
              break;
            default:
              throw Error(l(329));
          }
        }
      }
      return jo(m, Sr()), m.callbackNode === V ? Ht.bind(null, m) : null;
    }
    function Fa(m, A) {
      var V = xg;
      return m.current.memoizedState.isDehydrated && (Rl(m, A).flags |= 256), m = Sd(m, A), m !== 2 && (A = Ro, Ro = V, A !== null && Ai(A)), m;
    }
    function Ai(m) {
      Ro === null ? Ro = m : Ro.push.apply(Ro, m);
    }
    function Vg(m) {
      for (var A = m; ; ) {
        if (A.flags & 16384) {
          var V = A.updateQueue;
          if (V !== null && (V = V.stores, V !== null)) for (var E = 0; E < V.length; E++) {
            var k = V[E], $ = k.getSnapshot;
            k = k.value;
            try {
              if (!$a($(), k)) return !1;
            } catch {
              return !1;
            }
          }
        }
        if (V = A.child, A.subtreeFlags & 16384 && V !== null) V.return = A, A = V;
        else {
          if (A === m) break;
          for (; A.sibling === null; ) {
            if (A.return === null || A.return === m) return !0;
            A = A.return;
          }
          A.sibling.return = A.return, A = A.sibling;
        }
      }
      return !0;
    }
    function br(m, A) {
      for (A &= ~ZI, A &= ~nu, m.suspendedLanes |= A, m.pingedLanes &= ~A, m = m.expirationTimes; 0 < A; ) {
        var V = 31 - Ao(A), E = 1 << V;
        m[V] = -1, A &= ~E;
      }
    }
    function xo(m) {
      if ((ri & 6) !== 0) throw Error(l(327));
      lo();
      var A = Cu(m, 0);
      if ((A & 1) === 0) return jo(m, Sr()), null;
      var V = Sd(m, A);
      if (m.tag !== 0 && V === 2) {
        var E = hu(m);
        E !== 0 && (A = E, V = Fa(m, E));
      }
      if (V === 1) throw V = SI, Rl(m, 0), br(m, A), jo(m, Sr()), V;
      if (V === 6) throw Error(l(345));
      return m.finishedWork = m.current.alternate, m.finishedLanes = A, ra(m, Ro), jo(m, Sr()), null;
    }
    function tl(m) {
      Mu !== null && Mu.tag === 0 && (ri & 6) === 0 && lo();
      var A = ri;
      ri |= 1;
      var V = Vr.transition, E = Bi;
      try {
        if (Vr.transition = null, Bi = 1, m) return m();
      } finally {
        Bi = E, Vr.transition = V, ri = A, (ri & 6) === 0 && Os();
      }
    }
    function Ng() {
      us = nc.current, xn(nc);
    }
    function Rl(m, A) {
      m.finishedWork = null, m.finishedLanes = 0;
      var V = m.timeoutHandle;
      if (V !== mn && (m.timeoutHandle = mn, Dt(V)), ia !== null) for (V = ia.return; V !== null; ) {
        var E = V;
        switch (yu(E), E.tag) {
          case 1:
            E = E.type.childContextTypes, E != null && or();
            break;
          case 3:
            hd(), xn(Wr), xn(li), yg();
            break;
          case 5:
            Gu(E);
            break;
          case 4:
            hd();
            break;
          case 13:
            xn(Tr);
            break;
          case 19:
            xn(Tr);
            break;
          case 10:
            Si(E.type._context);
            break;
          case 22:
          case 23:
            Ng();
        }
        V = V.return;
      }
      if (oo = m, ia = m = xl(m.current, null), Wa = us = A, ua = 0, SI = null, ZI = nu = ic = 0, Ro = xg = null, $i !== null) {
        for (A = 0; A < $i.length; A++) if (V = $i[A], E = V.interleaved, E !== null) {
          V.interleaved = null;
          var k = E.next, $ = V.pending;
          if ($ !== null) {
            var ve = $.next;
            $.next = k, E.next = ve;
          }
          V.pending = E;
        }
        $i = null;
      }
      return m;
    }
    function Ec(m, A) {
      do {
        var V = ia;
        try {
          if (qn(), os.current = Su, yl) {
            for (var E = Hr.memoizedState; E !== null; ) {
              var k = E.queue;
              k !== null && (k.pending = null), E = E.next;
            }
            yl = !1;
          }
          if (Qo = 0, bo = fa = Hr = null, Ql = !1, Zs = 0, Nu.current = null, V === null || V.return === null) {
            ua = 1, SI = A, ia = null;
            break;
          }
          e: {
            var $ = m, ve = V.return, Ke = V, Rt = A;
            if (A = Wa, Ke.flags |= 32768, Rt !== null && typeof Rt == "object" && typeof Rt.then == "function") {
              var In = Rt, $n = Ke, zi = $n.tag;
              if (($n.mode & 1) === 0 && (zi === 0 || zi === 11 || zi === 15)) {
                var ci = $n.alternate;
                ci ? ($n.updateQueue = ci.updateQueue, $n.memoizedState = ci.memoizedState, $n.lanes = ci.lanes) : ($n.updateQueue = null, $n.memoizedState = null);
              }
              var Yi = yI(ve);
              if (Yi !== null) {
                Yi.flags &= -257, Zg(Yi, ve, Ke, $, A), Yi.mode & 1 && Gl($, In, A), A = Yi, Rt = In;
                var wn = A.updateQueue;
                if (wn === null) {
                  var Oa = /* @__PURE__ */ new Set();
                  Oa.add(Rt), A.updateQueue = Oa;
                } else wn.add(Rt);
                break e;
              } else {
                if ((A & 1) === 0) {
                  Gl($, In, A), wI();
                  break e;
                }
                Rt = Error(l(426));
              }
            } else if (Ga && Ke.mode & 1) {
              var ga = yI(ve);
              if (ga !== null) {
                (ga.flags & 65536) === 0 && (ga.flags |= 256), Zg(ga, ve, Ke, $, A), tC(Rt);
                break e;
              }
            }
            $ = Rt, ua !== 4 && (ua = 2), xg === null ? xg = [$] : xg.push($), Rt = aC(Rt, Ke), Ke = ve;
            do {
              switch (Ke.tag) {
                case 3:
                  Ke.flags |= 65536, A &= -A, Ke.lanes |= A;
                  var ot = Zu(Ke, Rt, A);
                  ud(Ke, ot);
                  break e;
                case 1:
                  $ = Rt;
                  var Fe = Ke.type, bt = Ke.stateNode;
                  if ((Ke.flags & 128) === 0 && (typeof Fe.getDerivedStateFromError == "function" || bt !== null && typeof bt.componentDidCatch == "function" && (rc === null || !rc.has(bt)))) {
                    Ke.flags |= 65536, A &= -A, Ke.lanes |= A;
                    var Sn = Sg(Ke, $, A);
                    ud(Ke, Sn);
                    break e;
                  }
              }
              Ke = Ke.return;
            } while (Ke !== null);
          }
          ph(V);
        } catch (ei) {
          A = ei, ia === V && V !== null && (ia = V = V.return);
          continue;
        }
        break;
      } while (!0);
    }
    function hh() {
      var m = Ch.current;
      return Ch.current = Su, m === null ? Su : m;
    }
    function wI() {
      (ua === 0 || ua === 3 || ua === 2) && (ua = 4), oo === null || (ic & 268435455) === 0 && (nu & 268435455) === 0 || br(oo, Wa);
    }
    function Sd(m, A) {
      var V = ri;
      ri |= 2;
      var E = hh();
      oo === m && Wa === A || Rl(m, A);
      do
        try {
          nl();
          break;
        } catch (k) {
          Ec(m, k);
        }
      while (!0);
      if (qn(), ri = V, Ch.current = E, ia !== null) throw Error(l(261));
      return oo = null, Wa = 0, ua;
    }
    function nl() {
      for (; ia !== null; ) fh(ia);
    }
    function Zd() {
      for (; ia !== null && !Ds(); ) fh(ia);
    }
    function fh(m) {
      var A = Hu(m.alternate, m, us);
      m.memoizedProps = m.pendingProps, A === null ? ph(m) : ia = A, Nu.current = null;
    }
    function ph(m) {
      var A = m;
      do {
        var V = A.alternate;
        if (m = A.return, (A.flags & 32768) === 0) {
          if (V = Ru(V, A, us), V !== null) {
            ia = V;
            return;
          }
        } else {
          if (V = GI(V, A), V !== null) {
            V.flags &= 32767, ia = V;
            return;
          }
          if (m !== null) m.flags |= 32768, m.subtreeFlags = 0, m.deletions = null;
          else {
            ua = 6, ia = null;
            return;
          }
        }
        if (A = A.sibling, A !== null) {
          ia = A;
          return;
        }
        ia = A = m;
      } while (A !== null);
      ua === 0 && (ua = 5);
    }
    function ra(m, A) {
      var V = Bi, E = Vr.transition;
      try {
        Vr.transition = null, Bi = 1, so(m, A, V);
      } finally {
        Vr.transition = E, Bi = V;
      }
      return null;
    }
    function so(m, A, V) {
      do
        lo();
      while (Mu !== null);
      if ((ri & 6) !== 0) throw Error(l(327));
      var E = m.finishedWork, k = m.finishedLanes;
      if (E === null) return null;
      if (m.finishedWork = null, m.finishedLanes = 0, E === m.current) throw Error(l(177));
      m.callbackNode = null, m.callbackPriority = 0;
      var $ = E.lanes | E.childLanes;
      if (Po(m, $), m === oo && (ia = oo = null, Wa = 0), (E.subtreeFlags & 2064) === 0 && (E.flags & 2064) === 0 || gC || (gC = !0, Tc(sd, function() {
        return lo(), null;
      })), $ = (E.flags & 15990) !== 0, (E.subtreeFlags & 15990) !== 0 || $) {
        $ = Vr.transition, Vr.transition = null;
        var ve = Bi;
        Bi = 1;
        var Ke = ri;
        ri |= 4, Nu.current = null, Bp(m, E), Gd(m, E), Be(m.containerInfo), m.current = E, Ih(E), fu(), ri = Ke, Bi = ve, Vr.transition = $;
      } else m.current = E;
      if (gC && (gC = !1, Mu = m, si = k), $ = m.pendingLanes, $ === 0 && (rc = null), CI(E.stateNode), jo(m, Sr()), A !== null) for (V = m.onRecoverableError, E = 0; E < A.length; E++) V(A[E]);
      if (cC) throw cC = !1, m = pa, pa = null, m;
      return (si & 1) !== 0 && m.tag !== 0 && lo(), $ = m.pendingLanes, ($ & 1) !== 0 ? m === ir ? Oi++ : (Oi = 0, ir = m) : Oi = 0, Os(), null;
    }
    function lo() {
      if (Mu !== null) {
        var m = Qu(si), A = Vr.transition, V = Bi;
        try {
          if (Vr.transition = null, Bi = 16 > m ? 16 : m, Mu === null) var E = !1;
          else {
            if (m = Mu, Mu = null, si = 0, (ri & 6) !== 0) throw Error(l(331));
            var k = ri;
            for (ri |= 4, fn = m.current; fn !== null; ) {
              var $ = fn, ve = $.child;
              if ((fn.flags & 16) !== 0) {
                var Ke = $.deletions;
                if (Ke !== null) {
                  for (var Rt = 0; Rt < Ke.length; Rt++) {
                    var In = Ke[Rt];
                    for (fn = In; fn !== null; ) {
                      var $n = fn;
                      switch ($n.tag) {
                        case 0:
                        case 11:
                        case 15:
                          tc(8, $n, $);
                      }
                      var zi = $n.child;
                      if (zi !== null) zi.return = $n, fn = zi;
                      else for (; fn !== null; ) {
                        $n = fn;
                        var ci = $n.sibling, Yi = $n.return;
                        if (sC($n), $n === In) {
                          fn = null;
                          break;
                        }
                        if (ci !== null) {
                          ci.return = Yi, fn = ci;
                          break;
                        }
                        fn = Yi;
                      }
                    }
                  }
                  var wn = $.alternate;
                  if (wn !== null) {
                    var Oa = wn.child;
                    if (Oa !== null) {
                      wn.child = null;
                      do {
                        var ga = Oa.sibling;
                        Oa.sibling = null, Oa = ga;
                      } while (Oa !== null);
                    }
                  }
                  fn = $;
                }
              }
              if (($.subtreeFlags & 2064) !== 0 && ve !== null) ve.return = $, fn = ve;
              else e: for (; fn !== null; ) {
                if ($ = fn, ($.flags & 2048) !== 0) switch ($.tag) {
                  case 0:
                  case 11:
                  case 15:
                    tc(9, $, $.return);
                }
                var ot = $.sibling;
                if (ot !== null) {
                  ot.return = $.return, fn = ot;
                  break e;
                }
                fn = $.return;
              }
            }
            var Fe = m.current;
            for (fn = Fe; fn !== null; ) {
              ve = fn;
              var bt = ve.child;
              if ((ve.subtreeFlags & 2064) !== 0 && bt !== null) bt.return = ve, fn = bt;
              else e: for (ve = Fe; fn !== null; ) {
                if (Ke = fn, (Ke.flags & 2048) !== 0) try {
                  switch (Ke.tag) {
                    case 0:
                    case 11:
                    case 15:
                      To(9, Ke);
                  }
                } catch (ei) {
                  gs(Ke, Ke.return, ei);
                }
                if (Ke === ve) {
                  fn = null;
                  break e;
                }
                var Sn = Ke.sibling;
                if (Sn !== null) {
                  Sn.return = Ke.return, fn = Sn;
                  break e;
                }
                fn = Ke.return;
              }
            }
            if (ri = k, Os(), Us && typeof Us.onPostCommitFiberRoot == "function") try {
              Us.onPostCommitFiberRoot(hg, m);
            } catch {
            }
            E = !0;
          }
          return E;
        } finally {
          Bi = V, Vr.transition = A;
        }
      }
      return !1;
    }
    function cs(m, A, V) {
      A = aC(V, A), A = Zu(m, A, 1), mu(m, A), A = fr(), m = Vs(m, 1), m !== null && (Ju(m, 1, A), jo(m, A));
    }
    function gs(m, A, V) {
      if (m.tag === 3) cs(m, m, V);
      else for (; A !== null; ) {
        if (A.tag === 3) {
          cs(A, m, V);
          break;
        } else if (A.tag === 1) {
          var E = A.stateNode;
          if (typeof A.type.getDerivedStateFromError == "function" || typeof E.componentDidCatch == "function" && (rc === null || !rc.has(E))) {
            m = aC(V, m), m = Sg(A, m, 1), mu(A, m), m = fr(), A = Vs(A, 1), A !== null && (Ju(A, 1, m), jo(A, m));
            break;
          }
        }
        A = A.return;
      }
    }
    function oc(m, A, V) {
      var E = m.pingCache;
      E !== null && E.delete(A), A = fr(), m.pingedLanes |= m.suspendedLanes & V, oo === m && (Wa & V) === V && (ua === 4 || ua === 3 && (Wa & 130023424) === Wa && 500 > Sr() - uC ? Rl(m, 0) : ZI |= V), jo(m, A);
    }
    function Mg(m, A) {
      A === 0 && ((m.mode & 1) === 0 ? A = 1 : (A = sr, sr <<= 1, (sr & 130023424) === 0 && (sr = 4194304)));
      var V = fr();
      m = Vs(m, A), m !== null && (Ju(m, A, V), jo(m, V));
    }
    function wd(m) {
      var A = m.memoizedState, V = 0;
      A !== null && (V = A.retryLane), Mg(m, V);
    }
    function Hg(m, A) {
      var V = 0;
      switch (m.tag) {
        case 13:
          var E = m.stateNode, k = m.memoizedState;
          k !== null && (V = k.retryLane);
          break;
        case 19:
          E = m.stateNode;
          break;
        default:
          throw Error(l(314));
      }
      E !== null && E.delete(A), Mg(m, V);
    }
    var Hu;
    Hu = function(m, A, V) {
      if (m !== null) if (m.memoizedProps !== A.pendingProps || Wr.current) pi = !0;
      else {
        if ((m.lanes & V) === 0 && (A.flags & 128) === 0) return pi = !1, bI(m, A, V);
        pi = (m.flags & 131072) !== 0;
      }
      else pi = !1, Ga && (A.flags & 1048576) !== 0 && Wc(A, $I, A.index);
      switch (A.lanes = 0, A.tag) {
        case 2:
          var E = A.type;
          m !== null && (m.alternate = null, A.alternate = null, A.flags |= 2), m = A.pendingProps;
          var k = $r(A, li.current);
          ur(A, V), k = pd(null, A, E, m, k, V);
          var $ = qu();
          return A.flags |= 1, typeof k == "object" && k !== null && typeof k.render == "function" && k.$$typeof === void 0 ? (A.tag = 1, A.memoizedState = null, A.updateQueue = null, ba(E) ? ($ = !0, Xa(A)) : $ = !1, A.memoizedState = k.state !== null && k.state !== void 0 ? k.state : null, kr(A), k.updater = rh, A.stateNode = k, k._reactInternals = A, uf(A, E, m, V), A = Da(null, A, E, !0, $, V)) : (A.tag = 0, Ga && $ && ha(A), ea(null, A, k, V), A = A.child), A;
        case 16:
          E = A.elementType;
          e: {
            switch (m !== null && (m.alternate = null, A.alternate = null, A.flags |= 2), m = A.pendingProps, k = E._init, E = k(E._payload), A.type = E, k = A.tag = Rp(E), m = ie(E, m), k) {
              case 0:
                A = Rs(null, A, E, m, V);
                break e;
              case 1:
                A = $s(
                  null,
                  A,
                  E,
                  m,
                  V
                );
                break e;
              case 11:
                A = Ur(null, A, E, m, V);
                break e;
              case 14:
                A = ta(null, A, E, ie(E.type, m), V);
                break e;
            }
            throw Error(l(306, E, ""));
          }
          return A;
        case 0:
          return E = A.type, k = A.pendingProps, k = A.elementType === E ? k : ie(E, k), Rs(m, A, E, k, V);
        case 1:
          return E = A.type, k = A.pendingProps, k = A.elementType === E ? k : ie(E, k), $s(m, A, E, k, V);
        case 3:
          e: {
            if (Sl(A), m === null) throw Error(l(387));
            E = A.pendingProps, $ = A.memoizedState, k = $.element, Ka(m, A), mg(A, E, null, V);
            var ve = A.memoizedState;
            if (E = ve.element, Wt && $.isDehydrated) if ($ = {
              element: E,
              isDehydrated: !1,
              cache: ve.cache,
              transitions: ve.transitions
            }, A.updateQueue.baseState = $, A.memoizedState = $, A.flags & 256) {
              k = Error(l(423)), A = gh(m, A, E, V, k);
              break e;
            } else if (E !== k) {
              k = Error(l(424)), A = gh(m, A, E, V, k);
              break e;
            } else for (Wt && (eo = Ie(A.stateNode.containerInfo), Jo = A, Ga = !0, Ol = null, ju = !1), V = bp(A, null, E, V), A.child = V; V; ) V.flags = V.flags & -3 | 4096, V = V.sibling;
            else {
              if (Pl(), E === k) {
                A = Eo(m, A, V);
                break e;
              }
              ea(m, A, E, V);
            }
            A = A.child;
          }
          return A;
        case 5:
          return oh(A), m === null && cd(A), E = A.type, k = A.pendingProps, $ = m !== null ? m.memoizedProps : null, ve = k.children, Je(E, k) ? ve = null : $ !== null && Je(E, $) && (A.flags |= 32), io(m, A), ea(m, A, ve, V), A.child;
        case 6:
          return m === null && cd(A), null;
        case 13:
          return eu(m, A, V);
        case 4:
          return vl(A, A.stateNode.containerInfo), E = A.pendingProps, m === null ? A.child = bu(A, null, E, V) : ea(m, A, E, V), A.child;
        case 11:
          return E = A.type, k = A.pendingProps, k = A.elementType === E ? k : ie(E, k), Ur(m, A, E, k, V);
        case 7:
          return ea(m, A, A.pendingProps, V), A.child;
        case 8:
          return ea(m, A, A.pendingProps.children, V), A.child;
        case 12:
          return ea(m, A, A.pendingProps.children, V), A.child;
        case 10:
          e: {
            if (E = A.type._context, k = A.pendingProps, $ = A.memoizedProps, ve = k.value, _n(A, E, ve), $ !== null) if ($a($.value, ve)) {
              if ($.children === k.children && !Wr.current) {
                A = Eo(m, A, V);
                break e;
              }
            } else for ($ = A.child, $ !== null && ($.return = A); $ !== null; ) {
              var Ke = $.dependencies;
              if (Ke !== null) {
                ve = $.child;
                for (var Rt = Ke.firstContext; Rt !== null; ) {
                  if (Rt.context === E) {
                    if ($.tag === 1) {
                      Rt = Js(-1, V & -V), Rt.tag = 2;
                      var In = $.updateQueue;
                      if (In !== null) {
                        In = In.shared;
                        var $n = In.pending;
                        $n === null ? Rt.next = Rt : (Rt.next = $n.next, $n.next = Rt), In.pending = Rt;
                      }
                    }
                    $.lanes |= V, Rt = $.alternate, Rt !== null && (Rt.lanes |= V), Ui($.return, V, A), Ke.lanes |= V;
                    break;
                  }
                  Rt = Rt.next;
                }
              } else if ($.tag === 10) ve = $.type === A.type ? null : $.child;
              else if ($.tag === 18) {
                if (ve = $.return, ve === null) throw Error(l(341));
                ve.lanes |= V, Ke = ve.alternate, Ke !== null && (Ke.lanes |= V), Ui(ve, V, A), ve = $.sibling;
              } else ve = $.child;
              if (ve !== null) ve.return = $;
              else for (ve = $; ve !== null; ) {
                if (ve === A) {
                  ve = null;
                  break;
                }
                if ($ = ve.sibling, $ !== null) {
                  $.return = ve.return, ve = $;
                  break;
                }
                ve = ve.return;
              }
              $ = ve;
            }
            ea(m, A, k.children, V), A = A.child;
          }
          return A;
        case 9:
          return k = A.type, E = A.pendingProps.children, ur(A, V), k = nr(k), E = E(k), A.flags |= 1, ea(m, A, E, V), A.child;
        case 14:
          return E = A.type, k = ie(E, A.pendingProps), k = ie(E.type, k), ta(m, A, E, k, V);
        case 15:
          return er(m, A, A.type, A.pendingProps, V);
        case 17:
          return E = A.type, k = A.pendingProps, k = A.elementType === E ? k : ie(E, k), m !== null && (m.alternate = null, A.alternate = null, A.flags |= 2), A.tag = 1, ba(E) ? (m = !0, Xa(A)) : m = !1, ur(A, V), vp(A, E, k), uf(A, E, k, V), Da(null, A, E, !0, m, V);
        case 19:
          return Wi(m, A, V);
        case 22:
          return Sa(m, A, V);
      }
      throw Error(l(156, A.tag));
    };
    function Tc(m, A) {
      return Ra(m, A);
    }
    function Rd(m, A, V, E) {
      this.tag = m, this.key = V, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = A, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = E, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function uo(m, A, V, E) {
      return new Rd(m, A, V, E);
    }
    function Xg(m) {
      return m = m.prototype, !(!m || !m.isReactComponent);
    }
    function Rp(m) {
      if (typeof m == "function") return Xg(m) ? 1 : 0;
      if (m != null) {
        if (m = m.$$typeof, m === W) return 11;
        if (m === Y) return 14;
      }
      return 2;
    }
    function xl(m, A) {
      var V = m.alternate;
      return V === null ? (V = uo(m.tag, A, m.key, m.mode), V.elementType = m.elementType, V.type = m.type, V.stateNode = m.stateNode, V.alternate = m, m.alternate = V) : (V.pendingProps = A, V.type = m.type, V.flags = 0, V.subtreeFlags = 0, V.deletions = null), V.flags = m.flags & 14680064, V.childLanes = m.childLanes, V.lanes = m.lanes, V.child = m.child, V.memoizedProps = m.memoizedProps, V.memoizedState = m.memoizedState, V.updateQueue = m.updateQueue, A = m.dependencies, V.dependencies = A === null ? null : { lanes: A.lanes, firstContext: A.firstContext }, V.sibling = m.sibling, V.index = m.index, V.ref = m.ref, V;
    }
    function dC(m, A, V, E, k, $) {
      var ve = 2;
      if (E = m, typeof m == "function") Xg(m) && (ve = 1);
      else if (typeof m == "string") ve = 5;
      else e: switch (m) {
        case f:
          return iu(V.children, k, $, A);
        case v:
          ve = 8, k |= 8;
          break;
        case b:
          return m = uo(12, V, A, k | 2), m.elementType = b, m.lanes = $, m;
        case x:
          return m = uo(13, V, A, k), m.elementType = x, m.lanes = $, m;
        case N:
          return m = uo(19, V, A, k), m.elementType = N, m.lanes = $, m;
        case T:
          return sc(V, k, $, A);
        default:
          if (typeof m == "object" && m !== null) switch (m.$$typeof) {
            case S:
              ve = 10;
              break e;
            case R:
              ve = 9;
              break e;
            case W:
              ve = 11;
              break e;
            case Y:
              ve = 14;
              break e;
            case F:
              ve = 16, E = null;
              break e;
          }
          throw Error(l(130, m == null ? m : typeof m, ""));
      }
      return A = uo(ve, V, A, k), A.elementType = m, A.type = E, A.lanes = $, A;
    }
    function iu(m, A, V, E) {
      return m = uo(7, m, E, A), m.lanes = V, m;
    }
    function sc(m, A, V, E) {
      return m = uo(22, m, E, A), m.elementType = T, m.lanes = V, m.stateNode = {}, m;
    }
    function il(m, A, V) {
      return m = uo(6, m, null, A), m.lanes = V, m;
    }
    function Wl(m, A, V) {
      return A = uo(4, m.children !== null ? m.children : [], m.key, A), A.lanes = V, A.stateNode = { containerInfo: m.containerInfo, pendingChildren: null, implementation: m.implementation }, A;
    }
    function Nr(m, A, V, E, k) {
      this.tag = A, this.containerInfo = m, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = mn, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = xi(0), this.expirationTimes = xi(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = xi(0), this.identifierPrefix = E, this.onRecoverableError = k, Wt && (this.mutableSourceEagerHydrationData = null);
    }
    function Yg(m, A, V, E, k, $, ve, Ke, Rt) {
      return m = new Nr(m, A, V, Ke, Rt), A === 1 ? (A = 1, $ === !0 && (A |= 8)) : A = 0, $ = uo(3, null, null, A), m.current = $, $.stateNode = m, $.memoizedState = { element: E, isDehydrated: V, cache: null, transitions: null }, kr($), m;
    }
    function xd(m) {
      if (!m) return Xn;
      m = m._reactInternals;
      e: {
        if (J(m) !== m || m.tag !== 1) throw Error(l(170));
        var A = m;
        do {
          switch (A.tag) {
            case 3:
              A = A.stateNode.context;
              break e;
            case 1:
              if (ba(A.type)) {
                A = A.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          A = A.return;
        } while (A !== null);
        throw Error(l(171));
      }
      if (m.tag === 1) {
        var V = m.type;
        if (ba(V)) return pl(m, V, A);
      }
      return A;
    }
    function lc(m) {
      var A = m._reactInternals;
      if (A === void 0)
        throw typeof m.render == "function" ? Error(l(188)) : (m = Object.keys(m).join(","), Error(l(268, m)));
      return m = he(A), m === null ? null : m.stateNode;
    }
    function ds(m, A) {
      if (m = m.memoizedState, m !== null && m.dehydrated !== null) {
        var V = m.retryLane;
        m.retryLane = V !== 0 && V < A ? V : A;
      }
    }
    function Wd(m, A) {
      ds(m, A), (m = m.alternate) && ds(m, A);
    }
    function RI(m) {
      return m = he(m), m === null ? null : m.stateNode;
    }
    function xp() {
      return null;
    }
    return t.attemptContinuousHydration = function(m) {
      if (m.tag === 13) {
        var A = fr();
        ca(m, 134217728, A), Wd(m, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(m) {
      if (m.tag === 13) {
        var A = fr(), V = ac(m);
        ca(m, V, A), Wd(m, V);
      }
    }, t.attemptSynchronousHydration = function(m) {
      switch (m.tag) {
        case 3:
          var A = m.stateNode;
          if (A.current.memoizedState.isDehydrated) {
            var V = Yo(A.pendingLanes);
            V !== 0 && (Gs(A, V | 1), jo(A, Sr()), (ri & 6) === 0 && (Bd(), Os()));
          }
          break;
        case 13:
          var E = fr();
          tl(function() {
            return ca(m, 1, E);
          }), Wd(m, 1);
      }
    }, t.batchedUpdates = function(m, A) {
      var V = ri;
      ri |= 1;
      try {
        return m(A);
      } finally {
        ri = V, ri === 0 && (Bd(), Ul && Os());
      }
    }, t.createComponentSelector = function(m) {
      return { $$typeof: ao, value: m };
    }, t.createContainer = function(m, A, V, E, k, $, ve) {
      return Yg(m, A, !1, null, V, E, k, $, ve);
    }, t.createHasPseudoClassSelector = function(m) {
      return { $$typeof: yn, value: m };
    }, t.createHydrationContainer = function(m, A, V, E, k, $, ve, Ke, Rt) {
      return m = Yg(V, E, !0, m, k, $, ve, Ke, Rt), m.context = xd(null), V = m.current, E = fr(), k = ac(V), $ = Js(E, k), $.callback = A ?? null, mu(V, $), m.current.lanes = k, Ju(m, k, E), jo(m, E), m;
    }, t.createPortal = function(m, A, V) {
      var E = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: C, key: E == null ? null : "" + E, children: m, containerInfo: A, implementation: V };
    }, t.createRoleSelector = function(m) {
      return { $$typeof: ss, value: m };
    }, t.createTestNameSelector = function(m) {
      return { $$typeof: _o, value: m };
    }, t.createTextSelector = function(m) {
      return { $$typeof: lC, value: m };
    }, t.deferredUpdates = function(m) {
      var A = Bi, V = Vr.transition;
      try {
        return Vr.transition = null, Bi = 16, m();
      } finally {
        Bi = A, Vr.transition = V;
      }
    }, t.discreteUpdates = function(m, A, V, E, k) {
      var $ = Bi, ve = Vr.transition;
      try {
        return Vr.transition = null, Bi = 1, m(A, V, E, k);
      } finally {
        Bi = $, Vr.transition = ve, ri === 0 && Bd();
      }
    }, t.findAllNodes = Rg, t.findBoundingRects = function(m, A) {
      if (!me) throw Error(l(363));
      A = Rg(m, A), m = [];
      for (var V = 0; V < A.length; V++) m.push($e(A[V]));
      for (A = m.length - 1; 0 < A; A--) {
        V = m[A];
        for (var E = V.x, k = E + V.width, $ = V.y, ve = $ + V.height, Ke = A - 1; 0 <= Ke; Ke--) if (A !== Ke) {
          var Rt = m[Ke], In = Rt.x, $n = In + Rt.width, zi = Rt.y, ci = zi + Rt.height;
          if (E >= In && $ >= zi && k <= $n && ve <= ci) {
            m.splice(A, 1);
            break;
          } else if (E !== In || V.width !== Rt.width || ci < $ || zi > ve) {
            if (!($ !== zi || V.height !== Rt.height || $n < E || In > k)) {
              In > E && (Rt.width += In - E, Rt.x = E), $n < k && (Rt.width = k - In), m.splice(A, 1);
              break;
            }
          } else {
            zi > $ && (Rt.height += zi - $, Rt.y = $), ci < ve && (Rt.height = ve - zi), m.splice(A, 1);
            break;
          }
        }
      }
      return m;
    }, t.findHostInstance = lc, t.findHostInstanceWithNoPortals = function(m) {
      return m = ne(m), m = m !== null ? Ae(m) : null, m === null ? null : m.stateNode;
    }, t.findHostInstanceWithWarning = function(m) {
      return lc(m);
    }, t.flushControlled = function(m) {
      var A = ri;
      ri |= 1;
      var V = Vr.transition, E = Bi;
      try {
        Vr.transition = null, Bi = 1, m();
      } finally {
        Bi = E, Vr.transition = V, ri = A, ri === 0 && (Bd(), Os());
      }
    }, t.flushPassiveEffects = lo, t.flushSync = tl, t.focusWithin = function(m, A) {
      if (!me) throw Error(l(363));
      for (m = wo(m), A = tr(m, A), A = Array.from(A), m = 0; m < A.length; ) {
        var V = A[m++];
        if (!Bt(V)) {
          if (V.tag === 5 && Gn(V.stateNode)) return !0;
          for (V = V.child; V !== null; ) A.push(V), V = V.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return Bi;
    }, t.getFindAllNodesFailureDescription = function(m, A) {
      if (!me) throw Error(l(363));
      var V = 0, E = [];
      m = [wo(m), 0];
      for (var k = 0; k < m.length; ) {
        var $ = m[k++], ve = m[k++], Ke = A[ve];
        if (($.tag !== 5 || !Bt($)) && (Wn($, Ke) && (E.push(ls(Ke)), ve++, ve > V && (V = ve)), ve < A.length)) for ($ = $.child; $ !== null; ) m.push($, ve), $ = $.sibling;
      }
      if (V < A.length) {
        for (m = []; V < A.length; V++) m.push(ls(A[V]));
        return `findAllNodes was able to match part of the selector:
  ` + (E.join(" > ") + `

No matching component was found for:
  `) + m.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(m) {
      if (m = m.current, !m.child) return null;
      switch (m.child.tag) {
        case 5:
          return Re(m.child.stateNode);
        default:
          return m.child.stateNode;
      }
    }, t.injectIntoDevTools = function(m) {
      if (m = { bundleType: m.bundleType, version: m.version, rendererPackageName: m.rendererPackageName, rendererConfig: m.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: u.ReactCurrentDispatcher, findHostInstanceByFiber: RI, findFiberByHostInstance: m.findFiberByHostInstance || xp, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") m = !1;
      else {
        var A = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (A.isDisabled || !A.supportsFiber) m = !0;
        else {
          try {
            hg = A.inject(m), Us = A;
          } catch {
          }
          m = !!A.checkDCE;
        }
      }
      return m;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(m, A, V, E) {
      if (!me) throw Error(l(363));
      m = Rg(m, A);
      var k = jt(m, V, E).disconnect;
      return { disconnect: function() {
        k();
      } };
    }, t.registerMutableSourceForHydration = function(m, A) {
      var V = A._getVersion;
      V = V(A._source), m.mutableSourceEagerHydrationData == null ? m.mutableSourceEagerHydrationData = [A, V] : m.mutableSourceEagerHydrationData.push(A, V);
    }, t.runWithPriority = function(m, A) {
      var V = Bi;
      try {
        return Bi = m, A();
      } finally {
        Bi = V;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(m, A, V, E) {
      var k = A.current, $ = fr(), ve = ac(k);
      return V = xd(V), A.context === null ? A.context = V : A.pendingContext = V, A = Js($, ve), A.payload = { element: m }, E = E === void 0 ? null : E, E !== null && (A.callback = E), mu(k, A), m = ca(k, ve, $), m !== null && Au(m, k, ve), ve;
    }, t;
  }), lH;
}
var uH = { exports: {} }, S5;
function Mee() {
  if (S5) return uH.exports;
  S5 = 1;
  var r = {};
  /**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return r.NODE_ENV !== "production" && (uH.exports = function(t) {
    var n = {}, i = xb(), o = TY(), l = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, u = !1;
    function I(g) {
      u = g;
    }
    function C(g) {
      if (!u) {
        for (var d = arguments.length, G = new Array(d > 1 ? d - 1 : 0), w = 1; w < d; w++)
          G[w - 1] = arguments[w];
        v("warn", g, G);
      }
    }
    function f(g) {
      if (!u) {
        for (var d = arguments.length, G = new Array(d > 1 ? d - 1 : 0), w = 1; w < d; w++)
          G[w - 1] = arguments[w];
        v("error", g, G);
      }
    }
    function v(g, d, G) {
      {
        var w = l.ReactDebugCurrentFrame, H = w.getStackAddendum();
        H !== "" && (d += "%s", G = G.concat([H]));
        var z = G.map(function(q) {
          return String(q);
        });
        z.unshift("Warning: " + d), Function.prototype.apply.call(console[g], console, z);
      }
    }
    var b = Object.assign;
    function S(g) {
      return g._reactInternals;
    }
    function R(g, d) {
      g._reactInternals = d;
    }
    var W = !1, x = !1, N = !1, Y = !1, F = !0, T = !0, P = !0, D = 0, L = 1, j = 2, J = 3, O = 4, ne = 5, he = 6, pe = 7, Ae = 8, ke = 9, Re = 10, Xe = 11, re = 12, Se = 13, Be = 14, le = 15, Ye = 16, nt = 17, ze = 18, Je = 19, wt = 21, mt = 22, Dt = 23, mn = 24, An = 25, Hn = Symbol.for("react.element"), ge = Symbol.for("react.portal"), Wt = Symbol.for("react.fragment"), Nt = Symbol.for("react.strict_mode"), $t = Symbol.for("react.profiler"), ft = Symbol.for("react.provider"), bn = Symbol.for("react.context"), en = Symbol.for("react.forward_ref"), hn = Symbol.for("react.suspense"), me = Symbol.for("react.suspense_list"), se = Symbol.for("react.memo"), $e = Symbol.for("react.lazy"), Vt = Symbol.for("react.scope"), Bt = Symbol.for("react.debug_trace_mode"), Mt = Symbol.for("react.offscreen"), Gn = Symbol.for("react.legacy_hidden"), jt = Symbol.for("react.cache"), an = Symbol.for("react.tracing_marker"), jn = Symbol.iterator, Ot = "@@iterator";
    function He(g) {
      if (g === null || typeof g != "object")
        return null;
      var d = jn && g[jn] || g[Ot];
      return typeof d == "function" ? d : null;
    }
    function vt(g, d, G) {
      var w = g.displayName;
      if (w)
        return w;
      var H = d.displayName || d.name || "";
      return H !== "" ? G + "(" + H + ")" : G;
    }
    function xt(g) {
      return g.displayName || "Context";
    }
    function ht(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && f("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case Wt:
          return "Fragment";
        case ge:
          return "Portal";
        case $t:
          return "Profiler";
        case Nt:
          return "StrictMode";
        case hn:
          return "Suspense";
        case me:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case bn:
            var d = g;
            return xt(d) + ".Consumer";
          case ft:
            var G = g;
            return xt(G._context) + ".Provider";
          case en:
            return vt(g, g.render, "ForwardRef");
          case se:
            var w = g.displayName || null;
            return w !== null ? w : ht(g.type) || "Memo";
          case $e: {
            var H = g, z = H._payload, q = H._init;
            try {
              return ht(q(z));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function on(g, d, G) {
      var w = d.displayName || d.name || "";
      return g.displayName || (w !== "" ? G + "(" + w + ")" : G);
    }
    function we(g) {
      return g.displayName || "Context";
    }
    function qe(g) {
      var d = g.tag, G = g.type;
      switch (d) {
        case mn:
          return "Cache";
        case ke:
          var w = G;
          return we(w) + ".Consumer";
        case Re:
          var H = G;
          return we(H._context) + ".Provider";
        case ze:
          return "DehydratedFragment";
        case Xe:
          return on(G, G.render, "ForwardRef");
        case pe:
          return "Fragment";
        case ne:
          return G;
        case O:
          return "Portal";
        case J:
          return "Root";
        case he:
          return "Text";
        case Ye:
          return ht(G);
        case Ae:
          return G === Nt ? "StrictMode" : "Mode";
        case mt:
          return "Offscreen";
        case re:
          return "Profiler";
        case wt:
          return "Scope";
        case Se:
          return "Suspense";
        case Je:
          return "SuspenseList";
        case An:
          return "TracingMarker";
        // The display name for this tags come from the user-provided type:
        case L:
        case D:
        case nt:
        case j:
        case Be:
        case le:
          if (typeof G == "function")
            return G.displayName || G.name || null;
          if (typeof G == "string")
            return G;
          break;
      }
      return null;
    }
    var de = (
      /*                      */
      0
    ), it = (
      /*                */
      1
    ), je = (
      /*                    */
      2
    ), et = (
      /*                       */
      4
    ), Jt = (
      /*           */
      je | et
    ), Kn = (
      /*                */
      16
    ), di = (
      /*                 */
      32
    ), Di = (
      /*                     */
      64
    ), Jn = (
      /*                   */
      128
    ), Ii = (
      /*            */
      256
    ), dr = (
      /*                          */
      512
    ), xr = (
      /*                     */
      1024
    ), la = (
      /*                      */
      2048
    ), Ve = (
      /*                    */
      4096
    ), Oe = (
      /*           */
      Ve | et
    ), rt = (
      /*                   */
      8192
    ), Et = (
      /*             */
      16384
    ), gn = (
      /*               */
      32767
    ), Vn = (
      /*                   */
      32768
    ), Ln = (
      /*                */
      65536
    ), Ie = (
      /* */
      131072
    ), tt = (
      /*                       */
      1048576
    ), At = (
      /*                    */
      2097152
    ), Gt = (
      /*                 */
      4194304
    ), vn = (
      /*                */
      8388608
    ), ae = (
      /*               */
      16777216
    ), Ne = (
      /*              */
      33554432
    ), Te = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      et | xr | 0
    ), De = je | et | Kn | di | dr | Ve | rt, Ee = et | Di | dr | rt, Tt = la | Kn, tn = Gt | vn | At, Bn = l.ReactCurrentOwner;
    function Pt(g) {
      var d = g, G = g;
      if (g.alternate)
        for (; d.return; )
          d = d.return;
      else {
        var w = d;
        do
          d = w, (d.flags & (je | Ve)) !== de && (G = d.return), w = d.return;
        while (w);
      }
      return d.tag === J ? G : null;
    }
    function Zn(g) {
      return Pt(g) === g;
    }
    function rn(g) {
      {
        var d = Bn.current;
        if (d !== null && d.tag === L) {
          var G = d, w = G.stateNode;
          w._warnedAboutRefsInRender || f("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", qe(G) || "A component"), w._warnedAboutRefsInRender = !0;
        }
      }
      var H = S(g);
      return H ? Pt(H) === H : !1;
    }
    function Yn(g) {
      if (Pt(g) !== g)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Fi(g) {
      var d = g.alternate;
      if (!d) {
        var G = Pt(g);
        if (G === null)
          throw new Error("Unable to find node on an unmounted component.");
        return G !== g ? null : g;
      }
      for (var w = g, H = d; ; ) {
        var z = w.return;
        if (z === null)
          break;
        var q = z.alternate;
        if (q === null) {
          var ee = z.return;
          if (ee !== null) {
            w = H = ee;
            continue;
          }
          break;
        }
        if (z.child === q.child) {
          for (var ue = z.child; ue; ) {
            if (ue === w)
              return Yn(z), g;
            if (ue === H)
              return Yn(z), d;
            ue = ue.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (w.return !== H.return)
          w = z, H = q;
        else {
          for (var Ze = !1, _e = z.child; _e; ) {
            if (_e === w) {
              Ze = !0, w = z, H = q;
              break;
            }
            if (_e === H) {
              Ze = !0, H = z, w = q;
              break;
            }
            _e = _e.sibling;
          }
          if (!Ze) {
            for (_e = q.child; _e; ) {
              if (_e === w) {
                Ze = !0, w = q, H = z;
                break;
              }
              if (_e === H) {
                Ze = !0, H = q, w = z;
                break;
              }
              _e = _e.sibling;
            }
            if (!Ze)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (w.alternate !== H)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (w.tag !== J)
        throw new Error("Unable to find node on an unmounted component.");
      return w.stateNode.current === w ? g : d;
    }
    function Ir(g) {
      var d = Fi(g);
      return d !== null ? Tn(d) : null;
    }
    function Tn(g) {
      if (g.tag === ne || g.tag === he)
        return g;
      for (var d = g.child; d !== null; ) {
        var G = Tn(d);
        if (G !== null)
          return G;
        d = d.sibling;
      }
      return null;
    }
    function mi(g) {
      var d = Fi(g);
      return d !== null ? xn(d) : null;
    }
    function xn(g) {
      if (g.tag === ne || g.tag === he)
        return g;
      for (var d = g.child; d !== null; ) {
        if (d.tag !== O) {
          var G = xn(d);
          if (G !== null)
            return G;
        }
        d = d.sibling;
      }
      return null;
    }
    var un = Array.isArray;
    function Xn(g) {
      return un(g);
    }
    var li = t.getPublicInstance, Wr = t.getRootHostContext, Xo = t.getChildHostContext, $r = t.prepareForCommit, ba = t.resetAfterCommit, or = t.createInstance, za = t.appendInitialChild, pl = t.finalizeInitialChildren, Xa = t.prepareUpdate, bs = t.shouldSetTextContent, Ao = t.createTextInstance, Ou = t.scheduleTimeout, od = t.cancelTimeout, dI = t.noTimeout;
    t.now;
    var Pu = t.isPrimaryRenderer, sr = t.warnsIfNotActing, Yo = t.supportsMutation, Cu = t.supportsPersistence, Hi = t.supportsHydration, sf = t.getInstanceFromNode;
    t.beforeActiveInstanceBlur, t.afterActiveInstanceBlur;
    var hu = t.preparePortalMount;
    t.preparePortalMount, t.getInstanceFromScope;
    var xi = t.getCurrentEventPriority, Ju = t.detachDeletedInstance, Po = t.supportsMicrotasks, Gs = t.scheduleMicrotask, Bi = t.supportsTestSelectors, Qu = t.findFiberRoot, Ra = t.getBoundingRect, Lr = t.getTextContent, Ds = t.isHiddenSubtree, fu = t.matchAccessibilityRole, Sr = t.setFocusIfFocusable, as = t.setupIntersectionObserver, Ap = t.appendChild, sd = t.appendChildToContainer, II = t.commitTextUpdate, hg = t.commitMount, Us = t.commitUpdate, CI = t.insertBefore, pu = t.insertInContainerBefore, $a = t.removeChild, Bs = t.removeChildFromContainer, Ul = t.resetTextContent, ld = t.hideInstance, fg = t.hideTextInstance, pg = t.unhideInstance, Os = t.unhideTextInstance, th = t.clearContainer, Ps = t.cloneInstance, hI = t.createContainerChildSet, ie = t.appendChildToContainerChildSet, Me = t.finalizeContainerChildren, gt = t.replaceContainerChildren;
    t.getOffscreenContainerType, t.getOffscreenContainerProps;
    var St = t.cloneHiddenInstance, dn = t.cloneHiddenTextInstance, qn = t.canHydrateInstance, _n = t.canHydrateTextInstance, Si = t.canHydrateSuspenseInstance, Ui = t.isSuspenseInstancePending, ur = t.isSuspenseInstanceFallback, nr = t.registerSuspenseInstanceRetry, $i = t.getNextHydratableSibling, Zi = t.getFirstHydratableChild, kr = t.getFirstHydratableChildWithinContainer, Ka = t.getFirstHydratableChildWithinSuspenseInstance, Js = t.hydrateInstance, mu = t.hydrateTextInstance, Au = t.hydrateSuspenseInstance, ud = t.getNextHydratableInstanceAfterSuspenseInstance, mg = t.commitHydratedContainer, lf = t.commitHydratedSuspenseInstance, nh = t.clearSuspenseBoundary, ih = t.clearSuspenseBoundaryFromContainer, rh = t.shouldDeleteUnhydratedTailInstances, ah = t.didNotMatchHydratedContainerTextInstance, vp = t.didNotMatchHydratedTextInstance, yp = t.didNotHydrateInstanceWithinContainer, uf = t.didNotHydrateInstanceWithinSuspenseInstance, qI = t.didNotHydrateInstance, Ss = t.didNotFindHydratableInstanceWithinContainer, cf = t.didNotFindHydratableTextInstanceWithinContainer, $I = t.didNotFindHydratableSuspenseInstanceWithinContainer, ml = t.didNotFindHydratableInstanceWithinSuspenseInstance, Qs = t.didNotFindHydratableTextInstanceWithinSuspenseInstance, fI = t.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, vu = t.didNotFindHydratableInstance, xc = t.didNotFindHydratableTextInstance, vo = t.didNotFindHydratableSuspenseInstance, Wc = t.errorHydratingContainer, ha = 0, yu, Jo, eo, Ga, ju, Ol, gf;
    function eC() {
    }
    eC.__reactDisabledLog = !0;
    function df() {
      {
        if (ha === 0) {
          yu = console.log, Jo = console.info, eo = console.warn, Ga = console.error, ju = console.group, Ol = console.groupCollapsed, gf = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: eC,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        ha++;
      }
    }
    function cd() {
      {
        if (ha--, ha === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: b({}, g, {
              value: yu
            }),
            info: b({}, g, {
              value: Jo
            }),
            warn: b({}, g, {
              value: eo
            }),
            error: b({}, g, {
              value: Ga
            }),
            group: b({}, g, {
              value: ju
            }),
            groupCollapsed: b({}, g, {
              value: Ol
            }),
            groupEnd: b({}, g, {
              value: gf
            })
          });
        }
        ha < 0 && f("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var If = l.ReactCurrentDispatcher, gd;
    function Pl(g, d, G) {
      {
        if (gd === void 0)
          try {
            throw Error();
          } catch (H) {
            var w = H.stack.trim().match(/\n( *(at )?)/);
            gd = w && w[1] || "";
          }
        return `
` + gd + g;
      }
    }
    var tC = !1, Ag;
    {
      var vg = typeof WeakMap == "function" ? WeakMap : Map;
      Ag = new vg();
    }
    function Jl(g, d) {
      if (!g || tC)
        return "";
      {
        var G = Ag.get(g);
        if (G !== void 0)
          return G;
      }
      var w;
      tC = !0;
      var H = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var z;
      z = If.current, If.current = null, df();
      try {
        if (d) {
          var q = function() {
            throw Error();
          };
          if (Object.defineProperty(q.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(q, []);
            } catch (nn) {
              w = nn;
            }
            Reflect.construct(g, [], q);
          } else {
            try {
              q.call();
            } catch (nn) {
              w = nn;
            }
            g.call(q.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (nn) {
            w = nn;
          }
          g();
        }
      } catch (nn) {
        if (nn && w && typeof nn.stack == "string") {
          for (var ee = nn.stack.split(`
`), ue = w.stack.split(`
`), Ze = ee.length - 1, _e = ue.length - 1; Ze >= 1 && _e >= 0 && ee[Ze] !== ue[_e]; )
            _e--;
          for (; Ze >= 1 && _e >= 0; Ze--, _e--)
            if (ee[Ze] !== ue[_e]) {
              if (Ze !== 1 || _e !== 1)
                do
                  if (Ze--, _e--, _e < 0 || ee[Ze] !== ue[_e]) {
                    var st = `
` + ee[Ze].replace(" at new ", " at ");
                    return g.displayName && st.includes("<anonymous>") && (st = st.replace("<anonymous>", g.displayName)), typeof g == "function" && Ag.set(g, st), st;
                  }
                while (Ze >= 1 && _e >= 0);
              break;
            }
        }
      } finally {
        tC = !1, If.current = z, cd(), Error.prepareStackTrace = H;
      }
      var Zt = g ? g.displayName || g.name : "", Xt = Zt ? Pl(Zt) : "";
      return typeof g == "function" && Ag.set(g, Xt), Xt;
    }
    function Cf(g, d, G) {
      return Jl(g, !0);
    }
    function bu(g, d, G) {
      return Jl(g, !1);
    }
    function bp(g) {
      var d = g.prototype;
      return !!(d && d.isReactComponent);
    }
    function dd(g, d, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return Jl(g, bp(g));
      if (typeof g == "string")
        return Pl(g);
      switch (g) {
        case hn:
          return Pl("Suspense");
        case me:
          return Pl("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case en:
            return bu(g.render);
          case se:
            return dd(g.type, d, G);
          case $e: {
            var w = g, H = w._payload, z = w._init;
            try {
              return dd(z(H), d, G);
            } catch {
            }
          }
        }
      return "";
    }
    var js = Object.prototype.hasOwnProperty, Id = {}, Cd = l.ReactDebugCurrentFrame;
    function Al(g) {
      if (g) {
        var d = g._owner, G = dd(g.type, g._source, d ? d.type : null);
        Cd.setExtraStackFrame(G);
      } else
        Cd.setExtraStackFrame(null);
    }
    function vl(g, d, G, w, H) {
      {
        var z = Function.call.bind(js);
        for (var q in g)
          if (z(g, q)) {
            var ee = void 0;
            try {
              if (typeof g[q] != "function") {
                var ue = Error((w || "React class") + ": " + G + " type `" + q + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[q] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ue.name = "Invariant Violation", ue;
              }
              ee = g[q](d, q, w, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ze) {
              ee = Ze;
            }
            ee && !(ee instanceof Error) && (Al(H), f("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", w || "React class", G, q, typeof ee), Al(null)), ee instanceof Error && !(ee.message in Id) && (Id[ee.message] = !0, Al(H), f("Failed %s type: %s", G, ee.message), Al(null));
          }
      }
    }
    var hd = [], oh;
    oh = [];
    var Gu = -1;
    function Tr(g) {
      return {
        current: g
      };
    }
    function yo(g, d) {
      if (Gu < 0) {
        f("Unexpected pop.");
        return;
      }
      d !== oh[Gu] && f("Unexpected Fiber popped."), g.current = hd[Gu], hd[Gu] = null, oh[Gu] = null, Gu--;
    }
    function Dr(g, d, G) {
      Gu++, hd[Gu] = g.current, oh[Gu] = G, g.current = d;
    }
    var yg;
    yg = {};
    var os = {};
    Object.freeze(os);
    var to = Tr(os), Qo = Tr(!1), Hr = os;
    function fa(g, d, G) {
      return G && Zs(d) ? Hr : to.current;
    }
    function bo(g, d, G) {
      {
        var w = g.stateNode;
        w.__reactInternalMemoizedUnmaskedChildContext = d, w.__reactInternalMemoizedMaskedChildContext = G;
      }
    }
    function yl(g, d) {
      {
        var G = g.type, w = G.contextTypes;
        if (!w)
          return os;
        var H = g.stateNode;
        if (H && H.__reactInternalMemoizedUnmaskedChildContext === d)
          return H.__reactInternalMemoizedMaskedChildContext;
        var z = {};
        for (var q in w)
          z[q] = d[q];
        {
          var ee = qe(g) || "Unknown";
          vl(w, z, "context", ee);
        }
        return H && bo(g, d, z), z;
      }
    }
    function Ql() {
      return Qo.current;
    }
    function Zs(g) {
      {
        var d = g.childContextTypes;
        return d != null;
      }
    }
    function fd(g) {
      yo(Qo, g), yo(to, g);
    }
    function Go(g) {
      yo(Qo, g), yo(to, g);
    }
    function sh(g, d, G) {
      {
        if (to.current !== os)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Dr(to, d, g), Dr(Qo, G, g);
      }
    }
    function pd(g, d, G) {
      {
        var w = g.stateNode, H = d.childContextTypes;
        if (typeof w.getChildContext != "function") {
          {
            var z = qe(g) || "Unknown";
            yg[z] || (yg[z] = !0, f("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", z, z));
          }
          return G;
        }
        var q = w.getChildContext();
        for (var ee in q)
          if (!(ee in H))
            throw new Error((qe(g) || "Unknown") + '.getChildContext(): key "' + ee + '" is not defined in childContextTypes.');
        {
          var ue = qe(g) || "Unknown";
          vl(H, q, "child context", ue);
        }
        return b({}, G, q);
      }
    }
    function qu(g) {
      {
        var d = g.stateNode, G = d && d.__reactInternalMemoizedMergedChildContext || os;
        return Hr = to.current, Dr(to, G, g), Dr(Qo, Qo.current, g), !0;
      }
    }
    function jl(g, d, G) {
      {
        var w = g.stateNode;
        if (!w)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (G) {
          var H = pd(g, d, Hr);
          w.__reactInternalMemoizedMergedChildContext = H, yo(Qo, g), yo(to, g), Dr(to, H, g), Dr(Qo, G, g);
        } else
          yo(Qo, g), Dr(Qo, G, g);
      }
    }
    function Ba(g) {
      {
        if (!Zn(g) || g.tag !== L)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var d = g;
        do {
          switch (d.tag) {
            case J:
              return d.stateNode.context;
            case L: {
              var G = d.type;
              if (Zs(G))
                return d.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          d = d.return;
        } while (d !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var ws = 0, nC = 1, wi = (
      /*                         */
      0
    ), _r = (
      /*                 */
      1
    ), vr = (
      /*                    */
      2
    ), La = (
      /*               */
      8
    ), ql = (
      /*              */
      16
    ), Bu = Math.clz32 ? Math.clz32 : bg, md = Math.log, lh = Math.LN2;
    function bg(g) {
      var d = g >>> 0;
      return d === 0 ? 32 : 31 - (md(d) / lh | 0) | 0;
    }
    var hf = 31, Qt = (
      /*                        */
      0
    ), no = (
      /*                          */
      0
    ), ji = (
      /*                        */
      1
    ), $l = (
      /*    */
      2
    ), lr = (
      /*            */
      4
    ), qs = (
      /*            */
      8
    ), bl = (
      /*                    */
      16
    ), Vc = (
      /*                */
      32
    ), Nc = (
      /*                       */
      4194240
    ), Ad = (
      /*                        */
      64
    ), Gg = (
      /*                        */
      128
    ), pI = (
      /*                        */
      256
    ), Mc = (
      /*                        */
      512
    ), iC = (
      /*                        */
      1024
    ), Gp = (
      /*                        */
      2048
    ), uh = (
      /*                        */
      4096
    ), ch = (
      /*                        */
      8192
    ), mI = (
      /*                        */
      16384
    ), AI = (
      /*                       */
      32768
    ), Su = (
      /*                       */
      65536
    ), vI = (
      /*                       */
      131072
    ), Bg = (
      /*                       */
      262144
    ), rC = (
      /*                       */
      524288
    ), aC = (
      /*                       */
      1048576
    ), vd = (
      /*                       */
      2097152
    ), ff = (
      /*                            */
      130023424
    ), Zu = (
      /*                             */
      4194304
    ), Sg = (
      /*                             */
      8388608
    ), Gl = (
      /*                             */
      16777216
    ), yI = (
      /*                             */
      33554432
    ), Zg = (
      /*                             */
      67108864
    ), ka = Zu, Hc = (
      /*          */
      134217728
    ), Bl = (
      /*                                 */
      268435455
    ), $u = (
      /*               */
      268435456
    ), wu = (
      /*                       */
      536870912
    ), Bo = (
      /*                   */
      1073741824
    );
    function yd(g) {
      {
        if (g & ji)
          return "Sync";
        if (g & $l)
          return "InputContinuousHydration";
        if (g & lr)
          return "InputContinuous";
        if (g & qs)
          return "DefaultHydration";
        if (g & bl)
          return "Default";
        if (g & Vc)
          return "TransitionHydration";
        if (g & Nc)
          return "Transition";
        if (g & ff)
          return "Retry";
        if (g & Hc)
          return "SelectiveHydration";
        if (g & $u)
          return "IdleHydration";
        if (g & wu)
          return "Idle";
        if (g & Bo)
          return "Offscreen";
      }
    }
    var yr = -1, Nn = Ad, Ru = Zu;
    function xa(g) {
      switch (Fo(g)) {
        case ji:
          return ji;
        case $l:
          return $l;
        case lr:
          return lr;
        case qs:
          return qs;
        case bl:
          return bl;
        case Vc:
          return Vc;
        case Ad:
        case Gg:
        case pI:
        case Mc:
        case iC:
        case Gp:
        case uh:
        case ch:
        case mI:
        case AI:
        case Su:
        case vI:
        case Bg:
        case rC:
        case aC:
        case vd:
          return g & Nc;
        case Zu:
        case Sg:
        case Gl:
        case yI:
        case Zg:
          return g & ff;
        case Hc:
          return Hc;
        case $u:
          return $u;
        case wu:
          return wu;
        case Bo:
          return Bo;
        default:
          return f("Should have found matching lanes. This is a bug in React."), g;
      }
    }
    function pi(g, d) {
      var G = g.pendingLanes;
      if (G === Qt)
        return Qt;
      var w = Qt, H = g.suspendedLanes, z = g.pingedLanes, q = G & Bl;
      if (q !== Qt) {
        var ee = q & ~H;
        if (ee !== Qt)
          w = xa(ee);
        else {
          var ue = q & z;
          ue !== Qt && (w = xa(ue));
        }
      } else {
        var Ze = G & ~H;
        Ze !== Qt ? w = xa(Ze) : z !== Qt && (w = xa(z));
      }
      if (w === Qt)
        return Qt;
      if (d !== Qt && d !== w && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (d & H) === Qt) {
        var _e = Fo(w), st = Fo(d);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          _e >= st || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          _e === bl && (st & Nc) !== Qt
        )
          return d;
      }
      (w & lr) !== Qt && (w |= G & bl);
      var Zt = g.entangledLanes;
      if (Zt !== Qt)
        for (var Xt = g.entanglements, nn = w & Zt; nn > 0; ) {
          var Cn = xu(nn), yi = 1 << Cn;
          w |= Xt[Cn], nn &= ~yi;
        }
      return w;
    }
    function ea(g, d) {
      for (var G = g.eventTimes, w = yr; d > 0; ) {
        var H = xu(d), z = 1 << H, q = G[H];
        q > w && (w = q), d &= ~z;
      }
      return w;
    }
    function Ur(g, d) {
      switch (g) {
        case ji:
        case $l:
        case lr:
          return d + 250;
        case qs:
        case bl:
        case Vc:
        case Ad:
        case Gg:
        case pI:
        case Mc:
        case iC:
        case Gp:
        case uh:
        case ch:
        case mI:
        case AI:
        case Su:
        case vI:
        case Bg:
        case rC:
        case aC:
        case vd:
          return d + 5e3;
        case Zu:
        case Sg:
        case Gl:
        case yI:
        case Zg:
          return yr;
        case Hc:
        case $u:
        case wu:
        case Bo:
          return yr;
        default:
          return f("Should have found matching lanes. This is a bug in React."), yr;
      }
    }
    function ta(g, d) {
      for (var G = g.pendingLanes, w = g.suspendedLanes, H = g.pingedLanes, z = g.expirationTimes, q = G; q > 0; ) {
        var ee = xu(q), ue = 1 << ee, Ze = z[ee];
        Ze === yr ? ((ue & w) === Qt || (ue & H) !== Qt) && (z[ee] = Ur(ue, d)) : Ze <= d && (g.expiredLanes |= ue), q &= ~ue;
      }
    }
    function er(g) {
      return xa(g.pendingLanes);
    }
    function Sa(g) {
      var d = g.pendingLanes & -1073741825;
      return d !== Qt ? d : d & Bo ? Bo : Qt;
    }
    function io(g) {
      return (g & ji) !== Qt;
    }
    function Rs(g) {
      return (g & Bl) !== Qt;
    }
    function $s(g) {
      return (g & ff) === g;
    }
    function Da(g) {
      return (g & Nc) === g;
    }
    function Sl(g, d) {
      var G = $l | lr | qs | bl;
      return (d & G) !== Qt;
    }
    function gh(g, d) {
      return (d & g.expiredLanes) !== Qt;
    }
    function oC(g) {
      return (g & Nc) !== 0;
    }
    function Xc() {
      var g = Nn;
      return Nn <<= 1, (Nn & Nc) === 0 && (Nn = Ad), g;
    }
    function eu() {
      var g = Ru;
      return Ru <<= 1, (Ru & ff) === 0 && (Ru = Zu), g;
    }
    function Fo(g) {
      return g & -g;
    }
    function Yc(g) {
      return Fo(g);
    }
    function xu(g) {
      return 31 - Bu(g);
    }
    function tu(g) {
      return xu(g);
    }
    function xs(g, d) {
      return (g & d) !== Qt;
    }
    function Ua(g, d) {
      return (g & d) === d;
    }
    function Wi(g, d) {
      return g | d;
    }
    function Eo(g, d) {
      return g & ~d;
    }
    function bI(g, d) {
      return g & d;
    }
    function GI(g) {
      return g;
    }
    function So(g, d) {
      return g !== no && g < d ? g : d;
    }
    function na(g) {
      for (var d = [], G = 0; G < hf; G++)
        d.push(g);
      return d;
    }
    function ec(g, d, G) {
      g.pendingLanes |= d, d !== wu && (g.suspendedLanes = Qt, g.pingedLanes = Qt);
      var w = g.eventTimes, H = tu(d);
      w[H] = G;
    }
    function fn(g, d) {
      g.suspendedLanes |= d, g.pingedLanes &= ~d;
      for (var G = g.expirationTimes, w = d; w > 0; ) {
        var H = xu(w), z = 1 << H;
        G[H] = yr, w &= ~z;
      }
    }
    function Zl(g, d, G) {
      g.pingedLanes |= g.suspendedLanes & d;
    }
    function Fc(g, d) {
      var G = g.pendingLanes & ~d;
      g.pendingLanes = d, g.suspendedLanes = 0, g.pingedLanes = 0, g.expiredLanes &= d, g.mutableReadLanes &= d, g.entangledLanes &= d;
      for (var w = g.entanglements, H = g.eventTimes, z = g.expirationTimes, q = G; q > 0; ) {
        var ee = xu(q), ue = 1 << ee;
        w[ee] = Qt, H[ee] = yr, z[ee] = yr, q &= ~ue;
      }
    }
    function dh(g, d) {
      for (var G = g.entangledLanes |= d, w = g.entanglements, H = G; H; ) {
        var z = xu(H), q = 1 << z;
        // Is this one of the newly entangled lanes?
        q & d | // Is this lane transitively entangled with the newly entangled lanes?
        w[z] & d && (w[z] |= d), H &= ~q;
      }
    }
    function Bp(g, d) {
      var G = Fo(d), w;
      switch (G) {
        case lr:
          w = $l;
          break;
        case bl:
          w = qs;
          break;
        case Ad:
        case Gg:
        case pI:
        case Mc:
        case iC:
        case Gp:
        case uh:
        case ch:
        case mI:
        case AI:
        case Su:
        case vI:
        case Bg:
        case rC:
        case aC:
        case vd:
        case Zu:
        case Sg:
        case Gl:
        case yI:
        case Zg:
          w = Vc;
          break;
        case wu:
          w = $u;
          break;
        default:
          w = no;
          break;
      }
      return (w & (g.suspendedLanes | d)) !== no ? no : w;
    }
    function tc(g, d, G) {
      if (tr)
        for (var w = g.pendingUpdatersLaneMap; G > 0; ) {
          var H = tu(G), z = 1 << H, q = w[H];
          q.add(d), G &= ~z;
        }
    }
    function To(g, d) {
      if (tr)
        for (var G = g.pendingUpdatersLaneMap, w = g.memoizedUpdaters; d > 0; ) {
          var H = tu(d), z = 1 << H, q = G[H];
          q.size > 0 && (q.forEach(function(ee) {
            var ue = ee.alternate;
            (ue === null || !w.has(ue)) && w.add(ee);
          }), q.clear()), d &= ~z;
        }
    }
    var Za = ji, zr = lr, Ws = bl, sC = wu, bd = no;
    function wl() {
      return bd;
    }
    function ro(g) {
      bd = g;
    }
    function pf(g, d) {
      var G = bd;
      try {
        return bd = g, d();
      } finally {
        bd = G;
      }
    }
    function Ya(g, d) {
      return g !== 0 && g < d ? g : d;
    }
    function Sp(g, d) {
      return g > d ? g : d;
    }
    function Wu(g, d) {
      return g !== 0 && g < d;
    }
    function wg(g) {
      var d = Fo(g);
      return Wu(Za, d) ? Wu(zr, d) ? Rs(d) ? Ws : sC : zr : Za;
    }
    var Gd = o.unstable_scheduleCallback, Ih = o.unstable_cancelCallback, BI = o.unstable_shouldYield, Zp = o.unstable_requestPaint, Zo = o.unstable_now, el = o.unstable_ImmediatePriority, ao = o.unstable_UserBlockingPriority, yn = o.unstable_NormalPriority, ss = o.unstable_IdlePriority, _o = o.unstable_yieldValue, lC = o.unstable_setDisableYieldValue, Vu = null, wo = null, Wn = null, ls = !1, tr = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Rg(g) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var d = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (d.isDisabled)
        return !0;
      if (!d.supportsFiber)
        return f("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        F && (g = b({}, g, {
          getLaneLabelMap: ia,
          injectProfilingHooks: oo
        })), Vu = d.inject(g), wo = d;
      } catch (G) {
        f("React instrumentation encountered an error: %s.", G);
      }
      return !!d.checkDCE;
    }
    function wp(g, d) {
      if (wo && typeof wo.onScheduleFiberRoot == "function")
        try {
          wo.onScheduleFiberRoot(Vu, g, d);
        } catch (G) {
          ls || (ls = !0, f("React instrumentation encountered an error: %s", G));
        }
    }
    function Ch(g, d) {
      if (wo && typeof wo.onCommitFiberRoot == "function")
        try {
          var G = (g.current.flags & Jn) === Jn;
          if (T) {
            var w;
            switch (d) {
              case Za:
                w = el;
                break;
              case zr:
                w = ao;
                break;
              case Ws:
                w = yn;
                break;
              case sC:
                w = ss;
                break;
              default:
                w = yn;
                break;
            }
            wo.onCommitFiberRoot(Vu, g, w, G);
          }
        } catch (H) {
          ls || (ls = !0, f("React instrumentation encountered an error: %s", H));
        }
    }
    function Nu(g) {
      if (wo && typeof wo.onPostCommitFiberRoot == "function")
        try {
          wo.onPostCommitFiberRoot(Vu, g);
        } catch (d) {
          ls || (ls = !0, f("React instrumentation encountered an error: %s", d));
        }
    }
    function Vr(g) {
      if (wo && typeof wo.onCommitFiberUnmount == "function")
        try {
          wo.onCommitFiberUnmount(Vu, g);
        } catch (d) {
          ls || (ls = !0, f("React instrumentation encountered an error: %s", d));
        }
    }
    function ri(g) {
      if (typeof _o == "function" && (lC(g), I(g)), wo && typeof wo.setStrictMode == "function")
        try {
          wo.setStrictMode(Vu, g);
        } catch (d) {
          ls || (ls = !0, f("React instrumentation encountered an error: %s", d));
        }
    }
    function oo(g) {
      Wn = g;
    }
    function ia() {
      {
        for (var g = /* @__PURE__ */ new Map(), d = 1, G = 0; G < hf; G++) {
          var w = yd(d);
          g.set(d, w), d *= 2;
        }
        return g;
      }
    }
    function Wa(g) {
      Wn !== null && typeof Wn.markCommitStarted == "function" && Wn.markCommitStarted(g);
    }
    function us() {
      Wn !== null && typeof Wn.markCommitStopped == "function" && Wn.markCommitStopped();
    }
    function nc(g) {
      Wn !== null && typeof Wn.markComponentRenderStarted == "function" && Wn.markComponentRenderStarted(g);
    }
    function ua() {
      Wn !== null && typeof Wn.markComponentRenderStopped == "function" && Wn.markComponentRenderStopped();
    }
    function SI(g) {
      Wn !== null && typeof Wn.markComponentPassiveEffectMountStarted == "function" && Wn.markComponentPassiveEffectMountStarted(g);
    }
    function ic() {
      Wn !== null && typeof Wn.markComponentPassiveEffectMountStopped == "function" && Wn.markComponentPassiveEffectMountStopped();
    }
    function nu(g) {
      Wn !== null && typeof Wn.markComponentPassiveEffectUnmountStarted == "function" && Wn.markComponentPassiveEffectUnmountStarted(g);
    }
    function ZI() {
      Wn !== null && typeof Wn.markComponentPassiveEffectUnmountStopped == "function" && Wn.markComponentPassiveEffectUnmountStopped();
    }
    function xg(g) {
      Wn !== null && typeof Wn.markComponentLayoutEffectMountStarted == "function" && Wn.markComponentLayoutEffectMountStarted(g);
    }
    function Ro() {
      Wn !== null && typeof Wn.markComponentLayoutEffectMountStopped == "function" && Wn.markComponentLayoutEffectMountStopped();
    }
    function uC(g) {
      Wn !== null && typeof Wn.markComponentLayoutEffectUnmountStarted == "function" && Wn.markComponentLayoutEffectUnmountStarted(g);
    }
    function Wg() {
      Wn !== null && typeof Wn.markComponentLayoutEffectUnmountStopped == "function" && Wn.markComponentLayoutEffectUnmountStopped();
    }
    function Bd(g, d, G) {
      Wn !== null && typeof Wn.markComponentErrored == "function" && Wn.markComponentErrored(g, d, G);
    }
    function cC(g, d, G) {
      Wn !== null && typeof Wn.markComponentSuspended == "function" && Wn.markComponentSuspended(g, d, G);
    }
    function pa(g) {
      Wn !== null && typeof Wn.markLayoutEffectsStarted == "function" && Wn.markLayoutEffectsStarted(g);
    }
    function rc() {
      Wn !== null && typeof Wn.markLayoutEffectsStopped == "function" && Wn.markLayoutEffectsStopped();
    }
    function gC(g) {
      Wn !== null && typeof Wn.markPassiveEffectsStarted == "function" && Wn.markPassiveEffectsStarted(g);
    }
    function Mu() {
      Wn !== null && typeof Wn.markPassiveEffectsStopped == "function" && Wn.markPassiveEffectsStopped();
    }
    function si(g) {
      Wn !== null && typeof Wn.markRenderStarted == "function" && Wn.markRenderStarted(g);
    }
    function Oi() {
      Wn !== null && typeof Wn.markRenderYielded == "function" && Wn.markRenderYielded();
    }
    function ir() {
      Wn !== null && typeof Wn.markRenderStopped == "function" && Wn.markRenderStopped();
    }
    function Xi(g) {
      Wn !== null && typeof Wn.markRenderScheduled == "function" && Wn.markRenderScheduled(g);
    }
    function Xr(g, d) {
      Wn !== null && typeof Wn.markForceUpdateScheduled == "function" && Wn.markForceUpdateScheduled(g, d);
    }
    function fr(g, d) {
      Wn !== null && typeof Wn.markStateUpdateScheduled == "function" && Wn.markStateUpdateScheduled(g, d);
    }
    function ac(g, d) {
      return g === d && (g !== 0 || 1 / g === 1 / d) || g !== g && d !== d;
    }
    var ca = typeof Object.is == "function" ? Object.is : ac, Vs = null, jo = !1, Ht = !1;
    function Fa(g) {
      Vs === null ? Vs = [g] : Vs.push(g);
    }
    function Ai(g) {
      jo = !0, Fa(g);
    }
    function Vg() {
      jo && br();
    }
    function br() {
      if (!Ht && Vs !== null) {
        Ht = !0;
        var g = 0, d = wl();
        try {
          var G = !0, w = Vs;
          for (ro(Za); g < w.length; g++) {
            var H = w[g];
            do
              H = H(G);
            while (H !== null);
          }
          Vs = null, jo = !1;
        } catch (z) {
          throw Vs !== null && (Vs = Vs.slice(g + 1)), Gd(el, br), z;
        } finally {
          ro(d), Ht = !1;
        }
      }
      return null;
    }
    function xo(g) {
      var d = g.current.memoizedState;
      return d.isDehydrated;
    }
    var tl = l.ReactCurrentBatchConfig, Ng = null;
    function Rl() {
      return tl.transition;
    }
    function Ec(g, d) {
      if (ca(g, d))
        return !0;
      if (typeof g != "object" || g === null || typeof d != "object" || d === null)
        return !1;
      var G = Object.keys(g), w = Object.keys(d);
      if (G.length !== w.length)
        return !1;
      for (var H = 0; H < G.length; H++) {
        var z = G[H];
        if (!js.call(d, z) || !ca(g[z], d[z]))
          return !1;
      }
      return !0;
    }
    function hh(g) {
      switch (g._debugOwner && g._debugOwner.type, g._debugSource, g.tag) {
        case ne:
          return Pl(g.type);
        case Ye:
          return Pl("Lazy");
        case Se:
          return Pl("Suspense");
        case Je:
          return Pl("SuspenseList");
        case D:
        case j:
        case le:
          return bu(g.type);
        case Xe:
          return bu(g.type.render);
        case L:
          return Cf(g.type);
        default:
          return "";
      }
    }
    function wI(g) {
      try {
        var d = "", G = g;
        do
          d += hh(G), G = G.return;
        while (G);
        return d;
      } catch (w) {
        return `
Error generating stack: ` + w.message + `
` + w.stack;
      }
    }
    var Sd = l.ReactDebugCurrentFrame, nl = null, Zd = !1;
    function fh() {
      {
        if (nl === null)
          return null;
        var g = nl._debugOwner;
        if (g !== null && typeof g < "u")
          return qe(g);
      }
      return null;
    }
    function ph() {
      return nl === null ? "" : wI(nl);
    }
    function ra() {
      Sd.getCurrentStack = null, nl = null, Zd = !1;
    }
    function so(g) {
      Sd.getCurrentStack = ph, nl = g, Zd = !1;
    }
    function lo(g) {
      Zd = g;
    }
    var cs = {
      recordUnsafeLifecycleWarnings: function(g, d) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(g, d) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var gs = function(g) {
        for (var d = null, G = g; G !== null; )
          G.mode & La && (d = G), G = G.return;
        return d;
      }, oc = function(g) {
        var d = [];
        return g.forEach(function(G) {
          d.push(G);
        }), d.sort().join(", ");
      }, Mg = [], wd = [], Hg = [], Hu = [], Tc = [], Rd = [], uo = /* @__PURE__ */ new Set();
      cs.recordUnsafeLifecycleWarnings = function(g, d) {
        uo.has(g.type) || (typeof d.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        d.componentWillMount.__suppressDeprecationWarning !== !0 && Mg.push(g), g.mode & La && typeof d.UNSAFE_componentWillMount == "function" && wd.push(g), typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Hg.push(g), g.mode & La && typeof d.UNSAFE_componentWillReceiveProps == "function" && Hu.push(g), typeof d.componentWillUpdate == "function" && d.componentWillUpdate.__suppressDeprecationWarning !== !0 && Tc.push(g), g.mode & La && typeof d.UNSAFE_componentWillUpdate == "function" && Rd.push(g));
      }, cs.flushPendingUnsafeLifecycleWarnings = function() {
        var g = /* @__PURE__ */ new Set();
        Mg.length > 0 && (Mg.forEach(function(Zt) {
          g.add(qe(Zt) || "Component"), uo.add(Zt.type);
        }), Mg = []);
        var d = /* @__PURE__ */ new Set();
        wd.length > 0 && (wd.forEach(function(Zt) {
          d.add(qe(Zt) || "Component"), uo.add(Zt.type);
        }), wd = []);
        var G = /* @__PURE__ */ new Set();
        Hg.length > 0 && (Hg.forEach(function(Zt) {
          G.add(qe(Zt) || "Component"), uo.add(Zt.type);
        }), Hg = []);
        var w = /* @__PURE__ */ new Set();
        Hu.length > 0 && (Hu.forEach(function(Zt) {
          w.add(qe(Zt) || "Component"), uo.add(Zt.type);
        }), Hu = []);
        var H = /* @__PURE__ */ new Set();
        Tc.length > 0 && (Tc.forEach(function(Zt) {
          H.add(qe(Zt) || "Component"), uo.add(Zt.type);
        }), Tc = []);
        var z = /* @__PURE__ */ new Set();
        if (Rd.length > 0 && (Rd.forEach(function(Zt) {
          z.add(qe(Zt) || "Component"), uo.add(Zt.type);
        }), Rd = []), d.size > 0) {
          var q = oc(d);
          f(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, q);
        }
        if (w.size > 0) {
          var ee = oc(w);
          f(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, ee);
        }
        if (z.size > 0) {
          var ue = oc(z);
          f(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, ue);
        }
        if (g.size > 0) {
          var Ze = oc(g);
          C(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ze);
        }
        if (G.size > 0) {
          var _e = oc(G);
          C(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _e);
        }
        if (H.size > 0) {
          var st = oc(H);
          C(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, st);
        }
      };
      var Xg = /* @__PURE__ */ new Map(), Rp = /* @__PURE__ */ new Set();
      cs.recordLegacyContextWarning = function(g, d) {
        var G = gs(g);
        if (G === null) {
          f("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Rp.has(g.type)) {
          var w = Xg.get(G);
          (g.type.contextTypes != null || g.type.childContextTypes != null || d !== null && typeof d.getChildContext == "function") && (w === void 0 && (w = [], Xg.set(G, w)), w.push(g));
        }
      }, cs.flushLegacyContextWarning = function() {
        Xg.forEach(function(g, d) {
          if (g.length !== 0) {
            var G = g[0], w = /* @__PURE__ */ new Set();
            g.forEach(function(z) {
              w.add(qe(z) || "Component"), Rp.add(z.type);
            });
            var H = oc(w);
            try {
              so(G), f(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, H);
            } finally {
              ra();
            }
          }
        });
      }, cs.discardPendingWarnings = function() {
        Mg = [], wd = [], Hg = [], Hu = [], Tc = [], Rd = [], Xg = /* @__PURE__ */ new Map();
      };
    }
    function xl(g) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, G = d && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function dC(g) {
      try {
        return iu(g), !1;
      } catch {
        return !0;
      }
    }
    function iu(g) {
      return "" + g;
    }
    function sc(g) {
      if (dC(g))
        return f("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", xl(g)), iu(g);
    }
    function il(g, d) {
      if (dC(g))
        return f("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", d, xl(g)), iu(g);
    }
    function Wl(g, d) {
      if (g && g.defaultProps) {
        var G = b({}, d), w = g.defaultProps;
        for (var H in w)
          G[H] === void 0 && (G[H] = w[H]);
        return G;
      }
      return d;
    }
    var Nr = Tr(null), Yg;
    Yg = {};
    var xd = null, lc = null, ds = null, Wd = !1;
    function RI() {
      xd = null, lc = null, ds = null, Wd = !1;
    }
    function xp() {
      Wd = !0;
    }
    function m() {
      Wd = !1;
    }
    function A(g, d, G) {
      Pu ? (Dr(Nr, d._currentValue, g), d._currentValue = G, d._currentRenderer !== void 0 && d._currentRenderer !== null && d._currentRenderer !== Yg && f("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), d._currentRenderer = Yg) : (Dr(Nr, d._currentValue2, g), d._currentValue2 = G, d._currentRenderer2 !== void 0 && d._currentRenderer2 !== null && d._currentRenderer2 !== Yg && f("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), d._currentRenderer2 = Yg);
    }
    function V(g, d) {
      var G = Nr.current;
      yo(Nr, d), Pu ? g._currentValue = G : g._currentValue2 = G;
    }
    function E(g, d, G) {
      for (var w = g; w !== null; ) {
        var H = w.alternate;
        if (Ua(w.childLanes, d) ? H !== null && !Ua(H.childLanes, d) && (H.childLanes = Wi(H.childLanes, d)) : (w.childLanes = Wi(w.childLanes, d), H !== null && (H.childLanes = Wi(H.childLanes, d))), w === G)
          break;
        w = w.return;
      }
      w !== G && f("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function k(g, d, G) {
      $(g, d, G);
    }
    function $(g, d, G) {
      var w = g.child;
      for (w !== null && (w.return = g); w !== null; ) {
        var H = void 0, z = w.dependencies;
        if (z !== null) {
          H = w.child;
          for (var q = z.firstContext; q !== null; ) {
            if (q.context === d) {
              if (w.tag === L) {
                var ee = Yc(G), ue = Sn(yr, ee);
                ue.tag = Yi;
                var Ze = w.updateQueue;
                if (Ze !== null) {
                  var _e = Ze.shared, st = _e.pending;
                  st === null ? ue.next = ue : (ue.next = st.next, st.next = ue), _e.pending = ue;
                }
              }
              w.lanes = Wi(w.lanes, G);
              var Zt = w.alternate;
              Zt !== null && (Zt.lanes = Wi(Zt.lanes, G)), E(w.return, G, g), z.lanes = Wi(z.lanes, G);
              break;
            }
            q = q.next;
          }
        } else if (w.tag === Re)
          H = w.type === g.type ? null : w.child;
        else if (w.tag === ze) {
          var Xt = w.return;
          if (Xt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Xt.lanes = Wi(Xt.lanes, G);
          var nn = Xt.alternate;
          nn !== null && (nn.lanes = Wi(nn.lanes, G)), E(Xt, G, g), H = w.sibling;
        } else
          H = w.child;
        if (H !== null)
          H.return = w;
        else
          for (H = w; H !== null; ) {
            if (H === g) {
              H = null;
              break;
            }
            var Cn = H.sibling;
            if (Cn !== null) {
              Cn.return = H.return, H = Cn;
              break;
            }
            H = H.return;
          }
        w = H;
      }
    }
    function ve(g, d) {
      xd = g, lc = null, ds = null;
      var G = g.dependencies;
      if (G !== null) {
        var w = G.firstContext;
        w !== null && (xs(G.lanes, d) && Ff(), G.firstContext = null);
      }
    }
    function Ke(g) {
      Wd && f("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var d = Pu ? g._currentValue : g._currentValue2;
      if (ds !== g) {
        var G = {
          context: g,
          memoizedValue: d,
          next: null
        };
        if (lc === null) {
          if (xd === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          lc = G, xd.dependencies = {
            lanes: Qt,
            firstContext: G
          };
        } else
          lc = lc.next = G;
      }
      return d;
    }
    var Rt = null;
    function In(g) {
      Rt === null ? Rt = [g] : Rt.push(g);
    }
    function $n() {
      if (Rt !== null) {
        for (var g = 0; g < Rt.length; g++) {
          var d = Rt[g], G = d.interleaved;
          if (G !== null) {
            d.interleaved = null;
            var w = G.next, H = d.pending;
            if (H !== null) {
              var z = H.next;
              H.next = w, G.next = z;
            }
            d.pending = G;
          }
        }
        Rt = null;
      }
    }
    var zi = 0, ci = 1, Yi = 2, wn = 3, Oa = !1, ga, ot;
    ga = !1, ot = null;
    function Fe(g) {
      var d = {
        baseState: g.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Qt
        },
        effects: null
      };
      g.updateQueue = d;
    }
    function bt(g, d) {
      var G = d.updateQueue, w = g.updateQueue;
      if (G === w) {
        var H = {
          baseState: w.baseState,
          firstBaseUpdate: w.firstBaseUpdate,
          lastBaseUpdate: w.lastBaseUpdate,
          shared: w.shared,
          effects: w.effects
        };
        d.updateQueue = H;
      }
    }
    function Sn(g, d) {
      var G = {
        eventTime: g,
        lane: d,
        tag: zi,
        payload: null,
        callback: null,
        next: null
      };
      return G;
    }
    function ei(g, d, G) {
      var w = g.updateQueue;
      if (w !== null) {
        var H = w.shared;
        if (Im(g)) {
          var z = H.interleaved;
          z === null ? (d.next = d, In(H)) : (d.next = z.next, z.next = d), H.interleaved = d;
        } else {
          var q = H.pending;
          q === null ? d.next = d : (d.next = q.next, q.next = d), H.pending = d;
        }
        ot === H && !ga && (f("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), ga = !0);
      }
    }
    function Ki(g, d, G) {
      var w = d.updateQueue;
      if (w !== null) {
        var H = w.shared;
        if (oC(G)) {
          var z = H.lanes;
          z = bI(z, g.pendingLanes);
          var q = Wi(z, G);
          H.lanes = q, dh(g, q);
        }
      }
    }
    function Vi(g, d) {
      var G = g.updateQueue, w = g.alternate;
      if (w !== null) {
        var H = w.updateQueue;
        if (G === H) {
          var z = null, q = null, ee = G.firstBaseUpdate;
          if (ee !== null) {
            var ue = ee;
            do {
              var Ze = {
                eventTime: ue.eventTime,
                lane: ue.lane,
                tag: ue.tag,
                payload: ue.payload,
                callback: ue.callback,
                next: null
              };
              q === null ? z = q = Ze : (q.next = Ze, q = Ze), ue = ue.next;
            } while (ue !== null);
            q === null ? z = q = d : (q.next = d, q = d);
          } else
            z = q = d;
          G = {
            baseState: H.baseState,
            firstBaseUpdate: z,
            lastBaseUpdate: q,
            shared: H.shared,
            effects: H.effects
          }, g.updateQueue = G;
          return;
        }
      }
      var _e = G.lastBaseUpdate;
      _e === null ? G.firstBaseUpdate = d : _e.next = d, G.lastBaseUpdate = d;
    }
    function cr(g, d, G, w, H, z) {
      switch (G.tag) {
        case ci: {
          var q = G.payload;
          if (typeof q == "function") {
            xp();
            var ee = q.call(z, w, H);
            {
              if (g.mode & La) {
                ri(!0);
                try {
                  q.call(z, w, H);
                } finally {
                  ri(!1);
                }
              }
              m();
            }
            return ee;
          }
          return q;
        }
        case wn:
          g.flags = g.flags & -65537 | Jn;
        // Intentional fallthrough
        case zi: {
          var ue = G.payload, Ze;
          if (typeof ue == "function") {
            xp(), Ze = ue.call(z, w, H);
            {
              if (g.mode & La) {
                ri(!0);
                try {
                  ue.call(z, w, H);
                } finally {
                  ri(!1);
                }
              }
              m();
            }
          } else
            Ze = ue;
          return Ze == null ? w : b({}, w, Ze);
        }
        case Yi:
          return Oa = !0, w;
      }
      return w;
    }
    function Ea(g, d, G, w) {
      var H = g.updateQueue;
      Oa = !1, ot = H.shared;
      var z = H.firstBaseUpdate, q = H.lastBaseUpdate, ee = H.shared.pending;
      if (ee !== null) {
        H.shared.pending = null;
        var ue = ee, Ze = ue.next;
        ue.next = null, q === null ? z = Ze : q.next = Ze, q = ue;
        var _e = g.alternate;
        if (_e !== null) {
          var st = _e.updateQueue, Zt = st.lastBaseUpdate;
          Zt !== q && (Zt === null ? st.firstBaseUpdate = Ze : Zt.next = Ze, st.lastBaseUpdate = ue);
        }
      }
      if (z !== null) {
        var Xt = H.baseState, nn = Qt, Cn = null, yi = null, rr = null, Ni = z;
        do {
          var Ja = Ni.lane, Qa = Ni.eventTime;
          if (Ua(w, Ja)) {
            if (rr !== null) {
              var zt = {
                eventTime: Qa,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: no,
                tag: Ni.tag,
                payload: Ni.payload,
                callback: Ni.callback,
                next: null
              };
              rr = rr.next = zt;
            }
            Xt = cr(g, H, Ni, Xt, d, G);
            var dt = Ni.callback;
            if (dt !== null && // If the update was already committed, we should not queue its
            // callback again.
            Ni.lane !== no) {
              g.flags |= Di;
              var ln = H.effects;
              ln === null ? H.effects = [Ni] : ln.push(Ni);
            }
          } else {
            var Ct = {
              eventTime: Qa,
              lane: Ja,
              tag: Ni.tag,
              payload: Ni.payload,
              callback: Ni.callback,
              next: null
            };
            rr === null ? (yi = rr = Ct, Cn = Xt) : rr = rr.next = Ct, nn = Wi(nn, Ja);
          }
          if (Ni = Ni.next, Ni === null) {
            if (ee = H.shared.pending, ee === null)
              break;
            var gi = ee, Mn = gi.next;
            gi.next = null, Ni = Mn, H.lastBaseUpdate = gi, H.shared.pending = null;
          }
        } while (!0);
        rr === null && (Cn = Xt), H.baseState = Cn, H.firstBaseUpdate = yi, H.lastBaseUpdate = rr;
        var mr = H.shared.interleaved;
        if (mr !== null) {
          var Pr = mr;
          do
            nn = Wi(nn, Pr.lane), Pr = Pr.next;
          while (Pr !== mr);
        } else z === null && (H.shared.lanes = Qt);
        EA(nn), g.lanes = nn, g.memoizedState = Xt;
      }
      ot = null;
    }
    function pr(g, d) {
      if (typeof g != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + g));
      g.call(d);
    }
    function _c() {
      Oa = !1;
    }
    function Vd() {
      return Oa;
    }
    function Wp(g, d, G) {
      var w = d.effects;
      if (d.effects = null, w !== null)
        for (var H = 0; H < w.length; H++) {
          var z = w[H], q = z.callback;
          q !== null && (z.callback = null, pr(q, G));
        }
    }
    var tA = {}, nA = new i.Component().refs, mf, Vl, Xu, Is, Af, mh, Nl, zo, iA, Ah;
    {
      mf = /* @__PURE__ */ new Set(), Vl = /* @__PURE__ */ new Set(), Xu = /* @__PURE__ */ new Set(), Is = /* @__PURE__ */ new Set(), zo = /* @__PURE__ */ new Set(), Af = /* @__PURE__ */ new Set(), iA = /* @__PURE__ */ new Set(), Ah = /* @__PURE__ */ new Set();
      var rl = /* @__PURE__ */ new Set();
      Nl = function(g, d) {
        if (!(g === null || typeof g == "function")) {
          var G = d + "_" + g;
          rl.has(G) || (rl.add(G), f("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d, g));
        }
      }, mh = function(g, d) {
        if (d === void 0) {
          var G = ht(g) || "Component";
          Af.has(G) || (Af.add(G), f("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", G));
        }
      }, Object.defineProperty(tA, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(tA);
    }
    function Vp(g, d, G, w) {
      var H = g.memoizedState, z = G(w, H);
      {
        if (g.mode & La) {
          ri(!0);
          try {
            z = G(w, H);
          } finally {
            ri(!1);
          }
        }
        mh(d, z);
      }
      var q = z == null ? H : b({}, H, z);
      if (g.memoizedState = q, g.lanes === Qt) {
        var ee = g.updateQueue;
        ee.baseState = q;
      }
    }
    var rA = {
      isMounted: rn,
      enqueueSetState: function(g, d, G) {
        var w = S(g), H = zu(), z = Eh(w), q = Sn(H, z);
        q.payload = d, G != null && (Nl(G, "setState"), q.callback = G), ei(w, q);
        var ee = fs(w, z, H);
        ee !== null && Ki(ee, w, z), fr(w, z);
      },
      enqueueReplaceState: function(g, d, G) {
        var w = S(g), H = zu(), z = Eh(w), q = Sn(H, z);
        q.tag = ci, q.payload = d, G != null && (Nl(G, "replaceState"), q.callback = G), ei(w, q);
        var ee = fs(w, z, H);
        ee !== null && Ki(ee, w, z), fr(w, z);
      },
      enqueueForceUpdate: function(g, d) {
        var G = S(g), w = zu(), H = Eh(G), z = Sn(w, H);
        z.tag = Yi, d != null && (Nl(d, "forceUpdate"), z.callback = d), ei(G, z);
        var q = fs(G, H, w);
        q !== null && Ki(q, G, H), Xr(G, H);
      }
    };
    function IC(g, d, G, w, H, z, q) {
      var ee = g.stateNode;
      if (typeof ee.shouldComponentUpdate == "function") {
        var ue = ee.shouldComponentUpdate(w, z, q);
        {
          if (g.mode & La) {
            ri(!0);
            try {
              ue = ee.shouldComponentUpdate(w, z, q);
            } finally {
              ri(!1);
            }
          }
          ue === void 0 && f("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", ht(d) || "Component");
        }
        return ue;
      }
      return d.prototype && d.prototype.isPureReactComponent ? !Ec(G, w) || !Ec(H, z) : !0;
    }
    function al(g, d, G) {
      var w = g.stateNode;
      {
        var H = ht(d) || "Component", z = w.render;
        z || (d.prototype && typeof d.prototype.render == "function" ? f("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", H) : f("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", H)), w.getInitialState && !w.getInitialState.isReactClassApproved && !w.state && f("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", H), w.getDefaultProps && !w.getDefaultProps.isReactClassApproved && f("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", H), w.propTypes && f("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", H), w.contextType && f("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", H), w.contextTypes && f("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", H), d.contextType && d.contextTypes && !iA.has(d) && (iA.add(d), f("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", H)), typeof w.componentShouldUpdate == "function" && f("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", H), d.prototype && d.prototype.isPureReactComponent && typeof w.shouldComponentUpdate < "u" && f("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", ht(d) || "A pure component"), typeof w.componentDidUnmount == "function" && f("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", H), typeof w.componentDidReceiveProps == "function" && f("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", H), typeof w.componentWillRecieveProps == "function" && f("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", H), typeof w.UNSAFE_componentWillRecieveProps == "function" && f("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", H);
        var q = w.props !== G;
        w.props !== void 0 && q && f("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", H, H), w.defaultProps && f("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", H, H), typeof w.getSnapshotBeforeUpdate == "function" && typeof w.componentDidUpdate != "function" && !Xu.has(d) && (Xu.add(d), f("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", ht(d))), typeof w.getDerivedStateFromProps == "function" && f("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", H), typeof w.getDerivedStateFromError == "function" && f("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", H), typeof d.getSnapshotBeforeUpdate == "function" && f("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", H);
        var ee = w.state;
        ee && (typeof ee != "object" || Xn(ee)) && f("%s.state: must be set to an object or null", H), typeof w.getChildContext == "function" && typeof d.childContextTypes != "object" && f("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", H);
      }
    }
    function Tb(g, d) {
      d.updater = rA, g.stateNode = d, R(d, g), d._reactInternalInstance = tA;
    }
    function ti(g, d, G) {
      var w = !1, H = os, z = os, q = d.contextType;
      if ("contextType" in d) {
        var ee = (
          // Allow null for conditional declaration
          q === null || q !== void 0 && q.$$typeof === bn && q._context === void 0
        );
        if (!ee && !Ah.has(d)) {
          Ah.add(d);
          var ue = "";
          q === void 0 ? ue = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof q != "object" ? ue = " However, it is set to a " + typeof q + "." : q.$$typeof === ft ? ue = " Did you accidentally pass the Context.Provider instead?" : q._context !== void 0 ? ue = " Did you accidentally pass the Context.Consumer instead?" : ue = " However, it is set to an object with keys {" + Object.keys(q).join(", ") + "}.", f("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", ht(d) || "Component", ue);
        }
      }
      if (typeof q == "object" && q !== null)
        z = Ke(q);
      else {
        H = fa(g, d, !0);
        var Ze = d.contextTypes;
        w = Ze != null, z = w ? yl(g, H) : os;
      }
      var _e = new d(G, z);
      if (g.mode & La) {
        ri(!0);
        try {
          _e = new d(G, z);
        } finally {
          ri(!1);
        }
      }
      var st = g.memoizedState = _e.state !== null && _e.state !== void 0 ? _e.state : null;
      Tb(g, _e);
      {
        if (typeof d.getDerivedStateFromProps == "function" && st === null) {
          var Zt = ht(d) || "Component";
          Vl.has(Zt) || (Vl.add(Zt), f("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Zt, _e.state === null ? "null" : "undefined", Zt));
        }
        if (typeof d.getDerivedStateFromProps == "function" || typeof _e.getSnapshotBeforeUpdate == "function") {
          var Xt = null, nn = null, Cn = null;
          if (typeof _e.componentWillMount == "function" && _e.componentWillMount.__suppressDeprecationWarning !== !0 ? Xt = "componentWillMount" : typeof _e.UNSAFE_componentWillMount == "function" && (Xt = "UNSAFE_componentWillMount"), typeof _e.componentWillReceiveProps == "function" && _e.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? nn = "componentWillReceiveProps" : typeof _e.UNSAFE_componentWillReceiveProps == "function" && (nn = "UNSAFE_componentWillReceiveProps"), typeof _e.componentWillUpdate == "function" && _e.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Cn = "componentWillUpdate" : typeof _e.UNSAFE_componentWillUpdate == "function" && (Cn = "UNSAFE_componentWillUpdate"), Xt !== null || nn !== null || Cn !== null) {
            var yi = ht(d) || "Component", rr = typeof d.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Is.has(yi) || (Is.add(yi), f(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, yi, rr, Xt !== null ? `
  ` + Xt : "", nn !== null ? `
  ` + nn : "", Cn !== null ? `
  ` + Cn : ""));
          }
        }
      }
      return w && bo(g, H, z), _e;
    }
    function CC(g, d) {
      var G = d.state;
      typeof d.componentWillMount == "function" && d.componentWillMount(), typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(), G !== d.state && (f("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", qe(g) || "Component"), rA.enqueueReplaceState(d, d.state, null));
    }
    function aA(g, d, G, w) {
      var H = d.state;
      if (typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(G, w), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(G, w), d.state !== H) {
        {
          var z = qe(g) || "Component";
          mf.has(z) || (mf.add(z), f("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", z));
        }
        rA.enqueueReplaceState(d, d.state, null);
      }
    }
    function Np(g, d, G, w) {
      al(g, d, G);
      var H = g.stateNode;
      H.props = G, H.state = g.memoizedState, H.refs = nA, Fe(g);
      var z = d.contextType;
      if (typeof z == "object" && z !== null)
        H.context = Ke(z);
      else {
        var q = fa(g, d, !0);
        H.context = yl(g, q);
      }
      {
        if (H.state === G) {
          var ee = ht(d) || "Component";
          zo.has(ee) || (zo.add(ee), f("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", ee));
        }
        g.mode & La && cs.recordLegacyContextWarning(g, H), cs.recordUnsafeLifecycleWarnings(g, H);
      }
      H.state = g.memoizedState;
      var ue = d.getDerivedStateFromProps;
      if (typeof ue == "function" && (Vp(g, d, ue, G), H.state = g.memoizedState), typeof d.getDerivedStateFromProps != "function" && typeof H.getSnapshotBeforeUpdate != "function" && (typeof H.UNSAFE_componentWillMount == "function" || typeof H.componentWillMount == "function") && (CC(g, H), Ea(g, G, H, w), H.state = g.memoizedState), typeof H.componentDidMount == "function") {
        var Ze = et;
        Ze |= Gt, (g.mode & ql) !== wi && (Ze |= ae), g.flags |= Ze;
      }
    }
    function HB(g, d, G, w) {
      var H = g.stateNode, z = g.memoizedProps;
      H.props = z;
      var q = H.context, ee = d.contextType, ue = os;
      if (typeof ee == "object" && ee !== null)
        ue = Ke(ee);
      else {
        var Ze = fa(g, d, !0);
        ue = yl(g, Ze);
      }
      var _e = d.getDerivedStateFromProps, st = typeof _e == "function" || typeof H.getSnapshotBeforeUpdate == "function";
      !st && (typeof H.UNSAFE_componentWillReceiveProps == "function" || typeof H.componentWillReceiveProps == "function") && (z !== G || q !== ue) && aA(g, H, G, ue), _c();
      var Zt = g.memoizedState, Xt = H.state = Zt;
      if (Ea(g, G, H, w), Xt = g.memoizedState, z === G && Zt === Xt && !Ql() && !Vd()) {
        if (typeof H.componentDidMount == "function") {
          var nn = et;
          nn |= Gt, (g.mode & ql) !== wi && (nn |= ae), g.flags |= nn;
        }
        return !1;
      }
      typeof _e == "function" && (Vp(g, d, _e, G), Xt = g.memoizedState);
      var Cn = Vd() || IC(g, d, z, G, Zt, Xt, ue);
      if (Cn) {
        if (!st && (typeof H.UNSAFE_componentWillMount == "function" || typeof H.componentWillMount == "function") && (typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount()), typeof H.componentDidMount == "function") {
          var yi = et;
          yi |= Gt, (g.mode & ql) !== wi && (yi |= ae), g.flags |= yi;
        }
      } else {
        if (typeof H.componentDidMount == "function") {
          var rr = et;
          rr |= Gt, (g.mode & ql) !== wi && (rr |= ae), g.flags |= rr;
        }
        g.memoizedProps = G, g.memoizedState = Xt;
      }
      return H.props = G, H.state = Xt, H.context = ue, Cn;
    }
    function vf(g, d, G, w, H) {
      var z = d.stateNode;
      bt(g, d);
      var q = d.memoizedProps, ee = d.type === d.elementType ? q : Wl(d.type, q);
      z.props = ee;
      var ue = d.pendingProps, Ze = z.context, _e = G.contextType, st = os;
      if (typeof _e == "object" && _e !== null)
        st = Ke(_e);
      else {
        var Zt = fa(d, G, !0);
        st = yl(d, Zt);
      }
      var Xt = G.getDerivedStateFromProps, nn = typeof Xt == "function" || typeof z.getSnapshotBeforeUpdate == "function";
      !nn && (typeof z.UNSAFE_componentWillReceiveProps == "function" || typeof z.componentWillReceiveProps == "function") && (q !== ue || Ze !== st) && aA(d, z, w, st), _c();
      var Cn = d.memoizedState, yi = z.state = Cn;
      if (Ea(d, w, z, H), yi = d.memoizedState, q === ue && Cn === yi && !Ql() && !Vd())
        return typeof z.componentDidUpdate == "function" && (q !== g.memoizedProps || Cn !== g.memoizedState) && (d.flags |= et), typeof z.getSnapshotBeforeUpdate == "function" && (q !== g.memoizedProps || Cn !== g.memoizedState) && (d.flags |= xr), !1;
      typeof Xt == "function" && (Vp(d, G, Xt, w), yi = d.memoizedState);
      var rr = Vd() || IC(d, G, ee, w, Cn, yi, st) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      x;
      return rr ? (!nn && (typeof z.UNSAFE_componentWillUpdate == "function" || typeof z.componentWillUpdate == "function") && (typeof z.componentWillUpdate == "function" && z.componentWillUpdate(w, yi, st), typeof z.UNSAFE_componentWillUpdate == "function" && z.UNSAFE_componentWillUpdate(w, yi, st)), typeof z.componentDidUpdate == "function" && (d.flags |= et), typeof z.getSnapshotBeforeUpdate == "function" && (d.flags |= xr)) : (typeof z.componentDidUpdate == "function" && (q !== g.memoizedProps || Cn !== g.memoizedState) && (d.flags |= et), typeof z.getSnapshotBeforeUpdate == "function" && (q !== g.memoizedProps || Cn !== g.memoizedState) && (d.flags |= xr), d.memoizedProps = w, d.memoizedState = yi), z.props = w, z.state = yi, z.context = st, rr;
    }
    var xI = [], WI = 0, Mp = null, vh = 0, Ml = [], Ko = 0, Hl = null, Kr = 1, co = "";
    function zc(g) {
      return fC(), (g.flags & tt) !== de;
    }
    function VI(g) {
      return fC(), vh;
    }
    function _b() {
      var g = co, d = Kr, G = d & ~zb(d);
      return G.toString(32) + g;
    }
    function ol(g, d) {
      fC(), xI[WI++] = vh, xI[WI++] = Mp, Mp = g, vh = d;
    }
    function Vv(g, d, G) {
      fC(), Ml[Ko++] = Kr, Ml[Ko++] = co, Ml[Ko++] = Hl, Hl = g;
      var w = Kr, H = co, z = hC(w) - 1, q = w & ~(1 << z), ee = G + 1, ue = hC(d) + z;
      if (ue > 30) {
        var Ze = z - z % 5, _e = (1 << Ze) - 1, st = (q & _e).toString(32), Zt = q >> Ze, Xt = z - Ze, nn = hC(d) + Xt, Cn = ee << Xt, yi = Cn | Zt, rr = st + H;
        Kr = 1 << nn | yi, co = rr;
      } else {
        var Ni = ee << z, Ja = Ni | q, Qa = H;
        Kr = 1 << ue | Ja, co = Qa;
      }
    }
    function uc(g) {
      fC();
      var d = g.return;
      if (d !== null) {
        var G = 1, w = 0;
        ol(g, G), Vv(g, G, w);
      }
    }
    function hC(g) {
      return 32 - Bu(g);
    }
    function zb(g) {
      return 1 << hC(g) - 1;
    }
    function Hp(g) {
      for (; g === Mp; )
        Mp = xI[--WI], xI[WI] = null, vh = xI[--WI], xI[WI] = null;
      for (; g === Hl; )
        Hl = Ml[--Ko], Ml[Ko] = null, co = Ml[--Ko], Ml[Ko] = null, Kr = Ml[--Ko], Ml[Ko] = null;
    }
    function Kb() {
      return fC(), Hl !== null ? {
        id: Kr,
        overflow: co
      } : null;
    }
    function Xp(g, d) {
      fC(), Ml[Ko++] = Kr, Ml[Ko++] = co, Ml[Ko++] = Hl, Kr = d.id, co = d.overflow, Hl = g;
    }
    function fC() {
      Wo() || f("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var qo = null, Ns = null, Va = !1, Qi = !1, wa = null;
    function Lo() {
      Va && f("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function sl() {
      Qi = !0;
    }
    function cc(g) {
      if (!Hi)
        return !1;
      var d = g.stateNode.containerInfo;
      return Ns = kr(d), qo = g, Va = !0, wa = null, Qi = !1, !0;
    }
    function yf(g, d, G) {
      return Hi ? (Ns = Ka(d), qo = g, Va = !0, wa = null, Qi = !1, G !== null && Xp(g, G), !0) : !1;
    }
    function $o(g, d) {
      switch (g.tag) {
        case J:
          yp(g.stateNode.containerInfo, d);
          break;
        case ne:
          qI(g.type, g.memoizedProps, g.stateNode, d);
          break;
        case Se:
          var G = g.memoizedState;
          G.dehydrated !== null && uf(G.dehydrated, d);
          break;
      }
    }
    function pC(g, d) {
      $o(g, d);
      var G = px();
      G.stateNode = d, G.return = g;
      var w = g.deletions;
      w === null ? (g.deletions = [G], g.flags |= Kn) : w.push(G);
    }
    function NI(g, d) {
      {
        if (Qi)
          return;
        switch (g.tag) {
          case J: {
            var G = g.stateNode.containerInfo;
            switch (d.tag) {
              case ne:
                var w = d.type, H = d.pendingProps;
                Ss(G, w, H);
                break;
              case he:
                var z = d.pendingProps;
                cf(G, z);
                break;
              case Se:
                $I(G);
                break;
            }
            break;
          }
          case ne: {
            var q = g.type, ee = g.memoizedProps, ue = g.stateNode;
            switch (d.tag) {
              case ne:
                var Ze = d.type, _e = d.pendingProps;
                vu(q, ee, ue, Ze, _e);
                break;
              case he:
                var st = d.pendingProps;
                xc(q, ee, ue, st);
                break;
              case Se:
                vo(q, ee, ue);
                break;
            }
            break;
          }
          case Se: {
            var Zt = g.memoizedState, Xt = Zt.dehydrated;
            if (Xt !== null) switch (d.tag) {
              case ne:
                var nn = d.type, Cn = d.pendingProps;
                ml(Xt, nn, Cn);
                break;
              case he:
                var yi = d.pendingProps;
                Qs(Xt, yi);
                break;
              case Se:
                fI(Xt);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function mC(g, d) {
      d.flags = d.flags & -4097 | je, NI(g, d);
    }
    function bf(g, d) {
      switch (g.tag) {
        case ne: {
          var G = g.type, w = g.pendingProps, H = qn(d, G, w);
          return H !== null ? (g.stateNode = H, qo = g, Ns = Zi(H), !0) : !1;
        }
        case he: {
          var z = g.pendingProps, q = _n(d, z);
          return q !== null ? (g.stateNode = q, qo = g, Ns = null, !0) : !1;
        }
        case Se: {
          {
            var ee = Si(d);
            if (ee !== null) {
              var ue = {
                dehydrated: ee,
                treeContext: Kb(),
                retryLane: Bo
              };
              g.memoizedState = ue;
              var Ze = mx(ee);
              return Ze.return = g, g.child = Ze, qo = g, Ns = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function AC(g) {
      return (g.mode & _r) !== wi && (g.flags & Jn) === de;
    }
    function Xl(g) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function Yp(g) {
      if (Va) {
        var d = Ns;
        if (!d) {
          AC(g) && (NI(qo, g), Xl()), mC(qo, g), Va = !1, qo = g;
          return;
        }
        var G = d;
        if (!bf(g, d)) {
          AC(g) && (NI(qo, g), Xl()), d = $i(G);
          var w = qo;
          if (!d || !bf(g, d)) {
            mC(qo, g), Va = !1, qo = g;
            return;
          }
          pC(w, G);
        }
      }
    }
    function Gf(g, d, G) {
      if (!Hi)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var w = g.stateNode, H = !Qi, z = Js(w, g.type, g.memoizedProps, d, G, g, H);
      return g.updateQueue = z, z !== null;
    }
    function MI(g) {
      if (!Hi)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = g.stateNode, G = g.memoizedProps, w = !Qi, H = mu(d, G, g, w);
      if (H) {
        var z = qo;
        if (z !== null) {
          var q = (z.mode & _r) !== wi;
          switch (z.tag) {
            case J: {
              var ee = z.stateNode.containerInfo;
              ah(
                ee,
                d,
                G,
                // TODO: Delete this argument when we remove the legacy root API.
                q
              );
              break;
            }
            case ne: {
              var ue = z.type, Ze = z.memoizedProps, _e = z.stateNode;
              vp(
                ue,
                Ze,
                _e,
                d,
                G,
                // TODO: Delete this argument when we remove the legacy root API.
                q
              );
              break;
            }
          }
        }
      }
      return H;
    }
    function vC(g) {
      if (!Hi)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = g.memoizedState, G = d !== null ? d.dehydrated : null;
      if (!G)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Au(G, g);
    }
    function Fp(g) {
      if (!Hi)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = g.memoizedState, G = d !== null ? d.dehydrated : null;
      if (!G)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return ud(G);
    }
    function gc(g) {
      for (var d = g.return; d !== null && d.tag !== ne && d.tag !== J && d.tag !== Se; )
        d = d.return;
      qo = d;
    }
    function yC(g) {
      if (!Hi || g !== qo)
        return !1;
      if (!Va)
        return gc(g), Va = !0, !1;
      if (g.tag !== J && (g.tag !== ne || rh(g.type) && !bs(g.type, g.memoizedProps))) {
        var d = Ns;
        if (d)
          if (AC(g))
            Bf(g), Xl();
          else
            for (; d; )
              pC(g, d), d = $i(d);
      }
      return gc(g), g.tag === Se ? Ns = Fp(g) : Ns = qo ? $i(g.stateNode) : null, !0;
    }
    function bC() {
      return Va && Ns !== null;
    }
    function Bf(g) {
      for (var d = Ns; d; )
        $o(g, d), d = $i(d);
    }
    function Fg() {
      Hi && (qo = null, Ns = null, Va = !1, Qi = !1);
    }
    function yh() {
      wa !== null && (ax(wa), wa = null);
    }
    function Wo() {
      return Va;
    }
    function bh(g) {
      wa === null ? wa = [g] : wa.push(g);
    }
    var da, ru, au, es, oA, Sf = function(g, d) {
    };
    da = !1, ru = !1, au = {}, es = {}, oA = {}, Sf = function(g, d) {
      if (!(g === null || typeof g != "object") && !(!g._store || g._store.validated || g.key != null)) {
        if (typeof g._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        g._store.validated = !0;
        var G = qe(d) || "Component";
        es[G] || (es[G] = !0, f('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function HI(g, d, G) {
      var w = G.ref;
      if (w !== null && typeof w != "function" && typeof w != "object") {
        if ((g.mode & La || Y) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(G._owner && G._self && G._owner.stateNode !== G._self)) {
          var H = qe(g) || "Component";
          au[H] || (f('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', w), au[H] = !0);
        }
        if (G._owner) {
          var z = G._owner, q;
          if (z) {
            var ee = z;
            if (ee.tag !== L)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            q = ee.stateNode;
          }
          if (!q)
            throw new Error("Missing owner for string ref " + w + ". This error is likely caused by a bug in React. Please file an issue.");
          var ue = q;
          il(w, "ref");
          var Ze = "" + w;
          if (d !== null && d.ref !== null && typeof d.ref == "function" && d.ref._stringRef === Ze)
            return d.ref;
          var _e = function(st) {
            var Zt = ue.refs;
            Zt === nA && (Zt = ue.refs = {}), st === null ? delete Zt[Ze] : Zt[Ze] = st;
          };
          return _e._stringRef = Ze, _e;
        } else {
          if (typeof w != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!G._owner)
            throw new Error("Element ref was specified as a string (" + w + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return w;
    }
    function GC(g, d) {
      var G = Object.prototype.toString.call(d);
      throw new Error("Objects are not valid as a React child (found: " + (G === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : G) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Eg(g) {
      {
        var d = qe(g) || "Component";
        if (oA[d])
          return;
        oA[d] = !0, f("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Zf(g) {
      var d = g._payload, G = g._init;
      return G(d);
    }
    function Ep(g) {
      function d(Ct, zt) {
        if (g) {
          var dt = Ct.deletions;
          dt === null ? (Ct.deletions = [zt], Ct.flags |= Kn) : dt.push(zt);
        }
      }
      function G(Ct, zt) {
        if (!g)
          return null;
        for (var dt = zt; dt !== null; )
          d(Ct, dt), dt = dt.sibling;
        return null;
      }
      function w(Ct, zt) {
        for (var dt = /* @__PURE__ */ new Map(), ln = zt; ln !== null; )
          ln.key !== null ? dt.set(ln.key, ln) : dt.set(ln.index, ln), ln = ln.sibling;
        return dt;
      }
      function H(Ct, zt) {
        var dt = Tl(Ct, zt);
        return dt.index = 0, dt.sibling = null, dt;
      }
      function z(Ct, zt, dt) {
        if (Ct.index = dt, !g)
          return Ct.flags |= tt, zt;
        var ln = Ct.alternate;
        if (ln !== null) {
          var gi = ln.index;
          return gi < zt ? (Ct.flags |= je, zt) : gi;
        } else
          return Ct.flags |= je, zt;
      }
      function q(Ct) {
        return g && Ct.alternate === null && (Ct.flags |= je), Ct;
      }
      function ee(Ct, zt, dt, ln) {
        if (zt === null || zt.tag !== he) {
          var gi = O0(dt, Ct.mode, ln);
          return gi.return = Ct, gi;
        } else {
          var Mn = H(zt, dt);
          return Mn.return = Ct, Mn;
        }
      }
      function ue(Ct, zt, dt, ln) {
        var gi = dt.type;
        if (gi === Wt)
          return _e(Ct, zt, dt.props.children, ln, dt.key);
        if (zt !== null && (zt.elementType === gi || // Keep this check inline so it only runs on the false path:
        Cx(zt, dt) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof gi == "object" && gi !== null && gi.$$typeof === $e && Zf(gi) === zt.type)) {
          var Mn = H(zt, dt.props);
          return Mn.ref = HI(Ct, zt, dt), Mn.return = Ct, Mn._debugSource = dt._source, Mn._debugOwner = dt._owner, Mn;
        }
        var mr = vy(dt, Ct.mode, ln);
        return mr.ref = HI(Ct, zt, dt), mr.return = Ct, mr;
      }
      function Ze(Ct, zt, dt, ln) {
        if (zt === null || zt.tag !== O || zt.stateNode.containerInfo !== dt.containerInfo || zt.stateNode.implementation !== dt.implementation) {
          var gi = P0(dt, Ct.mode, ln);
          return gi.return = Ct, gi;
        } else {
          var Mn = H(zt, dt.children || []);
          return Mn.return = Ct, Mn;
        }
      }
      function _e(Ct, zt, dt, ln, gi) {
        if (zt === null || zt.tag !== pe) {
          var Mn = zC(dt, Ct.mode, ln, gi);
          return Mn.return = Ct, Mn;
        } else {
          var mr = H(zt, dt);
          return mr.return = Ct, mr;
        }
      }
      function st(Ct, zt, dt) {
        if (typeof zt == "string" && zt !== "" || typeof zt == "number") {
          var ln = O0("" + zt, Ct.mode, dt);
          return ln.return = Ct, ln;
        }
        if (typeof zt == "object" && zt !== null) {
          switch (zt.$$typeof) {
            case Hn: {
              var gi = vy(zt, Ct.mode, dt);
              return gi.ref = HI(Ct, null, zt), gi.return = Ct, gi;
            }
            case ge: {
              var Mn = P0(zt, Ct.mode, dt);
              return Mn.return = Ct, Mn;
            }
            case $e: {
              var mr = zt._payload, Pr = zt._init;
              return st(Ct, Pr(mr), dt);
            }
          }
          if (Xn(zt) || He(zt)) {
            var wr = zC(zt, Ct.mode, dt, null);
            return wr.return = Ct, wr;
          }
          GC(Ct, zt);
        }
        return typeof zt == "function" && Eg(Ct), null;
      }
      function Zt(Ct, zt, dt, ln) {
        var gi = zt !== null ? zt.key : null;
        if (typeof dt == "string" && dt !== "" || typeof dt == "number")
          return gi !== null ? null : ee(Ct, zt, "" + dt, ln);
        if (typeof dt == "object" && dt !== null) {
          switch (dt.$$typeof) {
            case Hn:
              return dt.key === gi ? ue(Ct, zt, dt, ln) : null;
            case ge:
              return dt.key === gi ? Ze(Ct, zt, dt, ln) : null;
            case $e: {
              var Mn = dt._payload, mr = dt._init;
              return Zt(Ct, zt, mr(Mn), ln);
            }
          }
          if (Xn(dt) || He(dt))
            return gi !== null ? null : _e(Ct, zt, dt, ln, null);
          GC(Ct, dt);
        }
        return typeof dt == "function" && Eg(Ct), null;
      }
      function Xt(Ct, zt, dt, ln, gi) {
        if (typeof ln == "string" && ln !== "" || typeof ln == "number") {
          var Mn = Ct.get(dt) || null;
          return ee(zt, Mn, "" + ln, gi);
        }
        if (typeof ln == "object" && ln !== null) {
          switch (ln.$$typeof) {
            case Hn: {
              var mr = Ct.get(ln.key === null ? dt : ln.key) || null;
              return ue(zt, mr, ln, gi);
            }
            case ge: {
              var Pr = Ct.get(ln.key === null ? dt : ln.key) || null;
              return Ze(zt, Pr, ln, gi);
            }
            case $e: {
              var wr = ln._payload, Jr = ln._init;
              return Xt(Ct, zt, dt, Jr(wr), gi);
            }
          }
          if (Xn(ln) || He(ln)) {
            var ho = Ct.get(dt) || null;
            return _e(zt, ho, ln, gi, null);
          }
          GC(zt, ln);
        }
        return typeof ln == "function" && Eg(zt), null;
      }
      function nn(Ct, zt, dt) {
        {
          if (typeof Ct != "object" || Ct === null)
            return zt;
          switch (Ct.$$typeof) {
            case Hn:
            case ge:
              Sf(Ct, dt);
              var ln = Ct.key;
              if (typeof ln != "string")
                break;
              if (zt === null) {
                zt = /* @__PURE__ */ new Set(), zt.add(ln);
                break;
              }
              if (!zt.has(ln)) {
                zt.add(ln);
                break;
              }
              f("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", ln);
              break;
            case $e: {
              var gi = Ct._payload, Mn = Ct._init;
              nn(Mn(gi), zt, dt);
              break;
            }
          }
        }
        return zt;
      }
      function Cn(Ct, zt, dt, ln) {
        for (var gi = null, Mn = 0; Mn < dt.length; Mn++) {
          var mr = dt[Mn];
          gi = nn(mr, gi, Ct);
        }
        for (var Pr = null, wr = null, Jr = zt, ho = 0, Yr = 0, gr = null; Jr !== null && Yr < dt.length; Yr++) {
          Jr.index > Yr ? (gr = Jr, Jr = null) : gr = Jr.sibling;
          var Uo = Zt(Ct, Jr, dt[Yr], ln);
          if (Uo === null) {
            Jr === null && (Jr = gr);
            break;
          }
          g && Jr && Uo.alternate === null && d(Ct, Jr), ho = z(Uo, ho, Yr), wr === null ? Pr = Uo : wr.sibling = Uo, wr = Uo, Jr = gr;
        }
        if (Yr === dt.length) {
          if (G(Ct, Jr), Wo()) {
            var fo = Yr;
            ol(Ct, fo);
          }
          return Pr;
        }
        if (Jr === null) {
          for (; Yr < dt.length; Yr++) {
            var zg = st(Ct, dt[Yr], ln);
            zg !== null && (ho = z(zg, ho, Yr), wr === null ? Pr = zg : wr.sibling = zg, wr = zg);
          }
          if (Wo()) {
            var Es = Yr;
            ol(Ct, Es);
          }
          return Pr;
        }
        for (var pc = w(Ct, Jr); Yr < dt.length; Yr++) {
          var mc = Xt(pc, Ct, Yr, dt[Yr], ln);
          mc !== null && (g && mc.alternate !== null && pc.delete(mc.key === null ? Yr : mc.key), ho = z(mc, ho, Yr), wr === null ? Pr = mc : wr.sibling = mc, wr = mc);
        }
        if (g && pc.forEach(function(KC) {
          return d(Ct, KC);
        }), Wo()) {
          var Od = Yr;
          ol(Ct, Od);
        }
        return Pr;
      }
      function yi(Ct, zt, dt, ln) {
        var gi = He(dt);
        if (typeof gi != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          dt[Symbol.toStringTag] === "Generator" && (ru || f("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), ru = !0), dt.entries === gi && (da || f("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), da = !0);
          var Mn = gi.call(dt);
          if (Mn)
            for (var mr = null, Pr = Mn.next(); !Pr.done; Pr = Mn.next()) {
              var wr = Pr.value;
              mr = nn(wr, mr, Ct);
            }
        }
        var Jr = gi.call(dt);
        if (Jr == null)
          throw new Error("An iterable object provided no iterator.");
        for (var ho = null, Yr = null, gr = zt, Uo = 0, fo = 0, zg = null, Es = Jr.next(); gr !== null && !Es.done; fo++, Es = Jr.next()) {
          gr.index > fo ? (zg = gr, gr = null) : zg = gr.sibling;
          var pc = Zt(Ct, gr, Es.value, ln);
          if (pc === null) {
            gr === null && (gr = zg);
            break;
          }
          g && gr && pc.alternate === null && d(Ct, gr), Uo = z(pc, Uo, fo), Yr === null ? ho = pc : Yr.sibling = pc, Yr = pc, gr = zg;
        }
        if (Es.done) {
          if (G(Ct, gr), Wo()) {
            var mc = fo;
            ol(Ct, mc);
          }
          return ho;
        }
        if (gr === null) {
          for (; !Es.done; fo++, Es = Jr.next()) {
            var Od = st(Ct, Es.value, ln);
            Od !== null && (Uo = z(Od, Uo, fo), Yr === null ? ho = Od : Yr.sibling = Od, Yr = Od);
          }
          if (Wo()) {
            var KC = fo;
            ol(Ct, KC);
          }
          return ho;
        }
        for (var vm = w(Ct, gr); !Es.done; fo++, Es = Jr.next()) {
          var Ac = Xt(vm, Ct, fo, Es.value, ln);
          Ac !== null && (g && Ac.alternate !== null && vm.delete(Ac.key === null ? fo : Ac.key), Uo = z(Ac, Uo, fo), Yr === null ? ho = Ac : Yr.sibling = Ac, Yr = Ac);
        }
        if (g && vm.forEach(function(uG) {
          return d(Ct, uG);
        }), Wo()) {
          var zh = fo;
          ol(Ct, zh);
        }
        return ho;
      }
      function rr(Ct, zt, dt, ln) {
        if (zt !== null && zt.tag === he) {
          G(Ct, zt.sibling);
          var gi = H(zt, dt);
          return gi.return = Ct, gi;
        }
        G(Ct, zt);
        var Mn = O0(dt, Ct.mode, ln);
        return Mn.return = Ct, Mn;
      }
      function Ni(Ct, zt, dt, ln) {
        for (var gi = dt.key, Mn = zt; Mn !== null; ) {
          if (Mn.key === gi) {
            var mr = dt.type;
            if (mr === Wt) {
              if (Mn.tag === pe) {
                G(Ct, Mn.sibling);
                var Pr = H(Mn, dt.props.children);
                return Pr.return = Ct, Pr._debugSource = dt._source, Pr._debugOwner = dt._owner, Pr;
              }
            } else if (Mn.elementType === mr || // Keep this check inline so it only runs on the false path:
            Cx(Mn, dt) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof mr == "object" && mr !== null && mr.$$typeof === $e && Zf(mr) === Mn.type) {
              G(Ct, Mn.sibling);
              var wr = H(Mn, dt.props);
              return wr.ref = HI(Ct, Mn, dt), wr.return = Ct, wr._debugSource = dt._source, wr._debugOwner = dt._owner, wr;
            }
            G(Ct, Mn);
            break;
          } else
            d(Ct, Mn);
          Mn = Mn.sibling;
        }
        if (dt.type === Wt) {
          var Jr = zC(dt.props.children, Ct.mode, ln, dt.key);
          return Jr.return = Ct, Jr;
        } else {
          var ho = vy(dt, Ct.mode, ln);
          return ho.ref = HI(Ct, zt, dt), ho.return = Ct, ho;
        }
      }
      function Ja(Ct, zt, dt, ln) {
        for (var gi = dt.key, Mn = zt; Mn !== null; ) {
          if (Mn.key === gi)
            if (Mn.tag === O && Mn.stateNode.containerInfo === dt.containerInfo && Mn.stateNode.implementation === dt.implementation) {
              G(Ct, Mn.sibling);
              var mr = H(Mn, dt.children || []);
              return mr.return = Ct, mr;
            } else {
              G(Ct, Mn);
              break;
            }
          else
            d(Ct, Mn);
          Mn = Mn.sibling;
        }
        var Pr = P0(dt, Ct.mode, ln);
        return Pr.return = Ct, Pr;
      }
      function Qa(Ct, zt, dt, ln) {
        var gi = typeof dt == "object" && dt !== null && dt.type === Wt && dt.key === null;
        if (gi && (dt = dt.props.children), typeof dt == "object" && dt !== null) {
          switch (dt.$$typeof) {
            case Hn:
              return q(Ni(Ct, zt, dt, ln));
            case ge:
              return q(Ja(Ct, zt, dt, ln));
            case $e: {
              var Mn = dt._payload, mr = dt._init;
              return Qa(Ct, zt, mr(Mn), ln);
            }
          }
          if (Xn(dt))
            return Cn(Ct, zt, dt, ln);
          if (He(dt))
            return yi(Ct, zt, dt, ln);
          GC(Ct, dt);
        }
        return typeof dt == "string" && dt !== "" || typeof dt == "number" ? q(rr(Ct, zt, "" + dt, ln)) : (typeof dt == "function" && Eg(Ct), G(Ct, zt));
      }
      return Qa;
    }
    var Kc = Ep(!0), sA = Ep(!1);
    function Gh(g, d) {
      if (g !== null && d.child !== g.child)
        throw new Error("Resuming work not yet implemented.");
      if (d.child !== null) {
        var G = d.child, w = Tl(G, G.pendingProps);
        for (d.child = w, w.return = d; G.sibling !== null; )
          G = G.sibling, w = w.sibling = Tl(G, G.pendingProps), w.return = d;
        w.sibling = null;
      }
    }
    function lA(g, d) {
      for (var G = g.child; G !== null; )
        fx(G, d), G = G.sibling;
    }
    var wf = {}, Nd = Tr(wf), BC = Tr(wf), uA = Tr(wf);
    function cA(g) {
      if (g === wf)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return g;
    }
    function Tp() {
      var g = cA(uA.current);
      return g;
    }
    function gA(g, d) {
      Dr(uA, d, g), Dr(BC, g, g), Dr(Nd, wf, g);
      var G = Wr(d);
      yo(Nd, g), Dr(Nd, G, g);
    }
    function Lc(g) {
      yo(Nd, g), yo(BC, g), yo(uA, g);
    }
    function _p() {
      var g = cA(Nd.current);
      return g;
    }
    function Bh(g) {
      var d = cA(uA.current), G = cA(Nd.current), w = Xo(G, g.type, d);
      G !== w && (Dr(BC, g, g), Dr(Nd, w, g));
    }
    function dA(g) {
      BC.current === g && (yo(Nd, g), yo(BC, g));
    }
    var Vo = 0, IA = 1, Nv = 1, zp = 2, Tg = Tr(Vo);
    function Kp(g, d) {
      return (g & d) !== 0;
    }
    function Sh(g) {
      return g & IA;
    }
    function Mv(g, d) {
      return g & IA | d;
    }
    function kc(g, d) {
      return g | d;
    }
    function Md(g, d) {
      Dr(Tg, d, g);
    }
    function Rf(g) {
      yo(Tg, g);
    }
    function SC(g, d) {
      var G = g.memoizedState;
      return G !== null ? G.dehydrated !== null : (g.memoizedProps, !0);
    }
    function Zh(g) {
      for (var d = g; d !== null; ) {
        if (d.tag === Se) {
          var G = d.memoizedState;
          if (G !== null) {
            var w = G.dehydrated;
            if (w === null || Ui(w) || ur(w))
              return d;
          }
        } else if (d.tag === Je && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        d.memoizedProps.revealOrder !== void 0) {
          var H = (d.flags & Jn) !== de;
          if (H)
            return d;
        } else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === g)
          return null;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === g)
            return null;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return null;
    }
    var ll = (
      /*   */
      0
    ), ma = (
      /* */
      1
    ), Yu = (
      /*  */
      2
    ), go = (
      /*    */
      4
    ), Ms = (
      /*   */
      8
    ), xf = [];
    function CA() {
      for (var g = 0; g < xf.length; g++) {
        var d = xf[g];
        Pu ? d._workInProgressVersionPrimary = null : d._workInProgressVersionSecondary = null;
      }
      xf.length = 0;
    }
    function Lb(g, d) {
      var G = d._getVersion, w = G(d._source);
      g.mutableSourceEagerHydrationData == null ? g.mutableSourceEagerHydrationData = [d, w] : g.mutableSourceEagerHydrationData.push(d, w);
    }
    var Fn = l.ReactCurrentDispatcher, ul = l.ReactCurrentBatchConfig, Wf, wh;
    Wf = /* @__PURE__ */ new Set();
    var XI = Qt, Ia = null, Hs = null, Na = null, Rh = !1, xh = !1, ZC = 0, kb = 0, XB = 25, _t = null, dc = null, Dc = -1, Hv = !1;
    function Gr() {
      {
        var g = _t;
        dc === null ? dc = [g] : dc.push(g);
      }
    }
    function c() {
      {
        var g = _t;
        dc !== null && (Dc++, dc[Dc] !== g && B(g));
      }
    }
    function h(g) {
      g != null && !Xn(g) && f("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", _t, typeof g);
    }
    function B(g) {
      {
        var d = qe(Ia);
        if (!Wf.has(d) && (Wf.add(d), dc !== null)) {
          for (var G = "", w = 30, H = 0; H <= Dc; H++) {
            for (var z = dc[H], q = H === Dc ? g : z, ee = H + 1 + ". " + z; ee.length < w; )
              ee += " ";
            ee += q + `
`, G += ee;
          }
          f(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, d, G);
        }
      }
    }
    function M() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function _(g, d) {
      if (Hv)
        return !1;
      if (d === null)
        return f("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", _t), !1;
      g.length !== d.length && f(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, _t, "[" + d.join(", ") + "]", "[" + g.join(", ") + "]");
      for (var G = 0; G < d.length && G < g.length; G++)
        if (!ca(g[G], d[G]))
          return !1;
      return !0;
    }
    function U(g, d, G, w, H, z) {
      XI = z, Ia = d, dc = g !== null ? g._debugHookTypes : null, Dc = -1, Hv = g !== null && g.type !== d.type, d.memoizedState = null, d.updateQueue = null, d.lanes = Qt, g !== null && g.memoizedState !== null ? Fn.current = pR : dc !== null ? Fn.current = DB : Fn.current = fR;
      var q = G(w, H);
      if (xh) {
        var ee = 0;
        do {
          if (xh = !1, ZC = 0, ee >= XB)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          ee += 1, Hv = !1, Hs = null, Na = null, d.updateQueue = null, Dc = -1, Fn.current = Pa, q = G(w, H);
        } while (xh);
      }
      Fn.current = Kv, d._debugHookTypes = dc;
      var ue = Hs !== null && Hs.next !== null;
      if (XI = Qt, Ia = null, Hs = null, Na = null, _t = null, dc = null, Dc = -1, g !== null && (g.flags & tn) !== (d.flags & tn) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (g.mode & _r) !== wi && f("Internal React error: Expected static flag was missing. Please notify the React team."), Rh = !1, ue)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return q;
    }
    function oe() {
      var g = ZC !== 0;
      return ZC = 0, g;
    }
    function xe(g, d, G) {
      d.updateQueue = g.updateQueue, (d.mode & ql) !== wi ? d.flags &= -50333701 : d.flags &= -2053, g.lanes = Eo(g.lanes, G);
    }
    function Le() {
      if (Fn.current = Kv, Rh) {
        for (var g = Ia.memoizedState; g !== null; ) {
          var d = g.queue;
          d !== null && (d.pending = null), g = g.next;
        }
        Rh = !1;
      }
      XI = Qt, Ia = null, Hs = null, Na = null, dc = null, Dc = -1, _t = null, kB = !1, xh = !1, ZC = 0;
    }
    function It() {
      var g = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Na === null ? Ia.memoizedState = Na = g : Na = Na.next = g, Na;
    }
    function Ut() {
      var g;
      if (Hs === null) {
        var d = Ia.alternate;
        d !== null ? g = d.memoizedState : g = null;
      } else
        g = Hs.next;
      var G;
      if (Na === null ? G = Ia.memoizedState : G = Na.next, G !== null)
        Na = G, G = Na.next, Hs = g;
      else {
        if (g === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Hs = g;
        var w = {
          memoizedState: Hs.memoizedState,
          baseState: Hs.baseState,
          baseQueue: Hs.baseQueue,
          queue: Hs.queue,
          next: null
        };
        Na === null ? Ia.memoizedState = Na = w : Na = Na.next = w;
      }
      return Na;
    }
    function sn() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function qt(g, d) {
      return typeof d == "function" ? d(g) : d;
    }
    function kn(g, d, G) {
      var w = It(), H;
      G !== void 0 ? H = G(d) : H = d, w.memoizedState = w.baseState = H;
      var z = {
        pending: null,
        interleaved: null,
        lanes: Qt,
        dispatch: null,
        lastRenderedReducer: g,
        lastRenderedState: H
      };
      w.queue = z;
      var q = z.dispatch = dR.bind(null, Ia, z);
      return [w.memoizedState, q];
    }
    function ii(g, d, G) {
      var w = Ut(), H = w.queue;
      if (H === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      H.lastRenderedReducer = g;
      var z = Hs, q = z.baseQueue, ee = H.pending;
      if (ee !== null) {
        if (q !== null) {
          var ue = q.next, Ze = ee.next;
          q.next = Ze, ee.next = ue;
        }
        z.baseQueue !== q && f("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), z.baseQueue = q = ee, H.pending = null;
      }
      if (q !== null) {
        var _e = q.next, st = z.baseState, Zt = null, Xt = null, nn = null, Cn = _e;
        do {
          var yi = Cn.lane;
          if (Ua(XI, yi)) {
            if (nn !== null) {
              var Ni = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: no,
                action: Cn.action,
                hasEagerState: Cn.hasEagerState,
                eagerState: Cn.eagerState,
                next: null
              };
              nn = nn.next = Ni;
            }
            if (Cn.hasEagerState)
              st = Cn.eagerState;
            else {
              var Ja = Cn.action;
              st = g(st, Ja);
            }
          } else {
            var rr = {
              lane: yi,
              action: Cn.action,
              hasEagerState: Cn.hasEagerState,
              eagerState: Cn.eagerState,
              next: null
            };
            nn === null ? (Xt = nn = rr, Zt = st) : nn = nn.next = rr, Ia.lanes = Wi(Ia.lanes, yi), EA(yi);
          }
          Cn = Cn.next;
        } while (Cn !== null && Cn !== _e);
        nn === null ? Zt = st : nn.next = Xt, ca(st, w.memoizedState) || Ff(), w.memoizedState = st, w.baseState = Zt, w.baseQueue = nn, H.lastRenderedState = st;
      }
      var Qa = H.interleaved;
      if (Qa !== null) {
        var Ct = Qa;
        do {
          var zt = Ct.lane;
          Ia.lanes = Wi(Ia.lanes, zt), EA(zt), Ct = Ct.next;
        } while (Ct !== Qa);
      } else q === null && (H.lanes = Qt);
      var dt = H.dispatch;
      return [w.memoizedState, dt];
    }
    function oi(g, d, G) {
      var w = Ut(), H = w.queue;
      if (H === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      H.lastRenderedReducer = g;
      var z = H.dispatch, q = H.pending, ee = w.memoizedState;
      if (q !== null) {
        H.pending = null;
        var ue = q.next, Ze = ue;
        do {
          var _e = Ze.action;
          ee = g(ee, _e), Ze = Ze.next;
        } while (Ze !== ue);
        ca(ee, w.memoizedState) || Ff(), w.memoizedState = ee, w.baseQueue === null && (w.baseState = ee), H.lastRenderedState = ee;
      }
      return [ee, z];
    }
    function ts(g, d, G) {
    }
    function at(g, d, G) {
    }
    function Ue(g, d, G) {
      var w = Ia, H = It(), z, q = Wo();
      if (q) {
        if (G === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        z = G(), wh || z !== G() && (f("The result of getServerSnapshot should be cached to avoid an infinite loop"), wh = !0);
      } else {
        if (z = d(), !wh) {
          var ee = d();
          ca(z, ee) || (f("The result of getSnapshot should be cached to avoid an infinite loop"), wh = !0);
        }
        var ue = dy();
        if (ue === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Sl(ue, XI) || pn(w, d, z);
      }
      H.memoizedState = z;
      var Ze = {
        value: z,
        getSnapshot: d
      };
      return H.queue = Ze, hA(Ci.bind(null, w, Ze, g), [g]), w.flags |= la, Lp(ma | Ms, zn.bind(null, w, Ze, z, d), void 0, null), z;
    }
    function lt(g, d, G) {
      var w = Ia, H = Ut(), z = d();
      if (!wh) {
        var q = d();
        ca(z, q) || (f("The result of getSnapshot should be cached to avoid an infinite loop"), wh = !0);
      }
      var ee = H.memoizedState, ue = !ca(ee, z);
      ue && (H.memoizedState = z, Ff());
      var Ze = H.queue;
      if (Wh(Ci.bind(null, w, Ze, g), [g]), Ze.getSnapshot !== d || ue || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Na !== null && Na.memoizedState.tag & ma) {
        w.flags |= la, Lp(ma | Ms, zn.bind(null, w, Ze, z, d), void 0, null);
        var _e = dy();
        if (_e === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Sl(_e, XI) || pn(w, d, z);
      }
      return z;
    }
    function pn(g, d, G) {
      g.flags |= Et;
      var w = {
        getSnapshot: d,
        value: G
      }, H = Ia.updateQueue;
      if (H === null)
        H = sn(), Ia.updateQueue = H, H.stores = [w];
      else {
        var z = H.stores;
        z === null ? H.stores = [w] : z.push(w);
      }
    }
    function zn(g, d, G, w) {
      d.value = G, d.getSnapshot = w, vi(d) && Ei(g);
    }
    function Ci(g, d, G) {
      var w = function() {
        vi(d) && Ei(g);
      };
      return G(w);
    }
    function vi(g) {
      var d = g.getSnapshot, G = g.value;
      try {
        var w = d();
        return !ca(G, w);
      } catch {
        return !0;
      }
    }
    function Ei(g) {
      fs(g, ji, yr);
    }
    function Io(g) {
      var d = It();
      typeof g == "function" && (g = g()), d.memoizedState = d.baseState = g;
      var G = {
        pending: null,
        interleaved: null,
        lanes: Qt,
        dispatch: null,
        lastRenderedReducer: qt,
        lastRenderedState: g
      };
      d.queue = G;
      var w = G.dispatch = Nf.bind(null, Ia, G);
      return [d.memoizedState, w];
    }
    function Zr(g) {
      return ii(qt);
    }
    function _g(g) {
      return oi(qt);
    }
    function Lp(g, d, G, w) {
      var H = {
        tag: g,
        create: d,
        destroy: G,
        deps: w,
        // Circular
        next: null
      }, z = Ia.updateQueue;
      if (z === null)
        z = sn(), Ia.updateQueue = z, z.lastEffect = H.next = H;
      else {
        var q = z.lastEffect;
        if (q === null)
          z.lastEffect = H.next = H;
        else {
          var ee = q.next;
          q.next = H, H.next = ee, z.lastEffect = H;
        }
      }
      return H;
    }
    function Db(g) {
      var d = It();
      {
        var G = {
          current: g
        };
        return d.memoizedState = G, G;
      }
    }
    function Xv(g) {
      var d = Ut();
      return d.memoizedState;
    }
    function Yv(g, d, G, w) {
      var H = It(), z = w === void 0 ? null : w;
      Ia.flags |= g, H.memoizedState = Lp(ma | d, G, void 0, z);
    }
    function Ub(g, d, G, w) {
      var H = Ut(), z = w === void 0 ? null : w, q = void 0;
      if (Hs !== null) {
        var ee = Hs.memoizedState;
        if (q = ee.destroy, z !== null) {
          var ue = ee.deps;
          if (_(z, ue)) {
            H.memoizedState = Lp(d, G, q, z);
            return;
          }
        }
      }
      Ia.flags |= g, H.memoizedState = Lp(ma | d, G, q, z);
    }
    function hA(g, d) {
      return (Ia.mode & ql) !== wi ? Yv(Ne | la | vn, Ms, g, d) : Yv(la | vn, Ms, g, d);
    }
    function Wh(g, d) {
      return Ub(la, Ms, g, d);
    }
    function YB(g, d) {
      return Yv(et, Yu, g, d);
    }
    function Ob(g, d) {
      return Ub(et, Yu, g, d);
    }
    function FB(g, d) {
      var G = et;
      return G |= Gt, (Ia.mode & ql) !== wi && (G |= ae), Yv(G, go, g, d);
    }
    function Pb(g, d) {
      return Ub(et, go, g, d);
    }
    function cR(g, d) {
      if (typeof d == "function") {
        var G = d, w = g();
        return G(w), function() {
          G(null);
        };
      } else if (d != null) {
        var H = d;
        H.hasOwnProperty("current") || f("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(H).join(", ") + "}");
        var z = g();
        return H.current = z, function() {
          H.current = null;
        };
      }
    }
    function EB(g, d, G) {
      typeof d != "function" && f("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", d !== null ? typeof d : "null");
      var w = G != null ? G.concat([g]) : null, H = et;
      return H |= Gt, (Ia.mode & ql) !== wi && (H |= ae), Yv(H, go, cR.bind(null, d, g), w);
    }
    function Vh(g, d, G) {
      typeof d != "function" && f("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", d !== null ? typeof d : "null");
      var w = G != null ? G.concat([g]) : null;
      return Ub(et, go, cR.bind(null, d, g), w);
    }
    function TB(g, d) {
    }
    var Vf = TB;
    function Fv(g, d) {
      var G = It(), w = d === void 0 ? null : d;
      return G.memoizedState = [g, w], g;
    }
    function Jb(g, d) {
      var G = Ut(), w = d === void 0 ? null : d, H = G.memoizedState;
      if (H !== null && w !== null) {
        var z = H[1];
        if (_(w, z))
          return H[0];
      }
      return G.memoizedState = [g, w], g;
    }
    function _B(g, d) {
      var G = It(), w = d === void 0 ? null : d, H = g();
      return G.memoizedState = [H, w], H;
    }
    function Ev(g, d) {
      var G = Ut(), w = d === void 0 ? null : d, H = G.memoizedState;
      if (H !== null && w !== null) {
        var z = H[1];
        if (_(w, z))
          return H[0];
      }
      var q = g();
      return G.memoizedState = [q, w], q;
    }
    function zB(g) {
      var d = Io(g), G = d[0], w = d[1];
      return hA(function() {
        var H = ul.transition;
        ul.transition = {};
        try {
          w(g);
        } finally {
          ul.transition = H;
        }
      }, [g]), G;
    }
    function Tv(g) {
      var d = Zr(), G = d[0], w = d[1];
      return Wh(function() {
        var H = ul.transition;
        ul.transition = {};
        try {
          w(g);
        } finally {
          ul.transition = H;
        }
      }, [g]), G;
    }
    function kp(g) {
      var d = _g(), G = d[0], w = d[1];
      return Wh(function() {
        var H = ul.transition;
        ul.transition = {};
        try {
          w(g);
        } finally {
          ul.transition = H;
        }
      }, [g]), G;
    }
    function KB(g, d, G) {
      var w = wl();
      ro(Ya(w, zr)), g(!0);
      var H = ul.transition;
      ul.transition = {};
      var z = ul.transition;
      ul.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        g(!1), d();
      } finally {
        if (ro(w), ul.transition = H, H === null && z._updatedFibers) {
          var q = z._updatedFibers.size;
          q > 10 && C("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), z._updatedFibers.clear();
        }
      }
    }
    function Qb() {
      var g = Io(!1), d = g[0], G = g[1], w = KB.bind(null, G), H = It();
      return H.memoizedState = w, [d, w];
    }
    function _v() {
      var g = Zr(), d = g[0], G = Ut(), w = G.memoizedState;
      return [d, w];
    }
    function LB() {
      var g = _g(), d = g[0], G = Ut(), w = G.memoizedState;
      return [d, w];
    }
    var kB = !1;
    function gR() {
      return kB;
    }
    function jb() {
      var g = It(), d = dy(), G = d.identifierPrefix, w;
      if (Wo()) {
        var H = _b();
        w = ":" + G + "R" + H;
        var z = ZC++;
        z > 0 && (w += "H" + z.toString(32)), w += ":";
      } else {
        var q = kb++;
        w = ":" + G + "r" + q.toString(32) + ":";
      }
      return g.memoizedState = w, w;
    }
    function zv() {
      var g = Ut(), d = g.memoizedState;
      return d;
    }
    function dR(g, d, G) {
      typeof arguments[3] == "function" && f("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var w = Eh(g), H = {
        lane: w,
        action: G,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (IR(g))
        CR(d, H);
      else {
        hR(g, d, H);
        var z = zu(), q = fs(g, w, z);
        q !== null && fA(q, d, w);
      }
      qb(g, w);
    }
    function Nf(g, d, G) {
      typeof arguments[3] == "function" && f("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var w = Eh(g), H = {
        lane: w,
        action: G,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (IR(g))
        CR(d, H);
      else {
        hR(g, d, H);
        var z = g.alternate;
        if (g.lanes === Qt && (z === null || z.lanes === Qt)) {
          var q = d.lastRenderedReducer;
          if (q !== null) {
            var ee;
            ee = Fn.current, Fn.current = Uc;
            try {
              var ue = d.lastRenderedState, Ze = q(ue, G);
              if (H.hasEagerState = !0, H.eagerState = Ze, ca(Ze, ue))
                return;
            } catch {
            } finally {
              Fn.current = ee;
            }
          }
        }
        var _e = zu(), st = fs(g, w, _e);
        st !== null && fA(st, d, w);
      }
      qb(g, w);
    }
    function IR(g) {
      var d = g.alternate;
      return g === Ia || d !== null && d === Ia;
    }
    function CR(g, d) {
      xh = Rh = !0;
      var G = g.pending;
      G === null ? d.next = d : (d.next = G.next, G.next = d), g.pending = d;
    }
    function hR(g, d, G, w) {
      if (Im(g)) {
        var H = d.interleaved;
        H === null ? (G.next = G, In(d)) : (G.next = H.next, H.next = G), d.interleaved = G;
      } else {
        var z = d.pending;
        z === null ? G.next = G : (G.next = z.next, z.next = G), d.pending = G;
      }
    }
    function fA(g, d, G) {
      if (oC(G)) {
        var w = d.lanes;
        w = bI(w, g.pendingLanes);
        var H = Wi(w, G);
        d.lanes = H, dh(g, H);
      }
    }
    function qb(g, d, G) {
      fr(g, d);
    }
    var Kv = {
      readContext: Ke,
      useCallback: M,
      useContext: M,
      useEffect: M,
      useImperativeHandle: M,
      useInsertionEffect: M,
      useLayoutEffect: M,
      useMemo: M,
      useReducer: M,
      useRef: M,
      useState: M,
      useDebugValue: M,
      useDeferredValue: M,
      useTransition: M,
      useMutableSource: M,
      useSyncExternalStore: M,
      useId: M,
      unstable_isNewReconciler: W
    }, fR = null, DB = null, pR = null, Pa = null, Hd = null, Uc = null, Mf = null;
    {
      var $b = function() {
        f("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Li = function() {
        f("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      fR = {
        readContext: function(g) {
          return Ke(g);
        },
        useCallback: function(g, d) {
          return _t = "useCallback", Gr(), h(d), Fv(g, d);
        },
        useContext: function(g) {
          return _t = "useContext", Gr(), Ke(g);
        },
        useEffect: function(g, d) {
          return _t = "useEffect", Gr(), h(d), hA(g, d);
        },
        useImperativeHandle: function(g, d, G) {
          return _t = "useImperativeHandle", Gr(), h(G), EB(g, d, G);
        },
        useInsertionEffect: function(g, d) {
          return _t = "useInsertionEffect", Gr(), h(d), YB(g, d);
        },
        useLayoutEffect: function(g, d) {
          return _t = "useLayoutEffect", Gr(), h(d), FB(g, d);
        },
        useMemo: function(g, d) {
          _t = "useMemo", Gr(), h(d);
          var G = Fn.current;
          Fn.current = Hd;
          try {
            return _B(g, d);
          } finally {
            Fn.current = G;
          }
        },
        useReducer: function(g, d, G) {
          _t = "useReducer", Gr();
          var w = Fn.current;
          Fn.current = Hd;
          try {
            return kn(g, d, G);
          } finally {
            Fn.current = w;
          }
        },
        useRef: function(g) {
          return _t = "useRef", Gr(), Db(g);
        },
        useState: function(g) {
          _t = "useState", Gr();
          var d = Fn.current;
          Fn.current = Hd;
          try {
            return Io(g);
          } finally {
            Fn.current = d;
          }
        },
        useDebugValue: function(g, d) {
          return _t = "useDebugValue", Gr(), void 0;
        },
        useDeferredValue: function(g) {
          return _t = "useDeferredValue", Gr(), zB(g);
        },
        useTransition: function() {
          return _t = "useTransition", Gr(), Qb();
        },
        useMutableSource: function(g, d, G) {
          return _t = "useMutableSource", Gr(), void 0;
        },
        useSyncExternalStore: function(g, d, G) {
          return _t = "useSyncExternalStore", Gr(), Ue(g, d, G);
        },
        useId: function() {
          return _t = "useId", Gr(), jb();
        },
        unstable_isNewReconciler: W
      }, DB = {
        readContext: function(g) {
          return Ke(g);
        },
        useCallback: function(g, d) {
          return _t = "useCallback", c(), Fv(g, d);
        },
        useContext: function(g) {
          return _t = "useContext", c(), Ke(g);
        },
        useEffect: function(g, d) {
          return _t = "useEffect", c(), hA(g, d);
        },
        useImperativeHandle: function(g, d, G) {
          return _t = "useImperativeHandle", c(), EB(g, d, G);
        },
        useInsertionEffect: function(g, d) {
          return _t = "useInsertionEffect", c(), YB(g, d);
        },
        useLayoutEffect: function(g, d) {
          return _t = "useLayoutEffect", c(), FB(g, d);
        },
        useMemo: function(g, d) {
          _t = "useMemo", c();
          var G = Fn.current;
          Fn.current = Hd;
          try {
            return _B(g, d);
          } finally {
            Fn.current = G;
          }
        },
        useReducer: function(g, d, G) {
          _t = "useReducer", c();
          var w = Fn.current;
          Fn.current = Hd;
          try {
            return kn(g, d, G);
          } finally {
            Fn.current = w;
          }
        },
        useRef: function(g) {
          return _t = "useRef", c(), Db(g);
        },
        useState: function(g) {
          _t = "useState", c();
          var d = Fn.current;
          Fn.current = Hd;
          try {
            return Io(g);
          } finally {
            Fn.current = d;
          }
        },
        useDebugValue: function(g, d) {
          return _t = "useDebugValue", c(), void 0;
        },
        useDeferredValue: function(g) {
          return _t = "useDeferredValue", c(), zB(g);
        },
        useTransition: function() {
          return _t = "useTransition", c(), Qb();
        },
        useMutableSource: function(g, d, G) {
          return _t = "useMutableSource", c(), void 0;
        },
        useSyncExternalStore: function(g, d, G) {
          return _t = "useSyncExternalStore", c(), Ue(g, d, G);
        },
        useId: function() {
          return _t = "useId", c(), jb();
        },
        unstable_isNewReconciler: W
      }, pR = {
        readContext: function(g) {
          return Ke(g);
        },
        useCallback: function(g, d) {
          return _t = "useCallback", c(), Jb(g, d);
        },
        useContext: function(g) {
          return _t = "useContext", c(), Ke(g);
        },
        useEffect: function(g, d) {
          return _t = "useEffect", c(), Wh(g, d);
        },
        useImperativeHandle: function(g, d, G) {
          return _t = "useImperativeHandle", c(), Vh(g, d, G);
        },
        useInsertionEffect: function(g, d) {
          return _t = "useInsertionEffect", c(), Ob(g, d);
        },
        useLayoutEffect: function(g, d) {
          return _t = "useLayoutEffect", c(), Pb(g, d);
        },
        useMemo: function(g, d) {
          _t = "useMemo", c();
          var G = Fn.current;
          Fn.current = Uc;
          try {
            return Ev(g, d);
          } finally {
            Fn.current = G;
          }
        },
        useReducer: function(g, d, G) {
          _t = "useReducer", c();
          var w = Fn.current;
          Fn.current = Uc;
          try {
            return ii(g, d, G);
          } finally {
            Fn.current = w;
          }
        },
        useRef: function(g) {
          return _t = "useRef", c(), Xv();
        },
        useState: function(g) {
          _t = "useState", c();
          var d = Fn.current;
          Fn.current = Uc;
          try {
            return Zr(g);
          } finally {
            Fn.current = d;
          }
        },
        useDebugValue: function(g, d) {
          return _t = "useDebugValue", c(), Vf();
        },
        useDeferredValue: function(g) {
          return _t = "useDeferredValue", c(), Tv(g);
        },
        useTransition: function() {
          return _t = "useTransition", c(), _v();
        },
        useMutableSource: function(g, d, G) {
          return _t = "useMutableSource", c(), void 0;
        },
        useSyncExternalStore: function(g, d, G) {
          return _t = "useSyncExternalStore", c(), lt(g, d);
        },
        useId: function() {
          return _t = "useId", c(), zv();
        },
        unstable_isNewReconciler: W
      }, Pa = {
        readContext: function(g) {
          return Ke(g);
        },
        useCallback: function(g, d) {
          return _t = "useCallback", c(), Jb(g, d);
        },
        useContext: function(g) {
          return _t = "useContext", c(), Ke(g);
        },
        useEffect: function(g, d) {
          return _t = "useEffect", c(), Wh(g, d);
        },
        useImperativeHandle: function(g, d, G) {
          return _t = "useImperativeHandle", c(), Vh(g, d, G);
        },
        useInsertionEffect: function(g, d) {
          return _t = "useInsertionEffect", c(), Ob(g, d);
        },
        useLayoutEffect: function(g, d) {
          return _t = "useLayoutEffect", c(), Pb(g, d);
        },
        useMemo: function(g, d) {
          _t = "useMemo", c();
          var G = Fn.current;
          Fn.current = Mf;
          try {
            return Ev(g, d);
          } finally {
            Fn.current = G;
          }
        },
        useReducer: function(g, d, G) {
          _t = "useReducer", c();
          var w = Fn.current;
          Fn.current = Mf;
          try {
            return oi(g, d, G);
          } finally {
            Fn.current = w;
          }
        },
        useRef: function(g) {
          return _t = "useRef", c(), Xv();
        },
        useState: function(g) {
          _t = "useState", c();
          var d = Fn.current;
          Fn.current = Mf;
          try {
            return _g(g);
          } finally {
            Fn.current = d;
          }
        },
        useDebugValue: function(g, d) {
          return _t = "useDebugValue", c(), Vf();
        },
        useDeferredValue: function(g) {
          return _t = "useDeferredValue", c(), kp(g);
        },
        useTransition: function() {
          return _t = "useTransition", c(), LB();
        },
        useMutableSource: function(g, d, G) {
          return _t = "useMutableSource", c(), void 0;
        },
        useSyncExternalStore: function(g, d, G) {
          return _t = "useSyncExternalStore", c(), lt(g, d);
        },
        useId: function() {
          return _t = "useId", c(), zv();
        },
        unstable_isNewReconciler: W
      }, Hd = {
        readContext: function(g) {
          return $b(), Ke(g);
        },
        useCallback: function(g, d) {
          return _t = "useCallback", Li(), Gr(), Fv(g, d);
        },
        useContext: function(g) {
          return _t = "useContext", Li(), Gr(), Ke(g);
        },
        useEffect: function(g, d) {
          return _t = "useEffect", Li(), Gr(), hA(g, d);
        },
        useImperativeHandle: function(g, d, G) {
          return _t = "useImperativeHandle", Li(), Gr(), EB(g, d, G);
        },
        useInsertionEffect: function(g, d) {
          return _t = "useInsertionEffect", Li(), Gr(), YB(g, d);
        },
        useLayoutEffect: function(g, d) {
          return _t = "useLayoutEffect", Li(), Gr(), FB(g, d);
        },
        useMemo: function(g, d) {
          _t = "useMemo", Li(), Gr();
          var G = Fn.current;
          Fn.current = Hd;
          try {
            return _B(g, d);
          } finally {
            Fn.current = G;
          }
        },
        useReducer: function(g, d, G) {
          _t = "useReducer", Li(), Gr();
          var w = Fn.current;
          Fn.current = Hd;
          try {
            return kn(g, d, G);
          } finally {
            Fn.current = w;
          }
        },
        useRef: function(g) {
          return _t = "useRef", Li(), Gr(), Db(g);
        },
        useState: function(g) {
          _t = "useState", Li(), Gr();
          var d = Fn.current;
          Fn.current = Hd;
          try {
            return Io(g);
          } finally {
            Fn.current = d;
          }
        },
        useDebugValue: function(g, d) {
          return _t = "useDebugValue", Li(), Gr(), void 0;
        },
        useDeferredValue: function(g) {
          return _t = "useDeferredValue", Li(), Gr(), zB(g);
        },
        useTransition: function() {
          return _t = "useTransition", Li(), Gr(), Qb();
        },
        useMutableSource: function(g, d, G) {
          return _t = "useMutableSource", Li(), Gr(), void 0;
        },
        useSyncExternalStore: function(g, d, G) {
          return _t = "useSyncExternalStore", Li(), Gr(), Ue(g, d, G);
        },
        useId: function() {
          return _t = "useId", Li(), Gr(), jb();
        },
        unstable_isNewReconciler: W
      }, Uc = {
        readContext: function(g) {
          return $b(), Ke(g);
        },
        useCallback: function(g, d) {
          return _t = "useCallback", Li(), c(), Jb(g, d);
        },
        useContext: function(g) {
          return _t = "useContext", Li(), c(), Ke(g);
        },
        useEffect: function(g, d) {
          return _t = "useEffect", Li(), c(), Wh(g, d);
        },
        useImperativeHandle: function(g, d, G) {
          return _t = "useImperativeHandle", Li(), c(), Vh(g, d, G);
        },
        useInsertionEffect: function(g, d) {
          return _t = "useInsertionEffect", Li(), c(), Ob(g, d);
        },
        useLayoutEffect: function(g, d) {
          return _t = "useLayoutEffect", Li(), c(), Pb(g, d);
        },
        useMemo: function(g, d) {
          _t = "useMemo", Li(), c();
          var G = Fn.current;
          Fn.current = Uc;
          try {
            return Ev(g, d);
          } finally {
            Fn.current = G;
          }
        },
        useReducer: function(g, d, G) {
          _t = "useReducer", Li(), c();
          var w = Fn.current;
          Fn.current = Uc;
          try {
            return ii(g, d, G);
          } finally {
            Fn.current = w;
          }
        },
        useRef: function(g) {
          return _t = "useRef", Li(), c(), Xv();
        },
        useState: function(g) {
          _t = "useState", Li(), c();
          var d = Fn.current;
          Fn.current = Uc;
          try {
            return Zr(g);
          } finally {
            Fn.current = d;
          }
        },
        useDebugValue: function(g, d) {
          return _t = "useDebugValue", Li(), c(), Vf();
        },
        useDeferredValue: function(g) {
          return _t = "useDeferredValue", Li(), c(), Tv(g);
        },
        useTransition: function() {
          return _t = "useTransition", Li(), c(), _v();
        },
        useMutableSource: function(g, d, G) {
          return _t = "useMutableSource", Li(), c(), void 0;
        },
        useSyncExternalStore: function(g, d, G) {
          return _t = "useSyncExternalStore", Li(), c(), lt(g, d);
        },
        useId: function() {
          return _t = "useId", Li(), c(), zv();
        },
        unstable_isNewReconciler: W
      }, Mf = {
        readContext: function(g) {
          return $b(), Ke(g);
        },
        useCallback: function(g, d) {
          return _t = "useCallback", Li(), c(), Jb(g, d);
        },
        useContext: function(g) {
          return _t = "useContext", Li(), c(), Ke(g);
        },
        useEffect: function(g, d) {
          return _t = "useEffect", Li(), c(), Wh(g, d);
        },
        useImperativeHandle: function(g, d, G) {
          return _t = "useImperativeHandle", Li(), c(), Vh(g, d, G);
        },
        useInsertionEffect: function(g, d) {
          return _t = "useInsertionEffect", Li(), c(), Ob(g, d);
        },
        useLayoutEffect: function(g, d) {
          return _t = "useLayoutEffect", Li(), c(), Pb(g, d);
        },
        useMemo: function(g, d) {
          _t = "useMemo", Li(), c();
          var G = Fn.current;
          Fn.current = Uc;
          try {
            return Ev(g, d);
          } finally {
            Fn.current = G;
          }
        },
        useReducer: function(g, d, G) {
          _t = "useReducer", Li(), c();
          var w = Fn.current;
          Fn.current = Uc;
          try {
            return oi(g, d, G);
          } finally {
            Fn.current = w;
          }
        },
        useRef: function(g) {
          return _t = "useRef", Li(), c(), Xv();
        },
        useState: function(g) {
          _t = "useState", Li(), c();
          var d = Fn.current;
          Fn.current = Uc;
          try {
            return _g(g);
          } finally {
            Fn.current = d;
          }
        },
        useDebugValue: function(g, d) {
          return _t = "useDebugValue", Li(), c(), Vf();
        },
        useDeferredValue: function(g) {
          return _t = "useDeferredValue", Li(), c(), kp(g);
        },
        useTransition: function() {
          return _t = "useTransition", Li(), c(), LB();
        },
        useMutableSource: function(g, d, G) {
          return _t = "useMutableSource", Li(), c(), void 0;
        },
        useSyncExternalStore: function(g, d, G) {
          return _t = "useSyncExternalStore", Li(), c(), lt(g, d);
        },
        useId: function() {
          return _t = "useId", Li(), c(), zv();
        },
        unstable_isNewReconciler: W
      };
    }
    var wC = o.unstable_now, pA = 0, e0 = -1, Hf = -1, Nh = -1, UB = !1, Lv = !1;
    function mR() {
      return UB;
    }
    function mV() {
      Lv = !0;
    }
    function Oc() {
      UB = !1, Lv = !1;
    }
    function kv() {
      UB = Lv, Lv = !1;
    }
    function Dv() {
      return pA;
    }
    function Mh() {
      pA = wC();
    }
    function t0(g) {
      Hf = wC(), g.actualStartTime < 0 && (g.actualStartTime = wC());
    }
    function Xf(g) {
      Hf = -1;
    }
    function RC(g, d) {
      if (Hf >= 0) {
        var G = wC() - Hf;
        g.actualDuration += G, d && (g.selfBaseDuration = G), Hf = -1;
      }
    }
    function Ic(g) {
      if (e0 >= 0) {
        var d = wC() - e0;
        e0 = -1;
        for (var G = g.return; G !== null; ) {
          switch (G.tag) {
            case J:
              var w = G.stateNode;
              w.effectDuration += d;
              return;
            case re:
              var H = G.stateNode;
              H.effectDuration += d;
              return;
          }
          G = G.return;
        }
      }
    }
    function Uv(g) {
      if (Nh >= 0) {
        var d = wC() - Nh;
        Nh = -1;
        for (var G = g.return; G !== null; ) {
          switch (G.tag) {
            case J:
              var w = G.stateNode;
              w !== null && (w.passiveEffectDuration += d);
              return;
            case re:
              var H = G.stateNode;
              H !== null && (H.passiveEffectDuration += d);
              return;
          }
          G = G.return;
        }
      }
    }
    function Cc() {
      e0 = wC();
    }
    function Dp() {
      Nh = wC();
    }
    function n0(g) {
      for (var d = g.child; d; )
        g.actualDuration += d.actualDuration, d = d.sibling;
    }
    function Up(g, d) {
      return {
        value: g,
        source: d,
        stack: wI(d)
      };
    }
    function AR(g, d) {
      return !0;
    }
    function i0(g, d) {
      try {
        var G = AR(g, d);
        if (G === !1)
          return;
        var w = d.value, H = d.source, z = d.stack, q = z !== null ? z : "";
        if (w != null && w._suppressLogging) {
          if (g.tag === L)
            return;
          console.error(w);
        }
        var ee = H ? qe(H) : null, ue = ee ? "The above error occurred in the <" + ee + "> component:" : "The above error occurred in one of your React components:", Ze;
        if (g.tag === J)
          Ze = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var _e = qe(g) || "Anonymous";
          Ze = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + _e + ".");
        }
        var st = ue + `
` + q + `

` + ("" + Ze);
        console.error(st);
      } catch (Zt) {
        setTimeout(function() {
          throw Zt;
        });
      }
    }
    var AV = typeof WeakMap == "function" ? WeakMap : Map;
    function vR(g, d, G) {
      var w = Sn(yr, G);
      w.tag = wn, w.payload = {
        element: null
      };
      var H = d.value;
      return w.callback = function() {
        dx(H), i0(g, d);
      }, w;
    }
    function mA(g, d, G) {
      var w = Sn(yr, G);
      w.tag = wn;
      var H = g.type.getDerivedStateFromError;
      if (typeof H == "function") {
        var z = d.value;
        w.payload = function() {
          return H(z);
        }, w.callback = function() {
          Kt(g), i0(g, d);
        };
      }
      var q = g.stateNode;
      return q !== null && typeof q.componentDidCatch == "function" && (w.callback = function() {
        Kt(g), i0(g, d), typeof H != "function" && VS(this);
        var ue = d.value, Ze = d.stack;
        this.componentDidCatch(ue, {
          componentStack: Ze !== null ? Ze : ""
        }), typeof H != "function" && (xs(g.lanes, ji) || f("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", qe(g) || "Unknown"));
      }), w;
    }
    function Ov(g, d, G) {
      var w = g.pingCache, H;
      if (w === null ? (w = g.pingCache = new AV(), H = /* @__PURE__ */ new Set(), w.set(d, H)) : (H = w.get(d), H === void 0 && (H = /* @__PURE__ */ new Set(), w.set(d, H))), !H.has(G)) {
        H.add(G);
        var z = EI.bind(null, g, d, G);
        tr && py(g, G), d.then(z, z);
      }
    }
    function yR(g, d, G, w) {
      var H = g.updateQueue;
      if (H === null) {
        var z = /* @__PURE__ */ new Set();
        z.add(G), g.updateQueue = z;
      } else
        H.add(G);
    }
    function vV(g, d) {
      var G = g.tag;
      if ((g.mode & _r) === wi && (G === D || G === Xe || G === le)) {
        var w = g.alternate;
        w ? (g.updateQueue = w.updateQueue, g.memoizedState = w.memoizedState, g.lanes = w.lanes) : (g.updateQueue = null, g.memoizedState = null);
      }
    }
    function Pv(g) {
      var d = g;
      do {
        if (d.tag === Se && SC(d))
          return d;
        d = d.return;
      } while (d !== null);
      return null;
    }
    function bR(g, d, G, w, H) {
      if ((g.mode & _r) === wi) {
        if (g === d)
          g.flags |= Ln;
        else {
          if (g.flags |= Jn, G.flags |= Ie, G.flags &= -52805, G.tag === L) {
            var z = G.alternate;
            if (z === null)
              G.tag = nt;
            else {
              var q = Sn(yr, ji);
              q.tag = Yi, ei(G, q);
            }
          }
          G.lanes = Wi(G.lanes, ji);
        }
        return g;
      }
      return g.flags |= Ln, g.lanes = H, g;
    }
    function yV(g, d, G, w, H) {
      if (G.flags |= Vn, tr && py(g, H), w !== null && typeof w == "object" && typeof w.then == "function") {
        var z = w;
        vV(G);
        var q = Pv(d);
        if (q !== null) {
          q.flags &= -257, bR(q, d, G, g, H), q.mode & _r && Ov(g, z, H), yR(q, g, z);
          return;
        } else {
          if (!io(H)) {
            Ov(g, z, H), TA();
            return;
          }
          var ee = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          w = ee;
        }
      } else if (Wo() && G.mode & _r) {
        sl();
        var ue = Pv(d);
        if (ue !== null) {
          (ue.flags & Ln) === de && (ue.flags |= Ii), bR(ue, d, G, g, H), bh(w);
          return;
        }
      }
      rN(w), w = Up(w, G);
      var Ze = d;
      do {
        switch (Ze.tag) {
          case J: {
            var _e = w;
            Ze.flags |= Ln;
            var st = Yc(H);
            Ze.lanes = Wi(Ze.lanes, st);
            var Zt = vR(Ze, _e, st);
            Vi(Ze, Zt);
            return;
          }
          case L:
            var Xt = w, nn = Ze.type, Cn = Ze.stateNode;
            if ((Ze.flags & Jn) === de && (typeof nn.getDerivedStateFromError == "function" || Cn !== null && typeof Cn.componentDidCatch == "function" && !WS(Cn))) {
              Ze.flags |= Ln;
              var yi = Yc(H);
              Ze.lanes = Wi(Ze.lanes, yi);
              var rr = mA(Ze, Xt, yi);
              Vi(Ze, rr);
              return;
            }
            break;
        }
        Ze = Ze.return;
      } while (Ze !== null);
    }
    function bV() {
      return null;
    }
    function xC(g) {
      g.flags |= et;
    }
    function GR(g) {
      g.flags |= dr, g.flags |= At;
    }
    function BR(g, d) {
      var G = g !== null && g.child === d.child;
      if (G)
        return !0;
      if ((d.flags & Kn) !== de)
        return !1;
      for (var w = d.child; w !== null; ) {
        if ((w.flags & De) !== de || (w.subtreeFlags & De) !== de)
          return !1;
        w = w.sibling;
      }
      return !0;
    }
    var Jv, Qv, r0, a0;
    if (Yo)
      Jv = function(g, d, G, w) {
        for (var H = d.child; H !== null; ) {
          if (H.tag === ne || H.tag === he)
            za(g, H.stateNode);
          else if (H.tag !== O) {
            if (H.child !== null) {
              H.child.return = H, H = H.child;
              continue;
            }
          }
          if (H === d)
            return;
          for (; H.sibling === null; ) {
            if (H.return === null || H.return === d)
              return;
            H = H.return;
          }
          H.sibling.return = H.return, H = H.sibling;
        }
      }, Qv = function(g, d) {
      }, r0 = function(g, d, G, w, H) {
        var z = g.memoizedProps;
        if (z !== w) {
          var q = d.stateNode, ee = _p(), ue = Xa(q, G, z, w, H, ee);
          d.updateQueue = ue, ue && xC(d);
        }
      }, a0 = function(g, d, G, w) {
        G !== w && xC(d);
      };
    else if (Cu) {
      Jv = function(g, d, G, w) {
        for (var H = d.child; H !== null; ) {
          if (H.tag === ne) {
            var z = H.stateNode;
            if (G && w) {
              var q = H.memoizedProps, ee = H.type;
              z = St(z, ee, q, H);
            }
            za(g, z);
          } else if (H.tag === he) {
            var ue = H.stateNode;
            if (G && w) {
              var Ze = H.memoizedProps;
              ue = dn(ue, Ze, H);
            }
            za(g, ue);
          } else if (H.tag !== O) {
            if (H.tag === mt && H.memoizedState !== null) {
              var _e = H.child;
              _e !== null && (_e.return = H), Jv(g, H, !0, !0);
            } else if (H.child !== null) {
              H.child.return = H, H = H.child;
              continue;
            }
          }
          if (H = H, H === d)
            return;
          for (; H.sibling === null; ) {
            if (H.return === null || H.return === d)
              return;
            H = H.return;
          }
          H.sibling.return = H.return, H = H.sibling;
        }
      };
      var o0 = function(g, d, G, w) {
        for (var H = d.child; H !== null; ) {
          if (H.tag === ne) {
            var z = H.stateNode;
            if (G && w) {
              var q = H.memoizedProps, ee = H.type;
              z = St(z, ee, q, H);
            }
            ie(g, z);
          } else if (H.tag === he) {
            var ue = H.stateNode;
            if (G && w) {
              var Ze = H.memoizedProps;
              ue = dn(ue, Ze, H);
            }
            ie(g, ue);
          } else if (H.tag !== O) {
            if (H.tag === mt && H.memoizedState !== null) {
              var _e = H.child;
              _e !== null && (_e.return = H), o0(g, H, !0, !0);
            } else if (H.child !== null) {
              H.child.return = H, H = H.child;
              continue;
            }
          }
          if (H = H, H === d)
            return;
          for (; H.sibling === null; ) {
            if (H.return === null || H.return === d)
              return;
            H = H.return;
          }
          H.sibling.return = H.return, H = H.sibling;
        }
      };
      Qv = function(g, d) {
        var G = d.stateNode, w = BR(g, d);
        if (!w) {
          var H = G.containerInfo, z = hI(H);
          o0(z, d, !1, !1), G.pendingChildren = z, xC(d), Me(H, z);
        }
      }, r0 = function(g, d, G, w, H) {
        var z = g.stateNode, q = g.memoizedProps, ee = BR(g, d);
        if (ee && q === w) {
          d.stateNode = z;
          return;
        }
        var ue = d.stateNode, Ze = _p(), _e = null;
        if (q !== w && (_e = Xa(ue, G, q, w, H, Ze)), ee && _e === null) {
          d.stateNode = z;
          return;
        }
        var st = Ps(z, _e, G, q, w, d, ee, ue);
        pl(st, G, w, H, Ze) && xC(d), d.stateNode = st, ee ? xC(d) : Jv(st, d, !1, !1);
      }, a0 = function(g, d, G, w) {
        if (G !== w) {
          var H = Tp(), z = _p();
          d.stateNode = Ao(w, H, z, d), xC(d);
        } else
          d.stateNode = g.stateNode;
      };
    } else
      Qv = function(g, d) {
      }, r0 = function(g, d, G, w, H) {
      }, a0 = function(g, d, G, w) {
      };
    function Op(g, d) {
      if (!Wo())
        switch (g.tailMode) {
          case "hidden": {
            for (var G = g.tail, w = null; G !== null; )
              G.alternate !== null && (w = G), G = G.sibling;
            w === null ? g.tail = null : w.sibling = null;
            break;
          }
          case "collapsed": {
            for (var H = g.tail, z = null; H !== null; )
              H.alternate !== null && (z = H), H = H.sibling;
            z === null ? !d && g.tail !== null ? g.tail.sibling = null : g.tail = null : z.sibling = null;
            break;
          }
        }
    }
    function cl(g) {
      var d = g.alternate !== null && g.alternate.child === g.child, G = Qt, w = de;
      if (d) {
        if ((g.mode & vr) !== wi) {
          for (var ue = g.selfBaseDuration, Ze = g.child; Ze !== null; )
            G = Wi(G, Wi(Ze.lanes, Ze.childLanes)), w |= Ze.subtreeFlags & tn, w |= Ze.flags & tn, ue += Ze.treeBaseDuration, Ze = Ze.sibling;
          g.treeBaseDuration = ue;
        } else
          for (var _e = g.child; _e !== null; )
            G = Wi(G, Wi(_e.lanes, _e.childLanes)), w |= _e.subtreeFlags & tn, w |= _e.flags & tn, _e.return = g, _e = _e.sibling;
        g.subtreeFlags |= w;
      } else {
        if ((g.mode & vr) !== wi) {
          for (var H = g.actualDuration, z = g.selfBaseDuration, q = g.child; q !== null; )
            G = Wi(G, Wi(q.lanes, q.childLanes)), w |= q.subtreeFlags, w |= q.flags, H += q.actualDuration, z += q.treeBaseDuration, q = q.sibling;
          g.actualDuration = H, g.treeBaseDuration = z;
        } else
          for (var ee = g.child; ee !== null; )
            G = Wi(G, Wi(ee.lanes, ee.childLanes)), w |= ee.subtreeFlags, w |= ee.flags, ee.return = g, ee = ee.sibling;
        g.subtreeFlags |= w;
      }
      return g.childLanes = G, d;
    }
    function s0(g, d, G) {
      var w = d.pendingProps;
      switch (Hp(d), d.tag) {
        case j:
        case Ye:
        case le:
        case D:
        case Xe:
        case pe:
        case Ae:
        case re:
        case ke:
        case Be:
          return cl(d), null;
        case L: {
          var H = d.type;
          return Zs(H) && fd(d), cl(d), null;
        }
        case J: {
          var z = d.stateNode;
          if (Lc(d), Go(d), CA(), z.pendingContext && (z.context = z.pendingContext, z.pendingContext = null), g === null || g.child === null) {
            var q = yC(d);
            if (q)
              xC(d);
            else if (g !== null) {
              var ee = g.memoizedState;
              // Check if this is a client root
              (!ee.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (d.flags & Ii) !== de) && (d.flags |= xr, yh());
            }
          }
          return Qv(g, d), cl(d), null;
        }
        case ne: {
          dA(d);
          var ue = Tp(), Ze = d.type;
          if (g !== null && d.stateNode != null)
            r0(g, d, Ze, w, ue), g.ref !== d.ref && GR(d);
          else {
            if (!w) {
              if (d.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return cl(d), null;
            }
            var _e = _p(), st = yC(d);
            if (st)
              Gf(d, ue, _e) && xC(d);
            else {
              var Zt = or(Ze, w, ue, _e, d);
              Jv(Zt, d, !1, !1), d.stateNode = Zt, pl(Zt, Ze, w, ue, _e) && xC(d);
            }
            d.ref !== null && GR(d);
          }
          return cl(d), null;
        }
        case he: {
          var Xt = w;
          if (g && d.stateNode != null) {
            var nn = g.memoizedProps;
            a0(g, d, nn, Xt);
          } else {
            if (typeof Xt != "string" && d.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Cn = Tp(), yi = _p(), rr = yC(d);
            rr ? MI(d) && xC(d) : d.stateNode = Ao(Xt, Cn, yi, d);
          }
          return cl(d), null;
        }
        case Se: {
          Rf(d);
          var Ni = d.memoizedState;
          {
            if (bC() && (d.mode & _r) !== wi && (d.flags & Jn) === de)
              return Bf(d), Fg(), d.flags |= Ii | Vn | Ln, d;
            if (Ni !== null && Ni.dehydrated !== null) {
              var Ja = yC(d);
              if (g === null) {
                if (!Ja)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (vC(d), cl(d), (d.mode & vr) !== wi) {
                  var Qa = Ni !== null;
                  if (Qa) {
                    var Ct = d.child;
                    Ct !== null && (d.treeBaseDuration -= Ct.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (Fg(), (d.flags & Jn) === de && (d.memoizedState = null), d.flags |= et, cl(d), (d.mode & vr) !== wi) {
                  var zt = Ni !== null;
                  if (zt) {
                    var dt = d.child;
                    dt !== null && (d.treeBaseDuration -= dt.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            yh();
          }
          if ((d.flags & Jn) !== de)
            return d.lanes = G, (d.mode & vr) !== wi && n0(d), d;
          var ln = Ni !== null, gi = !1;
          if (g === null)
            yC(d);
          else {
            var Mn = g.memoizedState;
            gi = Mn !== null;
          }
          if (ln && !gi) {
            var mr = d.child;
            if (mr.flags |= rt, (d.mode & _r) !== wi) {
              var Pr = g === null && (d.memoizedProps.unstable_avoidThisFallback !== !0 || !0);
              Pr || Kp(Tg.current, Nv) ? iN() : TA();
            }
          }
          var wr = d.updateQueue;
          if (wr !== null && (d.flags |= et), cl(d), (d.mode & vr) !== wi && ln) {
            var Jr = d.child;
            Jr !== null && (d.treeBaseDuration -= Jr.treeBaseDuration);
          }
          return null;
        }
        case O:
          return Lc(d), Qv(g, d), g === null && hu(d.stateNode.containerInfo), cl(d), null;
        case Re:
          var ho = d.type._context;
          return V(ho, d), cl(d), null;
        case nt: {
          var Yr = d.type;
          return Zs(Yr) && fd(d), cl(d), null;
        }
        case Je: {
          Rf(d);
          var gr = d.memoizedState;
          if (gr === null)
            return cl(d), null;
          var Uo = (d.flags & Jn) !== de, fo = gr.rendering;
          if (fo === null)
            if (Uo)
              Op(gr, !1);
            else {
              var zg = ux() && (g === null || (g.flags & Jn) === de);
              if (!zg)
                for (var Es = d.child; Es !== null; ) {
                  var pc = Zh(Es);
                  if (pc !== null) {
                    Uo = !0, d.flags |= Jn, Op(gr, !1);
                    var mc = pc.updateQueue;
                    return mc !== null && (d.updateQueue = mc, d.flags |= et), d.subtreeFlags = de, lA(d, G), Md(d, Mv(Tg.current, zp)), d.child;
                  }
                  Es = Es.sibling;
                }
              gr.tail !== null && Zo() > cy() && (d.flags |= Jn, Uo = !0, Op(gr, !1), d.lanes = ka);
            }
          else {
            if (!Uo) {
              var Od = Zh(fo);
              if (Od !== null) {
                d.flags |= Jn, Uo = !0;
                var KC = Od.updateQueue;
                if (KC !== null && (d.updateQueue = KC, d.flags |= et), Op(gr, !0), gr.tail === null && gr.tailMode === "hidden" && !fo.alternate && !Wo())
                  return cl(d), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              Zo() * 2 - gr.renderingStartTime > cy() && G !== Bo && (d.flags |= Jn, Uo = !0, Op(gr, !1), d.lanes = ka);
            }
            if (gr.isBackwards)
              fo.sibling = d.child, d.child = fo;
            else {
              var vm = gr.last;
              vm !== null ? vm.sibling = fo : d.child = fo, gr.last = fo;
            }
          }
          if (gr.tail !== null) {
            var Ac = gr.tail;
            gr.rendering = Ac, gr.tail = Ac.sibling, gr.renderingStartTime = Zo(), Ac.sibling = null;
            var zh = Tg.current;
            return Uo ? zh = Mv(zh, zp) : zh = Sh(zh), Md(d, zh), Ac;
          }
          return cl(d), null;
        }
        case wt:
          break;
        case mt:
        case Dt: {
          FA(d);
          var uG = d.memoizedState, Zx = uG !== null;
          if (g !== null) {
            var wx = g.memoizedState, Rx = wx !== null;
            Rx !== Zx && (d.flags |= rt);
          }
          return !Zx || (d.mode & _r) === wi ? cl(d) : xs(jc, Bo) && (cl(d), Yo && d.subtreeFlags & (je | et) && (d.flags |= rt)), null;
        }
        case mn:
          return null;
        case An:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + d.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var jv = l.ReactCurrentOwner, hc = !1, Pp, qv, l0, OB, PB, Yf, JB, u0;
    Pp = {}, qv = {}, l0 = {}, OB = {}, PB = {}, Yf = !1, JB = {}, u0 = {};
    function Fu(g, d, G, w) {
      g === null ? d.child = sA(d, null, G, w) : d.child = Kc(d, g.child, G, w);
    }
    function c0(g, d, G, w) {
      d.child = Kc(d, g.child, null, w), d.child = Kc(d, null, G, w);
    }
    function $v(g, d, G, w, H) {
      if (d.type !== d.elementType) {
        var z = G.propTypes;
        z && vl(
          z,
          w,
          // Resolved props
          "prop",
          ht(G)
        );
      }
      var q = G.render, ee = d.ref, ue, Ze;
      ve(d, H), nc(d);
      {
        if (jv.current = d, lo(!0), ue = U(g, d, q, w, ee, H), Ze = oe(), d.mode & La) {
          ri(!0);
          try {
            ue = U(g, d, q, w, ee, H), Ze = oe();
          } finally {
            ri(!1);
          }
        }
        lo(!1);
      }
      return ua(), g !== null && !hc ? (xe(g, d, H), Hh(g, d, H)) : (Wo() && Ze && uc(d), d.flags |= it, Fu(g, d, ue, H), d.child);
    }
    function ey(g, d, G, w, H) {
      if (g === null) {
        var z = G.type;
        if (hx(z) && G.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        G.defaultProps === void 0) {
          var q = z;
          return q = TC(z), d.tag = le, d.type = q, ty(d, z), AA(g, d, q, w, H);
        }
        {
          var ee = z.propTypes;
          ee && vl(
            ee,
            w,
            // Resolved props
            "prop",
            ht(z)
          );
        }
        var ue = Ay(G.type, null, w, d, d.mode, H);
        return ue.ref = d.ref, ue.return = d, d.child = ue, ue;
      }
      {
        var Ze = G.type, _e = Ze.propTypes;
        _e && vl(
          _e,
          w,
          // Resolved props
          "prop",
          ht(Ze)
        );
      }
      var st = g.child, Zt = oS(g, H);
      if (!Zt) {
        var Xt = st.memoizedProps, nn = G.compare;
        if (nn = nn !== null ? nn : Ec, nn(Xt, w) && g.ref === d.ref)
          return Hh(g, d, H);
      }
      d.flags |= it;
      var Cn = Tl(st, w);
      return Cn.ref = d.ref, Cn.return = d, d.child = Cn, Cn;
    }
    function AA(g, d, G, w, H) {
      if (d.type !== d.elementType) {
        var z = d.elementType;
        if (z.$$typeof === $e) {
          var q = z, ee = q._payload, ue = q._init;
          try {
            z = ue(ee);
          } catch {
            z = null;
          }
          var Ze = z && z.propTypes;
          Ze && vl(
            Ze,
            w,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            ht(z)
          );
        }
      }
      if (g !== null) {
        var _e = g.memoizedProps;
        if (Ec(_e, w) && g.ref === d.ref && // Prevent bailout if the implementation changed due to hot reload.
        d.type === g.type)
          if (hc = !1, oS(g, H))
            (g.flags & Ie) !== de && (hc = !0);
          else return d.lanes = g.lanes, Hh(g, d, H);
      }
      return qB(g, d, G, w, H);
    }
    function vA(g, d, G) {
      var w = d.pendingProps, H = w.children, z = g !== null ? g.memoizedState : null;
      if (w.mode === "hidden" || N)
        if ((d.mode & _r) === wi) {
          var q = {
            baseLanes: Qt,
            cachePool: null
          };
          d.memoizedState = q, YA(d, G);
        } else if (xs(G, Bo)) {
          var st = {
            baseLanes: Qt,
            cachePool: null
          };
          d.memoizedState = st;
          var Zt = z !== null ? z.baseLanes : G;
          YA(d, Zt);
        } else {
          var ee = null, ue;
          if (z !== null) {
            var Ze = z.baseLanes;
            ue = Wi(Ze, G);
          } else
            ue = G;
          d.lanes = d.childLanes = Bo;
          var _e = {
            baseLanes: ue,
            cachePool: ee
          };
          return d.memoizedState = _e, d.updateQueue = null, YA(d, ue), null;
        }
      else {
        var Xt;
        z !== null ? (Xt = Wi(z.baseLanes, G), d.memoizedState = null) : Xt = G, YA(d, Xt);
      }
      return Fu(g, d, H, G), d.child;
    }
    function GV(g, d, G) {
      var w = d.pendingProps;
      return Fu(g, d, w, G), d.child;
    }
    function QB(g, d, G) {
      var w = d.pendingProps.children;
      return Fu(g, d, w, G), d.child;
    }
    function jB(g, d, G) {
      {
        d.flags |= et;
        {
          var w = d.stateNode;
          w.effectDuration = 0, w.passiveEffectDuration = 0;
        }
      }
      var H = d.pendingProps, z = H.children;
      return Fu(g, d, z, G), d.child;
    }
    function SR(g, d) {
      var G = d.ref;
      (g === null && G !== null || g !== null && g.ref !== G) && (d.flags |= dr, d.flags |= At);
    }
    function qB(g, d, G, w, H) {
      if (d.type !== d.elementType) {
        var z = G.propTypes;
        z && vl(
          z,
          w,
          // Resolved props
          "prop",
          ht(G)
        );
      }
      var q;
      {
        var ee = fa(d, G, !0);
        q = yl(d, ee);
      }
      var ue, Ze;
      ve(d, H), nc(d);
      {
        if (jv.current = d, lo(!0), ue = U(g, d, G, w, q, H), Ze = oe(), d.mode & La) {
          ri(!0);
          try {
            ue = U(g, d, G, w, q, H), Ze = oe();
          } finally {
            ri(!1);
          }
        }
        lo(!1);
      }
      return ua(), g !== null && !hc ? (xe(g, d, H), Hh(g, d, H)) : (Wo() && Ze && uc(d), d.flags |= it, Fu(g, d, ue, H), d.child);
    }
    function BV(g, d, G, w, H) {
      {
        switch (wy(d)) {
          case !1: {
            var z = d.stateNode, q = d.type, ee = new q(d.memoizedProps, z.context), ue = ee.state;
            z.updater.enqueueSetState(z, ue, null);
            break;
          }
          case !0: {
            d.flags |= Jn, d.flags |= Ln;
            var Ze = new Error("Simulated error coming from DevTools"), _e = Yc(H);
            d.lanes = Wi(d.lanes, _e);
            var st = mA(d, Up(Ze, d), _e);
            Vi(d, st);
            break;
          }
        }
        if (d.type !== d.elementType) {
          var Zt = G.propTypes;
          Zt && vl(
            Zt,
            w,
            // Resolved props
            "prop",
            ht(G)
          );
        }
      }
      var Xt;
      Zs(G) ? (Xt = !0, qu(d)) : Xt = !1, ve(d, H);
      var nn = d.stateNode, Cn;
      nn === null ? (g !== null && (g.alternate = null, d.alternate = null, d.flags |= je), ti(d, G, w), Np(d, G, w, H), Cn = !0) : g === null ? Cn = HB(d, G, w, H) : Cn = vf(g, d, G, w, H);
      var yi = $B(g, d, G, Cn, Xt, H);
      {
        var rr = d.stateNode;
        Cn && rr.props !== w && (Yf || f("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", qe(d) || "a component"), Yf = !0);
      }
      return yi;
    }
    function $B(g, d, G, w, H, z) {
      SR(g, d);
      var q = (d.flags & Jn) !== de;
      if (!w && !q)
        return H && jl(d, G, !1), Hh(g, d, z);
      var ee = d.stateNode;
      jv.current = d;
      var ue;
      if (q && typeof G.getDerivedStateFromError != "function")
        ue = null, Xf();
      else {
        nc(d);
        {
          if (lo(!0), ue = ee.render(), d.mode & La) {
            ri(!0);
            try {
              ee.render();
            } finally {
              ri(!1);
            }
          }
          lo(!1);
        }
        ua();
      }
      return d.flags |= it, g !== null && q ? c0(g, d, ue, z) : Fu(g, d, ue, z), d.memoizedState = ee.state, H && jl(d, G, !0), d.child;
    }
    function ZR(g) {
      var d = g.stateNode;
      d.pendingContext ? sh(g, d.pendingContext, d.pendingContext !== d.context) : d.context && sh(g, d.context, !1), gA(g, d.containerInfo);
    }
    function SV(g, d, G) {
      if (ZR(d), g === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var w = d.pendingProps, H = d.memoizedState, z = H.element;
      bt(g, d), Ea(d, w, null, G);
      var q = d.memoizedState;
      d.stateNode;
      var ee = q.element;
      if (Hi && H.isDehydrated) {
        var ue = {
          element: ee,
          isDehydrated: !1,
          cache: q.cache,
          transitions: q.transitions
        }, Ze = d.updateQueue;
        if (Ze.baseState = ue, d.memoizedState = ue, d.flags & Ii) {
          var _e = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return wR(g, d, ee, G, _e);
        } else if (ee !== z) {
          var st = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return wR(g, d, ee, G, st);
        } else {
          cc(d);
          var Zt = sA(d, null, ee, G);
          d.child = Zt;
          for (var Xt = Zt; Xt; )
            Xt.flags = Xt.flags & -3 | Ve, Xt = Xt.sibling;
        }
      } else {
        if (Fg(), ee === z)
          return Hh(g, d, G);
        Fu(g, d, ee, G);
      }
      return d.child;
    }
    function wR(g, d, G, w, H) {
      return Fg(), bh(H), d.flags |= Ii, Fu(g, d, G, w), d.child;
    }
    function ZV(g, d, G) {
      Bh(d), g === null && Yp(d);
      var w = d.type, H = d.pendingProps, z = g !== null ? g.memoizedProps : null, q = H.children, ee = bs(w, H);
      return ee ? q = null : z !== null && bs(w, z) && (d.flags |= di), SR(g, d), Fu(g, d, q, G), d.child;
    }
    function wV(g, d) {
      return g === null && Yp(d), null;
    }
    function eS(g, d, G, w) {
      g !== null && (g.alternate = null, d.alternate = null, d.flags |= je);
      var H = d.pendingProps, z = G, q = z._payload, ee = z._init, ue = ee(q);
      d.type = ue;
      var Ze = d.tag = _C(ue), _e = Wl(ue, H), st;
      switch (Ze) {
        case D:
          return ty(d, ue), d.type = ue = TC(ue), st = qB(null, d, ue, _e, w), st;
        case L:
          return d.type = ue = Am(ue), st = BV(null, d, ue, _e, w), st;
        case Xe:
          return d.type = ue = XS(ue), st = $v(null, d, ue, _e, w), st;
        case Be: {
          if (d.type !== d.elementType) {
            var Zt = ue.propTypes;
            Zt && vl(
              Zt,
              _e,
              // Resolved for outer only
              "prop",
              ht(ue)
            );
          }
          return st = ey(
            null,
            d,
            ue,
            Wl(ue.type, _e),
            // The inner type can have defaults too
            w
          ), st;
        }
      }
      var Xt = "";
      throw ue !== null && typeof ue == "object" && ue.$$typeof === $e && (Xt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + ue + ". " + ("Lazy element type must resolve to a class or function." + Xt));
    }
    function RV(g, d, G, w, H) {
      g !== null && (g.alternate = null, d.alternate = null, d.flags |= je), d.tag = L;
      var z;
      return Zs(G) ? (z = !0, qu(d)) : z = !1, ve(d, H), ti(d, G, w), Np(d, G, w, H), $B(null, d, G, !0, z, H);
    }
    function xV(g, d, G, w) {
      g !== null && (g.alternate = null, d.alternate = null, d.flags |= je);
      var H = d.pendingProps, z;
      {
        var q = fa(d, G, !1);
        z = yl(d, q);
      }
      ve(d, w);
      var ee, ue;
      nc(d);
      {
        if (G.prototype && typeof G.prototype.render == "function") {
          var Ze = ht(G) || "Unknown";
          Pp[Ze] || (f("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Ze, Ze), Pp[Ze] = !0);
        }
        d.mode & La && cs.recordLegacyContextWarning(d, null), lo(!0), jv.current = d, ee = U(null, d, G, H, z, w), ue = oe(), lo(!1);
      }
      if (ua(), d.flags |= it, typeof ee == "object" && ee !== null && typeof ee.render == "function" && ee.$$typeof === void 0) {
        var _e = ht(G) || "Unknown";
        qv[_e] || (f("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _e, _e, _e), qv[_e] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof ee == "object" && ee !== null && typeof ee.render == "function" && ee.$$typeof === void 0
      ) {
        {
          var st = ht(G) || "Unknown";
          qv[st] || (f("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", st, st, st), qv[st] = !0);
        }
        d.tag = L, d.memoizedState = null, d.updateQueue = null;
        var Zt = !1;
        return Zs(G) ? (Zt = !0, qu(d)) : Zt = !1, d.memoizedState = ee.state !== null && ee.state !== void 0 ? ee.state : null, Fe(d), Tb(d, ee), Np(d, G, H, w), $B(null, d, G, !0, Zt, w);
      } else {
        if (d.tag = D, d.mode & La) {
          ri(!0);
          try {
            ee = U(null, d, G, H, z, w), ue = oe();
          } finally {
            ri(!1);
          }
        }
        return Wo() && ue && uc(d), Fu(null, d, ee, w), ty(d, G), d.child;
      }
    }
    function ty(g, d) {
      {
        if (d && d.childContextTypes && f("%s(...): childContextTypes cannot be defined on a function component.", d.displayName || d.name || "Component"), g.ref !== null) {
          var G = "", w = fh();
          w && (G += `

Check the render method of \`` + w + "`.");
          var H = w || "", z = g._debugSource;
          z && (H = z.fileName + ":" + z.lineNumber), PB[H] || (PB[H] = !0, f("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", G));
        }
        if (typeof d.getDerivedStateFromProps == "function") {
          var q = ht(d) || "Unknown";
          OB[q] || (f("%s: Function components do not support getDerivedStateFromProps.", q), OB[q] = !0);
        }
        if (typeof d.contextType == "object" && d.contextType !== null) {
          var ee = ht(d) || "Unknown";
          l0[ee] || (f("%s: Function components do not support contextType.", ee), l0[ee] = !0);
        }
      }
    }
    var g0 = {
      dehydrated: null,
      treeContext: null,
      retryLane: no
    };
    function yA(g) {
      return {
        baseLanes: g,
        cachePool: bV()
      };
    }
    function tS(g, d) {
      var G = null;
      return {
        baseLanes: Wi(g.baseLanes, d),
        cachePool: G
      };
    }
    function WV(g, d, G, w) {
      if (d !== null) {
        var H = d.memoizedState;
        if (H === null)
          return !1;
      }
      return Kp(g, zp);
    }
    function RR(g, d) {
      return Eo(g.childLanes, d);
    }
    function xR(g, d, G) {
      var w = d.pendingProps;
      Ry(d) && (d.flags |= Jn);
      var H = Tg.current, z = !1, q = (d.flags & Jn) !== de;
      if (q || WV(H, g) ? (z = !0, d.flags &= -129) : (g === null || g.memoizedState !== null) && (H = kc(H, Nv)), H = Sh(H), Md(d, H), g === null) {
        Yp(d);
        {
          var ee = d.memoizedState;
          if (ee !== null) {
            var ue = ee.dehydrated;
            if (ue !== null)
              return NV(d, ue);
          }
        }
        var Ze = w.children, _e = w.fallback;
        if (z) {
          var st = WR(d, Ze, _e, G), Zt = d.child;
          return Zt.memoizedState = yA(G), d.memoizedState = g0, st;
        } else
          return nS(d, Ze);
      } else {
        var Xt = g.memoizedState;
        if (Xt !== null) {
          {
            var nn = Xt.dehydrated;
            if (nn !== null)
              if (q) {
                if (d.flags & Ii)
                  return d.flags &= -257, d0(g, d, G, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (d.memoizedState !== null)
                  return d.child = g.child, d.flags |= Jn, null;
                var Cn = w.children, yi = w.fallback, rr = VV(g, d, Cn, yi, G), Ni = d.child;
                return Ni.memoizedState = yA(G), d.memoizedState = g0, rr;
              } else return rS(g, d, nn, Xt, G);
          }
          if (z) {
            var Ja = w.fallback, Qa = w.children, Ct = MR(g, d, Qa, Ja, G), zt = d.child, dt = g.child.memoizedState;
            return zt.memoizedState = dt === null ? yA(G) : tS(dt, G), zt.childLanes = RR(g, G), d.memoizedState = g0, Ct;
          } else {
            var ln = w.children, gi = NR(g, d, ln, G);
            return d.memoizedState = null, gi;
          }
        } else if (z) {
          var Mn = w.fallback, mr = w.children, Pr = MR(g, d, mr, Mn, G), wr = d.child, Jr = g.child.memoizedState;
          return wr.memoizedState = Jr === null ? yA(G) : tS(Jr, G), wr.childLanes = RR(g, G), d.memoizedState = g0, Pr;
        } else {
          var ho = w.children, Yr = NR(g, d, ho, G);
          return d.memoizedState = null, Yr;
        }
      }
    }
    function nS(g, d, G) {
      var w = g.mode, H = {
        mode: "visible",
        children: d
      }, z = iS(H, w);
      return z.return = g, g.child = z, z;
    }
    function WR(g, d, G, w) {
      var H = g.mode, z = g.child, q = {
        mode: "hidden",
        children: d
      }, ee, ue;
      return (H & _r) === wi && z !== null ? (ee = z, ee.childLanes = Qt, ee.pendingProps = q, g.mode & vr && (ee.actualDuration = 0, ee.actualStartTime = -1, ee.selfBaseDuration = 0, ee.treeBaseDuration = 0), ue = zC(G, H, w, null)) : (ee = iS(q, H), ue = zC(G, H, w, null)), ee.return = g, ue.return = g, ee.sibling = ue, g.child = ee, ue;
    }
    function iS(g, d, G) {
      return yy(g, d, Qt, null);
    }
    function VR(g, d) {
      return Tl(g, d);
    }
    function NR(g, d, G, w) {
      var H = g.child, z = H.sibling, q = VR(H, {
        mode: "visible",
        children: G
      });
      if ((d.mode & _r) === wi && (q.lanes = w), q.return = d, q.sibling = null, z !== null) {
        var ee = d.deletions;
        ee === null ? (d.deletions = [z], d.flags |= Kn) : ee.push(z);
      }
      return d.child = q, q;
    }
    function MR(g, d, G, w, H) {
      var z = d.mode, q = g.child, ee = q.sibling, ue = {
        mode: "hidden",
        children: G
      }, Ze;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (z & _r) === wi && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        d.child !== q
      ) {
        var _e = d.child;
        Ze = _e, Ze.childLanes = Qt, Ze.pendingProps = ue, d.mode & vr && (Ze.actualDuration = 0, Ze.actualStartTime = -1, Ze.selfBaseDuration = q.selfBaseDuration, Ze.treeBaseDuration = q.treeBaseDuration), d.deletions = null;
      } else
        Ze = VR(q, ue), Ze.subtreeFlags = q.subtreeFlags & tn;
      var st;
      return ee !== null ? st = Tl(ee, w) : (st = zC(w, z, H, null), st.flags |= je), st.return = d, Ze.return = d, Ze.sibling = st, d.child = Ze, st;
    }
    function d0(g, d, G, w) {
      w !== null && bh(w), Kc(d, g.child, null, G);
      var H = d.pendingProps, z = H.children, q = nS(d, z);
      return q.flags |= je, d.memoizedState = null, q;
    }
    function VV(g, d, G, w, H) {
      var z = d.mode, q = {
        mode: "visible",
        children: G
      }, ee = iS(q, z), ue = zC(w, z, H, null);
      return ue.flags |= je, ee.return = d, ue.return = d, ee.sibling = ue, d.child = ee, (d.mode & _r) !== wi && Kc(d, g.child, null, H), ue;
    }
    function NV(g, d, G) {
      return (g.mode & _r) === wi ? (f("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), g.lanes = ji) : ur(d) ? g.lanes = qs : g.lanes = Bo, null;
    }
    function rS(g, d, G, w, H) {
      if (Lo(), (d.mode & _r) === wi)
        return d0(
          g,
          d,
          H,
          // TODO: When we delete legacy mode, we should make this error argument
          // required  every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (ur(G))
        return d0(
          g,
          d,
          H,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var z = xs(H, g.childLanes);
      if (hc || z) {
        var q = dy();
        if (q !== null) {
          var ee = Bp(q, H);
          if (ee !== no && ee !== w.retryLane) {
            w.retryLane = ee;
            var ue = yr;
            fs(g, ee, ue);
          }
        }
        return TA(), d0(g, d, H, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (Ui(G)) {
        d.flags |= Jn, d.child = g.child;
        var Ze = KA.bind(null, g);
        return nr(G, Ze), null;
      } else {
        yf(d, G, w.treeContext);
        var _e = d.pendingProps, st = _e.children, Zt = nS(d, st);
        return Zt.flags |= Ve, Zt;
      }
    }
    function HR(g, d, G) {
      g.lanes = Wi(g.lanes, d);
      var w = g.alternate;
      w !== null && (w.lanes = Wi(w.lanes, d)), E(g.return, d, G);
    }
    function MV(g, d, G) {
      for (var w = d; w !== null; ) {
        if (w.tag === Se) {
          var H = w.memoizedState;
          H !== null && HR(w, G, g);
        } else if (w.tag === Je)
          HR(w, G, g);
        else if (w.child !== null) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === g)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === g)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function HV(g) {
      for (var d = g, G = null; d !== null; ) {
        var w = d.alternate;
        w !== null && Zh(w) === null && (G = d), d = d.sibling;
      }
      return G;
    }
    function XV(g) {
      if (g !== void 0 && g !== "forwards" && g !== "backwards" && g !== "together" && !JB[g])
        if (JB[g] = !0, typeof g == "string")
          switch (g.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              f('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', g, g.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              f('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', g, g.toLowerCase());
              break;
            }
            default:
              f('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', g);
              break;
          }
        else
          f('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', g);
    }
    function YV(g, d) {
      g !== void 0 && !u0[g] && (g !== "collapsed" && g !== "hidden" ? (u0[g] = !0, f('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', g)) : d !== "forwards" && d !== "backwards" && (u0[g] = !0, f('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', g)));
    }
    function XR(g, d) {
      {
        var G = Xn(g), w = !G && typeof He(g) == "function";
        if (G || w) {
          var H = G ? "array" : "iterable";
          return f("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", H, d, H), !1;
        }
      }
      return !0;
    }
    function FV(g, d) {
      if ((d === "forwards" || d === "backwards") && g !== void 0 && g !== null && g !== !1)
        if (Xn(g)) {
          for (var G = 0; G < g.length; G++)
            if (!XR(g[G], G))
              return;
        } else {
          var w = He(g);
          if (typeof w == "function") {
            var H = w.call(g);
            if (H)
              for (var z = H.next(), q = 0; !z.done; z = H.next()) {
                if (!XR(z.value, q))
                  return;
                q++;
              }
          } else
            f('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', d);
        }
    }
    function aS(g, d, G, w, H) {
      var z = g.memoizedState;
      z === null ? g.memoizedState = {
        isBackwards: d,
        rendering: null,
        renderingStartTime: 0,
        last: w,
        tail: G,
        tailMode: H
      } : (z.isBackwards = d, z.rendering = null, z.renderingStartTime = 0, z.last = w, z.tail = G, z.tailMode = H);
    }
    function YR(g, d, G) {
      var w = d.pendingProps, H = w.revealOrder, z = w.tail, q = w.children;
      XV(H), YV(z, H), FV(q, H), Fu(g, d, q, G);
      var ee = Tg.current, ue = Kp(ee, zp);
      if (ue)
        ee = Mv(ee, zp), d.flags |= Jn;
      else {
        var Ze = g !== null && (g.flags & Jn) !== de;
        Ze && MV(d, d.child, G), ee = Sh(ee);
      }
      if (Md(d, ee), (d.mode & _r) === wi)
        d.memoizedState = null;
      else
        switch (H) {
          case "forwards": {
            var _e = HV(d.child), st;
            _e === null ? (st = d.child, d.child = null) : (st = _e.sibling, _e.sibling = null), aS(
              d,
              !1,
              // isBackwards
              st,
              _e,
              z
            );
            break;
          }
          case "backwards": {
            var Zt = null, Xt = d.child;
            for (d.child = null; Xt !== null; ) {
              var nn = Xt.alternate;
              if (nn !== null && Zh(nn) === null) {
                d.child = Xt;
                break;
              }
              var Cn = Xt.sibling;
              Xt.sibling = Zt, Zt = Xt, Xt = Cn;
            }
            aS(
              d,
              !0,
              // isBackwards
              Zt,
              null,
              // last
              z
            );
            break;
          }
          case "together": {
            aS(
              d,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            d.memoizedState = null;
        }
      return d.child;
    }
    function FR(g, d, G) {
      gA(d, d.stateNode.containerInfo);
      var w = d.pendingProps;
      return g === null ? d.child = Kc(d, null, w, G) : Fu(g, d, w, G), d.child;
    }
    var I0 = !1;
    function EV(g, d, G) {
      var w = d.type, H = w._context, z = d.pendingProps, q = d.memoizedProps, ee = z.value;
      {
        "value" in z || I0 || (I0 = !0, f("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var ue = d.type.propTypes;
        ue && vl(ue, z, "prop", "Context.Provider");
      }
      if (A(d, H, ee), q !== null) {
        var Ze = q.value;
        if (ca(Ze, ee)) {
          if (q.children === z.children && !Ql())
            return Hh(g, d, G);
        } else
          k(d, H, G);
      }
      var _e = z.children;
      return Fu(g, d, _e, G), d.child;
    }
    var ER = !1;
    function C0(g, d, G) {
      var w = d.type;
      w._context === void 0 ? w !== w.Consumer && (ER || (ER = !0, f("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : w = w._context;
      var H = d.pendingProps, z = H.children;
      typeof z != "function" && f("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), ve(d, G);
      var q = Ke(w);
      nc(d);
      var ee;
      return jv.current = d, lo(!0), ee = z(q), lo(!1), ua(), d.flags |= it, Fu(g, d, ee, G), d.child;
    }
    function Ff() {
      hc = !0;
    }
    function Hh(g, d, G) {
      return g !== null && (d.dependencies = g.dependencies), Xf(), EA(d.lanes), xs(G, d.childLanes) ? (Gh(g, d), d.child) : null;
    }
    function TV(g, d, G) {
      {
        var w = d.return;
        if (w === null)
          throw new Error("Cannot swap the root fiber.");
        if (g.alternate = null, d.alternate = null, G.index = d.index, G.sibling = d.sibling, G.return = d.return, G.ref = d.ref, d === w.child)
          w.child = G;
        else {
          var H = w.child;
          if (H === null)
            throw new Error("Expected parent to have a child.");
          for (; H.sibling !== d; )
            if (H = H.sibling, H === null)
              throw new Error("Expected to find the previous sibling.");
          H.sibling = G;
        }
        var z = w.deletions;
        return z === null ? (w.deletions = [g], w.flags |= Kn) : z.push(g), G.flags |= je, G;
      }
    }
    function oS(g, d) {
      var G = g.lanes;
      return !!xs(G, d);
    }
    function _V(g, d, G) {
      switch (d.tag) {
        case J:
          ZR(d), d.stateNode, Fg();
          break;
        case ne:
          Bh(d);
          break;
        case L: {
          var w = d.type;
          Zs(w) && qu(d);
          break;
        }
        case O:
          gA(d, d.stateNode.containerInfo);
          break;
        case Re: {
          var H = d.memoizedProps.value, z = d.type._context;
          A(d, z, H);
          break;
        }
        case re:
          {
            var q = xs(G, d.childLanes);
            q && (d.flags |= et);
            {
              var ee = d.stateNode;
              ee.effectDuration = 0, ee.passiveEffectDuration = 0;
            }
          }
          break;
        case Se: {
          var ue = d.memoizedState;
          if (ue !== null) {
            if (ue.dehydrated !== null)
              return Md(d, Sh(Tg.current)), d.flags |= Jn, null;
            var Ze = d.child, _e = Ze.childLanes;
            if (xs(G, _e))
              return xR(g, d, G);
            Md(d, Sh(Tg.current));
            var st = Hh(g, d, G);
            return st !== null ? st.sibling : null;
          } else
            Md(d, Sh(Tg.current));
          break;
        }
        case Je: {
          var Zt = (g.flags & Jn) !== de, Xt = xs(G, d.childLanes);
          if (Zt) {
            if (Xt)
              return YR(g, d, G);
            d.flags |= Jn;
          }
          var nn = d.memoizedState;
          if (nn !== null && (nn.rendering = null, nn.tail = null, nn.lastEffect = null), Md(d, Tg.current), Xt)
            break;
          return null;
        }
        case mt:
        case Dt:
          return d.lanes = Qt, vA(g, d, G);
      }
      return Hh(g, d, G);
    }
    function TR(g, d, G) {
      if (d._debugNeedsRemount && g !== null)
        return TV(g, d, Ay(d.type, d.key, d.pendingProps, d._debugOwner || null, d.mode, d.lanes));
      if (g !== null) {
        var w = g.memoizedProps, H = d.pendingProps;
        if (w !== H || Ql() || // Force a re-render if the implementation changed due to hot reload:
        d.type !== g.type)
          hc = !0;
        else {
          var z = oS(g, G);
          if (!z && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (d.flags & Jn) === de)
            return hc = !1, _V(g, d, G);
          (g.flags & Ie) !== de ? hc = !0 : hc = !1;
        }
      } else if (hc = !1, Wo() && zc(d)) {
        var q = d.index, ee = VI();
        Vv(d, ee, q);
      }
      switch (d.lanes = Qt, d.tag) {
        case j:
          return xV(g, d, d.type, G);
        case Ye: {
          var ue = d.elementType;
          return eS(g, d, ue, G);
        }
        case D: {
          var Ze = d.type, _e = d.pendingProps, st = d.elementType === Ze ? _e : Wl(Ze, _e);
          return qB(g, d, Ze, st, G);
        }
        case L: {
          var Zt = d.type, Xt = d.pendingProps, nn = d.elementType === Zt ? Xt : Wl(Zt, Xt);
          return BV(g, d, Zt, nn, G);
        }
        case J:
          return SV(g, d, G);
        case ne:
          return ZV(g, d, G);
        case he:
          return wV(g, d);
        case Se:
          return xR(g, d, G);
        case O:
          return FR(g, d, G);
        case Xe: {
          var Cn = d.type, yi = d.pendingProps, rr = d.elementType === Cn ? yi : Wl(Cn, yi);
          return $v(g, d, Cn, rr, G);
        }
        case pe:
          return GV(g, d, G);
        case Ae:
          return QB(g, d, G);
        case re:
          return jB(g, d, G);
        case Re:
          return EV(g, d, G);
        case ke:
          return C0(g, d, G);
        case Be: {
          var Ni = d.type, Ja = d.pendingProps, Qa = Wl(Ni, Ja);
          if (d.type !== d.elementType) {
            var Ct = Ni.propTypes;
            Ct && vl(
              Ct,
              Qa,
              // Resolved for outer only
              "prop",
              ht(Ni)
            );
          }
          return Qa = Wl(Ni.type, Qa), ey(g, d, Ni, Qa, G);
        }
        case le:
          return AA(g, d, d.type, d.pendingProps, G);
        case nt: {
          var zt = d.type, dt = d.pendingProps, ln = d.elementType === zt ? dt : Wl(zt, dt);
          return RV(g, d, zt, ln, G);
        }
        case Je:
          return YR(g, d, G);
        case wt:
          break;
        case mt:
          return vA(g, d, G);
      }
      throw new Error("Unknown unit of work tag (" + d.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function zV(g, d, G) {
      switch (Hp(d), d.tag) {
        case L: {
          var w = d.type;
          Zs(w) && fd(d);
          var H = d.flags;
          return H & Ln ? (d.flags = H & -65537 | Jn, (d.mode & vr) !== wi && n0(d), d) : null;
        }
        case J: {
          Lc(d), Go(d), CA();
          var z = d.flags;
          return (z & Ln) !== de && (z & Jn) === de ? (d.flags = z & -65537 | Jn, d) : null;
        }
        case ne:
          return dA(d), null;
        case Se: {
          Rf(d);
          {
            var q = d.memoizedState;
            if (q !== null && q.dehydrated !== null) {
              if (d.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              Fg();
            }
          }
          var ee = d.flags;
          return ee & Ln ? (d.flags = ee & -65537 | Jn, (d.mode & vr) !== wi && n0(d), d) : null;
        }
        case Je:
          return Rf(d), null;
        case O:
          return Lc(d), null;
        case Re:
          var ue = d.type._context;
          return V(ue, d), null;
        case mt:
        case Dt:
          return FA(d), null;
        case mn:
          return null;
        default:
          return null;
      }
    }
    function _R(g, d, G) {
      switch (Hp(d), d.tag) {
        case L: {
          var w = d.type.childContextTypes;
          w != null && fd(d);
          break;
        }
        case J: {
          Lc(d), Go(d), CA();
          break;
        }
        case ne: {
          dA(d);
          break;
        }
        case O:
          Lc(d);
          break;
        case Se:
          Rf(d);
          break;
        case Je:
          Rf(d);
          break;
        case Re:
          var H = d.type._context;
          V(H, d);
          break;
        case mt:
        case Dt:
          FA(d);
          break;
      }
    }
    function sS(g, d, G, w, H, z, q, ee, ue) {
      var Ze = Array.prototype.slice.call(arguments, 3);
      try {
        d.apply(G, Ze);
      } catch (_e) {
        this.onError(_e);
      }
    }
    var zR = sS;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var lS = document.createElement("react");
      zR = function(d, G, w, H, z, q, ee, ue, Ze) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var _e = document.createEvent("Event"), st = !1, Zt = !0, Xt = window.event, nn = Object.getOwnPropertyDescriptor(window, "event");
        function Cn() {
          lS.removeEventListener(zt, rr, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Xt);
        }
        var yi = Array.prototype.slice.call(arguments, 3);
        function rr() {
          st = !0, Cn(), G.apply(w, yi), Zt = !1;
        }
        var Ni, Ja = !1, Qa = !1;
        function Ct(dt) {
          if (Ni = dt.error, Ja = !0, Ni === null && dt.colno === 0 && dt.lineno === 0 && (Qa = !0), dt.defaultPrevented && Ni != null && typeof Ni == "object")
            try {
              Ni._suppressLogging = !0;
            } catch {
            }
        }
        var zt = "react-" + (d || "invokeguardedcallback");
        if (window.addEventListener("error", Ct), lS.addEventListener(zt, rr, !1), _e.initEvent(zt, !1, !1), lS.dispatchEvent(_e), nn && Object.defineProperty(window, "event", nn), st && Zt && (Ja ? Qa && (Ni = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Ni = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Ni)), window.removeEventListener("error", Ct), !st)
          return Cn(), sS.apply(this, arguments);
      };
    }
    var KV = zR, ny = !1, h0 = null, LV = {
      onError: function(g) {
        ny = !0, h0 = g;
      }
    };
    function KR(g, d, G, w, H, z, q, ee, ue) {
      ny = !1, h0 = null, KV.apply(LV, arguments);
    }
    function kV() {
      return ny;
    }
    function LR() {
      if (ny) {
        var g = h0;
        return ny = !1, h0 = null, g;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var kR = null;
    kR = /* @__PURE__ */ new Set();
    var f0 = !1, Ef = !1, DV = typeof WeakSet == "function" ? WeakSet : Set, Dn = null, bA = null, GA = null;
    function ns(g) {
      KR(null, function() {
        throw g;
      }), LR();
    }
    var BA = function(g, d) {
      if (d.props = g.memoizedProps, d.state = g.memoizedState, g.mode & vr)
        try {
          Cc(), d.componentWillUnmount();
        } finally {
          Ic(g);
        }
      else
        d.componentWillUnmount();
    };
    function p0(g, d) {
      try {
        Pc(go, g);
      } catch (G) {
        ns(G), ps(g, d, G);
      }
    }
    function Jp(g, d, G) {
      try {
        BA(g, G);
      } catch (w) {
        ns(w), ps(g, d, w);
      }
    }
    function uS(g, d, G) {
      try {
        G.componentDidMount();
      } catch (w) {
        ns(w), ps(g, d, w);
      }
    }
    function DR(g, d) {
      try {
        gS(g);
      } catch (G) {
        ns(G), ps(g, d, G);
      }
    }
    function m0(g, d) {
      var G = g.ref;
      if (G !== null)
        if (typeof G == "function") {
          var w;
          try {
            if (T && P && g.mode & vr)
              try {
                Cc(), w = G(null);
              } finally {
                Ic(g);
              }
            else
              w = G(null);
          } catch (H) {
            ns(H), ps(g, d, H);
          }
          typeof w == "function" && f("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", qe(g));
        } else
          G.current = null;
    }
    function A0(g, d, G) {
      try {
        G();
      } catch (w) {
        ns(w), ps(g, d, w);
      }
    }
    var SA = !1;
    function v0(g, d) {
      $r(g.containerInfo), Dn = d, UR();
      var G = SA;
      return SA = !1, G;
    }
    function UR() {
      for (; Dn !== null; ) {
        var g = Dn, d = g.child;
        (g.subtreeFlags & Te) !== de && d !== null ? (Td(d, g), Dn = d) : iy();
      }
    }
    function iy() {
      for (; Dn !== null; ) {
        var g = Dn;
        so(g);
        try {
          Qp(g);
        } catch (G) {
          ns(G), ps(g, g.return, G);
        }
        ra();
        var d = g.sibling;
        if (d !== null) {
          Td(d, g.return), Dn = d;
          return;
        }
        Dn = g.return;
      }
    }
    function Qp(g) {
      var d = g.alternate, G = g.flags;
      if ((G & xr) !== de) {
        switch (so(g), g.tag) {
          case D:
          case Xe:
          case le:
            break;
          case L: {
            if (d !== null) {
              var w = d.memoizedProps, H = d.memoizedState, z = g.stateNode;
              g.type === g.elementType && !Yf && (z.props !== g.memoizedProps && f("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", qe(g) || "instance"), z.state !== g.memoizedState && f("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", qe(g) || "instance"));
              var q = z.getSnapshotBeforeUpdate(g.elementType === g.type ? w : Wl(g.type, w), H);
              {
                var ee = kR;
                q === void 0 && !ee.has(g.type) && (ee.add(g.type), f("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", qe(g)));
              }
              z.__reactInternalSnapshotBeforeUpdate = q;
            }
            break;
          }
          case J: {
            if (Yo) {
              var ue = g.stateNode;
              th(ue.containerInfo);
            }
            break;
          }
          case ne:
          case he:
          case O:
          case nt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        ra();
      }
    }
    function Cs(g, d, G) {
      var w = d.updateQueue, H = w !== null ? w.lastEffect : null;
      if (H !== null) {
        var z = H.next, q = z;
        do {
          if ((q.tag & g) === g) {
            var ee = q.destroy;
            q.destroy = void 0, ee !== void 0 && ((g & Ms) !== ll ? nu(d) : (g & go) !== ll && uC(d), A0(d, G, ee), (g & Ms) !== ll ? ZI() : (g & go) !== ll && Wg());
          }
          q = q.next;
        } while (q !== z);
      }
    }
    function Pc(g, d) {
      var G = d.updateQueue, w = G !== null ? G.lastEffect : null;
      if (w !== null) {
        var H = w.next, z = H;
        do {
          if ((z.tag & g) === g) {
            (g & Ms) !== ll ? SI(d) : (g & go) !== ll && xg(d);
            var q = z.create;
            z.destroy = q(), (g & Ms) !== ll ? ic() : (g & go) !== ll && Ro();
            {
              var ee = z.destroy;
              if (ee !== void 0 && typeof ee != "function") {
                var ue = void 0;
                (z.tag & go) !== de ? ue = "useLayoutEffect" : (z.tag & Yu) !== de ? ue = "useInsertionEffect" : ue = "useEffect";
                var Ze = void 0;
                ee === null ? Ze = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof ee.then == "function" ? Ze = `

It looks like you wrote ` + ue + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + ue + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Ze = " You returned: " + ee, f("%s must not return anything besides a function, which is used for clean-up.%s", ue, Ze);
              }
            }
          }
          z = z.next;
        } while (z !== H);
      }
    }
    function y0(g, d) {
      if ((d.flags & et) !== de)
        switch (d.tag) {
          case re: {
            var G = d.stateNode.passiveEffectDuration, w = d.memoizedProps, H = w.id, z = w.onPostCommit, q = Dv(), ee = d.alternate === null ? "mount" : "update";
            mR() && (ee = "nested-update"), typeof z == "function" && z(H, ee, G, q);
            var ue = d.return;
            e: for (; ue !== null; ) {
              switch (ue.tag) {
                case J:
                  var Ze = ue.stateNode;
                  Ze.passiveEffectDuration += G;
                  break e;
                case re:
                  var _e = ue.stateNode;
                  _e.passiveEffectDuration += G;
                  break e;
              }
              ue = ue.return;
            }
            break;
          }
        }
    }
    function cS(g, d, G, w) {
      if ((G.flags & Ee) !== de)
        switch (G.tag) {
          case D:
          case Xe:
          case le: {
            if (!Ef)
              if (G.mode & vr)
                try {
                  Cc(), Pc(go | ma, G);
                } finally {
                  Ic(G);
                }
              else
                Pc(go | ma, G);
            break;
          }
          case L: {
            var H = G.stateNode;
            if (G.flags & et && !Ef)
              if (d === null)
                if (G.type === G.elementType && !Yf && (H.props !== G.memoizedProps && f("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", qe(G) || "instance"), H.state !== G.memoizedState && f("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", qe(G) || "instance")), G.mode & vr)
                  try {
                    Cc(), H.componentDidMount();
                  } finally {
                    Ic(G);
                  }
                else
                  H.componentDidMount();
              else {
                var z = G.elementType === G.type ? d.memoizedProps : Wl(G.type, d.memoizedProps), q = d.memoizedState;
                if (G.type === G.elementType && !Yf && (H.props !== G.memoizedProps && f("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", qe(G) || "instance"), H.state !== G.memoizedState && f("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", qe(G) || "instance")), G.mode & vr)
                  try {
                    Cc(), H.componentDidUpdate(z, q, H.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Ic(G);
                  }
                else
                  H.componentDidUpdate(z, q, H.__reactInternalSnapshotBeforeUpdate);
              }
            var ee = G.updateQueue;
            ee !== null && (G.type === G.elementType && !Yf && (H.props !== G.memoizedProps && f("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", qe(G) || "instance"), H.state !== G.memoizedState && f("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", qe(G) || "instance")), Wp(G, ee, H));
            break;
          }
          case J: {
            var ue = G.updateQueue;
            if (ue !== null) {
              var Ze = null;
              if (G.child !== null)
                switch (G.child.tag) {
                  case ne:
                    Ze = li(G.child.stateNode);
                    break;
                  case L:
                    Ze = G.child.stateNode;
                    break;
                }
              Wp(G, ue, Ze);
            }
            break;
          }
          case ne: {
            var _e = G.stateNode;
            if (d === null && G.flags & et) {
              var st = G.type, Zt = G.memoizedProps;
              hg(_e, st, Zt, G);
            }
            break;
          }
          case he:
            break;
          case O:
            break;
          case re: {
            {
              var Xt = G.memoizedProps, nn = Xt.onCommit, Cn = Xt.onRender, yi = G.stateNode.effectDuration, rr = Dv(), Ni = d === null ? "mount" : "update";
              mR() && (Ni = "nested-update"), typeof Cn == "function" && Cn(G.memoizedProps.id, Ni, G.actualDuration, G.treeBaseDuration, G.actualStartTime, rr);
              {
                typeof nn == "function" && nn(G.memoizedProps.id, Ni, yi, rr), zA(G);
                var Ja = G.return;
                e: for (; Ja !== null; ) {
                  switch (Ja.tag) {
                    case J:
                      var Qa = Ja.stateNode;
                      Qa.effectDuration += yi;
                      break e;
                    case re:
                      var Ct = Ja.stateNode;
                      Ct.effectDuration += yi;
                      break e;
                  }
                  Ja = Ja.return;
                }
              }
            }
            break;
          }
          case Se: {
            NC(g, G);
            break;
          }
          case Je:
          case nt:
          case wt:
          case mt:
          case Dt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Ef || G.flags & dr && gS(G);
    }
    function UV(g) {
      switch (g.tag) {
        case D:
        case Xe:
        case le: {
          if (g.mode & vr)
            try {
              Cc(), p0(g, g.return);
            } finally {
              Ic(g);
            }
          else
            p0(g, g.return);
          break;
        }
        case L: {
          var d = g.stateNode;
          typeof d.componentDidMount == "function" && uS(g, g.return, d), DR(g, g.return);
          break;
        }
        case ne: {
          DR(g, g.return);
          break;
        }
      }
    }
    function OR(g, d) {
      var G = null;
      if (Yo)
        for (var w = g; ; ) {
          if (w.tag === ne) {
            if (G === null) {
              G = w;
              var H = w.stateNode;
              d ? ld(H) : pg(w.stateNode, w.memoizedProps);
            }
          } else if (w.tag === he) {
            if (G === null) {
              var z = w.stateNode;
              d ? fg(z) : Os(z, w.memoizedProps);
            }
          } else if (!((w.tag === mt || w.tag === Dt) && w.memoizedState !== null && w !== g)) {
            if (w.child !== null) {
              w.child.return = w, w = w.child;
              continue;
            }
          }
          if (w === g)
            return;
          for (; w.sibling === null; ) {
            if (w.return === null || w.return === g)
              return;
            G === w && (G = null), w = w.return;
          }
          G === w && (G = null), w.sibling.return = w.return, w = w.sibling;
        }
    }
    function gS(g) {
      var d = g.ref;
      if (d !== null) {
        var G = g.stateNode, w;
        switch (g.tag) {
          case ne:
            w = li(G);
            break;
          default:
            w = G;
        }
        if (typeof d == "function") {
          var H;
          if (g.mode & vr)
            try {
              Cc(), H = d(w);
            } finally {
              Ic(g);
            }
          else
            H = d(w);
          typeof H == "function" && f("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", qe(g));
        } else
          d.hasOwnProperty("current") || f("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", qe(g)), d.current = w;
      }
    }
    function b0(g) {
      var d = g.ref;
      if (d !== null)
        if (typeof d == "function")
          if (g.mode & vr)
            try {
              Cc(), d(null);
            } finally {
              Ic(g);
            }
          else
            d(null);
        else
          d.current = null;
    }
    function Xd(g, d, G) {
      switch (Vr(d), d.tag) {
        case D:
        case Xe:
        case Be:
        case le: {
          var w = d.updateQueue;
          if (w !== null) {
            var H = w.lastEffect;
            if (H !== null) {
              var z = H.next, q = z;
              do {
                var ee = q, ue = ee.destroy, Ze = ee.tag;
                ue !== void 0 && ((Ze & Yu) !== ll ? A0(d, G, ue) : (Ze & go) !== ll && (uC(d), d.mode & vr ? (Cc(), A0(d, G, ue), Ic(d)) : A0(d, G, ue), Wg())), q = q.next;
              } while (q !== z);
            }
          }
          return;
        }
        case L: {
          m0(d, G);
          var _e = d.stateNode;
          typeof _e.componentWillUnmount == "function" && Jp(d, G, _e);
          return;
        }
        case ne: {
          m0(d, G);
          return;
        }
        case O: {
          Yo ? jp(g, d, G) : Cu && Tf(d);
          return;
        }
        case ze:
          return;
        case wt:
          return;
      }
    }
    function G0(g, d, G) {
      for (var w = d; ; ) {
        if (Xd(g, w, G), w.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!Yo || w.tag !== O)) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === d)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === d)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function B0(g) {
      var d = g.alternate;
      d !== null && (d.return = null), g.return = null;
    }
    function WC(g) {
      var d = g.alternate;
      d !== null && (g.alternate = null, WC(d));
      {
        if (g.child = null, g.deletions = null, g.sibling = null, g.tag === ne) {
          var G = g.stateNode;
          G !== null && Ju(G);
        }
        g.stateNode = null, g._debugOwner = null, g.return = null, g.dependencies = null, g.memoizedProps = null, g.memoizedState = null, g.pendingProps = null, g.stateNode = null, g.updateQueue = null;
      }
    }
    function Tf(g) {
      if (Cu) {
        var d = g.stateNode, G = d.containerInfo, w = hI(G);
        gt(G, w);
      }
    }
    function Eu(g) {
      if (Cu) {
        switch (g.tag) {
          case L:
          case ne:
          case he:
            return;
          case J:
          case O: {
            var d = g.stateNode, G = d.containerInfo, w = d.pendingChildren;
            gt(G, w);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function Tu(g) {
      for (var d = g.return; d !== null; ) {
        if (S0(d))
          return d;
        d = d.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function S0(g) {
      return g.tag === ne || g.tag === J || g.tag === O;
    }
    function Jc(g) {
      var d = g;
      e: for (; ; ) {
        for (; d.sibling === null; ) {
          if (d.return === null || S0(d.return))
            return null;
          d = d.return;
        }
        for (d.sibling.return = d.return, d = d.sibling; d.tag !== ne && d.tag !== he && d.tag !== ze; ) {
          if (d.flags & je || d.child === null || d.tag === O)
            continue e;
          d.child.return = d, d = d.child;
        }
        if (!(d.flags & je))
          return d.stateNode;
      }
    }
    function VC(g) {
      if (Yo) {
        var d = Tu(g);
        switch (d.tag) {
          case ne: {
            var G = d.stateNode;
            d.flags & di && (Ul(G), d.flags &= -33);
            var w = Jc(g);
            ry(g, w, G);
            break;
          }
          case J:
          case O: {
            var H = d.stateNode.containerInfo, z = Jc(g);
            Yd(g, z, H);
            break;
          }
          // eslint-disable-next-line-no-fallthrough
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function Yd(g, d, G) {
      var w = g.tag, H = w === ne || w === he;
      if (H) {
        var z = g.stateNode;
        d ? pu(G, z, d) : sd(G, z);
      } else if (w !== O) {
        var q = g.child;
        if (q !== null) {
          Yd(q, d, G);
          for (var ee = q.sibling; ee !== null; )
            Yd(ee, d, G), ee = ee.sibling;
        }
      }
    }
    function ry(g, d, G) {
      var w = g.tag, H = w === ne || w === he;
      if (H) {
        var z = g.stateNode;
        d ? CI(G, z, d) : Ap(G, z);
      } else if (w !== O) {
        var q = g.child;
        if (q !== null) {
          ry(q, d, G);
          for (var ee = q.sibling; ee !== null; )
            ry(ee, d, G), ee = ee.sibling;
        }
      }
    }
    function jp(g, d, G) {
      for (var w = d, H = !1, z, q; ; ) {
        if (!H) {
          var ee = w.return;
          e: for (; ; ) {
            if (ee === null)
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            var ue = ee.stateNode;
            switch (ee.tag) {
              case ne:
                z = ue, q = !1;
                break e;
              case J:
                z = ue.containerInfo, q = !0;
                break e;
              case O:
                z = ue.containerInfo, q = !0;
                break e;
            }
            ee = ee.return;
          }
          H = !0;
        }
        if (w.tag === ne || w.tag === he)
          G0(g, w, G), q ? Bs(z, w.stateNode) : $a(z, w.stateNode);
        else if (w.tag === ze)
          q ? ih(z, w.stateNode) : nh(z, w.stateNode);
        else if (w.tag === O) {
          if (w.child !== null) {
            z = w.stateNode.containerInfo, q = !0, w.child.return = w, w = w.child;
            continue;
          }
        } else if (Xd(g, w, G), w.child !== null) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === d)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === d)
            return;
          w = w.return, w.tag === O && (H = !1);
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function PR(g, d, G) {
      Yo ? jp(g, d, G) : G0(g, d, G), B0(d);
    }
    function _f(g, d) {
      if (!Yo) {
        switch (d.tag) {
          case D:
          case Xe:
          case Be:
          case le: {
            if (Cs(Yu | ma, d, d.return), Pc(Yu | ma, d), d.mode & vr)
              try {
                Cc(), Cs(go | ma, d, d.return);
              } finally {
                Ic(d);
              }
            else
              Cs(go | ma, d, d.return);
            return;
          }
          case re:
            return;
          case Se: {
            ay(d), qp(d);
            return;
          }
          case Je: {
            qp(d);
            return;
          }
          case J: {
            if (Hi && g !== null) {
              var G = g.memoizedState;
              if (G.isDehydrated) {
                var w = d.stateNode;
                mg(w.containerInfo);
              }
            }
            break;
          }
          case mt:
          case Dt:
            return;
        }
        Eu(d);
        return;
      }
      switch (d.tag) {
        case D:
        case Xe:
        case Be:
        case le: {
          if (Cs(Yu | ma, d, d.return), Pc(Yu | ma, d), d.mode & vr)
            try {
              Cc(), Cs(go | ma, d, d.return);
            } finally {
              Ic(d);
            }
          else
            Cs(go | ma, d, d.return);
          return;
        }
        case L:
          return;
        case ne: {
          var H = d.stateNode;
          if (H != null) {
            var z = d.memoizedProps, q = g !== null ? g.memoizedProps : z, ee = d.type, ue = d.updateQueue;
            d.updateQueue = null, ue !== null && Us(H, ue, ee, q, z, d);
          }
          return;
        }
        case he: {
          if (d.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var Ze = d.stateNode, _e = d.memoizedProps, st = g !== null ? g.memoizedProps : _e;
          II(Ze, st, _e);
          return;
        }
        case J: {
          if (Hi && g !== null) {
            var Zt = g.memoizedState;
            if (Zt.isDehydrated) {
              var Xt = d.stateNode;
              mg(Xt.containerInfo);
            }
          }
          return;
        }
        case re:
          return;
        case Se: {
          ay(d), qp(d);
          return;
        }
        case Je: {
          qp(d);
          return;
        }
        case nt:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ay(g) {
      g.memoizedState;
    }
    function NC(g, d) {
      if (Hi) {
        var G = d.memoizedState;
        if (G === null) {
          var w = d.alternate;
          if (w !== null) {
            var H = w.memoizedState;
            if (H !== null) {
              var z = H.dehydrated;
              z !== null && lf(z);
            }
          }
        }
      }
    }
    function qp(g) {
      var d = g.updateQueue;
      if (d !== null) {
        g.updateQueue = null;
        var G = g.stateNode;
        G === null && (G = g.stateNode = new DV()), d.forEach(function(w) {
          var H = MS.bind(null, g, w);
          if (!G.has(w)) {
            if (G.add(w), tr)
              if (bA !== null && GA !== null)
                py(GA, bA);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            w.then(H, H);
          }
        });
      }
    }
    function dS(g) {
      Yo && Ul(g.stateNode);
    }
    function JR(g, d, G) {
      bA = G, GA = g, Dn = d, QR(g, G), bA = null, GA = null;
    }
    function QR(g, d) {
      for (; Dn !== null; ) {
        var G = Dn, w = G.deletions;
        if (w !== null)
          for (var H = 0; H < w.length; H++) {
            var z = w[H];
            try {
              PR(g, z, G);
            } catch (ee) {
              ns(ee), ps(z, G, ee);
            }
          }
        var q = G.child;
        (G.subtreeFlags & De) !== de && q !== null ? (Td(q, G), Dn = q) : Z0(g, d);
      }
    }
    function Z0(g, d) {
      for (; Dn !== null; ) {
        var G = Dn;
        so(G);
        try {
          jR(G, g, d);
        } catch (H) {
          ns(H), ps(G, G.return, H);
        }
        ra();
        var w = G.sibling;
        if (w !== null) {
          Td(w, G.return), Dn = w;
          return;
        }
        Dn = G.return;
      }
    }
    function jR(g, d, G) {
      var w = g.flags;
      if (w & di && dS(g), w & dr) {
        var H = g.alternate;
        H !== null && b0(H);
      }
      if (w & rt)
        switch (g.tag) {
          case Se: {
            var z = g.memoizedState, q = z !== null;
            if (q) {
              var ee = g.alternate, ue = ee !== null && ee.memoizedState !== null;
              ue || z0();
            }
            break;
          }
          case mt: {
            var Ze = g.memoizedState, _e = Ze !== null, st = g.alternate, Zt = st !== null && st.memoizedState !== null, Xt = g;
            Yo && OR(Xt, _e);
            {
              if (_e && !Zt && (Xt.mode & _r) !== wi) {
                Dn = Xt;
                for (var nn = Xt.child; nn !== null; )
                  Dn = nn, Yh(nn), nn = nn.sibling;
              }
              break;
            }
          }
        }
      var Cn = w & (je | et | Ve);
      switch (Cn) {
        case je: {
          VC(g), g.flags &= -3;
          break;
        }
        case Jt: {
          VC(g), g.flags &= -3;
          var yi = g.alternate;
          _f(yi, g);
          break;
        }
        case Ve: {
          g.flags &= -4097;
          break;
        }
        case Oe: {
          g.flags &= -4097;
          var rr = g.alternate;
          _f(rr, g);
          break;
        }
        case et: {
          var Ni = g.alternate;
          _f(Ni, g);
          break;
        }
      }
    }
    function OV(g, d, G) {
      bA = G, GA = d, Dn = g, Xh(g, d, G), bA = null, GA = null;
    }
    function Xh(g, d, G) {
      for (var w = (g.mode & _r) !== wi; Dn !== null; ) {
        var H = Dn, z = H.child;
        if (H.tag === mt && w) {
          var q = H.memoizedState !== null, ee = q || f0;
          if (ee) {
            ZA(g, d, G);
            continue;
          } else {
            var ue = H.alternate, Ze = ue !== null && ue.memoizedState !== null, _e = Ze || Ef, st = f0, Zt = Ef;
            f0 = ee, Ef = _e, Ef && !Zt && (Dn = H, IS(H));
            for (var Xt = z; Xt !== null; )
              Dn = Xt, Xh(
                Xt,
                // New root; bubble back up to here and stop.
                d,
                G
              ), Xt = Xt.sibling;
            Dn = H, f0 = st, Ef = Zt, ZA(g, d, G);
            continue;
          }
        }
        (H.subtreeFlags & Ee) !== de && z !== null ? (Td(z, H), Dn = z) : ZA(g, d, G);
      }
    }
    function ZA(g, d, G) {
      for (; Dn !== null; ) {
        var w = Dn;
        if ((w.flags & Ee) !== de) {
          var H = w.alternate;
          so(w);
          try {
            cS(d, H, w, G);
          } catch (q) {
            ns(q), ps(w, w.return, q);
          }
          ra();
        }
        if (w === g) {
          Dn = null;
          return;
        }
        var z = w.sibling;
        if (z !== null) {
          Td(z, w.return), Dn = z;
          return;
        }
        Dn = w.return;
      }
    }
    function Yh(g) {
      for (; Dn !== null; ) {
        var d = Dn, G = d.child;
        switch (d.tag) {
          case D:
          case Xe:
          case Be:
          case le: {
            if (d.mode & vr)
              try {
                Cc(), Cs(go, d, d.return);
              } finally {
                Ic(d);
              }
            else
              Cs(go, d, d.return);
            break;
          }
          case L: {
            m0(d, d.return);
            var w = d.stateNode;
            typeof w.componentWillUnmount == "function" && Jp(d, d.return, w);
            break;
          }
          case ne: {
            m0(d, d.return);
            break;
          }
          case mt: {
            var H = d.memoizedState !== null;
            if (H) {
              w0(g);
              continue;
            }
            break;
          }
        }
        G !== null ? (G.return = d, Dn = G) : w0(g);
      }
    }
    function w0(g) {
      for (; Dn !== null; ) {
        var d = Dn;
        if (d === g) {
          Dn = null;
          return;
        }
        var G = d.sibling;
        if (G !== null) {
          G.return = d.return, Dn = G;
          return;
        }
        Dn = d.return;
      }
    }
    function IS(g) {
      for (; Dn !== null; ) {
        var d = Dn, G = d.child;
        if (d.tag === mt) {
          var w = d.memoizedState !== null;
          if (w) {
            CS(g);
            continue;
          }
        }
        G !== null ? (G.return = d, Dn = G) : CS(g);
      }
    }
    function CS(g) {
      for (; Dn !== null; ) {
        var d = Dn;
        so(d);
        try {
          UV(d);
        } catch (w) {
          ns(w), ps(d, d.return, w);
        }
        if (ra(), d === g) {
          Dn = null;
          return;
        }
        var G = d.sibling;
        if (G !== null) {
          G.return = d.return, Dn = G;
          return;
        }
        Dn = d.return;
      }
    }
    function PV(g, d) {
      Dn = d, qR(d, g);
    }
    function qR(g, d) {
      for (; Dn !== null; ) {
        var G = Dn, w = G.child;
        (G.subtreeFlags & Tt) !== de && w !== null ? (Td(w, G), Dn = w) : zf(g, d);
      }
    }
    function zf(g, d) {
      for (; Dn !== null; ) {
        var G = Dn;
        if ((G.flags & la) !== de) {
          so(G);
          try {
            wA(d, G);
          } catch (H) {
            ns(H), ps(G, G.return, H);
          }
          ra();
        }
        if (G === g) {
          Dn = null;
          return;
        }
        var w = G.sibling;
        if (w !== null) {
          Td(w, G.return), Dn = w;
          return;
        }
        Dn = G.return;
      }
    }
    function wA(g, d) {
      switch (d.tag) {
        case D:
        case Xe:
        case le: {
          if (d.mode & vr) {
            Dp();
            try {
              Pc(Ms | ma, d);
            } finally {
              Uv(d);
            }
          } else
            Pc(Ms | ma, d);
          break;
        }
      }
    }
    function RA(g) {
      Dn = g, R0();
    }
    function R0() {
      for (; Dn !== null; ) {
        var g = Dn, d = g.child;
        if ((Dn.flags & Kn) !== de) {
          var G = g.deletions;
          if (G !== null) {
            for (var w = 0; w < G.length; w++) {
              var H = G[w];
              Dn = H, Ed(H, g);
            }
            {
              var z = g.alternate;
              if (z !== null) {
                var q = z.child;
                if (q !== null) {
                  z.child = null;
                  do {
                    var ee = q.sibling;
                    q.sibling = null, q = ee;
                  } while (q !== null);
                }
              }
            }
            Dn = g;
          }
        }
        (g.subtreeFlags & Tt) !== de && d !== null ? (Td(d, g), Dn = d) : x0();
      }
    }
    function x0() {
      for (; Dn !== null; ) {
        var g = Dn;
        (g.flags & la) !== de && (so(g), Fd(g), ra());
        var d = g.sibling;
        if (d !== null) {
          Td(d, g.return), Dn = d;
          return;
        }
        Dn = g.return;
      }
    }
    function Fd(g) {
      switch (g.tag) {
        case D:
        case Xe:
        case le: {
          g.mode & vr ? (Dp(), Cs(Ms | ma, g, g.return), Uv(g)) : Cs(Ms | ma, g, g.return);
          break;
        }
      }
    }
    function Ed(g, d) {
      for (; Dn !== null; ) {
        var G = Dn;
        so(G), Fh(G, d), ra();
        var w = G.child;
        w !== null ? (Td(w, G), Dn = w) : $p(g);
      }
    }
    function $p(g) {
      for (; Dn !== null; ) {
        var d = Dn, G = d.sibling, w = d.return;
        if (WC(d), d === g) {
          Dn = null;
          return;
        }
        if (G !== null) {
          Td(G, w), Dn = G;
          return;
        }
        Dn = w;
      }
    }
    function Fh(g, d) {
      switch (g.tag) {
        case D:
        case Xe:
        case le: {
          g.mode & vr ? (Dp(), Cs(Ms, g, d), Uv(g)) : Cs(Ms, g, d);
          break;
        }
      }
    }
    var MC = !1;
    function Td(g, d) {
      !MC && g.return !== d && (MC = !0, f("Internal React error: Return pointer is inconsistent with parent.")), g.return = d;
    }
    function JV(g) {
      switch (g.tag) {
        case D:
        case Xe:
        case le: {
          try {
            Pc(go | ma, g);
          } catch (G) {
            ns(G), ps(g, g.return, G);
          }
          break;
        }
        case L: {
          var d = g.stateNode;
          try {
            d.componentDidMount();
          } catch (G) {
            ns(G), ps(g, g.return, G);
          }
          break;
        }
      }
    }
    function QV(g) {
      switch (g.tag) {
        case D:
        case Xe:
        case le: {
          try {
            Pc(Ms | ma, g);
          } catch (d) {
            ns(d), ps(g, g.return, d);
          }
          break;
        }
      }
    }
    function em(g) {
      switch (g.tag) {
        case D:
        case Xe:
        case le: {
          try {
            Cs(go | ma, g, g.return);
          } catch (G) {
            ns(G), ps(g, g.return, G);
          }
          break;
        }
        case L: {
          var d = g.stateNode;
          typeof d.componentWillUnmount == "function" && Jp(g, g.return, d);
          break;
        }
      }
    }
    function $R(g) {
      switch (g.tag) {
        case D:
        case Xe:
        case le:
          try {
            Cs(Ms | ma, g, g.return);
          } catch (d) {
            ns(d), ps(g, g.return, d);
          }
      }
    }
    var xA = 0, tm = 1, W0 = 2, WA = 3, V0 = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var oy = Symbol.for;
      xA = oy("selector.component"), tm = oy("selector.has_pseudo_class"), W0 = oy("selector.role"), WA = oy("selector.test_id"), V0 = oy("selector.text");
    }
    function nm(g) {
      return {
        $$typeof: xA,
        value: g
      };
    }
    function ou(g) {
      return {
        $$typeof: tm,
        value: g
      };
    }
    function _d(g) {
      return {
        $$typeof: W0,
        value: g
      };
    }
    function YI(g) {
      return {
        $$typeof: V0,
        value: g
      };
    }
    function im(g) {
      return {
        $$typeof: WA,
        value: g
      };
    }
    function HC(g) {
      var d = sf(g);
      if (d != null) {
        if (typeof d.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return d;
      } else {
        var G = Qu(g);
        if (G === null)
          throw new Error("Could not find React container within specified host subtree.");
        return G.stateNode.current;
      }
    }
    function hS(g, d) {
      switch (d.$$typeof) {
        case xA:
          if (g.type === d.value)
            return !0;
          break;
        case tm:
          return jV(g, d.value);
        case W0:
          if (g.tag === ne) {
            var G = g.stateNode;
            if (fu(G, d.value))
              return !0;
          }
          break;
        case V0:
          if (g.tag === ne || g.tag === he) {
            var w = Lr(g);
            if (w !== null && w.indexOf(d.value) >= 0)
              return !0;
          }
          break;
        case WA:
          if (g.tag === ne) {
            var H = g.memoizedProps["data-testname"];
            if (typeof H == "string" && H.toLowerCase() === d.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function N0(g) {
      switch (g.$$typeof) {
        case xA:
          var d = ht(g.value) || "Unknown";
          return "<" + d + ">";
        case tm:
          return ":has(" + (N0(g) || "") + ")";
        case W0:
          return '[role="' + g.value + '"]';
        case V0:
          return '"' + g.value + '"';
        case WA:
          return '[data-testname="' + g.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function ex(g, d) {
      for (var G = [], w = [g, 0], H = 0; H < w.length; ) {
        var z = w[H++], q = w[H++], ee = d[q];
        if (!(z.tag === ne && Ds(z))) {
          for (; ee != null && hS(z, ee); )
            q++, ee = d[q];
          if (q === d.length)
            G.push(z);
          else
            for (var ue = z.child; ue !== null; )
              w.push(ue, q), ue = ue.sibling;
        }
      }
      return G;
    }
    function jV(g, d) {
      for (var G = [g, 0], w = 0; w < G.length; ) {
        var H = G[w++], z = G[w++], q = d[z];
        if (!(H.tag === ne && Ds(H))) {
          for (; q != null && hS(H, q); )
            z++, q = d[z];
          if (z === d.length)
            return !0;
          for (var ee = H.child; ee !== null; )
            G.push(ee, z), ee = ee.sibling;
        }
      }
      return !1;
    }
    function M0(g, d) {
      if (!Bi)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var G = HC(g), w = ex(G, d), H = [], z = Array.from(w), q = 0; q < z.length; ) {
        var ee = z[q++];
        if (ee.tag === ne) {
          if (Ds(ee))
            continue;
          H.push(ee.stateNode);
        } else
          for (var ue = ee.child; ue !== null; )
            z.push(ue), ue = ue.sibling;
      }
      return H;
    }
    function tx(g, d) {
      if (!Bi)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var G = HC(g), w = 0, H = [], z = [G, 0], q = 0; q < z.length; ) {
        var ee = z[q++], ue = z[q++], Ze = d[ue];
        if (!(ee.tag === ne && Ds(ee)) && (hS(ee, Ze) && (H.push(N0(Ze)), ue++, ue > w && (w = ue)), ue < d.length))
          for (var _e = ee.child; _e !== null; )
            z.push(_e, ue), _e = _e.sibling;
      }
      if (w < d.length) {
        for (var st = [], Zt = w; Zt < d.length; Zt++)
          st.push(N0(d[Zt]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + H.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + st.join(" > "));
      }
      return null;
    }
    function nx(g, d) {
      if (!Bi)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var G = M0(g, d), w = [], H = 0; H < G.length; H++)
        w.push(Ra(G[H]));
      for (var z = w.length - 1; z > 0; z--)
        for (var q = w[z], ee = q.x, ue = ee + q.width, Ze = q.y, _e = Ze + q.height, st = z - 1; st >= 0; st--)
          if (z !== st) {
            var Zt = w[st], Xt = Zt.x, nn = Xt + Zt.width, Cn = Zt.y, yi = Cn + Zt.height;
            if (ee >= Xt && Ze >= Cn && ue <= nn && _e <= yi) {
              w.splice(z, 1);
              break;
            } else if (ee === Xt && q.width === Zt.width && !(yi < Ze) && !(Cn > _e)) {
              Cn > Ze && (Zt.height += Cn - Ze, Zt.y = Ze), yi < _e && (Zt.height = _e - Cn), w.splice(z, 1);
              break;
            } else if (Ze === Cn && q.height === Zt.height && !(nn < ee) && !(Xt > ue)) {
              Xt > ee && (Zt.width += Xt - ee, Zt.x = ee), nn < ue && (Zt.width = ue - Xt), w.splice(z, 1);
              break;
            }
          }
      return w;
    }
    function fS(g, d) {
      if (!Bi)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var G = HC(g), w = ex(G, d), H = Array.from(w), z = 0; z < H.length; ) {
        var q = H[z++];
        if (!Ds(q)) {
          if (q.tag === ne) {
            var ee = q.stateNode;
            if (Sr(ee))
              return !0;
          }
          for (var ue = q.child; ue !== null; )
            H.push(ue), ue = ue.sibling;
        }
      }
      return !1;
    }
    var sy = [];
    function ix() {
      Bi && sy.forEach(function(g) {
        return g();
      });
    }
    function pS(g, d, G, w) {
      if (!Bi)
        throw new Error("Test selector API is not supported by this renderer.");
      var H = M0(g, d), z = as(H, G, w), q = z.disconnect, ee = z.observe, ue = z.unobserve, Ze = function() {
        var _e = M0(g, d);
        H.forEach(function(st) {
          _e.indexOf(st) < 0 && ue(st);
        }), _e.forEach(function(st) {
          H.indexOf(st) < 0 && ee(st);
        });
      };
      return sy.push(Ze), {
        disconnect: function() {
          var _e = sy.indexOf(Ze);
          _e >= 0 && sy.splice(_e, 1), q();
        }
      };
    }
    var mS = l.ReactCurrentActQueue;
    function AS(g) {
      {
        var d = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), G = typeof jest < "u";
        return sr && G && d !== !1;
      }
    }
    function rx() {
      {
        var g = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !g && mS.current !== null && f("The current testing environment is not configured to support act(...)"), g;
      }
    }
    var qV = Math.ceil, vS = l.ReactCurrentDispatcher, yS = l.ReactCurrentOwner, No = l.ReactCurrentBatchConfig, Qc = l.ReactCurrentActQueue, Xs = (
      /*             */
      0
    ), H0 = (
      /*               */
      1
    ), hs = (
      /*                */
      2
    ), zd = (
      /*                */
      4
    ), Co = 0, rm = 1, am = 2, X0 = 3, ly = 4, Kd = 5, bS = 6, Pi = Xs, Ys = null, Ta = null, ko = Qt, jc = Qt, om = Tr(Qt), Do = Co, FI = null, sm = Qt, VA = Qt, NA = Qt, lm = null, _u = null, uy = 0, Y0 = 500, GS = 1 / 0, $V = 500;
    function XC() {
      GS = Zo() + $V;
    }
    function cy() {
      return GS;
    }
    var um = !1, F0 = null, cm = null, Ld = !1, YC = null, gy = Qt, BS = [], SS = 50, gm = 0, MA = null, HA = 50, XA = 0, Kf = yr, dm = Qt;
    function dy() {
      return Ys;
    }
    function zu() {
      return (Pi & (hs | zd)) !== Xs ? Zo() : (Kf !== yr || (Kf = Zo()), Kf);
    }
    function Eh(g) {
      var d = g.mode;
      if ((d & _r) === wi)
        return ji;
      if ((Pi & hs) !== Xs && ko !== Qt)
        return Yc(ko);
      var G = Rl() !== Ng;
      if (G) {
        if (No.transition !== null) {
          var w = No.transition;
          w._updatedFibers || (w._updatedFibers = /* @__PURE__ */ new Set()), w._updatedFibers.add(g);
        }
        return dm === no && (dm = Xc()), dm;
      }
      var H = wl();
      if (H !== no)
        return H;
      var z = xi();
      return z;
    }
    function ZS(g) {
      var d = g.mode;
      return (d & _r) === wi ? ji : eu();
    }
    function fs(g, d, G) {
      Uf();
      var w = E0(g, d);
      return w === null ? null : (ec(w, d, G), (Pi & hs) !== Qt && w === Ys ? HS(g) : (tr && tc(w, g, d), mm(g), w === Ys && ((Pi & hs) === Xs && (VA = Wi(VA, d)), Do === ly && kf(w, ko)), Or(w, G), d === ji && Pi === Xs && (g.mode & _r) === wi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Qc.isBatchingLegacy && (XC(), Vg())), w);
    }
    function eN(g, d, G) {
      var w = g.current;
      w.lanes = d, ec(g, d, G), Or(g, G);
    }
    function E0(g, d) {
      g.lanes = Wi(g.lanes, d);
      var G = g.alternate;
      G !== null && (G.lanes = Wi(G.lanes, d)), G === null && (g.flags & (je | Ve)) !== de && Fs(g);
      for (var w = g, H = g.return; H !== null; )
        H.childLanes = Wi(H.childLanes, d), G = H.alternate, G !== null ? G.childLanes = Wi(G.childLanes, d) : (H.flags & (je | Ve)) !== de && Fs(g), w = H, H = H.return;
      if (w.tag === J) {
        var z = w.stateNode;
        return z;
      } else
        return null;
    }
    function Im(g, d) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        Ys !== null && (g.mode & _r) !== wi && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (Pi & hs) === Xs
      );
    }
    function Or(g, d) {
      var G = g.callbackNode;
      ta(g, d);
      var w = pi(g, g === Ys ? ko : Qt);
      if (w === Qt) {
        G !== null && L0(G), g.callbackNode = null, g.callbackPriority = no;
        return;
      }
      var H = Fo(w), z = g.callbackPriority;
      if (z === H && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Qc.current !== null && G !== Un)) {
        G == null && z !== ji && f("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      G != null && L0(G);
      var q;
      if (H === ji)
        g.tag === ws ? (Qc.isBatchingLegacy !== null && (Qc.didScheduleLegacyUpdate = !0), Ai(fc.bind(null, g))) : Fa(fc.bind(null, g)), Po ? Qc.current !== null ? Qc.current.push(br) : Gs(function() {
          Pi === Xs && br();
        }) : Of(el, br), q = null;
      else {
        var ee;
        switch (wg(w)) {
          case Za:
            ee = el;
            break;
          case zr:
            ee = ao;
            break;
          case Ws:
            ee = yn;
            break;
          case sC:
            ee = ss;
            break;
          default:
            ee = yn;
            break;
        }
        q = Of(ee, Lf.bind(null, g));
      }
      g.callbackPriority = H, g.callbackNode = q;
    }
    function Lf(g, d) {
      if (Oc(), Kf = yr, dm = Qt, (Pi & (hs | zd)) !== Xs)
        throw new Error("Should not already be working.");
      var G = g.callbackNode, w = kd();
      if (w && g.callbackNode !== G)
        return null;
      var H = pi(g, g === Ys ? ko : Qt);
      if (H === Qt)
        return null;
      var z = !Sl(g, H) && !gh(g, H) && !d, q = z ? Cy(g, H) : hm(g, H);
      if (q !== Co) {
        if (q === am) {
          var ee = Sa(g);
          ee !== Qt && (H = ee, q = Iy(g, ee));
        }
        if (q === rm) {
          var ue = FI;
          throw Th(g, Qt), kf(g, H), Or(g, Zo()), ue;
        }
        if (q === bS)
          kf(g, H);
        else {
          var Ze = !Sl(g, H), _e = g.current.alternate;
          if (Ze && !tN(_e)) {
            if (q = hm(g, H), q === am) {
              var st = Sa(g);
              st !== Qt && (H = st, q = Iy(g, st));
            }
            if (q === rm) {
              var Zt = FI;
              throw Th(g, Qt), kf(g, H), Or(g, Zo()), Zt;
            }
          }
          g.finishedWork = _e, g.finishedLanes = H, ox(g, q, H);
        }
      }
      return Or(g, Zo()), g.callbackNode === G ? Lf.bind(null, g) : null;
    }
    function Iy(g, d) {
      var G = lm;
      if (xo(g)) {
        var w = Th(g, d);
        w.flags |= Ii, Wc(g.containerInfo);
      }
      var H = hm(g, d);
      if (H !== am) {
        var z = _u;
        _u = G, z !== null && ax(z);
      }
      return H;
    }
    function ax(g) {
      _u === null ? _u = g : _u.push.apply(_u, g);
    }
    function ox(g, d, G) {
      switch (d) {
        case Co:
        case rm:
          throw new Error("Root did not complete. This is a bug in React.");
        // Flow knows about invariant, so it complains if I add a break
        // statement, but eslint doesn't know about invariant, so it complains
        // if I do. eslint-disable-next-line no-fallthrough
        case am: {
          EC(g, _u);
          break;
        }
        case X0: {
          if (kf(g, G), $s(G) && // do not delay if we're inside an act() scope
          !pm()) {
            var w = uy + Y0 - Zo();
            if (w > 10) {
              var H = pi(g, Qt);
              if (H !== Qt)
                break;
              var z = g.suspendedLanes;
              if (!Ua(z, G)) {
                zu(), Zl(g, z);
                break;
              }
              g.timeoutHandle = Ou(EC.bind(null, g, _u), w);
              break;
            }
          }
          EC(g, _u);
          break;
        }
        case ly: {
          if (kf(g, G), Da(G))
            break;
          if (!pm()) {
            var q = ea(g, G), ee = q, ue = Zo() - ee, Ze = oN(ue) - ue;
            if (Ze > 10) {
              g.timeoutHandle = Ou(EC.bind(null, g, _u), Ze);
              break;
            }
          }
          EC(g, _u);
          break;
        }
        case Kd: {
          EC(g, _u);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function tN(g) {
      for (var d = g; ; ) {
        if (d.flags & Et) {
          var G = d.updateQueue;
          if (G !== null) {
            var w = G.stores;
            if (w !== null)
              for (var H = 0; H < w.length; H++) {
                var z = w[H], q = z.getSnapshot, ee = z.value;
                try {
                  if (!ca(q(), ee))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var ue = d.child;
        if (d.subtreeFlags & Et && ue !== null) {
          ue.return = d, d = ue;
          continue;
        }
        if (d === g)
          return !0;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === g)
            return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !0;
    }
    function kf(g, d) {
      d = Eo(d, NA), d = Eo(d, VA), fn(g, d);
    }
    function fc(g) {
      if (kv(), (Pi & (hs | zd)) !== Xs)
        throw new Error("Should not already be working.");
      kd();
      var d = pi(g, Qt);
      if (!xs(d, ji))
        return Or(g, Zo()), null;
      var G = hm(g, d);
      if (g.tag !== ws && G === am) {
        var w = Sa(g);
        w !== Qt && (d = w, G = Iy(g, w));
      }
      if (G === rm) {
        var H = FI;
        throw Th(g, Qt), kf(g, d), Or(g, Zo()), H;
      }
      if (G === bS)
        throw new Error("Root did not complete. This is a bug in React.");
      var z = g.current.alternate;
      return g.finishedWork = z, g.finishedLanes = d, EC(g, _u), Or(g, Zo()), null;
    }
    function nN(g, d) {
      d !== Qt && (dh(g, Wi(d, ji)), Or(g, Zo()), (Pi & (hs | zd)) === Xs && (XC(), br()));
    }
    function T0(g) {
      var d = wl(), G = No.transition;
      try {
        return No.transition = null, ro(Ws), g();
      } finally {
        ro(d), No.transition = G;
      }
    }
    function sx(g, d) {
      var G = Pi;
      Pi |= H0;
      try {
        return g(d);
      } finally {
        Pi = G, Pi === Xs && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Qc.isBatchingLegacy && (XC(), Vg());
      }
    }
    function lx(g, d, G, w, H) {
      var z = wl(), q = No.transition;
      try {
        return No.transition = null, ro(Za), g(d, G, w, H);
      } finally {
        ro(z), No.transition = q, Pi === Xs && XC();
      }
    }
    function Cm(g) {
      YC !== null && YC.tag === ws && (Pi & (hs | zd)) === Xs && kd();
      var d = Pi;
      Pi |= H0;
      var G = No.transition, w = wl();
      try {
        return No.transition = null, ro(Za), g ? g() : void 0;
      } finally {
        ro(w), No.transition = G, Pi = d, (Pi & (hs | zd)) === Xs && br();
      }
    }
    function wS() {
      return (Pi & (hs | zd)) !== Xs;
    }
    function _0(g) {
      var d = Pi;
      Pi |= H0;
      var G = No.transition, w = wl();
      try {
        No.transition = null, ro(Za), g();
      } finally {
        ro(w), No.transition = G, Pi = d, Pi === Xs && (XC(), br());
      }
    }
    function YA(g, d) {
      Dr(om, jc, g), jc = Wi(jc, d);
    }
    function FA(g) {
      jc = om.current, yo(om, g);
    }
    function Th(g, d) {
      g.finishedWork = null, g.finishedLanes = Qt;
      var G = g.timeoutHandle;
      if (G !== dI && (g.timeoutHandle = dI, od(G)), Ta !== null)
        for (var w = Ta.return; w !== null; ) {
          var H = w.alternate;
          _R(H, w), w = w.return;
        }
      Ys = g;
      var z = Tl(g.current, null);
      return Ta = z, ko = jc = d, Do = Co, FI = null, sm = Qt, VA = Qt, NA = Qt, lm = null, _u = null, $n(), cs.discardPendingWarnings(), z;
    }
    function RS(g, d) {
      do {
        var G = Ta;
        try {
          if (RI(), Le(), ra(), yS.current = null, G === null || G.return === null) {
            Do = rm, FI = d, Ta = null;
            return;
          }
          if (T && G.mode & vr && RC(G, !0), F)
            if (ua(), d !== null && typeof d == "object" && typeof d.then == "function") {
              var w = d;
              cC(G, w, ko);
            } else
              Bd(G, d, ko);
          yV(g, G.return, G, d, ko), hy(G);
        } catch (H) {
          d = H, Ta === G && G !== null ? (G = G.return, Ta = G) : G = Ta;
          continue;
        }
        return;
      } while (!0);
    }
    function FC() {
      var g = vS.current;
      return vS.current = Kv, g === null ? Kv : g;
    }
    function _h(g) {
      vS.current = g;
    }
    function z0() {
      uy = Zo();
    }
    function EA(g) {
      sm = Wi(g, sm);
    }
    function iN() {
      Do === Co && (Do = X0);
    }
    function TA() {
      (Do === Co || Do === X0 || Do === am) && (Do = ly), Ys !== null && (Rs(sm) || Rs(VA)) && kf(Ys, ko);
    }
    function rN(g) {
      Do !== ly && (Do = am), lm === null ? lm = [g] : lm.push(g);
    }
    function ux() {
      return Do === Co;
    }
    function hm(g, d) {
      var G = Pi;
      Pi |= hs;
      var w = FC();
      if (Ys !== g || ko !== d) {
        if (tr) {
          var H = g.memoizedUpdaters;
          H.size > 0 && (py(g, ko), H.clear()), To(g, d);
        }
        Th(g, d);
      }
      si(d);
      do
        try {
          cx();
          break;
        } catch (z) {
          RS(g, z);
        }
      while (!0);
      if (RI(), Pi = G, _h(w), Ta !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ir(), Ys = null, ko = Qt, Do;
    }
    function cx() {
      for (; Ta !== null; )
        _A(Ta);
    }
    function Cy(g, d) {
      var G = Pi;
      Pi |= hs;
      var w = FC();
      if (Ys !== g || ko !== d) {
        if (tr) {
          var H = g.memoizedUpdaters;
          H.size > 0 && (py(g, ko), H.clear()), To(g, d);
        }
        XC(), Th(g, d);
      }
      si(d);
      do
        try {
          Df();
          break;
        } catch (z) {
          RS(g, z);
        }
      while (!0);
      return RI(), _h(w), Pi = G, Ta !== null ? (Oi(), Co) : (ir(), Ys = null, ko = Qt, Do);
    }
    function Df() {
      for (; Ta !== null && !BI(); )
        _A(Ta);
    }
    function _A(g) {
      var d = g.alternate;
      so(g);
      var G;
      (g.mode & vr) !== wi ? (t0(g), G = Dd(d, g, jc), RC(g, !0)) : G = Dd(d, g, jc), ra(), g.memoizedProps = g.pendingProps, G === null ? hy(g) : Ta = G, yS.current = null;
    }
    function hy(g) {
      var d = g;
      do {
        var G = d.alternate, w = d.return;
        if ((d.flags & Vn) === de) {
          so(d);
          var H = void 0;
          if ((d.mode & vr) === wi ? H = s0(G, d, jc) : (t0(d), H = s0(G, d, jc), RC(d, !1)), ra(), H !== null) {
            Ta = H;
            return;
          }
        } else {
          var z = zV(G, d);
          if (z !== null) {
            z.flags &= gn, Ta = z;
            return;
          }
          if ((d.mode & vr) !== wi) {
            RC(d, !1);
            for (var q = d.actualDuration, ee = d.child; ee !== null; )
              q += ee.actualDuration, ee = ee.sibling;
            d.actualDuration = q;
          }
          if (w !== null)
            w.flags |= Vn, w.subtreeFlags = de, w.deletions = null;
          else {
            Do = bS, Ta = null;
            return;
          }
        }
        var ue = d.sibling;
        if (ue !== null) {
          Ta = ue;
          return;
        }
        d = w, Ta = d;
      } while (d !== null);
      Do === Co && (Do = Kd);
    }
    function EC(g, d) {
      var G = wl(), w = No.transition;
      try {
        No.transition = null, ro(Za), gx(g, d, G);
      } finally {
        No.transition = w, ro(G);
      }
      return null;
    }
    function gx(g, d, G) {
      do
        kd();
      while (YC !== null);
      if (LA(), (Pi & (hs | zd)) !== Xs)
        throw new Error("Should not already be working.");
      var w = g.finishedWork, H = g.finishedLanes;
      if (Wa(H), w === null)
        return us(), null;
      if (H === Qt && f("root.finishedLanes should not be empty during a commit. This is a bug in React."), g.finishedWork = null, g.finishedLanes = Qt, w === g.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      g.callbackNode = null, g.callbackPriority = no;
      var z = Wi(w.lanes, w.childLanes);
      Fc(g, z), g === Ys && (Ys = null, Ta = null, ko = Qt), ((w.subtreeFlags & Tt) !== de || (w.flags & Tt) !== de) && (Ld || (Ld = !0, Of(yn, function() {
        return kd(), null;
      })));
      var q = (w.subtreeFlags & (Te | De | Ee | Tt)) !== de, ee = (w.flags & (Te | De | Ee | Tt)) !== de;
      if (q || ee) {
        var ue = No.transition;
        No.transition = null;
        var Ze = wl();
        ro(Za);
        var _e = Pi;
        Pi |= zd, yS.current = null, v0(g, w), Mh(), JR(g, w, H), ba(g.containerInfo), g.current = w, pa(H), OV(w, g, H), rc(), Zp(), Pi = _e, ro(Ze), No.transition = ue;
      } else
        g.current = w, Mh();
      var st = Ld;
      if (Ld && (Ld = !1, YC = g, gy = H), z = g.pendingLanes, z === Qt && (cm = null), st || Ix(g.current, !1), Ch(w.stateNode, G), tr && g.memoizedUpdaters.clear(), ix(), Or(g, Zo()), d !== null)
        for (var Zt = g.onRecoverableError, Xt = 0; Xt < d.length; Xt++) {
          var nn = d[Xt];
          Zt(nn);
        }
      if (um) {
        um = !1;
        var Cn = F0;
        throw F0 = null, Cn;
      }
      return xs(gy, ji) && g.tag !== ws && kd(), z = g.pendingLanes, xs(z, ji) ? (mV(), g === MA ? gm++ : (gm = 0, MA = g)) : gm = 0, br(), us(), null;
    }
    function kd() {
      if (YC !== null) {
        var g = wg(gy), d = Sp(Ws, g), G = No.transition, w = wl();
        try {
          return No.transition = null, ro(d), xS();
        } finally {
          ro(w), No.transition = G;
        }
      }
      return !1;
    }
    function zA(g) {
      BS.push(g), Ld || (Ld = !0, Of(yn, function() {
        return kd(), null;
      }));
    }
    function xS() {
      if (YC === null)
        return !1;
      var g = YC, d = gy;
      if (YC = null, gy = Qt, (Pi & (hs | zd)) !== Xs)
        throw new Error("Cannot flush passive effects while already rendering.");
      gC(d);
      var G = Pi;
      Pi |= zd, RA(g.current), PV(g, g.current);
      {
        var w = BS;
        BS = [];
        for (var H = 0; H < w.length; H++) {
          var z = w[H];
          y0(g, z);
        }
      }
      Mu(), Ix(g.current, !0), Pi = G, br(), XA = YC === null ? 0 : XA + 1, Nu(g);
      {
        var q = g.current.stateNode;
        q.effectDuration = 0, q.passiveEffectDuration = 0;
      }
      return !0;
    }
    function WS(g) {
      return cm !== null && cm.has(g);
    }
    function VS(g) {
      cm === null ? cm = /* @__PURE__ */ new Set([g]) : cm.add(g);
    }
    function aN(g) {
      um || (um = !0, F0 = g);
    }
    var dx = aN;
    function NS(g, d, G) {
      var w = Up(G, d), H = vR(g, w, ji);
      ei(g, H);
      var z = zu(), q = E0(g, ji);
      q !== null && (ec(q, ji, z), Or(q, z));
    }
    function ps(g, d, G) {
      if (g.tag === J) {
        NS(g, g, G);
        return;
      }
      var w = null;
      for (w = d; w !== null; ) {
        if (w.tag === J) {
          NS(w, g, G);
          return;
        } else if (w.tag === L) {
          var H = w.type, z = w.stateNode;
          if (typeof H.getDerivedStateFromError == "function" || typeof z.componentDidCatch == "function" && !WS(z)) {
            var q = Up(G, g), ee = mA(w, q, ji);
            ei(w, ee);
            var ue = zu(), Ze = E0(w, ji);
            Ze !== null && (ec(Ze, ji, ue), Or(Ze, ue));
            return;
          }
        }
        w = w.return;
      }
      f(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, G);
    }
    function EI(g, d, G) {
      var w = g.pingCache;
      w !== null && w.delete(d);
      var H = zu();
      Zl(g, G), Aa(g), Ys === g && Ua(ko, G) && (Do === ly || Do === X0 && $s(ko) && Zo() - uy < Y0 ? Th(g, Qt) : NA = Wi(NA, G)), Or(g, H);
    }
    function K0(g, d) {
      d === no && (d = ZS(g));
      var G = zu(), w = E0(g, d);
      w !== null && (ec(w, d, G), Or(w, G));
    }
    function KA(g) {
      var d = g.memoizedState, G = no;
      d !== null && (G = d.retryLane), K0(g, G);
    }
    function MS(g, d) {
      var G = no, w;
      switch (g.tag) {
        case Se:
          w = g.stateNode;
          var H = g.memoizedState;
          H !== null && (G = H.retryLane);
          break;
        case Je:
          w = g.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      w !== null && w.delete(d), K0(g, G);
    }
    function oN(g) {
      return g < 120 ? 120 : g < 480 ? 480 : g < 1080 ? 1080 : g < 1920 ? 1920 : g < 3e3 ? 3e3 : g < 4320 ? 4320 : qV(g / 1960) * 1960;
    }
    function Uf() {
      if (gm > SS)
        throw gm = 0, MA = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      XA > HA && (XA = 0, f("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function LA() {
      cs.flushLegacyContextWarning(), cs.flushPendingUnsafeLifecycleWarnings();
    }
    function Ix(g, d) {
      so(g), fm(g, ae, em), d && fm(g, Ne, $R), fm(g, ae, JV), d && fm(g, Ne, QV), ra();
    }
    function fm(g, d, G) {
      for (var w = g, H = null; w !== null; ) {
        var z = w.subtreeFlags & d;
        w !== H && w.child !== null && z !== de ? w = w.child : ((w.flags & d) !== de && G(w), w.sibling !== null ? w = w.sibling : w = H = w.return);
      }
    }
    var su = null;
    function Fs(g) {
      {
        if ((Pi & hs) !== Xs || !(g.mode & _r))
          return;
        var d = g.tag;
        if (d !== j && d !== J && d !== L && d !== D && d !== Xe && d !== Be && d !== le)
          return;
        var G = qe(g) || "ReactComponent";
        if (su !== null) {
          if (su.has(G))
            return;
          su.add(G);
        } else
          su = /* @__PURE__ */ new Set([G]);
        var w = nl;
        try {
          so(g), f("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          w ? so(g) : ra();
        }
      }
    }
    var Dd;
    {
      var gl = null;
      Dd = function(g, d, G) {
        var w = ES(gl, d);
        try {
          return TR(g, d, G);
        } catch (z) {
          if (z !== null && typeof z == "object" && typeof z.then == "function")
            throw z;
          if (RI(), Le(), _R(g, d), ES(d, w), d.mode & vr && t0(d), KR(null, TR, null, g, d, G), kV()) {
            var H = LR();
            typeof H == "object" && H !== null && H._suppressLogging && typeof z == "object" && z !== null && !z._suppressLogging && (z._suppressLogging = !0);
          }
          throw z;
        }
      };
    }
    var Yl = !1, fy;
    fy = /* @__PURE__ */ new Set();
    function HS(g) {
      if (Zd && !gR())
        switch (g.tag) {
          case D:
          case Xe:
          case le: {
            var d = Ta && qe(Ta) || "Unknown", G = d;
            if (!fy.has(G)) {
              fy.add(G);
              var w = qe(g) || "Unknown";
              f("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", w, d, d);
            }
            break;
          }
          case L: {
            Yl || (f("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), Yl = !0);
            break;
          }
        }
    }
    function py(g, d) {
      if (tr) {
        var G = g.memoizedUpdaters;
        G.forEach(function(w) {
          tc(g, w, d);
        });
      }
    }
    var Un = {};
    function Of(g, d) {
      {
        var G = Qc.current;
        return G !== null ? (G.push(d), Un) : Gd(g, d);
      }
    }
    function L0(g) {
      if (g !== Un)
        return Ih(g);
    }
    function pm() {
      return Qc.current !== null;
    }
    function mm(g) {
      {
        if (g.mode & _r) {
          if (!rx())
            return;
        } else if (!AS() || Pi !== Xs || g.tag !== D && g.tag !== Xe && g.tag !== le)
          return;
        if (Qc.current === null) {
          var d = nl;
          try {
            so(g), f(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, qe(g));
          } finally {
            d ? so(g) : ra();
          }
        }
      }
    }
    function Aa(g) {
      g.tag !== ws && rx() && Qc.current === null && f(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var va = null, Mo = null, k0 = function(g) {
      va = g;
    };
    function TC(g) {
      {
        if (va === null)
          return g;
        var d = va(g);
        return d === void 0 ? g : d.current;
      }
    }
    function Am(g) {
      return TC(g);
    }
    function XS(g) {
      {
        if (va === null)
          return g;
        var d = va(g);
        if (d === void 0) {
          if (g != null && typeof g.render == "function") {
            var G = TC(g.render);
            if (g.render !== G) {
              var w = {
                $$typeof: en,
                render: G
              };
              return g.displayName !== void 0 && (w.displayName = g.displayName), w;
            }
          }
          return g;
        }
        return d.current;
      }
    }
    function Cx(g, d) {
      {
        if (va === null)
          return !1;
        var G = g.elementType, w = d.type, H = !1, z = typeof w == "object" && w !== null ? w.$$typeof : null;
        switch (g.tag) {
          case L: {
            typeof w == "function" && (H = !0);
            break;
          }
          case D: {
            (typeof w == "function" || z === $e) && (H = !0);
            break;
          }
          case Xe: {
            (z === en || z === $e) && (H = !0);
            break;
          }
          case Be:
          case le: {
            (z === se || z === $e) && (H = !0);
            break;
          }
          default:
            return !1;
        }
        if (H) {
          var q = va(G);
          if (q !== void 0 && q === va(w))
            return !0;
        }
        return !1;
      }
    }
    function Kt(g) {
      {
        if (va === null || typeof WeakSet != "function")
          return;
        Mo === null && (Mo = /* @__PURE__ */ new WeakSet()), Mo.add(g);
      }
    }
    var Ud = function(g, d) {
      {
        if (va === null)
          return;
        var G = d.staleFamilies, w = d.updatedFamilies;
        kd(), Cm(function() {
          my(g.current, w, G);
        });
      }
    }, Pf = function(g, d) {
      {
        if (g.context !== os)
          return;
        kd(), Cm(function() {
          Sy(d, g, null, null);
        });
      }
    };
    function my(g, d, G) {
      {
        var w = g.alternate, H = g.child, z = g.sibling, q = g.tag, ee = g.type, ue = null;
        switch (q) {
          case D:
          case le:
          case L:
            ue = ee;
            break;
          case Xe:
            ue = ee.render;
            break;
        }
        if (va === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Ze = !1, _e = !1;
        if (ue !== null) {
          var st = va(ue);
          st !== void 0 && (G.has(st) ? _e = !0 : d.has(st) && (q === L ? _e = !0 : Ze = !0));
        }
        Mo !== null && (Mo.has(g) || w !== null && Mo.has(w)) && (_e = !0), _e && (g._debugNeedsRemount = !0), (_e || Ze) && fs(g, ji, yr), H !== null && !_e && my(H, d, G), z !== null && my(z, d, G);
      }
    }
    var aa = function(g, d) {
      {
        var G = /* @__PURE__ */ new Set(), w = new Set(d.map(function(H) {
          return H.current;
        }));
        return Rn(g.current, w, G), G;
      }
    };
    function Rn(g, d, G) {
      {
        var w = g.child, H = g.sibling, z = g.tag, q = g.type, ee = null;
        switch (z) {
          case D:
          case le:
          case L:
            ee = q;
            break;
          case Xe:
            ee = q.render;
            break;
        }
        var ue = !1;
        ee !== null && d.has(ee) && (ue = !0), ue ? kA(g, G) : w !== null && Rn(w, d, G), H !== null && Rn(H, d, G);
      }
    }
    function kA(g, d) {
      {
        var G = sN(g, d);
        if (G)
          return;
        for (var w = g; ; ) {
          switch (w.tag) {
            case ne:
              d.add(w.stateNode);
              return;
            case O:
              d.add(w.stateNode.containerInfo);
              return;
            case J:
              d.add(w.stateNode.containerInfo);
              return;
          }
          if (w.return === null)
            throw new Error("Expected to reach root first.");
          w = w.return;
        }
      }
    }
    function sN(g, d) {
      for (var G = g, w = !1; ; ) {
        if (G.tag === ne)
          w = !0, d.add(G.stateNode);
        else if (G.child !== null) {
          G.child.return = G, G = G.child;
          continue;
        }
        if (G === g)
          return w;
        for (; G.sibling === null; ) {
          if (G.return === null || G.return === g)
            return w;
          G = G.return;
        }
        G.sibling.return = G.return, G = G.sibling;
      }
      return !1;
    }
    var Fl;
    {
      Fl = !1;
      try {
        var D0 = Object.preventExtensions({});
      } catch {
        Fl = !0;
      }
    }
    function DA(g, d, G, w) {
      this.tag = g, this.key = G, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = d, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = w, this.flags = de, this.subtreeFlags = de, this.deletions = null, this.lanes = Qt, this.childLanes = Qt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Fl && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var El = function(g, d, G, w) {
      return new DA(g, d, G, w);
    };
    function U0(g) {
      var d = g.prototype;
      return !!(d && d.isReactComponent);
    }
    function hx(g) {
      return typeof g == "function" && !U0(g) && g.defaultProps === void 0;
    }
    function _C(g) {
      if (typeof g == "function")
        return U0(g) ? L : D;
      if (g != null) {
        var d = g.$$typeof;
        if (d === en)
          return Xe;
        if (d === se)
          return Be;
      }
      return j;
    }
    function Tl(g, d) {
      var G = g.alternate;
      G === null ? (G = El(g.tag, d, g.key, g.mode), G.elementType = g.elementType, G.type = g.type, G.stateNode = g.stateNode, G._debugSource = g._debugSource, G._debugOwner = g._debugOwner, G._debugHookTypes = g._debugHookTypes, G.alternate = g, g.alternate = G) : (G.pendingProps = d, G.type = g.type, G.flags = de, G.subtreeFlags = de, G.deletions = null, G.actualDuration = 0, G.actualStartTime = -1), G.flags = g.flags & tn, G.childLanes = g.childLanes, G.lanes = g.lanes, G.child = g.child, G.memoizedProps = g.memoizedProps, G.memoizedState = g.memoizedState, G.updateQueue = g.updateQueue;
      var w = g.dependencies;
      switch (G.dependencies = w === null ? null : {
        lanes: w.lanes,
        firstContext: w.firstContext
      }, G.sibling = g.sibling, G.index = g.index, G.ref = g.ref, G.selfBaseDuration = g.selfBaseDuration, G.treeBaseDuration = g.treeBaseDuration, G._debugNeedsRemount = g._debugNeedsRemount, G.tag) {
        case j:
        case D:
        case le:
          G.type = TC(g.type);
          break;
        case L:
          G.type = Am(g.type);
          break;
        case Xe:
          G.type = XS(g.type);
          break;
      }
      return G;
    }
    function fx(g, d) {
      g.flags &= tn | je;
      var G = g.alternate;
      if (G === null)
        g.childLanes = Qt, g.lanes = d, g.child = null, g.subtreeFlags = de, g.memoizedProps = null, g.memoizedState = null, g.updateQueue = null, g.dependencies = null, g.stateNode = null, g.selfBaseDuration = 0, g.treeBaseDuration = 0;
      else {
        g.childLanes = G.childLanes, g.lanes = G.lanes, g.child = G.child, g.subtreeFlags = de, g.deletions = null, g.memoizedProps = G.memoizedProps, g.memoizedState = G.memoizedState, g.updateQueue = G.updateQueue, g.type = G.type;
        var w = G.dependencies;
        g.dependencies = w === null ? null : {
          lanes: w.lanes,
          firstContext: w.firstContext
        }, g.selfBaseDuration = G.selfBaseDuration, g.treeBaseDuration = G.treeBaseDuration;
      }
      return g;
    }
    function YS(g, d, G) {
      var w;
      return g === nC ? (w = _r, d === !0 && (w |= La, w |= ql)) : w = wi, tr && (w |= vr), El(J, null, null, w);
    }
    function Ay(g, d, G, w, H, z) {
      var q = j, ee = g;
      if (typeof g == "function")
        U0(g) ? (q = L, ee = Am(ee)) : ee = TC(ee);
      else if (typeof g == "string")
        q = ne;
      else
        e: switch (g) {
          case Wt:
            return zC(G.children, H, z, d);
          case Nt:
            q = Ae, H |= La, (H & _r) !== wi && (H |= ql);
            break;
          case $t:
            return cF(G, H, z, d);
          case hn:
            return gF(G, H, z, d);
          case me:
            return FS(G, H, z, d);
          case Mt:
            return yy(G, H, z, d);
          case Gn:
          // eslint-disable-next-line no-fallthrough
          case Vt:
          // eslint-disable-next-line no-fallthrough
          case jt:
          // eslint-disable-next-line no-fallthrough
          case an:
          // eslint-disable-next-line no-fallthrough
          case Bt:
          // eslint-disable-next-line no-fallthrough
          default: {
            if (typeof g == "object" && g !== null)
              switch (g.$$typeof) {
                case ft:
                  q = Re;
                  break e;
                case bn:
                  q = ke;
                  break e;
                case en:
                  q = Xe, ee = XS(ee);
                  break e;
                case se:
                  q = Be;
                  break e;
                case $e:
                  q = Ye, ee = null;
                  break e;
              }
            var ue = "";
            {
              (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ue += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var Ze = w ? qe(w) : null;
              Ze && (ue += `

Check the render method of \`` + Ze + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (g == null ? g : typeof g) + "." + ue));
          }
        }
      var _e = El(q, G, d, H);
      return _e.elementType = g, _e.type = ee, _e.lanes = z, _e._debugOwner = w, _e;
    }
    function vy(g, d, G) {
      var w = null;
      w = g._owner;
      var H = g.type, z = g.key, q = g.props, ee = Ay(H, z, q, w, d, G);
      return ee._debugSource = g._source, ee._debugOwner = g._owner, ee;
    }
    function zC(g, d, G, w) {
      var H = El(pe, g, w, d);
      return H.lanes = G, H;
    }
    function cF(g, d, G, w) {
      typeof g.id != "string" && f('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof g.id);
      var H = El(re, g, w, d | vr);
      return H.elementType = $t, H.lanes = G, H.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, H;
    }
    function gF(g, d, G, w) {
      var H = El(Se, g, w, d);
      return H.elementType = hn, H.lanes = G, H;
    }
    function FS(g, d, G, w) {
      var H = El(Je, g, w, d);
      return H.elementType = me, H.lanes = G, H;
    }
    function yy(g, d, G, w) {
      var H = El(mt, g, w, d);
      H.elementType = Mt, H.lanes = G;
      var z = {};
      return H.stateNode = z, H;
    }
    function O0(g, d, G) {
      var w = El(he, g, null, d);
      return w.lanes = G, w;
    }
    function px() {
      var g = El(ne, null, null, wi);
      return g.elementType = "DELETED", g;
    }
    function mx(g) {
      var d = El(ze, null, null, wi);
      return d.stateNode = g, d;
    }
    function P0(g, d, G) {
      var w = g.children !== null ? g.children : [], H = El(O, w, g.key, d);
      return H.lanes = G, H.stateNode = {
        containerInfo: g.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: g.implementation
      }, H;
    }
    function ES(g, d) {
      return g === null && (g = El(j, null, null, wi)), g.tag = d.tag, g.key = d.key, g.elementType = d.elementType, g.type = d.type, g.stateNode = d.stateNode, g.return = d.return, g.child = d.child, g.sibling = d.sibling, g.index = d.index, g.ref = d.ref, g.pendingProps = d.pendingProps, g.memoizedProps = d.memoizedProps, g.updateQueue = d.updateQueue, g.memoizedState = d.memoizedState, g.dependencies = d.dependencies, g.mode = d.mode, g.flags = d.flags, g.subtreeFlags = d.subtreeFlags, g.deletions = d.deletions, g.lanes = d.lanes, g.childLanes = d.childLanes, g.alternate = d.alternate, g.actualDuration = d.actualDuration, g.actualStartTime = d.actualStartTime, g.selfBaseDuration = d.selfBaseDuration, g.treeBaseDuration = d.treeBaseDuration, g._debugSource = d._debugSource, g._debugOwner = d._debugOwner, g._debugNeedsRemount = d._debugNeedsRemount, g._debugHookTypes = d._debugHookTypes, g;
    }
    function J0(g, d, G, w, H) {
      this.tag = d, this.containerInfo = g, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = dI, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = no, this.eventTimes = na(Qt), this.expirationTimes = na(yr), this.pendingLanes = Qt, this.suspendedLanes = Qt, this.pingedLanes = Qt, this.expiredLanes = Qt, this.mutableReadLanes = Qt, this.finishedLanes = Qt, this.entangledLanes = Qt, this.entanglements = na(Qt), this.identifierPrefix = w, this.onRecoverableError = H, Hi && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var z = this.pendingUpdatersLaneMap = [], q = 0; q < hf; q++)
          z.push(/* @__PURE__ */ new Set());
      }
      switch (d) {
        case nC:
          this._debugRootType = G ? "hydrateRoot()" : "createRoot()";
          break;
        case ws:
          this._debugRootType = G ? "hydrate()" : "render()";
          break;
      }
    }
    function Q0(g, d, G, w, H, z, q, ee, ue, Ze) {
      var _e = new J0(g, d, G, ee, ue), st = YS(d, z);
      _e.current = st, st.stateNode = _e;
      {
        var Zt = {
          element: w,
          isDehydrated: G,
          cache: null,
          // not enabled yet
          transitions: null
        };
        st.memoizedState = Zt;
      }
      return Fe(st), _e;
    }
    var TS = "18.0.0-fc46dba67-20220329";
    function by(g, d, G) {
      var w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return sc(w), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: ge,
        key: w == null ? null : "" + w,
        children: g,
        containerInfo: d,
        implementation: G
      };
    }
    var Gy, UA;
    Gy = !1, UA = {};
    function OA(g) {
      if (!g)
        return os;
      var d = S(g), G = Ba(d);
      if (d.tag === L) {
        var w = d.type;
        if (Zs(w))
          return pd(d, w, G);
      }
      return G;
    }
    function j0(g) {
      var d = S(g);
      if (d === void 0) {
        if (typeof g.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var G = Object.keys(g).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + G);
      }
      var w = Ir(d);
      return w === null ? null : w.stateNode;
    }
    function q0(g, d) {
      {
        var G = S(g);
        if (G === void 0) {
          if (typeof g.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var w = Object.keys(g).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + w);
        }
        var H = Ir(G);
        if (H === null)
          return null;
        if (H.mode & La) {
          var z = qe(G) || "Component";
          if (!UA[z]) {
            UA[z] = !0;
            var q = nl;
            try {
              so(H), G.mode & La ? f("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", d, d, z) : f("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", d, d, z);
            } finally {
              q ? so(q) : ra();
            }
          }
        }
        return H.stateNode;
      }
    }
    function By(g, d, G, w, H, z, q, ee) {
      var ue = !1, Ze = null;
      return Q0(g, d, ue, Ze, G, w, H, z, q);
    }
    function _S(g, d, G, w, H, z, q, ee, ue, Ze) {
      var _e = !0, st = Q0(G, w, _e, g, H, z, q, ee, ue);
      st.context = OA(null);
      var Zt = st.current, Xt = zu(), nn = Eh(Zt), Cn = Sn(Xt, nn);
      return Cn.callback = d ?? null, ei(Zt, Cn), eN(st, nn, Xt), st;
    }
    function Sy(g, d, G, w) {
      wp(d, g);
      var H = d.current, z = zu(), q = Eh(H);
      Xi(q);
      var ee = OA(G);
      d.context === null ? d.context = ee : d.pendingContext = ee, Zd && nl !== null && !Gy && (Gy = !0, f(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, qe(nl) || "Unknown"));
      var ue = Sn(z, q);
      ue.payload = {
        element: g
      }, w = w === void 0 ? null : w, w !== null && (typeof w != "function" && f("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", w), ue.callback = w), ei(H, ue);
      var Ze = fs(H, q, z);
      return Ze !== null && Ki(Ze, H, q), q;
    }
    function zS(g) {
      var d = g.current;
      if (!d.child)
        return null;
      switch (d.child.tag) {
        case ne:
          return li(d.child.stateNode);
        default:
          return d.child.stateNode;
      }
    }
    function $0(g) {
      switch (g.tag) {
        case J:
          var d = g.stateNode;
          if (xo(d)) {
            var G = er(d);
            nN(d, G);
          }
          break;
        case Se:
          var w = zu();
          Cm(function() {
            return fs(g, ji, w);
          });
          var H = ji;
          Zy(g, H);
          break;
      }
    }
    function KS(g, d) {
      var G = g.memoizedState;
      G !== null && G.dehydrated !== null && (G.retryLane = So(G.retryLane, d));
    }
    function Zy(g, d) {
      KS(g, d);
      var G = g.alternate;
      G && KS(G, d);
    }
    function eG(g) {
      if (g.tag === Se) {
        var d = zu(), G = Hc;
        fs(g, G, d), Zy(g, G);
      }
    }
    function lN(g) {
      if (g.tag === Se) {
        var d = zu(), G = Eh(g);
        fs(g, G, d), Zy(g, G);
      }
    }
    function tG(g) {
      var d = mi(g);
      return d === null ? null : d.stateNode;
    }
    var nG = function(g) {
      return null;
    };
    function wy(g) {
      return nG(g);
    }
    var iG = function(g) {
      return !1;
    };
    function Ry(g) {
      return iG(g);
    }
    var rG = null, LS = null, kS = null, DS = null, Ax = null, aG = null, US = null, OS = null, PS = null;
    {
      var vx = function(g, d, G) {
        var w = d[G], H = Xn(g) ? g.slice() : b({}, g);
        return G + 1 === d.length ? (Xn(H) ? H.splice(w, 1) : delete H[w], H) : (H[w] = vx(g[w], d, G + 1), H);
      }, oG = function(g, d) {
        return vx(g, d, 0);
      }, xy = function(g, d, G, w) {
        var H = d[w], z = Xn(g) ? g.slice() : b({}, g);
        if (w + 1 === d.length) {
          var q = G[w];
          z[q] = z[H], Xn(z) ? z.splice(H, 1) : delete z[H];
        } else
          z[H] = xy(
            // $FlowFixMe number or string is fine here
            g[H],
            d,
            G,
            w + 1
          );
        return z;
      }, yx = function(g, d, G) {
        if (d.length !== G.length) {
          C("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var w = 0; w < G.length - 1; w++)
            if (d[w] !== G[w]) {
              C("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return xy(g, d, G, 0);
      }, bx = function(g, d, G, w) {
        if (G >= d.length)
          return w;
        var H = d[G], z = Xn(g) ? g.slice() : b({}, g);
        return z[H] = bx(g[H], d, G + 1, w), z;
      }, JS = function(g, d, G) {
        return bx(g, d, 0, G);
      }, sG = function(g, d) {
        for (var G = g.memoizedState; G !== null && d > 0; )
          G = G.next, d--;
        return G;
      };
      rG = function(g, d, G, w) {
        var H = sG(g, d);
        if (H !== null) {
          var z = JS(H.memoizedState, G, w);
          H.memoizedState = z, H.baseState = z, g.memoizedProps = b({}, g.memoizedProps), fs(g, ji, yr);
        }
      }, LS = function(g, d, G) {
        var w = sG(g, d);
        if (w !== null) {
          var H = oG(w.memoizedState, G);
          w.memoizedState = H, w.baseState = H, g.memoizedProps = b({}, g.memoizedProps), fs(g, ji, yr);
        }
      }, kS = function(g, d, G, w) {
        var H = sG(g, d);
        if (H !== null) {
          var z = yx(H.memoizedState, G, w);
          H.memoizedState = z, H.baseState = z, g.memoizedProps = b({}, g.memoizedProps), fs(g, ji, yr);
        }
      }, DS = function(g, d, G) {
        g.pendingProps = JS(g.memoizedProps, d, G), g.alternate && (g.alternate.pendingProps = g.pendingProps), fs(g, ji, yr);
      }, Ax = function(g, d) {
        g.pendingProps = oG(g.memoizedProps, d), g.alternate && (g.alternate.pendingProps = g.pendingProps), fs(g, ji, yr);
      }, aG = function(g, d, G) {
        g.pendingProps = yx(g.memoizedProps, d, G), g.alternate && (g.alternate.pendingProps = g.pendingProps), fs(g, ji, yr);
      }, US = function(g) {
        fs(g, ji, yr);
      }, OS = function(g) {
        nG = g;
      }, PS = function(g) {
        iG = g;
      };
    }
    function Gx(g) {
      var d = Ir(g);
      return d === null ? null : d.stateNode;
    }
    function Bx(g) {
      return null;
    }
    function lG() {
      return nl;
    }
    function Sx(g) {
      var d = g.findFiberByHostInstance, G = l.ReactCurrentDispatcher;
      return Rg({
        bundleType: g.bundleType,
        version: g.version,
        rendererPackageName: g.rendererPackageName,
        rendererConfig: g.rendererConfig,
        overrideHookState: rG,
        overrideHookStateDeletePath: LS,
        overrideHookStateRenamePath: kS,
        overrideProps: DS,
        overridePropsDeletePath: Ax,
        overridePropsRenamePath: aG,
        setErrorHandler: OS,
        setSuspenseHandler: PS,
        scheduleUpdate: US,
        currentDispatcherRef: G,
        findHostInstanceByFiber: Gx,
        findFiberByHostInstance: d || Bx,
        // React Refresh
        findHostInstancesForRefresh: aa,
        scheduleRefresh: Ud,
        scheduleRoot: Pf,
        setRefreshHandler: k0,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: lG,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: TS
      });
    }
    return n.attemptContinuousHydration = eG, n.attemptHydrationAtCurrentPriority = lN, n.attemptSynchronousHydration = $0, n.batchedUpdates = sx, n.createComponentSelector = nm, n.createContainer = By, n.createHasPseudoClassSelector = ou, n.createHydrationContainer = _S, n.createPortal = by, n.createRoleSelector = _d, n.createTestNameSelector = im, n.createTextSelector = YI, n.deferredUpdates = T0, n.discreteUpdates = lx, n.findAllNodes = M0, n.findBoundingRects = nx, n.findHostInstance = j0, n.findHostInstanceWithNoPortals = tG, n.findHostInstanceWithWarning = q0, n.flushControlled = _0, n.flushPassiveEffects = kd, n.flushSync = Cm, n.focusWithin = fS, n.getCurrentUpdatePriority = wl, n.getFindAllNodesFailureDescription = tx, n.getPublicRootInstance = zS, n.injectIntoDevTools = Sx, n.isAlreadyRendering = wS, n.observeVisibleRects = pS, n.registerMutableSourceForHydration = Lb, n.runWithPriority = pf, n.shouldError = wy, n.shouldSuspend = Ry, n.updateContainer = Sy, n;
  }), uH.exports;
}
var Z5;
function Hee() {
  if (Z5) return J1.exports;
  Z5 = 1;
  var r = {};
  return r.NODE_ENV === "production" ? J1.exports = Nee() : J1.exports = Mee(), J1.exports;
}
var Xee = Hee();
const Yee = /* @__PURE__ */ BW(Xee);
var w5 = TY(), kL = {};
const _Y = {}, Fee = (r) => void Object.assign(_Y, r);
function Eee(r, e) {
  function t(f, {
    args: v = [],
    attach: b,
    ...S
  }, R) {
    let W = `${f[0].toUpperCase()}${f.slice(1)}`, x;
    if (f === "primitive") {
      if (S.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const N = S.object;
      x = JG(N, {
        type: f,
        root: R,
        attach: b,
        primitive: !0
      });
    } else {
      const N = _Y[W];
      if (!N)
        throw new Error(`R3F: ${W} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(v)) throw new Error("R3F: The args prop must be an array!");
      x = JG(new N(...v), {
        type: f,
        root: R,
        attach: b,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: v
        }
      });
    }
    return x.__r3f.attach === void 0 && (x.isBufferGeometry ? x.__r3f.attach = "geometry" : x.isMaterial && (x.__r3f.attach = "material")), W !== "inject" && dH(x, S), x;
  }
  function n(f, v) {
    let b = !1;
    if (v) {
      var S, R;
      (S = v.__r3f) != null && S.attach ? gH(f, v, v.__r3f.attach) : v.isObject3D && f.isObject3D && (f.add(v), b = !0), b || (R = f.__r3f) == null || R.objects.push(v), v.__r3f || JG(v, {}), v.__r3f.parent = f, oX(v), QG(v);
    }
  }
  function i(f, v, b) {
    let S = !1;
    if (v) {
      var R, W;
      if ((R = v.__r3f) != null && R.attach)
        gH(f, v, v.__r3f.attach);
      else if (v.isObject3D && f.isObject3D) {
        v.parent = f, v.dispatchEvent({
          type: "added"
        }), f.dispatchEvent({
          type: "childadded",
          child: v
        });
        const x = f.children.filter((Y) => Y !== v), N = x.indexOf(b);
        f.children = [...x.slice(0, N), v, ...x.slice(N)], S = !0;
      }
      S || (W = f.__r3f) == null || W.objects.push(v), v.__r3f || JG(v, {}), v.__r3f.parent = f, oX(v), QG(v);
    }
  }
  function o(f, v, b = !1) {
    f && [...f].forEach((S) => l(v, S, b));
  }
  function l(f, v, b) {
    if (v) {
      var S, R, W;
      if (v.__r3f && (v.__r3f.parent = null), (S = f.__r3f) != null && S.objects && (f.__r3f.objects = f.__r3f.objects.filter((T) => T !== v)), (R = v.__r3f) != null && R.attach)
        N5(f, v, v.__r3f.attach);
      else if (v.isObject3D && f.isObject3D) {
        var x;
        f.remove(v), (x = v.__r3f) != null && x.root && Uee(I2(v), v);
      }
      const Y = (W = v.__r3f) == null ? void 0 : W.primitive, F = !Y && (b === void 0 ? v.dispose !== null : b);
      if (!Y) {
        var N;
        o((N = v.__r3f) == null ? void 0 : N.objects, v, F), o(v.children, v, F);
      }
      if (delete v.__r3f, F && v.dispose && v.type !== "Scene") {
        const T = () => {
          try {
            v.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? w5.unstable_scheduleCallback(w5.unstable_IdlePriority, T) : T();
      }
      QG(f);
    }
  }
  function u(f, v, b, S) {
    var R;
    const W = (R = f.__r3f) == null ? void 0 : R.parent;
    if (!W) return;
    const x = t(v, b, f.__r3f.root);
    if (f.children) {
      for (const N of f.children)
        N.__r3f && n(x, N);
      f.children = f.children.filter((N) => !N.__r3f);
    }
    f.__r3f.objects.forEach((N) => n(x, N)), f.__r3f.objects = [], f.__r3f.autoRemovedBeforeAppend || l(W, f), x.parent && (x.__r3f.autoRemovedBeforeAppend = !0), n(W, x), x.raycast && x.__r3f.eventCount && I2(x).getState().internal.interaction.push(x), [S, S.alternate].forEach((N) => {
      N !== null && (N.stateNode = x, N.ref && (typeof N.ref == "function" ? N.ref(x) : N.ref.current = x));
    });
  }
  const I = () => {
  };
  return {
    reconciler: Yee({
      createInstance: t,
      removeChild: l,
      appendChild: n,
      appendInitialChild: n,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (f, v) => {
        if (!v) return;
        const b = f.getState().scene;
        b.__r3f && (b.__r3f.root = f, n(b, v));
      },
      removeChildFromContainer: (f, v) => {
        v && l(f.getState().scene, v);
      },
      insertInContainerBefore: (f, v, b) => {
        if (!v || !b) return;
        const S = f.getState().scene;
        S.__r3f && i(S, v, b);
      },
      getRootHostContext: () => null,
      getChildHostContext: (f) => f,
      finalizeInitialChildren(f) {
        var v;
        return !!((v = f?.__r3f) != null ? v : {}).handlers;
      },
      prepareUpdate(f, v, b, S) {
        var R;
        if (((R = f?.__r3f) != null ? R : {}).primitive && S.object && S.object !== f)
          return [!0];
        {
          const {
            args: x = [],
            children: N,
            ...Y
          } = S, {
            args: F = [],
            children: T,
            ...P
          } = b;
          if (!Array.isArray(x)) throw new Error("R3F: the args prop must be an array!");
          if (x.some((L, j) => L !== F[j])) return [!0];
          const D = jL(f, Y, P, !0);
          return D.changes.length ? [!1, D] : null;
        }
      },
      commitUpdate(f, [v, b], S, R, W, x) {
        v ? u(f, S, W, x) : dH(f, b);
      },
      commitMount(f, v, b, S) {
        var R;
        const W = (R = f.__r3f) != null ? R : {};
        f.raycast && W.handlers && W.eventCount && I2(f).getState().internal.interaction.push(f);
      },
      getPublicInstance: (f) => f,
      prepareForCommit: () => null,
      preparePortalMount: (f) => JG(f.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(f) {
        var v;
        const {
          attach: b,
          parent: S
        } = (v = f.__r3f) != null ? v : {};
        b && S && N5(S, f, b), f.isObject3D && (f.visible = !1), QG(f);
      },
      unhideInstance(f, v) {
        var b;
        const {
          attach: S,
          parent: R
        } = (b = f.__r3f) != null ? b : {};
        S && R && gH(R, f, S), (f.isObject3D && v.visible == null || v.visible) && (f.visible = !0), QG(f);
      },
      createTextInstance: I,
      hideTextInstance: I,
      unhideTextInstance: I,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-expect-error
      getCurrentEventPriority: () => e ? e() : iB.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && Oo.fun(performance.now) ? performance.now : Oo.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: Oo.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Oo.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: dH
  };
}
var R5, x5;
const cH = (r) => "colorSpace" in r || "outputColorSpace" in r, DL = () => {
  var r;
  return (r = _Y.ColorManagement) != null ? r : null;
}, UL = (r) => r && r.isOrthographicCamera, Tee = (r) => r && r.hasOwnProperty("current"), sR = typeof window < "u" && ((R5 = window.document) != null && R5.createElement || ((x5 = window.navigator) == null ? void 0 : x5.product) === "ReactNative") ? ye.useLayoutEffect : ye.useEffect;
function OL(r) {
  const e = ye.useRef(r);
  return sR(() => void (e.current = r), [r]), e;
}
function _ee({
  set: r
}) {
  return sR(() => (r(new Promise(() => null)), () => r(!1)), [r]), null;
}
class PL extends ye.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
PL.getDerivedStateFromError = () => ({
  error: !0
});
const JL = "__default", W5 = /* @__PURE__ */ new Map(), zee = (r) => r && !!r.memoized && !!r.changes;
function QL(r) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(r) ? Math.min(Math.max(r[0], t), r[1]) : r;
}
const XZ = (r) => {
  var e;
  return (e = r.__r3f) == null ? void 0 : e.root.getState();
};
function I2(r) {
  let e = r.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Oo = {
  obj: (r) => r === Object(r) && !Oo.arr(r) && typeof r != "function",
  fun: (r) => typeof r == "function",
  str: (r) => typeof r == "string",
  num: (r) => typeof r == "number",
  boo: (r) => typeof r == "boolean",
  und: (r) => r === void 0,
  arr: (r) => Array.isArray(r),
  equ(r, e, {
    arrays: t = "shallow",
    objects: n = "reference",
    strict: i = !0
  } = {}) {
    if (typeof r != typeof e || !!r != !!e) return !1;
    if (Oo.str(r) || Oo.num(r) || Oo.boo(r)) return r === e;
    const o = Oo.obj(r);
    if (o && n === "reference") return r === e;
    const l = Oo.arr(r);
    if (l && t === "reference") return r === e;
    if ((l || o) && r === e) return !0;
    let u;
    for (u in r) if (!(u in e)) return !1;
    if (o && t === "shallow" && n === "shallow") {
      for (u in i ? e : r) if (!Oo.equ(r[u], e[u], {
        strict: i,
        objects: "reference"
      })) return !1;
    } else
      for (u in i ? e : r) if (r[u] !== e[u]) return !1;
    if (Oo.und(u)) {
      if (l && r.length === 0 && e.length === 0 || o && Object.keys(r).length === 0 && Object.keys(e).length === 0) return !0;
      if (r !== e) return !1;
    }
    return !0;
  }
};
function Kee(r) {
  r.dispose && r.type !== "Scene" && r.dispose();
  for (const e in r)
    e.dispose == null || e.dispose(), delete r[e];
}
function JG(r, e) {
  const t = r;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, r;
}
function aX(r, e) {
  let t = r;
  if (e.includes("-")) {
    const n = e.split("-"), i = n.pop();
    return t = n.reduce((o, l) => o[l], r), {
      target: t,
      key: i
    };
  } else return {
    target: t,
    key: e
  };
}
const V5 = /-\d+$/;
function gH(r, e, t) {
  if (Oo.str(t)) {
    if (V5.test(t)) {
      const o = t.replace(V5, ""), {
        target: l,
        key: u
      } = aX(r, o);
      Array.isArray(l[u]) || (l[u] = []);
    }
    const {
      target: n,
      key: i
    } = aX(r, t);
    e.__r3f.previousAttach = n[i], n[i] = e;
  } else e.__r3f.previousAttach = t(r, e);
}
function N5(r, e, t) {
  var n, i;
  if (Oo.str(t)) {
    const {
      target: o,
      key: l
    } = aX(r, t), u = e.__r3f.previousAttach;
    u === void 0 ? delete o[l] : o[l] = u;
  } else (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(r, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function jL(r, {
  children: e,
  key: t,
  ref: n,
  ...i
}, {
  children: o,
  key: l,
  ref: u,
  ...I
} = {}, C = !1) {
  const f = r.__r3f, v = Object.entries(i), b = [];
  if (C) {
    const R = Object.keys(I);
    for (let W = 0; W < R.length; W++)
      i.hasOwnProperty(R[W]) || v.unshift([R[W], JL + "remove"]);
  }
  v.forEach(([R, W]) => {
    var x;
    if ((x = r.__r3f) != null && x.primitive && R === "object" || Oo.equ(W, I[R])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(R)) return b.push([R, W, !0, []]);
    let N = [];
    R.includes("-") && (N = R.split("-")), b.push([R, W, !1, N]);
    for (const Y in i) {
      const F = i[Y];
      Y.startsWith(`${R}-`) && b.push([Y, F, !1, Y.split("-")]);
    }
  });
  const S = {
    ...i
  };
  return f != null && f.memoizedProps && f != null && f.memoizedProps.args && (S.args = f.memoizedProps.args), f != null && f.memoizedProps && f != null && f.memoizedProps.attach && (S.attach = f.memoizedProps.attach), {
    memoized: S,
    changes: b
  };
}
const Lee = typeof process < "u" && kL.NODE_ENV !== "production";
function dH(r, e) {
  var t;
  const n = r.__r3f, i = n?.root, o = i == null || i.getState == null ? void 0 : i.getState(), {
    memoized: l,
    changes: u
  } = zee(e) ? e : jL(r, e), I = n?.eventCount;
  r.__r3f && (r.__r3f.memoizedProps = l);
  for (let b = 0; b < u.length; b++) {
    let [S, R, W, x] = u[b];
    if (cH(r)) {
      const T = "srgb", P = "srgb-linear";
      S === "encoding" ? (S = "colorSpace", R = R === 3001 ? T : P) : S === "outputEncoding" && (S = "outputColorSpace", R = R === 3001 ? T : P);
    }
    let N = r, Y = N[S];
    if (x.length && (Y = x.reduce((F, T) => F[T], r), !(Y && Y.set))) {
      const [F, ...T] = x.reverse();
      N = T.reverse().reduce((P, D) => P[D], r), S = F;
    }
    if (R === JL + "remove")
      if (N.constructor) {
        let F = W5.get(N.constructor);
        F || (F = new N.constructor(), W5.set(N.constructor, F)), R = F[S];
      } else
        R = 0;
    if (W && n)
      R ? n.handlers[S] = R : delete n.handlers[S], n.eventCount = Object.keys(n.handlers).length;
    else if (Y && Y.set && (Y.copy || Y instanceof pb)) {
      if (Array.isArray(R))
        Y.fromArray ? Y.fromArray(R) : Y.set(...R);
      else if (Y.copy && R && R.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (Lee ? Y.constructor.name === R.constructor.name : Y.constructor === R.constructor))
        Y.copy(R);
      else if (R !== void 0) {
        var C;
        const F = (C = Y) == null ? void 0 : C.isColor;
        !F && Y.setScalar ? Y.setScalar(R) : Y instanceof pb && R instanceof pb ? Y.mask = R.mask : Y.set(R), !DL() && o && !o.linear && F && Y.convertSRGBToLinear();
      }
    } else {
      var f;
      if (N[S] = R, (f = N[S]) != null && f.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
      N[S].format === cg && N[S].type === nf && o) {
        const F = N[S];
        cH(F) && cH(o.gl) ? F.colorSpace = o.gl.outputColorSpace : F.encoding = o.gl.outputEncoding;
      }
    }
    QG(r);
  }
  if (n && n.parent && r.raycast && I !== n.eventCount) {
    const b = I2(r).getState().internal, S = b.interaction.indexOf(r);
    S > -1 && b.interaction.splice(S, 1), n.eventCount && b.interaction.push(r);
  }
  return !(u.length === 1 && u[0][0] === "onUpdate") && u.length && (t = r.__r3f) != null && t.parent && oX(r), r;
}
function QG(r) {
  var e, t;
  const n = (e = r.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  n && n.internal.frames === 0 && n.invalidate();
}
function oX(r) {
  r.onUpdate == null || r.onUpdate(r);
}
function kee(r, e) {
  r.manual || (UL(r) ? (r.left = e.width / -2, r.right = e.width / 2, r.top = e.height / 2, r.bottom = e.height / -2) : r.aspect = e.width / e.height, r.updateProjectionMatrix(), r.updateMatrixWorld());
}
function j1(r) {
  return (r.eventObject || r.object).uuid + "/" + r.index + r.instanceId;
}
function Dee() {
  var r;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e) return iB.DefaultEventPriority;
  switch ((r = e.event) == null ? void 0 : r.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return iB.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return iB.ContinuousEventPriority;
    default:
      return iB.DefaultEventPriority;
  }
}
function qL(r, e, t, n) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (r.delete(n), i.target.releasePointerCapture(n)));
}
function Uee(r, e) {
  const {
    internal: t
  } = r.getState();
  t.interaction = t.interaction.filter((n) => n !== e), t.initialHits = t.initialHits.filter((n) => n !== e), t.hovered.forEach((n, i) => {
    (n.eventObject === e || n.object === e) && t.hovered.delete(i);
  }), t.capturedMap.forEach((n, i) => {
    qL(t.capturedMap, e, n, i);
  });
}
function Oee(r) {
  function e(I) {
    const {
      internal: C
    } = r.getState(), f = I.offsetX - C.initialClick[0], v = I.offsetY - C.initialClick[1];
    return Math.round(Math.sqrt(f * f + v * v));
  }
  function t(I) {
    return I.filter((C) => ["Move", "Over", "Enter", "Out", "Leave"].some((f) => {
      var v;
      return (v = C.__r3f) == null ? void 0 : v.handlers["onPointer" + f];
    }));
  }
  function n(I, C) {
    const f = r.getState(), v = /* @__PURE__ */ new Set(), b = [], S = C ? C(f.internal.interaction) : f.internal.interaction;
    for (let N = 0; N < S.length; N++) {
      const Y = XZ(S[N]);
      Y && (Y.raycaster.camera = void 0);
    }
    f.previousRoot || f.events.compute == null || f.events.compute(I, f);
    function R(N) {
      const Y = XZ(N);
      if (!Y || !Y.events.enabled || Y.raycaster.camera === null) return [];
      if (Y.raycaster.camera === void 0) {
        var F;
        Y.events.compute == null || Y.events.compute(I, Y, (F = Y.previousRoot) == null ? void 0 : F.getState()), Y.raycaster.camera === void 0 && (Y.raycaster.camera = null);
      }
      return Y.raycaster.camera ? Y.raycaster.intersectObject(N, !0) : [];
    }
    let W = S.flatMap(R).sort((N, Y) => {
      const F = XZ(N.object), T = XZ(Y.object);
      return !F || !T ? N.distance - Y.distance : T.events.priority - F.events.priority || N.distance - Y.distance;
    }).filter((N) => {
      const Y = j1(N);
      return v.has(Y) ? !1 : (v.add(Y), !0);
    });
    f.events.filter && (W = f.events.filter(W, f));
    for (const N of W) {
      let Y = N.object;
      for (; Y; ) {
        var x;
        (x = Y.__r3f) != null && x.eventCount && b.push({
          ...N,
          eventObject: Y
        }), Y = Y.parent;
      }
    }
    if ("pointerId" in I && f.internal.capturedMap.has(I.pointerId))
      for (let N of f.internal.capturedMap.get(I.pointerId).values())
        v.has(j1(N.intersection)) || b.push(N.intersection);
    return b;
  }
  function i(I, C, f, v) {
    const b = r.getState();
    if (I.length) {
      const S = {
        stopped: !1
      };
      for (const R of I) {
        const W = XZ(R.object) || b, {
          raycaster: x,
          pointer: N,
          camera: Y,
          internal: F
        } = W, T = new fe(N.x, N.y, 0).unproject(Y), P = (O) => {
          var ne, he;
          return (ne = (he = F.capturedMap.get(O)) == null ? void 0 : he.has(R.eventObject)) != null ? ne : !1;
        }, D = (O) => {
          const ne = {
            intersection: R,
            target: C.target
          };
          F.capturedMap.has(O) ? F.capturedMap.get(O).set(R.eventObject, ne) : F.capturedMap.set(O, /* @__PURE__ */ new Map([[R.eventObject, ne]])), C.target.setPointerCapture(O);
        }, L = (O) => {
          const ne = F.capturedMap.get(O);
          ne && qL(F.capturedMap, R.eventObject, ne, O);
        };
        let j = {};
        for (let O in C) {
          let ne = C[O];
          typeof ne != "function" && (j[O] = ne);
        }
        let J = {
          ...R,
          ...j,
          pointer: N,
          intersections: I,
          stopped: S.stopped,
          delta: f,
          unprojectedPoint: T,
          ray: x.ray,
          camera: Y,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const O = "pointerId" in C && F.capturedMap.get(C.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!O || // ... or if the hit object is capturing the pointer
              O.has(R.eventObject)) && (J.stopped = S.stopped = !0, F.hovered.size && Array.from(F.hovered.values()).find((ne) => ne.eventObject === R.eventObject))
            ) {
              const ne = I.slice(0, I.indexOf(R));
              o([...ne, R]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: P,
            setPointerCapture: D,
            releasePointerCapture: L
          },
          currentTarget: {
            hasPointerCapture: P,
            setPointerCapture: D,
            releasePointerCapture: L
          },
          nativeEvent: C
        };
        if (v(J), S.stopped === !0) break;
      }
    }
    return I;
  }
  function o(I) {
    const {
      internal: C
    } = r.getState();
    for (const f of C.hovered.values())
      if (!I.length || !I.find((v) => v.object === f.object && v.index === f.index && v.instanceId === f.instanceId)) {
        const b = f.eventObject.__r3f, S = b?.handlers;
        if (C.hovered.delete(j1(f)), b != null && b.eventCount) {
          const R = {
            ...f,
            intersections: I
          };
          S.onPointerOut == null || S.onPointerOut(R), S.onPointerLeave == null || S.onPointerLeave(R);
        }
      }
  }
  function l(I, C) {
    for (let f = 0; f < C.length; f++) {
      const v = C[f].__r3f;
      v == null || v.handlers.onPointerMissed == null || v.handlers.onPointerMissed(I);
    }
  }
  function u(I) {
    switch (I) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (C) => {
          const {
            internal: f
          } = r.getState();
          "pointerId" in C && f.capturedMap.has(C.pointerId) && requestAnimationFrame(() => {
            f.capturedMap.has(C.pointerId) && (f.capturedMap.delete(C.pointerId), o([]));
          });
        };
    }
    return function(f) {
      const {
        onPointerMissed: v,
        internal: b
      } = r.getState();
      b.lastEvent.current = f;
      const S = I === "onPointerMove", R = I === "onClick" || I === "onContextMenu" || I === "onDoubleClick", x = n(f, S ? t : void 0), N = R ? e(f) : 0;
      I === "onPointerDown" && (b.initialClick = [f.offsetX, f.offsetY], b.initialHits = x.map((F) => F.eventObject)), R && !x.length && N <= 2 && (l(f, b.interaction), v && v(f)), S && o(x);
      function Y(F) {
        const T = F.eventObject, P = T.__r3f, D = P?.handlers;
        if (P != null && P.eventCount)
          if (S) {
            if (D.onPointerOver || D.onPointerEnter || D.onPointerOut || D.onPointerLeave) {
              const L = j1(F), j = b.hovered.get(L);
              j ? j.stopped && F.stopPropagation() : (b.hovered.set(L, F), D.onPointerOver == null || D.onPointerOver(F), D.onPointerEnter == null || D.onPointerEnter(F));
            }
            D.onPointerMove == null || D.onPointerMove(F);
          } else {
            const L = D[I];
            L ? (!R || b.initialHits.includes(T)) && (l(f, b.interaction.filter((j) => !b.initialHits.includes(j))), L(F)) : R && b.initialHits.includes(T) && l(f, b.interaction.filter((j) => !b.initialHits.includes(j)));
          }
      }
      i(x, f, N, Y);
    };
  }
  return {
    handlePointer: u
  };
}
const $L = (r) => !!(r != null && r.render), e9 = /* @__PURE__ */ ye.createContext(null), Pee = (r, e) => {
  const t = xee((u, I) => {
    const C = new fe(), f = new fe(), v = new fe();
    function b(N = I().camera, Y = f, F = I().size) {
      const {
        width: T,
        height: P,
        top: D,
        left: L
      } = F, j = T / P;
      Y.isVector3 ? v.copy(Y) : v.set(...Y);
      const J = N.getWorldPosition(C).distanceTo(v);
      if (UL(N))
        return {
          width: T / N.zoom,
          height: P / N.zoom,
          top: D,
          left: L,
          factor: 1,
          distance: J,
          aspect: j
        };
      {
        const O = N.fov * Math.PI / 180, ne = 2 * Math.tan(O / 2) * J, he = ne * (T / P);
        return {
          width: he,
          height: ne,
          top: D,
          left: L,
          factor: T / he,
          distance: J,
          aspect: j
        };
      }
    }
    let S;
    const R = (N) => u((Y) => ({
      performance: {
        ...Y.performance,
        current: N
      }
    })), W = new Lt();
    return {
      set: u,
      get: I,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (N = 1) => r(I(), N),
      advance: (N, Y) => e(N, Y, I()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new MY(),
      pointer: W,
      mouse: W,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const N = I();
          S && clearTimeout(S), N.performance.current !== N.performance.min && R(N.performance.min), S = setTimeout(() => R(I().performance.max), N.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: b
      },
      setEvents: (N) => u((Y) => ({
        ...Y,
        events: {
          ...Y.events,
          ...N
        }
      })),
      setSize: (N, Y, F, T, P) => {
        const D = I().camera, L = {
          width: N,
          height: Y,
          top: T || 0,
          left: P || 0,
          updateStyle: F
        };
        u((j) => ({
          size: L,
          viewport: {
            ...j.viewport,
            ...b(D, f, L)
          }
        }));
      },
      setDpr: (N) => u((Y) => {
        const F = QL(N);
        return {
          viewport: {
            ...Y.viewport,
            dpr: F,
            initialDpr: Y.viewport.initialDpr || F
          }
        };
      }),
      setFrameloop: (N = "always") => {
        const Y = I().clock;
        Y.stop(), Y.elapsedTime = 0, N !== "never" && (Y.start(), Y.elapsedTime = 0), u(() => ({
          frameloop: N
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ ye.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (N, Y, F) => {
          const T = I().internal;
          return T.priority = T.priority + (Y > 0 ? 1 : 0), T.subscribers.push({
            ref: N,
            priority: Y,
            store: F
          }), T.subscribers = T.subscribers.sort((P, D) => P.priority - D.priority), () => {
            const P = I().internal;
            P != null && P.subscribers && (P.priority = P.priority - (Y > 0 ? 1 : 0), P.subscribers = P.subscribers.filter((D) => D.ref !== N));
          };
        }
      }
    };
  }), n = t.getState();
  let i = n.size, o = n.viewport.dpr, l = n.camera;
  return t.subscribe(() => {
    const {
      camera: u,
      size: I,
      viewport: C,
      gl: f,
      set: v
    } = t.getState();
    if (I.width !== i.width || I.height !== i.height || C.dpr !== o) {
      var b;
      i = I, o = C.dpr, kee(u, I), f.setPixelRatio(C.dpr);
      const S = (b = I.updateStyle) != null ? b : typeof HTMLCanvasElement < "u" && f.domElement instanceof HTMLCanvasElement;
      f.setSize(I.width, I.height, S);
    }
    u !== l && (l = u, v((S) => ({
      viewport: {
        ...S.viewport,
        ...S.viewport.getCurrentViewport(u)
      }
    })));
  }), t.subscribe((u) => r(u)), t;
};
let q1, Jee = /* @__PURE__ */ new Set(), Qee = /* @__PURE__ */ new Set(), jee = /* @__PURE__ */ new Set();
function IH(r, e) {
  if (r.size)
    for (const {
      callback: t
    } of r.values())
      t(e);
}
function YZ(r, e) {
  switch (r) {
    case "before":
      return IH(Jee, e);
    case "after":
      return IH(Qee, e);
    case "tail":
      return IH(jee, e);
  }
}
let CH, hH;
function fH(r, e, t) {
  let n = e.clock.getDelta();
  for (e.frameloop === "never" && typeof r == "number" && (n = r - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = r), CH = e.internal.subscribers, q1 = 0; q1 < CH.length; q1++)
    hH = CH[q1], hH.ref.current(hH.store.getState(), n, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function qee(r) {
  let e = !1, t = !1, n, i, o;
  function l(C) {
    i = requestAnimationFrame(l), e = !0, n = 0, YZ("before", C), t = !0;
    for (const v of r.values()) {
      var f;
      o = v.store.getState(), o.internal.active && (o.frameloop === "always" || o.internal.frames > 0) && !((f = o.gl.xr) != null && f.isPresenting) && (n += fH(C, o));
    }
    if (t = !1, YZ("after", C), n === 0)
      return YZ("tail", C), e = !1, cancelAnimationFrame(i);
  }
  function u(C, f = 1) {
    var v;
    if (!C) return r.forEach((b) => u(b.store.getState(), f));
    (v = C.gl.xr) != null && v.isPresenting || !C.internal.active || C.frameloop === "never" || (f > 1 ? C.internal.frames = Math.min(60, C.internal.frames + f) : t ? C.internal.frames = 2 : C.internal.frames = 1, e || (e = !0, requestAnimationFrame(l)));
  }
  function I(C, f = !0, v, b) {
    if (f && YZ("before", C), v) fH(C, v, b);
    else for (const S of r.values()) fH(C, S.store.getState());
    f && YZ("after", C);
  }
  return {
    loop: l,
    invalidate: u,
    advance: I
  };
}
function t9() {
  const r = ye.useContext(e9);
  if (!r) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return r;
}
function Jg(r = (t) => t, e) {
  return t9()(r, e);
}
function cV(r, e = 0) {
  const t = t9(), n = t.getState().internal.subscribe, i = OL(r);
  return sR(() => n(i, e, t), [e, n, t]), null;
}
const mB = /* @__PURE__ */ new Map(), {
  invalidate: M5,
  advance: H5
} = qee(mB), {
  reconciler: iW,
  applyProps: LG
} = Eee(mB, Dee), kG = {
  objects: "shallow",
  strict: !1
}, $ee = (r, e) => {
  const t = typeof r == "function" ? r(e) : r;
  return $L(t) ? t : new jK({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...r
  });
};
function ete(r, e) {
  const t = typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: n,
      height: i,
      top: o,
      left: l,
      updateStyle: u = t
    } = e;
    return {
      width: n,
      height: i,
      top: o,
      left: l,
      updateStyle: u
    };
  } else if (typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement && r.parentElement) {
    const {
      width: n,
      height: i,
      top: o,
      left: l
    } = r.parentElement.getBoundingClientRect();
    return {
      width: n,
      height: i,
      top: o,
      left: l,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas)
    return {
      width: r.width,
      height: r.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function tte(r) {
  const e = mB.get(r), t = e?.fiber, n = e?.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), o = n || Pee(M5, H5), l = t || iW.createContainer(o, iB.ConcurrentRoot, null, !1, null, "", i, null);
  e || mB.set(r, {
    fiber: l,
    store: o
  });
  let u, I = !1, C;
  return {
    configure(f = {}) {
      let {
        gl: v,
        size: b,
        scene: S,
        events: R,
        onCreated: W,
        shadows: x = !1,
        linear: N = !1,
        flat: Y = !1,
        legacy: F = !1,
        orthographic: T = !1,
        frameloop: P = "always",
        dpr: D = [1, 2],
        performance: L,
        raycaster: j,
        camera: J,
        onPointerMissed: O
      } = f, ne = o.getState(), he = ne.gl;
      ne.gl || ne.set({
        gl: he = $ee(v, r)
      });
      let pe = ne.raycaster;
      pe || ne.set({
        raycaster: pe = new FY()
      });
      const {
        params: Ae,
        ...ke
      } = j || {};
      if (Oo.equ(ke, pe, kG) || LG(pe, {
        ...ke
      }), Oo.equ(Ae, pe.params, kG) || LG(pe, {
        params: {
          ...pe.params,
          ...Ae
        }
      }), !ne.camera || ne.camera === C && !Oo.equ(C, J, kG)) {
        C = J;
        const Be = J instanceof $w, le = Be ? J : T ? new pv(0, 0, 0, 0, 0.1, 1e3) : new hl(75, 0, 0.1, 1e3);
        Be || (le.position.z = 5, J && (LG(le, J), ("aspect" in J || "left" in J || "right" in J || "bottom" in J || "top" in J) && (le.manual = !0, le.updateProjectionMatrix())), !ne.camera && !(J != null && J.rotation) && le.lookAt(0, 0, 0)), ne.set({
          camera: le
        }), pe.camera = le;
      }
      if (!ne.scene) {
        let Be;
        S != null && S.isScene ? Be = S : (Be = new fY(), S && LG(Be, S)), ne.set({
          scene: JG(Be)
        });
      }
      if (!ne.xr) {
        var Re;
        const Be = (nt, ze) => {
          const Je = o.getState();
          Je.frameloop !== "never" && H5(nt, !0, Je, ze);
        }, le = () => {
          const nt = o.getState();
          nt.gl.xr.enabled = nt.gl.xr.isPresenting, nt.gl.xr.setAnimationLoop(nt.gl.xr.isPresenting ? Be : null), nt.gl.xr.isPresenting || M5(nt);
        }, Ye = {
          connect() {
            const nt = o.getState().gl;
            nt.xr.addEventListener("sessionstart", le), nt.xr.addEventListener("sessionend", le);
          },
          disconnect() {
            const nt = o.getState().gl;
            nt.xr.removeEventListener("sessionstart", le), nt.xr.removeEventListener("sessionend", le);
          }
        };
        typeof ((Re = he.xr) == null ? void 0 : Re.addEventListener) == "function" && Ye.connect(), ne.set({
          xr: Ye
        });
      }
      if (he.shadowMap) {
        const Be = he.shadowMap.enabled, le = he.shadowMap.type;
        if (he.shadowMap.enabled = !!x, Oo.boo(x))
          he.shadowMap.type = QZ;
        else if (Oo.str(x)) {
          var Xe;
          const Ye = {
            basic: _z,
            percentage: VW,
            soft: QZ,
            variance: qh
          };
          he.shadowMap.type = (Xe = Ye[x]) != null ? Xe : QZ;
        } else Oo.obj(x) && Object.assign(he.shadowMap, x);
        (Be !== he.shadowMap.enabled || le !== he.shadowMap.type) && (he.shadowMap.needsUpdate = !0);
      }
      const re = DL();
      re && ("enabled" in re ? re.enabled = !F : "legacyMode" in re && (re.legacyMode = F)), I || LG(he, {
        outputEncoding: N ? 3e3 : 3001,
        toneMapping: Y ? cp : QX
      }), ne.legacy !== F && ne.set(() => ({
        legacy: F
      })), ne.linear !== N && ne.set(() => ({
        linear: N
      })), ne.flat !== Y && ne.set(() => ({
        flat: Y
      })), v && !Oo.fun(v) && !$L(v) && !Oo.equ(v, he, kG) && LG(he, v), R && !ne.events.handlers && ne.set({
        events: R(o)
      });
      const Se = ete(r, b);
      return Oo.equ(Se, ne.size, kG) || ne.setSize(Se.width, Se.height, Se.updateStyle, Se.top, Se.left), D && ne.viewport.dpr !== QL(D) && ne.setDpr(D), ne.frameloop !== P && ne.setFrameloop(P), ne.onPointerMissed || ne.set({
        onPointerMissed: O
      }), L && !Oo.equ(L, ne.performance, kG) && ne.set((Be) => ({
        performance: {
          ...Be.performance,
          ...L
        }
      })), u = W, I = !0, this;
    },
    render(f) {
      return I || this.configure(), iW.updateContainer(/* @__PURE__ */ We.jsx(nte, {
        store: o,
        children: f,
        onCreated: u,
        rootElement: r
      }), l, null, () => {
      }), o;
    },
    unmount() {
      n9(r);
    }
  };
}
function nte({
  store: r,
  children: e,
  onCreated: t,
  rootElement: n
}) {
  return sR(() => {
    const i = r.getState();
    i.set((o) => ({
      internal: {
        ...o.internal,
        active: !0
      }
    })), t && t(i), r.getState().events.connected || i.events.connect == null || i.events.connect(n);
  }, []), /* @__PURE__ */ We.jsx(e9.Provider, {
    value: r,
    children: e
  });
}
function n9(r, e) {
  const t = mB.get(r), n = t?.fiber;
  if (n) {
    const i = t?.store.getState();
    i && (i.internal.active = !1), iW.updateContainer(null, n, null, () => {
      i && setTimeout(() => {
        try {
          var o, l, u, I;
          i.events.disconnect == null || i.events.disconnect(), (o = i.gl) == null || (l = o.renderLists) == null || l.dispose == null || l.dispose(), (u = i.gl) == null || u.forceContextLoss == null || u.forceContextLoss(), (I = i.gl) != null && I.xr && i.xr.disconnect(), Kee(i), mB.delete(r);
        } catch {
        }
      }, 500);
    });
  }
}
iW.injectIntoDevTools({
  bundleType: kL.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: ye.version
});
const pH = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function ite(r) {
  const {
    handlePointer: e
  } = Oee(r);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, i) {
      n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(pH).reduce((t, n) => ({
      ...t,
      [n]: e(n)
    }), {}),
    update: () => {
      var t;
      const {
        events: n,
        internal: i
      } = r.getState();
      (t = i.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var n;
      const {
        set: i,
        events: o
      } = r.getState();
      o.disconnect == null || o.disconnect(), i((l) => ({
        events: {
          ...l.events,
          connected: t
        }
      })), Object.entries((n = o.handlers) != null ? n : []).forEach(([l, u]) => {
        const [I, C] = pH[l];
        t.addEventListener(I, u, {
          passive: C
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: n
      } = r.getState();
      if (n.connected) {
        var i;
        Object.entries((i = n.handlers) != null ? i : []).forEach(([o, l]) => {
          if (n && n.connected instanceof HTMLElement) {
            const [u] = pH[o];
            n.connected.removeEventListener(u, l);
          }
        }), t((o) => ({
          events: {
            ...o.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
function X5(r, e) {
  let t;
  return (...n) => {
    window.clearTimeout(t), t = window.setTimeout(() => r(...n), e);
  };
}
function rte({ debounce: r, scroll: e, polyfill: t, offsetSize: n } = { debounce: 0, scroll: !1, offsetSize: !1 }) {
  const i = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!i) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [o, l] = ye.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), u = ye.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: o, orientationHandler: null }), I = r ? typeof r == "number" ? r : r.scroll : null, C = r ? typeof r == "number" ? r : r.resize : null, f = ye.useRef(!1);
  ye.useEffect(() => (f.current = !0, () => void (f.current = !1)));
  const [v, b, S] = ye.useMemo(() => {
    const N = () => {
      if (!u.current.element) return;
      const { left: Y, top: F, width: T, height: P, bottom: D, right: L, x: j, y: J } = u.current.element.getBoundingClientRect(), O = { left: Y, top: F, width: T, height: P, bottom: D, right: L, x: j, y: J };
      u.current.element instanceof HTMLElement && n && (O.height = u.current.element.offsetHeight, O.width = u.current.element.offsetWidth), Object.freeze(O), f.current && !lte(u.current.lastBounds, O) && l(u.current.lastBounds = O);
    };
    return [N, C ? X5(N, C) : N, I ? X5(N, I) : N];
  }, [l, n, I, C]);
  function R() {
    u.current.scrollContainers && (u.current.scrollContainers.forEach((N) => N.removeEventListener("scroll", S, !0)), u.current.scrollContainers = null), u.current.resizeObserver && (u.current.resizeObserver.disconnect(), u.current.resizeObserver = null), u.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", u.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", u.current.orientationHandler));
  }
  function W() {
    u.current.element && (u.current.resizeObserver = new i(S), u.current.resizeObserver.observe(u.current.element), e && u.current.scrollContainers && u.current.scrollContainers.forEach((N) => N.addEventListener("scroll", S, { capture: !0, passive: !0 })), u.current.orientationHandler = () => {
      S();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", u.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", u.current.orientationHandler));
  }
  const x = (N) => {
    !N || N === u.current.element || (R(), u.current.element = N, u.current.scrollContainers = i9(N), W());
  };
  return ote(S, !!e), ate(b), ye.useEffect(() => {
    R(), W();
  }, [e, S, b]), ye.useEffect(() => R, []), [x, o, v];
}
function ate(r) {
  ye.useEffect(() => {
    const e = r;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [r]);
}
function ote(r, e) {
  ye.useEffect(() => {
    if (e) {
      const t = r;
      return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [r, e]);
}
function i9(r) {
  const e = [];
  if (!r || r === document.body) return e;
  const { overflow: t, overflowX: n, overflowY: i } = window.getComputedStyle(r);
  return [t, n, i].some((o) => o === "auto" || o === "scroll") && e.push(r), [...e, ...i9(r.parentElement)];
}
const ste = ["x", "y", "top", "bottom", "left", "right", "width", "height"], lte = (r, e) => ste.every((t) => r[t] === e[t]);
var ute = Object.defineProperty, cte = Object.defineProperties, gte = Object.getOwnPropertyDescriptors, Y5 = Object.getOwnPropertySymbols, dte = Object.prototype.hasOwnProperty, Ite = Object.prototype.propertyIsEnumerable, F5 = (r, e, t) => e in r ? ute(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, E5 = (r, e) => {
  for (var t in e || (e = {}))
    dte.call(e, t) && F5(r, t, e[t]);
  if (Y5)
    for (var t of Y5(e))
      Ite.call(e, t) && F5(r, t, e[t]);
  return r;
}, Cte = (r, e) => cte(r, gte(e)), T5, _5;
typeof window < "u" && ((T5 = window.document) != null && T5.createElement || ((_5 = window.navigator) == null ? void 0 : _5.product) === "ReactNative") ? ye.useLayoutEffect : ye.useEffect;
function r9(r, e, t) {
  if (!r)
    return;
  if (t(r) === !0)
    return r;
  let n = r.child;
  for (; n; ) {
    const i = r9(n, e, t);
    if (i)
      return i;
    n = n.sibling;
  }
}
function a9(r) {
  try {
    return Object.defineProperties(r, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return r;
  }
}
const z5 = console.error;
console.error = function() {
  const r = [...arguments].join("");
  if (r?.startsWith("Warning:") && r.includes("useContext")) {
    console.error = z5;
    return;
  }
  return z5.apply(this, arguments);
};
const zY = a9(ye.createContext(null));
class o9 extends ye.Component {
  render() {
    return /* @__PURE__ */ ye.createElement(zY.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
function hte() {
  const r = ye.useContext(zY);
  if (r === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = ye.useId();
  return ye.useMemo(() => {
    for (const n of [r, r?.alternate]) {
      if (!n)
        continue;
      const i = r9(n, !1, (o) => {
        let l = o.memoizedState;
        for (; l; ) {
          if (l.memoizedState === e)
            return !0;
          l = l.next;
        }
      });
      if (i)
        return i;
    }
  }, [r, e]);
}
function fte() {
  const r = hte(), [e] = ye.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = r;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      i && i !== zY && !e.has(i) && e.set(i, ye.useContext(a9(i)));
    }
    t = t.return;
  }
  return e;
}
function pte() {
  const r = fte();
  return ye.useMemo(
    () => Array.from(r.keys()).reduce(
      (e, t) => (n) => /* @__PURE__ */ ye.createElement(e, null, /* @__PURE__ */ ye.createElement(t.Provider, Cte(E5({}, n), {
        value: r.get(t)
      }))),
      (e) => /* @__PURE__ */ ye.createElement(o9, E5({}, e))
    ),
    [r]
  );
}
const mte = /* @__PURE__ */ ye.forwardRef(function({
  children: e,
  fallback: t,
  resize: n,
  style: i,
  gl: o,
  events: l = ite,
  eventSource: u,
  eventPrefix: I,
  shadows: C,
  linear: f,
  flat: v,
  legacy: b,
  orthographic: S,
  frameloop: R,
  dpr: W,
  performance: x,
  raycaster: N,
  camera: Y,
  scene: F,
  onPointerMissed: T,
  onCreated: P,
  ...D
}, L) {
  ye.useMemo(() => Fee(Gee), []);
  const j = pte(), [J, O] = rte({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...n
  }), ne = ye.useRef(null), he = ye.useRef(null);
  ye.useImperativeHandle(L, () => ne.current);
  const pe = OL(T), [Ae, ke] = ye.useState(!1), [Re, Xe] = ye.useState(!1);
  if (Ae) throw Ae;
  if (Re) throw Re;
  const re = ye.useRef(null);
  sR(() => {
    const Be = ne.current;
    O.width > 0 && O.height > 0 && Be && (re.current || (re.current = tte(Be)), re.current.configure({
      gl: o,
      events: l,
      shadows: C,
      linear: f,
      flat: v,
      legacy: b,
      orthographic: S,
      frameloop: R,
      dpr: W,
      performance: x,
      raycaster: N,
      camera: Y,
      scene: F,
      size: O,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...le) => pe.current == null ? void 0 : pe.current(...le),
      onCreated: (le) => {
        le.events.connect == null || le.events.connect(u ? Tee(u) ? u.current : u : he.current), I && le.setEvents({
          compute: (Ye, nt) => {
            const ze = Ye[I + "X"], Je = Ye[I + "Y"];
            nt.pointer.set(ze / nt.size.width * 2 - 1, -(Je / nt.size.height) * 2 + 1), nt.raycaster.setFromCamera(nt.pointer, nt.camera);
          }
        }), P?.(le);
      }
    }), re.current.render(/* @__PURE__ */ We.jsx(j, {
      children: /* @__PURE__ */ We.jsx(PL, {
        set: Xe,
        children: /* @__PURE__ */ We.jsx(ye.Suspense, {
          fallback: /* @__PURE__ */ We.jsx(_ee, {
            set: ke
          }),
          children: e ?? null
        })
      })
    })));
  }), ye.useEffect(() => {
    const Be = ne.current;
    if (Be) return () => n9(Be);
  }, []);
  const Se = u ? "none" : "auto";
  return /* @__PURE__ */ We.jsx("div", {
    ref: he,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: Se,
      ...i
    },
    ...D,
    children: /* @__PURE__ */ We.jsx("div", {
      ref: J,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ We.jsx("canvas", {
        ref: ne,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}), Ate = /* @__PURE__ */ ye.forwardRef(function(e, t) {
  return /* @__PURE__ */ We.jsx(o9, {
    children: /* @__PURE__ */ We.jsx(mte, {
      ...e,
      ref: t
    })
  });
});
var vte = Object.defineProperty, yte = (r, e, t) => e in r ? vte(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, bte = (r, e, t) => (yte(r, e + "", t), t);
class Gte {
  constructor() {
    bte(this, "_listeners");
  }
  /**
   * Adds a listener to an event type.
   * @param type The type of event to listen to.
   * @param listener The function that gets called when the event is fired.
   */
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
      * Checks if listener is added to an event type.
      * @param type The type of event to listen to.
      * @param listener The function that gets called when the event is fired.
      */
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
      * Removes a listener from an event type.
      * @param type The type of the listener that gets removed.
      * @param listener The listener function that gets removed.
      */
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  /**
      * Fire an event type.
      * @param event The event that gets fired.
      */
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let o = 0, l = i.length; o < l; o++)
        i[o].call(this, e);
      e.target = null;
    }
  }
}
var Bte = Object.defineProperty, Ste = (r, e, t) => e in r ? Bte(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Ti = (r, e, t) => (Ste(r, typeof e != "symbol" ? e + "" : e, t), t);
const $1 = /* @__PURE__ */ new Nb(), K5 = /* @__PURE__ */ new Em(), Zte = Math.cos(70 * (Math.PI / 180)), L5 = (r, e) => (r % e + e) % e;
let wte = class extends Gte {
  constructor(e, t) {
    super(), Ti(this, "object"), Ti(this, "domElement"), Ti(this, "enabled", !0), Ti(this, "target", new fe()), Ti(this, "minDistance", 0), Ti(this, "maxDistance", 1 / 0), Ti(this, "minZoom", 0), Ti(this, "maxZoom", 1 / 0), Ti(this, "minPolarAngle", 0), Ti(this, "maxPolarAngle", Math.PI), Ti(this, "minAzimuthAngle", -1 / 0), Ti(this, "maxAzimuthAngle", 1 / 0), Ti(this, "enableDamping", !1), Ti(this, "dampingFactor", 0.05), Ti(this, "enableZoom", !0), Ti(this, "zoomSpeed", 1), Ti(this, "enableRotate", !0), Ti(this, "rotateSpeed", 1), Ti(this, "enablePan", !0), Ti(this, "panSpeed", 1), Ti(this, "screenSpacePanning", !0), Ti(this, "keyPanSpeed", 7), Ti(this, "zoomToCursor", !1), Ti(this, "autoRotate", !1), Ti(this, "autoRotateSpeed", 2), Ti(this, "reverseOrbit", !1), Ti(this, "reverseHorizontalOrbit", !1), Ti(this, "reverseVerticalOrbit", !1), Ti(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), Ti(this, "mouseButtons", {
      LEFT: qy.ROTATE,
      MIDDLE: qy.DOLLY,
      RIGHT: qy.PAN
    }), Ti(this, "touches", { ONE: $y.ROTATE, TWO: $y.DOLLY_PAN }), Ti(this, "target0"), Ti(this, "position0"), Ti(this, "zoom0"), Ti(this, "_domElementKeyEvents", null), Ti(this, "getPolarAngle"), Ti(this, "getAzimuthalAngle"), Ti(this, "setPolarAngle"), Ti(this, "setAzimuthalAngle"), Ti(this, "getDistance"), Ti(this, "getZoomScale"), Ti(this, "listenToKeyEvents"), Ti(this, "stopListenToKeyEvents"), Ti(this, "saveState"), Ti(this, "reset"), Ti(this, "update"), Ti(this, "connect"), Ti(this, "dispose"), Ti(this, "dollyIn"), Ti(this, "dollyOut"), Ti(this, "getScale"), Ti(this, "setScale"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => f.phi, this.getAzimuthalAngle = () => f.theta, this.setPolarAngle = (we) => {
      let qe = L5(we, 2 * Math.PI), de = f.phi;
      de < 0 && (de += 2 * Math.PI), qe < 0 && (qe += 2 * Math.PI);
      let it = Math.abs(qe - de);
      2 * Math.PI - it < it && (qe < de ? qe += 2 * Math.PI : de += 2 * Math.PI), v.phi = qe - de, n.update();
    }, this.setAzimuthalAngle = (we) => {
      let qe = L5(we, 2 * Math.PI), de = f.theta;
      de < 0 && (de += 2 * Math.PI), qe < 0 && (qe += 2 * Math.PI);
      let it = Math.abs(qe - de);
      2 * Math.PI - it < it && (qe < de ? qe += 2 * Math.PI : de += 2 * Math.PI), v.theta = qe - de, n.update();
    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (we) => {
      we.addEventListener("keydown", an), this._domElementKeyEvents = we;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", an), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = () => {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(i), n.update(), I = u.NONE;
    }, this.update = (() => {
      const we = new fe(), qe = new fe(0, 1, 0), de = new ku().setFromUnitVectors(e.up, qe), it = de.clone().invert(), je = new fe(), et = new ku(), Jt = 2 * Math.PI;
      return function() {
        const di = n.object.position;
        de.setFromUnitVectors(e.up, qe), it.copy(de).invert(), we.copy(di).sub(n.target), we.applyQuaternion(de), f.setFromVector3(we), n.autoRotate && I === u.NONE && Ae(he()), n.enableDamping ? (f.theta += v.theta * n.dampingFactor, f.phi += v.phi * n.dampingFactor) : (f.theta += v.theta, f.phi += v.phi);
        let Di = n.minAzimuthAngle, Jn = n.maxAzimuthAngle;
        isFinite(Di) && isFinite(Jn) && (Di < -Math.PI ? Di += Jt : Di > Math.PI && (Di -= Jt), Jn < -Math.PI ? Jn += Jt : Jn > Math.PI && (Jn -= Jt), Di <= Jn ? f.theta = Math.max(Di, Math.min(Jn, f.theta)) : f.theta = f.theta > (Di + Jn) / 2 ? Math.max(Di, f.theta) : Math.min(Jn, f.theta)), f.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, f.phi)), f.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(S, n.dampingFactor) : n.target.add(S), n.zoomToCursor && J || n.object.isOrthographicCamera ? f.radius = nt(f.radius) : f.radius = nt(f.radius * b), we.setFromSpherical(f), we.applyQuaternion(it), di.copy(n.target).add(we), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (v.theta *= 1 - n.dampingFactor, v.phi *= 1 - n.dampingFactor, S.multiplyScalar(1 - n.dampingFactor)) : (v.set(0, 0, 0), S.set(0, 0, 0));
        let Ii = !1;
        if (n.zoomToCursor && J) {
          let dr = null;
          if (n.object instanceof hl && n.object.isPerspectiveCamera) {
            const xr = we.length();
            dr = nt(xr * b);
            const la = xr - dr;
            n.object.position.addScaledVector(L, la), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const xr = new fe(j.x, j.y, 0);
            xr.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / b)), n.object.updateProjectionMatrix(), Ii = !0;
            const la = new fe(j.x, j.y, 0);
            la.unproject(n.object), n.object.position.sub(la).add(xr), n.object.updateMatrixWorld(), dr = we.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          dr !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(dr).add(n.object.position) : ($1.origin.copy(n.object.position), $1.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot($1.direction)) < Zte ? e.lookAt(n.target) : (K5.setFromNormalAndCoplanarPoint(n.object.up, n.target), $1.intersectPlane(K5, n.target))));
        } else n.object instanceof pv && n.object.isOrthographicCamera && (Ii = b !== 1, Ii && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / b)), n.object.updateProjectionMatrix()));
        return b = 1, J = !1, Ii || je.distanceToSquared(n.object.position) > C || 8 * (1 - et.dot(n.object.quaternion)) > C ? (n.dispatchEvent(i), je.copy(n.object.position), et.copy(n.object.quaternion), Ii = !1, !0) : !1;
      };
    })(), this.connect = (we) => {
      n.domElement = we, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", He), n.domElement.addEventListener("pointerdown", $e), n.domElement.addEventListener("pointercancel", Bt), n.domElement.addEventListener("wheel", jt);
    }, this.dispose = () => {
      var we, qe, de, it, je, et;
      n.domElement && (n.domElement.style.touchAction = "auto"), (we = n.domElement) == null || we.removeEventListener("contextmenu", He), (qe = n.domElement) == null || qe.removeEventListener("pointerdown", $e), (de = n.domElement) == null || de.removeEventListener("pointercancel", Bt), (it = n.domElement) == null || it.removeEventListener("wheel", jt), (je = n.domElement) == null || je.ownerDocument.removeEventListener("pointermove", Vt), (et = n.domElement) == null || et.ownerDocument.removeEventListener("pointerup", Bt), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", an);
    };
    const n = this, i = { type: "change" }, o = { type: "start" }, l = { type: "end" }, u = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let I = u.NONE;
    const C = 1e-6, f = new rX(), v = new rX();
    let b = 1;
    const S = new fe(), R = new Lt(), W = new Lt(), x = new Lt(), N = new Lt(), Y = new Lt(), F = new Lt(), T = new Lt(), P = new Lt(), D = new Lt(), L = new fe(), j = new Lt();
    let J = !1;
    const O = [], ne = {};
    function he() {
      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function pe() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function Ae(we) {
      n.reverseOrbit || n.reverseHorizontalOrbit ? v.theta += we : v.theta -= we;
    }
    function ke(we) {
      n.reverseOrbit || n.reverseVerticalOrbit ? v.phi += we : v.phi -= we;
    }
    const Re = (() => {
      const we = new fe();
      return function(de, it) {
        we.setFromMatrixColumn(it, 0), we.multiplyScalar(-de), S.add(we);
      };
    })(), Xe = (() => {
      const we = new fe();
      return function(de, it) {
        n.screenSpacePanning === !0 ? we.setFromMatrixColumn(it, 1) : (we.setFromMatrixColumn(it, 0), we.crossVectors(n.object.up, we)), we.multiplyScalar(de), S.add(we);
      };
    })(), re = (() => {
      const we = new fe();
      return function(de, it) {
        const je = n.domElement;
        if (je && n.object instanceof hl && n.object.isPerspectiveCamera) {
          const et = n.object.position;
          we.copy(et).sub(n.target);
          let Jt = we.length();
          Jt *= Math.tan(n.object.fov / 2 * Math.PI / 180), Re(2 * de * Jt / je.clientHeight, n.object.matrix), Xe(2 * it * Jt / je.clientHeight, n.object.matrix);
        } else je && n.object instanceof pv && n.object.isOrthographicCamera ? (Re(
          de * (n.object.right - n.object.left) / n.object.zoom / je.clientWidth,
          n.object.matrix
        ), Xe(
          it * (n.object.top - n.object.bottom) / n.object.zoom / je.clientHeight,
          n.object.matrix
        )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    })();
    function Se(we) {
      n.object instanceof hl && n.object.isPerspectiveCamera || n.object instanceof pv && n.object.isOrthographicCamera ? b = we : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function Be(we) {
      Se(b / we);
    }
    function le(we) {
      Se(b * we);
    }
    function Ye(we) {
      if (!n.zoomToCursor || !n.domElement)
        return;
      J = !0;
      const qe = n.domElement.getBoundingClientRect(), de = we.clientX - qe.left, it = we.clientY - qe.top, je = qe.width, et = qe.height;
      j.x = de / je * 2 - 1, j.y = -(it / et) * 2 + 1, L.set(j.x, j.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function nt(we) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, we));
    }
    function ze(we) {
      R.set(we.clientX, we.clientY);
    }
    function Je(we) {
      Ye(we), T.set(we.clientX, we.clientY);
    }
    function wt(we) {
      N.set(we.clientX, we.clientY);
    }
    function mt(we) {
      W.set(we.clientX, we.clientY), x.subVectors(W, R).multiplyScalar(n.rotateSpeed);
      const qe = n.domElement;
      qe && (Ae(2 * Math.PI * x.x / qe.clientHeight), ke(2 * Math.PI * x.y / qe.clientHeight)), R.copy(W), n.update();
    }
    function Dt(we) {
      P.set(we.clientX, we.clientY), D.subVectors(P, T), D.y > 0 ? Be(pe()) : D.y < 0 && le(pe()), T.copy(P), n.update();
    }
    function mn(we) {
      Y.set(we.clientX, we.clientY), F.subVectors(Y, N).multiplyScalar(n.panSpeed), re(F.x, F.y), N.copy(Y), n.update();
    }
    function An(we) {
      Ye(we), we.deltaY < 0 ? le(pe()) : we.deltaY > 0 && Be(pe()), n.update();
    }
    function Hn(we) {
      let qe = !1;
      switch (we.code) {
        case n.keys.UP:
          re(0, n.keyPanSpeed), qe = !0;
          break;
        case n.keys.BOTTOM:
          re(0, -n.keyPanSpeed), qe = !0;
          break;
        case n.keys.LEFT:
          re(n.keyPanSpeed, 0), qe = !0;
          break;
        case n.keys.RIGHT:
          re(-n.keyPanSpeed, 0), qe = !0;
          break;
      }
      qe && (we.preventDefault(), n.update());
    }
    function ge() {
      if (O.length == 1)
        R.set(O[0].pageX, O[0].pageY);
      else {
        const we = 0.5 * (O[0].pageX + O[1].pageX), qe = 0.5 * (O[0].pageY + O[1].pageY);
        R.set(we, qe);
      }
    }
    function Wt() {
      if (O.length == 1)
        N.set(O[0].pageX, O[0].pageY);
      else {
        const we = 0.5 * (O[0].pageX + O[1].pageX), qe = 0.5 * (O[0].pageY + O[1].pageY);
        N.set(we, qe);
      }
    }
    function Nt() {
      const we = O[0].pageX - O[1].pageX, qe = O[0].pageY - O[1].pageY, de = Math.sqrt(we * we + qe * qe);
      T.set(0, de);
    }
    function $t() {
      n.enableZoom && Nt(), n.enablePan && Wt();
    }
    function ft() {
      n.enableZoom && Nt(), n.enableRotate && ge();
    }
    function bn(we) {
      if (O.length == 1)
        W.set(we.pageX, we.pageY);
      else {
        const de = on(we), it = 0.5 * (we.pageX + de.x), je = 0.5 * (we.pageY + de.y);
        W.set(it, je);
      }
      x.subVectors(W, R).multiplyScalar(n.rotateSpeed);
      const qe = n.domElement;
      qe && (Ae(2 * Math.PI * x.x / qe.clientHeight), ke(2 * Math.PI * x.y / qe.clientHeight)), R.copy(W);
    }
    function en(we) {
      if (O.length == 1)
        Y.set(we.pageX, we.pageY);
      else {
        const qe = on(we), de = 0.5 * (we.pageX + qe.x), it = 0.5 * (we.pageY + qe.y);
        Y.set(de, it);
      }
      F.subVectors(Y, N).multiplyScalar(n.panSpeed), re(F.x, F.y), N.copy(Y);
    }
    function hn(we) {
      const qe = on(we), de = we.pageX - qe.x, it = we.pageY - qe.y, je = Math.sqrt(de * de + it * it);
      P.set(0, je), D.set(0, Math.pow(P.y / T.y, n.zoomSpeed)), Be(D.y), T.copy(P);
    }
    function me(we) {
      n.enableZoom && hn(we), n.enablePan && en(we);
    }
    function se(we) {
      n.enableZoom && hn(we), n.enableRotate && bn(we);
    }
    function $e(we) {
      var qe, de;
      n.enabled !== !1 && (O.length === 0 && ((qe = n.domElement) == null || qe.ownerDocument.addEventListener("pointermove", Vt), (de = n.domElement) == null || de.ownerDocument.addEventListener("pointerup", Bt)), vt(we), we.pointerType === "touch" ? jn(we) : Mt(we));
    }
    function Vt(we) {
      n.enabled !== !1 && (we.pointerType === "touch" ? Ot(we) : Gn(we));
    }
    function Bt(we) {
      var qe, de, it;
      xt(we), O.length === 0 && ((qe = n.domElement) == null || qe.releasePointerCapture(we.pointerId), (de = n.domElement) == null || de.ownerDocument.removeEventListener("pointermove", Vt), (it = n.domElement) == null || it.ownerDocument.removeEventListener("pointerup", Bt)), n.dispatchEvent(l), I = u.NONE;
    }
    function Mt(we) {
      let qe;
      switch (we.button) {
        case 0:
          qe = n.mouseButtons.LEFT;
          break;
        case 1:
          qe = n.mouseButtons.MIDDLE;
          break;
        case 2:
          qe = n.mouseButtons.RIGHT;
          break;
        default:
          qe = -1;
      }
      switch (qe) {
        case qy.DOLLY:
          if (n.enableZoom === !1)
            return;
          Je(we), I = u.DOLLY;
          break;
        case qy.ROTATE:
          if (we.ctrlKey || we.metaKey || we.shiftKey) {
            if (n.enablePan === !1)
              return;
            wt(we), I = u.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            ze(we), I = u.ROTATE;
          }
          break;
        case qy.PAN:
          if (we.ctrlKey || we.metaKey || we.shiftKey) {
            if (n.enableRotate === !1)
              return;
            ze(we), I = u.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            wt(we), I = u.PAN;
          }
          break;
        default:
          I = u.NONE;
      }
      I !== u.NONE && n.dispatchEvent(o);
    }
    function Gn(we) {
      if (n.enabled !== !1)
        switch (I) {
          case u.ROTATE:
            if (n.enableRotate === !1)
              return;
            mt(we);
            break;
          case u.DOLLY:
            if (n.enableZoom === !1)
              return;
            Dt(we);
            break;
          case u.PAN:
            if (n.enablePan === !1)
              return;
            mn(we);
            break;
        }
    }
    function jt(we) {
      n.enabled === !1 || n.enableZoom === !1 || I !== u.NONE && I !== u.ROTATE || (we.preventDefault(), n.dispatchEvent(o), An(we), n.dispatchEvent(l));
    }
    function an(we) {
      n.enabled === !1 || n.enablePan === !1 || Hn(we);
    }
    function jn(we) {
      switch (ht(we), O.length) {
        case 1:
          switch (n.touches.ONE) {
            case $y.ROTATE:
              if (n.enableRotate === !1)
                return;
              ge(), I = u.TOUCH_ROTATE;
              break;
            case $y.PAN:
              if (n.enablePan === !1)
                return;
              Wt(), I = u.TOUCH_PAN;
              break;
            default:
              I = u.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case $y.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              $t(), I = u.TOUCH_DOLLY_PAN;
              break;
            case $y.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              ft(), I = u.TOUCH_DOLLY_ROTATE;
              break;
            default:
              I = u.NONE;
          }
          break;
        default:
          I = u.NONE;
      }
      I !== u.NONE && n.dispatchEvent(o);
    }
    function Ot(we) {
      switch (ht(we), I) {
        case u.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          bn(we), n.update();
          break;
        case u.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          en(we), n.update();
          break;
        case u.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          me(we), n.update();
          break;
        case u.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          se(we), n.update();
          break;
        default:
          I = u.NONE;
      }
    }
    function He(we) {
      n.enabled !== !1 && we.preventDefault();
    }
    function vt(we) {
      O.push(we);
    }
    function xt(we) {
      delete ne[we.pointerId];
      for (let qe = 0; qe < O.length; qe++)
        if (O[qe].pointerId == we.pointerId) {
          O.splice(qe, 1);
          return;
        }
    }
    function ht(we) {
      let qe = ne[we.pointerId];
      qe === void 0 && (qe = new Lt(), ne[we.pointerId] = qe), qe.set(we.pageX, we.pageY);
    }
    function on(we) {
      const qe = we.pointerId === O[0].pointerId ? O[1] : O[0];
      return ne[qe.pointerId];
    }
    this.dollyIn = (we = pe()) => {
      le(we), n.update();
    }, this.dollyOut = (we = pe()) => {
      Be(we), n.update();
    }, this.getScale = () => b, this.setScale = (we) => {
      Se(we), n.update();
    }, this.getZoomScale = () => pe(), t !== void 0 && this.connect(t), this.update();
  }
};
function Rte(r, e, t) {
  const n = Jg((b) => b.size), i = Jg((b) => b.viewport), o = typeof r == "number" ? r : n.width * i.dpr, l = n.height * i.dpr, u = (typeof r == "number" ? t : r) || {}, {
    samples: I = 0,
    depth: C,
    ...f
  } = u, v = ye.useMemo(() => {
    const b = new QC(o, l, {
      minFilter: Ks,
      magFilter: Ks,
      type: Vb,
      ...f
    });
    return C && (b.depthTexture = new KW(o, l, ed)), b.samples = I, b;
  }, []);
  return ye.useLayoutEffect(() => {
    v.setSize(o, l), I && (v.samples = I);
  }, [I, v, o, l]), ye.useEffect(() => () => v.dispose(), []), v;
}
const xte = (r) => typeof r == "function", Wte = /* @__PURE__ */ ye.forwardRef(({
  envMap: r,
  resolution: e = 256,
  frames: t = 1 / 0,
  makeDefault: n,
  children: i,
  ...o
}, l) => {
  const u = Jg(({
    set: x
  }) => x), I = Jg(({
    camera: x
  }) => x), C = Jg(({
    size: x
  }) => x), f = ye.useRef(null);
  ye.useImperativeHandle(l, () => f.current, []);
  const v = ye.useRef(null), b = Rte(e);
  ye.useLayoutEffect(() => {
    o.manual || (f.current.aspect = C.width / C.height);
  }, [C, o]), ye.useLayoutEffect(() => {
    f.current.updateProjectionMatrix();
  });
  let S = 0, R = null;
  const W = xte(i);
  return cV((x) => {
    W && (t === 1 / 0 || S < t) && (v.current.visible = !1, x.gl.setRenderTarget(b), R = x.scene.background, r && (x.scene.background = r), x.gl.render(x.scene, f.current), x.scene.background = R, x.gl.setRenderTarget(null), v.current.visible = !0, S++);
  }), ye.useLayoutEffect(() => {
    if (n) {
      const x = I;
      return u(() => ({
        camera: f.current
      })), () => u(() => ({
        camera: x
      }));
    }
  }, [f, n, u]), /* @__PURE__ */ ye.createElement(ye.Fragment, null, /* @__PURE__ */ ye.createElement("perspectiveCamera", pw({
    ref: f
  }, o), !W && i), /* @__PURE__ */ ye.createElement("group", {
    ref: v
  }, W && i(b.texture)));
}), Vte = /* @__PURE__ */ ye.forwardRef(({
  makeDefault: r,
  camera: e,
  regress: t,
  domElement: n,
  enableDamping: i = !0,
  keyEvents: o = !1,
  onChange: l,
  onStart: u,
  onEnd: I,
  ...C
}, f) => {
  const v = Jg((D) => D.invalidate), b = Jg((D) => D.camera), S = Jg((D) => D.gl), R = Jg((D) => D.events), W = Jg((D) => D.setEvents), x = Jg((D) => D.set), N = Jg((D) => D.get), Y = Jg((D) => D.performance), F = e || b, T = n || R.connected || S.domElement, P = ye.useMemo(() => new wte(F), [F]);
  return cV(() => {
    P.enabled && P.update();
  }, -1), ye.useEffect(() => (o && P.connect(o === !0 ? T : o), P.connect(T), () => void P.dispose()), [o, T, t, P, v]), ye.useEffect(() => {
    const D = (J) => {
      v(), t && Y.regress(), l && l(J);
    }, L = (J) => {
      u && u(J);
    }, j = (J) => {
      I && I(J);
    };
    return P.addEventListener("change", D), P.addEventListener("start", L), P.addEventListener("end", j), () => {
      P.removeEventListener("start", L), P.removeEventListener("end", j), P.removeEventListener("change", D);
    };
  }, [l, u, I, P, v, W]), ye.useEffect(() => {
    if (r) {
      const D = N().controls;
      return x({
        controls: P
      }), () => x({
        controls: D
      });
    }
  }, [r, P]), /* @__PURE__ */ ye.createElement("primitive", pw({
    ref: f,
    object: P,
    enableDamping: i
  }, C));
});
function Nte(r, e) {
  const t = r + "Geometry";
  return /* @__PURE__ */ ye.forwardRef(({
    args: n,
    children: i,
    ...o
  }, l) => {
    const u = ye.useRef(null);
    return ye.useImperativeHandle(l, () => u.current), ye.useLayoutEffect(() => void e?.(u.current)), /* @__PURE__ */ ye.createElement("mesh", pw({
      ref: u
    }, o), /* @__PURE__ */ ye.createElement(t, {
      attach: "geometry",
      args: n
    }), i);
  });
}
const Mte = /* @__PURE__ */ Nte("box");
var dv = /* @__PURE__ */ ((r) => (r.EN = "en", r.ZH = "zh", r))(dv || {}), id = /* @__PURE__ */ ((r) => (r.DEFAULT = "default", r.DARK = "dark", r.LIGHT = "light", r))(id || {}), sg = /* @__PURE__ */ ((r) => (r.JAN = "Jan.", r.FEB = "Feb.", r.MAR = "Mar.", r.APR = "Apr.", r.MAY = "May.", r.JUN = "Jun.", r.JUL = "Jul.", r.AUG = "Aug.", r.SEP = "Sep.", r.OCT = "Oct.", r.NOV = "Nov.", r.DEC = "Dec.", r))(sg || {}), lg = /* @__PURE__ */ ((r) => (r.HOME = "/", r.ABOUT = "/about", r.EXPERIENCE = "/experience", r.PROJECTS = "/projects", r.LINKS = "/links", r))(lg || {});
const AB = 575, Tw = {
  lang: "randyweb_lang",
  theme: "randyweb_theme"
}, Ji = {
  // 
  nativeJS: { name: "NativeJS", value: "nativejs" },
  typescript: { name: "TypeScript", value: "typescript" },
  nodeJS: { name: "Node.js", value: "nodejs" },
  python: { name: "Python", value: "python" },
  java: { name: "Java", value: "java" },
  htmlscss: { name: "HTML & SCSS", value: "htmlscss" },
  // 
  react: { name: "React", value: "react" },
  next: { name: "Next", value: "next" },
  express: { name: "Express.js", value: "express" },
  tailwind: { name: "TailwindCSS", value: "tailwindcss" },
  // 
  vite: { name: "Vite", value: "vite" },
  // 
  jest: { name: "Jest", value: "jest" },
  e2e: { name: "e2eTesting", value: "e2etesting" },
  // 
  webRTC: { name: "WebRTC", value: "webrtc" },
  websocket: { name: "WebSocket", value: "websocket" },
  webAudio: { name: "WebAudio", value: "webaudio" },
  canvas: { name: "Canvas", value: "canvas" },
  glsl: { name: "GLSL", value: "glsl" },
  three: { name: "Three.js", value: "three" },
  i18n: { name: "i18n", value: "i18n" }
}, KY = [
  { url: lg.ABOUT, title: "nav_about" },
  { url: lg.EXPERIENCE, title: "nav_experience" },
  { url: lg.PROJECTS, title: "nav_projects" },
  { url: lg.LINKS, title: "nav_links" }
], rW = [id.DEFAULT, id.DARK, id.LIGHT], ow = [dv.EN, dv.ZH], LY = () => {
  const r = window.document.documentElement;
  let e = localStorage.getItem(Tw.theme);
  return (!e || !rW.includes(e)) && (e = id.DEFAULT, localStorage.setItem(Tw.theme, e)), r.classList.contains(e) || r.classList.add(e), e;
}, s9 = ye.createContext(LY()), l9 = ye.createContext({ width: window.innerWidth }), Hte = ({ className: r, children: e }) => {
  const [t, n] = ye.useState(LY()), [i, o] = ye.useState({ width: window.innerWidth });
  return ye.useEffect(() => {
    const l = () => {
      o({ width: window.innerWidth });
    };
    return window.addEventListener("resize", l), () => window.removeEventListener("resize", l);
  }, []), ye.useEffect(() => {
    const l = ({ detail: { theme: u } }) => {
      n(u);
    };
    return window.addEventListener("change-theme", l), () => window.removeEventListener("change-theme", l);
  }, []), /* @__PURE__ */ We.jsx(s9.Provider, { value: t, children: /* @__PURE__ */ We.jsx(l9.Provider, { value: i, children: /* @__PURE__ */ We.jsxs("div", { className: "main-layout", children: [
    /* @__PURE__ */ We.jsx("div", { className: "main-layout_frame" }),
    /* @__PURE__ */ We.jsx("div", { className: r, children: e })
  ] }) }) });
}, Xte = () => wc.useContext(s9), Yb = () => wc.useContext(l9);
var kY = { exports: {} }, uB = typeof Reflect == "object" ? Reflect : null, k5 = uB && typeof uB.apply == "function" ? uB.apply : function(e, t, n) {
  return Function.prototype.apply.call(e, t, n);
}, C2;
uB && typeof uB.ownKeys == "function" ? C2 = uB.ownKeys : Object.getOwnPropertySymbols ? C2 = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : C2 = function(e) {
  return Object.getOwnPropertyNames(e);
};
function Yte(r) {
  console && console.warn && console.warn(r);
}
var u9 = Number.isNaN || function(e) {
  return e !== e;
};
function qa() {
  qa.init.call(this);
}
kY.exports = qa;
kY.exports.once = _te;
qa.EventEmitter = qa;
qa.prototype._events = void 0;
qa.prototype._eventsCount = 0;
qa.prototype._maxListeners = void 0;
var D5 = 10;
function gV(r) {
  if (typeof r != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
}
Object.defineProperty(qa, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return D5;
  },
  set: function(r) {
    if (typeof r != "number" || r < 0 || u9(r))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
    D5 = r;
  }
});
qa.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
qa.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || u9(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function c9(r) {
  return r._maxListeners === void 0 ? qa.defaultMaxListeners : r._maxListeners;
}
qa.prototype.getMaxListeners = function() {
  return c9(this);
};
qa.prototype.emit = function(e) {
  for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
  var i = e === "error", o = this._events;
  if (o !== void 0)
    i = i && o.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var l;
    if (t.length > 0 && (l = t[0]), l instanceof Error)
      throw l;
    var u = new Error("Unhandled error." + (l ? " (" + l.message + ")" : ""));
    throw u.context = l, u;
  }
  var I = o[e];
  if (I === void 0)
    return !1;
  if (typeof I == "function")
    k5(I, this, t);
  else
    for (var C = I.length, f = h9(I, C), n = 0; n < C; ++n)
      k5(f[n], this, t);
  return !0;
};
function g9(r, e, t, n) {
  var i, o, l;
  if (gV(t), o = r._events, o === void 0 ? (o = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (o.newListener !== void 0 && (r.emit(
    "newListener",
    e,
    t.listener ? t.listener : t
  ), o = r._events), l = o[e]), l === void 0)
    l = o[e] = t, ++r._eventsCount;
  else if (typeof l == "function" ? l = o[e] = n ? [t, l] : [l, t] : n ? l.unshift(t) : l.push(t), i = c9(r), i > 0 && l.length > i && !l.warned) {
    l.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + l.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = r, u.type = e, u.count = l.length, Yte(u);
  }
  return r;
}
qa.prototype.addListener = function(e, t) {
  return g9(this, e, t, !1);
};
qa.prototype.on = qa.prototype.addListener;
qa.prototype.prependListener = function(e, t) {
  return g9(this, e, t, !0);
};
function Fte() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function d9(r, e, t) {
  var n = { fired: !1, wrapFn: void 0, target: r, type: e, listener: t }, i = Fte.bind(n);
  return i.listener = t, n.wrapFn = i, i;
}
qa.prototype.once = function(e, t) {
  return gV(t), this.on(e, d9(this, e, t)), this;
};
qa.prototype.prependOnceListener = function(e, t) {
  return gV(t), this.prependListener(e, d9(this, e, t)), this;
};
qa.prototype.removeListener = function(e, t) {
  var n, i, o, l, u;
  if (gV(t), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === t || n.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
  else if (typeof n != "function") {
    for (o = -1, l = n.length - 1; l >= 0; l--)
      if (n[l] === t || n[l].listener === t) {
        u = n[l].listener, o = l;
        break;
      }
    if (o < 0)
      return this;
    o === 0 ? n.shift() : Ete(n, o), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, u || t);
  }
  return this;
};
qa.prototype.off = qa.prototype.removeListener;
qa.prototype.removeAllListeners = function(e) {
  var t, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var o = Object.keys(n), l;
    for (i = 0; i < o.length; ++i)
      l = o[i], l !== "removeListener" && this.removeAllListeners(l);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = n[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (i = t.length - 1; i >= 0; i--)
      this.removeListener(e, t[i]);
  return this;
};
function I9(r, e, t) {
  var n = r._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? Tte(i) : h9(i, i.length);
}
qa.prototype.listeners = function(e) {
  return I9(this, e, !0);
};
qa.prototype.rawListeners = function(e) {
  return I9(this, e, !1);
};
qa.listenerCount = function(r, e) {
  return typeof r.listenerCount == "function" ? r.listenerCount(e) : C9.call(r, e);
};
qa.prototype.listenerCount = C9;
function C9(r) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[r];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
qa.prototype.eventNames = function() {
  return this._eventsCount > 0 ? C2(this._events) : [];
};
function h9(r, e) {
  for (var t = new Array(e), n = 0; n < e; ++n)
    t[n] = r[n];
  return t;
}
function Ete(r, e) {
  for (; e + 1 < r.length; e++)
    r[e] = r[e + 1];
  r.pop();
}
function Tte(r) {
  for (var e = new Array(r.length), t = 0; t < e.length; ++t)
    e[t] = r[t].listener || r[t];
  return e;
}
function _te(r, e) {
  return new Promise(function(t, n) {
    function i(l) {
      r.removeListener(e, o), n(l);
    }
    function o() {
      typeof r.removeListener == "function" && r.removeListener("error", i), t([].slice.call(arguments));
    }
    f9(r, e, o, { once: !0 }), e !== "error" && zte(r, i, { once: !0 });
  });
}
function zte(r, e, t) {
  typeof r.on == "function" && f9(r, "error", e, t);
}
function f9(r, e, t, n) {
  if (typeof r.on == "function")
    n.once ? r.once(e, t) : r.on(e, t);
  else if (typeof r.addEventListener == "function")
    r.addEventListener(e, function i(o) {
      n.once && r.removeEventListener(e, i), t(o);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r);
}
var Kte = kY.exports;
function Lte(r, e) {
  var t = atob(r);
  if (e) {
    for (var n = new Uint8Array(t.length), i = 0, o = t.length; i < o; ++i)
      n[i] = t.charCodeAt(i);
    return String.fromCharCode.apply(null, new Uint16Array(n.buffer));
  }
  return t;
}
function kte(r, e, t) {
  var n = e === void 0 ? null : e, i = t === void 0 ? !1 : t, o = Lte(r, i), l = o.indexOf(`
`, 10) + 1, u = o.substring(l) + (n ? "//# sourceMappingURL=" + n : ""), I = new Blob([u], { type: "application/javascript" });
  return URL.createObjectURL(I);
}
function Dte(r, e, t) {
  var n;
  return function(o) {
    return n = n || kte(r, e, t), new Worker(n, o);
  };
}
var Ute = Dte("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogUmVjb3JkcyB3aGF0IG9iamVjdHMgYXJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXIKICAgKi8KCiAgLyoqCiAgICogQSAzeDMgbWF0cml4LgogICAqIEF1dGhvcmVkIGJ5IHtAbGluayBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS8gc2NodGVwcGV9CiAgICovCiAgY2xhc3MgTWF0MyB7CiAgICAvKioKICAgICAqIEEgdmVjdG9yIG9mIGxlbmd0aCA5LCBjb250YWluaW5nIGFsbCBtYXRyaXggZWxlbWVudHMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEBwYXJhbSBlbGVtZW50cyBBIHZlY3RvciBvZiBsZW5ndGggOSwgY29udGFpbmluZyBhbGwgbWF0cml4IGVsZW1lbnRzLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykgewogICAgICBpZiAoZWxlbWVudHMgPT09IHZvaWQgMCkgewogICAgICAgIGVsZW1lbnRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdOwogICAgICB9CgogICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdGhlIG1hdHJpeCB0byBpZGVudGl0eQogICAgICogQHRvZG8gU2hvdWxkIHBlcmhhcHMgYmUgcmVuYW1lZCB0byBgc2V0SWRlbnRpdHkoKWAgdG8gYmUgbW9yZSBjbGVhci4KICAgICAqIEB0b2RvIENyZWF0ZSBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgaW1tZWRpYXRlbHkgY3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXggZWcuIGBleWUoKWAKICAgICAqLwoKCiAgICBpZGVudGl0eSgpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGVbMF0gPSAxOwogICAgICBlWzFdID0gMDsKICAgICAgZVsyXSA9IDA7CiAgICAgIGVbM10gPSAwOwogICAgICBlWzRdID0gMTsKICAgICAgZVs1XSA9IDA7CiAgICAgIGVbNl0gPSAwOwogICAgICBlWzddID0gMDsKICAgICAgZVs4XSA9IDE7CiAgICB9CiAgICAvKioKICAgICAqIFNldCBhbGwgZWxlbWVudHMgdG8gemVybwogICAgICovCgoKICAgIHNldFplcm8oKSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzOwogICAgICBlWzBdID0gMDsKICAgICAgZVsxXSA9IDA7CiAgICAgIGVbMl0gPSAwOwogICAgICBlWzNdID0gMDsKICAgICAgZVs0XSA9IDA7CiAgICAgIGVbNV0gPSAwOwogICAgICBlWzZdID0gMDsKICAgICAgZVs3XSA9IDA7CiAgICAgIGVbOF0gPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHMgZnJvbSBhIFZlYzMKICAgICAqLwoKCiAgICBzZXRUcmFjZSh2ZWN0b3IpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGVbMF0gPSB2ZWN0b3IueDsKICAgICAgZVs0XSA9IHZlY3Rvci55OwogICAgICBlWzhdID0gdmVjdG9yLno7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIG1hdHJpeCBkaWFnb25hbCBlbGVtZW50cwogICAgICovCgoKICAgIGdldFRyYWNlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgdGFyZ2V0LnggPSBlWzBdOwogICAgICB0YXJnZXQueSA9IGVbNF07CiAgICAgIHRhcmdldC56ID0gZVs4XTsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTWF0cml4LVZlY3RvciBtdWx0aXBsaWNhdGlvbgogICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLCB0YXJnZXQgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLgogICAgICovCgoKICAgIHZtdWx0KHYsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgY29uc3QgeCA9IHYueDsKICAgICAgY29uc3QgeSA9IHYueTsKICAgICAgY29uc3QgeiA9IHYuejsKICAgICAgdGFyZ2V0LnggPSBlWzBdICogeCArIGVbMV0gKiB5ICsgZVsyXSAqIHo7CiAgICAgIHRhcmdldC55ID0gZVszXSAqIHggKyBlWzRdICogeSArIGVbNV0gKiB6OwogICAgICB0YXJnZXQueiA9IGVbNl0gKiB4ICsgZVs3XSAqIHkgKyBlWzhdICogejsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTWF0cml4LXNjYWxhciBtdWx0aXBsaWNhdGlvbgogICAgICovCgoKICAgIHNtdWx0KHMpIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSAqPSBzOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIE1hdHJpeCBtdWx0aXBsaWNhdGlvbgogICAgICogQHBhcmFtIG1hdHJpeCBNYXRyaXggdG8gbXVsdGlwbHkgd2l0aCBmcm9tIGxlZnQgc2lkZS4KICAgICAqLwoKCiAgICBtbXVsdChtYXRyaXgsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgTWF0MygpOwogICAgICB9CgogICAgICBjb25zdCBBID0gdGhpcy5lbGVtZW50czsKICAgICAgY29uc3QgQiA9IG1hdHJpeC5lbGVtZW50czsKICAgICAgY29uc3QgVCA9IHRhcmdldC5lbGVtZW50czsKICAgICAgY29uc3QgYTExID0gQVswXSwKICAgICAgICAgICAgYTEyID0gQVsxXSwKICAgICAgICAgICAgYTEzID0gQVsyXSwKICAgICAgICAgICAgYTIxID0gQVszXSwKICAgICAgICAgICAgYTIyID0gQVs0XSwKICAgICAgICAgICAgYTIzID0gQVs1XSwKICAgICAgICAgICAgYTMxID0gQVs2XSwKICAgICAgICAgICAgYTMyID0gQVs3XSwKICAgICAgICAgICAgYTMzID0gQVs4XTsKICAgICAgY29uc3QgYjExID0gQlswXSwKICAgICAgICAgICAgYjEyID0gQlsxXSwKICAgICAgICAgICAgYjEzID0gQlsyXSwKICAgICAgICAgICAgYjIxID0gQlszXSwKICAgICAgICAgICAgYjIyID0gQls0XSwKICAgICAgICAgICAgYjIzID0gQls1XSwKICAgICAgICAgICAgYjMxID0gQls2XSwKICAgICAgICAgICAgYjMyID0gQls3XSwKICAgICAgICAgICAgYjMzID0gQls4XTsKICAgICAgVFswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTsKICAgICAgVFsxXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjsKICAgICAgVFsyXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMzsKICAgICAgVFszXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTsKICAgICAgVFs0XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMjsKICAgICAgVFs1XSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMzsKICAgICAgVFs2XSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMTsKICAgICAgVFs3XSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjsKICAgICAgVFs4XSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMzsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogU2NhbGUgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeAogICAgICovCgoKICAgIHNjYWxlKHZlY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBNYXQzKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzOwogICAgICBjb25zdCB0ID0gdGFyZ2V0LmVsZW1lbnRzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDM7IGkrKykgewogICAgICAgIHRbMyAqIGkgKyAwXSA9IHZlY3Rvci54ICogZVszICogaSArIDBdOwogICAgICAgIHRbMyAqIGkgKyAxXSA9IHZlY3Rvci55ICogZVszICogaSArIDFdOwogICAgICAgIHRbMyAqIGkgKyAyXSA9IHZlY3Rvci56ICogZVszICogaSArIDJdOwogICAgICB9CgogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTb2x2ZSBBeD1iCiAgICAgKiBAcGFyYW0gYiBUaGUgcmlnaHQgaGFuZCBzaWRlCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdmVjdG9yIHRvIHNhdmUgaW4uCiAgICAgKiBAcmV0dXJuIFRoZSBzb2x1dGlvbiB4CiAgICAgKiBAdG9kbyBzaG91bGQgcmV1c2UgYXJyYXlzCiAgICAgKi8KCgogICAgc29sdmUoYiwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnMKICAgICAgY29uc3QgbnIgPSAzOyAvLyBudW0gcm93cwoKICAgICAgY29uc3QgbmMgPSA0OyAvLyBudW0gY29scwoKICAgICAgY29uc3QgZXFucyA9IFtdOwogICAgICBsZXQgaTsKICAgICAgbGV0IGo7CgogICAgICBmb3IgKGkgPSAwOyBpIDwgbnIgKiBuYzsgaSsrKSB7CiAgICAgICAgZXFucy5wdXNoKDApOwogICAgICB9CgogICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7CiAgICAgICAgZm9yIChqID0gMDsgaiA8IDM7IGorKykgewogICAgICAgICAgZXFuc1tpICsgbmMgKiBqXSA9IHRoaXMuZWxlbWVudHNbaSArIDMgKiBqXTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGVxbnNbMyArIDQgKiAwXSA9IGIueDsKICAgICAgZXFuc1szICsgNCAqIDFdID0gYi55OwogICAgICBlcW5zWzMgKyA0ICogMl0gPSBiLno7IC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvbgoKICAgICAgbGV0IG4gPSAzOwogICAgICBjb25zdCBrID0gbjsKICAgICAgbGV0IG5wOwogICAgICBjb25zdCBrcCA9IDQ7IC8vIG51bSByb3dzCgogICAgICBsZXQgcDsKCiAgICAgIGRvIHsKICAgICAgICBpID0gayAtIG47CgogICAgICAgIGlmIChlcW5zW2kgKyBuYyAqIGldID09PSAwKSB7CiAgICAgICAgICAvLyB0aGUgcGl2b3QgaXMgbnVsbCwgc3dhcCBsaW5lcwogICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHsKICAgICAgICAgICAgaWYgKGVxbnNbaSArIG5jICogal0gIT09IDApIHsKICAgICAgICAgICAgICBucCA9IGtwOwoKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAvLyBkbyBsaWduZSggaSApID0gbGlnbmUoIGkgKSArIGxpZ25lKCBrICkKICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wOwogICAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBpXSArPSBlcW5zW3AgKyBuYyAqIGpdOwogICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApOwoKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKGVxbnNbaSArIG5jICogaV0gIT09IDApIHsKICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7CiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBlcW5zW2kgKyBuYyAqIGpdIC8gZXFuc1tpICsgbmMgKiBpXTsKICAgICAgICAgICAgbnAgPSBrcDsKCiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAvLyBkbyBsaWduZSggayApID0gbGlnbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaWduZSggaSApCiAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7CiAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3AgKyBuYyAqIGpdIC0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSB3aGlsZSAoLS1uKTsgLy8gR2V0IHRoZSBzb2x1dGlvbgoKCiAgICAgIHRhcmdldC56ID0gZXFuc1syICogbmMgKyAzXSAvIGVxbnNbMiAqIG5jICsgMl07CiAgICAgIHRhcmdldC55ID0gKGVxbnNbMSAqIG5jICsgM10gLSBlcW5zWzEgKiBuYyArIDJdICogdGFyZ2V0LnopIC8gZXFuc1sxICogbmMgKyAxXTsKICAgICAgdGFyZ2V0LnggPSAoZXFuc1swICogbmMgKyAzXSAtIGVxbnNbMCAqIG5jICsgMl0gKiB0YXJnZXQueiAtIGVxbnNbMCAqIG5jICsgMV0gKiB0YXJnZXQueSkgLyBlcW5zWzAgKiBuYyArIDBdOwoKICAgICAgaWYgKGlzTmFOKHRhcmdldC54KSB8fCBpc05hTih0YXJnZXQueSkgfHwgaXNOYU4odGFyZ2V0LnopIHx8IHRhcmdldC54ID09PSBJbmZpbml0eSB8fCB0YXJnZXQueSA9PT0gSW5maW5pdHkgfHwgdGFyZ2V0LnogPT09IEluZmluaXR5KSB7CiAgICAgICAgdGhyb3cgYENvdWxkIG5vdCBzb2x2ZSBlcXVhdGlvbiEgR290IHg9WyR7dGFyZ2V0LnRvU3RyaW5nKCl9XSwgYj1bJHtiLnRvU3RyaW5nKCl9XSwgQT1bJHt0aGlzLnRvU3RyaW5nKCl9XWA7CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBlbGVtZW50IGluIHRoZSBtYXRyaXggYnkgaW5kZXguIEluZGV4IHN0YXJ0cyBhdCAwLCBub3QgMSEhIQogICAgICogQHBhcmFtIHZhbHVlIElmIHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnQgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS4KICAgICAqLwoKCiAgICBlKHJvdywgY29sdW1uLCB2YWx1ZSkgewogICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgewogICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW2NvbHVtbiArIDMgKiByb3ddOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFNldCB2YWx1ZQogICAgICAgIHRoaXMuZWxlbWVudHNbY29sdW1uICsgMyAqIHJvd10gPSB2YWx1ZTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDb3B5IGFub3RoZXIgbWF0cml4IGludG8gdGhpcyBtYXRyaXggb2JqZWN0LgogICAgICovCgoKICAgIGNvcHkobWF0cml4KSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IG1hdHJpeC5lbGVtZW50c1tpXTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeC4KICAgICAqLwoKCiAgICB0b1N0cmluZygpIHsKICAgICAgbGV0IHIgPSAnJzsKICAgICAgY29uc3Qgc2VwID0gJywnOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHsKICAgICAgICByICs9IHRoaXMuZWxlbWVudHNbaV0gKyBzZXA7CiAgICAgIH0KCiAgICAgIHJldHVybiByOwogICAgfQogICAgLyoqCiAgICAgKiByZXZlcnNlIHRoZSBtYXRyaXgKICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IG1hdHJpeCB0byBzYXZlIGluLgogICAgICogQHJldHVybiBUaGUgc29sdXRpb24geAogICAgICovCgoKICAgIHJldmVyc2UodGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBNYXQzKCk7CiAgICAgIH0KCiAgICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnMKICAgICAgY29uc3QgbnIgPSAzOyAvLyBudW0gcm93cwoKICAgICAgY29uc3QgbmMgPSA2OyAvLyBudW0gY29scwoKICAgICAgY29uc3QgZXFucyA9IHJldmVyc2VfZXFuczsKICAgICAgbGV0IGk7CiAgICAgIGxldCBqOwoKICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykgewogICAgICAgIGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHsKICAgICAgICAgIGVxbnNbaSArIG5jICogal0gPSB0aGlzLmVsZW1lbnRzW2kgKyAzICogal07CiAgICAgICAgfQogICAgICB9CgogICAgICBlcW5zWzMgKyA2ICogMF0gPSAxOwogICAgICBlcW5zWzMgKyA2ICogMV0gPSAwOwogICAgICBlcW5zWzMgKyA2ICogMl0gPSAwOwogICAgICBlcW5zWzQgKyA2ICogMF0gPSAwOwogICAgICBlcW5zWzQgKyA2ICogMV0gPSAxOwogICAgICBlcW5zWzQgKyA2ICogMl0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMF0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMV0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMl0gPSAxOyAvLyBDb21wdXRlIHJpZ2h0IHVwcGVyIHRyaWFuZ3VsYXIgdmVyc2lvbiBvZiB0aGUgbWF0cml4IC0gR2F1c3MgZWxpbWluYXRpb24KCiAgICAgIGxldCBuID0gMzsKICAgICAgY29uc3QgayA9IG47CiAgICAgIGxldCBucDsKICAgICAgY29uc3Qga3AgPSBuYzsgLy8gbnVtIHJvd3MKCiAgICAgIGxldCBwOwoKICAgICAgZG8gewogICAgICAgIGkgPSBrIC0gbjsKCiAgICAgICAgaWYgKGVxbnNbaSArIG5jICogaV0gPT09IDApIHsKICAgICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzCiAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykgewogICAgICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBqXSAhPT0gMCkgewogICAgICAgICAgICAgIG5wID0ga3A7CgogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIC8vIGRvIGxpbmUoIGkgKSA9IGxpbmUoIGkgKSArIGxpbmUoIGsgKQogICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7CiAgICAgICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGldICs9IGVxbnNbcCArIG5jICogal07CiAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CgogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBpXSAhPT0gMCkgewogICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHsKICAgICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldOwogICAgICAgICAgICBucCA9IGtwOwoKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIC8vIGRvIGxpbmUoIGsgKSA9IGxpbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaW5lKCBpICkKICAgICAgICAgICAgICBwID0ga3AgLSBucDsKICAgICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGpdID0gcCA8PSBpID8gMCA6IGVxbnNbcCArIG5jICogal0gLSBlcW5zW3AgKyBuYyAqIGldICogbXVsdGlwbGllcjsKICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IHdoaWxlICgtLW4pOyAvLyBlbGltaW5hdGUgdGhlIHVwcGVyIGxlZnQgdHJpYW5nbGUgb2YgdGhlIG1hdHJpeAoKCiAgICAgIGkgPSAyOwoKICAgICAgZG8gewogICAgICAgIGogPSBpIC0gMTsKCiAgICAgICAgZG8gewogICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldOwogICAgICAgICAgbnAgPSBuYzsKCiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHAgPSBuYyAtIG5wOwogICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGpdID0gZXFuc1twICsgbmMgKiBqXSAtIGVxbnNbcCArIG5jICogaV0gKiBtdWx0aXBsaWVyOwogICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgICAgfSB3aGlsZSAoai0tKTsKICAgICAgfSB3aGlsZSAoLS1pKTsgLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGlhZ29uYWwKCgogICAgICBpID0gMjsKCiAgICAgIGRvIHsKICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gMSAvIGVxbnNbaSArIG5jICogaV07CiAgICAgICAgbnAgPSBuYzsKCiAgICAgICAgZG8gewogICAgICAgICAgcCA9IG5jIC0gbnA7CiAgICAgICAgICBlcW5zW3AgKyBuYyAqIGldID0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7CiAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgIH0gd2hpbGUgKGktLSk7CgogICAgICBpID0gMjsKCiAgICAgIGRvIHsKICAgICAgICBqID0gMjsKCiAgICAgICAgZG8gewogICAgICAgICAgcCA9IGVxbnNbbnIgKyBqICsgbmMgKiBpXTsKCiAgICAgICAgICBpZiAoaXNOYU4ocCkgfHwgcCA9PT0gSW5maW5pdHkpIHsKICAgICAgICAgICAgdGhyb3cgYENvdWxkIG5vdCByZXZlcnNlISBBPVske3RoaXMudG9TdHJpbmcoKX1dYDsKICAgICAgICAgIH0KCiAgICAgICAgICB0YXJnZXQuZShpLCBqLCBwKTsKICAgICAgICB9IHdoaWxlIChqLS0pOwogICAgICB9IHdoaWxlIChpLS0pOwoKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBtYXRyaXggZnJvbSBhIHF1YXRlcmlvbgogICAgICovCgoKICAgIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSkgewogICAgICBjb25zdCB4ID0gcS54OwogICAgICBjb25zdCB5ID0gcS55OwogICAgICBjb25zdCB6ID0gcS56OwogICAgICBjb25zdCB3ID0gcS53OwogICAgICBjb25zdCB4MiA9IHggKyB4OwogICAgICBjb25zdCB5MiA9IHkgKyB5OwogICAgICBjb25zdCB6MiA9IHogKyB6OwogICAgICBjb25zdCB4eCA9IHggKiB4MjsKICAgICAgY29uc3QgeHkgPSB4ICogeTI7CiAgICAgIGNvbnN0IHh6ID0geCAqIHoyOwogICAgICBjb25zdCB5eSA9IHkgKiB5MjsKICAgICAgY29uc3QgeXogPSB5ICogejI7CiAgICAgIGNvbnN0IHp6ID0geiAqIHoyOwogICAgICBjb25zdCB3eCA9IHcgKiB4MjsKICAgICAgY29uc3Qgd3kgPSB3ICogeTI7CiAgICAgIGNvbnN0IHd6ID0gdyAqIHoyOwogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgZVszICogMCArIDBdID0gMSAtICh5eSArIHp6KTsKICAgICAgZVszICogMCArIDFdID0geHkgLSB3ejsKICAgICAgZVszICogMCArIDJdID0geHogKyB3eTsKICAgICAgZVszICogMSArIDBdID0geHkgKyB3ejsKICAgICAgZVszICogMSArIDFdID0gMSAtICh4eCArIHp6KTsKICAgICAgZVszICogMSArIDJdID0geXogLSB3eDsKICAgICAgZVszICogMiArIDBdID0geHogLSB3eTsKICAgICAgZVszICogMiArIDFdID0geXogKyB3eDsKICAgICAgZVszICogMiArIDJdID0gMSAtICh4eCArIHl5KTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFRyYW5zcG9zZSB0aGUgbWF0cml4CiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLiBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0LgogICAgICogQHJldHVybiBUaGUgdGFyZ2V0IE1hdDMsIG9yIGEgbmV3IE1hdDMgaWYgdGFyZ2V0IHdhcyBvbWl0dGVkLgogICAgICovCgoKICAgIHRyYW5zcG9zZSh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IE1hdDMoKTsKICAgICAgfQoKICAgICAgY29uc3QgTSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGNvbnN0IFQgPSB0YXJnZXQuZWxlbWVudHM7CiAgICAgIGxldCB0bXA7IC8vU2V0IGRpYWdvbmFscwoKICAgICAgVFswXSA9IE1bMF07CiAgICAgIFRbNF0gPSBNWzRdOwogICAgICBUWzhdID0gTVs4XTsKICAgICAgdG1wID0gTVsxXTsKICAgICAgVFsxXSA9IE1bM107CiAgICAgIFRbM10gPSB0bXA7CiAgICAgIHRtcCA9IE1bMl07CiAgICAgIFRbMl0gPSBNWzZdOwogICAgICBUWzZdID0gdG1wOwogICAgICB0bXAgPSBNWzVdOwogICAgICBUWzVdID0gTVs3XTsKICAgICAgVFs3XSA9IHRtcDsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KCiAgfQogIGNvbnN0IHJldmVyc2VfZXFucyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTsKCiAgLyoqCiAgICogMy1kaW1lbnNpb25hbCB2ZWN0b3IKICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCB2ID0gbmV3IFZlYzMoMSwgMiwgMykKICAgKiAgICAgY29uc29sZS5sb2coJ3g9JyArIHYueCkgLy8geD0xCiAgICovCgogIGNsYXNzIFZlYzMgewogICAgY29uc3RydWN0b3IoeCwgeSwgeikgewogICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7CiAgICAgICAgeCA9IDAuMDsKICAgICAgfQoKICAgICAgaWYgKHkgPT09IHZvaWQgMCkgewogICAgICAgIHkgPSAwLjA7CiAgICAgIH0KCiAgICAgIGlmICh6ID09PSB2b2lkIDApIHsKICAgICAgICB6ID0gMC4wOwogICAgICB9CgogICAgICB0aGlzLnggPSB4OwogICAgICB0aGlzLnkgPSB5OwogICAgICB0aGlzLnogPSB6OwogICAgfQogICAgLyoqCiAgICAgKiBWZWN0b3IgY3Jvc3MgcHJvZHVjdAogICAgICogQHBhcmFtIHRhcmdldCBPcHRpb25hbCB0YXJnZXQgdG8gc2F2ZSBpbi4KICAgICAqLwoKCiAgICBjcm9zcyh2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB2eCA9IHZlY3Rvci54OwogICAgICBjb25zdCB2eSA9IHZlY3Rvci55OwogICAgICBjb25zdCB2eiA9IHZlY3Rvci56OwogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICB0YXJnZXQueCA9IHkgKiB2eiAtIHogKiB2eTsKICAgICAgdGFyZ2V0LnkgPSB6ICogdnggLSB4ICogdno7CiAgICAgIHRhcmdldC56ID0geCAqIHZ5IC0geSAqIHZ4OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHZlY3RvcnMnIDMgZWxlbWVudHMKICAgICAqLwoKCiAgICBzZXQoeCwgeSwgeikgewogICAgICB0aGlzLnggPSB4OwogICAgICB0aGlzLnkgPSB5OwogICAgICB0aGlzLnogPSB6OwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogU2V0IGFsbCBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3IgdG8gemVyby4KICAgICAqLwoKCiAgICBzZXRaZXJvKCkgewogICAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLnogPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBWZWN0b3IgYWRkaXRpb24KICAgICAqLwoKCiAgICB2YWRkKHZlY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQpIHsKICAgICAgICB0YXJnZXQueCA9IHZlY3Rvci54ICsgdGhpcy54OwogICAgICAgIHRhcmdldC55ID0gdmVjdG9yLnkgKyB0aGlzLnk7CiAgICAgICAgdGFyZ2V0LnogPSB2ZWN0b3IueiArIHRoaXMuejsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54ICsgdmVjdG9yLngsIHRoaXMueSArIHZlY3Rvci55LCB0aGlzLnogKyB2ZWN0b3Iueik7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVmVjdG9yIHN1YnRyYWN0aW9uCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluLgogICAgICovCgoKICAgIHZzdWIodmVjdG9yLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCkgewogICAgICAgIHRhcmdldC54ID0gdGhpcy54IC0gdmVjdG9yLng7CiAgICAgICAgdGFyZ2V0LnkgPSB0aGlzLnkgLSB2ZWN0b3IueTsKICAgICAgICB0YXJnZXQueiA9IHRoaXMueiAtIHZlY3Rvci56OwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggLSB2ZWN0b3IueCwgdGhpcy55IC0gdmVjdG9yLnksIHRoaXMueiAtIHZlY3Rvci56KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGNyb3NzIHByb2R1Y3QgbWF0cml4IGFfY3Jvc3MgZnJvbSBhIHZlY3Rvciwgc3VjaCB0aGF0IGEgeCBiID0gYV9jcm9zcyAqIGIgPSBjCiAgICAgKgogICAgICogU2VlIHtAbGluayBodHRwczovL3d3dzguY3MudW11LnNlL2t1cnNlci9UREJEMjQvVlQwNi9sZWN0dXJlcy9MZWN0dXJlNi5wZGYgVW1lw6UgVW5pdmVyc2l0eSBMZWN0dXJlfQogICAgICovCgoKICAgIGNyb3NzbWF0KCkgewogICAgICByZXR1cm4gbmV3IE1hdDMoWzAsIC10aGlzLnosIHRoaXMueSwgdGhpcy56LCAwLCAtdGhpcy54LCAtdGhpcy55LCB0aGlzLngsIDBdKTsKICAgIH0KICAgIC8qKgogICAgICogTm9ybWFsaXplIHRoZSB2ZWN0b3IuIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHZhbHVlcyBpbiB0aGUgdmVjdG9yLgogICAgICAqIEByZXR1cm4gUmV0dXJucyB0aGUgbm9ybSBvZiB0aGUgdmVjdG9yCiAgICAgKi8KCgogICAgbm9ybWFsaXplKCkgewogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7CgogICAgICBpZiAobiA+IDAuMCkgewogICAgICAgIGNvbnN0IGludk4gPSAxIC8gbjsKICAgICAgICB0aGlzLnggKj0gaW52TjsKICAgICAgICB0aGlzLnkgKj0gaW52TjsKICAgICAgICB0aGlzLnogKj0gaW52TjsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBNYWtlIHNvbWV0aGluZyB1cAogICAgICAgIHRoaXMueCA9IDA7CiAgICAgICAgdGhpcy55ID0gMDsKICAgICAgICB0aGlzLnogPSAwOwogICAgICB9CgogICAgICByZXR1cm4gbjsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHRoYXQgaXMgb2YgbGVuZ3RoIDEuCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluCiAgICAgKiBAcmV0dXJuIFJldHVybnMgdGhlIHVuaXQgdmVjdG9yCiAgICAgKi8KCgogICAgdW5pdCh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgY29uc3QgeCA9IHRoaXMueDsKICAgICAgY29uc3QgeSA9IHRoaXMueTsKICAgICAgY29uc3QgeiA9IHRoaXMuejsKICAgICAgbGV0IG5pbnYgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTsKCiAgICAgIGlmIChuaW52ID4gMC4wKSB7CiAgICAgICAgbmludiA9IDEuMCAvIG5pbnY7CiAgICAgICAgdGFyZ2V0LnggPSB4ICogbmludjsKICAgICAgICB0YXJnZXQueSA9IHkgKiBuaW52OwogICAgICAgIHRhcmdldC56ID0geiAqIG5pbnY7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGFyZ2V0LnggPSAxOwogICAgICAgIHRhcmdldC55ID0gMDsKICAgICAgICB0YXJnZXQueiA9IDA7CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IKICAgICAqLwoKCiAgICBsZW5ndGgoKSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGUgdmVjdG9yLgogICAgICovCgoKICAgIGxlbmd0aFNxdWFyZWQoKSB7CiAgICAgIHJldHVybiB0aGlzLmRvdCh0aGlzKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50CiAgICAgKi8KCgogICAgZGlzdGFuY2VUbyhwKSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIGNvbnN0IHB4ID0gcC54OwogICAgICBjb25zdCBweSA9IHAueTsKICAgICAgY29uc3QgcHogPSBwLno7CiAgICAgIHJldHVybiBNYXRoLnNxcnQoKHB4IC0geCkgKiAocHggLSB4KSArIChweSAtIHkpICogKHB5IC0geSkgKyAocHogLSB6KSAqIChweiAtIHopKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnQKICAgICAqLwoKCiAgICBkaXN0YW5jZVNxdWFyZWQocCkgewogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCBweCA9IHAueDsKICAgICAgY29uc3QgcHkgPSBwLnk7CiAgICAgIGNvbnN0IHB6ID0gcC56OwogICAgICByZXR1cm4gKHB4IC0geCkgKiAocHggLSB4KSArIChweSAtIHkpICogKHB5IC0geSkgKyAocHogLSB6KSAqIChweiAtIHopOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSBhbGwgdGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB3aXRoIGEgc2NhbGFyLgogICAgICogQHBhcmFtIHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBzY2FsZShzY2FsYXIsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICB0YXJnZXQueCA9IHNjYWxhciAqIHg7CiAgICAgIHRhcmdldC55ID0gc2NhbGFyICogeTsKICAgICAgdGFyZ2V0LnogPSBzY2FsYXIgKiB6OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB0aGUgdmVjdG9yIHdpdGggYW4gb3RoZXIgdmVjdG9yLCBjb21wb25lbnQtd2lzZS4KICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uCiAgICAgKi8KCgogICAgdm11bCh2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IHZlY3Rvci54ICogdGhpcy54OwogICAgICB0YXJnZXQueSA9IHZlY3Rvci55ICogdGhpcy55OwogICAgICB0YXJnZXQueiA9IHZlY3Rvci56ICogdGhpcy56OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTY2FsZSBhIHZlY3RvciBhbmQgYWRkIGl0IHRvIHRoaXMgdmVjdG9yLiBTYXZlIHRoZSByZXN1bHQgaW4gInRhcmdldCIuICh0YXJnZXQgPSB0aGlzICsgdmVjdG9yICogc2NhbGFyKQogICAgICogQHBhcmFtIHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBhZGRTY2FsZWRWZWN0b3Ioc2NhbGFyLCB2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IHRoaXMueCArIHNjYWxhciAqIHZlY3Rvci54OwogICAgICB0YXJnZXQueSA9IHRoaXMueSArIHNjYWxhciAqIHZlY3Rvci55OwogICAgICB0YXJnZXQueiA9IHRoaXMueiArIHNjYWxhciAqIHZlY3Rvci56OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBDYWxjdWxhdGUgZG90IHByb2R1Y3QKICAgICAqIEBwYXJhbSB2ZWN0b3IKICAgICAqLwoKCiAgICBkb3QodmVjdG9yKSB7CiAgICAgIHJldHVybiB0aGlzLnggKiB2ZWN0b3IueCArIHRoaXMueSAqIHZlY3Rvci55ICsgdGhpcy56ICogdmVjdG9yLno7CiAgICB9CgogICAgaXNaZXJvKCkgewogICAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMCAmJiB0aGlzLnogPT09IDA7CiAgICB9CiAgICAvKioKICAgICAqIE1ha2UgdGhlIHZlY3RvciBwb2ludCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLgogICAgICogQHBhcmFtIHRhcmdldCBPcHRpb25hbCB0YXJnZXQgdG8gc2F2ZSBpbgogICAgICovCgoKICAgIG5lZ2F0ZSh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnggPSAtdGhpcy54OwogICAgICB0YXJnZXQueSA9IC10aGlzLnk7CiAgICAgIHRhcmdldC56ID0gLXRoaXMuejsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0d28gYXJ0aWZpY2lhbCB0YW5nZW50cyB0byB0aGUgdmVjdG9yCiAgICAgKiBAcGFyYW0gdDEgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBmaXJzdCB0YW5nZW50IGluCiAgICAgKiBAcGFyYW0gdDIgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBzZWNvbmQgdGFuZ2VudCBpbgogICAgICovCgoKICAgIHRhbmdlbnRzKHQxLCB0MikgewogICAgICBjb25zdCBub3JtID0gdGhpcy5sZW5ndGgoKTsKCiAgICAgIGlmIChub3JtID4gMC4wKSB7CiAgICAgICAgY29uc3QgbiA9IFZlYzNfdGFuZ2VudHNfbjsKICAgICAgICBjb25zdCBpbm9ybSA9IDEgLyBub3JtOwogICAgICAgIG4uc2V0KHRoaXMueCAqIGlub3JtLCB0aGlzLnkgKiBpbm9ybSwgdGhpcy56ICogaW5vcm0pOwogICAgICAgIGNvbnN0IHJhbmRWZWMgPSBWZWMzX3RhbmdlbnRzX3JhbmRWZWM7CgogICAgICAgIGlmIChNYXRoLmFicyhuLngpIDwgMC45KSB7CiAgICAgICAgICByYW5kVmVjLnNldCgxLCAwLCAwKTsKICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByYW5kVmVjLnNldCgwLCAxLCAwKTsKICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpOwogICAgICAgIH0KCiAgICAgICAgbi5jcm9zcyh0MSwgdDIpOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRoZSBub3JtYWwgbGVuZ3RoIGlzIHplcm8sIG1ha2Ugc29tZXRoaW5nIHVwCiAgICAgICAgdDEuc2V0KDEsIDAsIDApOwogICAgICAgIHQyLnNldCgwLCAxLCAwKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyB0byBhIG1vcmUgcmVhZGFibGUgZm9ybWF0CiAgICAgKi8KCgogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLnh9LCR7dGhpcy55fSwke3RoaXMuen1gOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyB0byBhbiBhcnJheQogICAgICovCgoKICAgIHRvQXJyYXkoKSB7CiAgICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07CiAgICB9CiAgICAvKioKICAgICAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyB2ZWN0b3IuCiAgICAgKi8KCgogICAgY29weSh2ZWN0b3IpIHsKICAgICAgdGhpcy54ID0gdmVjdG9yLng7CiAgICAgIHRoaXMueSA9IHZlY3Rvci55OwogICAgICB0aGlzLnogPSB2ZWN0b3IuejsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9ycwogICAgICogQHBhcmFtIHQgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiAwIHdpbGwgbWFrZSB0aGlzIGZ1bmN0aW9uIHJldHVybiB1LCBhbmQgMSB3aWxsIG1ha2UgaXQgcmV0dXJuIHYuIE51bWJlcnMgaW4gYmV0d2VlbiB3aWxsIGdlbmVyYXRlIGEgdmVjdG9yIGluIGJldHdlZW4gdGhlbS4KICAgICAqLwoKCiAgICBsZXJwKHZlY3RvciwgdCwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIHRhcmdldC54ID0geCArICh2ZWN0b3IueCAtIHgpICogdDsKICAgICAgdGFyZ2V0LnkgPSB5ICsgKHZlY3Rvci55IC0geSkgKiB0OwogICAgICB0YXJnZXQueiA9IHogKyAodmVjdG9yLnogLSB6KSAqIHQ7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGEgdmVjdG9yIGVxdWFscyBpcyBhbG1vc3QgZXF1YWwgdG8gYW5vdGhlciBvbmUuCiAgICAgKi8KCgogICAgYWxtb3N0RXF1YWxzKHZlY3RvciwgcHJlY2lzaW9uKSB7CiAgICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgewogICAgICAgIHByZWNpc2lvbiA9IDFlLTY7CiAgICAgIH0KCiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSB2ZWN0b3IueCkgPiBwcmVjaXNpb24gfHwgTWF0aC5hYnModGhpcy55IC0gdmVjdG9yLnkpID4gcHJlY2lzaW9uIHx8IE1hdGguYWJzKHRoaXMueiAtIHZlY3Rvci56KSA+IHByZWNpc2lvbikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvCiAgICAgKi8KCgogICAgYWxtb3N0WmVybyhwcmVjaXNpb24pIHsKICAgICAgaWYgKHByZWNpc2lvbiA9PT0gdm9pZCAwKSB7CiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjsKICAgICAgfQoKICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCkgPiBwcmVjaXNpb24gfHwgTWF0aC5hYnModGhpcy55KSA+IHByZWNpc2lvbiB8fCBNYXRoLmFicyh0aGlzLnopID4gcHJlY2lzaW9uKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIHZlY3RvciBpcyBhbnRpLXBhcmFsbGVsIHRvIGFub3RoZXIgdmVjdG9yLgogICAgICogQHBhcmFtIHByZWNpc2lvbiBTZXQgdG8gemVybyBmb3IgZXhhY3QgY29tcGFyaXNvbnMKICAgICAqLwoKCiAgICBpc0FudGlwYXJhbGxlbFRvKHZlY3RvciwgcHJlY2lzaW9uKSB7CiAgICAgIHRoaXMubmVnYXRlKGFudGlwX25lZyk7CiAgICAgIHJldHVybiBhbnRpcF9uZWcuYWxtb3N0RXF1YWxzKHZlY3RvciwgcHJlY2lzaW9uKTsKICAgIH0KICAgIC8qKgogICAgICogQ2xvbmUgdGhlIHZlY3RvcgogICAgICovCgoKICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LCB0aGlzLnksIHRoaXMueik7CiAgICB9CgogIH0KICBWZWMzLlpFUk8gPSBuZXcgVmVjMygwLCAwLCAwKTsKICBWZWMzLlVOSVRfWCA9IG5ldyBWZWMzKDEsIDAsIDApOwogIFZlYzMuVU5JVF9ZID0gbmV3IFZlYzMoMCwgMSwgMCk7CiAgVmVjMy5VTklUX1ogPSBuZXcgVmVjMygwLCAwLCAxKTsKICBjb25zdCBWZWMzX3RhbmdlbnRzX24gPSBuZXcgVmVjMygpOwogIGNvbnN0IFZlYzNfdGFuZ2VudHNfcmFuZFZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYW50aXBfbmVnID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy4KICAgKi8KICBjbGFzcyBBQUJCIHsKICAgIC8qKgogICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3gKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3gKICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLmxvd2VyQm91bmQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnVwcGVyQm91bmQgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMubG93ZXJCb3VuZCkgewogICAgICAgIHRoaXMubG93ZXJCb3VuZC5jb3B5KG9wdGlvbnMubG93ZXJCb3VuZCk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLnVwcGVyQm91bmQpIHsKICAgICAgICB0aGlzLnVwcGVyQm91bmQuY29weShvcHRpb25zLnVwcGVyQm91bmQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgQUFCQiBib3VuZHMgZnJvbSBhIHNldCBvZiBwb2ludHMuCiAgICAgKiBAcGFyYW0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMncy4KICAgICAqIEByZXR1cm4gVGhlIHNlbGYgb2JqZWN0CiAgICAgKi8KCgogICAgc2V0RnJvbVBvaW50cyhwb2ludHMsIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBza2luU2l6ZSkgewogICAgICBjb25zdCBsID0gdGhpcy5sb3dlckJvdW5kOwogICAgICBjb25zdCB1ID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBxID0gcXVhdGVybmlvbjsgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludAoKICAgICAgbC5jb3B5KHBvaW50c1swXSk7CgogICAgICBpZiAocSkgewogICAgICAgIHEudm11bHQobCwgbCk7CiAgICAgIH0KCiAgICAgIHUuY29weShsKTsKCiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgbGV0IHAgPSBwb2ludHNbaV07CgogICAgICAgIGlmIChxKSB7CiAgICAgICAgICBxLnZtdWx0KHAsIHRtcCQxKTsKICAgICAgICAgIHAgPSB0bXAkMTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnggPiB1LngpIHsKICAgICAgICAgIHUueCA9IHAueDsKICAgICAgICB9CgogICAgICAgIGlmIChwLnggPCBsLngpIHsKICAgICAgICAgIGwueCA9IHAueDsKICAgICAgICB9CgogICAgICAgIGlmIChwLnkgPiB1LnkpIHsKICAgICAgICAgIHUueSA9IHAueTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnkgPCBsLnkpIHsKICAgICAgICAgIGwueSA9IHAueTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnogPiB1LnopIHsKICAgICAgICAgIHUueiA9IHAuejsKICAgICAgICB9CgogICAgICAgIGlmIChwLnogPCBsLnopIHsKICAgICAgICAgIGwueiA9IHAuejsKICAgICAgICB9CiAgICAgIH0gLy8gQWRkIG9mZnNldAoKCiAgICAgIGlmIChwb3NpdGlvbikgewogICAgICAgIHBvc2l0aW9uLnZhZGQobCwgbCk7CiAgICAgICAgcG9zaXRpb24udmFkZCh1LCB1KTsKICAgICAgfQoKICAgICAgaWYgKHNraW5TaXplKSB7CiAgICAgICAgbC54IC09IHNraW5TaXplOwogICAgICAgIGwueSAtPSBza2luU2l6ZTsKICAgICAgICBsLnogLT0gc2tpblNpemU7CiAgICAgICAgdS54ICs9IHNraW5TaXplOwogICAgICAgIHUueSArPSBza2luU2l6ZTsKICAgICAgICB1LnogKz0gc2tpblNpemU7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCCiAgICAgKiBAcGFyYW0gYWFiYiBTb3VyY2UgdG8gY29weSBmcm9tCiAgICAgKiBAcmV0dXJuIFRoZSB0aGlzIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eQogICAgICovCgoKICAgIGNvcHkoYWFiYikgewogICAgICB0aGlzLmxvd2VyQm91bmQuY29weShhYWJiLmxvd2VyQm91bmQpOwogICAgICB0aGlzLnVwcGVyQm91bmQuY29weShhYWJiLnVwcGVyQm91bmQpOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogQ2xvbmUgYW4gQUFCQgogICAgICovCgoKICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IEFBQkIoKS5jb3B5KHRoaXMpOwogICAgfQogICAgLyoqCiAgICAgKiBFeHRlbmQgdGhpcyBBQUJCIHNvIHRoYXQgaXQgY292ZXJzIHRoZSBnaXZlbiBBQUJCIHRvby4KICAgICAqLwoKCiAgICBleHRlbmQoYWFiYikgewogICAgICB0aGlzLmxvd2VyQm91bmQueCA9IE1hdGgubWluKHRoaXMubG93ZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueCk7CiAgICAgIHRoaXMudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC54KTsKICAgICAgdGhpcy5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueSwgYWFiYi5sb3dlckJvdW5kLnkpOwogICAgICB0aGlzLnVwcGVyQm91bmQueSA9IE1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC55LCBhYWJiLnVwcGVyQm91bmQueSk7CiAgICAgIHRoaXMubG93ZXJCb3VuZC56ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnosIGFhYmIubG93ZXJCb3VuZC56KTsKICAgICAgdGhpcy51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueiwgYWFiYi51cHBlckJvdW5kLnopOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgb3ZlcmxhcHMgdGhpcyBBQUJCLgogICAgICovCgoKICAgIG92ZXJsYXBzKGFhYmIpIHsKICAgICAgY29uc3QgbDEgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUxID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBsMiA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdTIgPSBhYWJiLnVwcGVyQm91bmQ7IC8vICAgICAgbDIgICAgICAgIHUyCiAgICAgIC8vICAgICAgfC0tLS0tLS0tLXwKICAgICAgLy8gfC0tLS0tLS0tfAogICAgICAvLyBsMSAgICAgICB1MQoKICAgICAgY29uc3Qgb3ZlcmxhcHNYID0gbDIueCA8PSB1MS54ICYmIHUxLnggPD0gdTIueCB8fCBsMS54IDw9IHUyLnggJiYgdTIueCA8PSB1MS54OwogICAgICBjb25zdCBvdmVybGFwc1kgPSBsMi55IDw9IHUxLnkgJiYgdTEueSA8PSB1Mi55IHx8IGwxLnkgPD0gdTIueSAmJiB1Mi55IDw9IHUxLnk7CiAgICAgIGNvbnN0IG92ZXJsYXBzWiA9IGwyLnogPD0gdTEueiAmJiB1MS56IDw9IHUyLnogfHwgbDEueiA8PSB1Mi56ICYmIHUyLnogPD0gdTEuejsKICAgICAgcmV0dXJuIG92ZXJsYXBzWCAmJiBvdmVybGFwc1kgJiYgb3ZlcmxhcHNaOwogICAgfSAvLyBNb3N0bHkgZm9yIGRlYnVnZ2luZwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIGNvbnN0IGwgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUgPSB0aGlzLnVwcGVyQm91bmQ7CiAgICAgIHJldHVybiAodS54IC0gbC54KSAqICh1LnkgLSBsLnkpICogKHUueiAtIGwueik7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBpcyBmdWxseSBjb250YWluZWQgaW4gdGhpcyBBQUJCLgogICAgICovCgoKICAgIGNvbnRhaW5zKGFhYmIpIHsKICAgICAgY29uc3QgbDEgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUxID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBsMiA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdTIgPSBhYWJiLnVwcGVyQm91bmQ7IC8vICAgICAgbDIgICAgICAgIHUyCiAgICAgIC8vICAgICAgfC0tLS0tLS0tLXwKICAgICAgLy8gfC0tLS0tLS0tLS0tLS0tLXwKICAgICAgLy8gbDEgICAgICAgICAgICAgIHUxCgogICAgICByZXR1cm4gbDEueCA8PSBsMi54ICYmIHUxLnggPj0gdTIueCAmJiBsMS55IDw9IGwyLnkgJiYgdTEueSA+PSB1Mi55ICYmIGwxLnogPD0gbDIueiAmJiB1MS56ID49IHUyLno7CiAgICB9CgogICAgZ2V0Q29ybmVycyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7CiAgICAgIGNvbnN0IGwgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUgPSB0aGlzLnVwcGVyQm91bmQ7CiAgICAgIGEuY29weShsKTsKICAgICAgYi5zZXQodS54LCBsLnksIGwueik7CiAgICAgIGMuc2V0KHUueCwgdS55LCBsLnopOwogICAgICBkLnNldChsLngsIHUueSwgdS56KTsKICAgICAgZS5zZXQodS54LCBsLnksIHUueik7CiAgICAgIGYuc2V0KGwueCwgdS55LCBsLnopOwogICAgICBnLnNldChsLngsIGwueSwgdS56KTsKICAgICAgaC5jb3B5KHUpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gYW5vdGhlciBmcmFtZS4KICAgICAqIEByZXR1cm4gVGhlICJ0YXJnZXQiIEFBQkIgb2JqZWN0LgogICAgICovCgoKICAgIHRvTG9jYWxGcmFtZShmcmFtZSwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVyczsKICAgICAgY29uc3QgYSA9IGNvcm5lcnNbMF07CiAgICAgIGNvbnN0IGIgPSBjb3JuZXJzWzFdOwogICAgICBjb25zdCBjID0gY29ybmVyc1syXTsKICAgICAgY29uc3QgZCA9IGNvcm5lcnNbM107CiAgICAgIGNvbnN0IGUgPSBjb3JuZXJzWzRdOwogICAgICBjb25zdCBmID0gY29ybmVyc1s1XTsKICAgICAgY29uc3QgZyA9IGNvcm5lcnNbNl07CiAgICAgIGNvbnN0IGggPSBjb3JuZXJzWzddOyAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lCgogICAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7IC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgIGNvbnN0IGNvcm5lciA9IGNvcm5lcnNbaV07CiAgICAgICAgZnJhbWUucG9pbnRUb0xvY2FsKGNvcm5lciwgY29ybmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gdGhlIGdsb2JhbCBmcmFtZS4KICAgICAqIEByZXR1cm4gVGhlICJ0YXJnZXQiIEFBQkIgb2JqZWN0LgogICAgICovCgoKICAgIHRvV29ybGRGcmFtZShmcmFtZSwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVyczsKICAgICAgY29uc3QgYSA9IGNvcm5lcnNbMF07CiAgICAgIGNvbnN0IGIgPSBjb3JuZXJzWzFdOwogICAgICBjb25zdCBjID0gY29ybmVyc1syXTsKICAgICAgY29uc3QgZCA9IGNvcm5lcnNbM107CiAgICAgIGNvbnN0IGUgPSBjb3JuZXJzWzRdOwogICAgICBjb25zdCBmID0gY29ybmVyc1s1XTsKICAgICAgY29uc3QgZyA9IGNvcm5lcnNbNl07CiAgICAgIGNvbnN0IGggPSBjb3JuZXJzWzddOyAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lCgogICAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7IC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgIGNvbnN0IGNvcm5lciA9IGNvcm5lcnNbaV07CiAgICAgICAgZnJhbWUucG9pbnRUb1dvcmxkKGNvcm5lciwgY29ybmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgQUFCQiBpcyBoaXQgYnkgYSByYXkuCiAgICAgKi8KCgogICAgb3ZlcmxhcHNSYXkocmF5KSB7CiAgICAgIGNvbnN0IHsKICAgICAgICBkaXJlY3Rpb24sCiAgICAgICAgZnJvbQogICAgICB9ID0gcmF5OyAvLyBjb25zdCB0ID0gMAogICAgICAvLyByYXkuZGlyZWN0aW9uIGlzIHVuaXQgZGlyZWN0aW9uIHZlY3RvciBvZiByYXkKCiAgICAgIGNvbnN0IGRpckZyYWNYID0gMSAvIGRpcmVjdGlvbi54OwogICAgICBjb25zdCBkaXJGcmFjWSA9IDEgLyBkaXJlY3Rpb24ueTsKICAgICAgY29uc3QgZGlyRnJhY1ogPSAxIC8gZGlyZWN0aW9uLno7IC8vIHRoaXMubG93ZXJCb3VuZCBpcyB0aGUgY29ybmVyIG9mIEFBQkIgd2l0aCBtaW5pbWFsIGNvb3JkaW5hdGVzIC0gbGVmdCBib3R0b20sIHJ0IGlzIG1heGltYWwgY29ybmVyCgogICAgICBjb25zdCB0MSA9ICh0aGlzLmxvd2VyQm91bmQueCAtIGZyb20ueCkgKiBkaXJGcmFjWDsKICAgICAgY29uc3QgdDIgPSAodGhpcy51cHBlckJvdW5kLnggLSBmcm9tLngpICogZGlyRnJhY1g7CiAgICAgIGNvbnN0IHQzID0gKHRoaXMubG93ZXJCb3VuZC55IC0gZnJvbS55KSAqIGRpckZyYWNZOwogICAgICBjb25zdCB0NCA9ICh0aGlzLnVwcGVyQm91bmQueSAtIGZyb20ueSkgKiBkaXJGcmFjWTsKICAgICAgY29uc3QgdDUgPSAodGhpcy5sb3dlckJvdW5kLnogLSBmcm9tLnopICogZGlyRnJhY1o7CiAgICAgIGNvbnN0IHQ2ID0gKHRoaXMudXBwZXJCb3VuZC56IC0gZnJvbS56KSAqIGRpckZyYWNaOyAvLyBjb25zdCB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSkpOwogICAgICAvLyBjb25zdCB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSkpOwoKICAgICAgY29uc3QgdG1pbiA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWluKHQxLCB0MiksIE1hdGgubWluKHQzLCB0NCkpLCBNYXRoLm1pbih0NSwgdDYpKTsKICAgICAgY29uc3QgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpLCBNYXRoLm1heCh0NSwgdDYpKTsgLy8gaWYgdG1heCA8IDAsIHJheSAobGluZSkgaXMgaW50ZXJzZWN0aW5nIEFBQkIsIGJ1dCB3aG9sZSBBQUJCIGlzIGJlaGluZyB1cwoKICAgICAgaWYgKHRtYXggPCAwKSB7CiAgICAgICAgLy90ID0gdG1heDsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gaWYgdG1pbiA+IHRtYXgsIHJheSBkb2Vzbid0IGludGVyc2VjdCBBQUJCCgoKICAgICAgaWYgKHRtaW4gPiB0bWF4KSB7CiAgICAgICAgLy90ID0gdG1heDsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICB9CiAgY29uc3QgdG1wJDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzID0gW25ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCldOwoKICAvKioKICAgKiBDb2xsaXNpb24gIm1hdHJpeCIuCiAgICogSXQncyBhY3R1YWxseSBhIHRyaWFuZ3VsYXItc2hhcGVkIGFycmF5IG9mIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcgdGhpcyBzdGVwLCBmb3IgcmVmZXJlbmNlIG5leHQgc3RlcAogICAqLwogIGNsYXNzIEFycmF5Q29sbGlzaW9uTWF0cml4IHsKICAgIC8qKgogICAgICogVGhlIG1hdHJpeCBzdG9yYWdlLgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy5tYXRyaXggPSBbXTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFuIGVsZW1lbnQKICAgICAqLwoKCiAgICBnZXQoYmksIGJqKSB7CiAgICAgIGxldCB7CiAgICAgICAgaW5kZXg6IGkKICAgICAgfSA9IGJpOwogICAgICBsZXQgewogICAgICAgIGluZGV4OiBqCiAgICAgIH0gPSBiajsKCiAgICAgIGlmIChqID4gaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5tYXRyaXhbKGkgKiAoaSArIDEpID4+IDEpICsgaiAtIDFdOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgYW4gZWxlbWVudAogICAgICovCgoKICAgIHNldChiaSwgYmosIHZhbHVlKSB7CiAgICAgIGxldCB7CiAgICAgICAgaW5kZXg6IGkKICAgICAgfSA9IGJpOwogICAgICBsZXQgewogICAgICAgIGluZGV4OiBqCiAgICAgIH0gPSBiajsKCiAgICAgIGlmIChqID4gaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICB0aGlzLm1hdHJpeFsoaSAqIChpICsgMSkgPj4gMSkgKyBqIC0gMV0gPSB2YWx1ZSA/IDEgOiAwOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGFsbCBlbGVtZW50cyB0byB6ZXJvCiAgICAgKi8KCgogICAgcmVzZXQoKSB7CiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5tYXRyaXgubGVuZ3RoOyBpICE9PSBsOyBpKyspIHsKICAgICAgICB0aGlzLm1hdHJpeFtpXSA9IDA7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU2V0cyB0aGUgbWF4IG51bWJlciBvZiBvYmplY3RzCiAgICAgKi8KCgogICAgc2V0TnVtT2JqZWN0cyhuKSB7CiAgICAgIHRoaXMubWF0cml4Lmxlbmd0aCA9IG4gKiAobiAtIDEpID4+IDE7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IGRpc3BhdGNoZXMgZXZlbnRzLgogICAqLwogIGNsYXNzIEV2ZW50VGFyZ2V0IHsKICAgIC8qKgogICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyCiAgICAgKiBAcmV0dXJuIFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS4KICAgICAqLwogICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwoKICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgIH0KCiAgICAgIGlmICghbGlzdGVuZXJzW3R5cGVdLmluY2x1ZGVzKGxpc3RlbmVyKSkgewogICAgICAgIGxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGxpc3RlbmVyIGlzIGFkZGVkCiAgICAgKi8KCgogICAgaGFzRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyczsKCiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbdHlwZV0uaW5jbHVkZXMobGlzdGVuZXIpKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgYW55IGV2ZW50IGxpc3RlbmVyIG9mIHRoZSBnaXZlbiB0eXBlIGlzIGFkZGVkCiAgICAgKi8KCgogICAgaGFzQW55RXZlbnRMaXN0ZW5lcih0eXBlKSB7CiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwogICAgICByZXR1cm4gbGlzdGVuZXJzW3R5cGVdICE9PSB1bmRlZmluZWQ7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lcgogICAgICogQHJldHVybiBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuCiAgICAgKi8KCgogICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwoKICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpOwoKICAgICAgaWYgKGluZGV4ICE9PSAtMSkgewogICAgICAgIGxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogRW1pdCBhbiBldmVudC4KICAgICAqIEByZXR1cm4gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LgogICAgICovCgoKICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsKICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyczsKICAgICAgY29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1tldmVudC50eXBlXTsKCiAgICAgIGlmIChsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQpIHsKICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzOwoKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICBsaXN0ZW5lckFycmF5W2ldLmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQSBRdWF0ZXJuaW9uIGRlc2NyaWJlcyBhIHJvdGF0aW9uIGluIDNEIHNwYWNlLiBUaGUgUXVhdGVybmlvbiBpcyBtYXRoZW1hdGljYWxseSBkZWZpbmVkIGFzIFEgPSB4KmkgKyB5KmogKyB6KmsgKyB3LCB3aGVyZSAoaSxqLGspIGFyZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9ycy4gKHgseSx6KSBjYW4gYmUgc2VlbiBhcyBhIHZlY3RvciByZWxhdGVkIHRvIHRoZSBheGlzIG9mIHJvdGF0aW9uLCB3aGlsZSB0aGUgcmVhbCBtdWx0aXBsaWVyLCB3LCBpcyByZWxhdGVkIHRvIHRoZSBhbW91bnQgb2Ygcm90YXRpb24uCiAgICogQHBhcmFtIHggTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBpLgogICAqIEBwYXJhbSB5IE11bHRpcGxpZXIgb2YgdGhlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3Igai4KICAgKiBAcGFyYW0geiBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGsuCiAgICogQHBhcmFtIHcgTXVsdGlwbGllciBvZiB0aGUgcmVhbCBwYXJ0LgogICAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWF0ZXJuaW9uCiAgICovCgogIGNsYXNzIFF1YXRlcm5pb24gewogICAgY29uc3RydWN0b3IoeCwgeSwgeiwgdykgewogICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7CiAgICAgICAgeCA9IDA7CiAgICAgIH0KCiAgICAgIGlmICh5ID09PSB2b2lkIDApIHsKICAgICAgICB5ID0gMDsKICAgICAgfQoKICAgICAgaWYgKHogPT09IHZvaWQgMCkgewogICAgICAgIHogPSAwOwogICAgICB9CgogICAgICBpZiAodyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdyA9IDE7CiAgICAgIH0KCiAgICAgIHRoaXMueCA9IHg7CiAgICAgIHRoaXMueSA9IHk7CiAgICAgIHRoaXMueiA9IHo7CiAgICAgIHRoaXMudyA9IHc7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHF1YXRlcm5pb24uCiAgICAgKi8KCgogICAgc2V0KHgsIHksIHosIHcpIHsKICAgICAgdGhpcy54ID0geDsKICAgICAgdGhpcy55ID0geTsKICAgICAgdGhpcy56ID0gejsKICAgICAgdGhpcy53ID0gdzsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgdG8gYSByZWFkYWJsZSBmb3JtYXQKICAgICAqIEByZXR1cm4gIngseSx6LHciCiAgICAgKi8KCgogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLnh9LCR7dGhpcy55fSwke3RoaXMuen0sJHt0aGlzLnd9YDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCB0byBhbiBBcnJheQogICAgICogQHJldHVybiBbeCwgeSwgeiwgd10KICAgICAqLwoKCiAgICB0b0FycmF5KCkgewogICAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud107CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIGFuIGF4aXMgYW5kIGFuIGFuZ2xlIGluIHJhZGlhbnMuCiAgICAgKi8KCgogICAgc2V0RnJvbUF4aXNBbmdsZSh2ZWN0b3IsIGFuZ2xlKSB7CiAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSAqIDAuNSk7CiAgICAgIHRoaXMueCA9IHZlY3Rvci54ICogczsKICAgICAgdGhpcy55ID0gdmVjdG9yLnkgKiBzOwogICAgICB0aGlzLnogPSB2ZWN0b3IueiAqIHM7CiAgICAgIHRoaXMudyA9IE1hdGguY29zKGFuZ2xlICogMC41KTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIHRoZSBxdWF0ZXJuaW9uIHRvIFsgYXhpcywgYW5nbGUgXSByZXByZXNlbnRhdGlvbi4KICAgICAqIEBwYXJhbSB0YXJnZXRBeGlzIEEgdmVjdG9yIG9iamVjdCB0byByZXVzZSBmb3Igc3RvcmluZyB0aGUgYXhpcy4KICAgICAqIEByZXR1cm4gQW4gYXJyYXksIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuCiAgICAgKi8KCgogICAgdG9BeGlzQW5nbGUodGFyZ2V0QXhpcykgewogICAgICBpZiAodGFyZ2V0QXhpcyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0QXhpcyA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMubm9ybWFsaXplKCk7IC8vIGlmIHc+MSBhY29zIGFuZCBzcXJ0IHdpbGwgcHJvZHVjZSBlcnJvcnMsIHRoaXMgY2FudCBoYXBwZW4gaWYgcXVhdGVybmlvbiBpcyBub3JtYWxpc2VkCgogICAgICBjb25zdCBhbmdsZSA9IDIgKiBNYXRoLmFjb3ModGhpcy53KTsKICAgICAgY29uc3QgcyA9IE1hdGguc3FydCgxIC0gdGhpcy53ICogdGhpcy53KTsgLy8gYXNzdW1pbmcgcXVhdGVybmlvbiBub3JtYWxpc2VkIHRoZW4gdyBpcyBsZXNzIHRoYW4gMSwgc28gdGVybSBhbHdheXMgcG9zaXRpdmUuCgogICAgICBpZiAocyA8IDAuMDAxKSB7CiAgICAgICAgLy8gdGVzdCB0byBhdm9pZCBkaXZpZGUgYnkgemVybywgcyBpcyBhbHdheXMgcG9zaXRpdmUgZHVlIHRvIHNxcnQKICAgICAgICAvLyBpZiBzIGNsb3NlIHRvIHplcm8gdGhlbiBkaXJlY3Rpb24gb2YgYXhpcyBub3QgaW1wb3J0YW50CiAgICAgICAgdGFyZ2V0QXhpcy54ID0gdGhpcy54OyAvLyBpZiBpdCBpcyBpbXBvcnRhbnQgdGhhdCBheGlzIGlzIG5vcm1hbGlzZWQgdGhlbiByZXBsYWNlIHdpdGggeD0xOyB5PXo9MDsKCiAgICAgICAgdGFyZ2V0QXhpcy55ID0gdGhpcy55OwogICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMuejsKICAgICAgfSBlbHNlIHsKICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLnggLyBzOyAvLyBub3JtYWxpc2UgYXhpcwoKICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnkgLyBzOwogICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMueiAvIHM7CiAgICAgIH0KCiAgICAgIHJldHVybiBbdGFyZ2V0QXhpcywgYW5nbGVdOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHF1YXRlcm5pb24gdmFsdWUgZ2l2ZW4gdHdvIHZlY3RvcnMuIFRoZSByZXN1bHRpbmcgcm90YXRpb24gd2lsbCBiZSB0aGUgbmVlZGVkIHJvdGF0aW9uIHRvIHJvdGF0ZSB1IHRvIHYuCiAgICAgKi8KCgogICAgc2V0RnJvbVZlY3RvcnModSwgdikgewogICAgICBpZiAodS5pc0FudGlwYXJhbGxlbFRvKHYpKSB7CiAgICAgICAgY29uc3QgdDEgPSBzZnZfdDE7CiAgICAgICAgY29uc3QgdDIgPSBzZnZfdDI7CiAgICAgICAgdS50YW5nZW50cyh0MSwgdDIpOwogICAgICAgIHRoaXMuc2V0RnJvbUF4aXNBbmdsZSh0MSwgTWF0aC5QSSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgYSA9IHUuY3Jvc3Modik7CiAgICAgICAgdGhpcy54ID0gYS54OwogICAgICAgIHRoaXMueSA9IGEueTsKICAgICAgICB0aGlzLnogPSBhLno7CiAgICAgICAgdGhpcy53ID0gTWF0aC5zcXJ0KHUubGVuZ3RoKCkgKiogMiAqIHYubGVuZ3RoKCkgKiogMikgKyB1LmRvdCh2KTsKICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogTXVsdGlwbHkgdGhlIHF1YXRlcm5pb24gd2l0aCBhbiBvdGhlciBxdWF0ZXJuaW9uLgogICAgICovCgoKICAgIG11bHQocXVhdCwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4ID0gdGhpcy54OwogICAgICBjb25zdCBheSA9IHRoaXMueTsKICAgICAgY29uc3QgYXogPSB0aGlzLno7CiAgICAgIGNvbnN0IGF3ID0gdGhpcy53OwogICAgICBjb25zdCBieCA9IHF1YXQueDsKICAgICAgY29uc3QgYnkgPSBxdWF0Lnk7CiAgICAgIGNvbnN0IGJ6ID0gcXVhdC56OwogICAgICBjb25zdCBidyA9IHF1YXQudzsKICAgICAgdGFyZ2V0LnggPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5OwogICAgICB0YXJnZXQueSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7CiAgICAgIHRhcmdldC56ID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDsKICAgICAgdGFyZ2V0LncgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGludmVyc2UgcXVhdGVybmlvbiByb3RhdGlvbi4KICAgICAqLwoKCiAgICBpbnZlcnNlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCB3ID0gdGhpcy53OwogICAgICB0aGlzLmNvbmp1Z2F0ZSh0YXJnZXQpOwogICAgICBjb25zdCBpbm9ybTIgPSAxIC8gKHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTsKICAgICAgdGFyZ2V0LnggKj0gaW5vcm0yOwogICAgICB0YXJnZXQueSAqPSBpbm9ybTI7CiAgICAgIHRhcmdldC56ICo9IGlub3JtMjsKICAgICAgdGFyZ2V0LncgKj0gaW5vcm0yOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHF1YXRlcm5pb24gY29uanVnYXRlCiAgICAgKi8KCgogICAgY29uanVnYXRlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IC10aGlzLng7CiAgICAgIHRhcmdldC55ID0gLXRoaXMueTsKICAgICAgdGFyZ2V0LnogPSAtdGhpcy56OwogICAgICB0YXJnZXQudyA9IHRoaXMudzsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIHF1YXRlcm5pb24uCiAgICAgKi8KCgogICAgbm9ybWFsaXplKCkgewogICAgICBsZXQgbCA9IE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpOwoKICAgICAgaWYgKGwgPT09IDApIHsKICAgICAgICB0aGlzLnggPSAwOwogICAgICAgIHRoaXMueSA9IDA7CiAgICAgICAgdGhpcy56ID0gMDsKICAgICAgICB0aGlzLncgPSAwOwogICAgICB9IGVsc2UgewogICAgICAgIGwgPSAxIC8gbDsKICAgICAgICB0aGlzLnggKj0gbDsKICAgICAgICB0aGlzLnkgKj0gbDsKICAgICAgICB0aGlzLnogKj0gbDsKICAgICAgICB0aGlzLncgKj0gbDsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIEFwcHJveGltYXRpb24gb2YgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uLiBXb3JrcyBiZXN0IHdoZW4gcXVhdCBpcyBhbHJlYWR5IGFsbW9zdC1ub3JtYWxpemVkLgogICAgICogQGF1dGhvciB1bnBoYXNlZCwgaHR0cHM6Ly9naXRodWIuY29tL3VucGhhc2VkCiAgICAgKi8KCgogICAgbm9ybWFsaXplRmFzdCgpIHsKICAgICAgY29uc3QgZiA9ICgzLjAgLSAodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KSkgLyAyLjA7CgogICAgICBpZiAoZiA9PT0gMCkgewogICAgICAgIHRoaXMueCA9IDA7CiAgICAgICAgdGhpcy55ID0gMDsKICAgICAgICB0aGlzLnogPSAwOwogICAgICAgIHRoaXMudyA9IDA7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy54ICo9IGY7CiAgICAgICAgdGhpcy55ICo9IGY7CiAgICAgICAgdGhpcy56ICo9IGY7CiAgICAgICAgdGhpcy53ICo9IGY7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB0aGUgcXVhdGVybmlvbiBieSBhIHZlY3RvcgogICAgICovCgoKICAgIHZtdWx0KHYsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdi54OwogICAgICBjb25zdCB5ID0gdi55OwogICAgICBjb25zdCB6ID0gdi56OwogICAgICBjb25zdCBxeCA9IHRoaXMueDsKICAgICAgY29uc3QgcXkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHF6ID0gdGhpcy56OwogICAgICBjb25zdCBxdyA9IHRoaXMudzsgLy8gcSp2CgogICAgICBjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTsKICAgICAgY29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7CiAgICAgIGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4OwogICAgICBjb25zdCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7CiAgICAgIHRhcmdldC54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTsKICAgICAgdGFyZ2V0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6OwogICAgICB0YXJnZXQueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLgogICAgICogQHJldHVybiB0aGlzCiAgICAgKi8KCgogICAgY29weShxdWF0KSB7CiAgICAgIHRoaXMueCA9IHF1YXQueDsKICAgICAgdGhpcy55ID0gcXVhdC55OwogICAgICB0aGlzLnogPSBxdWF0Lno7CiAgICAgIHRoaXMudyA9IHF1YXQudzsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgdGhlIHF1YXRlcm5pb24gdG8gZXVsZXIgYW5nbGUgcmVwcmVzZW50YXRpb24uIE9yZGVyOiBZWlgsIGFzIHRoaXMgcGFnZSBkZXNjcmliZXM6IGh0dHBzOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9zdGFuZGFyZHMvaW5kZXguaHRtCiAgICAgKiBAcGFyYW0gb3JkZXIgVGhyZWUtY2hhcmFjdGVyIHN0cmluZywgZGVmYXVsdHMgdG8gIllaWCIKICAgICAqLwoKCiAgICB0b0V1bGVyKHRhcmdldCwgb3JkZXIpIHsKICAgICAgaWYgKG9yZGVyID09PSB2b2lkIDApIHsKICAgICAgICBvcmRlciA9ICdZWlgnOwogICAgICB9CgogICAgICBsZXQgaGVhZGluZzsKICAgICAgbGV0IGF0dGl0dWRlOwogICAgICBsZXQgYmFuazsKICAgICAgY29uc3QgeCA9IHRoaXMueDsKICAgICAgY29uc3QgeSA9IHRoaXMueTsKICAgICAgY29uc3QgeiA9IHRoaXMuejsKICAgICAgY29uc3QgdyA9IHRoaXMudzsKCiAgICAgIHN3aXRjaCAob3JkZXIpIHsKICAgICAgICBjYXNlICdZWlgnOgogICAgICAgICAgY29uc3QgdGVzdCA9IHggKiB5ICsgeiAqIHc7CgogICAgICAgICAgaWYgKHRlc3QgPiAwLjQ5OSkgewogICAgICAgICAgICAvLyBzaW5ndWxhcml0eSBhdCBub3J0aCBwb2xlCiAgICAgICAgICAgIGhlYWRpbmcgPSAyICogTWF0aC5hdGFuMih4LCB3KTsKICAgICAgICAgICAgYXR0aXR1ZGUgPSBNYXRoLlBJIC8gMjsKICAgICAgICAgICAgYmFuayA9IDA7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKHRlc3QgPCAtMC40OTkpIHsKICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZQogICAgICAgICAgICBoZWFkaW5nID0gLTIgKiBNYXRoLmF0YW4yKHgsIHcpOwogICAgICAgICAgICBhdHRpdHVkZSA9IC1NYXRoLlBJIC8gMjsKICAgICAgICAgICAgYmFuayA9IDA7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGhlYWRpbmcgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBjb25zdCBzcXggPSB4ICogeDsKICAgICAgICAgICAgY29uc3Qgc3F5ID0geSAqIHk7CiAgICAgICAgICAgIGNvbnN0IHNxeiA9IHogKiB6OwogICAgICAgICAgICBoZWFkaW5nID0gTWF0aC5hdGFuMigyICogeSAqIHcgLSAyICogeCAqIHosIDEgLSAyICogc3F5IC0gMiAqIHNxeik7IC8vIEhlYWRpbmcKCiAgICAgICAgICAgIGF0dGl0dWRlID0gTWF0aC5hc2luKDIgKiB0ZXN0KTsgLy8gYXR0aXR1ZGUKCiAgICAgICAgICAgIGJhbmsgPSBNYXRoLmF0YW4yKDIgKiB4ICogdyAtIDIgKiB5ICogeiwgMSAtIDIgKiBzcXggLSAyICogc3F6KTsgLy8gYmFuawogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdWxlciBvcmRlciAke29yZGVyfSBub3Qgc3VwcG9ydGVkIHlldC5gKTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnkgPSBoZWFkaW5nOwogICAgICB0YXJnZXQueiA9IGF0dGl0dWRlOwogICAgICB0YXJnZXQueCA9IGJhbms7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIEV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uLgogICAgICoKICAgICAqIEBwYXJhbSBvcmRlciBUaGUgb3JkZXIgdG8gYXBwbHkgYW5nbGVzOiAnWFlaJyBvciAnWVhaJyBvciBhbnkgb3RoZXIgY29tYmluYXRpb24uCiAgICAgKgogICAgICogU2VlIHtAbGluayBodHRwczovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlLzIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzIE1hdGhXb3Jrc30gcmVmZXJlbmNlCiAgICAgKi8KCgogICAgc2V0RnJvbUV1bGVyKHgsIHksIHosIG9yZGVyKSB7CiAgICAgIGlmIChvcmRlciA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3JkZXIgPSAnWFlaJzsKICAgICAgfQoKICAgICAgY29uc3QgYzEgPSBNYXRoLmNvcyh4IC8gMik7CiAgICAgIGNvbnN0IGMyID0gTWF0aC5jb3MoeSAvIDIpOwogICAgICBjb25zdCBjMyA9IE1hdGguY29zKHogLyAyKTsKICAgICAgY29uc3QgczEgPSBNYXRoLnNpbih4IC8gMik7CiAgICAgIGNvbnN0IHMyID0gTWF0aC5zaW4oeSAvIDIpOwogICAgICBjb25zdCBzMyA9IE1hdGguc2luKHogLyAyKTsKCiAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHsKICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7CiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzOwogICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMzsKICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7CiAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWFonKSB7CiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzOwogICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMzsKICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7CiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzOwogICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWlhZJykgewogICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMzsKICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7CiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzOwogICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMzsKICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHsKICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7CiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzOwogICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMzsKICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7CiAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWlgnKSB7CiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzOwogICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMzsKICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7CiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzOwogICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWFpZJykgewogICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMzsKICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7CiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzOwogICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMzsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CgogICAgY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpOwogICAgfQogICAgLyoqCiAgICAgKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0CiAgICAgKgogICAgICogQHBhcmFtIHRvUXVhdCBzZWNvbmQgb3BlcmFuZAogICAgICogQHBhcmFtIHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgc2VsZiBxdWF0ZXJuaW9uIGFuZCB0b1F1YXQKICAgICAqIEBwYXJhbSB0YXJnZXQgQSBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC4KICAgICAqIEByZXR1cm5zIHtRdWF0ZXJuaW9ufSBUaGUgInRhcmdldCIgb2JqZWN0CiAgICAgKi8KCgogICAgc2xlcnAodG9RdWF0LCB0LCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgfQoKICAgICAgY29uc3QgYXggPSB0aGlzLng7CiAgICAgIGNvbnN0IGF5ID0gdGhpcy55OwogICAgICBjb25zdCBheiA9IHRoaXMuejsKICAgICAgY29uc3QgYXcgPSB0aGlzLnc7CiAgICAgIGxldCBieCA9IHRvUXVhdC54OwogICAgICBsZXQgYnkgPSB0b1F1YXQueTsKICAgICAgbGV0IGJ6ID0gdG9RdWF0Lno7CiAgICAgIGxldCBidyA9IHRvUXVhdC53OwogICAgICBsZXQgb21lZ2E7CiAgICAgIGxldCBjb3NvbTsKICAgICAgbGV0IHNpbm9tOwogICAgICBsZXQgc2NhbGUwOwogICAgICBsZXQgc2NhbGUxOyAvLyBjYWxjIGNvc2luZQoKICAgICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3OyAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSkKCiAgICAgIGlmIChjb3NvbSA8IDAuMCkgewogICAgICAgIGNvc29tID0gLWNvc29tOwogICAgICAgIGJ4ID0gLWJ4OwogICAgICAgIGJ5ID0gLWJ5OwogICAgICAgIGJ6ID0gLWJ6OwogICAgICAgIGJ3ID0gLWJ3OwogICAgICB9IC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHMKCgogICAgICBpZiAoMS4wIC0gY29zb20gPiAwLjAwMDAwMSkgewogICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKQogICAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTsKICAgICAgICBzaW5vbSA9IE1hdGguc2luKG9tZWdhKTsKICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTsKICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gImZyb20iIGFuZCAidG8iIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlCiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbgogICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7CiAgICAgICAgc2NhbGUxID0gdDsKICAgICAgfSAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzCgoKICAgICAgdGFyZ2V0LnggPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4OwogICAgICB0YXJnZXQueSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7CiAgICAgIHRhcmdldC56ID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejsKICAgICAgdGFyZ2V0LncgPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBSb3RhdGUgYW4gYWJzb2x1dGUgb3JpZW50YXRpb24gcXVhdGVybmlvbiBnaXZlbiBhbiBhbmd1bGFyIHZlbG9jaXR5IGFuZCBhIHRpbWUgc3RlcC4KICAgICAqLwoKCiAgICBpbnRlZ3JhdGUoYW5ndWxhclZlbG9jaXR5LCBkdCwgYW5ndWxhckZhY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4ID0gYW5ndWxhclZlbG9jaXR5LnggKiBhbmd1bGFyRmFjdG9yLngsCiAgICAgICAgICAgIGF5ID0gYW5ndWxhclZlbG9jaXR5LnkgKiBhbmd1bGFyRmFjdG9yLnksCiAgICAgICAgICAgIGF6ID0gYW5ndWxhclZlbG9jaXR5LnogKiBhbmd1bGFyRmFjdG9yLnosCiAgICAgICAgICAgIGJ4ID0gdGhpcy54LAogICAgICAgICAgICBieSA9IHRoaXMueSwKICAgICAgICAgICAgYnogPSB0aGlzLnosCiAgICAgICAgICAgIGJ3ID0gdGhpcy53OwogICAgICBjb25zdCBoYWxmX2R0ID0gZHQgKiAwLjU7CiAgICAgIHRhcmdldC54ICs9IGhhbGZfZHQgKiAoYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5KTsKICAgICAgdGFyZ2V0LnkgKz0gaGFsZl9kdCAqIChheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYnopOwogICAgICB0YXJnZXQueiArPSBoYWxmX2R0ICogKGF6ICogYncgKyBheCAqIGJ5IC0gYXkgKiBieCk7CiAgICAgIHRhcmdldC53ICs9IGhhbGZfZHQgKiAoLWF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBieik7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CgogIH0KICBjb25zdCBzZnZfdDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNmdl90MiA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIFRoZSBhdmFpbGFibGUgc2hhcGUgdHlwZXMuCiAgICovCiAgY29uc3QgU0hBUEVfVFlQRVMgPSB7CiAgICAvKiogU1BIRVJFICovCiAgICBTUEhFUkU6IDEsCgogICAgLyoqIFBMQU5FICovCiAgICBQTEFORTogMiwKCiAgICAvKiogQk9YICovCiAgICBCT1g6IDQsCgogICAgLyoqIENPTVBPVU5EICovCiAgICBDT01QT1VORDogOCwKCiAgICAvKiogQ09OVkVYUE9MWUhFRFJPTiAqLwogICAgQ09OVkVYUE9MWUhFRFJPTjogMTYsCgogICAgLyoqIEhFSUdIVEZJRUxEICovCiAgICBIRUlHSFRGSUVMRDogMzIsCgogICAgLyoqIFBBUlRJQ0xFICovCiAgICBQQVJUSUNMRTogNjQsCgogICAgLyoqIENZTElOREVSICovCiAgICBDWUxJTkRFUjogMTI4LAoKICAgIC8qKiBUUklNRVNIICovCiAgICBUUklNRVNIOiAyNTYKICB9OwogIC8qKgogICAqIFNoYXBlVHlwZQogICAqLwoKICAvKioKICAgKiBCYXNlIGNsYXNzIGZvciBzaGFwZXMKICAgKi8KICBjbGFzcyBTaGFwZSB7CiAgICAvKioKICAgICAqIElkZW50aWZpZXIgb2YgdGhlIFNoYXBlLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBNdXN0IGJlIHNldCB0byBhbiBpbnQgPiAwIGJ5IHN1YmNsYXNzZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBsb2NhbCBib3VuZGluZyBzcGhlcmUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4KICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogQGRlZmF1bHQgMQogICAgICovCgogICAgLyoqCiAgICAgKiBAZGVmYXVsdCAtMQogICAgICovCgogICAgLyoqCiAgICAgKiBPcHRpb25hbCBtYXRlcmlhbCBvZiB0aGUgc2hhcGUgdGhhdCByZWd1bGF0ZXMgY29udGFjdCBwcm9wZXJ0aWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgYm9keSB0byB3aGljaCB0aGUgc2hhcGUgaXMgYWRkZWQgdG8uCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFsbCB0aGUgU2hhcGUgdHlwZXMuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgdGhpcy5pZCA9IFNoYXBlLmlkQ291bnRlcisrOwogICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgMDsKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDA7CiAgICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID8gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSA6IHRydWU7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgOiAtMTsKICAgICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgPyBvcHRpb25zLm1hdGVyaWFsIDogbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMuCiAgICAgKiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiB0aGUgcHJvcGVydHkgYC5ib3VuZGluZ1NwaGVyZVJhZGl1c2AKICAgICAqLwoKCiAgICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHsKICAgICAgdGhyb3cgYGNvbXB1dGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAke3RoaXMudHlwZX1gOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHZvbHVtZSBvZiB0aGlzIHNoYXBlCiAgICAgKi8KCgogICAgdm9sdW1lKCkgewogICAgICB0aHJvdyBgdm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7CiAgICB9CiAgICAvKioKICAgICAqIENhbGN1bGF0ZXMgdGhlIGluZXJ0aWEgaW4gdGhlIGxvY2FsIGZyYW1lIGZvciB0aGlzIHNoYXBlLgogICAgICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICB0aHJvdyBgY2FsY3VsYXRlTG9jYWxJbmVydGlhKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7CiAgICB9CiAgICAvKioKICAgICAqIEB0b2RvIHVzZSBhYnN0cmFjdCBmb3IgdGhlc2Uga2luZCBvZiBtZXRob2RzCiAgICAgKi8KCgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgdGhyb3cgYGNhbGN1bGF0ZVdvcmxkQUFCQigpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAke3RoaXMudHlwZX1gOwogICAgfQoKICB9CiAgU2hhcGUuaWRDb3VudGVyID0gMDsKICBTaGFwZS50eXBlcyA9IFNIQVBFX1RZUEVTOwoKICAvKioKICAgKiBUcmFuc2Zvcm1hdGlvbiB1dGlsaXRpZXMuCiAgICovCiAgY2xhc3MgVHJhbnNmb3JtIHsKICAgIC8qKgogICAgICogcG9zaXRpb24KICAgICAqLwoKICAgIC8qKgogICAgICogcXVhdGVybmlvbgogICAgICovCiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpOwoKICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHsKICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLnF1YXRlcm5pb24pIHsKICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIGdsb2JhbCBwb2ludCBpbiBsb2NhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuCiAgICAgKi8KCgogICAgcG9pbnRUb0xvY2FsKHdvcmxkUG9pbnQsIHJlc3VsdCkgewogICAgICByZXR1cm4gVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgd29ybGRQb2ludCwgcmVzdWx0KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGEgbG9jYWwgcG9pbnQgaW4gZ2xvYmFsIHRyYW5zZm9ybSBjb29yZGluYXRlcy4KICAgICAqLwoKCiAgICBwb2ludFRvV29ybGQobG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIHJldHVybiBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCBsb2NhbFBvaW50LCByZXN1bHQpOwogICAgfQogICAgLyoqCiAgICAgKiB2ZWN0b3JUb1dvcmxkRnJhbWUKICAgICAqLwoKCiAgICB2ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHBvaW50VG9Mb2NhbEZyYW1lCiAgICAgKi8KCgogICAgc3RhdGljIHBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFBvaW50LCByZXN1bHQpIHsKICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmVzdWx0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgd29ybGRQb2ludC52c3ViKHBvc2l0aW9uLCByZXN1bHQpOwogICAgICBxdWF0ZXJuaW9uLmNvbmp1Z2F0ZSh0bXBRdWF0JDEpOwogICAgICB0bXBRdWF0JDEudm11bHQocmVzdWx0LCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBwb2ludFRvV29ybGRGcmFtZQogICAgICovCgoKICAgIHN0YXRpYyBwb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgbG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCwgcmVzdWx0KTsKICAgICAgcmVzdWx0LnZhZGQocG9zaXRpb24sIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHZlY3RvclRvV29ybGRGcmFtZQogICAgICovCgoKICAgIHN0YXRpYyB2ZWN0b3JUb1dvcmxkRnJhbWUocXVhdGVybmlvbiwgbG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBxdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiB2ZWN0b3JUb0xvY2FsRnJhbWUKICAgICAqLwoKCiAgICBzdGF0aWMgdmVjdG9yVG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFZlY3RvciwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHF1YXRlcm5pb24udyAqPSAtMTsKICAgICAgcXVhdGVybmlvbi52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTsKICAgICAgcXVhdGVybmlvbi53ICo9IC0xOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICB9CiAgY29uc3QgdG1wUXVhdCQxID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgLyoqCiAgICogQSBzZXQgb2YgcG9seWdvbnMgZGVzY3JpYmluZyBhIGNvbnZleCBzaGFwZS4KICAgKgogICAqIFRoZSBzaGFwZSBNVVNUIGJlIGNvbnZleCBmb3IgdGhlIGNvZGUgdG8gd29yayBwcm9wZXJseS4gTm8gcG9seWdvbnMgbWF5IGJlIGNvcGxhbmFyIChjb250YWluZWQKICAgKiBpbiB0aGUgc2FtZSAzRCBwbGFuZSksIGluc3RlYWQgdGhlc2Ugc2hvdWxkIGJlIG1lcmdlZCBpbnRvIG9uZSBwb2x5Z29uLgogICAqCiAgICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW8gKG9yaWdpbmFsIGF1dGhvciwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvL3RocmVlLmpzL2NvbW1pdC84NTAyNmYwYzc2OWU0MDAwMTQ4YTY3ZDQ1YTllOWI5YzUxMDg4MzZmKQogICAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUKICAgKiBAc2VlIGh0dHBzOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvCiAgICoKICAgKiBAdG9kbyBNb3ZlIHRoZSBjbGlwcGluZyBmdW5jdGlvbnMgdG8gQ29udGFjdEdlbmVyYXRvcj8KICAgKiBAdG9kbyBBdXRvbWF0aWNhbGx5IG1lcmdlIGNvcGxhbmFyIHBvbHlnb25zIGluIGNvbnN0cnVjdG9yLgogICAqIEBleGFtcGxlCiAgICogICAgIGNvbnN0IGNvbnZleFNoYXBlID0gbmV3IENBTk5PTi5Db252ZXhQb2x5aGVkcm9uKHsgdmVydGljZXMsIGZhY2VzIH0pCiAgICogICAgIGNvbnN0IGNvbnZleEJvZHkgPSBuZXcgQ0FOTk9OLkJvZHkoeyBtYXNzOiAxLCBzaGFwZTogY29udmV4U2hhcGUgfSkKICAgKiAgICAgd29ybGQuYWRkQm9keShjb252ZXhCb2R5KQogICAqLwogIGNsYXNzIENvbnZleFBvbHloZWRyb24gZXh0ZW5kcyBTaGFwZSB7CiAgICAvKiogdmVydGljZXMgKi8KCiAgICAvKioKICAgICAqIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggZmFjZSBjb25zaXN0cyBvZgogICAgICovCgogICAgLyoqIGZhY2VOb3JtYWxzICovCgogICAgLyoqIHdvcmxkVmVydGljZXMgKi8KCiAgICAvKiogd29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlICovCgogICAgLyoqIHdvcmxkRmFjZU5vcm1hbHMgKi8KCiAgICAvKiogd29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlICovCgogICAgLyoqCiAgICAgKiBJZiBnaXZlbiwgdGhlc2UgbG9jYWxseSBkZWZpbmVkLCBub3JtYWxpemVkIGF4ZXMgYXJlIHRoZSBvbmx5IG9uZXMgYmVpbmcgY2hlY2tlZCB3aGVuIGRvaW5nIHNlcGFyYXRpbmcgYXhpcyBjaGVjay4KICAgICAqLwoKICAgIC8qKiB1bmlxdWVFZGdlcyAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIHZlcnRpY2VzIEFuIGFycmF5IG9mIFZlYzMncwogICAgICogQHBhcmFtIGZhY2VzIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBkZXNjcmliaW5nIHdoaWNoIHZlcnRpY2VzIHRoYXQgaXMgaW5jbHVkZWQgaW4gZWFjaCBmYWNlLgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihwcm9wcykgewogICAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkgewogICAgICAgIHByb3BzID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IHsKICAgICAgICB2ZXJ0aWNlcyA9IFtdLAogICAgICAgIGZhY2VzID0gW10sCiAgICAgICAgbm9ybWFscyA9IFtdLAogICAgICAgIGF4ZXMsCiAgICAgICAgYm91bmRpbmdTcGhlcmVSYWRpdXMKICAgICAgfSA9IHByb3BzOwogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTgogICAgICB9KTsKICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzOwogICAgICB0aGlzLmZhY2VzID0gZmFjZXM7CiAgICAgIHRoaXMuZmFjZU5vcm1hbHMgPSBub3JtYWxzOwoKICAgICAgaWYgKHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdGhpcy5jb21wdXRlTm9ybWFscygpOwogICAgICB9CgogICAgICBpZiAoIWJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBib3VuZGluZ1NwaGVyZVJhZGl1czsKICAgICAgfQoKICAgICAgdGhpcy53b3JsZFZlcnRpY2VzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLnZlcnRpY2VzCgogICAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IHRydWU7CiAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFscyA9IFtdOyAvLyBXb3JsZCB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIC5mYWNlTm9ybWFscwoKICAgICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSB0cnVlOwogICAgICB0aGlzLnVuaXF1ZUF4ZXMgPSBheGVzID8gYXhlcy5zbGljZSgpIDogbnVsbDsKICAgICAgdGhpcy51bmlxdWVFZGdlcyA9IFtdOwogICAgICB0aGlzLmNvbXB1dGVFZGdlcygpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyB1bmlxdWVFZGdlcwogICAgICovCgoKICAgIGNvbXB1dGVFZGdlcygpIHsKICAgICAgY29uc3QgZmFjZXMgPSB0aGlzLmZhY2VzOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIGNvbnN0IGVkZ2VzID0gdGhpcy51bmlxdWVFZGdlczsKICAgICAgZWRnZXMubGVuZ3RoID0gMDsKICAgICAgY29uc3QgZWRnZSA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbaV07CiAgICAgICAgY29uc3QgbnVtVmVydGljZXMgPSBmYWNlLmxlbmd0aDsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IG51bVZlcnRpY2VzOyBqKyspIHsKICAgICAgICAgIGNvbnN0IGsgPSAoaiArIDEpICUgbnVtVmVydGljZXM7CiAgICAgICAgICB2ZXJ0aWNlc1tmYWNlW2pdXS52c3ViKHZlcnRpY2VzW2ZhY2Vba11dLCBlZGdlKTsKICAgICAgICAgIGVkZ2Uubm9ybWFsaXplKCk7CiAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTsKCiAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspIHsKICAgICAgICAgICAgaWYgKGVkZ2VzW3BdLmFsbW9zdEVxdWFscyhlZGdlKSB8fCBlZGdlc1twXS5hbG1vc3RFcXVhbHMoZWRnZSkpIHsKICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIWZvdW5kKSB7CiAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuCiAgICAgKiBXaWxsIHJldXNlIGV4aXN0aW5nIFZlYzMgb2JqZWN0cyBpbiB0aGUgYGZhY2VOb3JtYWxzYCBhcnJheSBpZiB0aGV5IGV4aXN0LgogICAgICovCgoKICAgIGNvbXB1dGVOb3JtYWxzKCkgewogICAgICB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aCA9IHRoaXMuZmFjZXMubGVuZ3RoOyAvLyBHZW5lcmF0ZSBub3JtYWxzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAvLyBDaGVjayBzbyBhbGwgdmVydGljZXMgZXhpc3RzIGZvciB0aGlzIGZhY2UKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspIHsKICAgICAgICAgIGlmICghdGhpcy52ZXJ0aWNlc1t0aGlzLmZhY2VzW2ldW2pdXSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnRleCAke3RoaXMuZmFjZXNbaV1bal19IG5vdCBmb3VuZCFgKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGNvbnN0IG4gPSB0aGlzLmZhY2VOb3JtYWxzW2ldIHx8IG5ldyBWZWMzKCk7CiAgICAgICAgdGhpcy5nZXRGYWNlTm9ybWFsKGksIG4pOwogICAgICAgIG4ubmVnYXRlKG4pOwogICAgICAgIHRoaXMuZmFjZU5vcm1hbHNbaV0gPSBuOwogICAgICAgIGNvbnN0IHZlcnRleCA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVswXV07CgogICAgICAgIGlmIChuLmRvdCh2ZXJ0ZXgpIDwgMCkgewogICAgICAgICAgY29uc29sZS5lcnJvcihgLmZhY2VOb3JtYWxzWyR7aX1dID0gVmVjMygke24udG9TdHJpbmcoKX0pIGxvb2tzIGxpa2UgaXQgcG9pbnRzIGludG8gdGhlIHNoYXBlPyBUaGUgdmVydGljZXMgZm9sbG93LiBNYWtlIHN1cmUgdGhleSBhcmUgb3JkZXJlZCBDQ1cgYXJvdW5kIHRoZSBub3JtYWwsIHVzaW5nIHRoZSByaWdodCBoYW5kIHJ1bGUuYCk7CgogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmZhY2VzW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgIGNvbnNvbGUud2FybihgLnZlcnRpY2VzWyR7dGhpcy5mYWNlc1tpXVtqXX1dID0gVmVjMygke3RoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0udG9TdHJpbmcoKX0pYCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGUgdGhlIG5vcm1hbCBvZiBhIGZhY2UgZnJvbSBpdHMgdmVydGljZXMKICAgICAqLwoKCiAgICBnZXRGYWNlTm9ybWFsKGksIHRhcmdldCkgewogICAgICBjb25zdCBmID0gdGhpcy5mYWNlc1tpXTsKICAgICAgY29uc3QgdmEgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dOwogICAgICBjb25zdCB2YiA9IHRoaXMudmVydGljZXNbZlsxXV07CiAgICAgIGNvbnN0IHZjID0gdGhpcy52ZXJ0aWNlc1tmWzJdXTsKICAgICAgQ29udmV4UG9seWhlZHJvbi5jb21wdXRlTm9ybWFsKHZhLCB2YiwgdmMsIHRhcmdldCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzCiAgICAgKi8KCgogICAgc3RhdGljIGNvbXB1dGVOb3JtYWwodmEsIHZiLCB2YywgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNiID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgYWIgPSBuZXcgVmVjMygpOwogICAgICB2Yi52c3ViKHZhLCBhYik7CiAgICAgIHZjLnZzdWIodmIsIGNiKTsKICAgICAgY2IuY3Jvc3MoYWIsIHRhcmdldCk7CgogICAgICBpZiAoIXRhcmdldC5pc1plcm8oKSkgewogICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBAcGFyYW0gbWluRGlzdCBDbGFtcCBkaXN0YW5jZQogICAgICogQHBhcmFtIHJlc3VsdCBUaGUgYW4gYXJyYXkgb2YgY29udGFjdCBwb2ludCBvYmplY3RzLCBzZWUgY2xpcEZhY2VBZ2FpbnN0SHVsbAogICAgICovCgoKICAgIGNsaXBBZ2FpbnN0SHVsbChwb3NBLCBxdWF0QSwgaHVsbEIsIHBvc0IsIHF1YXRCLCBzZXBhcmF0aW5nTm9ybWFsLCBtaW5EaXN0LCBtYXhEaXN0LCByZXN1bHQpIHsKICAgICAgY29uc3QgV29ybGROb3JtYWwgPSBuZXcgVmVjMygpOwogICAgICBsZXQgY2xvc2VzdEZhY2VCID0gLTE7CiAgICAgIGxldCBkbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7CgogICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IGh1bGxCLmZhY2VzLmxlbmd0aDsgZmFjZSsrKSB7CiAgICAgICAgV29ybGROb3JtYWwuY29weShodWxsQi5mYWNlTm9ybWFsc1tmYWNlXSk7CiAgICAgICAgcXVhdEIudm11bHQoV29ybGROb3JtYWwsIFdvcmxkTm9ybWFsKTsKICAgICAgICBjb25zdCBkID0gV29ybGROb3JtYWwuZG90KHNlcGFyYXRpbmdOb3JtYWwpOwoKICAgICAgICBpZiAoZCA+IGRtYXgpIHsKICAgICAgICAgIGRtYXggPSBkOwogICAgICAgICAgY2xvc2VzdEZhY2VCID0gZmFjZTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IHdvcmxkVmVydHNCMSA9IFtdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsQi5mYWNlc1tjbG9zZXN0RmFjZUJdLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgYiA9IGh1bGxCLnZlcnRpY2VzW2h1bGxCLmZhY2VzW2Nsb3Nlc3RGYWNlQl1baV1dOwogICAgICAgIGNvbnN0IHdvcmxkYiA9IG5ldyBWZWMzKCk7CiAgICAgICAgd29ybGRiLmNvcHkoYik7CiAgICAgICAgcXVhdEIudm11bHQod29ybGRiLCB3b3JsZGIpOwogICAgICAgIHBvc0IudmFkZCh3b3JsZGIsIHdvcmxkYik7CiAgICAgICAgd29ybGRWZXJ0c0IxLnB1c2god29ybGRiKTsKICAgICAgfQoKICAgICAgaWYgKGNsb3Nlc3RGYWNlQiA+PSAwKSB7CiAgICAgICAgdGhpcy5jbGlwRmFjZUFnYWluc3RIdWxsKHNlcGFyYXRpbmdOb3JtYWwsIHBvc0EsIHF1YXRBLCB3b3JsZFZlcnRzQjEsIG1pbkRpc3QsIG1heERpc3QsIHJlc3VsdCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogRmluZCB0aGUgc2VwYXJhdGluZyBheGlzIGJldHdlZW4gdGhpcyBodWxsIGFuZCBhbm90aGVyCiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgdmVjdG9yIHRvIHNhdmUgdGhlIGF4aXMgaW4KICAgICAqIEByZXR1cm4gUmV0dXJucyBmYWxzZSBpZiBhIHNlcGFyYXRpb24gaXMgZm91bmQsIGVsc2UgdHJ1ZQogICAgICovCgoKICAgIGZpbmRTZXBhcmF0aW5nQXhpcyhodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCLCB0YXJnZXQsIGZhY2VMaXN0QSwgZmFjZUxpc3RCKSB7CiAgICAgIGNvbnN0IGZhY2VBTm9ybWFsV1MzID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgV29ybGRub3JtYWwxID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgZGVsdGFDID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3Qgd29ybGRFZGdlMCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHdvcmxkRWRnZTEgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBDcm9zcyA9IG5ldyBWZWMzKCk7CiAgICAgIGxldCBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTsKICAgICAgY29uc3QgaHVsbEEgPSB0aGlzOwoKICAgICAgaWYgKCFodWxsQS51bmlxdWVBeGVzKSB7CiAgICAgICAgY29uc3QgbnVtRmFjZXNBID0gZmFjZUxpc3RBID8gZmFjZUxpc3RBLmxlbmd0aCA6IGh1bGxBLmZhY2VzLmxlbmd0aDsgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQQoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZhY2VzQTsgaSsrKSB7CiAgICAgICAgICBjb25zdCBmaSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QVtpXSA6IGk7IC8vIEdldCB3b3JsZCBmYWNlIG5vcm1hbAoKICAgICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTsKICAgICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MzLCBmYWNlQU5vcm1hbFdTMyk7CiAgICAgICAgICBjb25zdCBkID0gaHVsbEEudGVzdFNlcEF4aXMoZmFjZUFOb3JtYWxXUzMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpOwoKICAgICAgICAgIGlmIChkID09PSBmYWxzZSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGQgPCBkbWluKSB7CiAgICAgICAgICAgIGRtaW4gPSBkOwogICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gaHVsbEEudW5pcXVlQXhlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgLy8gR2V0IHdvcmxkIGF4aXMKICAgICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUF4ZXNbaV0sIGZhY2VBTm9ybWFsV1MzKTsKICAgICAgICAgIGNvbnN0IGQgPSBodWxsQS50ZXN0U2VwQXhpcyhmYWNlQU5vcm1hbFdTMywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KGZhY2VBTm9ybWFsV1MzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICghaHVsbEIudW5pcXVlQXhlcykgewogICAgICAgIC8vIFRlc3QgZmFjZSBub3JtYWxzIGZyb20gaHVsbEIKICAgICAgICBjb25zdCBudW1GYWNlc0IgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEIubGVuZ3RoIDogaHVsbEIuZmFjZXMubGVuZ3RoOwoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZhY2VzQjsgaSsrKSB7CiAgICAgICAgICBjb25zdCBmaSA9IGZhY2VMaXN0QiA/IGZhY2VMaXN0QltpXSA6IGk7CiAgICAgICAgICBXb3JsZG5vcm1hbDEuY29weShodWxsQi5mYWNlTm9ybWFsc1tmaV0pOwogICAgICAgICAgcXVhdEIudm11bHQoV29ybGRub3JtYWwxLCBXb3JsZG5vcm1hbDEpOwogICAgICAgICAgY29uc3QgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMgaW4gQgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBodWxsQi51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBxdWF0Qi52bXVsdChodWxsQi51bmlxdWVBeGVzW2ldLCBXb3JsZG5vcm1hbDEpOwogICAgICAgICAgY29uc3QgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIFRlc3QgZWRnZXMKCgogICAgICBmb3IgKGxldCBlMCA9IDA7IGUwICE9PSBodWxsQS51bmlxdWVFZGdlcy5sZW5ndGg7IGUwKyspIHsKICAgICAgICAvLyBHZXQgd29ybGQgZWRnZQogICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUVkZ2VzW2UwXSwgd29ybGRFZGdlMCk7CgogICAgICAgIGZvciAobGV0IGUxID0gMDsgZTEgIT09IGh1bGxCLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTErKykgewogICAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2UgMgogICAgICAgICAgcXVhdEIudm11bHQoaHVsbEIudW5pcXVlRWRnZXNbZTFdLCB3b3JsZEVkZ2UxKTsKICAgICAgICAgIHdvcmxkRWRnZTAuY3Jvc3Mod29ybGRFZGdlMSwgQ3Jvc3MpOwoKICAgICAgICAgIGlmICghQ3Jvc3MuYWxtb3N0WmVybygpKSB7CiAgICAgICAgICAgIENyb3NzLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICBjb25zdCBkaXN0ID0gaHVsbEEudGVzdFNlcEF4aXMoQ3Jvc3MsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpOwoKICAgICAgICAgICAgaWYgKGRpc3QgPT09IGZhbHNlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoZGlzdCA8IGRtaW4pIHsKICAgICAgICAgICAgICBkbWluID0gZGlzdDsKICAgICAgICAgICAgICB0YXJnZXQuY29weShDcm9zcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHBvc0IudnN1Yihwb3NBLCBkZWx0YUMpOwoKICAgICAgaWYgKGRlbHRhQy5kb3QodGFyZ2V0KSA+IDAuMCkgewogICAgICAgIHRhcmdldC5uZWdhdGUodGFyZ2V0KTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIFRlc3Qgc2VwYXJhdGluZyBheGlzIGFnYWluc3QgdHdvIGh1bGxzLiBCb3RoIGh1bGxzIGFyZSBwcm9qZWN0ZWQgb250byB0aGUgYXhpcyBhbmQgdGhlIG92ZXJsYXAgc2l6ZSBpcyByZXR1cm5lZCBpZiB0aGVyZSBpcyBvbmUuCiAgICAgKiBAcmV0dXJuIFRoZSBvdmVybGFwIGRlcHRoLCBvciBGQUxTRSBpZiBubyBwZW5ldHJhdGlvbi4KICAgICAqLwoKCiAgICB0ZXN0U2VwQXhpcyhheGlzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKSB7CiAgICAgIGNvbnN0IGh1bGxBID0gdGhpczsKICAgICAgQ29udmV4UG9seWhlZHJvbi5wcm9qZWN0KGh1bGxBLCBheGlzLCBwb3NBLCBxdWF0QSwgbWF4bWluQSk7CiAgICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQiwgYXhpcywgcG9zQiwgcXVhdEIsIG1heG1pbkIpOwogICAgICBjb25zdCBtYXhBID0gbWF4bWluQVswXTsKICAgICAgY29uc3QgbWluQSA9IG1heG1pbkFbMV07CiAgICAgIGNvbnN0IG1heEIgPSBtYXhtaW5CWzBdOwogICAgICBjb25zdCBtaW5CID0gbWF4bWluQlsxXTsKCiAgICAgIGlmIChtYXhBIDwgbWluQiB8fCBtYXhCIDwgbWluQSkgewogICAgICAgIHJldHVybiBmYWxzZTsgLy8gU2VwYXJhdGVkCiAgICAgIH0KCiAgICAgIGNvbnN0IGQwID0gbWF4QSAtIG1pbkI7CiAgICAgIGNvbnN0IGQxID0gbWF4QiAtIG1pbkE7CiAgICAgIGNvbnN0IGRlcHRoID0gZDAgPCBkMSA/IGQwIDogZDE7CiAgICAgIHJldHVybiBkZXB0aDsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlTG9jYWxJbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhCiAgICAgIC8vIEV4YWN0IGluZXJ0aWEgY2FsY3VsYXRpb24gaXMgb3ZlcmtpbGwsIGJ1dCBzZWUgaHR0cDovL2dlb21ldHJpY3Rvb2xzLmNvbS9Eb2N1bWVudGF0aW9uL1BvbHloZWRyYWxNYXNzUHJvcGVydGllcy5wZGYgZm9yIHRoZSBjb3JyZWN0IHdheSB0byBkbyBpdAogICAgICBjb25zdCBhYWJibWF4ID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgYWFiYm1pbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQihhYWJibWluLCBhYWJibWF4KTsKICAgICAgY29uc3QgeCA9IGFhYmJtYXgueCAtIGFhYmJtaW4ueDsKICAgICAgY29uc3QgeSA9IGFhYmJtYXgueSAtIGFhYmJtaW4ueTsKICAgICAgY29uc3QgeiA9IGFhYmJtYXgueiAtIGFhYmJtaW4uejsKICAgICAgdGFyZ2V0LnggPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHogKiAyICogeik7CiAgICAgIHRhcmdldC55ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIHggKiAyICogeCArIDIgKiB6ICogMiAqIHopOwogICAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB5ICogMiAqIHkgKyAyICogeCAqIDIgKiB4KTsKICAgIH0KICAgIC8qKgogICAgICogQHBhcmFtIGZhY2VfaSBJbmRleCBvZiB0aGUgZmFjZQogICAgICovCgoKICAgIGdldFBsYW5lQ29uc3RhbnRPZkZhY2UoZmFjZV9pKSB7CiAgICAgIGNvbnN0IGYgPSB0aGlzLmZhY2VzW2ZhY2VfaV07CiAgICAgIGNvbnN0IG4gPSB0aGlzLmZhY2VOb3JtYWxzW2ZhY2VfaV07CiAgICAgIGNvbnN0IHYgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dOwogICAgICBjb25zdCBjID0gLW4uZG90KHYpOwogICAgICByZXR1cm4gYzsKICAgIH0KICAgIC8qKgogICAgICogQ2xpcCBhIGZhY2UgYWdhaW5zdCBhIGh1bGwuCiAgICAgKiBAcGFyYW0gd29ybGRWZXJ0c0IxIEFuIGFycmF5IG9mIFZlYzMgd2l0aCB2ZXJ0aWNlcyBpbiB0aGUgd29ybGQgZnJhbWUuCiAgICAgKiBAcGFyYW0gbWluRGlzdCBEaXN0YW5jZSBjbGFtcGluZwogICAgICogQHBhcmFtIEFycmF5IHJlc3VsdCBBcnJheSB0byBzdG9yZSByZXN1bHRpbmcgY29udGFjdCBwb2ludHMgaW4uIFdpbGwgYmUgb2JqZWN0cyB3aXRoIHByb3BlcnRpZXM6IHBvaW50LCBkZXB0aCwgbm9ybWFsLiBUaGVzZSBhcmUgcmVwcmVzZW50ZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKi8KCgogICAgY2xpcEZhY2VBZ2FpbnN0SHVsbChzZXBhcmF0aW5nTm9ybWFsLCBwb3NBLCBxdWF0QSwgd29ybGRWZXJ0c0IxLCBtaW5EaXN0LCBtYXhEaXN0LCByZXN1bHQpIHsKICAgICAgY29uc3QgZmFjZUFOb3JtYWxXUyA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGVkZ2UwID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgV29ybGRFZGdlMCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHdvcmxkUGxhbmVBbm9ybWFsMSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHBsYW5lTm9ybWFsV1MxID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3Qgd29ybGRBMSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGxvY2FsUGxhbmVOb3JtYWwgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBwbGFuZU5vcm1hbFdTID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgaHVsbEEgPSB0aGlzOwogICAgICBjb25zdCB3b3JsZFZlcnRzQjIgPSBbXTsKICAgICAgY29uc3QgcFZ0eEluID0gd29ybGRWZXJ0c0IxOwogICAgICBjb25zdCBwVnR4T3V0ID0gd29ybGRWZXJ0c0IyOwogICAgICBsZXQgY2xvc2VzdEZhY2VBID0gLTE7CiAgICAgIGxldCBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gRmluZCB0aGUgZmFjZSB3aXRoIG5vcm1hbCBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXMKCiAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgaHVsbEEuZmFjZXMubGVuZ3RoOyBmYWNlKyspIHsKICAgICAgICBmYWNlQU5vcm1hbFdTLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmFjZV0pOwogICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MsIGZhY2VBTm9ybWFsV1MpOwogICAgICAgIGNvbnN0IGQgPSBmYWNlQU5vcm1hbFdTLmRvdChzZXBhcmF0aW5nTm9ybWFsKTsKCiAgICAgICAgaWYgKGQgPCBkbWluKSB7CiAgICAgICAgICBkbWluID0gZDsKICAgICAgICAgIGNsb3Nlc3RGYWNlQSA9IGZhY2U7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoY2xvc2VzdEZhY2VBIDwgMCkgewogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBHZXQgdGhlIGZhY2UgYW5kIGNvbnN0cnVjdCBjb25uZWN0ZWQgZmFjZXMKCgogICAgICBjb25zdCBwb2x5QSA9IGh1bGxBLmZhY2VzW2Nsb3Nlc3RGYWNlQV07CiAgICAgIHBvbHlBLmNvbm5lY3RlZEZhY2VzID0gW107CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGh1bGxBLmZhY2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBodWxsQS5mYWNlc1tpXS5sZW5ndGg7IGorKykgewogICAgICAgICAgaWYgKAogICAgICAgICAgLyogU2hhcmluZyBhIHZlcnRleCovCiAgICAgICAgICBwb2x5QS5pbmRleE9mKGh1bGxBLmZhY2VzW2ldW2pdKSAhPT0gLTEgJiYKICAgICAgICAgIC8qIE5vdCB0aGUgb25lIHdlIGFyZSBsb29raW5nIGZvciBjb25uZWN0aW9ucyBmcm9tICovCiAgICAgICAgICBpICE9PSBjbG9zZXN0RmFjZUEgJiYKICAgICAgICAgIC8qIE5vdCBhbHJlYWR5IGFkZGVkICovCiAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKGkpID09PSAtMSkgewogICAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5wdXNoKGkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyBDbGlwIHRoZSBwb2x5Z29uIHRvIHRoZSBiYWNrIG9mIHRoZSBwbGFuZXMgb2YgYWxsIGZhY2VzIG9mIGh1bGwgQSwKICAgICAgLy8gdGhhdCBhcmUgYWRqYWNlbnQgdG8gdGhlIHdpdG5lc3MgZmFjZQoKCiAgICAgIGNvbnN0IG51bVZlcnRpY2VzQSA9IHBvbHlBLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXNBOyBpKyspIHsKICAgICAgICBjb25zdCBhID0gaHVsbEEudmVydGljZXNbcG9seUFbaV1dOwogICAgICAgIGNvbnN0IGIgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVsoaSArIDEpICUgbnVtVmVydGljZXNBXV07CiAgICAgICAgYS52c3ViKGIsIGVkZ2UwKTsKICAgICAgICBXb3JsZEVkZ2UwLmNvcHkoZWRnZTApOwogICAgICAgIHF1YXRBLnZtdWx0KFdvcmxkRWRnZTAsIFdvcmxkRWRnZTApOwogICAgICAgIHBvc0EudmFkZChXb3JsZEVkZ2UwLCBXb3JsZEVkZ2UwKTsKICAgICAgICB3b3JsZFBsYW5lQW5vcm1hbDEuY29weSh0aGlzLmZhY2VOb3JtYWxzW2Nsb3Nlc3RGYWNlQV0pOwogICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkUGxhbmVBbm9ybWFsMSwgd29ybGRQbGFuZUFub3JtYWwxKTsKICAgICAgICBwb3NBLnZhZGQod29ybGRQbGFuZUFub3JtYWwxLCB3b3JsZFBsYW5lQW5vcm1hbDEpOwogICAgICAgIFdvcmxkRWRnZTAuY3Jvc3Mod29ybGRQbGFuZUFub3JtYWwxLCBwbGFuZU5vcm1hbFdTMSk7CiAgICAgICAgcGxhbmVOb3JtYWxXUzEubmVnYXRlKHBsYW5lTm9ybWFsV1MxKTsKICAgICAgICB3b3JsZEExLmNvcHkoYSk7CiAgICAgICAgcXVhdEEudm11bHQod29ybGRBMSwgd29ybGRBMSk7CiAgICAgICAgcG9zQS52YWRkKHdvcmxkQTEsIHdvcmxkQTEpOwogICAgICAgIGNvbnN0IG90aGVyRmFjZSA9IHBvbHlBLmNvbm5lY3RlZEZhY2VzW2ldOwogICAgICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW290aGVyRmFjZV0pOwogICAgICAgIGNvbnN0IGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShvdGhlckZhY2UpOwogICAgICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTsKICAgICAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLCBwbGFuZU5vcm1hbFdTKTsKICAgICAgICBjb25zdCBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTsgLy8gQ2xpcCBmYWNlIGFnYWluc3Qgb3VyIGNvbnN0cnVjdGVkIHBsYW5lCgogICAgICAgIHRoaXMuY2xpcEZhY2VBZ2FpbnN0UGxhbmUocFZ0eEluLCBwVnR4T3V0LCBwbGFuZU5vcm1hbFdTLCBwbGFuZUVxV1MpOyAvLyBUaHJvdyBhd2F5IGFsbCBjbGlwcGVkIHBvaW50cywgYnV0IHNhdmUgdGhlIHJlbWFpbmluZyB1bnRpbCBuZXh0IGNsaXAKCiAgICAgICAgd2hpbGUgKHBWdHhJbi5sZW5ndGgpIHsKICAgICAgICAgIHBWdHhJbi5zaGlmdCgpOwogICAgICAgIH0KCiAgICAgICAgd2hpbGUgKHBWdHhPdXQubGVuZ3RoKSB7CiAgICAgICAgICBwVnR4SW4ucHVzaChwVnR4T3V0LnNoaWZ0KCkpOwogICAgICAgIH0KICAgICAgfSAvLyBvbmx5IGtlZXAgY29udGFjdCBwb2ludHMgdGhhdCBhcmUgYmVoaW5kIHRoZSB3aXRuZXNzIGZhY2UKCgogICAgICBsb2NhbFBsYW5lTm9ybWFsLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tjbG9zZXN0RmFjZUFdKTsKICAgICAgY29uc3QgbG9jYWxQbGFuZUVxID0gdGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKGNsb3Nlc3RGYWNlQSk7CiAgICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTsKICAgICAgcXVhdEEudm11bHQocGxhbmVOb3JtYWxXUywgcGxhbmVOb3JtYWxXUyk7CiAgICAgIGNvbnN0IHBsYW5lRXFXUyA9IGxvY2FsUGxhbmVFcSAtIHBsYW5lTm9ybWFsV1MuZG90KHBvc0EpOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwVnR4SW4ubGVuZ3RoOyBpKyspIHsKICAgICAgICBsZXQgZGVwdGggPSBwbGFuZU5vcm1hbFdTLmRvdChwVnR4SW5baV0pICsgcGxhbmVFcVdTOyAvLyA/Pz8KCiAgICAgICAgaWYgKGRlcHRoIDw9IG1pbkRpc3QpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKGBjbGFtcGVkOiBkZXB0aD0ke2RlcHRofSB0byBtaW5EaXN0PSR7bWluRGlzdH1gKTsKICAgICAgICAgIGRlcHRoID0gbWluRGlzdDsKICAgICAgICB9CgogICAgICAgIGlmIChkZXB0aCA8PSBtYXhEaXN0KSB7CiAgICAgICAgICBjb25zdCBwb2ludCA9IHBWdHhJbltpXTsKCiAgICAgICAgICBpZiAoZGVwdGggPD0gMWUtNikgewogICAgICAgICAgICBjb25zdCBwID0gewogICAgICAgICAgICAgIHBvaW50LAogICAgICAgICAgICAgIG5vcm1hbDogcGxhbmVOb3JtYWxXUywKICAgICAgICAgICAgICBkZXB0aAogICAgICAgICAgICB9OwogICAgICAgICAgICByZXN1bHQucHVzaChwKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2xpcCBhIGZhY2UgaW4gYSBodWxsIGFnYWluc3QgdGhlIGJhY2sgb2YgYSBwbGFuZS4KICAgICAqIEBwYXJhbSBwbGFuZUNvbnN0YW50IFRoZSBjb25zdGFudCBpbiB0aGUgbWF0aGVtYXRpY2FsIHBsYW5lIGVxdWF0aW9uCiAgICAgKi8KCgogICAgY2xpcEZhY2VBZ2FpbnN0UGxhbmUoaW5WZXJ0aWNlcywgb3V0VmVydGljZXMsIHBsYW5lTm9ybWFsLCBwbGFuZUNvbnN0YW50KSB7CiAgICAgIGxldCBuX2RvdF9maXJzdDsKICAgICAgbGV0IG5fZG90X2xhc3Q7CiAgICAgIGNvbnN0IG51bVZlcnRzID0gaW5WZXJ0aWNlcy5sZW5ndGg7CgogICAgICBpZiAobnVtVmVydHMgPCAyKSB7CiAgICAgICAgcmV0dXJuIG91dFZlcnRpY2VzOwogICAgICB9CgogICAgICBsZXQgZmlyc3RWZXJ0ZXggPSBpblZlcnRpY2VzW2luVmVydGljZXMubGVuZ3RoIC0gMV07CiAgICAgIGxldCBsYXN0VmVydGV4ID0gaW5WZXJ0aWNlc1swXTsKICAgICAgbl9kb3RfZmlyc3QgPSBwbGFuZU5vcm1hbC5kb3QoZmlyc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDsKCiAgICAgIGZvciAobGV0IHZpID0gMDsgdmkgPCBudW1WZXJ0czsgdmkrKykgewogICAgICAgIGxhc3RWZXJ0ZXggPSBpblZlcnRpY2VzW3ZpXTsKICAgICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDsKCiAgICAgICAgaWYgKG5fZG90X2ZpcnN0IDwgMCkgewogICAgICAgICAgaWYgKG5fZG90X2xhc3QgPCAwKSB7CiAgICAgICAgICAgIC8vIFN0YXJ0IDwgMCwgZW5kIDwgMCwgc28gb3V0cHV0IGxhc3RWZXJ0ZXgKICAgICAgICAgICAgY29uc3QgbmV3diA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIG5ld3YuY29weShsYXN0VmVydGV4KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIFN0YXJ0IDwgMCwgZW5kID49IDAsIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24KICAgICAgICAgICAgY29uc3QgbmV3diA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCwgbl9kb3RfZmlyc3QgLyAobl9kb3RfZmlyc3QgLSBuX2RvdF9sYXN0KSwgbmV3dik7CiAgICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChuX2RvdF9sYXN0IDwgMCkgewogICAgICAgICAgICAvLyBTdGFydCA+PSAwLCBlbmQgPCAwIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24gYW5kIGVuZAogICAgICAgICAgICBjb25zdCBuZXd2ID0gbmV3IFZlYzMoKTsKICAgICAgICAgICAgZmlyc3RWZXJ0ZXgubGVycChsYXN0VmVydGV4LCBuX2RvdF9maXJzdCAvIChuX2RvdF9maXJzdCAtIG5fZG90X2xhc3QpLCBuZXd2KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChsYXN0VmVydGV4KTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZpcnN0VmVydGV4ID0gbGFzdFZlcnRleDsKICAgICAgICBuX2RvdF9maXJzdCA9IG5fZG90X2xhc3Q7CiAgICAgIH0KCiAgICAgIHJldHVybiBvdXRWZXJ0aWNlczsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyBgLndvcmxkVmVydGljZXNgIGFuZCBzZXRzIGAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlYCB0byBmYWxzZS4KICAgICAqLwoKCiAgICBjb21wdXRlV29ybGRWZXJ0aWNlcyhwb3NpdGlvbiwgcXVhdCkgewogICAgICB3aGlsZSAodGhpcy53b3JsZFZlcnRpY2VzLmxlbmd0aCA8IHRoaXMudmVydGljZXMubGVuZ3RoKSB7CiAgICAgICAgdGhpcy53b3JsZFZlcnRpY2VzLnB1c2gobmV3IFZlYzMoKSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsKICAgICAgY29uc3Qgd29ybGRWZXJ0cyA9IHRoaXMud29ybGRWZXJ0aWNlczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgcXVhdC52bXVsdCh2ZXJ0c1tpXSwgd29ybGRWZXJ0c1tpXSk7CiAgICAgICAgcG9zaXRpb24udmFkZCh3b3JsZFZlcnRzW2ldLCB3b3JsZFZlcnRzW2ldKTsKICAgICAgfQoKICAgICAgdGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgPSBmYWxzZTsKICAgIH0KCiAgICBjb21wdXRlTG9jYWxBQUJCKGFhYmJtaW4sIGFhYmJtYXgpIHsKICAgICAgY29uc3QgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBhYWJibWluLnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTsKICAgICAgYWFiYm1heC5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gdmVydGljZXNbaV07CgogICAgICAgIGlmICh2LnggPCBhYWJibWluLngpIHsKICAgICAgICAgIGFhYmJtaW4ueCA9IHYueDsKICAgICAgICB9IGVsc2UgaWYgKHYueCA+IGFhYmJtYXgueCkgewogICAgICAgICAgYWFiYm1heC54ID0gdi54OwogICAgICAgIH0KCiAgICAgICAgaWYgKHYueSA8IGFhYmJtaW4ueSkgewogICAgICAgICAgYWFiYm1pbi55ID0gdi55OwogICAgICAgIH0gZWxzZSBpZiAodi55ID4gYWFiYm1heC55KSB7CiAgICAgICAgICBhYWJibWF4LnkgPSB2Lnk7CiAgICAgICAgfQoKICAgICAgICBpZiAodi56IDwgYWFiYm1pbi56KSB7CiAgICAgICAgICBhYWJibWluLnogPSB2Lno7CiAgICAgICAgfSBlbHNlIGlmICh2LnogPiBhYWJibWF4LnopIHsKICAgICAgICAgIGFhYmJtYXgueiA9IHYuejsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyBgd29ybGRWZXJ0aWNlc2AgYW5kIHNldHMgYHdvcmxkVmVydGljZXNOZWVkc1VwZGF0ZWAgdG8gZmFsc2UuCiAgICAgKi8KCgogICAgY29tcHV0ZVdvcmxkRmFjZU5vcm1hbHMocXVhdCkgewogICAgICBjb25zdCBOID0gdGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7CgogICAgICB3aGlsZSAodGhpcy53b3JsZEZhY2VOb3JtYWxzLmxlbmd0aCA8IE4pIHsKICAgICAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMucHVzaChuZXcgVmVjMygpKTsKICAgICAgfQoKICAgICAgY29uc3Qgbm9ybWFscyA9IHRoaXMuZmFjZU5vcm1hbHM7CiAgICAgIGNvbnN0IHdvcmxkTm9ybWFscyA9IHRoaXMud29ybGRGYWNlTm9ybWFsczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBxdWF0LnZtdWx0KG5vcm1hbHNbaV0sIHdvcmxkTm9ybWFsc1tpXSk7CiAgICAgIH0KCiAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXIKICAgICAgbGV0IG1heDIgPSAwOwogICAgICBjb25zdCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBub3JtMiA9IHZlcnRzW2ldLmxlbmd0aFNxdWFyZWQoKTsKCiAgICAgICAgaWYgKG5vcm0yID4gbWF4MikgewogICAgICAgICAgbWF4MiA9IG5vcm0yOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE1hdGguc3FydChtYXgyKTsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlV29ybGRBQUJCCiAgICAgKi8KCgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgY29uc3QgdmVydHMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBsZXQgbWlueDsKICAgICAgbGV0IG1pbnk7CiAgICAgIGxldCBtaW56OwogICAgICBsZXQgbWF4eDsKICAgICAgbGV0IG1heHk7CiAgICAgIGxldCBtYXh6OwogICAgICBsZXQgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICB0ZW1wV29ybGRWZXJ0ZXguY29weSh2ZXJ0c1tpXSk7CiAgICAgICAgcXVhdC52bXVsdCh0ZW1wV29ybGRWZXJ0ZXgsIHRlbXBXb3JsZFZlcnRleCk7CiAgICAgICAgcG9zLnZhZGQodGVtcFdvcmxkVmVydGV4LCB0ZW1wV29ybGRWZXJ0ZXgpOwogICAgICAgIGNvbnN0IHYgPSB0ZW1wV29ybGRWZXJ0ZXg7CgogICAgICAgIGlmIChtaW54ID09PSB1bmRlZmluZWQgfHwgdi54IDwgbWlueCkgewogICAgICAgICAgbWlueCA9IHYueDsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh4ID09PSB1bmRlZmluZWQgfHwgdi54ID4gbWF4eCkgewogICAgICAgICAgbWF4eCA9IHYueDsKICAgICAgICB9CgogICAgICAgIGlmIChtaW55ID09PSB1bmRlZmluZWQgfHwgdi55IDwgbWlueSkgewogICAgICAgICAgbWlueSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh5ID09PSB1bmRlZmluZWQgfHwgdi55ID4gbWF4eSkgewogICAgICAgICAgbWF4eSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmIChtaW56ID09PSB1bmRlZmluZWQgfHwgdi56IDwgbWlueikgewogICAgICAgICAgbWlueiA9IHYuejsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh6ID09PSB1bmRlZmluZWQgfHwgdi56ID4gbWF4eikgewogICAgICAgICAgbWF4eiA9IHYuejsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIG1pbi5zZXQobWlueCwgbWlueSwgbWlueik7CiAgICAgIG1heC5zZXQobWF4eCwgbWF4eSwgbWF4eik7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhcHByb3hpbWF0ZSBjb252ZXggdm9sdW1lCiAgICAgKi8KCgogICAgdm9sdW1lKCkgewogICAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgLyAzLjA7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBhdmVyYWdlIG9mIGFsbCB0aGUgdmVydGljZXMgcG9zaXRpb25zCiAgICAgKi8KCgogICAgZ2V0QXZlcmFnZVBvaW50TG9jYWwodGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICB0YXJnZXQudmFkZCh2ZXJ0c1tpXSwgdGFyZ2V0KTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnNjYWxlKDEgLyB2ZXJ0cy5sZW5ndGgsIHRhcmdldCk7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIFRyYW5zZm9ybSBhbGwgbG9jYWwgcG9pbnRzLiBXaWxsIGNoYW5nZSB0aGUgLnZlcnRpY2VzCiAgICAgKi8KCgogICAgdHJhbnNmb3JtQWxsUG9pbnRzKG9mZnNldCwgcXVhdCkgewogICAgICBjb25zdCBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7CiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsgLy8gQXBwbHkgcm90YXRpb24KCiAgICAgIGlmIChxdWF0KSB7CiAgICAgICAgLy8gUm90YXRlIHZlcnRpY2VzCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHYgPSB2ZXJ0c1tpXTsKICAgICAgICAgIHF1YXQudm11bHQodiwgdik7CiAgICAgICAgfSAvLyBSb3RhdGUgZmFjZSBub3JtYWxzCgoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmZhY2VOb3JtYWxzW2ldOwogICAgICAgICAgcXVhdC52bXVsdCh2LCB2KTsKICAgICAgICB9CiAgICAgICAgLyoKICAgICAgICAgICAgICAvLyBSb3RhdGUgZWRnZXMKICAgICAgICAgICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgaSsrKXsKICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMudW5pcXVlRWRnZXNbaV07CiAgICAgICAgICAgICAgICAgIHF1YXQudm11bHQodix2KTsKICAgICAgICAgICAgICB9Ki8KCiAgICAgIH0gLy8gQXBwbHkgb2Zmc2V0CgoKICAgICAgaWYgKG9mZnNldCkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7CiAgICAgICAgICBjb25zdCB2ID0gdmVydHNbaV07CiAgICAgICAgICB2LnZhZGQob2Zmc2V0LCB2KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgcCBpcyBpbnNpZGUgdGhlIHBvbHloZWRyYS4gTXVzdCBiZSBpbiBsb2NhbCBjb29yZHMuCiAgICAgKiBUaGUgcG9pbnQgbGllcyBvdXRzaWRlIG9mIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgb3RoZXIgcG9pbnRzIGlmIGFuZCBvbmx5IGlmIHRoZSBkaXJlY3Rpb24KICAgICAqIG9mIGFsbCB0aGUgdmVjdG9ycyBmcm9tIGl0IHRvIHRob3NlIG90aGVyIHBvaW50cyBhcmUgb24gbGVzcyB0aGFuIG9uZSBoYWxmIG9mIGEgc3BoZXJlIGFyb3VuZCBpdC4KICAgICAqIEBwYXJhbSBwIEEgcG9pbnQgZ2l2ZW4gaW4gbG9jYWwgY29vcmRpbmF0ZXMKICAgICAqLwoKCiAgICBwb2ludElzSW5zaWRlKHApIHsKICAgICAgY29uc3QgdmVydHMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBjb25zdCBmYWNlcyA9IHRoaXMuZmFjZXM7CiAgICAgIGNvbnN0IG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzOwogICAgICBjb25zdCBwb3NpdGl2ZVJlc3VsdCA9IG51bGw7CiAgICAgIGNvbnN0IHBvaW50SW5zaWRlID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5nZXRBdmVyYWdlUG9pbnRMb2NhbChwb2ludEluc2lkZSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBsZXQgbiA9IG5vcm1hbHNbaV07CiAgICAgICAgY29uc3QgdiA9IHZlcnRzW2ZhY2VzW2ldWzBdXTsgLy8gV2Ugb25seSBuZWVkIG9uZSBwb2ludCBpbiB0aGUgZmFjZQogICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpcwoKICAgICAgICBjb25zdCB2VG9QID0gbmV3IFZlYzMoKTsKICAgICAgICBwLnZzdWIodiwgdlRvUCk7CiAgICAgICAgY29uc3QgcjEgPSBuLmRvdCh2VG9QKTsKICAgICAgICBjb25zdCB2VG9Qb2ludEluc2lkZSA9IG5ldyBWZWMzKCk7CiAgICAgICAgcG9pbnRJbnNpZGUudnN1Yih2LCB2VG9Qb2ludEluc2lkZSk7CiAgICAgICAgY29uc3QgcjIgPSBuLmRvdCh2VG9Qb2ludEluc2lkZSk7CgogICAgICAgIGlmIChyMSA8IDAgJiYgcjIgPiAwIHx8IHIxID4gMCAmJiByMiA8IDApIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRW5jb3VudGVyZWQgc29tZSBvdGhlciBzaWduLiBFeGl0LgogICAgICAgIH0KICAgICAgfSAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uCgoKICAgICAgcmV0dXJuIHBvc2l0aXZlUmVzdWx0ID8gMSA6IC0xOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgbWF4IGFuZCBtaW4gZG90IHByb2R1Y3Qgb2YgYSBjb252ZXggaHVsbCBhdCBwb3NpdGlvbiAocG9zLHF1YXQpIHByb2plY3RlZCBvbnRvIGFuIGF4aXMuCiAgICAgKiBSZXN1bHRzIGFyZSBzYXZlZCBpbiB0aGUgYXJyYXkgbWF4bWluLgogICAgICogQHBhcmFtIHJlc3VsdCByZXN1bHRbMF0gYW5kIHJlc3VsdFsxXSB3aWxsIGJlIHNldCB0byBtYXhpbXVtIGFuZCBtaW5pbXVtLCByZXNwZWN0aXZlbHkuCiAgICAgKi8KCgogICAgc3RhdGljIHByb2plY3Qoc2hhcGUsIGF4aXMsIHBvcywgcXVhdCwgcmVzdWx0KSB7CiAgICAgIGNvbnN0IG4gPSBzaGFwZS52ZXJ0aWNlcy5sZW5ndGg7CiAgICAgIGNvbnN0IGxvY2FsQXhpcyA9IHByb2plY3RfbG9jYWxBeGlzOwogICAgICBsZXQgbWF4ID0gMDsKICAgICAgbGV0IG1pbiA9IDA7CiAgICAgIGNvbnN0IGxvY2FsT3JpZ2luID0gcHJvamVjdF9sb2NhbE9yaWdpbjsKICAgICAgY29uc3QgdnMgPSBzaGFwZS52ZXJ0aWNlczsKICAgICAgbG9jYWxPcmlnaW4uc2V0WmVybygpOyAvLyBUcmFuc2Zvcm0gdGhlIGF4aXMgdG8gbG9jYWwKCiAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBheGlzLCBsb2NhbEF4aXMpOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBsb2NhbE9yaWdpbiwgbG9jYWxPcmlnaW4pOwogICAgICBjb25zdCBhZGQgPSBsb2NhbE9yaWdpbi5kb3QobG9jYWxBeGlzKTsKICAgICAgbWluID0gbWF4ID0gdnNbMF0uZG90KGxvY2FsQXhpcyk7CgogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykgewogICAgICAgIGNvbnN0IHZhbCA9IHZzW2ldLmRvdChsb2NhbEF4aXMpOwoKICAgICAgICBpZiAodmFsID4gbWF4KSB7CiAgICAgICAgICBtYXggPSB2YWw7CiAgICAgICAgfQoKICAgICAgICBpZiAodmFsIDwgbWluKSB7CiAgICAgICAgICBtaW4gPSB2YWw7CiAgICAgICAgfQogICAgICB9CgogICAgICBtaW4gLT0gYWRkOwogICAgICBtYXggLT0gYWRkOwoKICAgICAgaWYgKG1pbiA+IG1heCkgewogICAgICAgIC8vIEluY29uc2lzdGVudCAtIHN3YXAKICAgICAgICBjb25zdCB0ZW1wID0gbWluOwogICAgICAgIG1pbiA9IG1heDsKICAgICAgICBtYXggPSB0ZW1wOwogICAgICB9IC8vIE91dHB1dAoKCiAgICAgIHJlc3VsdFswXSA9IG1heDsKICAgICAgcmVzdWx0WzFdID0gbWluOwogICAgfQoKICB9CiAgY29uc3QgbWF4bWluQSA9IFtdOwogIGNvbnN0IG1heG1pbkIgPSBbXTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHByb2plY3RfbG9jYWxBeGlzID0gbmV3IFZlYzMoKTsKICBjb25zdCBwcm9qZWN0X2xvY2FsT3JpZ2luID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQSAzZCBib3ggc2hhcGUuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3Qgc2l6ZSA9IDEKICAgKiAgICAgY29uc3QgaGFsZkV4dGVudHMgPSBuZXcgQ0FOTk9OLlZlYzMoc2l6ZSwgc2l6ZSwgc2l6ZSkKICAgKiAgICAgY29uc3QgYm94U2hhcGUgPSBuZXcgQ0FOTk9OLkJveChoYWxmRXh0ZW50cykKICAgKiAgICAgY29uc3QgYm94Qm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBib3hTaGFwZSB9KQogICAqICAgICB3b3JsZC5hZGRCb2R5KGJveEJvZHkpCiAgICovCiAgY2xhc3MgQm94IGV4dGVuZHMgU2hhcGUgewogICAgLyoqCiAgICAgKiBUaGUgaGFsZiBleHRlbnRzIG9mIHRoZSBib3guCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZWQgYnkgdGhlIGNvbnRhY3QgZ2VuZXJhdG9yIHRvIG1ha2UgY29udGFjdHMgd2l0aCBvdGhlciBjb252ZXggcG9seWhlZHJhIGZvciBleGFtcGxlLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihoYWxmRXh0ZW50cykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuQk9YCiAgICAgIH0pOwogICAgICB0aGlzLmhhbGZFeHRlbnRzID0gaGFsZkV4dGVudHM7CiAgICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gbnVsbDsKICAgICAgdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBjb252ZXggcG9seWhlZHJvbiByZXByZXNlbnRhdGlvbiB1c2VkIGZvciBzb21lIGNvbGxpc2lvbnMuCiAgICAgKi8KCgogICAgdXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uKCkgewogICAgICBjb25zdCBzeCA9IHRoaXMuaGFsZkV4dGVudHMueDsKICAgICAgY29uc3Qgc3kgPSB0aGlzLmhhbGZFeHRlbnRzLnk7CiAgICAgIGNvbnN0IHN6ID0gdGhpcy5oYWxmRXh0ZW50cy56OwogICAgICBjb25zdCBWID0gVmVjMzsKICAgICAgY29uc3QgdmVydGljZXMgPSBbbmV3IFYoLXN4LCAtc3ksIC1zeiksIG5ldyBWKHN4LCAtc3ksIC1zeiksIG5ldyBWKHN4LCBzeSwgLXN6KSwgbmV3IFYoLXN4LCBzeSwgLXN6KSwgbmV3IFYoLXN4LCAtc3ksIHN6KSwgbmV3IFYoc3gsIC1zeSwgc3opLCBuZXcgVihzeCwgc3ksIHN6KSwgbmV3IFYoLXN4LCBzeSwgc3opXTsKICAgICAgY29uc3QgZmFjZXMgPSBbWzMsIDIsIDEsIDBdLCAvLyAtegogICAgICBbNCwgNSwgNiwgN10sIC8vICt6CiAgICAgIFs1LCA0LCAwLCAxXSwgLy8gLXkKICAgICAgWzIsIDMsIDcsIDZdLCAvLyAreQogICAgICBbMCwgNCwgNywgM10sIC8vIC14CiAgICAgIFsxLCAyLCA2LCA1XSAvLyAreAogICAgICBdOwogICAgICBjb25zdCBheGVzID0gW25ldyBWKDAsIDAsIDEpLCBuZXcgVigwLCAxLCAwKSwgbmV3IFYoMSwgMCwgMCldOwogICAgICBjb25zdCBoID0gbmV3IENvbnZleFBvbHloZWRyb24oewogICAgICAgIHZlcnRpY2VzLAogICAgICAgIGZhY2VzLAogICAgICAgIGF4ZXMKICAgICAgfSk7CiAgICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gaDsKICAgICAgaC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7CiAgICB9CiAgICAvKioKICAgICAqIENhbGN1bGF0ZSB0aGUgaW5lcnRpYSBvZiB0aGUgYm94LgogICAgICovCgoKICAgIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEodGhpcy5oYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KTsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KCiAgICBzdGF0aWMgY2FsY3VsYXRlSW5lcnRpYShoYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGUgPSBoYWxmRXh0ZW50czsKICAgICAgdGFyZ2V0LnggPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS55ICogMiAqIGUueSArIDIgKiBlLnogKiAyICogZS56KTsKICAgICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS54ICogMiAqIGUueCArIDIgKiBlLnogKiAyICogZS56KTsKICAgICAgdGFyZ2V0LnogPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS55ICogMiAqIGUueSArIDIgKiBlLnggKiAyICogZS54KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBib3ggNiBzaWRlIG5vcm1hbHMKICAgICAqIEBwYXJhbSBzaXhUYXJnZXRWZWN0b3JzIEFuIGFycmF5IG9mIDYgdmVjdG9ycywgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIG5vcm1hbHMgaW4uCiAgICAgKiBAcGFyYW0gcXVhdCBPcmllbnRhdGlvbiB0byBhcHBseSB0byB0aGUgbm9ybWFsIHZlY3RvcnMuIElmIG5vdCBwcm92aWRlZCwgdGhlIHZlY3RvcnMgd2lsbCBiZSBpbiByZXNwZWN0IHRvIHRoZSBsb2NhbCBmcmFtZS4KICAgICAqLwoKCiAgICBnZXRTaWRlTm9ybWFscyhzaXhUYXJnZXRWZWN0b3JzLCBxdWF0KSB7CiAgICAgIGNvbnN0IHNpZGVzID0gc2l4VGFyZ2V0VmVjdG9yczsKICAgICAgY29uc3QgZXggPSB0aGlzLmhhbGZFeHRlbnRzOwogICAgICBzaWRlc1swXS5zZXQoZXgueCwgMCwgMCk7CiAgICAgIHNpZGVzWzFdLnNldCgwLCBleC55LCAwKTsKICAgICAgc2lkZXNbMl0uc2V0KDAsIDAsIGV4LnopOwogICAgICBzaWRlc1szXS5zZXQoLWV4LngsIDAsIDApOwogICAgICBzaWRlc1s0XS5zZXQoMCwgLWV4LnksIDApOwogICAgICBzaWRlc1s1XS5zZXQoMCwgMCwgLWV4LnopOwoKICAgICAgaWYgKHF1YXQgIT09IHVuZGVmaW5lZCkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzaWRlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgcXVhdC52bXVsdChzaWRlc1tpXSwgc2lkZXNbaV0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHNpZGVzOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSB2b2x1bWUgb2YgdGhlIGJveC4KICAgICAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA4LjAgKiB0aGlzLmhhbGZFeHRlbnRzLnggKiB0aGlzLmhhbGZFeHRlbnRzLnkgKiB0aGlzLmhhbGZFeHRlbnRzLno7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLmhhbGZFeHRlbnRzLmxlbmd0aCgpOwogICAgfQogICAgLyoqCiAgICAgKiBmb3JFYWNoV29ybGRDb3JuZXIKICAgICAqLwoKCiAgICBmb3JFYWNoV29ybGRDb3JuZXIocG9zLCBxdWF0LCBjYWxsYmFjaykgewogICAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50czsKICAgICAgY29uc3QgY29ybmVycyA9IFtbZS54LCBlLnksIGUuel0sIFstZS54LCBlLnksIGUuel0sIFstZS54LCAtZS55LCBlLnpdLCBbLWUueCwgLWUueSwgLWUuel0sIFtlLngsIC1lLnksIC1lLnpdLCBbZS54LCBlLnksIC1lLnpdLCBbLWUueCwgZS55LCAtZS56XSwgW2UueCwgLWUueSwgZS56XV07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcm5lcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICB3b3JsZENvcm5lclRlbXBQb3Muc2V0KGNvcm5lcnNbaV1bMF0sIGNvcm5lcnNbaV1bMV0sIGNvcm5lcnNbaV1bMl0pOwogICAgICAgIHF1YXQudm11bHQod29ybGRDb3JuZXJUZW1wUG9zLCB3b3JsZENvcm5lclRlbXBQb3MpOwogICAgICAgIHBvcy52YWRkKHdvcmxkQ29ybmVyVGVtcFBvcywgd29ybGRDb3JuZXJUZW1wUG9zKTsKICAgICAgICBjYWxsYmFjayh3b3JsZENvcm5lclRlbXBQb3MueCwgd29ybGRDb3JuZXJUZW1wUG9zLnksIHdvcmxkQ29ybmVyVGVtcFBvcy56KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBjYWxjdWxhdGVXb3JsZEFBQkIKICAgICAqLwoKCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50czsKICAgICAgd29ybGRDb3JuZXJzVGVtcFswXS5zZXQoZS54LCBlLnksIGUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbMV0uc2V0KC1lLngsIGUueSwgZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFsyXS5zZXQoLWUueCwgLWUueSwgZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFszXS5zZXQoLWUueCwgLWUueSwgLWUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbNF0uc2V0KGUueCwgLWUueSwgLWUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbNV0uc2V0KGUueCwgZS55LCAtZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFs2XS5zZXQoLWUueCwgZS55LCAtZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFs3XS5zZXQoZS54LCAtZS55LCBlLnopOwogICAgICBjb25zdCB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbMF07CiAgICAgIHF1YXQudm11bHQod2MsIHdjKTsKICAgICAgcG9zLnZhZGQod2MsIHdjKTsKICAgICAgbWF4LmNvcHkod2MpOwogICAgICBtaW4uY29weSh3Yyk7CgogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykgewogICAgICAgIGNvbnN0IHdjID0gd29ybGRDb3JuZXJzVGVtcFtpXTsKICAgICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7CiAgICAgICAgcG9zLnZhZGQod2MsIHdjKTsKICAgICAgICBjb25zdCB4ID0gd2MueDsKICAgICAgICBjb25zdCB5ID0gd2MueTsKICAgICAgICBjb25zdCB6ID0gd2MuejsKCiAgICAgICAgaWYgKHggPiBtYXgueCkgewogICAgICAgICAgbWF4LnggPSB4OwogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPiBtYXgueSkgewogICAgICAgICAgbWF4LnkgPSB5OwogICAgICAgIH0KCiAgICAgICAgaWYgKHogPiBtYXgueikgewogICAgICAgICAgbWF4LnogPSB6OwogICAgICAgIH0KCiAgICAgICAgaWYgKHggPCBtaW4ueCkgewogICAgICAgICAgbWluLnggPSB4OwogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPCBtaW4ueSkgewogICAgICAgICAgbWluLnkgPSB5OwogICAgICAgIH0KCiAgICAgICAgaWYgKHogPCBtaW4ueikgewogICAgICAgICAgbWluLnogPSB6OwogICAgICAgIH0KICAgICAgfSAvLyBHZXQgZWFjaCBheGlzIG1heAogICAgICAvLyBtaW4uc2V0KEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTsKICAgICAgLy8gbWF4LnNldCgtSW5maW5pdHksLUluZmluaXR5LC1JbmZpbml0eSk7CiAgICAgIC8vIHRoaXMuZm9yRWFjaFdvcmxkQ29ybmVyKHBvcyxxdWF0LGZ1bmN0aW9uKHgseSx6KXsKICAgICAgLy8gICAgIGlmKHggPiBtYXgueCl7CiAgICAgIC8vICAgICAgICAgbWF4LnggPSB4OwogICAgICAvLyAgICAgfQogICAgICAvLyAgICAgaWYoeSA+IG1heC55KXsKICAgICAgLy8gICAgICAgICBtYXgueSA9IHk7CiAgICAgIC8vICAgICB9CiAgICAgIC8vICAgICBpZih6ID4gbWF4LnopewogICAgICAvLyAgICAgICAgIG1heC56ID0gejsKICAgICAgLy8gICAgIH0KICAgICAgLy8gICAgIGlmKHggPCBtaW4ueCl7CiAgICAgIC8vICAgICAgICAgbWluLnggPSB4OwogICAgICAvLyAgICAgfQogICAgICAvLyAgICAgaWYoeSA8IG1pbi55KXsKICAgICAgLy8gICAgICAgICBtaW4ueSA9IHk7CiAgICAgIC8vICAgICB9CiAgICAgIC8vICAgICBpZih6IDwgbWluLnopewogICAgICAvLyAgICAgICAgIG1pbi56ID0gejsKICAgICAgLy8gICAgIH0KICAgICAgLy8gfSk7CgogICAgfQoKICB9CiAgY29uc3Qgd29ybGRDb3JuZXJUZW1wUG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCB3b3JsZENvcm5lcnNUZW1wID0gW25ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCldOwoKICAvKioKICAgKiBCT0RZX1RZUEVTCiAgICovCiAgY29uc3QgQk9EWV9UWVBFUyA9IHsKICAgIC8qKiBEWU5BTUlDICovCiAgICBEWU5BTUlDOiAxLAoKICAgIC8qKiBTVEFUSUMgKi8KICAgIFNUQVRJQzogMiwKCiAgICAvKiogS0lORU1BVElDICovCiAgICBLSU5FTUFUSUM6IDQKICB9OwogIC8qKgogICAqIEJvZHlUeXBlCiAgICovCgogIC8qKgogICAqIEJPRFlfU0xFRVBfU1RBVEVTCiAgICovCiAgY29uc3QgQk9EWV9TTEVFUF9TVEFURVMgPSB7CiAgICAvKiogQVdBS0UgKi8KICAgIEFXQUtFOiAwLAoKICAgIC8qKiBTTEVFUFkgKi8KICAgIFNMRUVQWTogMSwKCiAgICAvKiogU0xFRVBJTkcgKi8KICAgIFNMRUVQSU5HOiAyCiAgfTsKICAvKioKICAgKiBCb2R5U2xlZXBTdGF0ZQogICAqLwoKICAvKioKICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgYm9keSB0eXBlcy4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBzaGFwZSA9IG5ldyBDQU5OT04uU3BoZXJlKDEpCiAgICogICAgIGNvbnN0IGJvZHkgPSBuZXcgQ0FOTk9OLkJvZHkoewogICAqICAgICAgIG1hc3M6IDEsCiAgICogICAgICAgc2hhcGUsCiAgICogICAgIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSkKICAgKi8KICBjbGFzcyBCb2R5IGV4dGVuZHMgRXZlbnRUYXJnZXQgewogICAgLyoqCiAgICAgKiBEaXNwYXRjaGVkIGFmdGVyIHR3byBib2RpZXMgY29sbGlkZS4gVGhpcyBldmVudCBpcyBkaXNwYXRjaGVkIG9uIGVhY2gKICAgICAqIG9mIHRoZSB0d28gYm9kaWVzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uCiAgICAgKiBAZXZlbnQgY29sbGlkZQogICAgICogQHBhcmFtIGJvZHkgVGhlIGJvZHkgdGhhdCB3YXMgaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvbi4KICAgICAqIEBwYXJhbSBjb250YWN0IFRoZSBkZXRhaWxzIG9mIHRoZSBjb2xsaXNpb24uCiAgICAgKi8KCiAgICAvKioKICAgICAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC4gQ2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBidXQgbm9ybWFsbHkgdGhleSBtb3ZlIGFjY29yZGluZyB0byBmb3JjZXMuIEEgZHluYW1pYyBib2R5IGNhbiBjb2xsaWRlIHdpdGggYWxsIGJvZHkgdHlwZXMuIEEgZHluYW1pYyBib2R5IGFsd2F5cyBoYXMgZmluaXRlLCBub24temVybyBtYXNzLgogICAgICovCgogICAgLyoqCiAgICAgKiBBIHN0YXRpYyBib2R5IGRvZXMgbm90IG1vdmUgZHVyaW5nIHNpbXVsYXRpb24gYW5kIGJlaGF2ZXMgYXMgaWYgaXQgaGFzIGluZmluaXRlIG1hc3MuIFN0YXRpYyBib2RpZXMgY2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHNldHRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5LiBUaGUgdmVsb2NpdHkgb2YgYSBzdGF0aWMgYm9keSBpcyBhbHdheXMgemVyby4gU3RhdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIHN0YXRpYyBvciBraW5lbWF0aWMgYm9kaWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBBIGtpbmVtYXRpYyBib2R5IG1vdmVzIHVuZGVyIHNpbXVsYXRpb24gYWNjb3JkaW5nIHRvIGl0cyB2ZWxvY2l0eS4gVGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMuIFRoZXkgY2FuIGJlIG1vdmVkIG1hbnVhbGx5LCBidXQgbm9ybWFsbHkgYSBraW5lbWF0aWMgYm9keSBpcyBtb3ZlZCBieSBzZXR0aW5nIGl0cyB2ZWxvY2l0eS4gQSBraW5lbWF0aWMgYm9keSBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFXQUtFCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNMRUVQWQogICAgICovCgogICAgLyoqCiAgICAgKiBTTEVFUElORwogICAgICovCgogICAgLyoqCiAgICAgKiBEaXNwYXRjaGVkIGFmdGVyIGEgc2xlZXBpbmcgYm9keSBoYXMgd29rZW4gdXAuCiAgICAgKiBAZXZlbnQgd2FrZXVwCiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBnb25lIGluIHRvIHRoZSBzbGVlcHkgc3RhdGUuCiAgICAgKiBAZXZlbnQgc2xlZXB5CiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBmYWxsZW4gYXNsZWVwLgogICAgICogQGV2ZW50IHNsZWVwCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pZCA9IEJvZHkuaWRDb3VudGVyKys7CiAgICAgIHRoaXMuaW5kZXggPSAtMTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMudmxhbWJkYSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Ygb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mIG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgOiAtMTsKICAgICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTsKICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmluaXRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbikgewogICAgICAgIHRoaXMucG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7CiAgICAgICAgdGhpcy5pbml0UG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgfQoKICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy52ZWxvY2l0eSkgewogICAgICAgIHRoaXMudmVsb2NpdHkuY29weShvcHRpb25zLnZlbG9jaXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmZvcmNlID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgbWFzcyA9IHR5cGVvZiBvcHRpb25zLm1hc3MgPT09ICdudW1iZXInID8gb3B0aW9ucy5tYXNzIDogMDsKICAgICAgdGhpcy5tYXNzID0gbWFzczsKICAgICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDsKICAgICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgfHwgbnVsbDsKICAgICAgdGhpcy5saW5lYXJEYW1waW5nID0gdHlwZW9mIG9wdGlvbnMubGluZWFyRGFtcGluZyA9PT0gJ251bWJlcicgPyBvcHRpb25zLmxpbmVhckRhbXBpbmcgOiAwLjAxOwogICAgICB0aGlzLnR5cGUgPSBtYXNzIDw9IDAuMCA/IEJvZHkuU1RBVElDIDogQm9keS5EWU5BTUlDOwoKICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgPT09IHR5cGVvZiBCb2R5LlNUQVRJQykgewogICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTsKICAgICAgfQoKICAgICAgdGhpcy5hbGxvd1NsZWVwID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dTbGVlcCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFsbG93U2xlZXAgOiB0cnVlOwogICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFOwogICAgICB0aGlzLnNsZWVwU3BlZWRMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCA6IDAuMTsKICAgICAgdGhpcy5zbGVlcFRpbWVMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnNsZWVwVGltZUxpbWl0ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc2xlZXBUaW1lTGltaXQgOiAxOwogICAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CiAgICAgIHRoaXMudG9ycXVlID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgdGhpcy5pbml0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgICAgIGlmIChvcHRpb25zLnF1YXRlcm5pb24pIHsKICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICAgIHRoaXMuaW5pdFF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTsKICAgICAgICB0aGlzLmludGVycG9sYXRlZFF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICB9CgogICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpIHsKICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5pbml0QW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5zaGFwZXMgPSBbXTsKICAgICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTsKICAgICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucyA9IFtdOwogICAgICB0aGlzLmluZXJ0aWEgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWEgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWFXb3JsZCA9IG5ldyBNYXQzKCk7CiAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDsKICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlID0gbmV3IE1hdDMoKTsKICAgICAgdGhpcy5maXhlZFJvdGF0aW9uID0gdHlwZW9mIG9wdGlvbnMuZml4ZWRSb3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmZpeGVkUm90YXRpb24gOiBmYWxzZTsKICAgICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZiBvcHRpb25zLmFuZ3VsYXJEYW1waW5nICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcgOiAwLjAxOwogICAgICB0aGlzLmxpbmVhckZhY3RvciA9IG5ldyBWZWMzKDEsIDEsIDEpOwoKICAgICAgaWYgKG9wdGlvbnMubGluZWFyRmFjdG9yKSB7CiAgICAgICAgdGhpcy5saW5lYXJGYWN0b3IuY29weShvcHRpb25zLmxpbmVhckZhY3Rvcik7CiAgICAgIH0KCiAgICAgIHRoaXMuYW5ndWxhckZhY3RvciA9IG5ldyBWZWMzKDEsIDEsIDEpOwoKICAgICAgaWYgKG9wdGlvbnMuYW5ndWxhckZhY3RvcikgewogICAgICAgIHRoaXMuYW5ndWxhckZhY3Rvci5jb3B5KG9wdGlvbnMuYW5ndWxhckZhY3Rvcik7CiAgICAgIH0KCiAgICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7CiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7CiAgICAgIHRoaXMud2xhbWJkYSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaXNUcmlnZ2VyID0gQm9vbGVhbihvcHRpb25zLmlzVHJpZ2dlcik7CgogICAgICBpZiAob3B0aW9ucy5zaGFwZSkgewogICAgICAgIHRoaXMuYWRkU2hhcGUob3B0aW9ucy5zaGFwZSk7CiAgICAgIH0KCiAgICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTsKICAgIH0KICAgIC8qKgogICAgICogV2FrZSB0aGUgYm9keSB1cC4KICAgICAqLwoKCiAgICB3YWtlVXAoKSB7CiAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc2xlZXBTdGF0ZTsKICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CgogICAgICBpZiAocHJldlN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSB7CiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEJvZHkud2FrZXVwRXZlbnQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEZvcmNlIGJvZHkgc2xlZXAKICAgICAqLwoKCiAgICBzbGVlcCgpIHsKICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORzsKICAgICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7CiAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnNldCgwLCAwLCAwKTsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuCiAgICAgKiBAcGFyYW0gdGltZSBUaGUgd29ybGQgdGltZSBpbiBzZWNvbmRzCiAgICAgKi8KCgogICAgc2xlZXBUaWNrKHRpbWUpIHsKICAgICAgaWYgKHRoaXMuYWxsb3dTbGVlcCkgewogICAgICAgIGNvbnN0IHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7CiAgICAgICAgY29uc3Qgc3BlZWRTcXVhcmVkID0gdGhpcy52ZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCkgKyB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCk7CiAgICAgICAgY29uc3Qgc3BlZWRMaW1pdFNxdWFyZWQgPSB0aGlzLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICBpZiAoc2xlZXBTdGF0ZSA9PT0gQm9keS5BV0FLRSAmJiBzcGVlZFNxdWFyZWQgPCBzcGVlZExpbWl0U3F1YXJlZCkgewogICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7IC8vIFNsZWVweQoKICAgICAgICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSB0aW1lOwogICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEJvZHkuc2xlZXB5RXZlbnQpOwogICAgICAgIH0gZWxzZSBpZiAoc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUFkgJiYgc3BlZWRTcXVhcmVkID4gc3BlZWRMaW1pdFNxdWFyZWQpIHsKICAgICAgICAgIHRoaXMud2FrZVVwKCk7IC8vIFdha2UgdXAKICAgICAgICB9IGVsc2UgaWYgKHNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBZICYmIHRpbWUgLSB0aGlzLnRpbWVMYXN0U2xlZXB5ID4gdGhpcy5zbGVlcFRpbWVMaW1pdCkgewogICAgICAgICAgdGhpcy5zbGVlcCgpOyAvLyBTbGVlcGluZwoKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5LnNsZWVwRXZlbnQpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBJZiB0aGUgYm9keSBpcyBzbGVlcGluZywgaXQgc2hvdWxkIGJlIGltbW92YWJsZSAvIGhhdmUgaW5maW5pdGUgbWFzcyBkdXJpbmcgc29sdmUuIFdlIHNvbHZlIGl0IGJ5IGhhdmluZyBhIHNlcGFyYXRlICJzb2x2ZSBtYXNzIi4KICAgICAqLwoKCiAgICB1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCkgewogICAgICBpZiAodGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpIHsKICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7CiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpOwogICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuc2V0WmVybygpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gdGhpcy5pbnZNYXNzOwogICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhKTsKICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLgogICAgICovCgoKICAgIHBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkUG9pbnQsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbiwgcmVzdWx0KTsKICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHJlc3VsdCwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCBhIHdvcmxkIHZlY3RvciB0byBsb2NhbCBib2R5IGZyYW1lLgogICAgICovCgoKICAgIHZlY3RvclRvTG9jYWxGcmFtZSh3b3JsZFZlY3RvciwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCBhIGxvY2FsIGJvZHkgcG9pbnQgdG8gd29ybGQgZnJhbWUuCiAgICAgKi8KCgogICAgcG9pbnRUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFBvaW50LCByZXN1bHQpOwogICAgICByZXN1bHQudmFkZCh0aGlzLnBvc2l0aW9uLCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS4KICAgICAqLwoKCiAgICB2ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5IHdpdGggYSBsb2NhbCBvZmZzZXQgYW5kIG9yaWVudGF0aW9uLgogICAgICogQHJldHVybiBUaGUgYm9keSBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuCiAgICAgKi8KCgogICAgYWRkU2hhcGUoc2hhcGUsIF9vZmZzZXQsIF9vcmllbnRhdGlvbikgewogICAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBvcmllbnRhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7CgogICAgICBpZiAoX29mZnNldCkgewogICAgICAgIG9mZnNldC5jb3B5KF9vZmZzZXQpOwogICAgICB9CgogICAgICBpZiAoX29yaWVudGF0aW9uKSB7CiAgICAgICAgb3JpZW50YXRpb24uY29weShfb3JpZW50YXRpb24pOwogICAgICB9CgogICAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlKTsKICAgICAgdGhpcy5zaGFwZU9mZnNldHMucHVzaChvZmZzZXQpOwogICAgICB0aGlzLnNoYXBlT3JpZW50YXRpb25zLnB1c2gob3JpZW50YXRpb24pOwogICAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7CiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTsKICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlOwogICAgICBzaGFwZS5ib2R5ID0gdGhpczsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZSBhIHNoYXBlIGZyb20gdGhlIGJvZHkuCiAgICAgKiBAcmV0dXJuIFRoZSBib2R5IG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS4KICAgICAqLwoKCiAgICByZW1vdmVTaGFwZShzaGFwZSkgewogICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2hhcGVzLmluZGV4T2Yoc2hhcGUpOwoKICAgICAgaWYgKGluZGV4ID09PSAtMSkgewogICAgICAgIGNvbnNvbGUud2FybignU2hhcGUgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBib2R5Jyk7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIHRoaXMuc2hhcGVzLnNwbGljZShpbmRleCwgMSk7CiAgICAgIHRoaXMuc2hhcGVPZmZzZXRzLnNwbGljZShpbmRleCwgMSk7CiAgICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpOwogICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7CiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgc2hhcGUuYm9keSA9IG51bGw7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZXMgYXJlIGNoYW5nZWQuCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdSYWRpdXMoKSB7CiAgICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc2hhcGVzOwogICAgICBjb25zdCBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0czsKICAgICAgY29uc3QgTiA9IHNoYXBlcy5sZW5ndGg7CiAgICAgIGxldCByYWRpdXMgPSAwOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldOwogICAgICAgIHNoYXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc2hhcGVPZmZzZXRzW2ldLmxlbmd0aCgpOwogICAgICAgIGNvbnN0IHIgPSBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1czsKCiAgICAgICAgaWYgKG9mZnNldCArIHIgPiByYWRpdXMpIHsKICAgICAgICAgIHJhZGl1cyA9IG9mZnNldCArIHI7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gcmFkaXVzOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGVzIHRoZSAuYWFiYgogICAgICovCgoKICAgIHVwZGF0ZUFBQkIoKSB7CiAgICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc2hhcGVzOwogICAgICBjb25zdCBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0czsKICAgICAgY29uc3Qgc2hhcGVPcmllbnRhdGlvbnMgPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zOwogICAgICBjb25zdCBOID0gc2hhcGVzLmxlbmd0aDsKICAgICAgY29uc3Qgb2Zmc2V0ID0gdG1wVmVjOwogICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRtcFF1YXQ7CiAgICAgIGNvbnN0IGJvZHlRdWF0ID0gdGhpcy5xdWF0ZXJuaW9uOwogICAgICBjb25zdCBhYWJiID0gdGhpcy5hYWJiOwogICAgICBjb25zdCBzaGFwZUFBQkIgPSB1cGRhdGVBQUJCX3NoYXBlQUFCQjsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBzaGFwZSA9IHNoYXBlc1tpXTsgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uCgogICAgICAgIGJvZHlRdWF0LnZtdWx0KHNoYXBlT2Zmc2V0c1tpXSwgb2Zmc2V0KTsKICAgICAgICBvZmZzZXQudmFkZCh0aGlzLnBvc2l0aW9uLCBvZmZzZXQpOyAvLyBHZXQgc2hhcGUgd29ybGQgcXVhdGVybmlvbgoKICAgICAgICBib2R5UXVhdC5tdWx0KHNoYXBlT3JpZW50YXRpb25zW2ldLCBvcmllbnRhdGlvbik7IC8vIEdldCBzaGFwZSBBQUJCCgogICAgICAgIHNoYXBlLmNhbGN1bGF0ZVdvcmxkQUFCQihvZmZzZXQsIG9yaWVudGF0aW9uLCBzaGFwZUFBQkIubG93ZXJCb3VuZCwgc2hhcGVBQUJCLnVwcGVyQm91bmQpOwoKICAgICAgICBpZiAoaSA9PT0gMCkgewogICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGFhYmIuZXh0ZW5kKHNoYXBlQUFCQik7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgYC5pbmVydGlhV29ybGRgIGFuZCBgLmludkluZXJ0aWFXb3JsZGAKICAgICAqLwoKCiAgICB1cGRhdGVJbmVydGlhV29ybGQoZm9yY2UpIHsKICAgICAgY29uc3QgSSA9IHRoaXMuaW52SW5lcnRpYTsKCiAgICAgIGlmIChJLnggPT09IEkueSAmJiBJLnkgPT09IEkueiAmJiAhZm9yY2UpIDsgZWxzZSB7CiAgICAgICAgY29uc3QgbTEgPSB1aXdfbTE7CiAgICAgICAgY29uc3QgbTIgPSB1aXdfbTI7CiAgICAgICAgbTEuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pOwogICAgICAgIG0xLnRyYW5zcG9zZShtMik7CiAgICAgICAgbTEuc2NhbGUoSSwgbTEpOwogICAgICAgIG0xLm1tdWx0KG0yLCB0aGlzLmludkluZXJ0aWFXb3JsZCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQXBwbHkgZm9yY2UgdG8gYSBwb2ludCBvZiB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuCiAgICAgKiBBcHBseWluZyBmb3JjZSB0aGlzIHdheSB3aWxsIGFkZCB0byBCb2R5LmZvcmNlIGFuZCBCb2R5LnRvcnF1ZS4KICAgICAqIEBwYXJhbSBmb3JjZSBUaGUgYW1vdW50IG9mIGZvcmNlIHRvIGFkZC4KICAgICAqIEBwYXJhbSByZWxhdGl2ZVBvaW50IEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIHRvIGFwcGx5IHRoZSBmb3JjZSBvbi4KICAgICAqLwoKCiAgICBhcHBseUZvcmNlKGZvcmNlLCByZWxhdGl2ZVBvaW50KSB7CiAgICAgIGlmIChyZWxhdGl2ZVBvaW50ID09PSB2b2lkIDApIHsKICAgICAgICByZWxhdGl2ZVBvaW50ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgLy8gTmVlZGVkPwogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBmb3JjZQoKCiAgICAgIGNvbnN0IHJvdEZvcmNlID0gQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlOwogICAgICByZWxhdGl2ZVBvaW50LmNyb3NzKGZvcmNlLCByb3RGb3JjZSk7IC8vIEFkZCBsaW5lYXIgZm9yY2UKCiAgICAgIHRoaXMuZm9yY2UudmFkZChmb3JjZSwgdGhpcy5mb3JjZSk7IC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlCgogICAgICB0aGlzLnRvcnF1ZS52YWRkKHJvdEZvcmNlLCB0aGlzLnRvcnF1ZSk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IGZvcmNlIHRvIGEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkuCiAgICAgKiBAcGFyYW0gZm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhcHBseSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBib2R5IGZyYW1lLgogICAgICogQHBhcmFtIGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uCiAgICAgKi8KCgogICAgYXBwbHlMb2NhbEZvcmNlKGxvY2FsRm9yY2UsIGxvY2FsUG9pbnQpIHsKICAgICAgaWYgKGxvY2FsUG9pbnQgPT09IHZvaWQgMCkgewogICAgICAgIGxvY2FsUG9pbnQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlOwogICAgICBjb25zdCByZWxhdGl2ZVBvaW50V29ybGQgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV9yZWxhdGl2ZVBvaW50V29ybGQ7IC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlCgogICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEZvcmNlLCB3b3JsZEZvcmNlKTsKICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVsYXRpdmVQb2ludFdvcmxkKTsKICAgICAgdGhpcy5hcHBseUZvcmNlKHdvcmxkRm9yY2UsIHJlbGF0aXZlUG9pbnRXb3JsZCk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IHRvcnF1ZSB0byB0aGUgYm9keS4KICAgICAqIEBwYXJhbSB0b3JxdWUgVGhlIGFtb3VudCBvZiB0b3JxdWUgdG8gYWRkLgogICAgICovCgoKICAgIGFwcGx5VG9ycXVlKHRvcnF1ZSkgewogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlCgoKICAgICAgdGhpcy50b3JxdWUudmFkZCh0b3JxdWUsIHRoaXMudG9ycXVlKTsKICAgIH0KICAgIC8qKgogICAgICogQXBwbHkgaW1wdWxzZSB0byBhIHBvaW50IG9mIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4KICAgICAqIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLgogICAgICogSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS4KICAgICAqIEBwYXJhbSBpbXB1bHNlIFRoZSBhbW91bnQgb2YgaW1wdWxzZSB0byBhZGQuCiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQb2ludCBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyB0byBhcHBseSB0aGUgZm9yY2Ugb24uCiAgICAgKi8KCgogICAgYXBwbHlJbXB1bHNlKGltcHVsc2UsIHJlbGF0aXZlUG9pbnQpIHsKICAgICAgaWYgKHJlbGF0aXZlUG9pbnQgPT09IHZvaWQgMCkgewogICAgICAgIHJlbGF0aXZlUG9pbnQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIENvbXB1dGUgcG9pbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyCgoKICAgICAgY29uc3QgciA9IHJlbGF0aXZlUG9pbnQ7IC8vIENvbXB1dGUgcHJvZHVjZWQgY2VudHJhbCBpbXB1bHNlIHZlbG9jaXR5CgogICAgICBjb25zdCB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbzsKICAgICAgdmVsby5jb3B5KGltcHVsc2UpOwogICAgICB2ZWxvLnNjYWxlKHRoaXMuaW52TWFzcywgdmVsbyk7IC8vIEFkZCBsaW5lYXIgaW1wdWxzZQoKICAgICAgdGhpcy52ZWxvY2l0eS52YWRkKHZlbG8sIHRoaXMudmVsb2NpdHkpOyAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgaW1wdWxzZSB2ZWxvY2l0eQoKICAgICAgY29uc3Qgcm90VmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG87CiAgICAgIHIuY3Jvc3MoaW1wdWxzZSwgcm90VmVsbyk7CiAgICAgIC8qCiAgICAgICByb3RWZWxvLnggKj0gdGhpcy5pbnZJbmVydGlhLng7CiAgICAgICByb3RWZWxvLnkgKj0gdGhpcy5pbnZJbmVydGlhLnk7CiAgICAgICByb3RWZWxvLnogKj0gdGhpcy5pbnZJbmVydGlhLno7CiAgICAgICAqLwoKICAgICAgdGhpcy5pbnZJbmVydGlhV29ybGQudm11bHQocm90VmVsbywgcm90VmVsbyk7IC8vIEFkZCByb3RhdGlvbmFsIEltcHVsc2UKCiAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnZhZGQocm90VmVsbywgdGhpcy5hbmd1bGFyVmVsb2NpdHkpOwogICAgfQogICAgLyoqCiAgICAgKiBBcHBseSBsb2NhbGx5LWRlZmluZWQgaW1wdWxzZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LgogICAgICogQHBhcmFtIGZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYXBwbHksIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keSBmcmFtZS4KICAgICAqIEBwYXJhbSBsb2NhbFBvaW50IEEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLgogICAgICovCgoKICAgIGFwcGx5TG9jYWxJbXB1bHNlKGxvY2FsSW1wdWxzZSwgbG9jYWxQb2ludCkgewogICAgICBpZiAobG9jYWxQb2ludCA9PT0gdm9pZCAwKSB7CiAgICAgICAgbG9jYWxQb2ludCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQykgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3Qgd29ybGRJbXB1bHNlID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2U7CiAgICAgIGNvbnN0IHJlbGF0aXZlUG9pbnRXb3JsZCA9IEJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludDsgLy8gVHJhbnNmb3JtIHRoZSBmb3JjZSB2ZWN0b3IgdG8gd29ybGQgc3BhY2UKCiAgICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGxvY2FsSW1wdWxzZSwgd29ybGRJbXB1bHNlKTsKICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVsYXRpdmVQb2ludFdvcmxkKTsKICAgICAgdGhpcy5hcHBseUltcHVsc2Uod29ybGRJbXB1bHNlLCByZWxhdGl2ZVBvaW50V29ybGQpOwogICAgfQogICAgLyoqCiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGJvZHkgc2hhcGUgb3IgbWFzcy4KICAgICAqLwoKCiAgICB1cGRhdGVNYXNzUHJvcGVydGllcygpIHsKICAgICAgY29uc3QgaGFsZkV4dGVudHMgPSBCb2R5X3VwZGF0ZU1hc3NQcm9wZXJ0aWVzX2hhbGZFeHRlbnRzOwogICAgICB0aGlzLmludk1hc3MgPSB0aGlzLm1hc3MgPiAwID8gMS4wIC8gdGhpcy5tYXNzIDogMDsKICAgICAgY29uc3QgSSA9IHRoaXMuaW5lcnRpYTsKICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZpeGVkUm90YXRpb247IC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3gKCiAgICAgIHRoaXMudXBkYXRlQUFCQigpOwogICAgICBoYWxmRXh0ZW50cy5zZXQoKHRoaXMuYWFiYi51cHBlckJvdW5kLnggLSB0aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsICh0aGlzLmFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5hYWJiLmxvd2VyQm91bmQueSkgLyAyLCAodGhpcy5hYWJiLnVwcGVyQm91bmQueiAtIHRoaXMuYWFiYi5sb3dlckJvdW5kLnopIC8gMik7CiAgICAgIEJveC5jYWxjdWxhdGVJbmVydGlhKGhhbGZFeHRlbnRzLCB0aGlzLm1hc3MsIEkpOwogICAgICB0aGlzLmludkluZXJ0aWEuc2V0KEkueCA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS54IDogMCwgSS55ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnkgOiAwLCBJLnogPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueiA6IDApOwogICAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCh0cnVlKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHdvcmxkIHZlbG9jaXR5IG9mIGEgcG9pbnQgaW4gdGhlIGJvZHkuCiAgICAgKiBAcGFyYW0gd29ybGRQb2ludAogICAgICogQHBhcmFtIHJlc3VsdAogICAgICogQHJldHVybiBUaGUgcmVzdWx0IHZlY3Rvci4KICAgICAqLwoKCiAgICBnZXRWZWxvY2l0eUF0V29ybGRQb2ludCh3b3JsZFBvaW50LCByZXN1bHQpIHsKICAgICAgY29uc3QgciA9IG5ldyBWZWMzKCk7CiAgICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLCByKTsKICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MociwgcmVzdWx0KTsKICAgICAgdGhpcy52ZWxvY2l0eS52YWRkKHJlc3VsdCwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUuCiAgICAgKiBAcGFyYW0gZHQgVGltZSBzdGVwCiAgICAgKiBAcGFyYW0gcXVhdE5vcm1hbGl6ZSBTZXQgdG8gdHJ1ZSB0byBub3JtYWxpemUgdGhlIGJvZHkgcXVhdGVybmlvbgogICAgICogQHBhcmFtIHF1YXROb3JtYWxpemVGYXN0IElmIHRoZSBxdWF0ZXJuaW9uIHNob3VsZCBiZSBub3JtYWxpemVkIHVzaW5nICJmYXN0IiBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24KICAgICAqLwoKCiAgICBpbnRlZ3JhdGUoZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KSB7CiAgICAgIC8vIFNhdmUgcHJldmlvdXMgcG9zaXRpb24KICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uLmNvcHkodGhpcy5wb3NpdGlvbik7CiAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkodGhpcy5xdWF0ZXJuaW9uKTsKCiAgICAgIGlmICghKHRoaXMudHlwZSA9PT0gQm9keS5EWU5BTUlDIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpIHx8IHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORykgewogICAgICAgIC8vIE9ubHkgZm9yIGR5bmFtaWMKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlbG8gPSB0aGlzLnZlbG9jaXR5OwogICAgICBjb25zdCBhbmd1bGFyVmVsbyA9IHRoaXMuYW5ndWxhclZlbG9jaXR5OwogICAgICBjb25zdCBwb3MgPSB0aGlzLnBvc2l0aW9uOwogICAgICBjb25zdCBmb3JjZSA9IHRoaXMuZm9yY2U7CiAgICAgIGNvbnN0IHRvcnF1ZSA9IHRoaXMudG9ycXVlOwogICAgICBjb25zdCBxdWF0ID0gdGhpcy5xdWF0ZXJuaW9uOwogICAgICBjb25zdCBpbnZNYXNzID0gdGhpcy5pbnZNYXNzOwogICAgICBjb25zdCBpbnZJbmVydGlhID0gdGhpcy5pbnZJbmVydGlhV29ybGQ7CiAgICAgIGNvbnN0IGxpbmVhckZhY3RvciA9IHRoaXMubGluZWFyRmFjdG9yOwogICAgICBjb25zdCBpTWR0ID0gaW52TWFzcyAqIGR0OwogICAgICB2ZWxvLnggKz0gZm9yY2UueCAqIGlNZHQgKiBsaW5lYXJGYWN0b3IueDsKICAgICAgdmVsby55ICs9IGZvcmNlLnkgKiBpTWR0ICogbGluZWFyRmFjdG9yLnk7CiAgICAgIHZlbG8ueiArPSBmb3JjZS56ICogaU1kdCAqIGxpbmVhckZhY3Rvci56OwogICAgICBjb25zdCBlID0gaW52SW5lcnRpYS5lbGVtZW50czsKICAgICAgY29uc3QgYW5ndWxhckZhY3RvciA9IHRoaXMuYW5ndWxhckZhY3RvcjsKICAgICAgY29uc3QgdHggPSB0b3JxdWUueCAqIGFuZ3VsYXJGYWN0b3IueDsKICAgICAgY29uc3QgdHkgPSB0b3JxdWUueSAqIGFuZ3VsYXJGYWN0b3IueTsKICAgICAgY29uc3QgdHogPSB0b3JxdWUueiAqIGFuZ3VsYXJGYWN0b3IuejsKICAgICAgYW5ndWxhclZlbG8ueCArPSBkdCAqIChlWzBdICogdHggKyBlWzFdICogdHkgKyBlWzJdICogdHopOwogICAgICBhbmd1bGFyVmVsby55ICs9IGR0ICogKGVbM10gKiB0eCArIGVbNF0gKiB0eSArIGVbNV0gKiB0eik7CiAgICAgIGFuZ3VsYXJWZWxvLnogKz0gZHQgKiAoZVs2XSAqIHR4ICsgZVs3XSAqIHR5ICsgZVs4XSAqIHR6KTsgLy8gVXNlIG5ldyB2ZWxvY2l0eSAgLSBsZWFwIGZyb2cKCiAgICAgIHBvcy54ICs9IHZlbG8ueCAqIGR0OwogICAgICBwb3MueSArPSB2ZWxvLnkgKiBkdDsKICAgICAgcG9zLnogKz0gdmVsby56ICogZHQ7CiAgICAgIHF1YXQuaW50ZWdyYXRlKHRoaXMuYW5ndWxhclZlbG9jaXR5LCBkdCwgdGhpcy5hbmd1bGFyRmFjdG9yLCBxdWF0KTsKCiAgICAgIGlmIChxdWF0Tm9ybWFsaXplKSB7CiAgICAgICAgaWYgKHF1YXROb3JtYWxpemVGYXN0KSB7CiAgICAgICAgICBxdWF0Lm5vcm1hbGl6ZUZhc3QoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcXVhdC5ub3JtYWxpemUoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gVXBkYXRlIHdvcmxkIGluZXJ0aWEKCiAgICAgIHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKCk7CiAgICB9CgogIH0KICBCb2R5LmlkQ291bnRlciA9IDA7CiAgQm9keS5DT0xMSURFX0VWRU5UX05BTUUgPSAnY29sbGlkZSc7CiAgQm9keS5EWU5BTUlDID0gQk9EWV9UWVBFUy5EWU5BTUlDOwogIEJvZHkuU1RBVElDID0gQk9EWV9UWVBFUy5TVEFUSUM7CiAgQm9keS5LSU5FTUFUSUMgPSBCT0RZX1RZUEVTLktJTkVNQVRJQzsKICBCb2R5LkFXQUtFID0gQk9EWV9TTEVFUF9TVEFURVMuQVdBS0U7CiAgQm9keS5TTEVFUFkgPSBCT0RZX1NMRUVQX1NUQVRFUy5TTEVFUFk7CiAgQm9keS5TTEVFUElORyA9IEJPRFlfU0xFRVBfU1RBVEVTLlNMRUVQSU5HOwogIEJvZHkud2FrZXVwRXZlbnQgPSB7CiAgICB0eXBlOiAnd2FrZXVwJwogIH07CiAgQm9keS5zbGVlcHlFdmVudCA9IHsKICAgIHR5cGU6ICdzbGVlcHknCiAgfTsKICBCb2R5LnNsZWVwRXZlbnQgPSB7CiAgICB0eXBlOiAnc2xlZXAnCiAgfTsKICBjb25zdCB0bXBWZWMgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpOwogIGNvbnN0IHVwZGF0ZUFBQkJfc2hhcGVBQUJCID0gbmV3IEFBQkIoKTsKICBjb25zdCB1aXdfbTEgPSBuZXcgTWF0MygpOwogIGNvbnN0IHVpd19tMiA9IG5ldyBNYXQzKCk7CiAgbmV3IE1hdDMoKTsKICBjb25zdCBCb2R5X2FwcGx5Rm9yY2Vfcm90Rm9yY2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkRm9yY2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3JlbGF0aXZlUG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cyA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zCiAgICogQGF1dGhvciBzY2h0ZXBwZQogICAqLwogIGNsYXNzIEJyb2FkcGhhc2UgewogICAgLyoqCiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb25zIGluLgogICAgICovCgogICAgLyoqCiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGJyb2FkcGhhc2UgdXNlcyBib3VuZGluZyBib3hlcyBmb3IgaW50ZXJzZWN0aW9uIHRlc3RzLCBlbHNlIGl0IHVzZXMgYm91bmRpbmcgc3BoZXJlcy4KICAgICAqLwoKICAgIC8qKgogICAgICogU2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdHMgaW4gdGhlIHdvcmxkIG1vdmVkLgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMudXNlQm91bmRpbmdCb3hlcyA9IGZhbHNlOwogICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBjb2xsaXNpb24gcGFpcnMgZnJvbSB0aGUgd29ybGQKICAgICAqIEBwYXJhbSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluCiAgICAgKiBAcGFyYW0gcDEgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzCiAgICAgKiBAcGFyYW0gcDIgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHAxLCBwMikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbGxpc2lvblBhaXJzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBCcm9hZFBoYXNlIGNsYXNzIScpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiBhIGJvZHkgcGFpciBuZWVkcyB0byBiZSBpbnRlcnNlY3Rpb24gdGVzdGVkIGF0IGFsbC4KICAgICAqLwoKCiAgICBuZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihib2R5QSwgYm9keUIpIHsKICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uIGZpbHRlciBtYXNrcwogICAgICBpZiAoKGJvZHlBLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUIuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDAgfHwgKGJvZHlCLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUEuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDApIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gQ2hlY2sgdHlwZXMKCgogICAgICBpZiAoKChib2R5QS50eXBlICYgQm9keS5TVEFUSUMpICE9PSAwIHx8IGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpICYmICgoYm9keUIudHlwZSAmIEJvZHkuU1RBVElDKSAhPT0gMCB8fCBib2R5Qi5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSkgewogICAgICAgIC8vIEJvdGggYm9kaWVzIGFyZSBzdGF0aWMgb3Igc2xlZXBpbmcuIFNraXAuCiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHZvbHVtZXMgb2YgdHdvIGJvZGllcyBpbnRlcnNlY3QuCiAgICAgKi8KCgogICAgaW50ZXJzZWN0aW9uVGVzdChib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKSB7CiAgICAgIGlmICh0aGlzLnVzZUJvdW5kaW5nQm94ZXMpIHsKICAgICAgICB0aGlzLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UoYm9keUEsIGJvZHlCLCBwYWlyczEsIHBhaXJzMik7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLgogICAgICogQHBhcmFtIHBhaXJzMSBib2R5QSBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvbgogICAgICogQHBhcmFtIHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvbgogICAgICovCgoKICAgIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpIHsKICAgICAgY29uc3QgciA9IEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcjsKICAgICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbiwgcik7CiAgICAgIGNvbnN0IGJvdW5kaW5nUmFkaXVzU3VtMiA9IChib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzKSAqKiAyOwogICAgICBjb25zdCBub3JtMiA9IHIubGVuZ3RoU3F1YXJlZCgpOwoKICAgICAgaWYgKG5vcm0yIDwgYm91bmRpbmdSYWRpdXNTdW0yKSB7CiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpOwogICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94ZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLgogICAgICovCgoKICAgIGRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpIHsKICAgICAgaWYgKGJvZHlBLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgIGJvZHlBLnVwZGF0ZUFBQkIoKTsKICAgICAgfQoKICAgICAgaWYgKGJvZHlCLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgIGJvZHlCLnVwZGF0ZUFBQkIoKTsKICAgICAgfSAvLyBDaGVjayBBQUJCIC8gQUFCQgoKCiAgICAgIGlmIChib2R5QS5hYWJiLm92ZXJsYXBzKGJvZHlCLmFhYmIpKSB7CiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpOwogICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGR1cGxpY2F0ZSBwYWlycyBmcm9tIHRoZSBwYWlyIGFycmF5cy4KICAgICAqLwoKCiAgICBtYWtlUGFpcnNVbmlxdWUocGFpcnMxLCBwYWlyczIpIHsKICAgICAgY29uc3QgdCA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXA7CiAgICAgIGNvbnN0IHAxID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDE7CiAgICAgIGNvbnN0IHAyID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDI7CiAgICAgIGNvbnN0IE4gPSBwYWlyczEubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIHAxW2ldID0gcGFpcnMxW2ldOwogICAgICAgIHAyW2ldID0gcGFpcnMyW2ldOwogICAgICB9CgogICAgICBwYWlyczEubGVuZ3RoID0gMDsKICAgICAgcGFpcnMyLmxlbmd0aCA9IDA7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgaWQxID0gcDFbaV0uaWQ7CiAgICAgICAgY29uc3QgaWQyID0gcDJbaV0uaWQ7CiAgICAgICAgY29uc3Qga2V5ID0gaWQxIDwgaWQyID8gYCR7aWQxfSwke2lkMn1gIDogYCR7aWQyfSwke2lkMX1gOwogICAgICAgIHRba2V5XSA9IGk7CiAgICAgICAgdC5rZXlzLnB1c2goa2V5KTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHQua2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGtleSA9IHQua2V5cy5wb3AoKTsKICAgICAgICBjb25zdCBwYWlySW5kZXggPSB0W2tleV07CiAgICAgICAgcGFpcnMxLnB1c2gocDFbcGFpckluZGV4XSk7CiAgICAgICAgcGFpcnMyLnB1c2gocDJbcGFpckluZGV4XSk7CiAgICAgICAgZGVsZXRlIHRba2V5XTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBieSBzdWJjYXNzZXMKICAgICAqLwoKCiAgICBzZXRXb3JsZCh3b3JsZCkge30KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLgogICAgICovCgoKICAgIHN0YXRpYyBib3VuZGluZ1NwaGVyZUNoZWNrKGJvZHlBLCBib2R5QikgewogICAgICBjb25zdCBkaXN0ID0gbmV3IFZlYzMoKTsgLy8gYnNjX2Rpc3Q7CgogICAgICBib2R5QS5wb3NpdGlvbi52c3ViKGJvZHlCLnBvc2l0aW9uLCBkaXN0KTsKICAgICAgY29uc3Qgc2EgPSBib2R5QS5zaGFwZXNbMF07CiAgICAgIGNvbnN0IHNiID0gYm9keUIuc2hhcGVzWzBdOwogICAgICByZXR1cm4gTWF0aC5wb3coc2EuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzYi5ib3VuZGluZ1NwaGVyZVJhZGl1cywgMikgPiBkaXN0Lmxlbmd0aFNxdWFyZWQoKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuCiAgICAgKi8KCgogICAgYWFiYlF1ZXJ5KHdvcmxkLCBhYWJiLCByZXN1bHQpIHsKICAgICAgY29uc29sZS53YXJuKCcuYWFiYlF1ZXJ5IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIEJyb2FkcGhhc2Ugc3ViY2xhc3MuJyk7CiAgICAgIHJldHVybiBbXTsKICAgIH0KCiAgfSAvLyBUZW1wIG9iamVjdHMKCiAgY29uc3QgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yID0gbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIG5ldyBRdWF0ZXJuaW9uKCk7CiAgbmV3IFZlYzMoKTsKICBjb25zdCBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wID0gewogICAga2V5czogW10KICB9OwogIGNvbnN0IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxID0gW107CiAgY29uc3QgQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDIgPSBbXTsKICBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbiwgdXNlZCBpbiBsYWNrIG9mIGJldHRlciBvbmVzLgogICAqCiAgICogVGhlIG5haXZlIGJyb2FkcGhhc2UgbG9va3MgYXQgYWxsIHBvc3NpYmxlIHBhaXJzIHdpdGhvdXQgcmVzdHJpY3Rpb24sIHRoZXJlZm9yZSBpdCBoYXMgY29tcGxleGl0eSBOXjIgXyh3aGljaCBpcyBiYWQpXwogICAqLwogIGNsYXNzIE5haXZlQnJvYWRwaGFzZSBleHRlbmRzIEJyb2FkcGhhc2UgewogICAgLyoqCiAgICAgKiBAdG9kbyBSZW1vdmUgdXNlbGVzcyBjb25zdHJ1Y3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHBhaXJzMSwgcGFpcnMyKSB7CiAgICAgIGNvbnN0IGJvZGllcyA9IHdvcmxkLmJvZGllczsKICAgICAgY29uc3QgbiA9IGJvZGllcy5sZW5ndGg7CiAgICAgIGxldCBiaTsKICAgICAgbGV0IGJqOyAvLyBOYWl2ZSBOXjIgZnR3IQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IG47IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBpOyBqKyspIHsKICAgICAgICAgIGJpID0gYm9kaWVzW2ldOwogICAgICAgICAgYmogPSBib2RpZXNbal07CgogICAgICAgICAgaWYgKCF0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJpLCBiaikpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLCBiaiwgcGFpcnMxLCBwYWlyczIpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLgogICAgICovCgoKICAgIGFhYmJRdWVyeSh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IFtdOwogICAgICB9CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGIgPSB3b3JsZC5ib2RpZXNbaV07CgogICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYi51cGRhdGVBQUJCKCk7CiAgICAgICAgfSAvLyBVZ2x5IGhhY2sgdW50aWwgQm9keSBnZXRzIGFhYmIKCgogICAgICAgIGlmIChiLmFhYmIub3ZlcmxhcHMoYWFiYikpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKGIpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgfQoKICAvKioKICAgKiBTdG9yYWdlIGZvciBSYXkgY2FzdGluZyBkYXRhCiAgICovCiAgY2xhc3MgUmF5Y2FzdFJlc3VsdCB7CiAgICAvKioKICAgICAqIHJheUZyb21Xb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiByYXlUb1dvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIGhpdE5vcm1hbFdvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIGhpdFBvaW50V29ybGQKICAgICAqLwoKICAgIC8qKgogICAgICogaGFzSGl0CiAgICAgKi8KCiAgICAvKioKICAgICAqIHNoYXBlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGJvZHkKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGluZGV4IG9mIHRoZSBoaXQgdHJpYW5nbGUsIGlmIHRoZSBoaXQgc2hhcGUgd2FzIGEgdHJpbWVzaAogICAgICovCgogICAgLyoqCiAgICAgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0CiAgICAgKi8KCiAgICAvKioKICAgICAqIElmIHRoZSByYXkgc2hvdWxkIHN0b3AgdHJhdmVyc2luZyB0aGUgYm9kaWVzCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLnJheUZyb21Xb3JsZCA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucmF5VG9Xb3JsZCA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaGl0Tm9ybWFsV29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmhpdFBvaW50V29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlOwogICAgICB0aGlzLnNoYXBlID0gbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgICAgdGhpcy5oaXRGYWNlSW5kZXggPSAtMTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IC0xOwogICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLgogICAgICovCgoKICAgIHJlc2V0KCkgewogICAgICB0aGlzLnJheUZyb21Xb3JsZC5zZXRaZXJvKCk7CiAgICAgIHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCk7CiAgICAgIHRoaXMuaGl0Tm9ybWFsV29ybGQuc2V0WmVybygpOwogICAgICB0aGlzLmhpdFBvaW50V29ybGQuc2V0WmVybygpOwogICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlOwogICAgICB0aGlzLnNoYXBlID0gbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgICAgdGhpcy5oaXRGYWNlSW5kZXggPSAtMTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IC0xOwogICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogYWJvcnQKICAgICAqLwoKCiAgICBhYm9ydCgpIHsKICAgICAgdGhpcy5zaG91bGRTdG9wID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHJlc3VsdCBkYXRhLgogICAgICovCgoKICAgIHNldChyYXlGcm9tV29ybGQsIHJheVRvV29ybGQsIGhpdE5vcm1hbFdvcmxkLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgZGlzdGFuY2UpIHsKICAgICAgdGhpcy5yYXlGcm9tV29ybGQuY29weShyYXlGcm9tV29ybGQpOwogICAgICB0aGlzLnJheVRvV29ybGQuY29weShyYXlUb1dvcmxkKTsKICAgICAgdGhpcy5oaXROb3JtYWxXb3JsZC5jb3B5KGhpdE5vcm1hbFdvcmxkKTsKICAgICAgdGhpcy5oaXRQb2ludFdvcmxkLmNvcHkoaGl0UG9pbnRXb3JsZCk7CiAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTsKICAgICAgdGhpcy5ib2R5ID0gYm9keTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlOwogICAgfQoKICB9CgogIGxldCBfU2hhcGUkdHlwZXMkU1BIRVJFLCBfU2hhcGUkdHlwZXMkUExBTkUsIF9TaGFwZSR0eXBlcyRCT1gsIF9TaGFwZSR0eXBlcyRDWUxJTkRFUiwgX1NoYXBlJHR5cGVzJENPTlZFWFBPLCBfU2hhcGUkdHlwZXMkSEVJR0hURkksIF9TaGFwZSR0eXBlcyRUUklNRVNIOwoKICAvKioKICAgKiBSQVlfTU9ERVMKICAgKi8KICBjb25zdCBSQVlfTU9ERVMgPSB7CiAgICAvKiogQ0xPU0VTVCAqLwogICAgQ0xPU0VTVDogMSwKCiAgICAvKiogQU5ZICovCiAgICBBTlk6IDIsCgogICAgLyoqIEFMTCAqLwogICAgQUxMOiA0CiAgfTsKICAvKioKICAgKiBSYXlNb2RlCiAgICovCgogIF9TaGFwZSR0eXBlcyRTUEhFUkUgPSBTaGFwZS50eXBlcy5TUEhFUkU7CiAgX1NoYXBlJHR5cGVzJFBMQU5FID0gU2hhcGUudHlwZXMuUExBTkU7CiAgX1NoYXBlJHR5cGVzJEJPWCA9IFNoYXBlLnR5cGVzLkJPWDsKICBfU2hhcGUkdHlwZXMkQ1lMSU5ERVIgPSBTaGFwZS50eXBlcy5DWUxJTkRFUjsKICBfU2hhcGUkdHlwZXMkQ09OVkVYUE8gPSBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OOwogIF9TaGFwZSR0eXBlcyRIRUlHSFRGSSA9IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEOwogIF9TaGFwZSR0eXBlcyRUUklNRVNIID0gU2hhcGUudHlwZXMuVFJJTUVTSDsKCiAgLyoqCiAgICogQSBsaW5lIGluIDNEIHNwYWNlIHRoYXQgaW50ZXJzZWN0cyBib2RpZXMgYW5kIHJldHVybiBwb2ludHMuCiAgICovCiAgY2xhc3MgUmF5IHsKICAgIC8qKgogICAgICogZnJvbQogICAgICovCgogICAgLyoqCiAgICAgKiB0bwogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb24KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHByZWNpc2lvbiBvZiB0aGUgcmF5LiBVc2VkIHdoZW4gY2hlY2tpbmcgcGFyYWxsZWxpdHkgZXRjLgogICAgICogQGRlZmF1bHQgMC4wMDAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNldCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBSYXkgdG8gdGFrZSBgY29sbGlzaW9uUmVzcG9uc2VgIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy4KICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuCiAgICAgKiBAZGVmYXVsdCBmYWxzZQogICAgICovCgogICAgLyoqCiAgICAgKiBjb2xsaXNpb25GaWx0ZXJNYXNrCiAgICAgKiBAZGVmYXVsdCAtMQogICAgICovCgogICAgLyoqCiAgICAgKiBjb2xsaXNpb25GaWx0ZXJHcm91cAogICAgICogQGRlZmF1bHQgLTEKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC4KICAgICAqIEBkZWZhdWx0IFJBWS5BTlkKICAgICAqLwoKICAgIC8qKgogICAgICogQ3VycmVudCByZXN1bHQgb2JqZWN0LgogICAgICovCgogICAgLyoqCiAgICAgKiBXaWxsIGJlIHNldCB0byBgdHJ1ZWAgZHVyaW5nIGludGVyc2VjdFdvcmxkKCkgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLgogICAgICovCgogICAgLyoqCiAgICAgKiBDTE9TRVNUCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFOWQogICAgICovCgogICAgLyoqCiAgICAgKiBBTEwKICAgICAqLwogICAgZ2V0IFtfU2hhcGUkdHlwZXMkU1BIRVJFXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdFNwaGVyZTsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRQTEFORV0oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RQbGFuZTsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRCT1hdKCkgewogICAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0Qm94OwogICAgfQoKICAgIGdldCBbX1NoYXBlJHR5cGVzJENZTElOREVSXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdENvbnZleDsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRDT05WRVhQT10oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RDb252ZXg7CiAgICB9CgogICAgZ2V0IFtfU2hhcGUkdHlwZXMkSEVJR0hURkldKCkgewogICAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0SGVpZ2h0ZmllbGQ7CiAgICB9CgogICAgZ2V0IFtfU2hhcGUkdHlwZXMkVFJJTUVTSF0oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RUcmltZXNoOwogICAgfQoKICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7CiAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsKICAgICAgICBmcm9tID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsKICAgICAgICB0byA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMuZnJvbSA9IGZyb20uY2xvbmUoKTsKICAgICAgdGhpcy50byA9IHRvLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5wcmVjaXNpb24gPSAwLjAwMDE7CiAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRydWU7CiAgICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9IGZhbHNlOwogICAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSAtMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IC0xOwogICAgICB0aGlzLm1vZGUgPSBSYXkuQU5ZOwogICAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7CiAgICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7CgogICAgICB0aGlzLmNhbGxiYWNrID0gcmVzdWx0ID0+IHt9OwogICAgfQogICAgLyoqCiAgICAgKiBEbyBpdGVyc2VjdGlvbiBhZ2FpbnN0IGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIFdvcmxkLgogICAgICogQHJldHVybiBUcnVlIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLCBvdGhlcndpc2UgZmFsc2UuCiAgICAgKi8KCgogICAgaW50ZXJzZWN0V29ybGQod29ybGQsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7CiAgICAgIHRoaXMucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgfHwgbmV3IFJheWNhc3RSZXN1bHQoKTsKICAgICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Ygb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogLTE7CiAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHR5cGVvZiBvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTsKCiAgICAgIGlmIChvcHRpb25zLmZyb20pIHsKICAgICAgICB0aGlzLmZyb20uY29weShvcHRpb25zLmZyb20pOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy50bykgewogICAgICAgIHRoaXMudG8uY29weShvcHRpb25zLnRvKTsKICAgICAgfQoKICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgKCgpID0+IHt9KTsKCiAgICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7CiAgICAgIHRoaXMucmVzdWx0LnJlc2V0KCk7CiAgICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7CiAgICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCJDEpOwogICAgICB0bXBBcnJheS5sZW5ndGggPSAwOwogICAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiQxLCB0bXBBcnJheSk7CiAgICAgIHRoaXMuaW50ZXJzZWN0Qm9kaWVzKHRtcEFycmF5KTsKICAgICAgcmV0dXJuIHRoaXMuaGFzSGl0OwogICAgfQogICAgLyoqCiAgICAgKiBTaG9vdCBhIHJheSBhdCBhIGJvZHksIGdldCBiYWNrIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXQuCiAgICAgKiBAZGVwcmVjYXRlZCBAcGFyYW0gcmVzdWx0IHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC4KICAgICAqLwoKCiAgICBpbnRlcnNlY3RCb2R5KGJvZHksIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7CiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTsKICAgICAgfQoKICAgICAgY29uc3QgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTsKCiAgICAgIGlmIChjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFib2R5LmNvbGxpc2lvblJlc3BvbnNlKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAoKHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5LmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAwIHx8IChib2R5LmNvbGxpc2lvbkZpbHRlckdyb3VwICYgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrKSA9PT0gMCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3QgeGkgPSBpbnRlcnNlY3RCb2R5X3hpOwogICAgICBjb25zdCBxaSA9IGludGVyc2VjdEJvZHlfcWk7CgogICAgICBmb3IgKGxldCBpID0gMCwgTiA9IGJvZHkuc2hhcGVzLmxlbmd0aDsgaSA8IE47IGkrKykgewogICAgICAgIGNvbnN0IHNoYXBlID0gYm9keS5zaGFwZXNbaV07CgogICAgICAgIGlmIChjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFzaGFwZS5jb2xsaXNpb25SZXNwb25zZSkgewogICAgICAgICAgY29udGludWU7IC8vIFNraXAKICAgICAgICB9CgogICAgICAgIGJvZHkucXVhdGVybmlvbi5tdWx0KGJvZHkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTsKICAgICAgICBib2R5LnF1YXRlcm5pb24udm11bHQoYm9keS5zaGFwZU9mZnNldHNbaV0sIHhpKTsKICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTsKICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKHNoYXBlLCBxaSwgeGksIGJvZHkpOwoKICAgICAgICBpZiAodGhpcy5yZXN1bHQuc2hvdWxkU3RvcCkgewogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNob290IGEgcmF5IGF0IGFuIGFycmF5IGJvZGllcywgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC4KICAgICAqIEBwYXJhbSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLgogICAgICogQGRlcHJlY2F0ZWQgQHBhcmFtIHJlc3VsdCBzZXQgdGhlIHJlc3VsdCBwcm9wZXJ0eSBvZiB0aGUgUmF5IGluc3RlYWQuCiAgICAgKgogICAgICovCgoKICAgIGludGVyc2VjdEJvZGllcyhib2RpZXMsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7CiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBpIDwgbDsgaSsrKSB7CiAgICAgICAgdGhpcy5pbnRlcnNlY3RCb2R5KGJvZGllc1tpXSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyB0aGUgZGlyZWN0aW9uIHZlY3Rvci4KICAgICAqLwoKCiAgICB1cGRhdGVEaXJlY3Rpb24oKSB7CiAgICAgIHRoaXMudG8udnN1Yih0aGlzLmZyb20sIHRoaXMuZGlyZWN0aW9uKTsKICAgICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7CiAgICB9CgogICAgaW50ZXJzZWN0U2hhcGUoc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5KSB7CiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207IC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlCgogICAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCB0aGlzLmRpcmVjdGlvbiwgcG9zaXRpb24pOwoKICAgICAgaWYgKGRpc3RhbmNlID4gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGludGVyc2VjdE1ldGhvZCA9IHRoaXNbc2hhcGUudHlwZV07CgogICAgICBpZiAoaW50ZXJzZWN0TWV0aG9kKSB7CiAgICAgICAgaW50ZXJzZWN0TWV0aG9kLmNhbGwodGhpcywgc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCBzaGFwZSk7CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0Qm94KGJveCwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdENvbnZleChib3guY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSk7CiAgICB9CgogICAgX2ludGVyc2VjdFBsYW5lKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSkgewogICAgICBjb25zdCBmcm9tID0gdGhpcy5mcm9tOwogICAgICBjb25zdCB0byA9IHRoaXMudG87CiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uOyAvLyBHZXQgcGxhbmUgbm9ybWFsCgogICAgICBjb25zdCB3b3JsZE5vcm1hbCA9IG5ldyBWZWMzKDAsIDAsIDEpOwogICAgICBxdWF0LnZtdWx0KHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7CiAgICAgIGNvbnN0IGxlbiA9IG5ldyBWZWMzKCk7CiAgICAgIGZyb20udnN1Yihwb3NpdGlvbiwgbGVuKTsKICAgICAgY29uc3QgcGxhbmVUb0Zyb20gPSBsZW4uZG90KHdvcmxkTm9ybWFsKTsKICAgICAgdG8udnN1Yihwb3NpdGlvbiwgbGVuKTsKICAgICAgY29uc3QgcGxhbmVUb1RvID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7CgogICAgICBpZiAocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKSB7CiAgICAgICAgLy8gImZyb20iIGFuZCAidG8iIGFyZSBvbiB0aGUgc2FtZSBzaWRlIG9mIHRoZSBwbGFuZS4uLiBiYWlsIG91dAogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKGZyb20uZGlzdGFuY2VUbyh0bykgPCBwbGFuZVRvRnJvbSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3Qgbl9kb3RfZGlyID0gd29ybGROb3JtYWwuZG90KGRpcmVjdGlvbik7CgogICAgICBpZiAoTWF0aC5hYnMobl9kb3RfZGlyKSA8IHRoaXMucHJlY2lzaW9uKSB7CiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCBwbGFuZVBvaW50VG9Gcm9tID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgZGlyX3NjYWxlZF93aXRoX3QgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBoaXRQb2ludFdvcmxkID0gbmV3IFZlYzMoKTsKICAgICAgZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTsKICAgICAgY29uc3QgdCA9IC13b3JsZE5vcm1hbC5kb3QocGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXI7CiAgICAgIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7CiAgICAgIGZyb20udmFkZChkaXJfc2NhbGVkX3dpdGhfdCwgaGl0UG9pbnRXb3JsZCk7CiAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCBoaXRQb2ludFdvcmxkLCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgd29ybGQgQUFCQiBvZiB0aGUgcmF5LgogICAgICovCgoKICAgIGdldEFBQkIoYWFiYikgewogICAgICBjb25zdCB7CiAgICAgICAgbG93ZXJCb3VuZCwKICAgICAgICB1cHBlckJvdW5kCiAgICAgIH0gPSBhYWJiOwogICAgICBjb25zdCB0byA9IHRoaXMudG87CiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207CiAgICAgIGxvd2VyQm91bmQueCA9IE1hdGgubWluKHRvLngsIGZyb20ueCk7CiAgICAgIGxvd2VyQm91bmQueSA9IE1hdGgubWluKHRvLnksIGZyb20ueSk7CiAgICAgIGxvd2VyQm91bmQueiA9IE1hdGgubWluKHRvLnosIGZyb20ueik7CiAgICAgIHVwcGVyQm91bmQueCA9IE1hdGgubWF4KHRvLngsIGZyb20ueCk7CiAgICAgIHVwcGVyQm91bmQueSA9IE1hdGgubWF4KHRvLnksIGZyb20ueSk7CiAgICAgIHVwcGVyQm91bmQueiA9IE1hdGgubWF4KHRvLnosIGZyb20ueik7CiAgICB9CgogICAgX2ludGVyc2VjdEhlaWdodGZpZWxkKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSkgewogICAgICBzaGFwZS5kYXRhOwogICAgICBzaGFwZS5lbGVtZW50U2l6ZTsgLy8gQ29udmVydCB0aGUgcmF5IHRvIGxvY2FsIGhlaWdodGZpZWxkIGNvb3JkaW5hdGVzCgogICAgICBjb25zdCBsb2NhbFJheSA9IGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsUmF5OyAvL25ldyBSYXkodGhpcy5mcm9tLCB0aGlzLnRvKTsKCiAgICAgIGxvY2FsUmF5LmZyb20uY29weSh0aGlzLmZyb20pOwogICAgICBsb2NhbFJheS50by5jb3B5KHRoaXMudG8pOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGxvY2FsUmF5LmZyb20sIGxvY2FsUmF5LmZyb20pOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGxvY2FsUmF5LnRvLCBsb2NhbFJheS50byk7CiAgICAgIGxvY2FsUmF5LnVwZGF0ZURpcmVjdGlvbigpOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3QKCiAgICAgIGNvbnN0IGluZGV4ID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXg7CiAgICAgIGxldCBpTWluWDsKICAgICAgbGV0IGlNaW5ZOwogICAgICBsZXQgaU1heFg7CiAgICAgIGxldCBpTWF4WTsgLy8gU2V0IHRvIG1heAoKICAgICAgaU1pblggPSBpTWluWSA9IDA7CiAgICAgIGlNYXhYID0gaU1heFkgPSBzaGFwZS5kYXRhLmxlbmd0aCAtIDE7CiAgICAgIGNvbnN0IGFhYmIgPSBuZXcgQUFCQigpOwogICAgICBsb2NhbFJheS5nZXRBQUJCKGFhYmIpOwogICAgICBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24oYWFiYi5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC55LCBpbmRleCwgdHJ1ZSk7CiAgICAgIGlNaW5YID0gTWF0aC5tYXgoaU1pblgsIGluZGV4WzBdKTsKICAgICAgaU1pblkgPSBNYXRoLm1heChpTWluWSwgaW5kZXhbMV0pOwogICAgICBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24oYWFiYi51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55LCBpbmRleCwgdHJ1ZSk7CiAgICAgIGlNYXhYID0gTWF0aC5taW4oaU1heFgsIGluZGV4WzBdICsgMSk7CiAgICAgIGlNYXhZID0gTWF0aC5taW4oaU1heFksIGluZGV4WzFdICsgMSk7CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKykgewogICAgICAgICAgaWYgKHRoaXMucmVzdWx0LnNob3VsZFN0b3ApIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQoKICAgICAgICAgIHNoYXBlLmdldEFhYmJBdEluZGV4KGksIGosIGFhYmIpOwoKICAgICAgICAgIGlmICghYWFiYi5vdmVybGFwc1JheShsb2NhbFJheSkpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IC8vIExvd2VyIHRyaWFuZ2xlCgoKICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgdGhpcy5faW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIHJlcG9ydGVkU2hhcGUsIGludGVyc2VjdENvbnZleE9wdGlvbnMpOwoKICAgICAgICAgIGlmICh0aGlzLnJlc3VsdC5zaG91bGRTdG9wKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0gLy8gVXBwZXIgdHJpYW5nbGUKCgogICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7CiAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIHNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIHRoaXMuX2ludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCByZXBvcnRlZFNoYXBlLCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0U3BoZXJlKHNwaGVyZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpIHsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCByID0gc3BoZXJlLnJhZGl1czsKICAgICAgY29uc3QgYSA9ICh0by54IC0gZnJvbS54KSAqKiAyICsgKHRvLnkgLSBmcm9tLnkpICoqIDIgKyAodG8ueiAtIGZyb20ueikgKiogMjsKICAgICAgY29uc3QgYiA9IDIgKiAoKHRvLnggLSBmcm9tLngpICogKGZyb20ueCAtIHBvc2l0aW9uLngpICsgKHRvLnkgLSBmcm9tLnkpICogKGZyb20ueSAtIHBvc2l0aW9uLnkpICsgKHRvLnogLSBmcm9tLnopICogKGZyb20ueiAtIHBvc2l0aW9uLnopKTsKICAgICAgY29uc3QgYyA9IChmcm9tLnggLSBwb3NpdGlvbi54KSAqKiAyICsgKGZyb20ueSAtIHBvc2l0aW9uLnkpICoqIDIgKyAoZnJvbS56IC0gcG9zaXRpb24ueikgKiogMiAtIHIgKiogMjsKICAgICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYSAqIGM7CiAgICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50ID0gUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludDsKICAgICAgY29uc3Qgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7CgogICAgICBpZiAoZGVsdGEgPCAwKSB7CiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uCiAgICAgICAgcmV0dXJuOwogICAgICB9IGVsc2UgaWYgKGRlbHRhID09PSAwKSB7CiAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludAogICAgICAgIGZyb20ubGVycCh0bywgZGVsdGEsIGludGVyc2VjdGlvblBvaW50KTsKICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpOwogICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZDEgPSAoLWIgLSBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7CiAgICAgICAgY29uc3QgZDIgPSAoLWIgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7CgogICAgICAgIGlmIChkMSA+PSAwICYmIGQxIDw9IDEpIHsKICAgICAgICAgIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTsKICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7CiAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7CiAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5yZXN1bHQuc2hvdWxkU3RvcCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgaWYgKGQyID49IDAgJiYgZDIgPD0gMSkgewogICAgICAgICAgZnJvbS5sZXJwKHRvLCBkMiwgaW50ZXJzZWN0aW9uUG9pbnQpOwogICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTsKICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHJlcG9ydGVkU2hhcGUsIGJvZHksIC0xKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0Q29udmV4KHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSwgb3B0aW9ucykgewogICAgICBjb25zdCBub3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbm9ybWFsOwogICAgICBjb25zdCB2ZWN0b3IgPSBpbnRlcnNlY3RDb252ZXhfdmVjdG9yOwogICAgICBjb25zdCBmYWNlTGlzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mYWNlTGlzdCB8fCBudWxsOyAvLyBDaGVja2luZyBmYWNlcwoKICAgICAgY29uc3QgZmFjZXMgPSBzaGFwZS5mYWNlczsKICAgICAgY29uc3QgdmVydGljZXMgPSBzaGFwZS52ZXJ0aWNlczsKICAgICAgY29uc3Qgbm9ybWFscyA9IHNoYXBlLmZhY2VOb3JtYWxzOwogICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCBmcm9tVG9EaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyh0byk7CiAgICAgIGNvbnN0IE5mYWNlcyA9IGZhY2VMaXN0ID8gZmFjZUxpc3QubGVuZ3RoIDogZmFjZXMubGVuZ3RoOwogICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdDsKCiAgICAgIGZvciAobGV0IGogPSAwOyAhcmVzdWx0LnNob3VsZFN0b3AgJiYgaiA8IE5mYWNlczsgaisrKSB7CiAgICAgICAgY29uc3QgZmkgPSBmYWNlTGlzdCA/IGZhY2VMaXN0W2pdIDogajsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbZmldOwogICAgICAgIGNvbnN0IGZhY2VOb3JtYWwgPSBub3JtYWxzW2ZpXTsKICAgICAgICBjb25zdCBxID0gcXVhdDsKICAgICAgICBjb25zdCB4ID0gcG9zaXRpb247IC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2UKICAgICAgICAvLyBub3RlOiB0aGlzIHdvcmtzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZmFjZSBub3JtYWwKICAgICAgICAvLyBHZXQgcGxhbmUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuLi4KCiAgICAgICAgdmVjdG9yLmNvcHkodmVydGljZXNbZmFjZVswXV0pOwogICAgICAgIHEudm11bHQodmVjdG9yLCB2ZWN0b3IpOwogICAgICAgIHZlY3Rvci52YWRkKHgsIHZlY3Rvcik7IC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuCgogICAgICAgIHZlY3Rvci52c3ViKGZyb20sIHZlY3Rvcik7IC8vIEdldCBwbGFuZSBub3JtYWwKCiAgICAgICAgcS52bXVsdChmYWNlTm9ybWFsLCBub3JtYWwpOyAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZwoKICAgICAgICBjb25zdCBkb3QgPSBkaXJlY3Rpb24uZG90KG5vcm1hbCk7IC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsCgogICAgICAgIGlmIChNYXRoLmFicyhkb3QpIDwgdGhpcy5wcmVjaXNpb24pIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZQoKCiAgICAgICAgY29uc3Qgc2NhbGFyID0gbm9ybWFsLmRvdCh2ZWN0b3IpIC8gZG90OyAvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5CgogICAgICAgIGlmIChzY2FsYXIgPCAwKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9IC8vIGlmIChkb3QgPCAwKSB7CiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXIKCgogICAgICAgIGRpcmVjdGlvbi5zY2FsZShzY2FsYXIsIGludGVyc2VjdFBvaW50KTsKICAgICAgICBpbnRlcnNlY3RQb2ludC52YWRkKGZyb20sIGludGVyc2VjdFBvaW50KTsgLy8gYSBpcyB0aGUgcG9pbnQgd2UgY29tcGFyZSBwb2ludHMgYiBhbmQgYyB3aXRoLgoKICAgICAgICBhLmNvcHkodmVydGljZXNbZmFjZVswXV0pOwogICAgICAgIHEudm11bHQoYSwgYSk7CiAgICAgICAgeC52YWRkKGEsIGEpOwoKICAgICAgICBmb3IgKGxldCBpID0gMTsgIXJlc3VsdC5zaG91bGRTdG9wICYmIGkgPCBmYWNlLmxlbmd0aCAtIDE7IGkrKykgewogICAgICAgICAgLy8gVHJhbnNmb3JtIDMgdmVydGljZXMgdG8gd29ybGQgY29vcmRzCiAgICAgICAgICBiLmNvcHkodmVydGljZXNbZmFjZVtpXV0pOwogICAgICAgICAgYy5jb3B5KHZlcnRpY2VzW2ZhY2VbaSArIDFdXSk7CiAgICAgICAgICBxLnZtdWx0KGIsIGIpOwogICAgICAgICAgcS52bXVsdChjLCBjKTsKICAgICAgICAgIHgudmFkZChiLCBiKTsKICAgICAgICAgIHgudmFkZChjLCBjKTsKICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhmcm9tKTsKCiAgICAgICAgICBpZiAoIShSYXkucG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSB8fCBSYXkucG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSkgfHwgZGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCBmaSk7CiAgICAgICAgfSAvLyB9CgogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEB0b2RvIE9wdGltaXplIGJ5IHRyYW5zZm9ybWluZyB0aGUgd29ybGQgdG8gbG9jYWwgc3BhY2UgZmlyc3QuCiAgICAgKiBAdG9kbyBVc2UgT2N0cmVlIGxvb2t1cAogICAgICovCgoKICAgIF9pbnRlcnNlY3RUcmltZXNoKG1lc2gsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlLCBvcHRpb25zKSB7CiAgICAgIGNvbnN0IG5vcm1hbCA9IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsOwogICAgICBjb25zdCB0cmlhbmdsZXMgPSBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlczsKICAgICAgY29uc3QgdHJlZVRyYW5zZm9ybSA9IGludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybTsKICAgICAgY29uc3QgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjsKICAgICAgY29uc3QgbG9jYWxEaXJlY3Rpb24gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uOwogICAgICBjb25zdCBsb2NhbEZyb20gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbTsKICAgICAgY29uc3QgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbzsKICAgICAgY29uc3Qgd29ybGRJbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFRyaW1lc2hfd29ybGRJbnRlcnNlY3RQb2ludDsKICAgICAgY29uc3Qgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsOyAvLyBDaGVja2luZyBmYWNlcwoKICAgICAgY29uc3QgaW5kaWNlcyA9IG1lc2guaW5kaWNlczsKICAgICAgbWVzaC52ZXJ0aWNlczsgLy8gY29uc3Qgbm9ybWFscyA9IG1lc2guZmFjZU5vcm1hbHMKCiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207CiAgICAgIGNvbnN0IHRvID0gdGhpcy50bzsKICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247CiAgICAgIHRyZWVUcmFuc2Zvcm0ucG9zaXRpb24uY29weShwb3NpdGlvbik7CiAgICAgIHRyZWVUcmFuc2Zvcm0ucXVhdGVybmlvbi5jb3B5KHF1YXQpOyAvLyBUcmFuc2Zvcm0gcmF5IHRvIGxvY2FsIHNwYWNlIQoKICAgICAgVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZGlyZWN0aW9uLCBsb2NhbERpcmVjdGlvbik7CiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZnJvbSwgbG9jYWxGcm9tKTsKICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCB0bywgbG9jYWxUbyk7CiAgICAgIGxvY2FsVG8ueCAqPSBtZXNoLnNjYWxlLng7CiAgICAgIGxvY2FsVG8ueSAqPSBtZXNoLnNjYWxlLnk7CiAgICAgIGxvY2FsVG8ueiAqPSBtZXNoLnNjYWxlLno7CiAgICAgIGxvY2FsRnJvbS54ICo9IG1lc2guc2NhbGUueDsKICAgICAgbG9jYWxGcm9tLnkgKj0gbWVzaC5zY2FsZS55OwogICAgICBsb2NhbEZyb20ueiAqPSBtZXNoLnNjYWxlLno7CiAgICAgIGxvY2FsVG8udnN1Yihsb2NhbEZyb20sIGxvY2FsRGlyZWN0aW9uKTsKICAgICAgbG9jYWxEaXJlY3Rpb24ubm9ybWFsaXplKCk7CiAgICAgIGNvbnN0IGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCA9IGxvY2FsRnJvbS5kaXN0YW5jZVNxdWFyZWQobG9jYWxUbyk7CiAgICAgIG1lc2gudHJlZS5yYXlRdWVyeSh0aGlzLCB0cmVlVHJhbnNmb3JtLCB0cmlhbmdsZXMpOwoKICAgICAgZm9yIChsZXQgaSA9IDAsIE4gPSB0cmlhbmdsZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCB0cmlhbmdsZXNJbmRleCA9IHRyaWFuZ2xlc1tpXTsKICAgICAgICBtZXNoLmdldE5vcm1hbCh0cmlhbmdsZXNJbmRleCwgbm9ybWFsKTsgLy8gZGV0ZXJtaW5lIGlmIHJheSBpbnRlcnNlY3RzIHRoZSBwbGFuZSBvZiB0aGUgZmFjZQogICAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbAogICAgICAgIC8vIEdldCBwbGFuZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy4uLgoKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogM10sIGEpOyAvLyAuLi5idXQgbWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgcmF5IGZyb20uIFdlJ2xsIGZpeCB0aGlzIGxhdGVyLgoKICAgICAgICBhLnZzdWIobG9jYWxGcm9tLCB2ZWN0b3IpOyAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZwoKICAgICAgICBjb25zdCBkb3QgPSBsb2NhbERpcmVjdGlvbi5kb3Qobm9ybWFsKTsgLy8gQmFpbCBvdXQgaWYgcmF5IGFuZCBwbGFuZSBhcmUgcGFyYWxsZWwKICAgICAgICAvLyBpZiAoTWF0aC5hYnMoIGRvdCApIDwgdGhpcy5wcmVjaXNpb24pewogICAgICAgIC8vICAgICBjb250aW51ZTsKICAgICAgICAvLyB9CiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZQoKICAgICAgICBjb25zdCBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7IC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXkKCiAgICAgICAgaWYgKHNjYWxhciA8IDApIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXIKCgogICAgICAgIGxvY2FsRGlyZWN0aW9uLnNjYWxlKHNjYWxhciwgaW50ZXJzZWN0UG9pbnQpOwogICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQobG9jYWxGcm9tLCBpbnRlcnNlY3RQb2ludCk7IC8vIEdldCB0cmlhbmdsZSB2ZXJ0aWNlcwoKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDFdLCBiKTsKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDJdLCBjKTsKICAgICAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVNxdWFyZWQobG9jYWxGcm9tKTsKCiAgICAgICAgaWYgKCEoUmF5LnBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYiwgYSwgYykgfHwgUmF5LnBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYSwgYiwgYykpIHx8IHNxdWFyZWREaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSAvLyB0cmFuc2Zvcm0gaW50ZXJzZWN0cG9pbnQgYW5kIG5vcm1hbCB0byB3b3JsZAoKCiAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZShxdWF0LCBub3JtYWwsIHdvcmxkTm9ybWFsKTsKICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIGludGVyc2VjdFBvaW50LCB3b3JsZEludGVyc2VjdFBvaW50KTsKICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbCwgd29ybGRJbnRlcnNlY3RQb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgdHJpYW5nbGVzSW5kZXgpOwogICAgICB9CgogICAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDsKICAgIH0KICAgIC8qKgogICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZQogICAgICovCgoKICAgIHJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBoaXRGYWNlSW5kZXgpIHsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTsKICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7IC8vIFNraXAgYmFjayBmYWNlcz8KCiAgICAgIGlmICh0aGlzLnNraXBCYWNrZmFjZXMgJiYgbm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbikgPiAwKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICByZXN1bHQuaGl0RmFjZUluZGV4ID0gdHlwZW9mIGhpdEZhY2VJbmRleCAhPT0gJ3VuZGVmaW5lZCcgPyBoaXRGYWNlSW5kZXggOiAtMTsKCiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7CiAgICAgICAgY2FzZSBSYXkuQUxMOgogICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlOwogICAgICAgICAgcmVzdWx0LnNldChmcm9tLCB0bywgbm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgZGlzdGFuY2UpOwogICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSBSYXkuQ0xPU0VTVDoKICAgICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdAogICAgICAgICAgaWYgKGRpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlIHx8ICFyZXN1bHQuaGFzSGl0KSB7CiAgICAgICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTsKICAgICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICAgIHJlc3VsdC5zZXQoZnJvbSwgdG8sIG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIGRpc3RhbmNlKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSBSYXkuQU5ZOgogICAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLgogICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlOwogICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICByZXN1bHQuc2V0KGZyb20sIHRvLCBub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBkaXN0YW5jZSk7CiAgICAgICAgICByZXN1bHQuc2hvdWxkU3RvcCA9IHRydWU7CiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBBcyBwZXIgIkJhcnljZW50cmljIFRlY2huaXF1ZSIgYXMgbmFtZWQKICAgICAqIHtAbGluayBodHRwczovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbCBoZXJlfSBidXQgd2l0aG91dCB0aGUgZGl2aXNpb24KICAgICAqLwoKCiAgICBzdGF0aWMgcG9pbnRJblRyaWFuZ2xlKHAsIGEsIGIsIGMpIHsKICAgICAgYy52c3ViKGEsIHYwKTsKICAgICAgYi52c3ViKGEsIHYxKTsKICAgICAgcC52c3ViKGEsIHYyKTsKICAgICAgY29uc3QgZG90MDAgPSB2MC5kb3QodjApOwogICAgICBjb25zdCBkb3QwMSA9IHYwLmRvdCh2MSk7CiAgICAgIGNvbnN0IGRvdDAyID0gdjAuZG90KHYyKTsKICAgICAgY29uc3QgZG90MTEgPSB2MS5kb3QodjEpOwogICAgICBjb25zdCBkb3QxMiA9IHYxLmRvdCh2Mik7CiAgICAgIGxldCB1OwogICAgICBsZXQgdjsKICAgICAgcmV0dXJuICh1ID0gZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpID49IDAgJiYgKHYgPSBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgPj0gMCAmJiB1ICsgdiA8IGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxOwogICAgfQoKICB9CiAgUmF5LkNMT1NFU1QgPSBSQVlfTU9ERVMuQ0xPU0VTVDsKICBSYXkuQU5ZID0gUkFZX01PREVTLkFOWTsKICBSYXkuQUxMID0gUkFZX01PREVTLkFMTDsKICBjb25zdCB0bXBBQUJCJDEgPSBuZXcgQUFCQigpOwogIGNvbnN0IHRtcEFycmF5ID0gW107CiAgY29uc3QgdjEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHYyID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RCb2R5X3hpID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RCb2R5X3FpID0gbmV3IFF1YXRlcm5pb24oKTsKICBjb25zdCBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYyA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgUmF5Y2FzdFJlc3VsdCgpOwogIGNvbnN0IGludGVyc2VjdENvbnZleE9wdGlvbnMgPSB7CiAgICBmYWNlTGlzdDogWzBdCiAgfTsKICBjb25zdCB3b3JsZFBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxSYXkgPSBuZXcgUmF5KCk7CiAgY29uc3QgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXggPSBbXTsKICBjb25zdCBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50ID0gbmV3IFZlYzMoKTsKICBjb25zdCBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0Q29udmV4X25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdENvbnZleF92ZWN0b3IgPSBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3dvcmxkSW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpOwogIG5ldyBBQUJCKCk7CiAgY29uc3QgaW50ZXJzZWN0VHJpbWVzaF90cmlhbmdsZXMgPSBbXTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7CiAgY29uc3QgdjAgPSBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdCA9IG5ldyBWZWMzKCk7CgogIGZ1bmN0aW9uIGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7CiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uCiAgICBwb3NpdGlvbi52c3ViKGZyb20sIHYwKTsKICAgIGNvbnN0IGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pOyAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24qZG90ICsgZnJvbQoKICAgIGRpcmVjdGlvbi5zY2FsZShkb3QsIGludGVyc2VjdCk7CiAgICBpbnRlcnNlY3QudmFkZChmcm9tLCBpbnRlcnNlY3QpOwogICAgY29uc3QgZGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7CiAgICByZXR1cm4gZGlzdGFuY2U7CiAgfQoKICAvKioKICAgKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy4KICAgKi8KICBjbGFzcyBTQVBCcm9hZHBoYXNlIGV4dGVuZHMgQnJvYWRwaGFzZSB7CiAgICAvKioKICAgICAqIExpc3Qgb2YgYm9kaWVzIGN1cnJlbnRseSBpbiB0aGUgYnJvYWRwaGFzZS4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi4KICAgICAqLwoKICAgIC8qKgogICAgICogQXhpcyB0byBzb3J0IHRoZSBib2RpZXMgYWxvbmcuCiAgICAgKiBTZXQgdG8gMCBmb3IgeCBheGlzLCBhbmQgMSBmb3IgeSBheGlzLgogICAgICogRm9yIGJlc3QgcGVyZm9ybWFuY2UsIHBpY2sgdGhlIGF4aXMgd2hlcmUgYm9kaWVzIGFyZSBtb3N0IGRpc3RyaWJ1dGVkLgogICAgICovCgogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgYm91bmRzIG9mIHR3byBib2RpZXMgb3ZlcmxhcCwgYWxvbmcgdGhlIGdpdmVuIFNBUCBheGlzLgogICAgICovCiAgICBzdGF0aWMgY2hlY2tCb3VuZHMoYmksIGJqLCBheGlzSW5kZXgpIHsKICAgICAgbGV0IGJpUG9zOwogICAgICBsZXQgYmpQb3M7CgogICAgICBpZiAoYXhpc0luZGV4ID09PSAwKSB7CiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi54OwogICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24ueDsKICAgICAgfSBlbHNlIGlmIChheGlzSW5kZXggPT09IDEpIHsKICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLnk7CiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi55OwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMikgewogICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24uejsKICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLno7CiAgICAgIH0KCiAgICAgIGNvbnN0IHJpID0gYmkuYm91bmRpbmdSYWRpdXMsCiAgICAgICAgICAgIHJqID0gYmouYm91bmRpbmdSYWRpdXMsCiAgICAgICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLAogICAgICAgICAgICBib3VuZEIxID0gYmpQb3MgLSByajsKICAgICAgcmV0dXJuIGJvdW5kQjEgPCBib3VuZEEyOwogICAgfSAvLyBOb3RlOiB0aGVzZSBhcmUgaWRlbnRpY2FsLCBzYXZlIGZvciB4L3kveiBsb3dlcmJvdW5kCgogICAgLyoqCiAgICAgKiBpbnNlcnRpb25Tb3J0WAogICAgICovCgoKICAgIHN0YXRpYyBpbnNlcnRpb25Tb3J0WChhKSB7CiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gYVtpXTsKICAgICAgICBsZXQgajsKCiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7CiAgICAgICAgICBpZiAoYVtqXS5hYWJiLmxvd2VyQm91bmQueCA8PSB2LmFhYmIubG93ZXJCb3VuZC54KSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGFbaiArIDFdID0gYVtqXTsKICAgICAgICB9CgogICAgICAgIGFbaiArIDFdID0gdjsKICAgICAgfQoKICAgICAgcmV0dXJuIGE7CiAgICB9CiAgICAvKioKICAgICAqIGluc2VydGlvblNvcnRZCiAgICAgKi8KCgogICAgc3RhdGljIGluc2VydGlvblNvcnRZKGEpIHsKICAgICAgZm9yIChsZXQgaSA9IDEsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgIGNvbnN0IHYgPSBhW2ldOwogICAgICAgIGxldCBqOwoKICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHsKICAgICAgICAgIGlmIChhW2pdLmFhYmIubG93ZXJCb3VuZC55IDw9IHYuYWFiYi5sb3dlckJvdW5kLnkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgYVtqICsgMV0gPSBhW2pdOwogICAgICAgIH0KCiAgICAgICAgYVtqICsgMV0gPSB2OwogICAgICB9CgogICAgICByZXR1cm4gYTsKICAgIH0KICAgIC8qKgogICAgICogaW5zZXJ0aW9uU29ydFoKICAgICAqLwoKCiAgICBzdGF0aWMgaW5zZXJ0aW9uU29ydFooYSkgewogICAgICBmb3IgKGxldCBpID0gMSwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgY29uc3QgdiA9IGFbaV07CiAgICAgICAgbGV0IGo7CgogICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkgewogICAgICAgICAgaWYgKGFbal0uYWFiYi5sb3dlckJvdW5kLnogPD0gdi5hYWJiLmxvd2VyQm91bmQueikgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBhW2ogKyAxXSA9IGFbal07CiAgICAgICAgfQoKICAgICAgICBhW2ogKyAxXSA9IHY7CiAgICAgIH0KCiAgICAgIHJldHVybiBhOwogICAgfQoKICAgIGNvbnN0cnVjdG9yKHdvcmxkKSB7CiAgICAgIHN1cGVyKCk7CiAgICAgIHRoaXMuYXhpc0xpc3QgPSBbXTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDsKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwoKICAgICAgdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBldmVudCA9PiB7CiAgICAgICAgYXhpc0xpc3QucHVzaChldmVudC5ib2R5KTsKICAgICAgfTsKCiAgICAgIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyID0gZXZlbnQgPT4gewogICAgICAgIGNvbnN0IGlkeCA9IGF4aXNMaXN0LmluZGV4T2YoZXZlbnQuYm9keSk7CgogICAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgICBheGlzTGlzdC5zcGxpY2UoaWR4LCAxKTsKICAgICAgICB9CiAgICAgIH07CgogICAgICBpZiAod29ybGQpIHsKICAgICAgICB0aGlzLnNldFdvcmxkKHdvcmxkKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDaGFuZ2UgdGhlIHdvcmxkCiAgICAgKi8KCgogICAgc2V0V29ybGQod29ybGQpIHsKICAgICAgLy8gQ2xlYXIgdGhlIG9sZCBheGlzIGFycmF5CiAgICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDsgLy8gQWRkIGFsbCBib2RpZXMgZnJvbSB0aGUgbmV3IHdvcmxkCgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKykgewogICAgICAgIHRoaXMuYXhpc0xpc3QucHVzaCh3b3JsZC5ib2RpZXNbaV0pOwogICAgICB9IC8vIFJlbW92ZSBvbGQgaGFuZGxlcnMsIGlmIGFueQoKCiAgICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZEJvZHknLCB0aGlzLl9hZGRCb2R5SGFuZGxlcik7CiAgICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZUJvZHknLCB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7IC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLgoKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcignYWRkQm9keScsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTsKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZlQm9keScsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTsKICAgICAgdGhpcy53b3JsZCA9IHdvcmxkOwogICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ29sbGVjdCBhbGwgY29sbGlzaW9uIHBhaXJzCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHAxLCBwMikgewogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmF4aXNMaXN0OwogICAgICBjb25zdCBOID0gYm9kaWVzLmxlbmd0aDsKICAgICAgY29uc3QgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7CiAgICAgIGxldCBpOwogICAgICBsZXQgajsKCiAgICAgIGlmICh0aGlzLmRpcnR5KSB7CiAgICAgICAgdGhpcy5zb3J0TGlzdCgpOwogICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTsKICAgICAgfSAvLyBMb29rIHRocm91Z2ggdGhlIGxpc3QKCgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKCiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBOOyBqKyspIHsKICAgICAgICAgIGNvbnN0IGJqID0gYm9kaWVzW2pdOwoKICAgICAgICAgIGlmICghdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSwgYmopKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyhiaSwgYmosIGF4aXNJbmRleCkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLCBiaiwgcDEsIHAyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBzb3J0TGlzdCgpIHsKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwogICAgICBjb25zdCBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDsKICAgICAgY29uc3QgTiA9IGF4aXNMaXN0Lmxlbmd0aDsgLy8gVXBkYXRlIEFBQkJzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYmkgPSBheGlzTGlzdFtpXTsKCiAgICAgICAgaWYgKGJpLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYmkudXBkYXRlQUFCQigpOwogICAgICAgIH0KICAgICAgfSAvLyBTb3J0IHRoZSBsaXN0CgoKICAgICAgaWYgKGF4aXNJbmRleCA9PT0gMCkgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFgoYXhpc0xpc3QpOwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMSkgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkoYXhpc0xpc3QpOwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMikgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFooYXhpc0xpc3QpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIHRoZSB2YXJpYW5jZSBvZiB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIGVzdGltYXRlcyB0aGUgYmVzdCBheGlzIHRvIHVzZS4KICAgICAqIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgYGF4aXNJbmRleGAuCiAgICAgKi8KCgogICAgYXV0b0RldGVjdEF4aXMoKSB7CiAgICAgIGxldCBzdW1YID0gMDsKICAgICAgbGV0IHN1bVgyID0gMDsKICAgICAgbGV0IHN1bVkgPSAwOwogICAgICBsZXQgc3VtWTIgPSAwOwogICAgICBsZXQgc3VtWiA9IDA7CiAgICAgIGxldCBzdW1aMiA9IDA7CiAgICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYXhpc0xpc3Q7CiAgICAgIGNvbnN0IE4gPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBpbnZOID0gMSAvIE47CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYiA9IGJvZGllc1tpXTsKICAgICAgICBjb25zdCBjZW50ZXJYID0gYi5wb3NpdGlvbi54OwogICAgICAgIHN1bVggKz0gY2VudGVyWDsKICAgICAgICBzdW1YMiArPSBjZW50ZXJYICogY2VudGVyWDsKICAgICAgICBjb25zdCBjZW50ZXJZID0gYi5wb3NpdGlvbi55OwogICAgICAgIHN1bVkgKz0gY2VudGVyWTsKICAgICAgICBzdW1ZMiArPSBjZW50ZXJZICogY2VudGVyWTsKICAgICAgICBjb25zdCBjZW50ZXJaID0gYi5wb3NpdGlvbi56OwogICAgICAgIHN1bVogKz0gY2VudGVyWjsKICAgICAgICBzdW1aMiArPSBjZW50ZXJaICogY2VudGVyWjsKICAgICAgfQoKICAgICAgY29uc3QgdmFyaWFuY2VYID0gc3VtWDIgLSBzdW1YICogc3VtWCAqIGludk47CiAgICAgIGNvbnN0IHZhcmlhbmNlWSA9IHN1bVkyIC0gc3VtWSAqIHN1bVkgKiBpbnZOOwogICAgICBjb25zdCB2YXJpYW5jZVogPSBzdW1aMiAtIHN1bVogKiBzdW1aICogaW52TjsKCiAgICAgIGlmICh2YXJpYW5jZVggPiB2YXJpYW5jZVkpIHsKICAgICAgICBpZiAodmFyaWFuY2VYID4gdmFyaWFuY2VaKSB7CiAgICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodmFyaWFuY2VZID4gdmFyaWFuY2VaKSB7CiAgICAgICAgdGhpcy5heGlzSW5kZXggPSAxOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLgogICAgICovCgoKICAgIGFhYmJRdWVyeSh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IFtdOwogICAgICB9CgogICAgICBpZiAodGhpcy5kaXJ0eSkgewogICAgICAgIHRoaXMuc29ydExpc3QoKTsKICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4OwogICAgICBsZXQgYXhpcyA9ICd4JzsKCiAgICAgIGlmIChheGlzSW5kZXggPT09IDEpIHsKICAgICAgICBheGlzID0gJ3knOwogICAgICB9CgogICAgICBpZiAoYXhpc0luZGV4ID09PSAyKSB7CiAgICAgICAgYXhpcyA9ICd6JzsKICAgICAgfQoKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwogICAgICBhYWJiLmxvd2VyQm91bmRbYXhpc107CiAgICAgIGFhYmIudXBwZXJCb3VuZFtheGlzXTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBiID0gYXhpc0xpc3RbaV07CgogICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYi51cGRhdGVBQUJCKCk7CiAgICAgICAgfQoKICAgICAgICBpZiAoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKSB7CiAgICAgICAgICByZXN1bHQucHVzaChiKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CgogIH0KCiAgY2xhc3MgVXRpbHMgewogICAgLyoqCiAgICAgKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy4KICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIG9iamVjdC4gTWF5IGJlIGZhbHN5OiBpbiB0aGlzIGNhc2UsIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC4KICAgICAqIEBwYXJhbSBkZWZhdWx0cyBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHZhbHVlcy4KICAgICAqIEByZXR1cm4gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LgogICAgICovCiAgICBzdGF0aWMgZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdHMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKSB7CiAgICAgICAgaWYgKCEoa2V5IGluIG9wdGlvbnMpKSB7CiAgICAgICAgICBvcHRpb25zW2tleV0gPSBkZWZhdWx0c1trZXldOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG9wdGlvbnM7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQ29uc3RyYWludCBiYXNlIGNsYXNzCiAgICovCiAgY2xhc3MgQ29uc3RyYWludCB7CiAgICAvKioKICAgICAqIEVxdWF0aW9ucyB0byBiZSBzb2x2ZWQgaW4gdGhpcyBjb25zdHJhaW50LgogICAgICovCgogICAgLyoqCiAgICAgKiBCb2R5IEEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEJvZHkgQi4KICAgICAqLwoKICAgIC8qKgogICAgICogU2V0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBib2RpZXMgdG8gY29sbGlkZSB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZC4KICAgICAqLwogICAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7CiAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdHJ1ZSwKICAgICAgICB3YWtlVXBCb2RpZXM6IHRydWUKICAgICAgfSk7CiAgICAgIHRoaXMuZXF1YXRpb25zID0gW107CiAgICAgIHRoaXMuYm9keUEgPSBib2R5QTsKICAgICAgdGhpcy5ib2R5QiA9IGJvZHlCOwogICAgICB0aGlzLmlkID0gQ29uc3RyYWludC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkOwoKICAgICAgaWYgKG9wdGlvbnMud2FrZVVwQm9kaWVzKSB7CiAgICAgICAgaWYgKGJvZHlBKSB7CiAgICAgICAgICBib2R5QS53YWtlVXAoKTsKICAgICAgICB9CgogICAgICAgIGlmIChib2R5QikgewogICAgICAgICAgYm9keUIud2FrZVVwKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFVwZGF0ZSBhbGwgdGhlIGVxdWF0aW9ucyB3aXRoIGRhdGEuCiAgICAgKi8KCgogICAgdXBkYXRlKCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyEnKTsKICAgIH0KICAgIC8qKgogICAgICogRW5hYmxlcyBhbGwgZXF1YXRpb25zIGluIHRoZSBjb25zdHJhaW50LgogICAgICovCgoKICAgIGVuYWJsZSgpIHsKICAgICAgY29uc3QgZXFzID0gdGhpcy5lcXVhdGlvbnM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVxcy5sZW5ndGg7IGkrKykgewogICAgICAgIGVxc1tpXS5lbmFibGVkID0gdHJ1ZTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBEaXNhYmxlcyBhbGwgZXF1YXRpb25zIGluIHRoZSBjb25zdHJhaW50LgogICAgICovCgoKICAgIGRpc2FibGUoKSB7CiAgICAgIGNvbnN0IGVxcyA9IHRoaXMuZXF1YXRpb25zOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBlcXNbaV0uZW5hYmxlZCA9IGZhbHNlOwogICAgICB9CiAgICB9CgogIH0KICBDb25zdHJhaW50LmlkQ291bnRlciA9IDA7CgogIC8qKgogICAqIEFuIGVsZW1lbnQgY29udGFpbmluZyA2IGVudHJpZXMsIDMgc3BhdGlhbCBhbmQgMyByb3RhdGlvbmFsIGRlZ3JlZXMgb2YgZnJlZWRvbS4KICAgKi8KCiAgY2xhc3MgSmFjb2JpYW5FbGVtZW50IHsKICAgIC8qKgogICAgICogc3BhdGlhbAogICAgICovCgogICAgLyoqCiAgICAgKiByb3RhdGlvbmFsCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLnNwYXRpYWwgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnJvdGF0aW9uYWwgPSBuZXcgVmVjMygpOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB3aXRoIG90aGVyIEphY29iaWFuRWxlbWVudAogICAgICovCgoKICAgIG11bHRpcGx5RWxlbWVudChlbGVtZW50KSB7CiAgICAgIHJldHVybiBlbGVtZW50LnNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyBlbGVtZW50LnJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7CiAgICB9CiAgICAvKioKICAgICAqIE11bHRpcGx5IHdpdGggdHdvIHZlY3RvcnMKICAgICAqLwoKCiAgICBtdWx0aXBseVZlY3RvcnMoc3BhdGlhbCwgcm90YXRpb25hbCkgewogICAgICByZXR1cm4gc3BhdGlhbC5kb3QodGhpcy5zcGF0aWFsKSArIHJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7CiAgICB9CgogIH0KCiAgLyoqCiAgICogRXF1YXRpb24gYmFzZSBjbGFzcy4KICAgKgogICAqIGBhYCwgYGJgIGFuZCBgZXBzYCBhcmUge0BsaW5rIGh0dHBzOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDE1L2xlY3R1cmVzL1NQT09LbGFibm90ZXMucGRmIFNQT09LfSBwYXJhbWV0ZXJzIHRoYXQgZGVmYXVsdCB0byBgMC4wYC4gU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzL2lzc3Vlcy8yMzgjaXNzdWVjb21tZW50LTE0NzE3MjMyNyB0aGlzIGV4Y2hhbmdlfSBmb3IgbW9yZSBkZXRhaWxzIG9uIENhbm5vbidzIHBoeXNpY3MgaW1wbGVtZW50YXRpb24uCiAgICovCiAgY2xhc3MgRXF1YXRpb24gewogICAgLyoqCiAgICAgKiBNaW5pbXVtIChyZWFkOiBuZWdhdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1heGltdW0gKHJlYWQ6IHBvc2l0aXZlIG1heCkgZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludC4KICAgICAqLwoKICAgIC8qKgogICAgICogU1BPT0sgcGFyYW1ldGVyCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNQT09LIHBhcmFtZXRlcgogICAgICovCgogICAgLyoqCiAgICAgKiBTUE9PSyBwYXJhbWV0ZXIKICAgICAqLwoKICAgIC8qKgogICAgICogQSBudW1iZXIsIHByb3BvcnRpb25hbCB0byB0aGUgZm9yY2UgYWRkZWQgdG8gdGhlIGJvZGllcy4KICAgICAqLwogICAgY29uc3RydWN0b3IoYmksIGJqLCBtaW5Gb3JjZSwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1pbkZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtaW5Gb3JjZSA9IC0xZTY7CiAgICAgIH0KCiAgICAgIGlmIChtYXhGb3JjZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7CiAgICAgIH0KCiAgICAgIHRoaXMuaWQgPSBFcXVhdGlvbi5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5taW5Gb3JjZSA9IG1pbkZvcmNlOwogICAgICB0aGlzLm1heEZvcmNlID0gbWF4Rm9yY2U7CiAgICAgIHRoaXMuYmkgPSBiaTsKICAgICAgdGhpcy5iaiA9IGJqOwogICAgICB0aGlzLmEgPSAwLjA7IC8vIFNQT09LIHBhcmFtZXRlcgoKICAgICAgdGhpcy5iID0gMC4wOyAvLyBTUE9PSyBwYXJhbWV0ZXIKCiAgICAgIHRoaXMuZXBzID0gMC4wOyAvLyBTUE9PSyBwYXJhbWV0ZXIKCiAgICAgIHRoaXMuamFjb2JpYW5FbGVtZW50QSA9IG5ldyBKYWNvYmlhbkVsZW1lbnQoKTsKICAgICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRCID0gbmV3IEphY29iaWFuRWxlbWVudCgpOwogICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlOwogICAgICB0aGlzLm11bHRpcGxpZXIgPSAwOwogICAgICB0aGlzLnNldFNwb29rUGFyYW1zKDFlNywgNCwgMSAvIDYwKTsgLy8gU2V0IHR5cGljYWwgc3Bvb2sgcGFyYW1zCiAgICB9CiAgICAvKioKICAgICAqIFJlY2FsY3VsYXRlcyBhLCBiLCBhbmQgZXBzLgogICAgICoKICAgICAqIFRoZSBFcXVhdGlvbiBjb25zdHJ1Y3RvciBzZXRzIHR5cGljYWwgU1BPT0sgcGFyYW1ldGVycyBhcyBzdWNoOgogICAgICogKiBgc3RpZmZuZXNzYCA9IDFlNwogICAgICogKiBgcmVsYXhhdGlvbmAgPSA0CiAgICAgKiAqIGB0aW1lU3RlcGA9IDEgLyA2MCwgX25vdGUgdGhlIGhhcmRjb2RlZCByZWZyZXNoIHJhdGUuXwogICAgICovCgoKICAgIHNldFNwb29rUGFyYW1zKHN0aWZmbmVzcywgcmVsYXhhdGlvbiwgdGltZVN0ZXApIHsKICAgICAgY29uc3QgZCA9IHJlbGF4YXRpb247CiAgICAgIGNvbnN0IGsgPSBzdGlmZm5lc3M7CiAgICAgIGNvbnN0IGggPSB0aW1lU3RlcDsKICAgICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7CiAgICAgIHRoaXMuYiA9IDQuMCAqIGQgLyAoMSArIDQgKiBkKTsKICAgICAgdGhpcy5lcHMgPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBTUE9PSyBlcXVhdGlvbgogICAgICovCgoKICAgIGNvbXB1dGVCKGEsIGIsIGgpIHsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHcSA9IHRoaXMuY29tcHV0ZUdxKCk7CiAgICAgIGNvbnN0IEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7CiAgICAgIHJldHVybiAtR3EgKiBhIC0gR1cgKiBiIC0gR2lNZiAqIGg7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIEcqcSwgd2hlcmUgcSBhcmUgdGhlIGdlbmVyYWxpemVkIGJvZHkgY29vcmRpbmF0ZXMKICAgICAqLwoKCiAgICBjb21wdXRlR3EoKSB7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgY29uc3QgYmkgPSB0aGlzLmJpOwogICAgICBjb25zdCBiaiA9IHRoaXMuYmo7CiAgICAgIGNvbnN0IHhpID0gYmkucG9zaXRpb247CiAgICAgIGNvbnN0IHhqID0gYmoucG9zaXRpb247CiAgICAgIHJldHVybiBHQS5zcGF0aWFsLmRvdCh4aSkgKyBHQi5zcGF0aWFsLmRvdCh4aik7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIEcqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllcwogICAgICovCgoKICAgIGNvbXB1dGVHVygpIHsKICAgICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7CiAgICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgdmkgPSBiaS52ZWxvY2l0eTsKICAgICAgY29uc3QgdmogPSBiai52ZWxvY2l0eTsKICAgICAgY29uc3Qgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHk7CiAgICAgIGNvbnN0IHdqID0gYmouYW5ndWxhclZlbG9jaXR5OwogICAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLCB3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosIHdqKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZXMgRypXbGFtYmRhLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzCiAgICAgKi8KCgogICAgY29tcHV0ZUdXbGFtYmRhKCkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCB2aSA9IGJpLnZsYW1iZGE7CiAgICAgIGNvbnN0IHZqID0gYmoudmxhbWJkYTsKICAgICAgY29uc3Qgd2kgPSBiaS53bGFtYmRhOwogICAgICBjb25zdCB3aiA9IGJqLndsYW1iZGE7CiAgICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnModmksIHdpKSArIEdCLm11bHRpcGx5VmVjdG9ycyh2aiwgd2opOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyBHKmludihNKSpmLCB3aGVyZSBNIGlzIHRoZSBtYXNzIG1hdHJpeCB3aXRoIGRpYWdvbmFsIGJsb2NrcyBmb3IgZWFjaCBib2R5LCBhbmQgZiBhcmUgdGhlIGZvcmNlcyBvbiB0aGUgYm9kaWVzLgogICAgICovCgoKICAgIGNvbXB1dGVHaU1mKCkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCBmaSA9IGJpLmZvcmNlOwogICAgICBjb25zdCB0aSA9IGJpLnRvcnF1ZTsKICAgICAgY29uc3QgZmogPSBiai5mb3JjZTsKICAgICAgY29uc3QgdGogPSBiai50b3JxdWU7CiAgICAgIGNvbnN0IGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlOwogICAgICBjb25zdCBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZTsKICAgICAgZmkuc2NhbGUoaW52TWFzc2ksIGlNZmkpOwogICAgICBmai5zY2FsZShpbnZNYXNzaiwgaU1maik7CiAgICAgIGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRpLCBpbnZJaV92bXVsdF90YXVpKTsKICAgICAgYmouaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQodGosIGludklqX3ZtdWx0X3RhdWopOwogICAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKGlNZmksIGludklpX3ZtdWx0X3RhdWkpICsgR0IubXVsdGlwbHlWZWN0b3JzKGlNZmosIGludklqX3ZtdWx0X3RhdWopOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyBHKmludihNKSpHJwogICAgICovCgoKICAgIGNvbXB1dGVHaU1HdCgpIHsKICAgICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7CiAgICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmU7CiAgICAgIGNvbnN0IGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlOwogICAgICBjb25zdCBpbnZJaSA9IGJpLmludkluZXJ0aWFXb3JsZFNvbHZlOwogICAgICBjb25zdCBpbnZJaiA9IGJqLmludkluZXJ0aWFXb3JsZFNvbHZlOwogICAgICBsZXQgcmVzdWx0ID0gaW52TWFzc2kgKyBpbnZNYXNzajsKICAgICAgaW52SWkudm11bHQoR0Eucm90YXRpb25hbCwgdG1wKTsKICAgICAgcmVzdWx0ICs9IHRtcC5kb3QoR0Eucm90YXRpb25hbCk7CiAgICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsIHRtcCk7CiAgICAgIHJlc3VsdCArPSB0bXAuZG90KEdCLnJvdGF0aW9uYWwpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLgogICAgICovCgoKICAgIGFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXA7IC8vIEFkZCB0byBsaW5lYXIgdmVsb2NpdHkKICAgICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHCgogICAgICBiaS52bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihiaS5pbnZNYXNzU29sdmUgKiBkZWx0YWxhbWJkYSwgR0Euc3BhdGlhbCwgYmkudmxhbWJkYSk7CiAgICAgIGJqLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJqLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQi5zcGF0aWFsLCBiai52bGFtYmRhKTsgLy8gQWRkIHRvIGFuZ3VsYXIgdmVsb2NpdHkKCiAgICAgIGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdBLnJvdGF0aW9uYWwsIHRlbXApOwogICAgICBiaS53bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihkZWx0YWxhbWJkYSwgdGVtcCwgYmkud2xhbWJkYSk7CiAgICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdCLnJvdGF0aW9uYWwsIHRlbXApOwogICAgICBiai53bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihkZWx0YWxhbWJkYSwgdGVtcCwgYmoud2xhbWJkYSk7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gRyppbnYoTSkqRycgKyBlcHMKICAgICAqLwoKCiAgICBjb21wdXRlQygpIHsKICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpTUd0KCkgKyB0aGlzLmVwczsKICAgIH0KCiAgfQogIEVxdWF0aW9uLmlkQ291bnRlciA9IDA7CiAgY29uc3QgaU1maSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaU1maiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW52SWlfdm11bHRfdGF1aSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW52SWpfdm11bHRfdGF1aiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wID0gbmV3IFZlYzMoKTsKICBjb25zdCBhZGRUb1dsYW1iZGFfdGVtcCA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIENvbnRhY3Qvbm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb24KICAgKi8KICBjbGFzcyBDb250YWN0RXF1YXRpb24gZXh0ZW5kcyBFcXVhdGlvbiB7CiAgICAvKioKICAgICAqICJib3VuY2luZXNzIjogdTEgPSAtZSp1MAogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBnb2VzIGZyb20gdGhlIGNlbnRlciBvZiBiaSB0byB0aGUgY29udGFjdCBwb2ludC4KICAgICAqLwoKICAgIC8qKgogICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIHRoYXQgc3RhcnRzIGluIGJvZHkgaiBwb3NpdGlvbiBhbmQgZ29lcyB0byB0aGUgY29udGFjdCBwb2ludC4KICAgICAqLwoKICAgIC8qKgogICAgICogQ29udGFjdCBub3JtYWwsIHBvaW50aW5nIG91dCBvZiBib2R5IGkuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1heEZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtYXhGb3JjZSA9IDFlNjsKICAgICAgfQoKICAgICAgc3VwZXIoYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7CiAgICAgIHRoaXMucmkgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnJqID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5uaSA9IG5ldyBWZWMzKCk7CiAgICB9CgogICAgY29tcHV0ZUIoaCkgewogICAgICBjb25zdCBhID0gdGhpcy5hOwogICAgICBjb25zdCBiID0gdGhpcy5iOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgcmkgPSB0aGlzLnJpOwogICAgICBjb25zdCByaiA9IHRoaXMucmo7CiAgICAgIGNvbnN0IHJpeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDE7CiAgICAgIGNvbnN0IHJqeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDI7CiAgICAgIGNvbnN0IHZpID0gYmkudmVsb2NpdHk7CiAgICAgIGNvbnN0IHdpID0gYmkuYW5ndWxhclZlbG9jaXR5OwogICAgICBiaS5mb3JjZTsKICAgICAgYmkudG9ycXVlOwogICAgICBjb25zdCB2aiA9IGJqLnZlbG9jaXR5OwogICAgICBjb25zdCB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTsKICAgICAgYmouZm9yY2U7CiAgICAgIGJqLnRvcnF1ZTsKICAgICAgY29uc3QgcGVuZXRyYXRpb25WZWMgPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDM7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgY29uc3QgbiA9IHRoaXMubmk7IC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0cwoKICAgICAgcmkuY3Jvc3Mobiwgcml4bik7CiAgICAgIHJqLmNyb3NzKG4sIHJqeG4pOyAvLyBnID0geGorcmogLSh4aStyaSkKICAgICAgLy8gRyA9IFsgLW5pICAtcml4biAgbmkgIHJqeG4gXQoKICAgICAgbi5uZWdhdGUoR0Euc3BhdGlhbCk7CiAgICAgIHJpeG4ubmVnYXRlKEdBLnJvdGF0aW9uYWwpOwogICAgICBHQi5zcGF0aWFsLmNvcHkobik7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShyanhuKTsgLy8gQ2FsY3VsYXRlIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3IKCiAgICAgIHBlbmV0cmF0aW9uVmVjLmNvcHkoYmoucG9zaXRpb24pOwogICAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLCBwZW5ldHJhdGlvblZlYyk7CiAgICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIoYmkucG9zaXRpb24sIHBlbmV0cmF0aW9uVmVjKTsKICAgICAgcGVuZXRyYXRpb25WZWMudnN1YihyaSwgcGVuZXRyYXRpb25WZWMpOwogICAgICBjb25zdCBnID0gbi5kb3QocGVuZXRyYXRpb25WZWMpOyAvLyBDb21wdXRlIGl0ZXJhdGlvbgoKICAgICAgY29uc3QgZVBsdXNPbmUgPSB0aGlzLnJlc3RpdHV0aW9uICsgMTsKICAgICAgY29uc3QgR1cgPSBlUGx1c09uZSAqIHZqLmRvdChuKSAtIGVQbHVzT25lICogdmkuZG90KG4pICsgd2ouZG90KHJqeG4pIC0gd2kuZG90KHJpeG4pOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLWcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7CiAgICAgIHJldHVybiBCOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcmVsYXRpdmUgdmVsb2NpdHkgaW4gdGhlIGNvbnRhY3QgcG9pbnQuCiAgICAgKi8KCgogICAgZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCgpIHsKICAgICAgY29uc3QgdmkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aTsKICAgICAgY29uc3QgdmogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92ajsKICAgICAgY29uc3QgeGkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aTsKICAgICAgY29uc3QgeGogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94ajsKICAgICAgY29uc3QgcmVsVmVsID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfcmVsVmVsOwogICAgICB0aGlzLmJpLnBvc2l0aW9uLnZhZGQodGhpcy5yaSwgeGkpOwogICAgICB0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaiwgeGopOwogICAgICB0aGlzLmJpLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHhpLCB2aSk7CiAgICAgIHRoaXMuYmouZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGosIHZqKTsKICAgICAgdmkudnN1Yih2aiwgcmVsVmVsKTsKICAgICAgcmV0dXJuIHRoaXMubmkuZG90KHJlbFZlbCk7CiAgICB9CgogIH0KICBjb25zdCBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnMKCiAgY29uc3QgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMgPSBuZXcgVmVjMygpOwogIGNvbnN0IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZpID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGkgPSBuZXcgVmVjMygpOwogIGNvbnN0IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3hqID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWwgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3QgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSkKICAgKiAgICAgY29uc3QgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSkKICAgKiAgICAgYm9keUEucG9zaXRpb24uc2V0KC0xLCAwLCAwKQogICAqICAgICBib2R5Qi5wb3NpdGlvbi5zZXQoMSwgMCwgMCkKICAgKiAgICAgYm9keUEuYWRkU2hhcGUoc2hhcGVBKQogICAqICAgICBib2R5Qi5hZGRTaGFwZShzaGFwZUIpCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUEpCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUIpCiAgICogICAgIGNvbnN0IGxvY2FsUGl2b3RBID0gbmV3IFZlYzMoMSwgMCwgMCkKICAgKiAgICAgY29uc3QgbG9jYWxQaXZvdEIgPSBuZXcgVmVjMygtMSwgMCwgMCkKICAgKiAgICAgY29uc3QgY29uc3RyYWludCA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KGJvZHlBLCBsb2NhbFBpdm90QSwgYm9keUIsIGxvY2FsUGl2b3RCKQogICAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpCiAgICovCiAgY2xhc3MgUG9pbnRUb1BvaW50Q29uc3RyYWludCBleHRlbmRzIENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLgogICAgICovCgogICAgLyoqCiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLgogICAgICovCgogICAgLyoqCiAgICAgKiBAcGFyYW0gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uCiAgICAgKiBAcGFyYW0gYm9keUIgQm9keSB0aGF0IHdpbGwgYmUgY29uc3RyYWluZWQgaW4gYSBzaW1pbGFyIHdheSB0byB0aGUgc2FtZSBwb2ludCBhcyBib2R5QS4gV2Ugd2lsbCB0aGVyZWZvcmUgZ2V0IGEgbGluayBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5Qi4gSWYgbm90IHNwZWNpZmllZCwgYm9keUEgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBhIHN0YXRpYyBwb2ludC4KICAgICAqIEBwYXJhbSBwaXZvdEIgVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiBib2R5QiB3aGljaCBib2R5QiBpcyBjb25zdHJhaW5lZCB0by4KICAgICAqIEBwYXJhbSBtYXhGb3JjZSBUaGUgbWF4aW11bSBmb3JjZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNvbnN0cmFpbiB0aGUgYm9kaWVzLgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSkgewogICAgICBpZiAocGl2b3RBID09PSB2b2lkIDApIHsKICAgICAgICBwaXZvdEEgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAocGl2b3RCID09PSB2b2lkIDApIHsKICAgICAgICBwaXZvdEIgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAobWF4Rm9yY2UgPT09IHZvaWQgMCkgewogICAgICAgIG1heEZvcmNlID0gMWU2OwogICAgICB9CgogICAgICBzdXBlcihib2R5QSwgYm9keUIpOwogICAgICB0aGlzLnBpdm90QSA9IHBpdm90QS5jbG9uZSgpOwogICAgICB0aGlzLnBpdm90QiA9IHBpdm90Qi5jbG9uZSgpOwogICAgICBjb25zdCB4ID0gdGhpcy5lcXVhdGlvblggPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7CiAgICAgIGNvbnN0IHkgPSB0aGlzLmVxdWF0aW9uWSA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKTsKICAgICAgY29uc3QgeiA9IHRoaXMuZXF1YXRpb25aID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIpOyAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXIKCiAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goeCwgeSwgeik7IC8vIE1ha2UgdGhlIGVxdWF0aW9ucyBiaWRpcmVjdGlvbmFsCgogICAgICB4Lm1pbkZvcmNlID0geS5taW5Gb3JjZSA9IHoubWluRm9yY2UgPSAtbWF4Rm9yY2U7CiAgICAgIHgubWF4Rm9yY2UgPSB5Lm1heEZvcmNlID0gei5tYXhGb3JjZSA9IG1heEZvcmNlOwogICAgICB4Lm5pLnNldCgxLCAwLCAwKTsKICAgICAgeS5uaS5zZXQoMCwgMSwgMCk7CiAgICAgIHoubmkuc2V0KDAsIDAsIDEpOwogICAgfQoKICAgIHVwZGF0ZSgpIHsKICAgICAgY29uc3QgYm9keUEgPSB0aGlzLmJvZHlBOwogICAgICBjb25zdCBib2R5QiA9IHRoaXMuYm9keUI7CiAgICAgIGNvbnN0IHggPSB0aGlzLmVxdWF0aW9uWDsKICAgICAgY29uc3QgeSA9IHRoaXMuZXF1YXRpb25ZOwogICAgICBjb25zdCB6ID0gdGhpcy5lcXVhdGlvblo7IC8vIFJvdGF0ZSB0aGUgcGl2b3RzIHRvIHdvcmxkIHNwYWNlCgogICAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLCB4LnJpKTsKICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90QiwgeC5yaik7CiAgICAgIHkucmkuY29weSh4LnJpKTsKICAgICAgeS5yai5jb3B5KHgucmopOwogICAgICB6LnJpLmNvcHkoeC5yaSk7CiAgICAgIHoucmouY29weSh4LnJqKTsKICAgIH0KCiAgfQoKICAvKioKICAgKiBDb25lIGVxdWF0aW9uLiBXb3JrcyB0byBrZWVwIHRoZSBnaXZlbiBib2R5IHdvcmxkIHZlY3RvcnMgYWxpZ25lZCwgb3IgdGlsdGVkIHdpdGhpbiBhIGdpdmVuIGFuZ2xlIGZyb20gZWFjaCBvdGhlci4KICAgKi8KICBjbGFzcyBDb25lRXF1YXRpb24gZXh0ZW5kcyBFcXVhdGlvbiB7CiAgICAvKioKICAgICAqIExvY2FsIGF4aXMgaW4gQQogICAgICovCgogICAgLyoqCiAgICAgKiBMb2NhbCBheGlzIGluIEIKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlICJjb25lIGFuZ2xlIiB0byBrZWVwCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7CiAgICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy5hbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIGNvbnN0IGEgPSB0aGlzLmE7CiAgICAgIGNvbnN0IGIgPSB0aGlzLmI7CiAgICAgIGNvbnN0IG5pID0gdGhpcy5heGlzQTsKICAgICAgY29uc3QgbmogPSB0aGlzLmF4aXNCOwogICAgICBjb25zdCBuaXhuaiA9IHRtcFZlYzEkMjsKICAgICAgY29uc3Qgbmp4bmkgPSB0bXBWZWMyJDI7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzCgogICAgICBuaS5jcm9zcyhuaiwgbml4bmopOwogICAgICBuai5jcm9zcyhuaSwgbmp4bmkpOyAvLyBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yIGlzOgogICAgICAvLyBjb3ModGhldGEpID0gYSAqIGIgLyAobGVuZ3RoKGEpICogbGVuZ3RoKGIpID0geyBsZW4oYSkgPSBsZW4oYikgPSAxIH0gPSBhICogYgogICAgICAvLyBnID0gYSAqIGIKICAgICAgLy8gZ2RvdCA9IChiIHggYSkgKiB3aSArIChhIHggYikgKiB3agogICAgICAvLyBHID0gWzAgYnhhIDAgYXhiXQogICAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXQoKICAgICAgR0Eucm90YXRpb25hbC5jb3B5KG5qeG5pKTsKICAgICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTsKICAgICAgY29uc3QgZyA9IE1hdGguY29zKHRoaXMuYW5nbGUpIC0gbmkuZG90KG5qKTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLWcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7CiAgICAgIHJldHVybiBCOwogICAgfQoKICB9CiAgY29uc3QgdG1wVmVjMSQyID0gbmV3IFZlYzMoKTsKICBjb25zdCB0bXBWZWMyJDIgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBSb3RhdGlvbmFsIGNvbnN0cmFpbnQuIFdvcmtzIHRvIGtlZXAgdGhlIGxvY2FsIHZlY3RvcnMgb3J0aG9nb25hbCB0byBlYWNoIG90aGVyIGluIHdvcmxkIHNwYWNlLgogICAqLwogIGNsYXNzIFJvdGF0aW9uYWxFcXVhdGlvbiBleHRlbmRzIEVxdWF0aW9uIHsKICAgIC8qKgogICAgICogV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzLgogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIG1heEFuZ2xlCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7CiAgICAgIHRoaXMubWF4QW5nbGUgPSBNYXRoLlBJIC8gMjsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIGNvbnN0IGEgPSB0aGlzLmE7CiAgICAgIGNvbnN0IGIgPSB0aGlzLmI7CiAgICAgIGNvbnN0IG5pID0gdGhpcy5heGlzQTsKICAgICAgY29uc3QgbmogPSB0aGlzLmF4aXNCOwogICAgICBjb25zdCBuaXhuaiA9IHRtcFZlYzEkMTsKICAgICAgY29uc3Qgbmp4bmkgPSB0bXBWZWMyJDE7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzCgogICAgICBuaS5jcm9zcyhuaiwgbml4bmopOwogICAgICBuai5jcm9zcyhuaSwgbmp4bmkpOyAvLyBnID0gbmkgKiBuagogICAgICAvLyBnZG90ID0gKG5qIHggbmkpICogd2kgKyAobmkgeCBuaikgKiB3agogICAgICAvLyBHID0gWzAgbmp4bmkgMCBuaXhual0KICAgICAgLy8gVyA9IFt2aSB3aSB2aiB3al0KCiAgICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShuaXhuaik7CiAgICAgIGNvbnN0IGcgPSBNYXRoLmNvcyh0aGlzLm1heEFuZ2xlKSAtIG5pLmRvdChuaik7CiAgICAgIGNvbnN0IEdXID0gdGhpcy5jb21wdXRlR1coKTsKICAgICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTsKICAgICAgY29uc3QgQiA9IC1nICogYSAtIEdXICogYiAtIGggKiBHaU1mOwogICAgICByZXR1cm4gQjsKICAgIH0KCiAgfQogIGNvbnN0IHRtcFZlYzEkMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMiQxID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQSBDb25lIFR3aXN0IGNvbnN0cmFpbnQsIHVzZWZ1bCBmb3IgcmFnZG9sbHMuCiAgICovCiAgY2xhc3MgQ29uZVR3aXN0Q29uc3RyYWludCBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBUaGUgYXhpcyBkaXJlY3Rpb24gZm9yIHRoZSBjb25zdHJhaW50IG9mIHRoZSBib2R5IEEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBheGlzIGRpcmVjdGlvbiBmb3IgdGhlIGNvbnN0cmFpbnQgb2YgdGhlIGJvZHkgQi4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGFwZXJ0dXJlIGFuZ2xlIG9mIHRoZSBjb25lLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgdHdpc3QgYW5nbGUgb2YgdGhlIGpvaW50LgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihib2R5QSwgYm9keUIsIG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgY29uc3QgbWF4Rm9yY2UgPSB0eXBlb2Ygb3B0aW9ucy5tYXhGb3JjZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2OyAvLyBTZXQgcGl2b3QgcG9pbnQgaW4gYmV0d2VlbgoKICAgICAgY29uc3QgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcGl2b3RCID0gb3B0aW9ucy5waXZvdEIgPyBvcHRpb25zLnBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOwogICAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gISFvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7CiAgICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy5hbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDsKICAgICAgY29uc3QgYyA9IHRoaXMuY29uZUVxdWF0aW9uID0gbmV3IENvbmVFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICBjb25zdCB0ID0gdGhpcy50d2lzdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICB0aGlzLnR3aXN0QW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy50d2lzdEFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMudHdpc3RBbmdsZSA6IDA7IC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZAoKICAgICAgYy5tYXhGb3JjZSA9IDA7CiAgICAgIGMubWluRm9yY2UgPSAtbWF4Rm9yY2U7IC8vIE1ha2UgdGhlIHR3aXN0IGVxdWF0aW9uIGFkZCB0b3JxdWUgdG93YXJkIHRoZSBpbml0aWFsIHBvc2l0aW9uCgogICAgICB0Lm1heEZvcmNlID0gMDsKICAgICAgdC5taW5Gb3JjZSA9IC1tYXhGb3JjZTsKICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChjLCB0KTsKICAgIH0KCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBjb25lID0gdGhpcy5jb25lRXF1YXRpb247CiAgICAgIGNvbnN0IHR3aXN0ID0gdGhpcy50d2lzdEVxdWF0aW9uOwogICAgICBzdXBlci51cGRhdGUoKTsgLy8gVXBkYXRlIHRoZSBheGVzIHRvIHRoZSBjb25lIGNvbnN0cmFpbnQKCiAgICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNBLCBjb25lLmF4aXNBKTsKICAgICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuYXhpc0IsIGNvbmUuYXhpc0IpOyAvLyBVcGRhdGUgdGhlIHdvcmxkIGF4ZXMgaW4gdGhlIHR3aXN0IGNvbnN0cmFpbnQKCiAgICAgIHRoaXMuYXhpc0EudGFuZ2VudHModHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTsKICAgICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKHR3aXN0LmF4aXNBLCB0d2lzdC5heGlzQSk7CiAgICAgIHRoaXMuYXhpc0IudGFuZ2VudHModHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTsKICAgICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHR3aXN0LmF4aXNCLCB0d2lzdC5heGlzQik7CiAgICAgIGNvbmUuYW5nbGUgPSB0aGlzLmFuZ2xlOwogICAgICB0d2lzdC5tYXhBbmdsZSA9IHRoaXMudHdpc3RBbmdsZTsKICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQ29uc3RyYWlucyB0d28gYm9kaWVzIHRvIGJlIGF0IGEgY29uc3RhbnQgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVycyBjZW50ZXIgb2YgbWFzcy4KICAgKi8KICBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnQgZXh0ZW5kcyBDb25zdHJhaW50IHsKICAgIC8qKgogICAgICogVGhlIGRpc3RhbmNlIHRvIGtlZXAuIElmIHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiBib2R5QSBhbmQgYm9keUIKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGRpc3RhbmNlIFRoZSBkaXN0YW5jZSB0byBrZWVwLiBJZiB1bmRlZmluZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gYm9keUEgYW5kIGJvZHlCLgogICAgICogQHBhcmFtIG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgZGlzdGFuY2UsIG1heEZvcmNlKSB7CiAgICAgIGlmIChtYXhGb3JjZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7CiAgICAgIH0KCiAgICAgIHN1cGVyKGJvZHlBLCBib2R5Qik7CgogICAgICBpZiAodHlwZW9mIGRpc3RhbmNlID09PSAndW5kZWZpbmVkJykgewogICAgICAgIGRpc3RhbmNlID0gYm9keUEucG9zaXRpb24uZGlzdGFuY2VUbyhib2R5Qi5wb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTsKICAgICAgY29uc3QgZXEgPSB0aGlzLmRpc3RhbmNlRXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7CiAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpOyAvLyBNYWtlIGl0IGJpZGlyZWN0aW9uYWwKCiAgICAgIGVxLm1pbkZvcmNlID0gLW1heEZvcmNlOwogICAgICBlcS5tYXhGb3JjZSA9IG1heEZvcmNlOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbjsKICAgICAgY29uc3QgaGFsZkRpc3QgPSB0aGlzLmRpc3RhbmNlICogMC41OwogICAgICBjb25zdCBub3JtYWwgPSBlcS5uaTsKICAgICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbiwgbm9ybWFsKTsKICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpOwogICAgICBub3JtYWwuc2NhbGUoaGFsZkRpc3QsIGVxLnJpKTsKICAgICAgbm9ybWFsLnNjYWxlKC1oYWxmRGlzdCwgZXEucmopOwogICAgfQoKICB9CgogIC8qKgogICAqIExvY2sgY29uc3RyYWludC4gV2lsbCByZW1vdmUgYWxsIGRlZ3JlZXMgb2YgZnJlZWRvbSBiZXR3ZWVuIHRoZSBib2RpZXMuCiAgICovCiAgY2xhc3MgTG9ja0NvbnN0cmFpbnQgZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50IHsKICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7IC8vIFNldCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuCgogICAgICBjb25zdCBwaXZvdEEgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBwaXZvdEIgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBoYWxmV2F5ID0gbmV3IFZlYzMoKTsKICAgICAgYm9keUEucG9zaXRpb24udmFkZChib2R5Qi5wb3NpdGlvbiwgaGFsZldheSk7CiAgICAgIGhhbGZXYXkuc2NhbGUoMC41LCBoYWxmV2F5KTsKICAgICAgYm9keUIucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RCKTsKICAgICAgYm9keUEucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RBKTsgLy8gVGhlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQgd2lsbCBrZWVwIGEgcG9pbnQgc2hhcmVkIGJldHdlZW4gdGhlIGJvZGllcwoKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOyAvLyBTdG9yZSBpbml0aWFsIHJvdGF0aW9uIG9mIHRoZSBib2RpZXMgYXMgdW5pdCB2ZWN0b3JzIGluIHRoZSBsb2NhbCBib2R5IHNwYWNlcwoKICAgICAgdGhpcy54QSA9IGJvZHlBLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWCk7CiAgICAgIHRoaXMueEIgPSBib2R5Qi52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1gpOwogICAgICB0aGlzLnlBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTsKICAgICAgdGhpcy55QiA9IGJvZHlCLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWSk7CiAgICAgIHRoaXMuekEgPSBib2R5QS52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1opOwogICAgICB0aGlzLnpCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTsgLy8gLi4uYW5kIHRoZSBmb2xsb3dpbmcgcm90YXRpb25hbCBlcXVhdGlvbnMgd2lsbCBrZWVwIGFsbCByb3RhdGlvbmFsIERPRidzIGluIHBsYWNlCgogICAgICBjb25zdCByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTsKICAgICAgY29uc3QgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7CiAgICAgIGNvbnN0IHIzID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24zID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHIxLCByMiwgcjMpOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICB0aGlzLm1vdG9yRXF1YXRpb247CiAgICAgIGNvbnN0IHIxID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xOwogICAgICBjb25zdCByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMjsKICAgICAgY29uc3QgcjMgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjM7CiAgICAgIHN1cGVyLnVwZGF0ZSgpOyAvLyBUaGVzZSB2ZWN0b3IgcGFpcnMgbXVzdCBiZSBvcnRob2dvbmFsCgogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QSwgcjEuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QiwgcjEuYXhpc0IpOwogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QSwgcjIuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QiwgcjIuYXhpc0IpOwogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QSwgcjMuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QiwgcjMuYXhpc0IpOwogICAgfQoKICB9CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwoKICAvKioKICAgKiBSb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnQuIFRyaWVzIHRvIGtlZXAgdGhlIHJlbGF0aXZlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZGllcyB0byBhIGdpdmVuIHZhbHVlLgogICAqLwogIGNsYXNzIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uIGV4dGVuZHMgRXF1YXRpb24gewogICAgLyoqCiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpcy4KICAgICAqLwoKICAgIC8qKgogICAgICogTW90b3IgdmVsb2NpdHkuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1heEZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtYXhGb3JjZSA9IDFlNjsKICAgICAgfQoKICAgICAgc3VwZXIoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKTsKICAgICAgdGhpcy5heGlzQSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuYXhpc0IgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnRhcmdldFZlbG9jaXR5ID0gMDsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIHRoaXMuYTsKICAgICAgY29uc3QgYiA9IHRoaXMuYjsKICAgICAgdGhpcy5iaTsKICAgICAgdGhpcy5iajsKICAgICAgY29uc3QgYXhpc0EgPSB0aGlzLmF4aXNBOwogICAgICBjb25zdCBheGlzQiA9IHRoaXMuYXhpc0I7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gZyA9IDAKICAgICAgLy8gZ2RvdCA9IGF4aXNBICogd2kgLSBheGlzQiAqIHdqCiAgICAgIC8vIGdkb3QgPSBHICogVyA9IEcgKiBbdmkgd2kgdmogd2pdCiAgICAgIC8vID0+CiAgICAgIC8vIEcgPSBbMCBheGlzQSAwIC1heGlzQl0KCiAgICAgIEdBLnJvdGF0aW9uYWwuY29weShheGlzQSk7CiAgICAgIGF4aXNCLm5lZ2F0ZShHQi5yb3RhdGlvbmFsKTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpIC0gdGhpcy50YXJnZXRWZWxvY2l0eTsKICAgICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTsKICAgICAgY29uc3QgQiA9IC1HVyAqIGIgLSBoICogR2lNZjsKICAgICAgcmV0dXJuIEI7CiAgICB9CgogIH0KCiAgLyoqCiAgICogSGluZ2UgY29uc3RyYWludC4gVGhpbmsgb2YgaXQgYXMgYSBkb29yIGhpbmdlLiBJdCB0cmllcyB0byBrZWVwIHRoZSBkb29yIGluIHRoZSBjb3JyZWN0IHBsYWNlIGFuZCB3aXRoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLgogICAqLwogIGNsYXNzIEhpbmdlQ29uc3RyYWludCBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBSb3RhdGlvbiBheGlzLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi4KICAgICAqLwogICAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IG1heEZvcmNlID0gdHlwZW9mIG9wdGlvbnMubWF4Rm9yY2UgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjsKICAgICAgY29uc3QgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcGl2b3RCID0gb3B0aW9ucy5waXZvdEIgPyBvcHRpb25zLnBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOwogICAgICBjb25zdCBheGlzQSA9IHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIGF4aXNBLm5vcm1hbGl6ZSgpOwogICAgICBjb25zdCBheGlzQiA9IHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIGF4aXNCLm5vcm1hbGl6ZSgpOwogICAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSAhIW9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDsKICAgICAgY29uc3Qgcm90YXRpb25hbDEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7CiAgICAgIGNvbnN0IHJvdGF0aW9uYWwyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICBjb25zdCBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbihib2R5QSwgYm9keUIsIG1heEZvcmNlKTsKICAgICAgbW90b3IuZW5hYmxlZCA9IGZhbHNlOyAvLyBOb3QgZW5hYmxlZCBieSBkZWZhdWx0CiAgICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlcgoKICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChyb3RhdGlvbmFsMSwgcm90YXRpb25hbDIsIG1vdG9yKTsKICAgIH0KICAgIC8qKgogICAgICogZW5hYmxlTW90b3IKICAgICAqLwoKCiAgICBlbmFibGVNb3RvcigpIHsKICAgICAgdGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQgPSB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBkaXNhYmxlTW90b3IKICAgICAqLwoKCiAgICBkaXNhYmxlTW90b3IoKSB7CiAgICAgIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIHNldE1vdG9yU3BlZWQKICAgICAqLwoKCiAgICBzZXRNb3RvclNwZWVkKHNwZWVkKSB7CiAgICAgIHRoaXMubW90b3JFcXVhdGlvbi50YXJnZXRWZWxvY2l0eSA9IHNwZWVkOwogICAgfQogICAgLyoqCiAgICAgKiBzZXRNb3Rvck1heEZvcmNlCiAgICAgKi8KCgogICAgc2V0TW90b3JNYXhGb3JjZShtYXhGb3JjZSkgewogICAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTsKICAgICAgdGhpcy5tb3RvckVxdWF0aW9uLm1pbkZvcmNlID0gLW1heEZvcmNlOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbjsKICAgICAgY29uc3QgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjE7CiAgICAgIGNvbnN0IHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yOwogICAgICBjb25zdCB3b3JsZEF4aXNBID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxOwogICAgICBjb25zdCB3b3JsZEF4aXNCID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyOwogICAgICBjb25zdCBheGlzQSA9IHRoaXMuYXhpc0E7CiAgICAgIGNvbnN0IGF4aXNCID0gdGhpcy5heGlzQjsKICAgICAgc3VwZXIudXBkYXRlKCk7IC8vIEdldCB3b3JsZCBheGVzCgogICAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KGF4aXNBLCB3b3JsZEF4aXNBKTsKICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdChheGlzQiwgd29ybGRBeGlzQik7CiAgICAgIHdvcmxkQXhpc0EudGFuZ2VudHMocjEuYXhpc0EsIHIyLmF4aXNBKTsKICAgICAgcjEuYXhpc0IuY29weSh3b3JsZEF4aXNCKTsKICAgICAgcjIuYXhpc0IuY29weSh3b3JsZEF4aXNCKTsKCiAgICAgIGlmICh0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCkgewogICAgICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQSwgbW90b3IuYXhpc0EpOwogICAgICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQiwgbW90b3IuYXhpc0IpOwogICAgICB9CiAgICB9CgogIH0KICBjb25zdCBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpOwogIGNvbnN0IEhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIENvbnN0cmFpbnMgdGhlIHNsaXBwaW5nIGluIGEgY29udGFjdCBhbG9uZyBhIHRhbmdlbnQKICAgKi8KICBjbGFzcyBGcmljdGlvbkVxdWF0aW9uIGV4dGVuZHMgRXF1YXRpb24gewogICAgLy8gVGFuZ2VudAoKICAgIC8qKgogICAgICogQHBhcmFtIHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKSB7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLXNsaXBGb3JjZSwgc2xpcEZvcmNlKTsKICAgICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucmogPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnQgPSBuZXcgVmVjMygpOwogICAgfQoKICAgIGNvbXB1dGVCKGgpIHsKICAgICAgdGhpcy5hOwogICAgICBjb25zdCBiID0gdGhpcy5iOwogICAgICB0aGlzLmJpOwogICAgICB0aGlzLmJqOwogICAgICBjb25zdCByaSA9IHRoaXMucmk7CiAgICAgIGNvbnN0IHJqID0gdGhpcy5yajsKICAgICAgY29uc3Qgcml4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDE7CiAgICAgIGNvbnN0IHJqeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyOwogICAgICBjb25zdCB0ID0gdGhpcy50OyAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHMKCiAgICAgIHJpLmNyb3NzKHQsIHJpeHQpOwogICAgICByai5jcm9zcyh0LCByanh0KTsgLy8gRyA9IFstdCAtcml4dCB0IHJqeHRdCiAgICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyEKCiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgdC5uZWdhdGUoR0Euc3BhdGlhbCk7CiAgICAgIHJpeHQubmVnYXRlKEdBLnJvdGF0aW9uYWwpOwogICAgICBHQi5zcGF0aWFsLmNvcHkodCk7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShyanh0KTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLUdXICogYiAtIGggKiBHaU1mOwogICAgICByZXR1cm4gQjsKICAgIH0KCiAgfQogIGNvbnN0IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldC4KICAgKiBAdG9kbyBSZWZhY3RvciBtYXRlcmlhbHMgdG8gbWF0ZXJpYWxBIGFuZCBtYXRlcmlhbEIKICAgKi8KICBjbGFzcyBDb250YWN0TWF0ZXJpYWwgewogICAgLyoqCiAgICAgKiBJZGVudGlmaWVyIG9mIHRoaXMgbWF0ZXJpYWwuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFBhcnRpY2lwYXRpbmcgbWF0ZXJpYWxzLgogICAgICovCgogICAgLyoqCiAgICAgKiBGcmljdGlvbiBjb2VmZmljaWVudC4KICAgICAqIEBkZWZhdWx0IDAuMwogICAgICovCgogICAgLyoqCiAgICAgKiBSZXN0aXR1dGlvbiBjb2VmZmljaWVudC4KICAgICAqIEBkZWZhdWx0IDAuMwogICAgICovCgogICAgLyoqCiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHByb2R1Y2VkIGNvbnRhY3QgZXF1YXRpb25zLgogICAgICogQGRlZmF1bHQgMWU3CiAgICAgKi8KCiAgICAvKioKICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnMuCiAgICAgKiBAZGVmYXVsdCAzCiAgICAgKi8KCiAgICAvKioKICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zLgogICAgICogQGRlZmF1bHQgMWU3CiAgICAgKi8KCiAgICAvKioKICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zCiAgICAgKiBAZGVmYXVsdCAzCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG0xLCBtMiwgb3B0aW9ucykgewogICAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywgewogICAgICAgIGZyaWN0aW9uOiAwLjMsCiAgICAgICAgcmVzdGl0dXRpb246IDAuMywKICAgICAgICBjb250YWN0RXF1YXRpb25TdGlmZm5lc3M6IDFlNywKICAgICAgICBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uOiAzLAogICAgICAgIGZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M6IDFlNywKICAgICAgICBmcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjogMwogICAgICB9KTsKICAgICAgdGhpcy5pZCA9IENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5tYXRlcmlhbHMgPSBbbTEsIG0yXTsKICAgICAgdGhpcy5mcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb247CiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uOwogICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOwogICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24gPSBvcHRpb25zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb247CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzczsKICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb247CiAgICB9CgogIH0KICBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDsKCiAgLyoqCiAgICogRGVmaW5lcyBhIHBoeXNpY3MgbWF0ZXJpYWwuCiAgICovCiAgY2xhc3MgTWF0ZXJpYWwgewogICAgLyoqCiAgICAgKiBNYXRlcmlhbCBuYW1lLgogICAgICogSWYgb3B0aW9ucyBpcyBhIHN0cmluZywgbmFtZSB3aWxsIGJlIHNldCB0byB0aGF0IHN0cmluZy4KICAgICAqIEB0b2RvIERlcHJlY2F0ZSB0aGlzCiAgICAgKi8KCiAgICAvKiogTWF0ZXJpYWwgaWQuICovCgogICAgLyoqCiAgICAgKiBGcmljdGlvbiBmb3IgdGhpcyBtYXRlcmlhbC4KICAgICAqIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGZyaWN0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSBgZGVmYXVsdENvbnRhY3RNYXRlcmlhbGAgaW4gdGhlIFdvcmxkIHdpbGwgYmUgdXNlZC4KICAgICAqLwoKICAgIC8qKgogICAgICogUmVzdGl0dXRpb24gZm9yIHRoaXMgbWF0ZXJpYWwuCiAgICAgKiBJZiBub24tbmVnYXRpdmUsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSByZXN0aXR1dGlvbiBnaXZlbiBieSBDb250YWN0TWF0ZXJpYWxzLiBJZiB0aGVyZSdzIG5vIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgdGhlIHZhbHVlIGZyb20gYGRlZmF1bHRDb250YWN0TWF0ZXJpYWxgIGluIHRoZSBXb3JsZCB3aWxsIGJlIHVzZWQuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgbGV0IG5hbWUgPSAnJzsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZml4CgogICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgLy9jb25zb2xlLndhcm4oYFBhc3NpbmcgYSBzdHJpbmcgdG8gTWF0ZXJpYWxPcHRpb25zIGlzIGRlcHJlY2F0ZWQsIGFuZCBoYXMgbm8gZWZmZWN0YCkKICAgICAgICBuYW1lID0gb3B0aW9uczsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgIHRoaXMuaWQgPSBNYXRlcmlhbC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5mcmljdGlvbiA9IHR5cGVvZiBvcHRpb25zLmZyaWN0aW9uICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZnJpY3Rpb24gOiAtMTsKICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IHR5cGVvZiBvcHRpb25zLnJlc3RpdHV0aW9uICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucmVzdGl0dXRpb24gOiAtMTsKICAgIH0KCiAgfQogIE1hdGVyaWFsLmlkQ291bnRlciA9IDA7CgogIC8qKgogICAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3Qgc3ByaW5nID0gbmV3IFNwcmluZyhib3hCb2R5LCBzcGhlcmVCb2R5LCB7CiAgICogICAgICAgcmVzdExlbmd0aDogMCwKICAgKiAgICAgICBzdGlmZm5lc3M6IDUwLAogICAqICAgICAgIGRhbXBpbmc6IDEsCiAgICogICAgIH0pCiAgICoKICAgKiAgICAgLy8gQ29tcHV0ZSB0aGUgZm9yY2UgYWZ0ZXIgZWFjaCBzdGVwCiAgICogICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgKGV2ZW50KSA9PiB7CiAgICogICAgICAgc3ByaW5nLmFwcGx5Rm9yY2UoKQogICAqICAgICB9KQogICAqLwogIGNsYXNzIFNwcmluZyB7CiAgICAvKioKICAgICAqIFJlc3QgbGVuZ3RoIG9mIHRoZSBzcHJpbmcuIEEgbnVtYmVyID4gMC4KICAgICAqIEBkZWZhdWx0IDEKICAgICAqLwoKICAgIC8qKgogICAgICogU3RpZmZuZXNzIG9mIHRoZSBzcHJpbmcuIEEgbnVtYmVyID49IDAuCiAgICAgKiBAZGVmYXVsdCAxMDAKICAgICAqLwoKICAgIC8qKgogICAgICogRGFtcGluZyBvZiB0aGUgc3ByaW5nLiBBIG51bWJlciA+PSAwLgogICAgICogQGRlZmF1bHQgMQogICAgICovCgogICAgLyoqCiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS4KICAgICAqLwoKICAgIC8qKgogICAgICogU2Vjb25kIGNvbm5lY3RlZCBib2R5LgogICAgICovCgogICAgLyoqCiAgICAgKiBBbmNob3IgZm9yIGJvZHlBIGluIGxvY2FsIGJvZHlBIGNvb3JkaW5hdGVzLgogICAgICogV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy4KICAgICAqIEBkZWZhdWx0IG5ldyBWZWMzKCkKICAgICAqLwoKICAgIC8qKgogICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy4KICAgICAqIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEIsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuCiAgICAgKiBAZGVmYXVsdCBuZXcgVmVjMygpCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Ygb3B0aW9ucy5yZXN0TGVuZ3RoID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7CiAgICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3MgfHwgMTAwOwogICAgICB0aGlzLmRhbXBpbmcgPSBvcHRpb25zLmRhbXBpbmcgfHwgMTsKICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBOwogICAgICB0aGlzLmJvZHlCID0gYm9keUI7CiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMubG9jYWxBbmNob3JBKSB7CiAgICAgICAgdGhpcy5sb2NhbEFuY2hvckEuY29weShvcHRpb25zLmxvY2FsQW5jaG9yQSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLmxvY2FsQW5jaG9yQikgewogICAgICAgIHRoaXMubG9jYWxBbmNob3JCLmNvcHkob3B0aW9ucy5sb2NhbEFuY2hvckIpOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy53b3JsZEFuY2hvckEpIHsKICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLndvcmxkQW5jaG9yQikgewogICAgICAgIHRoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLgogICAgICovCgoKICAgIHNldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpIHsKICAgICAgdGhpcy5ib2R5QS5wb2ludFRvTG9jYWxGcmFtZSh3b3JsZEFuY2hvckEsIHRoaXMubG9jYWxBbmNob3JBKTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy4KICAgICAqLwoKCiAgICBzZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKSB7CiAgICAgIHRoaXMuYm9keUIucG9pbnRUb0xvY2FsRnJhbWUod29ybGRBbmNob3JCLCB0aGlzLmxvY2FsQW5jaG9yQik7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBnZXRXb3JsZEFuY2hvckEocmVzdWx0KSB7CiAgICAgIHRoaXMuYm9keUEucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckEsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBnZXRXb3JsZEFuY2hvckIocmVzdWx0KSB7CiAgICAgIHRoaXMuYm9keUIucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuCiAgICAgKi8KCgogICAgYXBwbHlGb3JjZSgpIHsKICAgICAgY29uc3QgayA9IHRoaXMuc3RpZmZuZXNzOwogICAgICBjb25zdCBkID0gdGhpcy5kYW1waW5nOwogICAgICBjb25zdCBsID0gdGhpcy5yZXN0TGVuZ3RoOwogICAgICBjb25zdCBib2R5QSA9IHRoaXMuYm9keUE7CiAgICAgIGNvbnN0IGJvZHlCID0gdGhpcy5ib2R5QjsKICAgICAgY29uc3QgciA9IGFwcGx5Rm9yY2VfcjsKICAgICAgY29uc3Qgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQ7CiAgICAgIGNvbnN0IHUgPSBhcHBseUZvcmNlX3U7CiAgICAgIGNvbnN0IGYgPSBhcHBseUZvcmNlX2Y7CiAgICAgIGNvbnN0IHRtcCA9IGFwcGx5Rm9yY2VfdG1wOwogICAgICBjb25zdCB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQTsKICAgICAgY29uc3Qgd29ybGRBbmNob3JCID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckI7CiAgICAgIGNvbnN0IHJpID0gYXBwbHlGb3JjZV9yaTsKICAgICAgY29uc3QgcmogPSBhcHBseUZvcmNlX3JqOwogICAgICBjb25zdCByaV94X2YgPSBhcHBseUZvcmNlX3JpX3hfZjsKICAgICAgY29uc3QgcmpfeF9mID0gYXBwbHlGb3JjZV9yal94X2Y7IC8vIEdldCB3b3JsZCBhbmNob3JzCgogICAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpOwogICAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpOyAvLyBHZXQgb2Zmc2V0IHBvaW50cwoKICAgICAgd29ybGRBbmNob3JBLnZzdWIoYm9keUEucG9zaXRpb24sIHJpKTsKICAgICAgd29ybGRBbmNob3JCLnZzdWIoYm9keUIucG9zaXRpb24sIHJqKTsgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzCgogICAgICB3b3JsZEFuY2hvckIudnN1Yih3b3JsZEFuY2hvckEsIHIpOwogICAgICBjb25zdCBybGVuID0gci5sZW5ndGgoKTsKICAgICAgcl91bml0LmNvcHkocik7CiAgICAgIHJfdW5pdC5ub3JtYWxpemUoKTsgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdQoKICAgICAgYm9keUIudmVsb2NpdHkudnN1Yihib2R5QS52ZWxvY2l0eSwgdSk7IC8vIEFkZCByb3RhdGlvbmFsIHZlbG9jaXR5CgogICAgICBib2R5Qi5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MocmosIHRtcCk7CiAgICAgIHUudmFkZCh0bXAsIHUpOwogICAgICBib2R5QS5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MocmksIHRtcCk7CiAgICAgIHUudnN1Yih0bXAsIHUpOyAvLyBGID0gLSBrICogKCB4IC0gTCApIC0gRCAqICggdSApCgogICAgICByX3VuaXQuc2NhbGUoLWsgKiAocmxlbiAtIGwpIC0gZCAqIHUuZG90KHJfdW5pdCksIGYpOyAvLyBBZGQgZm9yY2VzIHRvIGJvZGllcwoKICAgICAgYm9keUEuZm9yY2UudnN1YihmLCBib2R5QS5mb3JjZSk7CiAgICAgIGJvZHlCLmZvcmNlLnZhZGQoZiwgYm9keUIuZm9yY2UpOyAvLyBBbmd1bGFyIGZvcmNlCgogICAgICByaS5jcm9zcyhmLCByaV94X2YpOwogICAgICByai5jcm9zcyhmLCByal94X2YpOwogICAgICBib2R5QS50b3JxdWUudnN1YihyaV94X2YsIGJvZHlBLnRvcnF1ZSk7CiAgICAgIGJvZHlCLnRvcnF1ZS52YWRkKHJqX3hfZiwgYm9keUIudG9ycXVlKTsKICAgIH0KCiAgfQogIGNvbnN0IGFwcGx5Rm9yY2VfciA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV9yX3VuaXQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfdSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV9mID0gbmV3IFZlYzMoKTsKICBjb25zdCBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV93b3JsZEFuY2hvckIgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmkgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmogPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmlfeF9mID0gbmV3IFZlYzMoKTsKICBjb25zdCBhcHBseUZvcmNlX3JqX3hfZiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV90bXAgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBXaGVlbEluZm8KICAgKi8KICBjbGFzcyBXaGVlbEluZm8gewogICAgLyoqCiAgICAgKiBNYXggdHJhdmVsIGRpc3RhbmNlIG9mIHRoZSBzdXNwZW5zaW9uLCBpbiBtZXRlcnMuCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNwZWVkIHRvIGFwcGx5IHRvIHRoZSB3aGVlbCByb3RhdGlvbiB3aGVuIHRoZSB3aGVlbCBpcyBzbGlkaW5nLgogICAgICogQGRlZmF1bHQgLTAuMQogICAgICovCgogICAgLyoqCiAgICAgKiBJZiB0aGUgY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCBzaG91bGQgYmUgdXNlZC4KICAgICAqIEBkZWZhdWx0IGZhbHNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNsaWRpbmcKICAgICAqLwoKICAgIC8qKgogICAgICogQ29ubmVjdGlvbiBwb2ludCwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBjaGFzc2lzIGJvZHkgZnJhbWUuCiAgICAgKi8KCiAgICAvKioKICAgICAqIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb25Mb2NhbAogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb25Xb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiBheGxlTG9jYWwKICAgICAqLwoKICAgIC8qKgogICAgICogYXhsZVdvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25SZXN0TGVuZ3RoCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25NYXhMZW5ndGgKICAgICAqIEBkZWZhdWx0IDIKICAgICAqLwoKICAgIC8qKgogICAgICogcmFkaXVzCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25TdGlmZm5lc3MKICAgICAqIEBkZWZhdWx0IDEwMAogICAgICovCgogICAgLyoqCiAgICAgKiBkYW1waW5nQ29tcHJlc3Npb24KICAgICAqIEBkZWZhdWx0IDEwCiAgICAgKi8KCiAgICAvKioKICAgICAqIGRhbXBpbmdSZWxheGF0aW9uCiAgICAgKiBAZGVmYXVsdCAxMAogICAgICovCgogICAgLyoqCiAgICAgKiBmcmljdGlvblNsaXAKICAgICAqIEBkZWZhdWx0IDEwLjUKICAgICAqLwoKICAgIC8qKiBmb3J3YXJkQWNjZWxlcmF0aW9uICovCgogICAgLyoqIHNpZGVBY2NlbGVyYXRpb24gKi8KCiAgICAvKioKICAgICAqIHN0ZWVyaW5nCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIFJvdGF0aW9uIHZhbHVlLCBpbiByYWRpYW5zLgogICAgICogQGRlZmF1bHQgMAogICAgICovCgogICAgLyoqCiAgICAgKiBkZWx0YVJvdGF0aW9uCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHJvbGxJbmZsdWVuY2UKICAgICAqIEBkZWZhdWx0IDAuMDEKICAgICAqLwoKICAgIC8qKgogICAgICogbWF4U3VzcGVuc2lvbkZvcmNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGVuZ2luZUZvcmNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGJyYWtlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGlzRnJvbnRXaGVlbAogICAgICogQGRlZmF1bHQgdHJ1ZQogICAgICovCgogICAgLyoqCiAgICAgKiBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24KICAgICAqIEBkZWZhdWx0IDEKICAgICAqLwoKICAgIC8qKgogICAgICogc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkKICAgICAqIEBkZWZhdWx0IDAKICAgICAqLwoKICAgIC8qKgogICAgICogc3VzcGVuc2lvbkZvcmNlCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNsaXBJbmZvCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNraWRJbmZvCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25MZW5ndGgKICAgICAqIEBkZWZhdWx0IDAKICAgICAqLwoKICAgIC8qKgogICAgICogc2lkZUltcHVsc2UKICAgICAqLwoKICAgIC8qKgogICAgICogZm9yd2FyZEltcHVsc2UKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHJlc3VsdCBmcm9tIHJheWNhc3RpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZWVsIHdvcmxkIHRyYW5zZm9ybS4KICAgICAqLwoKICAgIC8qKgogICAgICogaXNJbkNvbnRhY3QKICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywgewogICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbDogbmV3IFZlYzMoKSwKICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQ6IG5ldyBWZWMzKCksCiAgICAgICAgZGlyZWN0aW9uTG9jYWw6IG5ldyBWZWMzKCksCiAgICAgICAgZGlyZWN0aW9uV29ybGQ6IG5ldyBWZWMzKCksCiAgICAgICAgYXhsZUxvY2FsOiBuZXcgVmVjMygpLAogICAgICAgIGF4bGVXb3JsZDogbmV3IFZlYzMoKSwKICAgICAgICBzdXNwZW5zaW9uUmVzdExlbmd0aDogMSwKICAgICAgICBzdXNwZW5zaW9uTWF4TGVuZ3RoOiAyLAogICAgICAgIHJhZGl1czogMSwKICAgICAgICBzdXNwZW5zaW9uU3RpZmZuZXNzOiAxMDAsCiAgICAgICAgZGFtcGluZ0NvbXByZXNzaW9uOiAxMCwKICAgICAgICBkYW1waW5nUmVsYXhhdGlvbjogMTAsCiAgICAgICAgZnJpY3Rpb25TbGlwOiAxMC41LAogICAgICAgIGZvcndhcmRBY2NlbGVyYXRpb246IDEsCiAgICAgICAgc2lkZUFjY2VsZXJhdGlvbjogMSwKICAgICAgICBzdGVlcmluZzogMCwKICAgICAgICByb3RhdGlvbjogMCwKICAgICAgICBkZWx0YVJvdGF0aW9uOiAwLAogICAgICAgIHJvbGxJbmZsdWVuY2U6IDAuMDEsCiAgICAgICAgbWF4U3VzcGVuc2lvbkZvcmNlOiBOdW1iZXIuTUFYX1ZBTFVFLAogICAgICAgIGlzRnJvbnRXaGVlbDogdHJ1ZSwKICAgICAgICBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb246IDEsCiAgICAgICAgc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk6IDAsCiAgICAgICAgc3VzcGVuc2lvbkZvcmNlOiAwLAogICAgICAgIHNsaXBJbmZvOiAwLAogICAgICAgIHNraWRJbmZvOiAwLAogICAgICAgIHN1c3BlbnNpb25MZW5ndGg6IDAsCiAgICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSwKICAgICAgICB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiBmYWxzZSwKICAgICAgICBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiAtMC4xCiAgICAgIH0pOwogICAgICB0aGlzLm1heFN1c3BlbnNpb25UcmF2ZWwgPSBvcHRpb25zLm1heFN1c3BlbnNpb25UcmF2ZWw7CiAgICAgIHRoaXMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCA9IG9wdGlvbnMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDsKICAgICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOwogICAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTsKICAgICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbC5jbG9uZSgpOwogICAgICB0aGlzLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCA9IG9wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uTG9jYWwgPSBvcHRpb25zLmRpcmVjdGlvbkxvY2FsLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uV29ybGQgPSBvcHRpb25zLmRpcmVjdGlvbldvcmxkLmNsb25lKCk7CiAgICAgIHRoaXMuYXhsZUxvY2FsID0gb3B0aW9ucy5heGxlTG9jYWwuY2xvbmUoKTsKICAgICAgdGhpcy5heGxlV29ybGQgPSBvcHRpb25zLmF4bGVXb3JsZC5jbG9uZSgpOwogICAgICB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uUmVzdExlbmd0aDsKICAgICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoOwogICAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzOwogICAgICB0aGlzLnN1c3BlbnNpb25TdGlmZm5lc3MgPSBvcHRpb25zLnN1c3BlbnNpb25TdGlmZm5lc3M7CiAgICAgIHRoaXMuZGFtcGluZ0NvbXByZXNzaW9uID0gb3B0aW9ucy5kYW1waW5nQ29tcHJlc3Npb247CiAgICAgIHRoaXMuZGFtcGluZ1JlbGF4YXRpb24gPSBvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uOwogICAgICB0aGlzLmZyaWN0aW9uU2xpcCA9IG9wdGlvbnMuZnJpY3Rpb25TbGlwOwogICAgICB0aGlzLmZvcndhcmRBY2NlbGVyYXRpb24gPSBvcHRpb25zLmZvcndhcmRBY2NlbGVyYXRpb247CiAgICAgIHRoaXMuc2lkZUFjY2VsZXJhdGlvbiA9IG9wdGlvbnMuc2lkZUFjY2VsZXJhdGlvbjsKICAgICAgdGhpcy5zdGVlcmluZyA9IDA7CiAgICAgIHRoaXMucm90YXRpb24gPSAwOwogICAgICB0aGlzLmRlbHRhUm90YXRpb24gPSAwOwogICAgICB0aGlzLnJvbGxJbmZsdWVuY2UgPSBvcHRpb25zLnJvbGxJbmZsdWVuY2U7CiAgICAgIHRoaXMubWF4U3VzcGVuc2lvbkZvcmNlID0gb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2U7CiAgICAgIHRoaXMuZW5naW5lRm9yY2UgPSAwOwogICAgICB0aGlzLmJyYWtlID0gMDsKICAgICAgdGhpcy5pc0Zyb250V2hlZWwgPSBvcHRpb25zLmlzRnJvbnRXaGVlbDsKICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxOwogICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDsKICAgICAgdGhpcy5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICB0aGlzLnNsaXBJbmZvID0gMDsKICAgICAgdGhpcy5za2lkSW5mbyA9IDA7CiAgICAgIHRoaXMuc3VzcGVuc2lvbkxlbmd0aCA9IDA7CiAgICAgIHRoaXMuc2lkZUltcHVsc2UgPSAwOwogICAgICB0aGlzLmZvcndhcmRJbXB1bHNlID0gMDsKICAgICAgdGhpcy5yYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTsKICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTsKICAgICAgdGhpcy5pc0luQ29udGFjdCA9IGZhbHNlOwogICAgfQoKICAgIHVwZGF0ZVdoZWVsKGNoYXNzaXMpIHsKICAgICAgY29uc3QgcmF5Y2FzdFJlc3VsdCA9IHRoaXMucmF5Y2FzdFJlc3VsdDsKCiAgICAgIGlmICh0aGlzLmlzSW5Db250YWN0KSB7CiAgICAgICAgY29uc3QgcHJvamVjdCA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQpOwogICAgICAgIHJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXMucG9zaXRpb24sIHJlbHBvcyk7CiAgICAgICAgY2hhc3Npcy5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChyZWxwb3MsIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTsKICAgICAgICBjb25zdCBwcm9qVmVsID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpOwoKICAgICAgICBpZiAocHJvamVjdCA+PSAtMC4xKSB7CiAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wOwogICAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjAgLyAwLjE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGludiA9IC0xIC8gcHJvamVjdDsKICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSBwcm9qVmVsICogaW52OwogICAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIE5vdCBpbiBjb250YWN0IDogcG9zaXRpb24gd2hlZWwgaW4gYSBuaWNlIChyZXN0IGxlbmd0aCkgcG9zaXRpb24KICAgICAgICByYXljYXN0UmVzdWx0LnN1c3BlbnNpb25MZW5ndGggPSB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoOwogICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7CiAgICAgICAgcmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7CiAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjA7CiAgICAgIH0KICAgIH0KCiAgfQogIGNvbnN0IGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ID0gbmV3IFZlYzMoKTsKICBjb25zdCByZWxwb3MgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBWZWhpY2xlIGhlbHBlciBjbGFzcyB0aGF0IGNhc3RzIHJheXMgZnJvbSB0aGUgd2hlZWwgcG9zaXRpb25zIHRvd2FyZHMgdGhlIGdyb3VuZCBhbmQgYXBwbGllcyBmb3JjZXMuCiAgICovCiAgY2xhc3MgUmF5Y2FzdFZlaGljbGUgewogICAgLyoqIFRoZSBjYXIgY2hhc3NpcyBib2R5LiAqLwoKICAgIC8qKiBUaGUgd2hlZWxzLiAqLwoKICAgIC8qKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy4gKi8KCiAgICAvKiogSW5kZXggb2YgdGhlIHJpZ2h0IGF4aXMuIHg9MCwgeT0xLCB6PTIgKi8KCiAgICAvKiogSW5kZXggb2YgdGhlIGZvcndhcmQgYXhpcy4geD0wLCB5PTEsIHo9MiAqLwoKICAgIC8qKiBJbmRleCBvZiB0aGUgdXAgYXhpcy4geD0wLCB5PTEsIHo9MiAqLwoKICAgIC8qKiBUaGUgY29uc3RyYWludHMuICovCgogICAgLyoqIE9wdGlvbmFsIHByZS1zdGVwIGNhbGxiYWNrLiAqLwoKICAgIC8qKiBOdW1iZXIgb2Ygd2hlZWxzIG9uIHRoZSBncm91bmQuICovCiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7CiAgICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBvcHRpb25zLmNoYXNzaXNCb2R5OwogICAgICB0aGlzLndoZWVsSW5mb3MgPSBbXTsKICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7CiAgICAgIHRoaXMud29ybGQgPSBudWxsOwogICAgICB0aGlzLmluZGV4UmlnaHRBeGlzID0gdHlwZW9mIG9wdGlvbnMuaW5kZXhSaWdodEF4aXMgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleFJpZ2h0QXhpcyA6IDI7CiAgICAgIHRoaXMuaW5kZXhGb3J3YXJkQXhpcyA9IHR5cGVvZiBvcHRpb25zLmluZGV4Rm9yd2FyZEF4aXMgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleEZvcndhcmRBeGlzIDogMDsKICAgICAgdGhpcy5pbmRleFVwQXhpcyA9IHR5cGVvZiBvcHRpb25zLmluZGV4VXBBeGlzICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhVcEF4aXMgOiAxOwogICAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107CgogICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9ICgpID0+IHt9OwoKICAgICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyID0gMDsKICAgICAgdGhpcy5udW1XaGVlbHNPbkdyb3VuZCA9IDA7CiAgICB9CiAgICAvKioKICAgICAqIEFkZCBhIHdoZWVsLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMsIHNlZSBgV2hlZWxJbmZvYC4KICAgICAqLwoKCiAgICBhZGRXaGVlbChvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpOwogICAgICBjb25zdCBpbmRleCA9IHRoaXMud2hlZWxJbmZvcy5sZW5ndGg7CiAgICAgIHRoaXMud2hlZWxJbmZvcy5wdXNoKGluZm8pOwogICAgICByZXR1cm4gaW5kZXg7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC4KICAgICAqLwoKCiAgICBzZXRTdGVlcmluZ1ZhbHVlKHZhbHVlLCB3aGVlbEluZGV4KSB7CiAgICAgIGNvbnN0IHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdOwogICAgICB3aGVlbC5zdGVlcmluZyA9IHZhbHVlOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwCiAgICAgKi8KCgogICAgYXBwbHlFbmdpbmVGb3JjZSh2YWx1ZSwgd2hlZWxJbmRleCkgewogICAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uZW5naW5lRm9yY2UgPSB2YWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBicmFraW5nIGZvcmNlIG9mIGEgd2hlZWwKICAgICAqLwoKCiAgICBzZXRCcmFrZShicmFrZSwgd2hlZWxJbmRleCkgewogICAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uYnJha2UgPSBicmFrZTsKICAgIH0KICAgIC8qKgogICAgICogQWRkIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgdG8gdGhlIHdvcmxkLgogICAgICovCgoKICAgIGFkZFRvV29ybGQod29ybGQpIHsKICAgICAgd29ybGQuYWRkQm9keSh0aGlzLmNoYXNzaXNCb2R5KTsKICAgICAgY29uc3QgdGhhdCA9IHRoaXM7CgogICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9ICgpID0+IHsKICAgICAgICB0aGF0LnVwZGF0ZVZlaGljbGUod29ybGQuZHQpOwogICAgICB9OwoKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTsKICAgICAgdGhpcy53b3JsZCA9IHdvcmxkOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgb25lIG9mIHRoZSB3aGVlbCBheGxlcywgd29ybGQtb3JpZW50ZWQuCiAgICAgKi8KCgogICAgZ2V0VmVoaWNsZUF4aXNXb3JsZChheGlzSW5kZXgsIHJlc3VsdCkgewogICAgICByZXN1bHQuc2V0KGF4aXNJbmRleCA9PT0gMCA/IDEgOiAwLCBheGlzSW5kZXggPT09IDEgPyAxIDogMCwgYXhpc0luZGV4ID09PSAyID8gMSA6IDApOwogICAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZXN1bHQsIHJlc3VsdCk7CiAgICB9CgogICAgdXBkYXRlVmVoaWNsZSh0aW1lU3RlcCkgewogICAgICBjb25zdCB3aGVlbEluZm9zID0gdGhpcy53aGVlbEluZm9zOwogICAgICBjb25zdCBudW1XaGVlbHMgPSB3aGVlbEluZm9zLmxlbmd0aDsKICAgICAgY29uc3QgY2hhc3Npc0JvZHkgPSB0aGlzLmNoYXNzaXNCb2R5OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7CiAgICAgIH0KCiAgICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciA9IDMuNiAqIGNoYXNzaXNCb2R5LnZlbG9jaXR5Lmxlbmd0aCgpOwogICAgICBjb25zdCBmb3J3YXJkV29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmb3J3YXJkV29ybGQpOwoKICAgICAgaWYgKGZvcndhcmRXb3JsZC5kb3QoY2hhc3Npc0JvZHkudmVsb2NpdHkpIDwgMCkgewogICAgICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciAqPSAtMTsKICAgICAgfSAvLyBzaW11bGF0ZSBzdXNwZW5zaW9uCgoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIHRoaXMuY2FzdFJheSh3aGVlbEluZm9zW2ldKTsKICAgICAgfQoKICAgICAgdGhpcy51cGRhdGVTdXNwZW5zaW9uKHRpbWVTdGVwKTsKICAgICAgY29uc3QgaW1wdWxzZSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHJlbHBvcyA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7CiAgICAgICAgLy9hcHBseSBzdXNwZW5zaW9uIGZvcmNlCiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldOwogICAgICAgIGxldCBzdXNwZW5zaW9uRm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2U7CgogICAgICAgIGlmIChzdXNwZW5zaW9uRm9yY2UgPiB3aGVlbC5tYXhTdXNwZW5zaW9uRm9yY2UpIHsKICAgICAgICAgIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLm1heFN1c3BlbnNpb25Gb3JjZTsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuc2NhbGUoc3VzcGVuc2lvbkZvcmNlICogdGltZVN0ZXAsIGltcHVsc2UpOwogICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpOwogICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxwb3MpOwogICAgICB9CgogICAgICB0aGlzLnVwZGF0ZUZyaWN0aW9uKHRpbWVTdGVwKTsKICAgICAgY29uc3QgaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGZ3ZCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHZlbCA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7CiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldOyAvL2NvbnN0IHJlbHBvcyA9IG5ldyBWZWMzKCk7CiAgICAgICAgLy93aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQudnN1YihjaGFzc2lzQm9keS5wb3NpdGlvbiwgcmVscG9zKTsKCiAgICAgICAgY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCB2ZWwpOyAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uCgogICAgICAgIGxldCBtID0gMTsKCiAgICAgICAgc3dpdGNoICh0aGlzLmluZGV4VXBBeGlzKSB7CiAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgIG0gPSAtMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQoKICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHsKICAgICAgICAgIHRoaXMuZ2V0VmVoaWNsZUF4aXNXb3JsZCh0aGlzLmluZGV4Rm9yd2FyZEF4aXMsIGZ3ZCk7CiAgICAgICAgICBjb25zdCBwcm9qID0gZndkLmRvdCh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTsKICAgICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuc2NhbGUocHJvaiwgaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaik7CiAgICAgICAgICBmd2QudnN1YihoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qLCBmd2QpOwogICAgICAgICAgY29uc3QgcHJvajIgPSBmd2QuZG90KHZlbCk7CiAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gbSAqIHByb2oyICogdGltZVN0ZXAgLyB3aGVlbC5yYWRpdXM7CiAgICAgICAgfQoKICAgICAgICBpZiAoKHdoZWVsLnNsaWRpbmcgfHwgIXdoZWVsLmlzSW5Db250YWN0KSAmJiB3aGVlbC5lbmdpbmVGb3JjZSAhPT0gMCAmJiB3aGVlbC51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkKSB7CiAgICAgICAgICAvLyBBcHBseSBjdXN0b20gcm90YXRpb24gd2hlbiBhY2NlbGVyYXRpbmcgYW5kIHNsaWRpbmcKICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAod2hlZWwuZW5naW5lRm9yY2UgPiAwID8gMSA6IC0xKSAqIHdoZWVsLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgKiB0aW1lU3RlcDsKICAgICAgICB9IC8vIExvY2sgd2hlZWxzCgoKICAgICAgICBpZiAoTWF0aC5hYnMod2hlZWwuYnJha2UpID4gTWF0aC5hYnMod2hlZWwuZW5naW5lRm9yY2UpKSB7CiAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gMDsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnJvdGF0aW9uICs9IHdoZWVsLmRlbHRhUm90YXRpb247IC8vIFVzZSB0aGUgb2xkIHZhbHVlCgogICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gKj0gMC45OTsgLy8gZGFtcGluZyBvZiByb3RhdGlvbiB3aGVuIG5vdCBpbiBjb250YWN0CiAgICAgIH0KICAgIH0KCiAgICB1cGRhdGVTdXNwZW5zaW9uKGRlbHRhVGltZSkgewogICAgICBjb25zdCBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7CiAgICAgIGNvbnN0IGNoYXNzaXNNYXNzID0gY2hhc3Npc0JvZHkubWFzczsKICAgICAgY29uc3Qgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvczsKICAgICAgY29uc3QgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7CgogICAgICBmb3IgKGxldCB3X2l0ID0gMDsgd19pdCA8IG51bVdoZWVsczsgd19pdCsrKSB7CiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW3dfaXRdOwoKICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHsKICAgICAgICAgIGxldCBmb3JjZTsgLy8gU3ByaW5nCgogICAgICAgICAgY29uc3Qgc3VzcF9sZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aDsKICAgICAgICAgIGNvbnN0IGN1cnJlbnRfbGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvbkxlbmd0aDsKICAgICAgICAgIGNvbnN0IGxlbmd0aF9kaWZmID0gc3VzcF9sZW5ndGggLSBjdXJyZW50X2xlbmd0aDsKICAgICAgICAgIGZvcmNlID0gd2hlZWwuc3VzcGVuc2lvblN0aWZmbmVzcyAqIGxlbmd0aF9kaWZmICogd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOyAvLyBEYW1wZXIKCiAgICAgICAgICBjb25zdCBwcm9qZWN0ZWRfcmVsX3ZlbCA9IHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5OwogICAgICAgICAgbGV0IHN1c3BfZGFtcGluZzsKCiAgICAgICAgICBpZiAocHJvamVjdGVkX3JlbF92ZWwgPCAwKSB7CiAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdDb21wcmVzc2lvbjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdSZWxheGF0aW9uOwogICAgICAgICAgfQoKICAgICAgICAgIGZvcmNlIC09IHN1c3BfZGFtcGluZyAqIHByb2plY3RlZF9yZWxfdmVsOwogICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gZm9yY2UgKiBjaGFzc2lzTWFzczsKCiAgICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkZvcmNlIDwgMCkgewogICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmUgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyBmcm9tIHRoZSB3b3JsZC4KICAgICAqLwoKCiAgICByZW1vdmVGcm9tV29ybGQod29ybGQpIHsKICAgICAgdGhpcy5jb25zdHJhaW50czsKICAgICAgd29ybGQucmVtb3ZlQm9keSh0aGlzLmNoYXNzaXNCb2R5KTsKICAgICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICB9CgogICAgY2FzdFJheSh3aGVlbCkgewogICAgICBjb25zdCByYXl2ZWN0b3IgPSBjYXN0UmF5X3JheXZlY3RvcjsKICAgICAgY29uc3QgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7CiAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCh3aGVlbCk7CiAgICAgIGNvbnN0IGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTsKICAgICAgbGV0IGRlcHRoID0gLTE7CiAgICAgIGNvbnN0IHJheWxlbiA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwucmFkaXVzOwogICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZShyYXlsZW4sIHJheXZlY3Rvcik7CiAgICAgIGNvbnN0IHNvdXJjZSA9IHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZDsKICAgICAgc291cmNlLnZhZGQocmF5dmVjdG9yLCB0YXJnZXQpOwogICAgICBjb25zdCByYXljYXN0UmVzdWx0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdDsKICAgICAgcmF5Y2FzdFJlc3VsdC5yZXNldCgpOyAvLyBUdXJuIG9mZiByYXkgY29sbGlzaW9uIHdpdGggdGhlIGNoYXNzaXMgdGVtcG9yYXJpbHkKCiAgICAgIGNvbnN0IG9sZFN0YXRlID0gY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gZmFsc2U7IC8vIENhc3QgcmF5IGFnYWluc3Qgd29ybGQKCiAgICAgIHRoaXMud29ybGQucmF5VGVzdChzb3VyY2UsIHRhcmdldCwgcmF5Y2FzdFJlc3VsdCk7CiAgICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gb2xkU3RhdGU7CiAgICAgIGNvbnN0IG9iamVjdCA9IHJheWNhc3RSZXN1bHQuYm9keTsKICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5ncm91bmRPYmplY3QgPSAwOwoKICAgICAgaWYgKG9iamVjdCkgewogICAgICAgIGRlcHRoID0gcmF5Y2FzdFJlc3VsdC5kaXN0YW5jZTsKICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDsKICAgICAgICB3aGVlbC5pc0luQ29udGFjdCA9IHRydWU7CiAgICAgICAgY29uc3QgaGl0RGlzdGFuY2UgPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlOwogICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBoaXREaXN0YW5jZSAtIHdoZWVsLnJhZGl1czsgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsCgogICAgICAgIGNvbnN0IG1pblN1c3BlbnNpb25MZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCAtIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7CiAgICAgICAgY29uc3QgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDsKCiAgICAgICAgaWYgKHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPCBtaW5TdXNwZW5zaW9uTGVuZ3RoKSB7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWluU3VzcGVuc2lvbkxlbmd0aDsKICAgICAgICB9CgogICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID4gbWF4U3VzcGVuc2lvbkxlbmd0aCkgewogICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IG1heFN1c3BlbnNpb25MZW5ndGg7CiAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LnJlc2V0KCk7CiAgICAgICAgfQoKICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KHdoZWVsLmRpcmVjdGlvbldvcmxkKTsKICAgICAgICBjb25zdCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7CiAgICAgICAgY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7CiAgICAgICAgY29uc3QgcHJvalZlbCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTsKCiAgICAgICAgaWYgKGRlbm9taW5hdG9yID49IC0wLjEpIHsKICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDsKICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGludiA9IC0xIC8gZGVub21pbmF0b3I7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IHByb2pWZWwgKiBpbnY7CiAgICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vcHV0IHdoZWVsIGluZm8gYXMgaW4gcmVzdCBwb3NpdGlvbgogICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCArIDAgKiB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsOwogICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wOwogICAgICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKC0xLCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTsKICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjA7CiAgICAgIH0KCiAgICAgIHJldHVybiBkZXB0aDsKICAgIH0KCiAgICB1cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKSB7CiAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gZmFsc2U7CiAgICAgIGNvbnN0IGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTsKICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpOwogICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUod2hlZWwuZGlyZWN0aW9uTG9jYWwsIHdoZWVsLmRpcmVjdGlvbldvcmxkKTsKICAgICAgY2hhc3Npc0JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHdoZWVsLmF4bGVMb2NhbCwgd2hlZWwuYXhsZVdvcmxkKTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLgogICAgICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuCiAgICAgKiBAcGFyYW0gd2hlZWxJbmRleCBUaGUgd2hlZWwgaW5kZXggdG8gdXBkYXRlLgogICAgICovCgoKICAgIHVwZGF0ZVdoZWVsVHJhbnNmb3JtKHdoZWVsSW5kZXgpIHsKICAgICAgY29uc3QgdXAgPSB0bXBWZWM0OwogICAgICBjb25zdCByaWdodCA9IHRtcFZlYzU7CiAgICAgIGNvbnN0IGZ3ZCA9IHRtcFZlYzY7CiAgICAgIGNvbnN0IHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdOwogICAgICB0aGlzLnVwZGF0ZVdoZWVsVHJhbnNmb3JtV29ybGQod2hlZWwpOwogICAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApOwogICAgICByaWdodC5jb3B5KHdoZWVsLmF4bGVMb2NhbCk7CiAgICAgIHVwLmNyb3NzKHJpZ2h0LCBmd2QpOwogICAgICBmd2Qubm9ybWFsaXplKCk7CiAgICAgIHJpZ2h0Lm5vcm1hbGl6ZSgpOyAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZQoKICAgICAgY29uc3Qgc3RlZXJpbmcgPSB3aGVlbC5zdGVlcmluZzsKICAgICAgY29uc3Qgc3RlZXJpbmdPcm4gPSBuZXcgUXVhdGVybmlvbigpOwogICAgICBzdGVlcmluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHVwLCBzdGVlcmluZyk7CiAgICAgIGNvbnN0IHJvdGF0aW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgcm90YXRpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZShyaWdodCwgd2hlZWwucm90YXRpb24pOyAvLyBXb3JsZCByb3RhdGlvbiBvZiB0aGUgd2hlZWwKCiAgICAgIGNvbnN0IHEgPSB3aGVlbC53b3JsZFRyYW5zZm9ybS5xdWF0ZXJuaW9uOwogICAgICB0aGlzLmNoYXNzaXNCb2R5LnF1YXRlcm5pb24ubXVsdChzdGVlcmluZ09ybiwgcSk7CiAgICAgIHEubXVsdChyb3RhdGluZ09ybiwgcSk7CiAgICAgIHEubm9ybWFsaXplKCk7IC8vIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB3aGVlbAoKICAgICAgY29uc3QgcCA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uOwogICAgICBwLmNvcHkod2hlZWwuZGlyZWN0aW9uV29ybGQpOwogICAgICBwLnNjYWxlKHdoZWVsLnN1c3BlbnNpb25MZW5ndGgsIHApOwogICAgICBwLnZhZGQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCBwKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2Ygb25lIG9mIHRoZSB3aGVlbHMKICAgICAqLwoKCiAgICBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsSW5kZXgpIHsKICAgICAgcmV0dXJuIHRoaXMud2hlZWxJbmZvc1t3aGVlbEluZGV4XS53b3JsZFRyYW5zZm9ybTsKICAgIH0KCiAgICB1cGRhdGVGcmljdGlvbih0aW1lU3RlcCkgewogICAgICBjb25zdCBzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2o7IC8vY2FsY3VsYXRlIHRoZSBpbXB1bHNlLCBzbyB0aGF0IHRoZSB3aGVlbHMgZG9uJ3QgbW92ZSBzaWRld2FyZHMKCiAgICAgIGNvbnN0IHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7CiAgICAgIGNvbnN0IG51bVdoZWVscyA9IHdoZWVsSW5mb3MubGVuZ3RoOwogICAgICBjb25zdCBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7CiAgICAgIGNvbnN0IGZvcndhcmRXUyA9IHVwZGF0ZUZyaWN0aW9uX2ZvcndhcmRXUzsKICAgICAgY29uc3QgYXhsZSA9IHVwZGF0ZUZyaWN0aW9uX2F4bGU7CiAgICAgIHRoaXMubnVtV2hlZWxzT25Hcm91bmQgPSAwOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKICAgICAgICBjb25zdCBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7CgogICAgICAgIGlmIChncm91bmRPYmplY3QpIHsKICAgICAgICAgIHRoaXMubnVtV2hlZWxzT25Hcm91bmQrKzsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gMDsKICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7CgogICAgICAgIGlmICghZm9yd2FyZFdTW2ldKSB7CiAgICAgICAgICBmb3J3YXJkV1NbaV0gPSBuZXcgVmVjMygpOwogICAgICAgIH0KCiAgICAgICAgaWYgKCFheGxlW2ldKSB7CiAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICBjb25zdCB3aGVlbCA9IHdoZWVsSW5mb3NbaV07CiAgICAgICAgY29uc3QgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5OwoKICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7CiAgICAgICAgICBjb25zdCBheGxlaSA9IGF4bGVbaV07CiAgICAgICAgICBjb25zdCB3aGVlbFRyYW5zID0gdGhpcy5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkKGkpOyAvLyBHZXQgd29ybGQgYXhsZQoKICAgICAgICAgIHdoZWVsVHJhbnMudmVjdG9yVG9Xb3JsZEZyYW1lKGRpcmVjdGlvbnNbdGhpcy5pbmRleFJpZ2h0QXhpc10sIGF4bGVpKTsKICAgICAgICAgIGNvbnN0IHN1cmZOb3JtYWxXUyA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7CiAgICAgICAgICBjb25zdCBwcm9qID0gYXhsZWkuZG90KHN1cmZOb3JtYWxXUyk7CiAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTsKICAgICAgICAgIGF4bGVpLnZzdWIoc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qLCBheGxlaSk7CiAgICAgICAgICBheGxlaS5ub3JtYWxpemUoKTsKICAgICAgICAgIHN1cmZOb3JtYWxXUy5jcm9zcyhheGxlaSwgZm9yd2FyZFdTW2ldKTsKICAgICAgICAgIGZvcndhcmRXU1tpXS5ub3JtYWxpemUoKTsKICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChjaGFzc2lzQm9keSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLCBncm91bmRPYmplY3QsIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgYXhsZWkpOwogICAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgKj0gc2lkZUZyaWN0aW9uU3RpZmZuZXNzMjsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IHNpZGVGYWN0b3IgPSAxOwogICAgICBjb25zdCBmd2RGYWN0b3IgPSAwLjU7CiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKICAgICAgICBjb25zdCBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7CiAgICAgICAgbGV0IHJvbGxpbmdGcmljdGlvbiA9IDA7CiAgICAgICAgd2hlZWwuc2xpcEluZm8gPSAxOwoKICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7CiAgICAgICAgICBjb25zdCBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZSA9IDA7CiAgICAgICAgICBjb25zdCBtYXhJbXB1bHNlID0gd2hlZWwuYnJha2UgPyB3aGVlbC5icmFrZSA6IGRlZmF1bHRSb2xsaW5nRnJpY3Rpb25JbXB1bHNlOyAvLyBidFdoZWVsQ29udGFjdFBvaW50IGNvbnRhY3RQdChjaGFzc2lzQm9keSxncm91bmRPYmplY3Qsd2hlZWxJbmZyYXljYXN0SW5mby5oaXRQb2ludFdvcmxkLGZvcndhcmRXU1t3aGVlbF0sbWF4SW1wdWxzZSk7CiAgICAgICAgICAvLyByb2xsaW5nRnJpY3Rpb24gPSBjYWxjUm9sbGluZ0ZyaWN0aW9uKGNvbnRhY3RQdCk7CgogICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7CiAgICAgICAgICByb2xsaW5nRnJpY3Rpb24gKz0gd2hlZWwuZW5naW5lRm9yY2UgKiB0aW1lU3RlcDsgLy8gcm9sbGluZ0ZyaWN0aW9uID0gMDsKCiAgICAgICAgICBjb25zdCBmYWN0b3IgPSBtYXhJbXB1bHNlIC8gcm9sbGluZ0ZyaWN0aW9uOwogICAgICAgICAgd2hlZWwuc2xpcEluZm8gKj0gZmFjdG9yOwogICAgICAgIH0gLy9zd2l0Y2ggYmV0d2VlbiBhY3RpdmUgcm9sbGluZyAodGhyb3R0bGUpLCBicmFraW5nIGFuZCBub24tYWN0aXZlIHJvbGxpbmcgZnJpY3Rpb24gKG50aHJvdHRsZS9icmVhaykKCgogICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDsKICAgICAgICB3aGVlbC5za2lkSW5mbyA9IDE7CgogICAgICAgIGlmIChncm91bmRPYmplY3QpIHsKICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTsKICAgICAgICAgIGNvbnN0IG1heGltcCA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwICogd2hlZWwuZnJpY3Rpb25TbGlwOwogICAgICAgICAgY29uc3QgbWF4aW1wU2lkZSA9IG1heGltcDsKICAgICAgICAgIGNvbnN0IG1heGltcFNxdWFyZWQgPSBtYXhpbXAgKiBtYXhpbXBTaWRlOwogICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgPSByb2xsaW5nRnJpY3Rpb247IC8vd2hlZWxJbmZvLmVuZ2luZUZvcmNlKiB0aW1lU3RlcDsKCiAgICAgICAgICBjb25zdCB4ID0gd2hlZWwuZm9yd2FyZEltcHVsc2UgKiBmd2RGYWN0b3IgLyB3aGVlbC5mb3J3YXJkQWNjZWxlcmF0aW9uOwogICAgICAgICAgY29uc3QgeSA9IHdoZWVsLnNpZGVJbXB1bHNlICogc2lkZUZhY3RvciAvIHdoZWVsLnNpZGVBY2NlbGVyYXRpb247CiAgICAgICAgICBjb25zdCBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7CiAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gZmFsc2U7CgogICAgICAgICAgaWYgKGltcHVsc2VTcXVhcmVkID4gbWF4aW1wU3F1YXJlZCkgewogICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSB0cnVlOwogICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gdHJ1ZTsKICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gbWF4aW1wIC8gTWF0aC5zcXJ0KGltcHVsc2VTcXVhcmVkKTsKICAgICAgICAgICAgd2hlZWwuc2tpZEluZm8gKj0gZmFjdG9yOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuc2xpZGluZykgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKCiAgICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHsKICAgICAgICAgICAgaWYgKHdoZWVsLnNraWRJbmZvIDwgMSkgewogICAgICAgICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvOwogICAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIGFwcGx5IHRoZSBpbXB1bHNlcwoKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICBjb25zdCB3aGVlbCA9IHdoZWVsSW5mb3NbaV07CiAgICAgICAgY29uc3QgcmVsX3BvcyA9IG5ldyBWZWMzKCk7CiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbF9wb3MpOyAvLyBjYW5ub25zIGFwcGx5aW1wdWxzZSBpcyB1c2luZyB3b3JsZCBjb29yZCBmb3IgdGhlIHBvc2l0aW9uCiAgICAgICAgLy9yZWxfcG9zLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTsKCiAgICAgICAgaWYgKHdoZWVsLmZvcndhcmRJbXB1bHNlICE9PSAwKSB7CiAgICAgICAgICBjb25zdCBpbXB1bHNlID0gbmV3IFZlYzMoKTsKICAgICAgICAgIGZvcndhcmRXU1tpXS5zY2FsZSh3aGVlbC5mb3J3YXJkSW1wdWxzZSwgaW1wdWxzZSk7CiAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSwgcmVsX3Bvcyk7CiAgICAgICAgfQoKICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHsKICAgICAgICAgIGNvbnN0IGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTsKICAgICAgICAgIGNvbnN0IHJlbF9wb3MyID0gbmV3IFZlYzMoKTsKICAgICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGdyb3VuZE9iamVjdC5wb3NpdGlvbiwgcmVsX3BvczIpOyAvL3JlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTsKCiAgICAgICAgICBjb25zdCBzaWRlSW1wID0gbmV3IFZlYzMoKTsKICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApOyAvLyBTY2FsZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIHVwIGRpcmVjdGlvbiB3aXRoIHJvbGxJbmZsdWVuY2UuCiAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLgoKICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvTG9jYWxGcmFtZShyZWxfcG9zLCByZWxfcG9zKTsKICAgICAgICAgIHJlbF9wb3NbJ3h5eidbdGhpcy5pbmRleFVwQXhpc11dICo9IHdoZWVsLnJvbGxJbmZsdWVuY2U7CiAgICAgICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7CiAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3Bvcyk7IC8vYXBwbHkgZnJpY3Rpb24gaW1wdWxzZSBvbiB0aGUgZ3JvdW5kCgogICAgICAgICAgc2lkZUltcC5zY2FsZSgtMSwgc2lkZUltcCk7CiAgICAgICAgICBncm91bmRPYmplY3QuYXBwbHlJbXB1bHNlKHNpZGVJbXAsIHJlbF9wb3MyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzQgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzUgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzYgPSBuZXcgVmVjMygpOwogIG5ldyBSYXkoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IGNhc3RSYXlfcmF5dmVjdG9yID0gbmV3IFZlYzMoKTsKICBjb25zdCBjYXN0UmF5X3RhcmdldCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZGlyZWN0aW9ucyA9IFtuZXcgVmVjMygxLCAwLCAwKSwgbmV3IFZlYzMoMCwgMSwgMCksIG5ldyBWZWMzKDAsIDAsIDEpXTsKICBjb25zdCB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpOwogIGNvbnN0IHVwZGF0ZUZyaWN0aW9uX2F4bGUgPSBbXTsKICBjb25zdCB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTsKICBjb25zdCBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTsKICBjb25zdCBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwgPSBuZXcgVmVjMygpOwoKICBmdW5jdGlvbiBjYWxjUm9sbGluZ0ZyaWN0aW9uKGJvZHkwLCBib2R5MSwgZnJpY3Rpb25Qb3NXb3JsZCwgZnJpY3Rpb25EaXJlY3Rpb25Xb3JsZCwgbWF4SW1wdWxzZSkgewogICAgbGV0IGoxID0gMDsKICAgIGNvbnN0IGNvbnRhY3RQb3NXb3JsZCA9IGZyaWN0aW9uUG9zV29ybGQ7IC8vIGNvbnN0IHJlbF9wb3MxID0gbmV3IFZlYzMoKTsKICAgIC8vIGNvbnN0IHJlbF9wb3MyID0gbmV3IFZlYzMoKTsKCiAgICBjb25zdCB2ZWwxID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwxOwogICAgY29uc3QgdmVsMiA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMjsKICAgIGNvbnN0IHZlbCA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsOyAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MC5wb3NpdGlvbiwgcmVsX3BvczEpOwogICAgLy8gY29udGFjdFBvc1dvcmxkLnZzdWIoYm9keTEucG9zaXRpb24sIHJlbF9wb3MyKTsKCiAgICBib2R5MC5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChjb250YWN0UG9zV29ybGQsIHZlbDEpOwogICAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoY29udGFjdFBvc1dvcmxkLCB2ZWwyKTsKICAgIHZlbDEudnN1Yih2ZWwyLCB2ZWwpOwogICAgY29uc3QgdnJlbCA9IGZyaWN0aW9uRGlyZWN0aW9uV29ybGQuZG90KHZlbCk7CiAgICBjb25zdCBkZW5vbTAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yKGJvZHkwLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkKTsKICAgIGNvbnN0IGRlbm9tMSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpOwogICAgY29uc3QgcmVsYXhhdGlvbiA9IDE7CiAgICBjb25zdCBqYWNEaWFnQUJJbnYgPSByZWxheGF0aW9uIC8gKGRlbm9tMCArIGRlbm9tMSk7IC8vIGNhbGN1bGF0ZSBqIHRoYXQgbW92ZXMgdXMgdG8gemVybyByZWxhdGl2ZSB2ZWxvY2l0eQoKICAgIGoxID0gLXZyZWwgKiBqYWNEaWFnQUJJbnY7CgogICAgaWYgKG1heEltcHVsc2UgPCBqMSkgewogICAgICBqMSA9IG1heEltcHVsc2U7CiAgICB9CgogICAgaWYgKGoxIDwgLW1heEltcHVsc2UpIHsKICAgICAgajEgPSAtbWF4SW1wdWxzZTsKICAgIH0KCiAgICByZXR1cm4gajE7CiAgfQoKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tID0gbmV3IFZlYzMoKTsKCiAgZnVuY3Rpb24gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5LCBwb3MsIG5vcm1hbCkgewogICAgY29uc3QgcjAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwOwogICAgY29uc3QgYzAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwOwogICAgY29uc3QgdmVjID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWM7CiAgICBjb25zdCBtID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tOwogICAgcG9zLnZzdWIoYm9keS5wb3NpdGlvbiwgcjApOwogICAgcjAuY3Jvc3Mobm9ybWFsLCBjMCk7CiAgICBib2R5LmludkluZXJ0aWFXb3JsZC52bXVsdChjMCwgbSk7CiAgICBtLmNyb3NzKHIwLCB2ZWMpOwogICAgcmV0dXJuIGJvZHkuaW52TWFzcyArIG5vcm1hbC5kb3QodmVjKTsKICB9CgogIGNvbnN0IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyID0gbmV3IFZlYzMoKTsKICBjb25zdCByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbCA9IG5ldyBWZWMzKCk7IC8vIGJpbGF0ZXJhbCBjb25zdHJhaW50IGJldHdlZW4gdHdvIGR5bmFtaWMgb2JqZWN0cwoKICBmdW5jdGlvbiByZXNvbHZlU2luZ2xlQmlsYXRlcmFsKGJvZHkxLCBwb3MxLCBib2R5MiwgcG9zMiwgbm9ybWFsKSB7CiAgICBjb25zdCBub3JtYWxMZW5TcXIgPSBub3JtYWwubGVuZ3RoU3F1YXJlZCgpOwoKICAgIGlmIChub3JtYWxMZW5TcXIgPiAxLjEpIHsKICAgICAgcmV0dXJuIDA7IC8vIG5vIGltcHVsc2UKICAgIH0gLy8gY29uc3QgcmVsX3BvczEgPSBuZXcgVmVjMygpOwogICAgLy8gY29uc3QgcmVsX3BvczIgPSBuZXcgVmVjMygpOwogICAgLy8gcG9zMS52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMSk7CiAgICAvLyBwb3MyLnZzdWIoYm9keTIucG9zaXRpb24sIHJlbF9wb3MyKTsKCgogICAgY29uc3QgdmVsMSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMTsKICAgIGNvbnN0IHZlbDIgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDI7CiAgICBjb25zdCB2ZWwgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDsKICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHBvczEsIHZlbDEpOwogICAgYm9keTIuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMiwgdmVsMik7CiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTsKICAgIGNvbnN0IHJlbF92ZWwgPSBub3JtYWwuZG90KHZlbCk7CiAgICBjb25zdCBjb250YWN0RGFtcGluZyA9IDAuMjsKICAgIGNvbnN0IG1hc3NUZXJtID0gMSAvIChib2R5MS5pbnZNYXNzICsgYm9keTIuaW52TWFzcyk7CiAgICBjb25zdCBpbXB1bHNlID0gLWNvbnRhY3REYW1waW5nICogcmVsX3ZlbCAqIG1hc3NUZXJtOwogICAgcmV0dXJuIGltcHVsc2U7CiAgfQoKICAvKioKICAgKiBTcGhlcmljYWwgc2hhcGUKICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCByYWRpdXMgPSAxCiAgICogICAgIGNvbnN0IHNwaGVyZVNoYXBlID0gbmV3IENBTk5PTi5TcGhlcmUocmFkaXVzKQogICAqICAgICBjb25zdCBzcGhlcmVCb2R5ID0gbmV3IENBTk5PTi5Cb2R5KHsgbWFzczogMSwgc2hhcGU6IHNwaGVyZVNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoc3BoZXJlQm9keSkKICAgKi8KICBjbGFzcyBTcGhlcmUgZXh0ZW5kcyBTaGFwZSB7CiAgICAvKioKICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZS4KICAgICAqLwoKICAgIC8qKgogICAgICoKICAgICAqIEBwYXJhbSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLCBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKHJhZGl1cykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuU1BIRVJFCiAgICAgIH0pOwogICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyAhPT0gdW5kZWZpbmVkID8gcmFkaXVzIDogMS4wOwoKICAgICAgaWYgKHRoaXMucmFkaXVzIDwgMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwaGVyZSByYWRpdXMgY2Fubm90IGJlIG5lZ2F0aXZlLicpOwogICAgICB9CgogICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICB9CiAgICAvKiogY2FsY3VsYXRlTG9jYWxJbmVydGlhICovCgoKICAgIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgY29uc3QgSSA9IDIuMCAqIG1hc3MgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzIC8gNS4wOwogICAgICB0YXJnZXQueCA9IEk7CiAgICAgIHRhcmdldC55ID0gSTsKICAgICAgdGFyZ2V0LnogPSBJOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqIHZvbHVtZSAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDMpIC8gMy4wOwogICAgfQoKICAgIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkgewogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gdGhpcy5yYWRpdXM7CiAgICB9CgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgY29uc3QgciA9IHRoaXMucmFkaXVzOwogICAgICBjb25zdCBheGVzID0gWyd4JywgJ3knLCAneiddOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgYXggPSBheGVzW2ldOwogICAgICAgIG1pbltheF0gPSBwb3NbYXhdIC0gcjsKICAgICAgICBtYXhbYXhdID0gcG9zW2F4XSArIHI7CiAgICAgIH0KICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uCgogIG5ldyBWZWMzKCk7IC8vIFJlbGF0aXZlIHZlbG9jaXR5CgogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQ3lsaW5kZXIgY2xhc3MuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3QgcmFkaXVzVG9wID0gMC41CiAgICogICAgIGNvbnN0IHJhZGl1c0JvdHRvbSA9IDAuNQogICAqICAgICBjb25zdCBoZWlnaHQgPSAyCiAgICogICAgIGNvbnN0IG51bVNlZ21lbnRzID0gMTIKICAgKiAgICAgY29uc3QgY3lsaW5kZXJTaGFwZSA9IG5ldyBDQU5OT04uQ3lsaW5kZXIocmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgbnVtU2VnbWVudHMpCiAgICogICAgIGNvbnN0IGN5bGluZGVyQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBjeWxpbmRlclNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoY3lsaW5kZXJCb2R5KQogICAqLwoKICBjbGFzcyBDeWxpbmRlciBleHRlbmRzIENvbnZleFBvbHloZWRyb24gewogICAgLyoqIFRoZSByYWRpdXMgb2YgdGhlIHRvcCBvZiB0aGUgQ3lsaW5kZXIuICovCgogICAgLyoqIFRoZSByYWRpdXMgb2YgdGhlIGJvdHRvbSBvZiB0aGUgQ3lsaW5kZXIuICovCgogICAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIEN5bGluZGVyLiAqLwoKICAgIC8qKiBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGJ1aWxkIHRoZSBjeWxpbmRlciBvdXQgb2YuICovCgogICAgLyoqCiAgICAgKiBAcGFyYW0gcmFkaXVzVG9wIFRoZSByYWRpdXMgb2YgdGhlIHRvcCBvZiB0aGUgQ3lsaW5kZXIuCiAgICAgKiBAcGFyYW0gcmFkaXVzQm90dG9tIFRoZSByYWRpdXMgb2YgdGhlIGJvdHRvbSBvZiB0aGUgQ3lsaW5kZXIuCiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIEN5bGluZGVyLgogICAgICogQHBhcmFtIG51bVNlZ21lbnRzIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgdG8gYnVpbGQgdGhlIGN5bGluZGVyIG91dCBvZi4KICAgICAqLwogICAgY29uc3RydWN0b3IocmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgbnVtU2VnbWVudHMpIHsKICAgICAgaWYgKHJhZGl1c1RvcCA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmFkaXVzVG9wID0gMTsKICAgICAgfQoKICAgICAgaWYgKHJhZGl1c0JvdHRvbSA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmFkaXVzQm90dG9tID0gMTsKICAgICAgfQoKICAgICAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7CiAgICAgICAgaGVpZ2h0ID0gMTsKICAgICAgfQoKICAgICAgaWYgKG51bVNlZ21lbnRzID09PSB2b2lkIDApIHsKICAgICAgICBudW1TZWdtZW50cyA9IDg7CiAgICAgIH0KCiAgICAgIGlmIChyYWRpdXNUb3AgPCAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3lsaW5kZXIgcmFkaXVzVG9wIGNhbm5vdCBiZSBuZWdhdGl2ZS4nKTsKICAgICAgfQoKICAgICAgaWYgKHJhZGl1c0JvdHRvbSA8IDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjeWxpbmRlciByYWRpdXNCb3R0b20gY2Fubm90IGJlIG5lZ2F0aXZlLicpOwogICAgICB9CgogICAgICBjb25zdCBOID0gbnVtU2VnbWVudHM7CiAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICAgIGNvbnN0IGF4ZXMgPSBbXTsKICAgICAgY29uc3QgZmFjZXMgPSBbXTsKICAgICAgY29uc3QgYm90dG9tZmFjZSA9IFtdOwogICAgICBjb25zdCB0b3BmYWNlID0gW107CiAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zOwogICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbjsgLy8gRmlyc3QgYm90dG9tIHBvaW50CgogICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWMzKC1yYWRpdXNCb3R0b20gKiBzaW4oMCksIC1oZWlnaHQgKiAwLjUsIHJhZGl1c0JvdHRvbSAqIGNvcygwKSkpOwogICAgICBib3R0b21mYWNlLnB1c2goMCk7IC8vIEZpcnN0IHRvcCBwb2ludAoKICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjMygtcmFkaXVzVG9wICogc2luKDApLCBoZWlnaHQgKiAwLjUsIHJhZGl1c1RvcCAqIGNvcygwKSkpOwogICAgICB0b3BmYWNlLnB1c2goMSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgewogICAgICAgIGNvbnN0IHRoZXRhID0gMiAqIE1hdGguUEkgLyBOICogKGkgKyAxKTsKICAgICAgICBjb25zdCB0aGV0YU4gPSAyICogTWF0aC5QSSAvIE4gKiAoaSArIDAuNSk7CgogICAgICAgIGlmIChpIDwgTiAtIDEpIHsKICAgICAgICAgIC8vIEJvdHRvbQogICAgICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjMygtcmFkaXVzQm90dG9tICogc2luKHRoZXRhKSwgLWhlaWdodCAqIDAuNSwgcmFkaXVzQm90dG9tICogY29zKHRoZXRhKSkpOwogICAgICAgICAgYm90dG9tZmFjZS5wdXNoKDIgKiBpICsgMik7IC8vIFRvcAoKICAgICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlYzMoLXJhZGl1c1RvcCAqIHNpbih0aGV0YSksIGhlaWdodCAqIDAuNSwgcmFkaXVzVG9wICogY29zKHRoZXRhKSkpOwogICAgICAgICAgdG9wZmFjZS5wdXNoKDIgKiBpICsgMyk7IC8vIEZhY2UKCiAgICAgICAgICBmYWNlcy5wdXNoKFsyICogaSwgMiAqIGkgKyAxLCAyICogaSArIDMsIDIgKiBpICsgMl0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBmYWNlcy5wdXNoKFsyICogaSwgMiAqIGkgKyAxLCAxLCAwXSk7IC8vIENvbm5lY3QKICAgICAgICB9IC8vIEF4aXM6IHdlIGNhbiBjdXQgb2ZmIGhhbGYgb2YgdGhlbSBpZiB3ZSBoYXZlIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzCgoKICAgICAgICBpZiAoTiAlIDIgPT09IDEgfHwgaSA8IE4gLyAyKSB7CiAgICAgICAgICBheGVzLnB1c2gobmV3IFZlYzMoLXNpbih0aGV0YU4pLCAwLCBjb3ModGhldGFOKSkpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgZmFjZXMucHVzaChib3R0b21mYWNlKTsKICAgICAgYXhlcy5wdXNoKG5ldyBWZWMzKDAsIDEsIDApKTsgLy8gUmVvcmRlciB0b3AgZmFjZQoKICAgICAgY29uc3QgdGVtcCA9IFtdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BmYWNlLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGVtcC5wdXNoKHRvcGZhY2VbdG9wZmFjZS5sZW5ndGggLSBpIC0gMV0pOwogICAgICB9CgogICAgICBmYWNlcy5wdXNoKHRlbXApOwogICAgICBzdXBlcih7CiAgICAgICAgdmVydGljZXMsCiAgICAgICAgZmFjZXMsCiAgICAgICAgYXhlcwogICAgICB9KTsKICAgICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQ1lMSU5ERVI7CiAgICAgIHRoaXMucmFkaXVzVG9wID0gcmFkaXVzVG9wOwogICAgICB0aGlzLnJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbTsKICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7CiAgICAgIHRoaXMubnVtU2VnbWVudHMgPSBudW1TZWdtZW50czsKICAgIH0KCiAgfQoKICAvKioKICAgKiBQYXJ0aWNsZSBzaGFwZS4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBwYXJ0aWNsZVNoYXBlID0gbmV3IENBTk5PTi5QYXJ0aWNsZSgpCiAgICogICAgIGNvbnN0IHBhcnRpY2xlQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBwYXJ0aWNsZVNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkocGFydGljbGVCb2R5KQogICAqLwogIGNsYXNzIFBhcnRpY2xlIGV4dGVuZHMgU2hhcGUgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5QQVJUSUNMRQogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlTG9jYWxJbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQuc2V0KDAsIDAsIDApOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuIDA7CiAgICB9CgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSAwOwogICAgfQoKICAgIGNhbGN1bGF0ZVdvcmxkQUFCQihwb3MsIHF1YXQsIG1pbiwgbWF4KSB7CiAgICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4CiAgICAgIG1pbi5jb3B5KHBvcyk7CiAgICAgIG1heC5jb3B5KHBvcyk7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQSBwbGFuZSwgZmFjaW5nIGluIHRoZSBaIGRpcmVjdGlvbi4gVGhlIHBsYW5lIGhhcyBpdHMgc3VyZmFjZSBhdCB6PTAgYW5kIGV2ZXJ5dGhpbmcgYmVsb3cgej0wIGlzIGFzc3VtZWQgdG8gYmUgc29saWQgcGxhbmUuIFRvIG1ha2UgdGhlIHBsYW5lIGZhY2UgaW4gc29tZSBvdGhlciBkaXJlY3Rpb24gdGhhbiB6LCB5b3UgbXVzdCBwdXQgaXQgaW5zaWRlIGEgQm9keSBhbmQgcm90YXRlIHRoYXQgYm9keS4gU2VlIHRoZSBkZW1vcy4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBwbGFuZVNoYXBlID0gbmV3IENBTk5PTi5QbGFuZSgpCiAgICogICAgIGNvbnN0IHBsYW5lQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDAsIHNoYXBlOiAgcGxhbmVTaGFwZSB9KQogICAqICAgICBwbGFuZUJvZHkucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoLU1hdGguUEkgLyAyLCAwLCAwKSAvLyBtYWtlIGl0IGZhY2UgdXAKICAgKiAgICAgd29ybGQuYWRkQm9keShwbGFuZUJvZHkpCiAgICovCiAgY2xhc3MgUGxhbmUgZXh0ZW5kcyBTaGFwZSB7CiAgICAvKiogd29ybGROb3JtYWwgKi8KCiAgICAvKiogd29ybGROb3JtYWxOZWVkc1VwZGF0ZSAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5QTEFORQogICAgICB9KTsgLy8gV29ybGQgb3JpZW50ZWQgbm9ybWFsCgogICAgICB0aGlzLndvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7CiAgICB9CiAgICAvKiogY29tcHV0ZVdvcmxkTm9ybWFsICovCgoKICAgIGNvbXB1dGVXb3JsZE5vcm1hbChxdWF0KSB7CiAgICAgIGNvbnN0IG4gPSB0aGlzLndvcmxkTm9ybWFsOwogICAgICBuLnNldCgwLCAwLCAxKTsKICAgICAgcXVhdC52bXVsdChuLCBuKTsKICAgICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gZmFsc2U7CiAgICB9CgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuICgvLyBUaGUgcGxhbmUgaXMgaW5maW5pdGUuLi4KICAgICAgICBOdW1iZXIuTUFYX1ZBTFVFCiAgICAgICk7CiAgICB9CgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgLy8gVGhlIHBsYW5lIEFBQkIgaXMgaW5maW5pdGUsIGV4Y2VwdCBpZiB0aGUgbm9ybWFsIGlzIHBvaW50aW5nIGFsb25nIGFueSBheGlzCiAgICAgIHRlbXBOb3JtYWwuc2V0KDAsIDAsIDEpOyAvLyBEZWZhdWx0IHBsYW5lIG5vcm1hbCBpcyB6CgogICAgICBxdWF0LnZtdWx0KHRlbXBOb3JtYWwsIHRlbXBOb3JtYWwpOwogICAgICBjb25zdCBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFOwogICAgICBtaW4uc2V0KC1tYXhWYWwsIC1tYXhWYWwsIC1tYXhWYWwpOwogICAgICBtYXguc2V0KG1heFZhbCwgbWF4VmFsLCBtYXhWYWwpOwoKICAgICAgaWYgKHRlbXBOb3JtYWwueCA9PT0gMSkgewogICAgICAgIG1heC54ID0gcG9zLng7CiAgICAgIH0gZWxzZSBpZiAodGVtcE5vcm1hbC54ID09PSAtMSkgewogICAgICAgIG1pbi54ID0gcG9zLng7CiAgICAgIH0KCiAgICAgIGlmICh0ZW1wTm9ybWFsLnkgPT09IDEpIHsKICAgICAgICBtYXgueSA9IHBvcy55OwogICAgICB9IGVsc2UgaWYgKHRlbXBOb3JtYWwueSA9PT0gLTEpIHsKICAgICAgICBtaW4ueSA9IHBvcy55OwogICAgICB9CgogICAgICBpZiAodGVtcE5vcm1hbC56ID09PSAxKSB7CiAgICAgICAgbWF4LnogPSBwb3MuejsKICAgICAgfSBlbHNlIGlmICh0ZW1wTm9ybWFsLnogPT09IC0xKSB7CiAgICAgICAgbWluLnogPSBwb3MuejsKICAgICAgfQogICAgfQoKICAgIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkgewogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTsKICAgIH0KCiAgfQogIGNvbnN0IHRlbXBOb3JtYWwgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBIZWlnaHRmaWVsZCBzaGFwZSBjbGFzcy4gSGVpZ2h0IGRhdGEgaXMgZ2l2ZW4gYXMgYW4gYXJyYXkuIFRoZXNlIGRhdGEgcG9pbnRzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSB3aXRoIGEgZ2l2ZW4gZGlzdGFuY2UuCiAgICogQHRvZG8gU2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBhbG9uZyBhbGwgYXhlcywgbm90IGp1c3QgeQogICAqIEB0b2RvIHNob3VsZCBiZSBwb3NzaWJsZSB0byBzY2FsZSBhbG9uZyBhbGwgYXhlcwogICAqIEB0b2RvIFJlZmFjdG9yIGVsZW1lbnRTaXplIHRvIGVsZW1lbnRTaXplWCBhbmQgZWxlbWVudFNpemVZCiAgICoKICAgKiBAZXhhbXBsZQogICAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuCiAgICogICAgIGNvbnN0IGRhdGEgPSBbXQogICAqICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykgewogICAqICAgICAgICAgY29uc3QgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpCiAgICogICAgICAgICBkYXRhLnB1c2goeSkKICAgKiAgICAgfQogICAqCiAgICogICAgIC8vIENyZWF0ZSB0aGUgaGVpZ2h0ZmllbGQgc2hhcGUKICAgKiAgICAgY29uc3QgaGVpZ2h0ZmllbGRTaGFwZSA9IG5ldyBDQU5OT04uSGVpZ2h0ZmllbGQoZGF0YSwgewogICAqICAgICAgICAgZWxlbWVudFNpemU6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBhbmQgWSBkaXJlY3Rpb25zCiAgICogICAgIH0pCiAgICogICAgIGNvbnN0IGhlaWdodGZpZWxkQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IHNoYXBlOiBoZWlnaHRmaWVsZFNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KQogICAqLwogIGNsYXNzIEhlaWdodGZpZWxkIGV4dGVuZHMgU2hhcGUgewogICAgLyoqCiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1pbmltdW0gdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzIGluIHRoZSBkYXRhIGFycmF5LgogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZCBzcGFjaW5nIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggYW5kIFkgZGlyZWN0aW9uLgogICAgICogQHRvZG8gZWxlbWVudFNpemVYIGFuZCBZCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGRhdGEgQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7CiAgICAgICAgbWF4VmFsdWU6IG51bGwsCiAgICAgICAgbWluVmFsdWU6IG51bGwsCiAgICAgICAgZWxlbWVudFNpemU6IDEKICAgICAgfSk7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRAogICAgICB9KTsKICAgICAgdGhpcy5kYXRhID0gZGF0YTsKICAgICAgdGhpcy5tYXhWYWx1ZSA9IG9wdGlvbnMubWF4VmFsdWU7CiAgICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlOwogICAgICB0aGlzLmVsZW1lbnRTaXplID0gb3B0aW9ucy5lbGVtZW50U2l6ZTsKCiAgICAgIGlmIChvcHRpb25zLm1pblZhbHVlID09PSBudWxsKSB7CiAgICAgICAgdGhpcy51cGRhdGVNaW5WYWx1ZSgpOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCkgewogICAgICAgIHRoaXMudXBkYXRlTWF4VmFsdWUoKTsKICAgICAgfQoKICAgICAgdGhpcy5jYWNoZUVuYWJsZWQgPSB0cnVlOwogICAgICB0aGlzLnBpbGxhckNvbnZleCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAgIHRoaXMucGlsbGFyT2Zmc2V0ID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOyAvLyAiaV9qX2lzVXBwZXIiID0+IHsgY29udmV4OiAuLi4sIG9mZnNldDogLi4uIH0KICAgICAgLy8gZm9yIGV4YW1wbGU6CiAgICAgIC8vIF9jYWNoZWRQaWxsYXJzWyIwXzJfMSJdCgogICAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307CiAgICB9CiAgICAvKioKICAgICAqIENhbGwgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgZGF0YSBhcnJheS4KICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIHRoaXMuX2NhY2hlZFBpbGxhcnMgPSB7fTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIHRoZSBgbWluVmFsdWVgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlTWluVmFsdWUoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGxldCBtaW5WYWx1ZSA9IGRhdGFbMF1bMF07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCB2ID0gZGF0YVtpXVtqXTsKCiAgICAgICAgICBpZiAodiA8IG1pblZhbHVlKSB7CiAgICAgICAgICAgIG1pblZhbHVlID0gdjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIHRoZSBgbWF4VmFsdWVgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlTWF4VmFsdWUoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGxldCBtYXhWYWx1ZSA9IGRhdGFbMF1bMF07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCB2ID0gZGF0YVtpXVtqXTsKCiAgICAgICAgICBpZiAodiA+IG1heFZhbHVlKSB7CiAgICAgICAgICAgIG1heFZhbHVlID0gdjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMubWF4VmFsdWUgPSBtYXhWYWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBoZWlnaHQgdmFsdWUgYXQgYW4gaW5kZXguIERvbid0IGZvcmdldCB0byB1cGRhdGUgbWF4VmFsdWUgYW5kIG1pblZhbHVlIGFmdGVyIHlvdSdyZSBkb25lLgogICAgICovCgoKICAgIHNldEhlaWdodFZhbHVlQXRJbmRleCh4aSwgeWksIHZhbHVlKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGRhdGFbeGldW3lpXSA9IHZhbHVlOyAvLyBJbnZhbGlkYXRlIGNhY2hlCgogICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBmYWxzZSk7CgogICAgICBpZiAoeGkgPiAwKSB7CiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWksIHRydWUpOwogICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSAtIDEsIHlpLCBmYWxzZSk7CiAgICAgIH0KCiAgICAgIGlmICh5aSA+IDApIHsKICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpIC0gMSwgdHJ1ZSk7CiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSAtIDEsIGZhbHNlKTsKICAgICAgfQoKICAgICAgaWYgKHlpID4gMCAmJiB4aSA+IDApIHsKICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSAtIDEsIHRydWUpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBtYXgvbWluIGluIGEgcmVjdGFuZ2xlIGluIHRoZSBtYXRyaXggZGF0YQogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi4KICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdCBhcnJheSwgaWYgaXQgd2FzIHBhc3NlZCBpbi4gTWluaW11bSB3aWxsIGJlIGF0IHBvc2l0aW9uIDAgYW5kIG1heCBhdCAxLgogICAgICovCgoKICAgIGdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBbXTsKICAgICAgfQoKICAgICAgLy8gR2V0IG1heCBhbmQgbWluIG9mIHRoZSBkYXRhCiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7IC8vIFNldCBmaXJzdCB2YWx1ZQoKICAgICAgbGV0IG1heCA9IHRoaXMubWluVmFsdWU7CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPD0gaU1heFg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKSB7CiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBkYXRhW2ldW2pdOwoKICAgICAgICAgIGlmIChoZWlnaHQgPiBtYXgpIHsKICAgICAgICAgICAgbWF4ID0gaGVpZ2h0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmVzdWx0WzBdID0gdGhpcy5taW5WYWx1ZTsKICAgICAgcmVzdWx0WzFdID0gbWF4OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGluZGV4IG9mIGEgbG9jYWwgcG9zaXRpb24gb24gdGhlIGhlaWdodGZpZWxkLiBUaGUgaW5kZXhlcyBpbmRpY2F0ZSB0aGUgcmVjdGFuZ2xlcywgc28gaWYgeW91ciB0ZXJyYWluIGlzIG1hZGUgb2YgTiB4IE4gaGVpZ2h0IGRhdGEgcG9pbnRzLCB5b3Ugd2lsbCBoYXZlIHJlY3RhbmdsZSBpbmRleGVzIHJhbmdpbmcgZnJvbSAwIHRvIE4tMS4KICAgICAqIEBwYXJhbSByZXN1bHQgVHdvLWVsZW1lbnQgYXJyYXkKICAgICAqIEBwYXJhbSBjbGFtcCBJZiB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIGNsYW1wZWQgdG8gdGhlIGhlaWdodGZpZWxkIGVkZ2UuCiAgICAgKi8KCgogICAgZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIHJlc3VsdCwgY2xhbXApIHsKICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0CiAgICAgIGNvbnN0IHcgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBsZXQgeGkgPSBNYXRoLmZsb29yKHggLyB3KTsKICAgICAgbGV0IHlpID0gTWF0aC5mbG9vcih5IC8gdyk7CiAgICAgIHJlc3VsdFswXSA9IHhpOwogICAgICByZXN1bHRbMV0gPSB5aTsKCiAgICAgIGlmIChjbGFtcCkgewogICAgICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzCiAgICAgICAgaWYgKHhpIDwgMCkgewogICAgICAgICAgeGkgPSAwOwogICAgICAgIH0KCiAgICAgICAgaWYgKHlpIDwgMCkgewogICAgICAgICAgeWkgPSAwOwogICAgICAgIH0KCiAgICAgICAgaWYgKHhpID49IGRhdGEubGVuZ3RoIC0gMSkgewogICAgICAgICAgeGkgPSBkYXRhLmxlbmd0aCAtIDE7CiAgICAgICAgfQoKICAgICAgICBpZiAoeWkgPj0gZGF0YVswXS5sZW5ndGggLSAxKSB7CiAgICAgICAgICB5aSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsKICAgICAgICB9CiAgICAgIH0gLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpbgoKCiAgICAgIGlmICh4aSA8IDAgfHwgeWkgPCAwIHx8IHhpID49IGRhdGEubGVuZ3RoIC0gMSB8fCB5aSA+PSBkYXRhWzBdLmxlbmd0aCAtIDEpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGdldFRyaWFuZ2xlQXQoeCwgeSwgZWRnZUNsYW1wLCBhLCBiLCBjKSB7CiAgICAgIGNvbnN0IGlkeCA9IGdldEhlaWdodEF0X2lkeDsKICAgICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApOwogICAgICBsZXQgeGkgPSBpZHhbMF07CiAgICAgIGxldCB5aSA9IGlkeFsxXTsKICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTsKCiAgICAgIGlmIChlZGdlQ2xhbXApIHsKICAgICAgICB4aSA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeGkpKTsKICAgICAgICB5aSA9IE1hdGgubWluKGRhdGFbMF0ubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeWkpKTsKICAgICAgfQoKICAgICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBsb3dlckRpc3QyID0gKHggLyBlbGVtZW50U2l6ZSAtIHhpKSAqKiAyICsgKHkgLyBlbGVtZW50U2l6ZSAtIHlpKSAqKiAyOwogICAgICBjb25zdCB1cHBlckRpc3QyID0gKHggLyBlbGVtZW50U2l6ZSAtICh4aSArIDEpKSAqKiAyICsgKHkgLyBlbGVtZW50U2l6ZSAtICh5aSArIDEpKSAqKiAyOwogICAgICBjb25zdCB1cHBlciA9IGxvd2VyRGlzdDIgPiB1cHBlckRpc3QyOwogICAgICB0aGlzLmdldFRyaWFuZ2xlKHhpLCB5aSwgdXBwZXIsIGEsIGIsIGMpOwogICAgICByZXR1cm4gdXBwZXI7CiAgICB9CgogICAgZ2V0Tm9ybWFsQXQoeCwgeSwgZWRnZUNsYW1wLCByZXN1bHQpIHsKICAgICAgY29uc3QgYSA9IGdldE5vcm1hbEF0X2E7CiAgICAgIGNvbnN0IGIgPSBnZXROb3JtYWxBdF9iOwogICAgICBjb25zdCBjID0gZ2V0Tm9ybWFsQXRfYzsKICAgICAgY29uc3QgZTAgPSBnZXROb3JtYWxBdF9lMDsKICAgICAgY29uc3QgZTEgPSBnZXROb3JtYWxBdF9lMTsKICAgICAgdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7CiAgICAgIGIudnN1YihhLCBlMCk7CiAgICAgIGMudnN1YihhLCBlMSk7CiAgICAgIGUwLmNyb3NzKGUxLCByZXN1bHQpOwogICAgICByZXN1bHQubm9ybWFsaXplKCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBBQUJCIG9mIGEgc3F1YXJlIGluIHRoZSBoZWlnaHRmaWVsZAogICAgICogQHBhcmFtIHhpCiAgICAgKiBAcGFyYW0geWkKICAgICAqIEBwYXJhbSByZXN1bHQKICAgICAqLwoKCiAgICBnZXRBYWJiQXRJbmRleCh4aSwgeWksIF9yZWYpIHsKICAgICAgbGV0IHsKICAgICAgICBsb3dlckJvdW5kLAogICAgICAgIHVwcGVyQm91bmQKICAgICAgfSA9IF9yZWY7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTsKICAgICAgbG93ZXJCb3VuZC5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWldKTsKICAgICAgdXBwZXJCb3VuZC5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpICsgMV0pOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGhlaWdodCBpbiB0aGUgaGVpZ2h0ZmllbGQgYXQgYSBnaXZlbiBwb3NpdGlvbgogICAgICovCgoKICAgIGdldEhlaWdodEF0KHgsIHksIGVkZ2VDbGFtcCkgewogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBjb25zdCBhID0gZ2V0SGVpZ2h0QXRfYTsKICAgICAgY29uc3QgYiA9IGdldEhlaWdodEF0X2I7CiAgICAgIGNvbnN0IGMgPSBnZXRIZWlnaHRBdF9jOwogICAgICBjb25zdCBpZHggPSBnZXRIZWlnaHRBdF9pZHg7CiAgICAgIHRoaXMuZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIGlkeCwgZWRnZUNsYW1wKTsKICAgICAgbGV0IHhpID0gaWR4WzBdOwogICAgICBsZXQgeWkgPSBpZHhbMV07CgogICAgICBpZiAoZWRnZUNsYW1wKSB7CiAgICAgICAgeGkgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHhpKSk7CiAgICAgICAgeWkgPSBNYXRoLm1pbihkYXRhWzBdLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHlpKSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHVwcGVyID0gdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7CiAgICAgIGJhcnljZW50cmljV2VpZ2h0cyh4LCB5LCBhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBnZXRIZWlnaHRBdF93ZWlnaHRzKTsKICAgICAgY29uc3QgdyA9IGdldEhlaWdodEF0X3dlaWdodHM7CgogICAgICBpZiAodXBwZXIpIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICByZXR1cm4gZGF0YVt4aSArIDFdW3lpICsgMV0gKiB3LnggKyBkYXRhW3hpXVt5aSArIDFdICogdy55ICsgZGF0YVt4aSArIDFdW3lpXSAqIHcuejsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICByZXR1cm4gZGF0YVt4aV1beWldICogdy54ICsgZGF0YVt4aSArIDFdW3lpXSAqIHcueSArIGRhdGFbeGldW3lpICsgMV0gKiB3Lno7CiAgICAgIH0KICAgIH0KCiAgICBnZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICByZXR1cm4gYCR7eGl9XyR7eWl9XyR7Z2V0VXBwZXJUcmlhbmdsZSA/IDEgOiAwfWA7CiAgICB9CgogICAgZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKSB7CiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpXTsKICAgIH0KCiAgICBzZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUsIGNvbnZleCwgb2Zmc2V0KSB7CiAgICAgIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldID0gewogICAgICAgIGNvbnZleCwKICAgICAgICBvZmZzZXQKICAgICAgfTsKICAgIH0KCiAgICBjbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICBkZWxldGUgdGhpcy5fY2FjaGVkUGlsbGFyc1t0aGlzLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKV07CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIHRyaWFuZ2xlIGZyb20gdGhlIGhlaWdodGZpZWxkCiAgICAgKi8KCgogICAgZ2V0VHJpYW5nbGUoeGksIHlpLCB1cHBlciwgYSwgYiwgYykgewogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7CgogICAgICBpZiAodXBwZXIpIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICBhLnNldCgoeGkgKyAxKSAqIGVsZW1lbnRTaXplLCAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpICsgMV1beWkgKyAxXSk7CiAgICAgICAgYi5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWkgKyAxXSk7CiAgICAgICAgYy5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpXSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzCiAgICAgICAgYS5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWldKTsKICAgICAgICBiLnNldCgoeGkgKyAxKSAqIGVsZW1lbnRTaXplLCB5aSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpICsgMV1beWldKTsKICAgICAgICBjLnNldCh4aSAqIGVsZW1lbnRTaXplLCAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpXVt5aSArIDFdKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXQgYSB0cmlhbmdsZSBpbiB0aGUgdGVycmFpbiBpbiB0aGUgZm9ybSBvZiBhIHRyaWFuZ3VsYXIgY29udmV4IHNoYXBlLgogICAgICovCgoKICAgIGdldENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICBsZXQgcmVzdWx0ID0gdGhpcy5waWxsYXJDb252ZXg7CiAgICAgIGxldCBvZmZzZXRSZXN1bHQgPSB0aGlzLnBpbGxhck9mZnNldDsKCiAgICAgIGlmICh0aGlzLmNhY2hlRW5hYmxlZCkgewogICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSk7CgogICAgICAgIGlmIChkYXRhKSB7CiAgICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IGRhdGEuY29udmV4OwogICAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBkYXRhLm9mZnNldDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIHJlc3VsdCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAgICAgb2Zmc2V0UmVzdWx0ID0gbmV3IFZlYzMoKTsKICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IHJlc3VsdDsKICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IG9mZnNldFJlc3VsdDsKICAgICAgfQoKICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTsKICAgICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBmYWNlcyA9IHJlc3VsdC5mYWNlczsgLy8gUmV1c2UgdmVydHMgaWYgcG9zc2libGUKCiAgICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHsKICAgICAgICBpZiAoIXJlc3VsdC52ZXJ0aWNlc1tpXSkgewogICAgICAgICAgcmVzdWx0LnZlcnRpY2VzW2ldID0gbmV3IFZlYzMoKTsKICAgICAgICB9CiAgICAgIH0gLy8gUmV1c2UgZmFjZXMgaWYgcG9zc2libGUKCgogICAgICBmYWNlcy5sZW5ndGggPSA1OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHsKICAgICAgICBpZiAoIWZhY2VzW2ldKSB7CiAgICAgICAgICBmYWNlc1tpXSA9IFtdOwogICAgICAgIH0KICAgICAgfQoKICAgICAgY29uc3QgdmVydHMgPSByZXN1bHQudmVydGljZXM7CiAgICAgIGNvbnN0IGggPSAoTWF0aC5taW4oZGF0YVt4aV1beWldLCBkYXRhW3hpICsgMV1beWldLCBkYXRhW3hpXVt5aSArIDFdLCBkYXRhW3hpICsgMV1beWkgKyAxXSkgLSB0aGlzLm1pblZhbHVlKSAvIDIgKyB0aGlzLm1pblZhbHVlOwoKICAgICAgaWYgKCFnZXRVcHBlclRyaWFuZ2xlKSB7CiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lCiAgICAgICAgb2Zmc2V0UmVzdWx0LnNldCgoeGkgKyAwLjI1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlCiAgICAgICAgKHlpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSwgaCAvLyB2ZXJ0aWNhbCBjZW50ZXIKICAgICAgICApOyAvLyBUb3AgdHJpYW5nbGUgdmVydHMKCiAgICAgICAgdmVydHNbMF0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIC0wLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGldW3lpXSAtIGgpOwogICAgICAgIHZlcnRzWzFdLnNldCgwLjc1ICogZWxlbWVudFNpemUsIC0wLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aV0gLSBoKTsKICAgICAgICB2ZXJ0c1syXS5zZXQoLTAuMjUgKiBlbGVtZW50U2l6ZSwgMC43NSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpXVt5aSArIDFdIC0gaCk7IC8vIGJvdHRvbSB0cmlhbmdsZSB2ZXJ0cwoKICAgICAgICB2ZXJ0c1szXS5zZXQoLTAuMjUgKiBlbGVtZW50U2l6ZSwgLTAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNF0uc2V0KDAuNzUgKiBlbGVtZW50U2l6ZSwgLTAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNV0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIDAuNzUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7IC8vIHRvcCB0cmlhbmdsZQoKICAgICAgICBmYWNlc1swXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMF1bMV0gPSAxOwogICAgICAgIGZhY2VzWzBdWzJdID0gMjsgLy8gYm90dG9tIHRyaWFuZ2xlCgogICAgICAgIGZhY2VzWzFdWzBdID0gNTsKICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbMV1bMl0gPSAzOyAvLyAteCBmYWNpbmcgcXVhZAoKICAgICAgICBmYWNlc1syXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMl1bMV0gPSAyOwogICAgICAgIGZhY2VzWzJdWzJdID0gNTsKICAgICAgICBmYWNlc1syXVszXSA9IDM7IC8vIC15IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzNdWzBdID0gMTsKICAgICAgICBmYWNlc1szXVsxXSA9IDA7CiAgICAgICAgZmFjZXNbM11bMl0gPSAzOwogICAgICAgIGZhY2VzWzNdWzNdID0gNDsgLy8gK3h5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzRdWzBdID0gNDsKICAgICAgICBmYWNlc1s0XVsxXSA9IDU7CiAgICAgICAgZmFjZXNbNF1bMl0gPSAyOwogICAgICAgIGZhY2VzWzRdWzNdID0gMTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBDZW50ZXIgb2YgdGhlIHRyaWFuZ2xlIHBpbGxhciAtIGFsbCBwb2x5Z29ucyBhcmUgZ2l2ZW4gcmVsYXRpdmUgdG8gdGhpcyBvbmUKICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KCh4aSArIDAuNzUpICogZWxlbWVudFNpemUsIC8vIHNvcnQgb2YgY2VudGVyIG9mIGEgdHJpYW5nbGUKICAgICAgICAoeWkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCBoIC8vIHZlcnRpY2FsIGNlbnRlcgogICAgICAgICk7IC8vIFRvcCB0cmlhbmdsZSB2ZXJ0cwoKICAgICAgICB2ZXJ0c1swXS5zZXQoMC4yNSAqIGVsZW1lbnRTaXplLCAwLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aSArIDFdIC0gaCk7CiAgICAgICAgdmVydHNbMV0uc2V0KC0wLjc1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWkgKyAxXSAtIGgpOwogICAgICAgIHZlcnRzWzJdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIC0wLjc1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aV0gLSBoKTsgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzCgogICAgICAgIHZlcnRzWzNdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNF0uc2V0KC0wLjc1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNV0uc2V0KDAuMjUgKiBlbGVtZW50U2l6ZSwgLTAuNzUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7IC8vIFRvcCB0cmlhbmdsZQoKICAgICAgICBmYWNlc1swXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMF1bMV0gPSAxOwogICAgICAgIGZhY2VzWzBdWzJdID0gMjsgLy8gYm90dG9tIHRyaWFuZ2xlCgogICAgICAgIGZhY2VzWzFdWzBdID0gNTsKICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbMV1bMl0gPSAzOyAvLyAreCBmYWNpbmcgcXVhZAoKICAgICAgICBmYWNlc1syXVswXSA9IDI7CiAgICAgICAgZmFjZXNbMl1bMV0gPSA1OwogICAgICAgIGZhY2VzWzJdWzJdID0gMzsKICAgICAgICBmYWNlc1syXVszXSA9IDA7IC8vICt5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzNdWzBdID0gMzsKICAgICAgICBmYWNlc1szXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbM11bMl0gPSAxOwogICAgICAgIGZhY2VzWzNdWzNdID0gMDsgLy8gLXh5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzRdWzBdID0gMTsKICAgICAgICBmYWNlc1s0XVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbNF1bMl0gPSA1OwogICAgICAgIGZhY2VzWzRdWzNdID0gMjsKICAgICAgfQoKICAgICAgcmVzdWx0LmNvbXB1dGVOb3JtYWxzKCk7CiAgICAgIHJlc3VsdC5jb21wdXRlRWRnZXMoKTsKICAgICAgcmVzdWx0LnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICAgIHRoaXMuc2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCByZXN1bHQsIG9mZnNldFJlc3VsdCk7CiAgICB9CgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQuc2V0KDAsIDAsIDApOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuICgvLyBUaGUgdGVycmFpbiBpcyBpbmZpbml0ZQogICAgICAgIE51bWJlci5NQVhfVkFMVUUKICAgICAgKTsKICAgIH0KCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICAvKiogQFRPRE8gZG8gaXQgcHJvcGVybHkgKi8KICAgICAgbWluLnNldCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTsKICAgICAgbWF4LnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTsKICAgIH0KCiAgICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHsKICAgICAgLy8gVXNlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG1pbi9tYXggdmFsdWVzCiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IHMgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gbmV3IFZlYzMoZGF0YS5sZW5ndGggKiBzLCBkYXRhWzBdLmxlbmd0aCAqIHMsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLCBNYXRoLmFicyh0aGlzLm1pblZhbHVlKSkpLmxlbmd0aCgpOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgdmFsdWVzIGZyb20gYW4gaW1hZ2UuIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyLgogICAgICovCgoKICAgIHNldEhlaWdodHNGcm9tSW1hZ2UoaW1hZ2UsIHNjYWxlKSB7CiAgICAgIGNvbnN0IHsKICAgICAgICB4LAogICAgICAgIHosCiAgICAgICAgeQogICAgICB9ID0gc2NhbGU7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOwogICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDsKICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDsKICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7CiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpOwogICAgICBjb25zdCBtYXRyaXggPSB0aGlzLmRhdGE7CiAgICAgIG1hdHJpeC5sZW5ndGggPSAwOwogICAgICB0aGlzLmVsZW1lbnRTaXplID0gTWF0aC5hYnMoeCkgLyBpbWFnZURhdGEud2lkdGg7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlRGF0YS5oZWlnaHQ7IGkrKykgewogICAgICAgIGNvbnN0IHJvdyA9IFtdOwoKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGltYWdlRGF0YS53aWR0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCBhID0gaW1hZ2VEYXRhLmRhdGFbKGkgKiBpbWFnZURhdGEuaGVpZ2h0ICsgaikgKiA0XTsKICAgICAgICAgIGNvbnN0IGIgPSBpbWFnZURhdGEuZGF0YVsoaSAqIGltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAxXTsKICAgICAgICAgIGNvbnN0IGMgPSBpbWFnZURhdGEuZGF0YVsoaSAqIGltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAyXTsKICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChhICsgYiArIGMpIC8gNCAvIDI1NSAqIHo7CgogICAgICAgICAgaWYgKHggPCAwKSB7CiAgICAgICAgICAgIHJvdy5wdXNoKGhlaWdodCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByb3cudW5zaGlmdChoZWlnaHQpOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPCAwKSB7CiAgICAgICAgICBtYXRyaXgudW5zaGlmdChyb3cpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtYXRyaXgucHVzaChyb3cpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy51cGRhdGVNYXhWYWx1ZSgpOwogICAgICB0aGlzLnVwZGF0ZU1pblZhbHVlKCk7CiAgICAgIHRoaXMudXBkYXRlKCk7CiAgICB9CgogIH0KICBjb25zdCBnZXRIZWlnaHRBdF9pZHggPSBbXTsKICBjb25zdCBnZXRIZWlnaHRBdF93ZWlnaHRzID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9hID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9iID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9jID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9hID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9iID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9jID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9lMCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZ2V0Tm9ybWFsQXRfZTEgPSBuZXcgVmVjMygpOyAvLyBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JhcnljZW50cmljX2Nvb3JkaW5hdGVfc3lzdGVtCgogIGZ1bmN0aW9uIGJhcnljZW50cmljV2VpZ2h0cyh4LCB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCByZXN1bHQpIHsKICAgIHJlc3VsdC54ID0gKChieSAtIGN5KSAqICh4IC0gY3gpICsgKGN4IC0gYngpICogKHkgLSBjeSkpIC8gKChieSAtIGN5KSAqIChheCAtIGN4KSArIChjeCAtIGJ4KSAqIChheSAtIGN5KSk7CiAgICByZXN1bHQueSA9ICgoY3kgLSBheSkgKiAoeCAtIGN4KSArIChheCAtIGN4KSAqICh5IC0gY3kpKSAvICgoYnkgLSBjeSkgKiAoYXggLSBjeCkgKyAoY3ggLSBieCkgKiAoYXkgLSBjeSkpOwogICAgcmVzdWx0LnogPSAxIC0gcmVzdWx0LnggLSByZXN1bHQueTsKICB9CgogIC8qKgogICAqIE9jdHJlZU5vZGUKICAgKi8KICBjbGFzcyBPY3RyZWVOb2RlIHsKICAgIC8qKiBUaGUgcm9vdCBub2RlICovCgogICAgLyoqIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZSAqLwoKICAgIC8qKiBDb250YWluZWQgZGF0YSBhdCB0aGUgY3VycmVudCBub2RlIGxldmVsICovCgogICAgLyoqIENoaWxkcmVuIHRvIHRoaXMgbm9kZSAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDsKICAgICAgdGhpcy5hYWJiID0gb3B0aW9ucy5hYWJiID8gb3B0aW9ucy5hYWJiLmNsb25lKCkgOiBuZXcgQUFCQigpOwogICAgICB0aGlzLmRhdGEgPSBbXTsKICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdOwogICAgfQogICAgLyoqCiAgICAgKiByZXNldAogICAgICovCgoKICAgIHJlc2V0KCkgewogICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBJbnNlcnQgZGF0YSBpbnRvIHRoaXMgbm9kZQogICAgICogQHJldHVybiBUcnVlIGlmIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZQogICAgICovCgoKICAgIGluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwpIHsKICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsKICAgICAgICBsZXZlbCA9IDA7CiAgICAgIH0KCiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5kYXRhOyAvLyBJZ25vcmUgb2JqZWN0cyB0aGF0IGRvIG5vdCBiZWxvbmcgaW4gdGhpcyBub2RlCgogICAgICBpZiAoIXRoaXMuYWFiYi5jb250YWlucyhhYWJiKSkgewogICAgICAgIHJldHVybiBmYWxzZTsgLy8gb2JqZWN0IGNhbm5vdCBiZSBhZGRlZAogICAgICB9CgogICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47CiAgICAgIGNvbnN0IG1heERlcHRoID0gdGhpcy5tYXhEZXB0aCB8fCB0aGlzLnJvb3QubWF4RGVwdGg7CgogICAgICBpZiAobGV2ZWwgPCBtYXhEZXB0aCkgewogICAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0CiAgICAgICAgbGV0IHN1YmRpdmlkZWQgPSBmYWxzZTsKCiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKCk7CiAgICAgICAgICBzdWJkaXZpZGVkID0gdHJ1ZTsKICAgICAgICB9IC8vIGFkZCB0byB3aGljaGV2ZXIgbm9kZSB3aWxsIGFjY2VwdCBpdAoKCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwgKyAxKSkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChzdWJkaXZpZGVkKSB7CiAgICAgICAgICAvLyBObyBjaGlsZHJlbiBhY2NlcHRlZCEgTWlnaHQgYXMgd2VsbCBqdXN0IHJlbW92ZSBlbSBzaW5jZSB0aGV5IGNvbnRhaW4gbm9uZQogICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgIH0gLy8gVG9vIGRlZXAsIG9yIGNoaWxkcmVuIGRpZG50IHdhbnQgaXQuIGFkZCBpdCBpbiBjdXJyZW50IG5vZGUKCgogICAgICBub2RlRGF0YS5wdXNoKGVsZW1lbnREYXRhKTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZSA4IGVxdWFsbHkgc2l6ZWQgY2hpbGRyZW4gbm9kZXMgYW5kIHB1dCB0aGVtIGluIHRoZSBgY2hpbGRyZW5gIGFycmF5LgogICAgICovCgoKICAgIHN1YmRpdmlkZSgpIHsKICAgICAgY29uc3QgYWFiYiA9IHRoaXMuYWFiYjsKICAgICAgY29uc3QgbCA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IGFhYmIudXBwZXJCb3VuZDsKICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuOwogICAgICBjaGlsZHJlbi5wdXNoKG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygwLCAwLCAwKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMSwgMCwgMCkKICAgICAgICB9KQogICAgICB9KSwgbmV3IE9jdHJlZU5vZGUoewogICAgICAgIGFhYmI6IG5ldyBBQUJCKHsKICAgICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsIDEsIDApCiAgICAgICAgfSkKICAgICAgfSksIG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygxLCAxLCAxKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwgMSwgMSkKICAgICAgICB9KQogICAgICB9KSwgbmV3IE9jdHJlZU5vZGUoewogICAgICAgIGFhYmI6IG5ldyBBQUJCKHsKICAgICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsIDAsIDEpCiAgICAgICAgfSkKICAgICAgfSksIG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygxLCAwLCAxKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwgMSwgMCkKICAgICAgICB9KQogICAgICB9KSk7CiAgICAgIHUudnN1YihsLCBoYWxmRGlhZ29uYWwpOwogICAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpOwogICAgICBjb25zdCByb290ID0gdGhpcy5yb290IHx8IHRoaXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gODsgaSsrKSB7CiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gU2V0IGN1cnJlbnQgbm9kZSBhcyByb290CgogICAgICAgIGNoaWxkLnJvb3QgPSByb290OyAvLyBDb21wdXRlIGJvdW5kcwoKICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gY2hpbGQuYWFiYi5sb3dlckJvdW5kOwogICAgICAgIGxvd2VyQm91bmQueCAqPSBoYWxmRGlhZ29uYWwueDsKICAgICAgICBsb3dlckJvdW5kLnkgKj0gaGFsZkRpYWdvbmFsLnk7CiAgICAgICAgbG93ZXJCb3VuZC56ICo9IGhhbGZEaWFnb25hbC56OwogICAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTsgLy8gVXBwZXIgYm91bmQgaXMgYWx3YXlzIGxvd2VyIGJvdW5kICsgaGFsZkRpYWdvbmFsCgogICAgICAgIGxvd2VyQm91bmQudmFkZChoYWxmRGlhZ29uYWwsIGNoaWxkLmFhYmIudXBwZXJCb3VuZCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSB3aXRoaW4gYW4gQUFCQgogICAgICogQHJldHVybiBUaGUgInJlc3VsdCIgb2JqZWN0CiAgICAgKi8KCgogICAgYWFiYlF1ZXJ5KGFhYmIsIHJlc3VsdCkgewogICAgICB0aGlzLmRhdGE7IC8vIGFib3J0IGlmIHRoZSByYW5nZSBkb2VzIG5vdCBpbnRlcnNlY3QgdGhpcyBub2RlCiAgICAgIC8vIGlmICghdGhpcy5hYWJiLm92ZXJsYXBzKGFhYmIpKXsKICAgICAgLy8gICAgIHJldHVybiByZXN1bHQ7CiAgICAgIC8vIH0KICAgICAgLy8gQWRkIG9iamVjdHMgYXQgdGhpcyBsZXZlbAogICAgICAvLyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGVEYXRhKTsKICAgICAgLy8gQWRkIGNoaWxkIGRhdGEKICAgICAgLy8gQHRvZG8gdW53cmFwIHJlY3Vyc2lvbiBpbnRvIGEgcXVldWUgLyBsb29wLCB0aGF0J3MgZmFzdGVyIGluIEpTCgogICAgICB0aGlzLmNoaWxkcmVuOyAvLyBmb3IgKGxldCBpID0gMCwgTiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICE9PSBOOyBpKyspIHsKICAgICAgLy8gICAgIGNoaWxkcmVuW2ldLmFhYmJRdWVyeShhYWJiLCByZXN1bHQpOwogICAgICAvLyB9CgogICAgICBjb25zdCBxdWV1ZSA9IFt0aGlzXTsKCiAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHsKICAgICAgICBjb25zdCBub2RlID0gcXVldWUucG9wKCk7CgogICAgICAgIGlmIChub2RlLmFhYmIub3ZlcmxhcHMoYWFiYikpIHsKICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5kYXRhKTsKICAgICAgICB9CgogICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHF1ZXVlLCBub2RlLmNoaWxkcmVuKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSBpbnRlcnNlY3RlZCBieSBhIHJheS4KICAgICAqIEByZXR1cm4gVGhlICJyZXN1bHQiIG9iamVjdAogICAgICovCgoKICAgIHJheVF1ZXJ5KHJheSwgdHJlZVRyYW5zZm9ybSwgcmVzdWx0KSB7CiAgICAgIC8vIFVzZSBhYWJiIHF1ZXJ5IGZvciBub3cuCgogICAgICAvKiogQHRvZG8gaW1wbGVtZW50IHJlYWwgcmF5IHF1ZXJ5IHdoaWNoIG5lZWRzIGxlc3MgbG9va3VwcyAqLwogICAgICByYXkuZ2V0QUFCQih0bXBBQUJCKTsKICAgICAgdG1wQUFCQi50b0xvY2FsRnJhbWUodHJlZVRyYW5zZm9ybSwgdG1wQUFCQik7CiAgICAgIHRoaXMuYWFiYlF1ZXJ5KHRtcEFBQkIsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHJlbW92ZUVtcHR5Tm9kZXMKICAgICAqLwoKCiAgICByZW1vdmVFbXB0eU5vZGVzKCkgewogICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVtb3ZlRW1wdHlOb2RlcygpOwoKICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW5baV0uY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLmNoaWxkcmVuW2ldLmRhdGEubGVuZ3RoKSB7CiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpLCAxKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgfQogIC8qKgogICAqIE9jdHJlZQogICAqLwoKCiAgY2xhc3MgT2N0cmVlIGV4dGVuZHMgT2N0cmVlTm9kZSB7CiAgICAvKioKICAgICAqIE1heGltdW0gc3ViZGl2aXNpb24gZGVwdGgKICAgICAqIEBkZWZhdWx0IDgKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGFhYmIgVGhlIHRvdGFsIEFBQkIgb2YgdGhlIHRyZWUKICAgICAqLwogICAgY29uc3RydWN0b3IoYWFiYiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBzdXBlcih7CiAgICAgICAgcm9vdDogbnVsbCwKICAgICAgICBhYWJiCiAgICAgIH0pOwogICAgICB0aGlzLm1heERlcHRoID0gdHlwZW9mIG9wdGlvbnMubWF4RGVwdGggIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhEZXB0aCA6IDg7CiAgICB9CgogIH0KICBjb25zdCBoYWxmRGlhZ29uYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcEFBQkIgPSBuZXcgQUFCQigpOwoKICAvKioKICAgKiBUcmltZXNoLgogICAqIEBleGFtcGxlCiAgICogICAgIC8vIEhvdyB0byBtYWtlIGEgbWVzaCB3aXRoIGEgc2luZ2xlIHRyaWFuZ2xlCiAgICogICAgIGNvbnN0IHZlcnRpY2VzID0gWwogICAqICAgICAgICAgMCwgMCwgMCwgLy8gdmVydGV4IDAKICAgKiAgICAgICAgIDEsIDAsIDAsIC8vIHZlcnRleCAxCiAgICogICAgICAgICAwLCAxLCAwICAvLyB2ZXJ0ZXggMgogICAqICAgICBdCiAgICogICAgIGNvbnN0IGluZGljZXMgPSBbCiAgICogICAgICAgICAwLCAxLCAyICAvLyB0cmlhbmdsZSAwCiAgICogICAgIF0KICAgKiAgICAgY29uc3QgdHJpbWVzaFNoYXBlID0gbmV3IENBTk5PTi5UcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKQogICAqLwogIGNsYXNzIFRyaW1lc2ggZXh0ZW5kcyBTaGFwZSB7CiAgICAvKioKICAgICAqIHZlcnRpY2VzCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFycmF5IG9mIGludGVnZXJzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggdHJpYW5nbGUgY29uc2lzdHMgb2YuIFRoZSBsZW5ndGggb2YgdGhpcyBhcnJheSBpcyB0aHVzIDMgdGltZXMgdGhlIG51bWJlciBvZiB0cmlhbmdsZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBub3JtYWxzIGRhdGEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBsb2NhbCBBQUJCIG9mIHRoZSBtZXNoLgogICAgICovCgogICAgLyoqCiAgICAgKiBSZWZlcmVuY2VzIHRvIHZlcnRleCBwYWlycywgbWFraW5nIHVwIGFsbCB1bmlxdWUgZWRnZXMgaW4gdGhlIHRyaW1lc2guCiAgICAgKi8KCiAgICAvKioKICAgICAqIExvY2FsIHNjYWxpbmcgb2YgdGhlIG1lc2guIFVzZSAuc2V0U2NhbGUoKSB0byBzZXQgaXQuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBpbmRleGVkIHRyaWFuZ2xlcy4gVXNlIC51cGRhdGVUcmVlKCkgdG8gdXBkYXRlIGl0LgogICAgICovCiAgICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgaW5kaWNlcykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuVFJJTUVTSAogICAgICB9KTsKICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpOwogICAgICB0aGlzLmluZGljZXMgPSBuZXcgSW50MTZBcnJheShpbmRpY2VzKTsKICAgICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7CiAgICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7CiAgICAgIHRoaXMuZWRnZXMgPSBudWxsOwogICAgICB0aGlzLnNjYWxlID0gbmV3IFZlYzMoMSwgMSwgMSk7CiAgICAgIHRoaXMudHJlZSA9IG5ldyBPY3RyZWUoKTsKICAgICAgdGhpcy51cGRhdGVFZGdlcygpOwogICAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTsKICAgICAgdGhpcy51cGRhdGVBQUJCKCk7CiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTsKICAgICAgdGhpcy51cGRhdGVUcmVlKCk7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZVRyZWUKICAgICAqLwoKCiAgICB1cGRhdGVUcmVlKCkgewogICAgICBjb25zdCB0cmVlID0gdGhpcy50cmVlOwogICAgICB0cmVlLnJlc2V0KCk7CiAgICAgIHRyZWUuYWFiYi5jb3B5KHRoaXMuYWFiYik7CiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTsgLy8gVGhlIGxvY2FsIG1lc2ggQUFCQiBpcyBzY2FsZWQsIGJ1dCB0aGUgb2N0cmVlIEFBQkIgc2hvdWxkIGJlIHVuc2NhbGVkCgogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54OwogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55OwogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC56ICo9IDEgLyBzY2FsZS56OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC56ICo9IDEgLyBzY2FsZS56OyAvLyBJbnNlcnQgYWxsIHRyaWFuZ2xlcwoKICAgICAgY29uc3QgdHJpYW5nbGVBQUJCID0gbmV3IEFBQkIoKTsKICAgICAgY29uc3QgYSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGIgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBjID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcG9pbnRzID0gW2EsIGIsIGNdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgLy90aGlzLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgYSwgYiwgYyk7CiAgICAgICAgLy8gR2V0IHVuc2NhbGVkIHRyaWFuZ2xlIHZlcnRzCiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKCiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7CgogICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTsKCiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpOwoKICAgICAgICB0cmlhbmdsZUFBQkIuc2V0RnJvbVBvaW50cyhwb2ludHMpOwogICAgICAgIHRyZWUuaW5zZXJ0KHRyaWFuZ2xlQUFCQiwgaSk7CiAgICAgIH0KCiAgICAgIHRyZWUucmVtb3ZlRW1wdHlOb2RlcygpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdHJpYW5nbGVzIGluIGEgbG9jYWwgQUFCQiBmcm9tIHRoZSB0cmltZXNoLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSBvZiBpbnRlZ2VycywgcmVmZXJlbmNpbmcgdGhlIHF1ZXJpZWQgdHJpYW5nbGVzLgogICAgICovCgoKICAgIGdldFRyaWFuZ2xlc0luQUFCQihhYWJiLCByZXN1bHQpIHsKICAgICAgdW5zY2FsZWRBQUJCLmNvcHkoYWFiYik7IC8vIFNjYWxlIGl0IHRvIGxvY2FsCgogICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7CiAgICAgIGNvbnN0IGlzeCA9IHNjYWxlLng7CiAgICAgIGNvbnN0IGlzeSA9IHNjYWxlLnk7CiAgICAgIGNvbnN0IGlzeiA9IHNjYWxlLno7CiAgICAgIGNvbnN0IGwgPSB1bnNjYWxlZEFBQkIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IHVuc2NhbGVkQUFCQi51cHBlckJvdW5kOwogICAgICBsLnggLz0gaXN4OwogICAgICBsLnkgLz0gaXN5OwogICAgICBsLnogLz0gaXN6OwogICAgICB1LnggLz0gaXN4OwogICAgICB1LnkgLz0gaXN5OwogICAgICB1LnogLz0gaXN6OwogICAgICByZXR1cm4gdGhpcy50cmVlLmFhYmJRdWVyeSh1bnNjYWxlZEFBQkIsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIHNldFNjYWxlCiAgICAgKi8KCgogICAgc2V0U2NhbGUoc2NhbGUpIHsKICAgICAgY29uc3Qgd2FzVW5pZm9ybSA9IHRoaXMuc2NhbGUueCA9PT0gdGhpcy5zY2FsZS55ICYmIHRoaXMuc2NhbGUueSA9PT0gdGhpcy5zY2FsZS56OwogICAgICBjb25zdCBpc1VuaWZvcm0gPSBzY2FsZS54ID09PSBzY2FsZS55ICYmIHNjYWxlLnkgPT09IHNjYWxlLno7CgogICAgICBpZiAoISh3YXNVbmlmb3JtICYmIGlzVW5pZm9ybSkpIHsKICAgICAgICAvLyBOb24tdW5pZm9ybSBzY2FsaW5nLiBOZWVkIHRvIHVwZGF0ZSBub3JtYWxzLgogICAgICAgIHRoaXMudXBkYXRlTm9ybWFscygpOwogICAgICB9CgogICAgICB0aGlzLnNjYWxlLmNvcHkoc2NhbGUpOwogICAgICB0aGlzLnVwZGF0ZUFBQkIoKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlIHRoZSBub3JtYWxzIG9mIHRoZSBmYWNlcy4gV2lsbCBzYXZlIGluIHRoZSBgLm5vcm1hbHNgIGFycmF5LgogICAgICovCgoKICAgIHVwZGF0ZU5vcm1hbHMoKSB7CiAgICAgIGNvbnN0IG4gPSBjb21wdXRlTm9ybWFsc19uOyAvLyBHZW5lcmF0ZSBub3JtYWxzCgogICAgICBjb25zdCBub3JtYWxzID0gdGhpcy5ub3JtYWxzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKICAgICAgICBjb25zdCBhID0gdGhpcy5pbmRpY2VzW2kzXTsKICAgICAgICBjb25zdCBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV07CiAgICAgICAgY29uc3QgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdOwogICAgICAgIHRoaXMuZ2V0VmVydGV4KGEsIHZhKTsKICAgICAgICB0aGlzLmdldFZlcnRleChiLCB2Yik7CiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYywgdmMpOwogICAgICAgIFRyaW1lc2guY29tcHV0ZU5vcm1hbCh2YiwgdmEsIHZjLCBuKTsKICAgICAgICBub3JtYWxzW2kzXSA9IG4ueDsKICAgICAgICBub3JtYWxzW2kzICsgMV0gPSBuLnk7CiAgICAgICAgbm9ybWFsc1tpMyArIDJdID0gbi56OwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFVwZGF0ZSB0aGUgYC5lZGdlc2AgcHJvcGVydHkKICAgICAqLwoKCiAgICB1cGRhdGVFZGdlcygpIHsKICAgICAgY29uc3QgZWRnZXMgPSB7fTsKCiAgICAgIGNvbnN0IGFkZCA9IChhLCBiKSA9PiB7CiAgICAgICAgY29uc3Qga2V5ID0gYSA8IGIgPyBgJHthfV8ke2J9YCA6IGAke2J9XyR7YX1gOwogICAgICAgIGVkZ2VzW2tleV0gPSB0cnVlOwogICAgICB9OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKICAgICAgICBjb25zdCBhID0gdGhpcy5pbmRpY2VzW2kzXTsKICAgICAgICBjb25zdCBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV07CiAgICAgICAgY29uc3QgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdOwogICAgICAgIGFkZChhLCBiKTsKICAgICAgICBhZGQoYiwgYyk7CiAgICAgICAgYWRkKGMsIGEpOwogICAgICB9CgogICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZWRnZXMpOwogICAgICB0aGlzLmVkZ2VzID0gbmV3IEludDE2QXJyYXkoa2V5cy5sZW5ndGggKiAyKTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGluZGljZXMgPSBrZXlzW2ldLnNwbGl0KCdfJyk7CiAgICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7CiAgICAgICAgdGhpcy5lZGdlc1syICogaSArIDFdID0gcGFyc2VJbnQoaW5kaWNlc1sxXSwgMTApOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBlZGdlIHZlcnRleAogICAgICogQHBhcmFtIGZpcnN0T3JTZWNvbmQgMCBvciAxLCBkZXBlbmRpbmcgb24gd2hpY2ggb25lIG9mIHRoZSB2ZXJ0aWNlcyB5b3UgbmVlZC4KICAgICAqIEBwYXJhbSB2ZXJ0ZXhTdG9yZSBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0CiAgICAgKi8KCgogICAgZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKSB7CiAgICAgIGNvbnN0IHZlcnRleEluZGV4ID0gdGhpcy5lZGdlc1tlZGdlSW5kZXggKiAyICsgKGZpcnN0T3JTZWNvbmQgPyAxIDogMCldOwogICAgICB0aGlzLmdldFZlcnRleCh2ZXJ0ZXhJbmRleCwgdmVydGV4U3RvcmUpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS4KICAgICAqLwoKCiAgICBnZXRFZGdlVmVjdG9yKGVkZ2VJbmRleCwgdmVjdG9yU3RvcmUpIHsKICAgICAgY29uc3QgdmEgPSBnZXRFZGdlVmVjdG9yX3ZhOwogICAgICBjb25zdCB2YiA9IGdldEVkZ2VWZWN0b3JfdmI7CiAgICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDAsIHZhKTsKICAgICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMSwgdmIpOwogICAgICB2Yi52c3ViKHZhLCB2ZWN0b3JTdG9yZSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzCiAgICAgKi8KCgogICAgc3RhdGljIGNvbXB1dGVOb3JtYWwodmEsIHZiLCB2YywgdGFyZ2V0KSB7CiAgICAgIHZiLnZzdWIodmEsIGFiKTsKICAgICAgdmMudnN1Yih2YiwgY2IpOwogICAgICBjYi5jcm9zcyhhYiwgdGFyZ2V0KTsKCiAgICAgIGlmICghdGFyZ2V0LmlzWmVybygpKSB7CiAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCB2ZXJ0ZXggaS4KICAgICAqIEByZXR1cm4gVGhlICJvdXQiIHZlY3RvciBvYmplY3QKICAgICAqLwoKCiAgICBnZXRWZXJ0ZXgoaSwgb3V0KSB7CiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTsKCiAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCk7CgogICAgICBvdXQueCAqPSBzY2FsZS54OwogICAgICBvdXQueSAqPSBzY2FsZS55OwogICAgICBvdXQueiAqPSBzY2FsZS56OwogICAgICByZXR1cm4gb3V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgcmF3IHZlcnRleCBpCiAgICAgKiBAcmV0dXJuIFRoZSAib3V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCkgewogICAgICBjb25zdCBpMyA9IGkgKiAzOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIHJldHVybiBvdXQuc2V0KHZlcnRpY2VzW2kzXSwgdmVydGljZXNbaTMgKyAxXSwgdmVydGljZXNbaTMgKyAyXSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIHZlcnRleCBmcm9tIHRoZSB0cmltZXNoLHRyYW5zZm9ybWVkIGJ5IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgcXVhdGVybmlvbi4KICAgICAqIEByZXR1cm4gVGhlICJvdXQiIHZlY3RvciBvYmplY3QKICAgICAqLwoKCiAgICBnZXRXb3JsZFZlcnRleChpLCBwb3MsIHF1YXQsIG91dCkgewogICAgICB0aGlzLmdldFZlcnRleChpLCBvdXQpOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zLCBxdWF0LCBvdXQsIG91dCk7CiAgICAgIHJldHVybiBvdXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgdGhyZWUgdmVydGljZXMgZm9yIHRyaWFuZ2xlIGkuCiAgICAgKi8KCgogICAgZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCBhLCBiLCBjKSB7CiAgICAgIGNvbnN0IGkzID0gaSAqIDM7CiAgICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpM10sIGEpOwogICAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAxXSwgYik7CiAgICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDJdLCBjKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuCiAgICAgKiBAcmV0dXJuIFRoZSAidGFyZ2V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgZ2V0Tm9ybWFsKGksIHRhcmdldCkgewogICAgICBjb25zdCBpMyA9IGkgKiAzOwogICAgICByZXR1cm4gdGFyZ2V0LnNldCh0aGlzLm5vcm1hbHNbaTNdLCB0aGlzLm5vcm1hbHNbaTMgKyAxXSwgdGhpcy5ub3JtYWxzW2kzICsgMl0pOwogICAgfQogICAgLyoqCiAgICAgKiBAcmV0dXJuIFRoZSAidGFyZ2V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhCiAgICAgIC8vIEV4YWN0IGluZXJ0aWEgY2FsY3VsYXRpb24gaXMgb3ZlcmtpbGwsIGJ1dCBzZWUgaHR0cDovL2dlb21ldHJpY3Rvb2xzLmNvbS9Eb2N1bWVudGF0aW9uL1BvbHloZWRyYWxNYXNzUHJvcGVydGllcy5wZGYgZm9yIHRoZSBjb3JyZWN0IHdheSB0byBkbyBpdAogICAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmIpOwogICAgICBjb25zdCB4ID0gY2xpX2FhYmIudXBwZXJCb3VuZC54IC0gY2xpX2FhYmIubG93ZXJCb3VuZC54OwogICAgICBjb25zdCB5ID0gY2xpX2FhYmIudXBwZXJCb3VuZC55IC0gY2xpX2FhYmIubG93ZXJCb3VuZC55OwogICAgICBjb25zdCB6ID0gY2xpX2FhYmIudXBwZXJCb3VuZC56IC0gY2xpX2FhYmIubG93ZXJCb3VuZC56OwogICAgICByZXR1cm4gdGFyZ2V0LnNldCgxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHogKiAyICogeiksIDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB4ICogMiAqIHggKyAyICogeiAqIDIgKiB6KSwgMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIHkgKiAyICogeSArIDIgKiB4ICogMiAqIHgpKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbG9jYWwgQUFCQiBmb3IgdGhlIHRyaW1lc2gKICAgICAqLwoKCiAgICBjb21wdXRlTG9jYWxBQUJCKGFhYmIpIHsKICAgICAgY29uc3QgbCA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IGFhYmIudXBwZXJCb3VuZDsKICAgICAgY29uc3QgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoOwogICAgICB0aGlzLnZlcnRpY2VzOwogICAgICBjb25zdCB2ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7CiAgICAgIHRoaXMuZ2V0VmVydGV4KDAsIHYpOwogICAgICBsLmNvcHkodik7CiAgICAgIHUuY29weSh2KTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBuOyBpKyspIHsKICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKCiAgICAgICAgaWYgKHYueCA8IGwueCkgewogICAgICAgICAgbC54ID0gdi54OwogICAgICAgIH0gZWxzZSBpZiAodi54ID4gdS54KSB7CiAgICAgICAgICB1LnggPSB2Lng7CiAgICAgICAgfQoKICAgICAgICBpZiAodi55IDwgbC55KSB7CiAgICAgICAgICBsLnkgPSB2Lnk7CiAgICAgICAgfSBlbHNlIGlmICh2LnkgPiB1LnkpIHsKICAgICAgICAgIHUueSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmICh2LnogPCBsLnopIHsKICAgICAgICAgIGwueiA9IHYuejsKICAgICAgICB9IGVsc2UgaWYgKHYueiA+IHUueikgewogICAgICAgICAgdS56ID0gdi56OwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIGAuYWFiYmAgcHJvcGVydHkKICAgICAqLwoKCiAgICB1cGRhdGVBQUJCKCkgewogICAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIodGhpcy5hYWJiKTsKICAgIH0KICAgIC8qKgogICAgICogV2lsbCB1cGRhdGUgdGhlIGAuYm91bmRpbmdTcGhlcmVSYWRpdXNgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXIKICAgICAgbGV0IG1heDIgPSAwOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjMygpOwoKICAgICAgZm9yIChsZXQgaSA9IDAsIE4gPSB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICE9PSBOOyBpKyspIHsKICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKICAgICAgICBjb25zdCBub3JtMiA9IHYubGVuZ3RoU3F1YXJlZCgpOwoKICAgICAgICBpZiAobm9ybTIgPiBtYXgyKSB7CiAgICAgICAgICBtYXgyID0gbm9ybTI7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTWF0aC5zcXJ0KG1heDIpOwogICAgfQogICAgLyoqCiAgICAgKiBjYWxjdWxhdGVXb3JsZEFBQkIKICAgICAqLwoKCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICAvKgogICAgICAgICAgY29uc3QgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC8gMywKICAgICAgICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7CiAgICAgICAgICBjb25zdCBtaW54LG1pbnksbWlueixtYXh4LG1heHksbWF4ejsKICAgICAgICAgICBjb25zdCB2ID0gdGVtcFdvcmxkVmVydGV4OwogICAgICAgICAgZm9yKGxldCBpPTA7IGk8bjsgaSsrKXsKICAgICAgICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKICAgICAgICAgICAgICBxdWF0LnZtdWx0KHYsIHYpOwogICAgICAgICAgICAgIHBvcy52YWRkKHYsIHYpOwogICAgICAgICAgICAgIGlmICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpewogICAgICAgICAgICAgICAgICBtaW54ID0gdi54OwogICAgICAgICAgICAgIH0gZWxzZSBpZih2LnggPiBtYXh4IHx8IG1heHg9PT11bmRlZmluZWQpewogICAgICAgICAgICAgICAgICBtYXh4ID0gdi54OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgaWYgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7CiAgICAgICAgICAgICAgICAgIG1pbnkgPSB2Lnk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmKHYueSA+IG1heHkgfHwgbWF4eT09PXVuZGVmaW5lZCl7CiAgICAgICAgICAgICAgICAgIG1heHkgPSB2Lnk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICBpZiAodi56IDwgbWlueiB8fCBtaW56PT09dW5kZWZpbmVkKXsKICAgICAgICAgICAgICAgICAgbWlueiA9IHYuejsKICAgICAgICAgICAgICB9IGVsc2UgaWYodi56ID4gbWF4eiB8fCBtYXh6PT09dW5kZWZpbmVkKXsKICAgICAgICAgICAgICAgICAgbWF4eiA9IHYuejsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTsKICAgICAgICAgIG1heC5zZXQobWF4eCxtYXh5LG1heHopOwogICAgICAgICAgKi8KICAgICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQgogICAgICBjb25zdCBmcmFtZSA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZTsKICAgICAgY29uc3QgcmVzdWx0ID0gY2FsY3VsYXRlV29ybGRBQUJCX2FhYmI7CiAgICAgIGZyYW1lLnBvc2l0aW9uID0gcG9zOwogICAgICBmcmFtZS5xdWF0ZXJuaW9uID0gcXVhdDsKICAgICAgdGhpcy5hYWJiLnRvV29ybGRGcmFtZShmcmFtZSwgcmVzdWx0KTsKICAgICAgbWluLmNvcHkocmVzdWx0Lmxvd2VyQm91bmQpOwogICAgICBtYXguY29weShyZXN1bHQudXBwZXJCb3VuZCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhcHByb3hpbWF0ZSB2b2x1bWUKICAgICAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlIGEgVHJpbWVzaCBpbnN0YW5jZSwgc2hhcGVkIGFzIGEgdG9ydXMuCiAgICAgKi8KCgogICAgc3RhdGljIGNyZWF0ZVRvcnVzKHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjKSB7CiAgICAgIGlmIChyYWRpdXMgPT09IHZvaWQgMCkgewogICAgICAgIHJhZGl1cyA9IDE7CiAgICAgIH0KCiAgICAgIGlmICh0dWJlID09PSB2b2lkIDApIHsKICAgICAgICB0dWJlID0gMC41OwogICAgICB9CgogICAgICBpZiAocmFkaWFsU2VnbWVudHMgPT09IHZvaWQgMCkgewogICAgICAgIHJhZGlhbFNlZ21lbnRzID0gODsKICAgICAgfQoKICAgICAgaWYgKHR1YnVsYXJTZWdtZW50cyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdHVidWxhclNlZ21lbnRzID0gNjsKICAgICAgfQoKICAgICAgaWYgKGFyYyA9PT0gdm9pZCAwKSB7CiAgICAgICAgYXJjID0gTWF0aC5QSSAqIDI7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKykgewogICAgICAgICAgY29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7CiAgICAgICAgICBjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7CiAgICAgICAgICBjb25zdCB4ID0gKHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyh2KSkgKiBNYXRoLmNvcyh1KTsKICAgICAgICAgIGNvbnN0IHkgPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguc2luKHUpOwogICAgICAgICAgY29uc3QgeiA9IHR1YmUgKiBNYXRoLnNpbih2KTsKICAgICAgICAgIHZlcnRpY2VzLnB1c2goeCwgeSwgeik7CiAgICAgICAgfQogICAgICB9CgogICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHsKICAgICAgICAgIGNvbnN0IGEgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaSAtIDE7CiAgICAgICAgICBjb25zdCBiID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogKGogLSAxKSArIGkgLSAxOwogICAgICAgICAgY29uc3QgYyA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpOwogICAgICAgICAgY29uc3QgZCA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIGogKyBpOwogICAgICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGQpOwogICAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKTsKICAgIH0KCiAgfQogIGNvbnN0IGNvbXB1dGVOb3JtYWxzX24gPSBuZXcgVmVjMygpOwogIGNvbnN0IHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7CiAgY29uc3QgZ2V0RWRnZVZlY3Rvcl92YSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZ2V0RWRnZVZlY3Rvcl92YiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY2IgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFiID0gbmV3IFZlYzMoKTsKICBjb25zdCB2YSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdmIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHZjID0gbmV3IFZlYzMoKTsKICBjb25zdCBjbGlfYWFiYiA9IG5ldyBBQUJCKCk7CiAgY29uc3QgY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZSA9IG5ldyBUcmFuc2Zvcm0oKTsKICBjb25zdCBjYWxjdWxhdGVXb3JsZEFBQkJfYWFiYiA9IG5ldyBBQUJCKCk7CgogIC8qKgogICAqIENvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyIGJhc2UgY2xhc3MuCiAgICovCiAgY2xhc3MgU29sdmVyIHsKICAgIC8qKgogICAgICogQWxsIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWQKICAgICAqLwoKICAgIC8qKgogICAgICogQHRvZG8gcmVtb3ZlIHVzZWxlc3MgY29uc3RydWN0b3IKICAgICAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMuZXF1YXRpb25zID0gW107CiAgICB9CiAgICAvKioKICAgICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzIQogICAgICogQHRvZG8gdXNlIGFic3RyYWN0CiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBpdGVyYXRpb25zIHBlcmZvcm1lZAogICAgICovCgoKICAgIHNvbHZlKGR0LCB3b3JsZCkgewogICAgICByZXR1cm4gKC8vIFNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGRvbmUhCiAgICAgICAgMAogICAgICApOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYW4gZXF1YXRpb24KICAgICAqLwoKCiAgICBhZGRFcXVhdGlvbihlcSkgewogICAgICBpZiAoZXEuZW5hYmxlZCAmJiAhZXEuYmkuaXNUcmlnZ2VyICYmICFlcS5iai5pc1RyaWdnZXIpIHsKICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmUgYW4gZXF1YXRpb24KICAgICAqLwoKCiAgICByZW1vdmVFcXVhdGlvbihlcSkgewogICAgICBjb25zdCBlcXMgPSB0aGlzLmVxdWF0aW9uczsKICAgICAgY29uc3QgaSA9IGVxcy5pbmRleE9mKGVxKTsKCiAgICAgIGlmIChpICE9PSAtMSkgewogICAgICAgIGVxcy5zcGxpY2UoaSwgMSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQWRkIGFsbCBlcXVhdGlvbnMKICAgICAqLwoKCiAgICByZW1vdmVBbGxFcXVhdGlvbnMoKSB7CiAgICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQ29uc3RyYWludCBlcXVhdGlvbiBHYXVzcy1TZWlkZWwgc29sdmVyLgogICAqIEB0b2RvIFRoZSBzcG9vayBwYXJhbWV0ZXJzIHNob3VsZCBiZSBzcGVjaWZpZWQgZm9yIGVhY2ggY29uc3RyYWludCwgbm90IGdsb2JhbGx5LgogICAqIEBzZWUgaHR0cHM6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGYKICAgKi8KICBjbGFzcyBHU1NvbHZlciBleHRlbmRzIFNvbHZlciB7CiAgICAvKioKICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuCiAgICAgKiBUaGUgbW9yZSBpdGVyYXRpb25zLCB0aGUgbW9yZSBjb3JyZWN0IHNpbXVsYXRpb24uIE1vcmUgaXRlcmF0aW9ucyBuZWVkIG1vcmUgY29tcHV0YXRpb25zIHRob3VnaC4gSWYgeW91IGhhdmUgYSBsYXJnZSBncmF2aXR5IGZvcmNlIGluIHlvdXIgd29ybGQsIHlvdSB3aWxsIG5lZWQgbW9yZSBpdGVyYXRpb25zLgogICAgICovCgogICAgLyoqCiAgICAgKiBXaGVuIHRvbGVyYW5jZSBpcyByZWFjaGVkLCB0aGUgc3lzdGVtIGlzIGFzc3VtZWQgdG8gYmUgY29udmVyZ2VkLgogICAgICovCgogICAgLyoqCiAgICAgKiBAdG9kbyByZW1vdmUgdXNlbGVzcyBjb25zdHJ1Y3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pdGVyYXRpb25zID0gMTA7CiAgICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNzsKICAgIH0KICAgIC8qKgogICAgICogU29sdmUKICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgcGVyZm9ybWVkCiAgICAgKi8KCgogICAgc29sdmUoZHQsIHdvcmxkKSB7CiAgICAgIGxldCBpdGVyID0gMDsKICAgICAgY29uc3QgbWF4SXRlciA9IHRoaXMuaXRlcmF0aW9uczsKICAgICAgY29uc3QgdG9sU3F1YXJlZCA9IHRoaXMudG9sZXJhbmNlICogdGhpcy50b2xlcmFuY2U7CiAgICAgIGNvbnN0IGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zOwogICAgICBjb25zdCBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoOwogICAgICBjb25zdCBib2RpZXMgPSB3b3JsZC5ib2RpZXM7CiAgICAgIGNvbnN0IE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBoID0gZHQ7CiAgICAgIGxldCBCOwogICAgICBsZXQgaW52QzsKICAgICAgbGV0IGRlbHRhbGFtYmRhOwogICAgICBsZXQgZGVsdGFsYW1iZGFUb3Q7CiAgICAgIGxldCBHV2xhbWJkYTsKICAgICAgbGV0IGxhbWJkYWo7IC8vIFVwZGF0ZSBzb2x2ZSBtYXNzCgogICAgICBpZiAoTmVxICE9PSAwKSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykgewogICAgICAgICAgYm9kaWVzW2ldLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKTsKICAgICAgICB9CiAgICAgIH0gLy8gVGhpbmdzIHRoYXQgZG8gbm90IGNoYW5nZSBkdXJpbmcgaXRlcmF0aW9uIGNhbiBiZSBjb21wdXRlZCBvbmNlCgoKICAgICAgY29uc3QgaW52Q3MgPSBHU1NvbHZlcl9zb2x2ZV9pbnZDczsKICAgICAgY29uc3QgQnMgPSBHU1NvbHZlcl9zb2x2ZV9CczsKICAgICAgY29uc3QgbGFtYmRhID0gR1NTb2x2ZXJfc29sdmVfbGFtYmRhOwogICAgICBpbnZDcy5sZW5ndGggPSBOZXE7CiAgICAgIEJzLmxlbmd0aCA9IE5lcTsKICAgICAgbGFtYmRhLmxlbmd0aCA9IE5lcTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOZXE7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBlcXVhdGlvbnNbaV07CiAgICAgICAgbGFtYmRhW2ldID0gMC4wOwogICAgICAgIEJzW2ldID0gYy5jb21wdXRlQihoKTsKICAgICAgICBpbnZDc1tpXSA9IDEuMCAvIGMuY29tcHV0ZUMoKTsKICAgICAgfQoKICAgICAgaWYgKE5lcSAhPT0gMCkgewogICAgICAgIC8vIFJlc2V0IHZsYW1iZGEKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiID0gYm9kaWVzW2ldOwogICAgICAgICAgY29uc3QgdmxhbWJkYSA9IGIudmxhbWJkYTsKICAgICAgICAgIGNvbnN0IHdsYW1iZGEgPSBiLndsYW1iZGE7CiAgICAgICAgICB2bGFtYmRhLnNldCgwLCAwLCAwKTsKICAgICAgICAgIHdsYW1iZGEuc2V0KDAsIDAsIDApOwogICAgICAgIH0gLy8gSXRlcmF0ZSBvdmVyIGVxdWF0aW9ucwoKCiAgICAgICAgZm9yIChpdGVyID0gMDsgaXRlciAhPT0gbWF4SXRlcjsgaXRlcisrKSB7CiAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uCiAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDsKCiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gTmVxOyBqKyspIHsKICAgICAgICAgICAgY29uc3QgYyA9IGVxdWF0aW9uc1tqXTsgLy8gQ29tcHV0ZSBpdGVyYXRpb24KCiAgICAgICAgICAgIEIgPSBCc1tqXTsKICAgICAgICAgICAgaW52QyA9IGludkNzW2pdOwogICAgICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdOwogICAgICAgICAgICBHV2xhbWJkYSA9IGMuY29tcHV0ZUdXbGFtYmRhKCk7CiAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gaW52QyAqIChCIC0gR1dsYW1iZGEgLSBjLmVwcyAqIGxhbWJkYWopOyAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbAoKICAgICAgICAgICAgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA8IGMubWluRm9yY2UpIHsKICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGMubWluRm9yY2UgLSBsYW1iZGFqOwogICAgICAgICAgICB9IGVsc2UgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA+IGMubWF4Rm9yY2UpIHsKICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGMubWF4Rm9yY2UgLSBsYW1iZGFqOwogICAgICAgICAgICB9CgogICAgICAgICAgICBsYW1iZGFbal0gKz0gZGVsdGFsYW1iZGE7CiAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IGRlbHRhbGFtYmRhID4gMC4wID8gZGVsdGFsYW1iZGEgOiAtZGVsdGFsYW1iZGE7IC8vIGFicyhkZWx0YWxhbWJkYSkKCiAgICAgICAgICAgIGMuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTsKICAgICAgICAgIH0gLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZQoKCiAgICAgICAgICBpZiAoZGVsdGFsYW1iZGFUb3QgKiBkZWx0YWxhbWJkYVRvdCA8IHRvbFNxdWFyZWQpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5CgoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiID0gYm9kaWVzW2ldOwogICAgICAgICAgY29uc3QgdiA9IGIudmVsb2NpdHk7CiAgICAgICAgICBjb25zdCB3ID0gYi5hbmd1bGFyVmVsb2NpdHk7CiAgICAgICAgICBiLnZsYW1iZGEudm11bChiLmxpbmVhckZhY3RvciwgYi52bGFtYmRhKTsKICAgICAgICAgIHYudmFkZChiLnZsYW1iZGEsIHYpOwogICAgICAgICAgYi53bGFtYmRhLnZtdWwoYi5hbmd1bGFyRmFjdG9yLCBiLndsYW1iZGEpOwogICAgICAgICAgdy52YWRkKGIud2xhbWJkYSwgdyk7CiAgICAgICAgfSAvLyBTZXQgdGhlIGAubXVsdGlwbGllcmAgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvbgoKCiAgICAgICAgbGV0IGwgPSBlcXVhdGlvbnMubGVuZ3RoOwogICAgICAgIGNvbnN0IGludkR0ID0gMSAvIGg7CgogICAgICAgIHdoaWxlIChsLS0pIHsKICAgICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gaXRlcjsKICAgIH0KCiAgfSAvLyBKdXN0IHRlbXBvcmFyeSBudW1iZXIgaG9sZGVycyB0aGF0IHdlIHdhbnQgdG8gcmV1c2UgZWFjaCBpdGVyYXRpb24uCgogIGNvbnN0IEdTU29sdmVyX3NvbHZlX2xhbWJkYSA9IFtdOwogIGNvbnN0IEdTU29sdmVyX3NvbHZlX2ludkNzID0gW107CiAgY29uc3QgR1NTb2x2ZXJfc29sdmVfQnMgPSBbXTsKCiAgLyoqCiAgICogU3BsaXRzIHRoZSBlcXVhdGlvbnMgaW50byBpc2xhbmRzIGFuZCBzb2x2ZXMgdGhlbSBpbmRlcGVuZGVudGx5LiBDYW4gaW1wcm92ZSBwZXJmb3JtYW5jZS4KICAgKi8KICBjbGFzcyBTcGxpdFNvbHZlciBleHRlbmRzIFNvbHZlciB7CiAgICAvKioKICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuIFRoZSBtb3JlIGl0ZXJhdGlvbnMsIHRoZSBtb3JlIGNvcnJlY3Qgc2ltdWxhdGlvbi4gTW9yZSBpdGVyYXRpb25zIG5lZWQgbW9yZSBjb21wdXRhdGlvbnMgdGhvdWdoLiBJZiB5b3UgaGF2ZSBhIGxhcmdlIGdyYXZpdHkgZm9yY2UgaW4geW91ciB3b3JsZCwgeW91IHdpbGwgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZW4gdG9sZXJhbmNlIGlzIHJlYWNoZWQsIHRoZSBzeXN0ZW0gaXMgYXNzdW1lZCB0byBiZSBjb252ZXJnZWQuCiAgICAgKi8KCiAgICAvKiogc3Vic29sdmVyICovCiAgICBjb25zdHJ1Y3RvcihzdWJzb2x2ZXIpIHsKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pdGVyYXRpb25zID0gMTA7CiAgICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNzsKICAgICAgdGhpcy5zdWJzb2x2ZXIgPSBzdWJzb2x2ZXI7CiAgICAgIHRoaXMubm9kZXMgPSBbXTsKICAgICAgdGhpcy5ub2RlUG9vbCA9IFtdOyAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZQoKICAgICAgd2hpbGUgKHRoaXMubm9kZVBvb2wubGVuZ3RoIDwgMTI4KSB7CiAgICAgICAgdGhpcy5ub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBjcmVhdGVOb2RlCiAgICAgKi8KCgogICAgY3JlYXRlTm9kZSgpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBib2R5OiBudWxsLAogICAgICAgIGNoaWxkcmVuOiBbXSwKICAgICAgICBlcXM6IFtdLAogICAgICAgIHZpc2l0ZWQ6IGZhbHNlCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIFNvbHZlIHRoZSBzdWJzeXN0ZW1zCiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBpdGVyYXRpb25zIHBlcmZvcm1lZAogICAgICovCgoKICAgIHNvbHZlKGR0LCB3b3JsZCkgewogICAgICBjb25zdCBub2RlcyA9IFNwbGl0U29sdmVyX3NvbHZlX25vZGVzOwogICAgICBjb25zdCBub2RlUG9vbCA9IHRoaXMubm9kZVBvb2w7CiAgICAgIGNvbnN0IGJvZGllcyA9IHdvcmxkLmJvZGllczsKICAgICAgY29uc3QgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnM7CiAgICAgIGNvbnN0IE5lcSA9IGVxdWF0aW9ucy5sZW5ndGg7CiAgICAgIGNvbnN0IE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBzdWJzb2x2ZXIgPSB0aGlzLnN1YnNvbHZlcjsgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGUKCiAgICAgIHdoaWxlIChub2RlUG9vbC5sZW5ndGggPCBOYm9kaWVzKSB7CiAgICAgICAgbm9kZVBvb2wucHVzaCh0aGlzLmNyZWF0ZU5vZGUoKSk7CiAgICAgIH0KCiAgICAgIG5vZGVzLmxlbmd0aCA9IE5ib2RpZXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5ib2RpZXM7IGkrKykgewogICAgICAgIG5vZGVzW2ldID0gbm9kZVBvb2xbaV07CiAgICAgIH0gLy8gUmVzZXQgbm9kZSB2YWx1ZXMKCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldOwogICAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTsKICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7CiAgICAgICAgbm9kZS5lcXMubGVuZ3RoID0gMDsKICAgICAgICBub2RlLnZpc2l0ZWQgPSBmYWxzZTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgayA9IDA7IGsgIT09IE5lcTsgaysrKSB7CiAgICAgICAgY29uc3QgZXEgPSBlcXVhdGlvbnNba107CiAgICAgICAgY29uc3QgaSA9IGJvZGllcy5pbmRleE9mKGVxLmJpKTsKICAgICAgICBjb25zdCBqID0gYm9kaWVzLmluZGV4T2YoZXEuYmopOwogICAgICAgIGNvbnN0IG5pID0gbm9kZXNbaV07CiAgICAgICAgY29uc3QgbmogPSBub2Rlc1tqXTsKICAgICAgICBuaS5jaGlsZHJlbi5wdXNoKG5qKTsKICAgICAgICBuaS5lcXMucHVzaChlcSk7CiAgICAgICAgbmouY2hpbGRyZW4ucHVzaChuaSk7CiAgICAgICAgbmouZXFzLnB1c2goZXEpOwogICAgICB9CgogICAgICBsZXQgY2hpbGQ7CiAgICAgIGxldCBuID0gMDsKICAgICAgbGV0IGVxcyA9IFNwbGl0U29sdmVyX3NvbHZlX2VxczsKICAgICAgc3Vic29sdmVyLnRvbGVyYW5jZSA9IHRoaXMudG9sZXJhbmNlOwogICAgICBzdWJzb2x2ZXIuaXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9uczsKICAgICAgY29uc3QgZHVtbXlXb3JsZCA9IFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQ7CgogICAgICB3aGlsZSAoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGVzKSkgewogICAgICAgIGVxcy5sZW5ndGggPSAwOwogICAgICAgIGR1bW15V29ybGQuYm9kaWVzLmxlbmd0aCA9IDA7CiAgICAgICAgYmZzKGNoaWxkLCB2aXNpdEZ1bmMsIGR1bW15V29ybGQuYm9kaWVzLCBlcXMpOwogICAgICAgIGNvbnN0IE5lcXMgPSBlcXMubGVuZ3RoOwogICAgICAgIGVxcyA9IGVxcy5zb3J0KHNvcnRCeUlkKTsKCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5lcXM7IGkrKykgewogICAgICAgICAgc3Vic29sdmVyLmFkZEVxdWF0aW9uKGVxc1tpXSk7CiAgICAgICAgfQoKICAgICAgICBzdWJzb2x2ZXIuc29sdmUoZHQsIGR1bW15V29ybGQpOwogICAgICAgIHN1YnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTsKICAgICAgICBuKys7CiAgICAgIH0KCiAgICAgIHJldHVybiBuOwogICAgfQoKICB9IC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBzdWJzeXN0ZW1zCgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX25vZGVzID0gW107IC8vIEFsbCBhbGxvY2F0ZWQgbm9kZSBvYmplY3RzCgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX2VxcyA9IFtdOyAvLyBUZW1wIGFycmF5CgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQgPSB7CiAgICBib2RpZXM6IFtdCiAgfTsgLy8gVGVtcCBvYmplY3QKCiAgY29uc3QgU1RBVElDID0gQm9keS5TVEFUSUM7CgogIGZ1bmN0aW9uIGdldFVudmlzaXRlZE5vZGUobm9kZXMpIHsKICAgIGNvbnN0IE5ub2RlcyA9IG5vZGVzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTm5vZGVzOyBpKyspIHsKICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldOwoKICAgICAgaWYgKCFub2RlLnZpc2l0ZWQgJiYgIShub2RlLmJvZHkudHlwZSAmIFNUQVRJQykpIHsKICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBmYWxzZTsKICB9CgogIGNvbnN0IHF1ZXVlID0gW107CgogIGZ1bmN0aW9uIGJmcyhyb290LCB2aXNpdEZ1bmMsIGJkcywgZXFzKSB7CiAgICBxdWV1ZS5wdXNoKHJvb3QpOwogICAgcm9vdC52aXNpdGVkID0gdHJ1ZTsKICAgIHZpc2l0RnVuYyhyb290LCBiZHMsIGVxcyk7CgogICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkgewogICAgICBjb25zdCBub2RlID0gcXVldWUucG9wKCk7IC8vIExvb3Agb3ZlciB1bnZpc2l0ZWQgY2hpbGQgbm9kZXMKCiAgICAgIGxldCBjaGlsZDsKCiAgICAgIHdoaWxlIChjaGlsZCA9IGdldFVudmlzaXRlZE5vZGUobm9kZS5jaGlsZHJlbikpIHsKICAgICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTsKICAgICAgICB2aXNpdEZ1bmMoY2hpbGQsIGJkcywgZXFzKTsKICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTsKICAgICAgfQogICAgfQogIH0KCiAgZnVuY3Rpb24gdmlzaXRGdW5jKG5vZGUsIGJkcywgZXFzKSB7CiAgICBiZHMucHVzaChub2RlLmJvZHkpOwogICAgY29uc3QgTmVxcyA9IG5vZGUuZXFzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmVxczsgaSsrKSB7CiAgICAgIGNvbnN0IGVxID0gbm9kZS5lcXNbaV07CgogICAgICBpZiAoIWVxcy5pbmNsdWRlcyhlcSkpIHsKICAgICAgICBlcXMucHVzaChlcSk7CiAgICAgIH0KICAgIH0KICB9CgogIGZ1bmN0aW9uIHNvcnRCeUlkKGEsIGIpIHsKICAgIHJldHVybiBiLmlkIC0gYS5pZDsKICB9CgogIC8qKgogICAqIEZvciBwb29saW5nIG9iamVjdHMgdGhhdCBjYW4gYmUgcmV1c2VkLgogICAqLwogIGNsYXNzIFBvb2wgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMub2JqZWN0cyA9IFtdOwogICAgICB0aGlzLnR5cGUgPSBPYmplY3Q7CiAgICB9CgogICAgLyoqCiAgICAgKiBSZWxlYXNlIGFuIG9iamVjdCBhZnRlciB1c2UKICAgICAqLwogICAgcmVsZWFzZSgpIHsKICAgICAgY29uc3QgTmFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5hcmdzOyBpKyspIHsKICAgICAgICB0aGlzLm9iamVjdHMucHVzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFuIG9iamVjdAogICAgICovCgoKICAgIGdldCgpIHsKICAgICAgaWYgKHRoaXMub2JqZWN0cy5sZW5ndGggPT09IDApIHsKICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RPYmplY3QoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzLnBvcCgpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnN0cnVjdCBhbiBvYmplY3QuIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzLgogICAgICovCgoKICAgIGNvbnN0cnVjdE9iamVjdCgpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCEnKTsKICAgIH0KICAgIC8qKgogICAgICogQHJldHVybiBTZWxmLCBmb3IgY2hhaW5pbmcKICAgICAqLwoKCiAgICByZXNpemUoc2l6ZSkgewogICAgICBjb25zdCBvYmplY3RzID0gdGhpcy5vYmplY3RzOwoKICAgICAgd2hpbGUgKG9iamVjdHMubGVuZ3RoID4gc2l6ZSkgewogICAgICAgIG9iamVjdHMucG9wKCk7CiAgICAgIH0KCiAgICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHsKICAgICAgICBvYmplY3RzLnB1c2godGhpcy5jb25zdHJ1Y3RPYmplY3QoKSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQoKICB9CgogIC8qKgogICAqIFZlYzNQb29sCiAgICovCgogIGNsYXNzIFZlYzNQb29sIGV4dGVuZHMgUG9vbCB7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTsKICAgICAgdGhpcy50eXBlID0gVmVjMzsKICAgIH0KCiAgICAvKioKICAgICAqIENvbnN0cnVjdCBhIHZlY3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RPYmplY3QoKSB7CiAgICAgIHJldHVybiBuZXcgVmVjMygpOwogICAgfQoKICB9CgogIC8vIE5hbWluZyBydWxlOiBiYXNlZCBvZiB0aGUgb3JkZXIgaW4gU0hBUEVfVFlQRVMsCiAgLy8gdGhlIGZpcnN0IHBhcnQgb2YgdGhlIG1ldGhvZCBpcyBmb3JtZWQgYnkgdGhlCiAgLy8gc2hhcGUgdHlwZSB0aGF0IGNvbWVzIGJlZm9yZSwgaW4gdGhlIHNlY29uZCBwYXJ0CiAgLy8gdGhlcmUgaXMgdGhlIHNoYXBlIHR5cGUgdGhhdCBjb21lcyBhZnRlciBpbiB0aGUgU0hBUEVfVFlQRVMgbGlzdAogIGNvbnN0IENPTExJU0lPTl9UWVBFUyA9IHsKICAgIHNwaGVyZVNwaGVyZTogU2hhcGUudHlwZXMuU1BIRVJFLAogICAgc3BoZXJlUGxhbmU6IFNoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLlBMQU5FLAogICAgYm94Qm94OiBTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5CT1gsCiAgICBzcGhlcmVCb3g6IFNoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLkJPWCwKICAgIHBsYW5lQm94OiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkJPWCwKICAgIGNvbnZleENvbnZleDogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiwKICAgIHNwaGVyZUNvbnZleDogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiwKICAgIHBsYW5lQ29udmV4OiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBib3hDb252ZXg6IFNoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBzcGhlcmVIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTEQsCiAgICBib3hIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTEQsCiAgICBjb252ZXhIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxELAogICAgc3BoZXJlUGFydGljbGU6IFNoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFLAogICAgcGxhbmVQYXJ0aWNsZTogU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5QQVJUSUNMRSwKICAgIGJveFBhcnRpY2xlOiBTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5QQVJUSUNMRSwKICAgIGNvbnZleFBhcnRpY2xlOiBTaGFwZS50eXBlcy5QQVJUSUNMRSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBjeWxpbmRlckN5bGluZGVyOiBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHNwaGVyZUN5bGluZGVyOiBTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHBsYW5lQ3lsaW5kZXI6IFNoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBib3hDeWxpbmRlcjogU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBjb252ZXhDeWxpbmRlcjogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkNZTElOREVSLAogICAgaGVpZ2h0ZmllbGRDeWxpbmRlcjogU2hhcGUudHlwZXMuSEVJR0hURklFTEQgfCBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHBhcnRpY2xlQ3lsaW5kZXI6IFNoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBzcGhlcmVUcmltZXNoOiBTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5UUklNRVNILAogICAgcGxhbmVUcmltZXNoOiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlRSSU1FU0gKICB9OwoKICAvKioKICAgKiBIZWxwZXIgY2xhc3MgZm9yIHRoZSBXb3JsZC4gR2VuZXJhdGVzIENvbnRhY3RFcXVhdGlvbnMuCiAgICogQHRvZG8gU3BoZXJlLUNvbnZleFBvbHloZWRyb24gY29udGFjdHMKICAgKiBAdG9kbyBDb250YWN0IHJlZHVjdGlvbgogICAqIEB0b2RvIHNob3VsZCBtb3ZlIG1ldGhvZHMgdG8gcHJvdG90eXBlCiAgICovCiAgY2xhc3MgTmFycm93cGhhc2UgewogICAgLyoqCiAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy4KICAgICAqLwoKICAgIC8qKgogICAgICogUG9vbGVkIHZlY3RvcnMuCiAgICAgKi8KICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVNwaGVyZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnNwaGVyZVNwaGVyZTsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5zcGhlcmVQbGFuZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnNwaGVyZVBsYW5lOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmJveEJveF0oKSB7CiAgICAgIHJldHVybiB0aGlzLmJveEJveDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5zcGhlcmVCb3hdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVCb3g7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVCb3hdKCkgewogICAgICByZXR1cm4gdGhpcy5wbGFuZUJveDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhDb252ZXhdKCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuc3BoZXJlQ29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlQ29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBsYW5lQ29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMucGxhbmVDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94Q29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMuYm94Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZUhlaWdodGZpZWxkXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlSGVpZ2h0ZmllbGQ7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94SGVpZ2h0ZmllbGRdKCkgewogICAgICByZXR1cm4gdGhpcy5ib3hIZWlnaHRmaWVsZDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhIZWlnaHRmaWVsZF0oKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleEhlaWdodGZpZWxkOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVBhcnRpY2xlXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlUGFydGljbGU7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVQYXJ0aWNsZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lUGFydGljbGU7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94UGFydGljbGVdKCkgewogICAgICByZXR1cm4gdGhpcy5ib3hQYXJ0aWNsZTsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhQYXJ0aWNsZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleFBhcnRpY2xlOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmN5bGluZGVyQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuc3BoZXJlQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVDeWxpbmRlcl0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lQ29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmJveEN5bGluZGVyXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuYm94Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmNvbnZleEN5bGluZGVyXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuY29udmV4Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmhlaWdodGZpZWxkQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5oZWlnaHRmaWVsZEN5bGluZGVyOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBhcnRpY2xlQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5wYXJ0aWNsZUN5bGluZGVyOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVRyaW1lc2hdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVUcmltZXNoOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBsYW5lVHJpbWVzaF0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lVHJpbWVzaDsKICAgIH0gLy8gZ2V0IFtDT0xMSVNJT05fVFlQRVMuY29udmV4VHJpbWVzaF0oKSB7CiAgICAvLyAgIHJldHVybiB0aGlzLmNvbnZleFRyaW1lc2gKICAgIC8vIH0KCgogICAgY29uc3RydWN0b3Iod29ybGQpIHsKICAgICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTsKICAgICAgdGhpcy5yZXN1bHQgPSBbXTsKICAgICAgdGhpcy5mcmljdGlvblJlc3VsdCA9IFtdOwogICAgICB0aGlzLnYzcG9vbCA9IG5ldyBWZWMzUG9vbCgpOwogICAgICB0aGlzLndvcmxkID0gd29ybGQ7CiAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7CiAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogTWFrZSBhIGNvbnRhY3Qgb2JqZWN0LCBieSB1c2luZyB0aGUgaW50ZXJuYWwgcG9vbCBvciBjcmVhdGluZyBhIG5ldyBvbmUuCiAgICAgKi8KCgogICAgY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCBvdmVycmlkZVNoYXBlQSwgb3ZlcnJpZGVTaGFwZUIpIHsKICAgICAgbGV0IGM7CgogICAgICBpZiAodGhpcy5jb250YWN0UG9pbnRQb29sLmxlbmd0aCkgewogICAgICAgIGMgPSB0aGlzLmNvbnRhY3RQb2ludFBvb2wucG9wKCk7CiAgICAgICAgYy5iaSA9IGJpOwogICAgICAgIGMuYmogPSBiajsKICAgICAgfSBlbHNlIHsKICAgICAgICBjID0gbmV3IENvbnRhY3RFcXVhdGlvbihiaSwgYmopOwogICAgICB9CgogICAgICBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTsKICAgICAgY29uc3QgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7CiAgICAgIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjsKICAgICAgYy5zZXRTcG9va1BhcmFtcyhjbS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsIGNtLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sIHRoaXMud29ybGQuZHQpOwogICAgICBjb25zdCBtYXRBID0gc2kubWF0ZXJpYWwgfHwgYmkubWF0ZXJpYWw7CiAgICAgIGNvbnN0IG1hdEIgPSBzai5tYXRlcmlhbCB8fCBiai5tYXRlcmlhbDsKCiAgICAgIGlmIChtYXRBICYmIG1hdEIgJiYgbWF0QS5yZXN0aXR1dGlvbiA+PSAwICYmIG1hdEIucmVzdGl0dXRpb24gPj0gMCkgewogICAgICAgIGMucmVzdGl0dXRpb24gPSBtYXRBLnJlc3RpdHV0aW9uICogbWF0Qi5yZXN0aXR1dGlvbjsKICAgICAgfQoKICAgICAgYy5zaSA9IG92ZXJyaWRlU2hhcGVBIHx8IHNpOwogICAgICBjLnNqID0gb3ZlcnJpZGVTaGFwZUIgfHwgc2o7CiAgICAgIHJldHVybiBjOwogICAgfQoKICAgIGNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoY29udGFjdEVxdWF0aW9uLCBvdXRBcnJheSkgewogICAgICBjb25zdCBib2R5QSA9IGNvbnRhY3RFcXVhdGlvbi5iaTsKICAgICAgY29uc3QgYm9keUIgPSBjb250YWN0RXF1YXRpb24uYmo7CiAgICAgIGNvbnN0IHNoYXBlQSA9IGNvbnRhY3RFcXVhdGlvbi5zaTsKICAgICAgY29uc3Qgc2hhcGVCID0gY29udGFjdEVxdWF0aW9uLnNqOwogICAgICBjb25zdCB3b3JsZCA9IHRoaXMud29ybGQ7CiAgICAgIGNvbnN0IGNtID0gdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsOyAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtCgogICAgICBsZXQgZnJpY3Rpb24gPSBjbS5mcmljdGlvbjsKICAgICAgY29uc3QgbWF0QSA9IHNoYXBlQS5tYXRlcmlhbCB8fCBib2R5QS5tYXRlcmlhbDsKICAgICAgY29uc3QgbWF0QiA9IHNoYXBlQi5tYXRlcmlhbCB8fCBib2R5Qi5tYXRlcmlhbDsKCiAgICAgIGlmIChtYXRBICYmIG1hdEIgJiYgbWF0QS5mcmljdGlvbiA+PSAwICYmIG1hdEIuZnJpY3Rpb24gPj0gMCkgewogICAgICAgIGZyaWN0aW9uID0gbWF0QS5mcmljdGlvbiAqIG1hdEIuZnJpY3Rpb247CiAgICAgIH0KCiAgICAgIGlmIChmcmljdGlvbiA+IDApIHsKICAgICAgICAvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9ucwogICAgICAgIC8vIFVzZXJzIG1heSBwcm92aWRlIGEgZm9yY2UgZGlmZmVyZW50IGZyb20gZ2xvYmFsIGdyYXZpdHkgdG8gdXNlIHdoZW4gY29tcHV0aW5nIGNvbnRhY3QgZnJpY3Rpb24uCiAgICAgICAgY29uc3QgbXVnID0gZnJpY3Rpb24gKiAod29ybGQuZnJpY3Rpb25HcmF2aXR5IHx8IHdvcmxkLmdyYXZpdHkpLmxlbmd0aCgpOwogICAgICAgIGxldCByZWR1Y2VkTWFzcyA9IGJvZHlBLmludk1hc3MgKyBib2R5Qi5pbnZNYXNzOwoKICAgICAgICBpZiAocmVkdWNlZE1hc3MgPiAwKSB7CiAgICAgICAgICByZWR1Y2VkTWFzcyA9IDEgLyByZWR1Y2VkTWFzczsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sOwogICAgICAgIGNvbnN0IGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtdWcgKiByZWR1Y2VkTWFzcyk7CiAgICAgICAgY29uc3QgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihib2R5QSwgYm9keUIsIG11ZyAqIHJlZHVjZWRNYXNzKTsKICAgICAgICBjMS5iaSA9IGMyLmJpID0gYm9keUE7CiAgICAgICAgYzEuYmogPSBjMi5iaiA9IGJvZHlCOwogICAgICAgIGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnICogcmVkdWNlZE1hc3M7CiAgICAgICAgYzEubWF4Rm9yY2UgPSBjMi5tYXhGb3JjZSA9IG11ZyAqIHJlZHVjZWRNYXNzOyAvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnMKCiAgICAgICAgYzEucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpOwogICAgICAgIGMxLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTsKICAgICAgICBjMi5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7CiAgICAgICAgYzIucmouY29weShjb250YWN0RXF1YXRpb24ucmopOyAvLyBDb25zdHJ1Y3QgdGFuZ2VudHMKCiAgICAgICAgY29udGFjdEVxdWF0aW9uLm5pLnRhbmdlbnRzKGMxLnQsIGMyLnQpOyAvLyBTZXQgc3Bvb2sgcGFyYW1zCgogICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7CiAgICAgICAgYzIuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIHdvcmxkLmR0KTsKICAgICAgICBjMS5lbmFibGVkID0gYzIuZW5hYmxlZCA9IGNvbnRhY3RFcXVhdGlvbi5lbmFibGVkOwogICAgICAgIG91dEFycmF5LnB1c2goYzEsIGMyKTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQoKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgLyoqCiAgICAgKiBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLgogICAgICovCgoKICAgIGNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpIHsKICAgICAgLy8gVGhlIGxhc3QgY29udGFjdEVxdWF0aW9uCiAgICAgIGxldCBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMV07IC8vIENyZWF0ZSB0aGUgcmVzdWx0OiB0d28gImF2ZXJhZ2UiIGZyaWN0aW9uIGVxdWF0aW9ucwoKICAgICAgaWYgKCF0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoYywgdGhpcy5mcmljdGlvblJlc3VsdCkgfHwgbnVtQ29udGFjdHMgPT09IDEpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGYxID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdOwogICAgICBjb25zdCBmMiA9IHRoaXMuZnJpY3Rpb25SZXN1bHRbdGhpcy5mcmljdGlvblJlc3VsdC5sZW5ndGggLSAxXTsKICAgICAgYXZlcmFnZU5vcm1hbC5zZXRaZXJvKCk7CiAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNldFplcm8oKTsKICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIuc2V0WmVybygpOwogICAgICBjb25zdCBib2R5QSA9IGMuYmk7CiAgICAgIGMuYmo7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gbnVtQ29udGFjdHM7IGkrKykgewogICAgICAgIGMgPSB0aGlzLnJlc3VsdFt0aGlzLnJlc3VsdC5sZW5ndGggLSAxIC0gaV07CgogICAgICAgIGlmIChjLmJpICE9PSBib2R5QSkgewogICAgICAgICAgYXZlcmFnZU5vcm1hbC52YWRkKGMubmksIGF2ZXJhZ2VOb3JtYWwpOwogICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7CiAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYXZlcmFnZU5vcm1hbC52c3ViKGMubmksIGF2ZXJhZ2VOb3JtYWwpOwogICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJqLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7CiAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IGludk51bUNvbnRhY3RzID0gMSAvIG51bUNvbnRhY3RzOwogICAgICBhdmVyYWdlQ29udGFjdFBvaW50QS5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmkpOwogICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmopOwogICAgICBmMi5yaS5jb3B5KGYxLnJpKTsgLy8gU2hvdWxkIGJlIHRoZSBzYW1lCgogICAgICBmMi5yai5jb3B5KGYxLnJqKTsKICAgICAgYXZlcmFnZU5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgYXZlcmFnZU5vcm1hbC50YW5nZW50cyhmMS50LCBmMi50KTsgLy8gcmV0dXJuIGVxOwogICAgfQogICAgLyoqCiAgICAgKiBHZW5lcmF0ZSBhbGwgY29udGFjdHMgYmV0d2VlbiBhIGxpc3Qgb2YgYm9keSBwYWlycwogICAgICogQHBhcmFtIHAxIEFycmF5IG9mIGJvZHkgaW5kaWNlcwogICAgICogQHBhcmFtIHAyIEFycmF5IG9mIGJvZHkgaW5kaWNlcwogICAgICogQHBhcmFtIHJlc3VsdCBBcnJheSB0byBzdG9yZSBnZW5lcmF0ZWQgY29udGFjdHMKICAgICAqIEBwYXJhbSBvbGRjb250YWN0cyBPcHRpb25hbC4gQXJyYXkgb2YgcmV1c2FibGUgY29udGFjdCBvYmplY3RzCiAgICAgKi8KCgogICAgZ2V0Q29udGFjdHMocDEsIHAyLCB3b3JsZCwgcmVzdWx0LCBvbGRjb250YWN0cywgZnJpY3Rpb25SZXN1bHQsIGZyaWN0aW9uUG9vbCkgewogICAgICAvLyBTYXZlIG9sZCBjb250YWN0IG9iamVjdHMKICAgICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBmcmljdGlvblBvb2w7CiAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0OwogICAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7CiAgICAgIGNvbnN0IHFpID0gdG1wUXVhdDE7CiAgICAgIGNvbnN0IHFqID0gdG1wUXVhdDI7CiAgICAgIGNvbnN0IHhpID0gdG1wVmVjMTsKICAgICAgY29uc3QgeGogPSB0bXBWZWMyOwoKICAgICAgZm9yIChsZXQgayA9IDAsIE4gPSBwMS5sZW5ndGg7IGsgIT09IE47IGsrKykgewogICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXMKICAgICAgICBjb25zdCBiaSA9IHAxW2tdOwogICAgICAgIGNvbnN0IGJqID0gcDJba107IC8vIEdldCBjb250YWN0IG1hdGVyaWFsCgogICAgICAgIGxldCBib2R5Q29udGFjdE1hdGVyaWFsID0gbnVsbDsKCiAgICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7CiAgICAgICAgICBib2R5Q29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLCBiai5tYXRlcmlhbCkgfHwgbnVsbDsKICAgICAgICB9CgogICAgICAgIGNvbnN0IGp1c3RUZXN0ID0gYmkudHlwZSAmIEJvZHkuS0lORU1BVElDICYmIGJqLnR5cGUgJiBCb2R5LlNUQVRJQyB8fCBiaS50eXBlICYgQm9keS5TVEFUSUMgJiYgYmoudHlwZSAmIEJvZHkuS0lORU1BVElDIHx8IGJpLnR5cGUgJiBCb2R5LktJTkVNQVRJQyAmJiBiai50eXBlICYgQm9keS5LSU5FTUFUSUM7CgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmkuc2hhcGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBiaS5xdWF0ZXJuaW9uLm11bHQoYmkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTsKICAgICAgICAgIGJpLnF1YXRlcm5pb24udm11bHQoYmkuc2hhcGVPZmZzZXRzW2ldLCB4aSk7CiAgICAgICAgICB4aS52YWRkKGJpLnBvc2l0aW9uLCB4aSk7CiAgICAgICAgICBjb25zdCBzaSA9IGJpLnNoYXBlc1tpXTsKCiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJqLnNoYXBlcy5sZW5ndGg7IGorKykgewogICAgICAgICAgICAvLyBDb21wdXRlIHdvcmxkIHRyYW5zZm9ybSBvZiBzaGFwZXMKICAgICAgICAgICAgYmoucXVhdGVybmlvbi5tdWx0KGJqLnNoYXBlT3JpZW50YXRpb25zW2pdLCBxaik7CiAgICAgICAgICAgIGJqLnF1YXRlcm5pb24udm11bHQoYmouc2hhcGVPZmZzZXRzW2pdLCB4aik7CiAgICAgICAgICAgIHhqLnZhZGQoYmoucG9zaXRpb24sIHhqKTsKICAgICAgICAgICAgY29uc3Qgc2ogPSBiai5zaGFwZXNbal07CgogICAgICAgICAgICBpZiAoIShzaS5jb2xsaXNpb25GaWx0ZXJNYXNrICYgc2ouY29sbGlzaW9uRmlsdGVyR3JvdXAgJiYgc2ouY29sbGlzaW9uRmlsdGVyTWFzayAmIHNpLmNvbGxpc2lvbkZpbHRlckdyb3VwKSkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0gLy8gR2V0IGNvbGxpc2lvbiBtYXRlcmlhbAoKCiAgICAgICAgICAgIGxldCBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7CgogICAgICAgICAgICBpZiAoc2kubWF0ZXJpYWwgJiYgc2oubWF0ZXJpYWwpIHsKICAgICAgICAgICAgICBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmdldENvbnRhY3RNYXRlcmlhbChzaS5tYXRlcmlhbCwgc2oubWF0ZXJpYWwpIHx8IG51bGw7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHNoYXBlQ29udGFjdE1hdGVyaWFsIHx8IGJvZHlDb250YWN0TWF0ZXJpYWwgfHwgd29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDsgLy8gR2V0IGNvbnRhY3RzCgogICAgICAgICAgICBjb25zdCByZXNvbHZlckluZGV4ID0gc2kudHlwZSB8IHNqLnR5cGU7CiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gdGhpc1tyZXNvbHZlckluZGV4XTsKCiAgICAgICAgICAgIGlmIChyZXNvbHZlcikgewogICAgICAgICAgICAgIGxldCByZXR2YWwgPSBmYWxzZTsgLy8gVE8gRE86IGludmVzdGlnYXRlIHdoeSBzcGhlcmVQYXJ0aWNsZSBhbmQgY29udmV4UGFydGljbGUKICAgICAgICAgICAgICAvLyByZXNvbHZlcnMgZXhwZWN0IHNpIGFuZCBzaiBzaGFwZXMgdG8gYmUgaW4gcmV2ZXJzZSBvcmRlcgogICAgICAgICAgICAgIC8vIChpLmUuIGxhcmdlciBpbnRlZ2VyIHZhbHVlIHR5cGUgZmlyc3QgaW5zdGVhZCBvZiBzbWFsbGVyIGZpcnN0KQoKICAgICAgICAgICAgICBpZiAoc2kudHlwZSA8IHNqLnR5cGUpIHsKICAgICAgICAgICAgICAgIHJldHZhbCA9IHJlc29sdmVyLmNhbGwodGhpcywgc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dmFsID0gcmVzb2x2ZXIuY2FsbCh0aGlzLCBzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHNpLCBzaiwganVzdFRlc3QpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgaWYgKHJldHZhbCAmJiBqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgb3ZlcmxhcAogICAgICAgICAgICAgICAgd29ybGQuc2hhcGVPdmVybGFwS2VlcGVyLnNldChzaS5pZCwgc2ouaWQpOwogICAgICAgICAgICAgICAgd29ybGQuYm9keU92ZXJsYXBLZWVwZXIuc2V0KGJpLmlkLCBiai5pZCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgc3BoZXJlU3BoZXJlKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgIHJldHVybiB4aS5kaXN0YW5jZVNxdWFyZWQoeGopIDwgKHNpLnJhZGl1cyArIHNqLnJhZGl1cykgKiogMjsKICAgICAgfSAvLyBXZSB3aWxsIGhhdmUgb25seSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2UKCgogICAgICBjb25zdCBjb250YWN0RXEgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgeGoudnN1Yih4aSwgY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLm5pLm5vcm1hbGl6ZSgpOyAvLyBDb250YWN0IHBvaW50IGxvY2F0aW9ucwoKICAgICAgY29udGFjdEVxLnJpLmNvcHkoY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLnJqLmNvcHkoY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLnJpLnNjYWxlKHNpLnJhZGl1cywgY29udGFjdEVxLnJpKTsKICAgICAgY29udGFjdEVxLnJqLnNjYWxlKC1zai5yYWRpdXMsIGNvbnRhY3RFcS5yaik7CiAgICAgIGNvbnRhY3RFcS5yaS52YWRkKHhpLCBjb250YWN0RXEucmkpOwogICAgICBjb250YWN0RXEucmkudnN1YihiaS5wb3NpdGlvbiwgY29udGFjdEVxLnJpKTsKICAgICAgY29udGFjdEVxLnJqLnZhZGQoeGosIGNvbnRhY3RFcS5yaik7CiAgICAgIGNvbnRhY3RFcS5yai52c3ViKGJqLnBvc2l0aW9uLCBjb250YWN0RXEucmopOwogICAgICB0aGlzLnJlc3VsdC5wdXNoKGNvbnRhY3RFcSk7CiAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjb250YWN0RXEsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgfQoKICAgIHNwaGVyZVBsYW5lKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFdlIHdpbGwgaGF2ZSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2UKICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7IC8vIENvbnRhY3Qgbm9ybWFsCgogICAgICByLm5pLnNldCgwLCAwLCAxKTsKICAgICAgcWoudm11bHQoci5uaSwgci5uaSk7CiAgICAgIHIubmkubmVnYXRlKHIubmkpOyAvLyBib2R5IGkgaXMgdGhlIHNwaGVyZSwgZmxpcCBub3JtYWwKCiAgICAgIHIubmkubm9ybWFsaXplKCk7IC8vIE5lZWRlZD8KICAgICAgLy8gVmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0IHBvaW50CgogICAgICByLm5pLnNjYWxlKHNpLnJhZGl1cywgci5yaSk7IC8vIFByb2plY3QgZG93biBzcGhlcmUgb24gcGxhbmUKCiAgICAgIHhpLnZzdWIoeGosIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSk7CiAgICAgIHIubmkuc2NhbGUoci5uaS5kb3QocG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKSwgcGxhbmVfdG9fc3BoZXJlX29ydGhvKTsKICAgICAgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLnZzdWIocGxhbmVfdG9fc3BoZXJlX29ydGhvLCByLnJqKTsgLy8gVGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gcGxhbmUKCiAgICAgIGlmICgtcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLmRvdChyLm5pKSA8PSBzaS5yYWRpdXMpIHsKICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gLy8gTWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgYm9keQoKCiAgICAgICAgY29uc3QgcmkgPSByLnJpOwogICAgICAgIGNvbnN0IHJqID0gci5yajsKICAgICAgICByaS52YWRkKHhpLCByaSk7CiAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpOwogICAgICAgIHJqLnZhZGQoeGosIHJqKTsKICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7CiAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgIH0KICAgIH0KCiAgICBib3hCb3goc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsOwogICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTsKICAgICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2ouY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgc3BoZXJlQm94KHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGNvbnN0IHYzcG9vbCA9IHRoaXMudjNwb29sOyAvLyB3ZSByZWZlciB0byB0aGUgYm94IGFzIGJvZHkgagoKICAgICAgY29uc3Qgc2lkZXMgPSBzcGhlcmVCb3hfc2lkZXM7CiAgICAgIHhpLnZzdWIoeGosIGJveF90b19zcGhlcmUpOwogICAgICBzai5nZXRTaWRlTm9ybWFscyhzaWRlcywgcWopOwogICAgICBjb25zdCBSID0gc2kucmFkaXVzOwoKICAgICAgbGV0IGZvdW5kID0gZmFsc2U7IC8vIFN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBwZW5ldHJhdGlvbiBpbmZvCgogICAgICBjb25zdCBzaWRlX25zID0gc3BoZXJlQm94X3NpZGVfbnM7CiAgICAgIGNvbnN0IHNpZGVfbnMxID0gc3BoZXJlQm94X3NpZGVfbnMxOwogICAgICBjb25zdCBzaWRlX25zMiA9IHNwaGVyZUJveF9zaWRlX25zMjsKICAgICAgbGV0IHNpZGVfaCA9IG51bGw7CiAgICAgIGxldCBzaWRlX3BlbmV0cmF0aW9ucyA9IDA7CiAgICAgIGxldCBzaWRlX2RvdDEgPSAwOwogICAgICBsZXQgc2lkZV9kb3QyID0gMDsKICAgICAgbGV0IHNpZGVfZGlzdGFuY2UgPSBudWxsOwoKICAgICAgZm9yIChsZXQgaWR4ID0gMCwgbnNpZGVzID0gc2lkZXMubGVuZ3RoOyBpZHggIT09IG5zaWRlcyAmJiBmb3VuZCA9PT0gZmFsc2U7IGlkeCsrKSB7CiAgICAgICAgLy8gR2V0IHRoZSBwbGFuZSBzaWRlIG5vcm1hbCAobnMpCiAgICAgICAgY29uc3QgbnMgPSBzcGhlcmVCb3hfbnM7CiAgICAgICAgbnMuY29weShzaWRlc1tpZHhdKTsKICAgICAgICBjb25zdCBoID0gbnMubGVuZ3RoKCk7CiAgICAgICAgbnMubm9ybWFsaXplKCk7IC8vIFRoZSBub3JtYWwvZGlzdGFuY2UgZG90IHByb2R1Y3QgdGVsbHMgd2hpY2ggc2lkZSBvZiB0aGUgcGxhbmUgd2UgYXJlCgogICAgICAgIGNvbnN0IGRvdCA9IGJveF90b19zcGhlcmUuZG90KG5zKTsKCiAgICAgICAgaWYgKGRvdCA8IGggKyBSICYmIGRvdCA+IDApIHsKICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayB0aGUgb3RoZXIgdHdvIGRpbWVuc2lvbnMKICAgICAgICAgIGNvbnN0IG5zMSA9IHNwaGVyZUJveF9uczE7CiAgICAgICAgICBjb25zdCBuczIgPSBzcGhlcmVCb3hfbnMyOwogICAgICAgICAgbnMxLmNvcHkoc2lkZXNbKGlkeCArIDEpICUgM10pOwogICAgICAgICAgbnMyLmNvcHkoc2lkZXNbKGlkeCArIDIpICUgM10pOwogICAgICAgICAgY29uc3QgaDEgPSBuczEubGVuZ3RoKCk7CiAgICAgICAgICBjb25zdCBoMiA9IG5zMi5sZW5ndGgoKTsKICAgICAgICAgIG5zMS5ub3JtYWxpemUoKTsKICAgICAgICAgIG5zMi5ub3JtYWxpemUoKTsKICAgICAgICAgIGNvbnN0IGRvdDEgPSBib3hfdG9fc3BoZXJlLmRvdChuczEpOwogICAgICAgICAgY29uc3QgZG90MiA9IGJveF90b19zcGhlcmUuZG90KG5zMik7CgogICAgICAgICAgaWYgKGRvdDEgPCBoMSAmJiBkb3QxID4gLWgxICYmIGRvdDIgPCBoMiAmJiBkb3QyID4gLWgyKSB7CiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmFicyhkb3QgLSBoIC0gUik7CgogICAgICAgICAgICBpZiAoc2lkZV9kaXN0YW5jZSA9PT0gbnVsbCB8fCBkaXN0IDwgc2lkZV9kaXN0YW5jZSkgewogICAgICAgICAgICAgIHNpZGVfZGlzdGFuY2UgPSBkaXN0OwogICAgICAgICAgICAgIHNpZGVfZG90MSA9IGRvdDE7CiAgICAgICAgICAgICAgc2lkZV9kb3QyID0gZG90MjsKICAgICAgICAgICAgICBzaWRlX2ggPSBoOwogICAgICAgICAgICAgIHNpZGVfbnMuY29weShucyk7CiAgICAgICAgICAgICAgc2lkZV9uczEuY29weShuczEpOwogICAgICAgICAgICAgIHNpZGVfbnMyLmNvcHkobnMyKTsKICAgICAgICAgICAgICBzaWRlX3BlbmV0cmF0aW9ucysrOwoKICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHNpZGVfcGVuZXRyYXRpb25zKSB7CiAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgIHNpZGVfbnMuc2NhbGUoLVIsIHIucmkpOyAvLyBTcGhlcmUgcgoKICAgICAgICByLm5pLmNvcHkoc2lkZV9ucyk7CiAgICAgICAgci5uaS5uZWdhdGUoci5uaSk7IC8vIE5vcm1hbCBzaG91bGQgYmUgb3V0IG9mIHNwaGVyZQoKICAgICAgICBzaWRlX25zLnNjYWxlKHNpZGVfaCwgc2lkZV9ucyk7CiAgICAgICAgc2lkZV9uczEuc2NhbGUoc2lkZV9kb3QxLCBzaWRlX25zMSk7CiAgICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMxLCBzaWRlX25zKTsKICAgICAgICBzaWRlX25zMi5zY2FsZShzaWRlX2RvdDIsIHNpZGVfbnMyKTsKICAgICAgICBzaWRlX25zLnZhZGQoc2lkZV9uczIsIHIucmopOyAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwoKICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpOwogICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTsKICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopOwogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9IC8vIENoZWNrIGNvcm5lcnMKCgogICAgICBsZXQgcmogPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVCb3hfc3BoZXJlX3RvX2Nvcm5lcjsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSAyICYmICFmb3VuZDsgaisrKSB7CiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgIT09IDIgJiYgIWZvdW5kOyBrKyspIHsKICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsICE9PSAyICYmICFmb3VuZDsgbCsrKSB7CiAgICAgICAgICAgIHJqLnNldCgwLCAwLCAwKTsKCiAgICAgICAgICAgIGlmIChqKSB7CiAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1swXSwgcmopOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMF0sIHJqKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKGspIHsKICAgICAgICAgICAgICByai52YWRkKHNpZGVzWzFdLCByaik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmoudnN1YihzaWRlc1sxXSwgcmopOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAobCkgewogICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMl0sIHJqKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzJdLCByaik7CiAgICAgICAgICAgIH0gLy8gV29ybGQgcG9zaXRpb24gb2YgY29ybmVyCgoKICAgICAgICAgICAgeGoudmFkZChyaiwgc3BoZXJlX3RvX2Nvcm5lcik7CiAgICAgICAgICAgIHNwaGVyZV90b19jb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7CgogICAgICAgICAgICBpZiAoc3BoZXJlX3RvX2Nvcm5lci5sZW5ndGhTcXVhcmVkKCkgPCBSICogUikgewogICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICAgICAgci5yaS5jb3B5KHNwaGVyZV90b19jb3JuZXIpOwogICAgICAgICAgICAgIHIucmkubm9ybWFsaXplKCk7CiAgICAgICAgICAgICAgci5uaS5jb3B5KHIucmkpOwogICAgICAgICAgICAgIHIucmkuc2NhbGUoUiwgci5yaSk7CiAgICAgICAgICAgICAgci5yai5jb3B5KHJqKTsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXMKCiAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7CiAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsKICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdjNwb29sLnJlbGVhc2UocmopOwogICAgICByaiA9IG51bGw7IC8vIENoZWNrIGVkZ2VzCgogICAgICBjb25zdCBlZGdlVGFuZ2VudCA9IHYzcG9vbC5nZXQoKTsKICAgICAgY29uc3QgZWRnZUNlbnRlciA9IHYzcG9vbC5nZXQoKTsKICAgICAgY29uc3QgciA9IHYzcG9vbC5nZXQoKTsgLy8gciA9IGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXIKCiAgICAgIGNvbnN0IG9ydGhvZ29uYWwgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IGRpc3QgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IE5zaWRlcyA9IHNpZGVzLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBOc2lkZXMgJiYgIWZvdW5kOyBqKyspIHsKICAgICAgICBmb3IgKGxldCBrID0gMDsgayAhPT0gTnNpZGVzICYmICFmb3VuZDsgaysrKSB7CiAgICAgICAgICBpZiAoaiAlIDMgIT09IGsgJSAzKSB7CiAgICAgICAgICAgIC8vIEdldCBlZGdlIHRhbmdlbnQKICAgICAgICAgICAgc2lkZXNba10uY3Jvc3Moc2lkZXNbal0sIGVkZ2VUYW5nZW50KTsKICAgICAgICAgICAgZWRnZVRhbmdlbnQubm9ybWFsaXplKCk7CiAgICAgICAgICAgIHNpZGVzW2pdLnZhZGQoc2lkZXNba10sIGVkZ2VDZW50ZXIpOwogICAgICAgICAgICByLmNvcHkoeGkpOwogICAgICAgICAgICByLnZzdWIoZWRnZUNlbnRlciwgcik7CiAgICAgICAgICAgIHIudnN1Yih4aiwgcik7CiAgICAgICAgICAgIGNvbnN0IG9ydGhvbm9ybSA9IHIuZG90KGVkZ2VUYW5nZW50KTsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvbgoKICAgICAgICAgICAgZWRnZVRhbmdlbnQuc2NhbGUob3J0aG9ub3JtLCBvcnRob2dvbmFsKTsgLy8gVmVjdG9yIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb24KICAgICAgICAgICAgLy8gRmluZCB0aGUgdGhpcmQgc2lkZSBvcnRob2dvbmFsIHRvIHRoaXMgb25lCgogICAgICAgICAgICBsZXQgbCA9IDA7CgogICAgICAgICAgICB3aGlsZSAobCA9PT0gaiAlIDMgfHwgbCA9PT0gayAlIDMpIHsKICAgICAgICAgICAgICBsKys7CiAgICAgICAgICAgIH0gLy8gdmVjIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIHByb2plY3RlZCB0byB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byB0aGUgZWRnZSB0YW5nZW50CgoKICAgICAgICAgICAgZGlzdC5jb3B5KHhpKTsKICAgICAgICAgICAgZGlzdC52c3ViKG9ydGhvZ29uYWwsIGRpc3QpOwogICAgICAgICAgICBkaXN0LnZzdWIoZWRnZUNlbnRlciwgZGlzdCk7CiAgICAgICAgICAgIGRpc3QudnN1Yih4aiwgZGlzdCk7IC8vIERpc3RhbmNlcyBpbiB0YW5nZW50IGRpcmVjdGlvbiBhbmQgZGlzdGFuY2UgaW4gdGhlIHBsYW5lIG9ydGhvZ29uYWwgdG8gaXQKCiAgICAgICAgICAgIGNvbnN0IHRkaXN0ID0gTWF0aC5hYnMob3J0aG9ub3JtKTsKICAgICAgICAgICAgY29uc3QgbmRpc3QgPSBkaXN0Lmxlbmd0aCgpOwoKICAgICAgICAgICAgaWYgKHRkaXN0IDwgc2lkZXNbbF0ubGVuZ3RoKCkgJiYgbmRpc3QgPCBSKSB7CiAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTsKICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgICAgICAgIGVkZ2VDZW50ZXIudmFkZChvcnRob2dvbmFsLCByZXMucmopOyAvLyBib3ggcmoKCiAgICAgICAgICAgICAgcmVzLnJqLmNvcHkocmVzLnJqKTsKICAgICAgICAgICAgICBkaXN0Lm5lZ2F0ZShyZXMubmkpOwogICAgICAgICAgICAgIHJlcy5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICByZXMucmkuY29weShyZXMucmopOwogICAgICAgICAgICAgIHJlcy5yaS52YWRkKHhqLCByZXMucmkpOwogICAgICAgICAgICAgIHJlcy5yaS52c3ViKHhpLCByZXMucmkpOwogICAgICAgICAgICAgIHJlcy5yaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICByZXMucmkuc2NhbGUoUiwgcmVzLnJpKTsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXMKCiAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGksIHJlcy5yaSk7CiAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoYmkucG9zaXRpb24sIHJlcy5yaSk7CiAgICAgICAgICAgICAgcmVzLnJqLnZhZGQoeGosIHJlcy5yaik7CiAgICAgICAgICAgICAgcmVzLnJqLnZzdWIoYmoucG9zaXRpb24sIHJlcy5yaik7CiAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyZXMpOwogICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyZXMsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB2M3Bvb2wucmVsZWFzZShlZGdlVGFuZ2VudCwgZWRnZUNlbnRlciwgciwgb3J0aG9nb25hbCwgZGlzdCk7CiAgICB9CgogICAgcGxhbmVCb3goc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7CiAgICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uaWQgPSBzai5pZDsKICAgICAgcmV0dXJuIHRoaXMucGxhbmVDb252ZXgoc2ksIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgY29udmV4Q29udmV4KHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0LCBmYWNlTGlzdEEsIGZhY2VMaXN0QikgewogICAgICBjb25zdCBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7CgogICAgICBpZiAoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAoc2kuZmluZFNlcGFyYXRpbmdBeGlzKHNqLCB4aSwgcWksIHhqLCBxaiwgc2VwQXhpcywgZmFjZUxpc3RBLCBmYWNlTGlzdEIpKSB7CiAgICAgICAgY29uc3QgcmVzID0gW107CiAgICAgICAgY29uc3QgcSA9IGNvbnZleENvbnZleF9xOwogICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSwgcWksIHNqLCB4aiwgcWosIHNlcEF4aXMsIC0xMDAsIDEwMCwgcmVzKTsKICAgICAgICBsZXQgbnVtQ29udGFjdHMgPSAwOwoKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gcmVzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICBjb25zdCByaSA9IHIucmk7CiAgICAgICAgICBjb25zdCByaiA9IHIucmo7CiAgICAgICAgICBzZXBBeGlzLm5lZ2F0ZShyLm5pKTsKICAgICAgICAgIHJlc1tqXS5ub3JtYWwubmVnYXRlKHEpOwogICAgICAgICAgcS5zY2FsZShyZXNbal0uZGVwdGgsIHEpOwogICAgICAgICAgcmVzW2pdLnBvaW50LnZhZGQocSwgcmkpOwogICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpOyAvLyBDb250YWN0IHBvaW50cyBhcmUgaW4gd29ybGQgY29vcmRpbmF0ZXMuIFRyYW5zZm9ybSBiYWNrIHRvIHJlbGF0aXZlCgogICAgICAgICAgcmkudnN1Yih4aSwgcmkpOwogICAgICAgICAgcmoudnN1Yih4aiwgcmopOyAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwoKICAgICAgICAgIHJpLnZhZGQoeGksIHJpKTsKICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTsKICAgICAgICAgIHJqLnZhZGQoeGosIHJqKTsKICAgICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTsKICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICBudW1Db250YWN0cysrOwoKICAgICAgICAgIGlmICghdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikgewogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiBudW1Db250YWN0cykgewogICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBzcGhlcmVDb252ZXgoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgY29uc3QgdjNwb29sID0gdGhpcy52M3Bvb2w7CiAgICAgIHhpLnZzdWIoeGosIGNvbnZleF90b19zcGhlcmUpOwogICAgICBjb25zdCBub3JtYWxzID0gc2ouZmFjZU5vcm1hbHM7CiAgICAgIGNvbnN0IGZhY2VzID0gc2ouZmFjZXM7CiAgICAgIGNvbnN0IHZlcnRzID0gc2oudmVydGljZXM7CiAgICAgIGNvbnN0IFIgPSBzaS5yYWRpdXM7CiAgICAgIC8vICAgICByZXR1cm47CiAgICAgIC8vIH0KCiAgICAgIGxldCBmb3VuZCA9IGZhbHNlOyAvLyBDaGVjayBjb3JuZXJzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gdmVydHNbaV07IC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lcgoKICAgICAgICBjb25zdCB3b3JsZENvcm5lciA9IHNwaGVyZUNvbnZleF93b3JsZENvcm5lcjsKICAgICAgICBxai52bXVsdCh2LCB3b3JsZENvcm5lcik7CiAgICAgICAgeGoudmFkZCh3b3JsZENvcm5lciwgd29ybGRDb3JuZXIpOwogICAgICAgIGNvbnN0IHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXI7CiAgICAgICAgd29ybGRDb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7CgogICAgICAgIGlmIChzcGhlcmVfdG9fY29ybmVyLmxlbmd0aFNxdWFyZWQoKSA8IFIgKiBSKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7CiAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpOwogICAgICAgICAgci5uaS5jb3B5KHIucmkpOwogICAgICAgICAgci5yaS5zY2FsZShSLCByLnJpKTsKICAgICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGosIHIucmopOyAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuCgogICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTsKICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopOwogICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsKICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICB9IC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zCgoKICAgICAgZm9yIChsZXQgaSA9IDAsIG5mYWNlcyA9IGZhY2VzLmxlbmd0aDsgaSAhPT0gbmZhY2VzICYmIGZvdW5kID09PSBmYWxzZTsgaSsrKSB7CiAgICAgICAgY29uc3Qgbm9ybWFsID0gbm9ybWFsc1tpXTsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbaV07IC8vIEdldCB3b3JsZC10cmFuc2Zvcm1lZCBub3JtYWwgb2YgdGhlIGZhY2UKCiAgICAgICAgY29uc3Qgd29ybGROb3JtYWwgPSBzcGhlcmVDb252ZXhfd29ybGROb3JtYWw7CiAgICAgICAgcWoudm11bHQobm9ybWFsLCB3b3JsZE5vcm1hbCk7IC8vIEdldCBhIHdvcmxkIHZlcnRleCBmcm9tIHRoZSBmYWNlCgogICAgICAgIGNvbnN0IHdvcmxkUG9pbnQgPSBzcGhlcmVDb252ZXhfd29ybGRQb2ludDsKICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWzBdXSwgd29ybGRQb2ludCk7CiAgICAgICAgd29ybGRQb2ludC52YWRkKHhqLCB3b3JsZFBvaW50KTsgLy8gR2V0IGEgcG9pbnQgb24gdGhlIHNwaGVyZSwgY2xvc2VzdCB0byB0aGUgZmFjZSBub3JtYWwKCiAgICAgICAgY29uc3Qgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gc3BoZXJlQ29udmV4X3dvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZTsKICAgICAgICB3b3JsZE5vcm1hbC5zY2FsZSgtUiwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTsKICAgICAgICB4aS52YWRkKHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTsgLy8gVmVjdG9yIGZyb20gYSBmYWNlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzcGhlcmUKCiAgICAgICAgY29uc3QgcGVuZXRyYXRpb25WZWMgPSBzcGhlcmVDb252ZXhfcGVuZXRyYXRpb25WZWM7CiAgICAgICAgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lLnZzdWIod29ybGRQb2ludCwgcGVuZXRyYXRpb25WZWMpOyAvLyBUaGUgcGVuZXRyYXRpb24uIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIG92ZXJsYXAuCgogICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb25WZWMuZG90KHdvcmxkTm9ybWFsKTsKICAgICAgICBjb25zdCB3b3JsZFBvaW50VG9TcGhlcmUgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Xb3JsZFBvaW50OwogICAgICAgIHhpLnZzdWIod29ybGRQb2ludCwgd29ybGRQb2ludFRvU3BoZXJlKTsKCiAgICAgICAgaWYgKHBlbmV0cmF0aW9uIDwgMCAmJiB3b3JsZFBvaW50VG9TcGhlcmUuZG90KHdvcmxkTm9ybWFsKSA+IDApIHsKICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayBpZiB0aGUgc3BoZXJlIGlzIGluc2lkZSB0aGUgZmFjZSBwb2x5Z29uCiAgICAgICAgICBjb25zdCBmYWNlVmVydHMgPSBbXTsgLy8gRmFjZSB2ZXJ0aWNlcywgaW4gd29ybGQgY29vcmRzCgogICAgICAgICAgZm9yIChsZXQgaiA9IDAsIE52ZXJ0cyA9IGZhY2UubGVuZ3RoOyBqICE9PSBOdmVydHM7IGorKykgewogICAgICAgICAgICBjb25zdCB3b3JsZFZlcnRleCA9IHYzcG9vbC5nZXQoKTsKICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVtqXV0sIHdvcmxkVmVydGV4KTsKICAgICAgICAgICAgeGoudmFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpOwogICAgICAgICAgICBmYWNlVmVydHMucHVzaCh3b3JsZFZlcnRleCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKHBvaW50SW5Qb2x5Z29uKGZhY2VWZXJ0cywgd29ybGROb3JtYWwsIHhpKSkgewogICAgICAgICAgICAvLyBJcyB0aGUgc3BoZXJlIGNlbnRlciBpbiB0aGUgZmFjZSBwb2x5Z29uPwogICAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUoLVIsIHIucmkpOyAvLyBDb250YWN0IG9mZnNldCwgZnJvbSBzcGhlcmUgY2VudGVyIHRvIGNvbnRhY3QKCiAgICAgICAgICAgIHdvcmxkTm9ybWFsLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHBvaW50aW5nIG91dCBvZiBzcGhlcmUKCiAgICAgICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uVmVjMiA9IHYzcG9vbC5nZXQoKTsKICAgICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUoLXBlbmV0cmF0aW9uLCBwZW5ldHJhdGlvblZlYzIpOwogICAgICAgICAgICBjb25zdCBwZW5ldHJhdGlvblNwaGVyZVBvaW50ID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICB3b3JsZE5vcm1hbC5zY2FsZSgtUiwgcGVuZXRyYXRpb25TcGhlcmVQb2ludCk7IC8veGkudnN1Yih4aikudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50KS52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopOwoKICAgICAgICAgICAgeGkudnN1Yih4aiwgci5yaik7CiAgICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50LCByLnJqKTsKICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uVmVjMiwgci5yaik7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7CiAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7CiAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uVmVjMik7CiAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQpOwogICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7IC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXMKCiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBOZmFjZXZlcnRzID0gZmFjZVZlcnRzLmxlbmd0aDsgaiAhPT0gTmZhY2V2ZXJ0czsgaisrKSB7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBvbmx5IGV4cGVjdCAqb25lKiBmYWNlIGNvbnRhY3QKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIEVkZ2U/CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBmYWNlLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgICAgLy8gR2V0IHR3byB3b3JsZCB0cmFuc2Zvcm1lZCB2ZXJ0aWNlcwogICAgICAgICAgICAgIGNvbnN0IHYxID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIGNvbnN0IHYyID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbKGogKyAxKSAlIGZhY2UubGVuZ3RoXV0sIHYxKTsKICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqICsgMikgJSBmYWNlLmxlbmd0aF1dLCB2Mik7CiAgICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpOwogICAgICAgICAgICAgIHhqLnZhZGQodjIsIHYyKTsgLy8gQ29uc3RydWN0IGVkZ2UgdmVjdG9yCgogICAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBzcGhlcmVDb252ZXhfZWRnZTsKICAgICAgICAgICAgICB2Mi52c3ViKHYxLCBlZGdlKTsgLy8gQ29uc3RydWN0IHRoZSBzYW1lIHZlY3RvciwgYnV0IG5vcm1hbGl6ZWQKCiAgICAgICAgICAgICAgY29uc3QgZWRnZVVuaXQgPSBzcGhlcmVDb252ZXhfZWRnZVVuaXQ7CiAgICAgICAgICAgICAgZWRnZS51bml0KGVkZ2VVbml0KTsgLy8gcCBpcyB4aSBwcm9qZWN0ZWQgb250byB0aGUgZWRnZQoKICAgICAgICAgICAgICBjb25zdCBwID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIGNvbnN0IHYxX3RvX3hpID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIHhpLnZzdWIodjEsIHYxX3RvX3hpKTsKICAgICAgICAgICAgICBjb25zdCBkb3QgPSB2MV90b194aS5kb3QoZWRnZVVuaXQpOwogICAgICAgICAgICAgIGVkZ2VVbml0LnNjYWxlKGRvdCwgcCk7CiAgICAgICAgICAgICAgcC52YWRkKHYxLCBwKTsgLy8gQ29tcHV0ZSBhIHZlY3RvciBmcm9tIHAgdG8gdGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlCgogICAgICAgICAgICAgIGNvbnN0IHhpX3RvX3AgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTsgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1cwogICAgICAgICAgICAgIC8vIEFORCBpZiBwIGlzIGluIGJldHdlZW4gdjEgYW5kIHYyCgogICAgICAgICAgICAgIGlmIChkb3QgPiAwICYmIGRvdCAqIGRvdCA8IGVkZ2UubGVuZ3RoU3F1YXJlZCgpICYmIHhpX3RvX3AubGVuZ3RoU3F1YXJlZCgpIDwgUiAqIFIpIHsKICAgICAgICAgICAgICAgIC8vIENvbGxpc2lvbiBpZiB0aGUgZWRnZS1zcGhlcmUgZGlzdGFuY2UgaXMgbGVzcyB0aGFuIHRoZSByYWRpdXMKICAgICAgICAgICAgICAgIC8vIEVkZ2UgY29udGFjdCEKICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICAgICAgICAgIHAudnN1Yih4aiwgci5yaik7CiAgICAgICAgICAgICAgICBwLnZzdWIoeGksIHIubmkpOwogICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICAgIHIubmkuc2NhbGUoUiwgci5yaSk7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopOwogICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LgoKICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7CiAgICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlcwoKICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBOZmFjZXZlcnRzID0gZmFjZVZlcnRzLmxlbmd0aDsgaiAhPT0gTmZhY2V2ZXJ0czsgaisrKSB7CiAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpOwogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpOwogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7CiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTsKICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTsKICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2Mik7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjFfdG9feGkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXMKCgogICAgICAgICAgZm9yIChsZXQgaiA9IDAsIE5mYWNldmVydHMgPSBmYWNlVmVydHMubGVuZ3RoOyBqICE9PSBOZmFjZXZlcnRzOyBqKyspIHsKICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBwbGFuZUNvbnZleChwbGFuZVNoYXBlLCBjb252ZXhTaGFwZSwgcGxhbmVQb3NpdGlvbiwgY29udmV4UG9zaXRpb24sIHBsYW5lUXVhdCwgY29udmV4UXVhdCwgcGxhbmVCb2R5LCBjb252ZXhCb2R5LCBzaSwgc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFNpbXBseSByZXR1cm4gdGhlIHBvaW50cyBiZWhpbmQgdGhlIHBsYW5lLgogICAgICBjb25zdCB3b3JsZFZlcnRleCA9IHBsYW5lQ29udmV4X3Y7CiAgICAgIGNvbnN0IHdvcmxkTm9ybWFsID0gcGxhbmVDb252ZXhfbm9ybWFsOwogICAgICB3b3JsZE5vcm1hbC5zZXQoMCwgMCwgMSk7CiAgICAgIHBsYW5lUXVhdC52bXVsdCh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmUgb3JpZW50YXRpb24KCiAgICAgIGxldCBudW1Db250YWN0cyA9IDA7CiAgICAgIGNvbnN0IHJlbHBvcyA9IHBsYW5lQ29udmV4X3JlbHBvczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBjb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKykgewogICAgICAgIC8vIEdldCB3b3JsZCBjb252ZXggdmVydGV4CiAgICAgICAgd29ybGRWZXJ0ZXguY29weShjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXSk7CiAgICAgICAgY29udmV4UXVhdC52bXVsdCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpOwogICAgICAgIGNvbnZleFBvc2l0aW9uLnZhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTsKICAgICAgICB3b3JsZFZlcnRleC52c3ViKHBsYW5lUG9zaXRpb24sIHJlbHBvcyk7CiAgICAgICAgY29uc3QgZG90ID0gd29ybGROb3JtYWwuZG90KHJlbHBvcyk7CgogICAgICAgIGlmIChkb3QgPD0gMC4wKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSwgY29udmV4Qm9keSwgcGxhbmVTaGFwZSwgY29udmV4U2hhcGUsIHNpLCBzaik7IC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lCgogICAgICAgICAgY29uc3QgcHJvamVjdGVkID0gcGxhbmVDb252ZXhfcHJvamVjdGVkOwogICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUod29ybGROb3JtYWwuZG90KHJlbHBvcyksIHByb2plY3RlZCk7CiAgICAgICAgICB3b3JsZFZlcnRleC52c3ViKHByb2plY3RlZCwgcHJvamVjdGVkKTsKICAgICAgICAgIHByb2plY3RlZC52c3ViKHBsYW5lUG9zaXRpb24sIHIucmkpOyAvLyBGcm9tIHBsYW5lIHRvIHZlcnRleCBwcm9qZWN0ZWQgb24gcGxhbmUKCiAgICAgICAgICByLm5pLmNvcHkod29ybGROb3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsIG91dCBmcm9tIHBsYW5lCiAgICAgICAgICAvLyByaiBpcyBub3cganVzdCB0aGUgdmVjdG9yIGZyb20gdGhlIGNvbnZleCBjZW50ZXIgdG8gdGhlIHZlcnRleAoKICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIoY29udmV4UG9zaXRpb24sIHIucmopOyAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5CgogICAgICAgICAgci5yaS52YWRkKHBsYW5lUG9zaXRpb24sIHIucmkpOwogICAgICAgICAgci5yaS52c3ViKHBsYW5lQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICByLnJqLnZhZGQoY29udmV4UG9zaXRpb24sIHIucmopOwogICAgICAgICAgci5yai52c3ViKGNvbnZleEJvZHkucG9zaXRpb24sIHIucmopOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIG51bUNvbnRhY3RzKys7CgogICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7CiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIG51bUNvbnRhY3RzKSB7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTsKICAgICAgfQogICAgfQoKICAgIGJveENvbnZleChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBzcGhlcmVIZWlnaHRmaWVsZChzcGhlcmVTaGFwZSwgaGZTaGFwZSwgc3BoZXJlUG9zLCBoZlBvcywgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBkYXRhID0gaGZTaGFwZS5kYXRhOwogICAgICBjb25zdCByYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXM7CiAgICAgIGNvbnN0IHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplOwogICAgICBjb25zdCB3b3JsZFBpbGxhck9mZnNldCA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDI7IC8vIEdldCBzcGhlcmUgcG9zaXRpb24gdG8gaGVpZ2h0ZmllbGQgbG9jYWwhCgogICAgICBjb25zdCBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDE7CiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBzcGhlcmVQb3MsIGxvY2FsU3BoZXJlUG9zKTsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0CgogICAgICBsZXQgaU1pblggPSBNYXRoLmZsb29yKChsb2NhbFNwaGVyZVBvcy54IC0gcmFkaXVzKSAvIHcpIC0gMTsKICAgICAgbGV0IGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy54ICsgcmFkaXVzKSAvIHcpICsgMTsKICAgICAgbGV0IGlNaW5ZID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueSAtIHJhZGl1cykgLyB3KSAtIDE7CiAgICAgIGxldCBpTWF4WSA9IE1hdGguY2VpbCgobG9jYWxTcGhlcmVQb3MueSArIHJhZGl1cykgLyB3KSArIDE7IC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW4KCiAgICAgIGlmIChpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBDbGFtcCBpbmRleCB0byBlZGdlcwoKCiAgICAgIGlmIChpTWluWCA8IDApIHsKICAgICAgICBpTWluWCA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WCA8IDApIHsKICAgICAgICBpTWF4WCA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWSA8IDApIHsKICAgICAgICBpTWluWSA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WSA8IDApIHsKICAgICAgICBpTWF4WSA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWCA+PSBkYXRhLmxlbmd0aCkgewogICAgICAgIGlNaW5YID0gZGF0YS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBpZiAoaU1heFggPj0gZGF0YS5sZW5ndGgpIHsKICAgICAgICBpTWF4WCA9IGRhdGEubGVuZ3RoIC0gMTsKICAgICAgfQoKICAgICAgaWYgKGlNYXhZID49IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgaU1heFkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWSA+PSBkYXRhWzBdLmxlbmd0aCkgewogICAgICAgIGlNaW5ZID0gZGF0YVswXS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBjb25zdCBtaW5NYXggPSBbXTsKICAgICAgaGZTaGFwZS5nZXRSZWN0TWluTWF4KGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCBtaW5NYXgpOwogICAgICBjb25zdCBtaW4gPSBtaW5NYXhbMF07CiAgICAgIGNvbnN0IG1heCA9IG1pbk1heFsxXTsgLy8gQmFpbCBvdXQgaWYgd2UgY2FuJ3QgdG91Y2ggdGhlIGJvdW5kaW5nIGhlaWdodCBib3gKCiAgICAgIGlmIChsb2NhbFNwaGVyZVBvcy56IC0gcmFkaXVzID4gbWF4IHx8IGxvY2FsU3BoZXJlUG9zLnogKyByYWRpdXMgPCBtaW4pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0OwoKICAgICAgZm9yIChsZXQgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspIHsKICAgICAgICAgIGNvbnN0IG51bUNvbnRhY3RzQmVmb3JlID0gcmVzdWx0Lmxlbmd0aDsKICAgICAgICAgIGxldCBpbnRlcnNlY3RpbmcgPSBmYWxzZTsgLy8gTG93ZXIgdHJpYW5nbGUKCiAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBqdXN0VGVzdCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZykgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0gLy8gVXBwZXIgdHJpYW5nbGUKCgogICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBqdXN0VGVzdCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZykgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCBudW1Db250YWN0cyA9IHJlc3VsdC5sZW5ndGggLSBudW1Db250YWN0c0JlZm9yZTsKCiAgICAgICAgICBpZiAobnVtQ29udGFjdHMgPiAyKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIC8qCiAgICAgICAgICAgIC8vIFNraXAgYWxsIGJ1dCAxCiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbnVtQ29udGFjdHMgLSAxOyBrKyspIHsKICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgKi8KCiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgYm94SGVpZ2h0ZmllbGQoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICByZXR1cm4gdGhpcy5jb252ZXhIZWlnaHRmaWVsZChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBjb252ZXhIZWlnaHRmaWVsZChjb252ZXhTaGFwZSwgaGZTaGFwZSwgY29udmV4UG9zLCBoZlBvcywgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBkYXRhID0gaGZTaGFwZS5kYXRhOwogICAgICBjb25zdCB3ID0gaGZTaGFwZS5lbGVtZW50U2l6ZTsKICAgICAgY29uc3QgcmFkaXVzID0gY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXM7CiAgICAgIGNvbnN0IHdvcmxkUGlsbGFyT2Zmc2V0ID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMjsKICAgICAgY29uc3QgZmFjZUxpc3QgPSBjb252ZXhIZWlnaHRmaWVsZF9mYWNlTGlzdDsgLy8gR2V0IHNwaGVyZSBwb3NpdGlvbiB0byBoZWlnaHRmaWVsZCBsb2NhbCEKCiAgICAgIGNvbnN0IGxvY2FsQ29udmV4UG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMTsKICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKGhmUG9zLCBoZlF1YXQsIGNvbnZleFBvcywgbG9jYWxDb252ZXhQb3MpOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3QKCiAgICAgIGxldCBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnggLSByYWRpdXMpIC8gdykgLSAxOwogICAgICBsZXQgaU1heFggPSBNYXRoLmNlaWwoKGxvY2FsQ29udmV4UG9zLnggKyByYWRpdXMpIC8gdykgKyAxOwogICAgICBsZXQgaU1pblkgPSBNYXRoLmZsb29yKChsb2NhbENvbnZleFBvcy55IC0gcmFkaXVzKSAvIHcpIC0gMTsKICAgICAgbGV0IGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTsgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpbgoKICAgICAgaWYgKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWluWSA+IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzCgoKICAgICAgaWYgKGlNaW5YIDwgMCkgewogICAgICAgIGlNaW5YID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNYXhYIDwgMCkgewogICAgICAgIGlNYXhYID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNaW5ZIDwgMCkgewogICAgICAgIGlNaW5ZID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNYXhZIDwgMCkgewogICAgICAgIGlNYXhZID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNaW5YID49IGRhdGEubGVuZ3RoKSB7CiAgICAgICAgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WCA+PSBkYXRhLmxlbmd0aCkgewogICAgICAgIGlNYXhYID0gZGF0YS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBpZiAoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpIHsKICAgICAgICBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsKICAgICAgfQoKICAgICAgaWYgKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGNvbnN0IG1pbk1heCA9IFtdOwogICAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7CiAgICAgIGNvbnN0IG1pbiA9IG1pbk1heFswXTsKICAgICAgY29uc3QgbWF4ID0gbWluTWF4WzFdOyAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94CgogICAgICBpZiAobG9jYWxDb252ZXhQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbENvbnZleFBvcy56ICsgcmFkaXVzIDwgbWluKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKykgewogICAgICAgICAgbGV0IGludGVyc2VjdGluZyA9IGZhbHNlOyAvLyBMb3dlciB0cmlhbmdsZQoKICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwganVzdFRlc3QsIGZhY2VMaXN0LCBudWxsKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSAvLyBVcHBlciB0cmlhbmdsZQoKCiAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwganVzdFRlc3QsIGZhY2VMaXN0LCBudWxsKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIHNwaGVyZVBhcnRpY2xlKHNqLCBzaSwgeGosIHhpLCBxaiwgcWksIGJqLCBiaSwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFRoZSBub3JtYWwgaXMgdGhlIHVuaXQgdmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBwYXJ0aWNsZSBjZW50ZXIKICAgICAgY29uc3Qgbm9ybWFsID0gcGFydGljbGVTcGhlcmVfbm9ybWFsOwogICAgICBub3JtYWwuc2V0KDAsIDAsIDEpOwogICAgICB4aS52c3ViKHhqLCBub3JtYWwpOwogICAgICBjb25zdCBsZW5ndGhTcXVhcmVkID0gbm9ybWFsLmxlbmd0aFNxdWFyZWQoKTsKCiAgICAgIGlmIChsZW5ndGhTcXVhcmVkIDw9IHNqLnJhZGl1cyAqIHNqLnJhZGl1cykgewogICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQoKICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7CiAgICAgICAgci5yai5jb3B5KG5vcm1hbCk7CiAgICAgICAgci5yai5zY2FsZShzai5yYWRpdXMsIHIucmopOwogICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsKICAgICAgICByLnJpLnNldCgwLCAwLCAwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlCgogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9CiAgICB9CgogICAgcGxhbmVQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBub3JtYWwgPSBwYXJ0aWNsZVBsYW5lX25vcm1hbDsKICAgICAgbm9ybWFsLnNldCgwLCAwLCAxKTsKICAgICAgYmoucXVhdGVybmlvbi52bXVsdChub3JtYWwsIG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZSBvcmllbnRhdGlvbgoKICAgICAgY29uc3QgcmVscG9zID0gcGFydGljbGVQbGFuZV9yZWxwb3M7CiAgICAgIHhpLnZzdWIoYmoucG9zaXRpb24sIHJlbHBvcyk7CiAgICAgIGNvbnN0IGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTsKCiAgICAgIGlmIChkb3QgPD0gMC4wKSB7CiAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsCgogICAgICAgIHIubmkubmVnYXRlKHIubmkpOwogICAgICAgIHIucmkuc2V0KDAsIDAsIDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGUKICAgICAgICAvLyBHZXQgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lCgogICAgICAgIGNvbnN0IHByb2plY3RlZCA9IHBhcnRpY2xlUGxhbmVfcHJvamVjdGVkOwogICAgICAgIG5vcm1hbC5zY2FsZShub3JtYWwuZG90KHhpKSwgcHJvamVjdGVkKTsKICAgICAgICB4aS52c3ViKHByb2plY3RlZCwgcHJvamVjdGVkKTsgLy9wcm9qZWN0ZWQudmFkZChiai5wb3NpdGlvbixwcm9qZWN0ZWQpOwogICAgICAgIC8vIHJqIGlzIG5vdyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uCgogICAgICAgIHIucmouY29weShwcm9qZWN0ZWQpOwogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9CiAgICB9CgogICAgYm94UGFydGljbGUoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICByZXR1cm4gdGhpcy5jb252ZXhQYXJ0aWNsZShzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBjb252ZXhQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBsZXQgcGVuZXRyYXRlZEZhY2VJbmRleCA9IC0xOwogICAgICBjb25zdCBwZW5ldHJhdGVkRmFjZU5vcm1hbCA9IGNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsOwogICAgICBjb25zdCB3b3JsZFBlbmV0cmF0aW9uVmVjID0gY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYzsKICAgICAgbGV0IG1pblBlbmV0cmF0aW9uID0gbnVsbDsKCiAgICAgIGNvbnN0IGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7CiAgICAgIGxvY2FsLmNvcHkoeGkpOwogICAgICBsb2NhbC52c3ViKHhqLCBsb2NhbCk7IC8vIENvbnZlcnQgcG9zaXRpb24gdG8gcmVsYXRpdmUgdGhlIGNvbnZleCBvcmlnaW4KCiAgICAgIHFqLmNvbmp1Z2F0ZShjcWopOwogICAgICBjcWoudm11bHQobG9jYWwsIGxvY2FsKTsKCiAgICAgIGlmIChzai5wb2ludElzSW5zaWRlKGxvY2FsKSkgewogICAgICAgIGlmIChzai53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUpIHsKICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHhqLCBxaik7CiAgICAgICAgfQoKICAgICAgICBpZiAoc2oud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlKSB7CiAgICAgICAgICBzai5jb21wdXRlV29ybGRGYWNlTm9ybWFscyhxaik7CiAgICAgICAgfSAvLyBGb3IgZWFjaCB3b3JsZCBwb2x5Z29uIGluIHRoZSBwb2x5aGVkcmEKCgogICAgICAgIGZvciAobGV0IGkgPSAwLCBuZmFjZXMgPSBzai5mYWNlcy5sZW5ndGg7IGkgIT09IG5mYWNlczsgaSsrKSB7CiAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlcwogICAgICAgICAgY29uc3QgdmVydHMgPSBbc2oud29ybGRWZXJ0aWNlc1tzai5mYWNlc1tpXVswXV1dOwogICAgICAgICAgY29uc3Qgbm9ybWFsID0gc2oud29ybGRGYWNlTm9ybWFsc1tpXTsgLy8gQ2hlY2sgaG93IG11Y2ggdGhlIHBhcnRpY2xlIHBlbmV0cmF0ZXMgdGhlIHBvbHlnb24gcGxhbmUuCgogICAgICAgICAgeGkudnN1Yih2ZXJ0c1swXSwgY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7CiAgICAgICAgICBjb25zdCBwZW5ldHJhdGlvbiA9IC1ub3JtYWwuZG90KGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUpOwoKICAgICAgICAgIGlmIChtaW5QZW5ldHJhdGlvbiA9PT0gbnVsbCB8fCBNYXRoLmFicyhwZW5ldHJhdGlvbikgPCBNYXRoLmFicyhtaW5QZW5ldHJhdGlvbikpIHsKICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIG1pblBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247CiAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSBpOwogICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5jb3B5KG5vcm1hbCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAocGVuZXRyYXRlZEZhY2VJbmRleCAhPT0gLTEpIHsKICAgICAgICAgIC8vIFNldHVwIGNvbnRhY3QKICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwuc2NhbGUobWluUGVuZXRyYXRpb24sIHdvcmxkUGVuZXRyYXRpb25WZWMpOyAvLyByaiBpcyB0aGUgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIHRvIHRoZSBmYWNlCgogICAgICAgICAgd29ybGRQZW5ldHJhdGlvblZlYy52YWRkKHhpLCB3b3JsZFBlbmV0cmF0aW9uVmVjKTsKICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aiwgd29ybGRQZW5ldHJhdGlvblZlYyk7CiAgICAgICAgICByLnJqLmNvcHkod29ybGRQZW5ldHJhdGlvblZlYyk7IC8vY29uc3QgcHJvamVjdGVkVG9GYWNlID0geGkudnN1Yih4aikudmFkZCh3b3JsZFBlbmV0cmF0aW9uVmVjKTsKICAgICAgICAgIC8vcHJvamVjdGVkVG9GYWNlLmNvcHkoci5yaik7CiAgICAgICAgICAvL3FqLnZtdWx0KHIucmosci5yaik7CgogICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwubmVnYXRlKHIubmkpOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgICAgIHIucmkuc2V0KDAsIDAsIDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGUKCiAgICAgICAgICBjb25zdCByaSA9IHIucmk7CiAgICAgICAgICBjb25zdCByaiA9IHIucmo7IC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzCgogICAgICAgICAgcmkudmFkZCh4aSwgcmkpOwogICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpOwogICAgICAgICAgcmoudmFkZCh4aiwgcmopOwogICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc29sZS53YXJuKCdQb2ludCBmb3VuZCBpbnNpZGUgY29udmV4LCBidXQgZGlkIG5vdCBmaW5kIHBlbmV0cmF0aW5nIGZhY2UhJyk7CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgaGVpZ2h0ZmllbGRDeWxpbmRlcihoZlNoYXBlLCBjb252ZXhTaGFwZSwgaGZQb3MsIGNvbnZleFBvcywgaGZRdWF0LCBjb252ZXhRdWF0LCBoZkJvZHksIGNvbnZleEJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhIZWlnaHRmaWVsZChjb252ZXhTaGFwZSwgaGZTaGFwZSwgY29udmV4UG9zLCBoZlBvcywgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgcGFydGljbGVDeWxpbmRlcihzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgc3BoZXJlVHJpbWVzaChzcGhlcmVTaGFwZSwgdHJpbWVzaFNoYXBlLCBzcGhlcmVQb3MsIHRyaW1lc2hQb3MsIHNwaGVyZVF1YXQsIHRyaW1lc2hRdWF0LCBzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGNvbnN0IGVkZ2VWZXJ0ZXhBID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QTsKICAgICAgY29uc3QgZWRnZVZlcnRleEIgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCOwogICAgICBjb25zdCBlZGdlVmVjdG9yID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yOwogICAgICBjb25zdCBlZGdlVmVjdG9yVW5pdCA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQ7CiAgICAgIGNvbnN0IGxvY2FsU3BoZXJlUG9zID0gc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZVBvczsKICAgICAgY29uc3QgdG1wID0gc3BoZXJlVHJpbWVzaF90bXA7CiAgICAgIGNvbnN0IGxvY2FsU3BoZXJlQUFCQiA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVBQUJCOwogICAgICBjb25zdCB2MiA9IHNwaGVyZVRyaW1lc2hfdjI7CiAgICAgIGNvbnN0IHJlbHBvcyA9IHNwaGVyZVRyaW1lc2hfcmVscG9zOwogICAgICBjb25zdCB0cmlhbmdsZXMgPSBzcGhlcmVUcmltZXNoX3RyaWFuZ2xlczsgLy8gQ29udmVydCBzcGhlcmUgcG9zaXRpb24gdG8gbG9jYWwgaW4gdGhlIHRyaW1lc2gKCiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgc3BoZXJlUG9zLCBsb2NhbFNwaGVyZVBvcyk7IC8vIEdldCB0aGUgYWFiYiBvZiB0aGUgc3BoZXJlIGxvY2FsbHkgaW4gdGhlIHRyaW1lc2gKCiAgICAgIGNvbnN0IHNwaGVyZVJhZGl1cyA9IHNwaGVyZVNoYXBlLnJhZGl1czsKICAgICAgbG9jYWxTcGhlcmVBQUJCLmxvd2VyQm91bmQuc2V0KGxvY2FsU3BoZXJlUG9zLnggLSBzcGhlcmVSYWRpdXMsIGxvY2FsU3BoZXJlUG9zLnkgLSBzcGhlcmVSYWRpdXMsIGxvY2FsU3BoZXJlUG9zLnogLSBzcGhlcmVSYWRpdXMpOwogICAgICBsb2NhbFNwaGVyZUFBQkIudXBwZXJCb3VuZC5zZXQobG9jYWxTcGhlcmVQb3MueCArIHNwaGVyZVJhZGl1cywgbG9jYWxTcGhlcmVQb3MueSArIHNwaGVyZVJhZGl1cywgbG9jYWxTcGhlcmVQb3MueiArIHNwaGVyZVJhZGl1cyk7CiAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZXNJbkFBQkIobG9jYWxTcGhlcmVBQUJCLCB0cmlhbmdsZXMpOyAvL2ZvciAobGV0IGkgPSAwOyBpIDwgdHJpbWVzaFNoYXBlLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB0cmlhbmdsZXMucHVzaChpKTsgLy8gQWxsCiAgICAgIC8vIFZlcnRpY2VzCgogICAgICBjb25zdCB2ID0gc3BoZXJlVHJpbWVzaF92OwogICAgICBjb25zdCByYWRpdXNTcXVhcmVkID0gc3BoZXJlU2hhcGUucmFkaXVzICogc3BoZXJlU2hhcGUucmFkaXVzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykgewogICAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgal0sIHYpOyAvLyBDaGVjayB2ZXJ0ZXggb3ZlcmxhcCBpbiBzcGhlcmUKCiAgICAgICAgICB2LnZzdWIobG9jYWxTcGhlcmVQb3MsIHJlbHBvcyk7CgogICAgICAgICAgaWYgKHJlbHBvcy5sZW5ndGhTcXVhcmVkKCkgPD0gcmFkaXVzU3F1YXJlZCkgewogICAgICAgICAgICAvLyBTYWZlIHVwCiAgICAgICAgICAgIHYyLmNvcHkodik7CiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpOwogICAgICAgICAgICB2LnZzdWIoc3BoZXJlUG9zLCByZWxwb3MpOwoKICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGxldCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUsIHJzaSwgcnNqKTsKICAgICAgICAgICAgci5uaS5jb3B5KHJlbHBvcyk7CiAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7IC8vIHJpIGlzIHRoZSB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHRoZSBzcGhlcmUgc3VyZmFjZQoKICAgICAgICAgICAgci5yaS5jb3B5KHIubmkpOwogICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7CiAgICAgICAgICAgIHIucmkudmFkZChzcGhlcmVQb3MsIHIucmkpOwogICAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgIHIucmouY29weSh2KTsKICAgICAgICAgICAgci5yai52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTsgLy8gU3RvcmUgcmVzdWx0CgogICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIENoZWNrIGFsbCBlZGdlcwoKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHsKICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCBlZGdlVmVydGV4QSk7CiAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyAoaiArIDEpICUgM10sIGVkZ2VWZXJ0ZXhCKTsKICAgICAgICAgIGVkZ2VWZXJ0ZXhCLnZzdWIoZWRnZVZlcnRleEEsIGVkZ2VWZWN0b3IpOyAvLyBQcm9qZWN0IHNwaGVyZSBwb3NpdGlvbiB0byB0aGUgZWRnZQoKICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7CiAgICAgICAgICBjb25zdCBwb3NpdGlvbkFsb25nRWRnZUIgPSB0bXAuZG90KGVkZ2VWZWN0b3IpOwogICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTsKICAgICAgICAgIGxldCBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpOwoKICAgICAgICAgIGlmIChwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApIHsKICAgICAgICAgICAgLy8gTm93IGNoZWNrIHRoZSBvcnRob2dvbmFsIGRpc3RhbmNlIGZyb20gZWRnZSB0byBzcGhlcmUgY2VudGVyCiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEEsIHRtcCk7CiAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0LmNvcHkoZWRnZVZlY3Rvcik7CiAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0Lm5vcm1hbGl6ZSgpOwogICAgICAgICAgICBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3JVbml0KTsKICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQuc2NhbGUocG9zaXRpb25BbG9uZ0VkZ2VBLCB0bXApOwogICAgICAgICAgICB0bXAudmFkZChlZGdlVmVydGV4QSwgdG1wKTsgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIGNlbnRlciBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2UsIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgdHJpbWVzaCBmcmFtZQoKICAgICAgICAgICAgY29uc3QgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTsKCiAgICAgICAgICAgIGlmIChkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKSB7CiAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgcnNpLCByc2opOwogICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTsKICAgICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZhZGQoc3BoZXJlUG9zLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7CiAgICAgICAgICAgICAgdG1wLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopOwogICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIubmksIHIubmkpOwogICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpOwogICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIFRyaWFuZ2xlIGZhY2VzCgoKICAgICAgY29uc3QgdmEgPSBzcGhlcmVUcmltZXNoX3ZhOwogICAgICBjb25zdCB2YiA9IHNwaGVyZVRyaW1lc2hfdmI7CiAgICAgIGNvbnN0IHZjID0gc3BoZXJlVHJpbWVzaF92YzsKICAgICAgY29uc3Qgbm9ybWFsID0gc3BoZXJlVHJpbWVzaF9ub3JtYWw7CgogICAgICBmb3IgKGxldCBpID0gMCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgIT09IE47IGkrKykgewogICAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZVZlcnRpY2VzKHRyaWFuZ2xlc1tpXSwgdmEsIHZiLCB2Yyk7CiAgICAgICAgdHJpbWVzaFNoYXBlLmdldE5vcm1hbCh0cmlhbmdsZXNbaV0sIG5vcm1hbCk7CiAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1Yih2YSwgdG1wKTsKICAgICAgICBsZXQgZGlzdCA9IHRtcC5kb3Qobm9ybWFsKTsKICAgICAgICBub3JtYWwuc2NhbGUoZGlzdCwgdG1wKTsKICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHRtcCwgdG1wKTsgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgdHJpYW5nbGUgcGxhbmUKCiAgICAgICAgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTsKCiAgICAgICAgaWYgKFJheS5wb2ludEluVHJpYW5nbGUodG1wLCB2YSwgdmIsIHZjKSAmJiBkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgbGV0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgcnNpLCByc2opOwogICAgICAgICAgdG1wLnZzdWIobG9jYWxTcGhlcmVQb3MsIHIubmkpOwogICAgICAgICAgci5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTsKICAgICAgICAgIHIucmkudmFkZChzcGhlcmVQb3MsIHIucmkpOwogICAgICAgICAgci5yaS52c3ViKHNwaGVyZUJvZHkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7CiAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7CiAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLm5pLCByLm5pKTsKICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwOwogICAgfQoKICAgIHBsYW5lVHJpbWVzaChwbGFuZVNoYXBlLCB0cmltZXNoU2hhcGUsIHBsYW5lUG9zLCB0cmltZXNoUG9zLCBwbGFuZVF1YXQsIHRyaW1lc2hRdWF0LCBwbGFuZUJvZHksIHRyaW1lc2hCb2R5LCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgLy8gTWFrZSBjb250YWN0cyEKICAgICAgY29uc3QgdiA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IG5vcm1hbCA9IHBsYW5lVHJpbWVzaF9ub3JtYWw7CiAgICAgIG5vcm1hbC5zZXQoMCwgMCwgMSk7CiAgICAgIHBsYW5lUXVhdC52bXVsdChub3JtYWwsIG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmltZXNoU2hhcGUudmVydGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgLy8gR2V0IHdvcmxkIHZlcnRleCBmcm9tIHRyaW1lc2gKICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KGksIHYpOyAvLyBTYWZlIHVwCgogICAgICAgIGNvbnN0IHYyID0gbmV3IFZlYzMoKTsKICAgICAgICB2Mi5jb3B5KHYpOwogICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpOyAvLyBDaGVjayBwbGFuZSBzaWRlCgogICAgICAgIGNvbnN0IHJlbHBvcyA9IHBsYW5lVHJpbWVzaF9yZWxwb3M7CiAgICAgICAgdi52c3ViKHBsYW5lUG9zLCByZWxwb3MpOwogICAgICAgIGNvbnN0IGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTsKCiAgICAgICAgaWYgKGRvdCA8PSAwLjApIHsKICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCB0cmltZXNoQm9keSwgcGxhbmVTaGFwZSwgdHJpbWVzaFNoYXBlLCByc2ksIHJzaik7CiAgICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbAogICAgICAgICAgLy8gR2V0IHZlcnRleCBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmUKCiAgICAgICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwbGFuZVRyaW1lc2hfcHJvamVjdGVkOwogICAgICAgICAgbm9ybWFsLnNjYWxlKHJlbHBvcy5kb3Qobm9ybWFsKSwgcHJvamVjdGVkKTsKICAgICAgICAgIHYudnN1Yihwcm9qZWN0ZWQsIHByb2plY3RlZCk7IC8vIHJpIGlzIHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb24KCiAgICAgICAgICByLnJpLmNvcHkocHJvamVjdGVkKTsKICAgICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgci5yai5jb3B5KHYpOwogICAgICAgICAgci5yai52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTsgLy8gU3RvcmUgcmVzdWx0CgogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gLy8gY29udmV4VHJpbWVzaCgKICAgIC8vICAgc2k6IENvbnZleFBvbHloZWRyb24sIHNqOiBUcmltZXNoLCB4aTogVmVjMywgeGo6IFZlYzMsIHFpOiBRdWF0ZXJuaW9uLCBxajogUXVhdGVybmlvbiwKICAgIC8vICAgYmk6IEJvZHksIGJqOiBCb2R5LCByc2k/OiBTaGFwZSB8IG51bGwsIHJzaj86IFNoYXBlIHwgbnVsbCwKICAgIC8vICAgZmFjZUxpc3RBPzogbnVtYmVyW10gfCBudWxsLCBmYWNlTGlzdEI/OiBudW1iZXJbXSB8IG51bGwsCiAgICAvLyApIHsKICAgIC8vICAgY29uc3Qgc2VwQXhpcyA9IGNvbnZleENvbnZleF9zZXBBeGlzOwogICAgLy8gICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpewogICAgLy8gICAgICAgcmV0dXJuOwogICAgLy8gICB9CiAgICAvLyAgIC8vIENvbnN0cnVjdCBhIHRlbXAgaHVsbCBmb3IgZWFjaCB0cmlhbmdsZQogICAgLy8gICBjb25zdCBodWxsQiA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAvLyAgIGh1bGxCLmZhY2VzID0gW1swLDEsMl1dOwogICAgLy8gICBjb25zdCB2YSA9IG5ldyBWZWMzKCk7CiAgICAvLyAgIGNvbnN0IHZiID0gbmV3IFZlYzMoKTsKICAgIC8vICAgY29uc3QgdmMgPSBuZXcgVmVjMygpOwogICAgLy8gICBodWxsQi52ZXJ0aWNlcyA9IFsKICAgIC8vICAgICAgIHZhLAogICAgLy8gICAgICAgdmIsCiAgICAvLyAgICAgICB2YwogICAgLy8gICBdOwogICAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IHNqLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAvLyAgICAgICBjb25zdCB0cmlhbmdsZU5vcm1hbCA9IG5ldyBWZWMzKCk7CiAgICAvLyAgICAgICBzai5nZXROb3JtYWwoaSwgdHJpYW5nbGVOb3JtYWwpOwogICAgLy8gICAgICAgaHVsbEIuZmFjZU5vcm1hbHMgPSBbdHJpYW5nbGVOb3JtYWxdOwogICAgLy8gICAgICAgc2ouZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCB2YSwgdmIsIHZjKTsKICAgIC8vICAgICAgIGxldCBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7CiAgICAvLyAgICAgICBpZighZCl7CiAgICAvLyAgICAgICAgICAgdHJpYW5nbGVOb3JtYWwuc2NhbGUoLTEsIHRyaWFuZ2xlTm9ybWFsKTsKICAgIC8vICAgICAgICAgICBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7CiAgICAvLyAgICAgICAgICAgaWYoIWQpewogICAgLy8gICAgICAgICAgICAgICBjb250aW51ZTsKICAgIC8vICAgICAgICAgICB9CiAgICAvLyAgICAgICB9CiAgICAvLyAgICAgICBjb25zdCByZXM6IENvbnZleFBvbHloZWRyb25Db250YWN0UG9pbnRbXSA9IFtdOwogICAgLy8gICAgICAgY29uc3QgcSA9IGNvbnZleENvbnZleF9xOwogICAgLy8gICAgICAgc2kuY2xpcEFnYWluc3RIdWxsKHhpLHFpLGh1bGxCLHhqLHFqLHRyaWFuZ2xlTm9ybWFsLC0xMDAsMTAwLHJlcyk7CiAgICAvLyAgICAgICBmb3IobGV0IGogPSAwOyBqICE9PSByZXMubGVuZ3RoOyBqKyspewogICAgLy8gICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKSwKICAgIC8vICAgICAgICAgICAgICAgcmkgPSByLnJpLAogICAgLy8gICAgICAgICAgICAgICByaiA9IHIucmo7CiAgICAvLyAgICAgICAgICAgci5uaS5jb3B5KHRyaWFuZ2xlTm9ybWFsKTsKICAgIC8vICAgICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsKICAgIC8vICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTsKICAgIC8vICAgICAgICAgICBxLm11bHQocmVzW2pdLmRlcHRoLCBxKTsKICAgIC8vICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7CiAgICAvLyAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpOwogICAgLy8gICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmUKICAgIC8vICAgICAgICAgICByaS52c3ViKHhpLHJpKTsKICAgIC8vICAgICAgICAgICByai52c3ViKHhqLHJqKTsKICAgIC8vICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwogICAgLy8gICAgICAgICAgIHJpLnZhZGQoeGksIHJpKTsKICAgIC8vICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7CiAgICAvLyAgICAgICAgICAgcmoudmFkZCh4aiwgcmopOwogICAgLy8gICAgICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTsKICAgIC8vICAgICAgICAgICByZXN1bHQucHVzaChyKTsKICAgIC8vICAgICAgIH0KICAgIC8vICAgfQogICAgLy8gfQoKCiAgfQogIGNvbnN0IGF2ZXJhZ2VOb3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IGF2ZXJhZ2VDb250YWN0UG9pbnRBID0gbmV3IFZlYzMoKTsKICBjb25zdCBhdmVyYWdlQ29udGFjdFBvaW50QiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wUXVhdDEgPSBuZXcgUXVhdGVybmlvbigpOwogIGNvbnN0IHRtcFF1YXQyID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgY29uc3QgcGxhbmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVUcmltZXNoX3JlbHBvcyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfdiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92MiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3JVbml0ID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlUG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX3RtcCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YyA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZUFBQkIgPSBuZXcgQUFCQigpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfdHJpYW5nbGVzID0gW107CiAgY29uc3QgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTsKICBjb25zdCBwbGFuZV90b19zcGhlcmVfb3J0aG8gPSBuZXcgVmVjMygpOyAvLyBTZWUgaHR0cDovL2J1bGxldHBoeXNpY3MuY29tL0J1bGxldC9CdWxsZXRGdWxsL1NwaGVyZVRyaWFuZ2xlRGV0ZWN0b3JfOGNwcF9zb3VyY2UuaHRtbAoKICBjb25zdCBwb2ludEluUG9seWdvbl9lZGdlID0gbmV3IFZlYzMoKTsKICBjb25zdCBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBwb2ludEluUG9seWdvbl92dHAgPSBuZXcgVmVjMygpOwoKICBmdW5jdGlvbiBwb2ludEluUG9seWdvbih2ZXJ0cywgbm9ybWFsLCBwKSB7CiAgICBsZXQgcG9zaXRpdmVSZXN1bHQgPSBudWxsOwogICAgY29uc3QgTiA9IHZlcnRzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgIGNvbnN0IHYgPSB2ZXJ0c1tpXTsgLy8gR2V0IGVkZ2UgdG8gdGhlIG5leHQgdmVydGV4CgogICAgICBjb25zdCBlZGdlID0gcG9pbnRJblBvbHlnb25fZWRnZTsKICAgICAgdmVydHNbKGkgKyAxKSAlIE5dLnZzdWIodiwgZWRnZSk7IC8vIEdldCBjcm9zcyBwcm9kdWN0IGJldHdlZW4gcG9seWdvbiBub3JtYWwgYW5kIHRoZSBlZGdlCgogICAgICBjb25zdCBlZGdlX3hfbm9ybWFsID0gcG9pbnRJblBvbHlnb25fZWRnZV94X25vcm1hbDsgLy9jb25zdCBlZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTsKCiAgICAgIGVkZ2UuY3Jvc3Mobm9ybWFsLCBlZGdlX3hfbm9ybWFsKTsgLy8gR2V0IHZlY3RvciBiZXR3ZWVuIHBvaW50IGFuZCBjdXJyZW50IHZlcnRleAoKICAgICAgY29uc3QgdmVydGV4X3RvX3AgPSBwb2ludEluUG9seWdvbl92dHA7CiAgICAgIHAudnN1Yih2LCB2ZXJ0ZXhfdG9fcCk7IC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpcwoKICAgICAgY29uc3QgciA9IGVkZ2VfeF9ub3JtYWwuZG90KHZlcnRleF90b19wKTsgLy8gSWYgYWxsIHN1Y2ggZG90IHByb2R1Y3RzIGhhdmUgc2FtZSBzaWduLCB3ZSBhcmUgaW5zaWRlIHRoZSBwb2x5Z29uLgoKICAgICAgaWYgKHBvc2l0aXZlUmVzdWx0ID09PSBudWxsIHx8IHIgPiAwICYmIHBvc2l0aXZlUmVzdWx0ID09PSB0cnVlIHx8IHIgPD0gMCAmJiBwb3NpdGl2ZVJlc3VsdCA9PT0gZmFsc2UpIHsKICAgICAgICBpZiAocG9zaXRpdmVSZXN1bHQgPT09IG51bGwpIHsKICAgICAgICAgIHBvc2l0aXZlUmVzdWx0ID0gciA+IDA7CiAgICAgICAgfQoKICAgICAgICBjb250aW51ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC4KICAgICAgfQogICAgfSAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uCgoKICAgIHJldHVybiB0cnVlOwogIH0KCiAgY29uc3QgYm94X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQm94X25zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfbnMxID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfbnMyID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfc2lkZXMgPSBbbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKV07CiAgY29uc3Qgc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUJveF9zaWRlX25zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfc2lkZV9uczEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUJveF9zaWRlX25zMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY29udmV4X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X2VkZ2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludCA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHBsYW5lQ29udmV4X3YgPSBuZXcgVmVjMygpOwogIGNvbnN0IHBsYW5lQ29udmV4X25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVDb252ZXhfcmVscG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBwbGFuZUNvbnZleF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleENvbnZleF9zZXBBeGlzID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb252ZXhDb252ZXhfcSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGFydGljbGVQbGFuZV9ub3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHBhcnRpY2xlUGxhbmVfcmVscG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGFydGljbGVTcGhlcmVfbm9ybWFsID0gbmV3IFZlYzMoKTsgLy8gV0lQCgogIGNvbnN0IGNxaiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgY29uc3QgY29udmV4UGFydGljbGVfbG9jYWwgPSBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgY29uc3QgY29udmV4UGFydGljbGVfcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWMgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX3RtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX3RtcDIgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0ID0gWzBdOwogIGNvbnN0IHNwaGVyZUhlaWdodGZpZWxkX3RtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUhlaWdodGZpZWxkX3RtcDIgPSBuZXcgVmVjMygpOwoKICBjbGFzcyBPdmVybGFwS2VlcGVyIHsKICAgIC8qKgogICAgICogQHRvZG8gUmVtb3ZlIHVzZWxlc3MgY29uc3RydWN0b3IKICAgICAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMuY3VycmVudCA9IFtdOwogICAgICB0aGlzLnByZXZpb3VzID0gW107CiAgICB9CiAgICAvKioKICAgICAqIGdldEtleQogICAgICovCgoKICAgIGdldEtleShpLCBqKSB7CiAgICAgIGlmIChqIDwgaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICByZXR1cm4gaSA8PCAxNiB8IGo7CiAgICB9CiAgICAvKioKICAgICAqIHNldAogICAgICovCgoKICAgIHNldChpLCBqKSB7CiAgICAgIC8vIEluc2VydGlvbiBzb3J0LiBUaGlzIHdheSB0aGUgZGlmZiB3aWxsIGhhdmUgbGluZWFyIGNvbXBsZXhpdHkuCiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KGksIGopOwogICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50OwogICAgICBsZXQgaW5kZXggPSAwOwoKICAgICAgd2hpbGUgKGtleSA+IGN1cnJlbnRbaW5kZXhdKSB7CiAgICAgICAgaW5kZXgrKzsKICAgICAgfQoKICAgICAgaWYgKGtleSA9PT0gY3VycmVudFtpbmRleF0pIHsKICAgICAgICByZXR1cm47IC8vIFBhaXIgd2FzIGFscmVhZHkgYWRkZWQKICAgICAgfQoKICAgICAgZm9yIChsZXQgaiA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaiA+PSBpbmRleDsgai0tKSB7CiAgICAgICAgY3VycmVudFtqICsgMV0gPSBjdXJyZW50W2pdOwogICAgICB9CgogICAgICBjdXJyZW50W2luZGV4XSA9IGtleTsKICAgIH0KICAgIC8qKgogICAgICogdGljawogICAgICovCgoKICAgIHRpY2soKSB7CiAgICAgIGNvbnN0IHRtcCA9IHRoaXMuY3VycmVudDsKICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5wcmV2aW91czsKICAgICAgdGhpcy5wcmV2aW91cyA9IHRtcDsKICAgICAgdGhpcy5jdXJyZW50Lmxlbmd0aCA9IDA7CiAgICB9CiAgICAvKioKICAgICAqIGdldERpZmYKICAgICAqLwoKCiAgICBnZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpIHsKICAgICAgY29uc3QgYSA9IHRoaXMuY3VycmVudDsKICAgICAgY29uc3QgYiA9IHRoaXMucHJldmlvdXM7CiAgICAgIGNvbnN0IGFsID0gYS5sZW5ndGg7CiAgICAgIGNvbnN0IGJsID0gYi5sZW5ndGg7CiAgICAgIGxldCBqID0gMDsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWw7IGkrKykgewogICAgICAgIGxldCBmb3VuZCA9IGZhbHNlOwogICAgICAgIGNvbnN0IGtleUEgPSBhW2ldOwoKICAgICAgICB3aGlsZSAoa2V5QSA+IGJbal0pIHsKICAgICAgICAgIGorKzsKICAgICAgICB9CgogICAgICAgIGZvdW5kID0ga2V5QSA9PT0gYltqXTsKCiAgICAgICAgaWYgKCFmb3VuZCkgewogICAgICAgICAgdW5wYWNrQW5kUHVzaChhZGRpdGlvbnMsIGtleUEpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaiA9IDA7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsOyBpKyspIHsKICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTsKICAgICAgICBjb25zdCBrZXlCID0gYltpXTsKCiAgICAgICAgd2hpbGUgKGtleUIgPiBhW2pdKSB7CiAgICAgICAgICBqKys7CiAgICAgICAgfQoKICAgICAgICBmb3VuZCA9IGFbal0gPT09IGtleUI7CgogICAgICAgIGlmICghZm91bmQpIHsKICAgICAgICAgIHVucGFja0FuZFB1c2gocmVtb3ZhbHMsIGtleUIpOwogICAgICAgIH0KICAgICAgfQogICAgfQoKICB9CgogIGZ1bmN0aW9uIHVucGFja0FuZFB1c2goYXJyYXksIGtleSkgewogICAgYXJyYXkucHVzaCgoa2V5ICYgMHhmZmZmMDAwMCkgPj4gMTYsIGtleSAmIDB4MDAwMGZmZmYpOwogIH0KCiAgY29uc3QgZ2V0S2V5ID0gKGksIGopID0+IGkgPCBqID8gYCR7aX0tJHtqfWAgOiBgJHtqfS0ke2l9YDsKICAvKioKICAgKiBUdXBsZURpY3Rpb25hcnkKICAgKi8KCgogIGNsYXNzIFR1cGxlRGljdGlvbmFyeSB7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy5kYXRhID0gewogICAgICAgIGtleXM6IFtdCiAgICAgIH07CiAgICB9CgogICAgLyoqIGdldCAqLwogICAgZ2V0KGksIGopIHsKICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KGksIGopOwogICAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07CiAgICB9CiAgICAvKiogc2V0ICovCgoKICAgIHNldChpLCBqLCB2YWx1ZSkgewogICAgICBjb25zdCBrZXkgPSBnZXRLZXkoaSwgaik7IC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0cwoKICAgICAgaWYgKCF0aGlzLmdldChpLCBqKSkgewogICAgICAgIHRoaXMuZGF0YS5rZXlzLnB1c2goa2V5KTsKICAgICAgfQoKICAgICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTsKICAgIH0KICAgIC8qKiBkZWxldGUgKi8KCgogICAgZGVsZXRlKGksIGopIHsKICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KGksIGopOwogICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGF0YS5rZXlzLmluZGV4T2Yoa2V5KTsKCiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsKICAgICAgICB0aGlzLmRhdGEua2V5cy5zcGxpY2UoaW5kZXgsIDEpOwogICAgICB9CgogICAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07CiAgICB9CiAgICAvKiogcmVzZXQgKi8KCgogICAgcmVzZXQoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IGtleXMgPSBkYXRhLmtleXM7CgogICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7CiAgICAgICAgY29uc3Qga2V5ID0ga2V5cy5wb3AoKTsKICAgICAgICBkZWxldGUgZGF0YVtrZXldOwogICAgICB9CiAgICB9CgogIH0KCiAgLyoqCiAgICogVGhlIHBoeXNpY3Mgd29ybGQKICAgKi8KICBjbGFzcyBXb3JsZCBleHRlbmRzIEV2ZW50VGFyZ2V0IHsKICAgIC8qKgogICAgICogQ3VycmVudGx5IC8gbGFzdCB1c2VkIHRpbWVzdGVwLiBJcyBzZXQgdG8gLTEgaWYgbm90IGF2YWlsYWJsZS4gVGhpcyB2YWx1ZSBpcyB1cGRhdGVkIGJlZm9yZSBlYWNoIGludGVybmFsIHN0ZXAsIHdoaWNoIG1lYW5zIHRoYXQgaXQgaXMgImZyZXNoIiBpbnNpZGUgZXZlbnQgY2FsbGJhY2tzLgogICAgICovCgogICAgLyoqCiAgICAgKiBNYWtlcyBib2RpZXMgZ28gdG8gc2xlZXAgd2hlbiB0aGV5J3ZlIGJlZW4gaW5hY3RpdmUuCiAgICAgKiBAZGVmYXVsdCBmYWxzZQogICAgICovCgogICAgLyoqCiAgICAgKiBBbGwgdGhlIGN1cnJlbnQgY29udGFjdHMgKGluc3RhbmNlcyBvZiBDb250YWN0RXF1YXRpb24pIGluIHRoZSB3b3JsZC4KICAgICAqLwoKICAgIC8qKgogICAgICogSG93IG9mdGVuIHRvIG5vcm1hbGl6ZSBxdWF0ZXJuaW9ucy4gU2V0IHRvIDAgZm9yIGV2ZXJ5IHN0ZXAsIDEgZm9yIGV2ZXJ5IHNlY29uZCBldGMuLiBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgcGVyZm9ybWFuY2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBhIHNtYWxsZXIgdmFsdWUgKHplcm8gdG8gYmUgc3VyZSBub3RoaW5nIGNhbiBnbyB3cm9uZykuCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNldCB0byB0cnVlIHRvIHVzZSBmYXN0IHF1YXRlcm5pb24gbm9ybWFsaXphdGlvbi4gSXQgaXMgb2Z0ZW4gZW5vdWdoIGFjY3VyYXRlIHRvIHVzZS4KICAgICAqIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBmYWxzZS4KICAgICAqIEBkZWZhdWx0IGZhbHNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSB3YWxsLWNsb2NrIHRpbWUgc2luY2Ugc2ltdWxhdGlvbiBzdGFydC4KICAgICAqLwoKICAgIC8qKgogICAgICogTnVtYmVyIG9mIHRpbWVzdGVwcyB0YWtlbiBzaW5jZSBzdGFydC4KICAgICAqLwoKICAgIC8qKgogICAgICogRGVmYXVsdCBhbmQgbGFzdCB0aW1lc3RlcCBzaXplcy4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGdyYXZpdHkgb2YgdGhlIHdvcmxkLgogICAgICovCgogICAgLyoqCiAgICAgKiBHcmF2aXR5IHRvIHVzZSB3aGVuIGFwcHJveGltYXRpbmcgdGhlIGZyaWN0aW9uIG1heCBmb3JjZSAobXUqbWFzcypncmF2aXR5KS4KICAgICAqIElmIHVuZGVmaW5lZCwgZ2xvYmFsIGdyYXZpdHkgd2lsbCBiZSB1c2VkLgogICAgICogVXNlIHRvIGVuYWJsZSBmcmljdGlvbiBpbiBhIFdvcmxkIHdpdGggYSBudWxsIGdyYXZpdHkgdmVjdG9yIChubyBncmF2aXR5KS4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGJyb2FkcGhhc2UgYWxnb3JpdGhtIHRvIHVzZS4KICAgICAqIEBkZWZhdWx0IE5haXZlQnJvYWRwaGFzZQogICAgICovCgogICAgLyoqCiAgICAgKiBBbGwgYm9kaWVzIGluIHRoaXMgd29ybGQKICAgICAqLwoKICAgIC8qKgogICAgICogVHJ1ZSBpZiBhbnkgYm9kaWVzIGFyZSBub3Qgc2xlZXBpbmcsIGZhbHNlIGlmIGV2ZXJ5IGJvZHkgaXMgc2xlZXBpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBzb2x2ZXIgYWxnb3JpdGhtIHRvIHVzZS4KICAgICAqIEBkZWZhdWx0IEdTU29sdmVyCiAgICAgKi8KCiAgICAvKioKICAgICAqIGNvbGxpc2lvbk1hdHJpeAogICAgICovCgogICAgLyoqCiAgICAgKiBDb2xsaXNpb25NYXRyaXggZnJvbSB0aGUgcHJldmlvdXMgc3RlcC4KICAgICAqLwoKICAgIC8qKgogICAgICogQWxsIGFkZGVkIGNvbnRhY3RtYXRlcmlhbHMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZWQgdG8gbG9vayB1cCBhIENvbnRhY3RNYXRlcmlhbCBnaXZlbiB0d28gaW5zdGFuY2VzIG9mIE1hdGVyaWFsLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgZGVmYXVsdCBtYXRlcmlhbCBvZiB0aGUgYm9kaWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGlzIGNvbnRhY3QgbWF0ZXJpYWwgaXMgdXNlZCBpZiBubyBzdWl0YWJsZSBjb250YWN0bWF0ZXJpYWwgaXMgZm91bmQgZm9yIGEgY29udGFjdC4KICAgICAqLwoKICAgIC8qKgogICAgICogVGltZSBhY2N1bXVsYXRvciBmb3IgaW50ZXJwb2xhdGlvbi4KICAgICAqIEBzZWUgaHR0cHM6Ly9nYWZmZXJvbmdhbWVzLmNvbS9nYW1lLXBoeXNpY3MvZml4LXlvdXItdGltZXN0ZXAvCiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB3b3JsZC4KICAgICAqLwoKICAgIC8qKgogICAgICogRGlzcGF0Y2hlZCBhZnRlciBhIGJvZHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSB3b3JsZC4KICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBzdXBlcigpOwogICAgICB0aGlzLmR0ID0gLTE7CiAgICAgIHRoaXMuYWxsb3dTbGVlcCA9ICEhb3B0aW9ucy5hbGxvd1NsZWVwOwogICAgICB0aGlzLmNvbnRhY3RzID0gW107CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTsKICAgICAgdGhpcy5xdWF0Tm9ybWFsaXplU2tpcCA9IG9wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXAgOiAwOwogICAgICB0aGlzLnF1YXROb3JtYWxpemVGYXN0ID0gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCA6IGZhbHNlOwogICAgICB0aGlzLnRpbWUgPSAwLjA7CiAgICAgIHRoaXMuc3RlcG51bWJlciA9IDA7CiAgICAgIHRoaXMuZGVmYXVsdF9kdCA9IDEgLyA2MDsKICAgICAgdGhpcy5uZXh0SWQgPSAwOwogICAgICB0aGlzLmdyYXZpdHkgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMuZ3Jhdml0eSkgewogICAgICAgIHRoaXMuZ3Jhdml0eS5jb3B5KG9wdGlvbnMuZ3Jhdml0eSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLmZyaWN0aW9uR3Jhdml0eSkgewogICAgICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gbmV3IFZlYzMoKTsKICAgICAgICB0aGlzLmZyaWN0aW9uR3Jhdml0eS5jb3B5KG9wdGlvbnMuZnJpY3Rpb25HcmF2aXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5icm9hZHBoYXNlID0gb3B0aW9ucy5icm9hZHBoYXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJyb2FkcGhhc2UgOiBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7CiAgICAgIHRoaXMuYm9kaWVzID0gW107CiAgICAgIHRoaXMuaGFzQWN0aXZlQm9kaWVzID0gZmFsc2U7CiAgICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc29sdmVyIDogbmV3IEdTU29sdmVyKCk7CiAgICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTsKICAgICAgdGhpcy5uYXJyb3dwaGFzZSA9IG5ldyBOYXJyb3dwaGFzZSh0aGlzKTsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cyA9IG5ldyBBcnJheUNvbGxpc2lvbk1hdHJpeCgpOwogICAgICB0aGlzLmJvZHlPdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTsKICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIgPSBuZXcgT3ZlcmxhcEtlZXBlcigpOwogICAgICB0aGlzLmNvbnRhY3RtYXRlcmlhbHMgPSBbXTsKICAgICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTsKICAgICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoJ2RlZmF1bHQnKTsKICAgICAgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbCh0aGlzLmRlZmF1bHRNYXRlcmlhbCwgdGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHsKICAgICAgICBmcmljdGlvbjogMC4zLAogICAgICAgIHJlc3RpdHV0aW9uOiAwLjAKICAgICAgfSk7CiAgICAgIHRoaXMuZG9Qcm9maWxpbmcgPSBmYWxzZTsKICAgICAgdGhpcy5wcm9maWxlID0gewogICAgICAgIHNvbHZlOiAwLAogICAgICAgIG1ha2VDb250YWN0Q29uc3RyYWludHM6IDAsCiAgICAgICAgYnJvYWRwaGFzZTogMCwKICAgICAgICBpbnRlZ3JhdGU6IDAsCiAgICAgICAgbmFycm93cGhhc2U6IDAKICAgICAgfTsKICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7CiAgICAgIHRoaXMuc3Vic3lzdGVtcyA9IFtdOwogICAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHsKICAgICAgICB0eXBlOiAnYWRkQm9keScsCiAgICAgICAgYm9keTogbnVsbAogICAgICB9OwogICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHsKICAgICAgICB0eXBlOiAncmVtb3ZlQm9keScsCiAgICAgICAgYm9keTogbnVsbAogICAgICB9OwogICAgICB0aGlzLmlkVG9Cb2R5TWFwID0ge307CiAgICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBjb250YWN0IG1hdGVyaWFsIGJldHdlZW4gbWF0ZXJpYWxzIG0xIGFuZCBtMgogICAgICogQHJldHVybiBUaGUgY29udGFjdCBtYXRlcmlhbCBpZiBpdCB3YXMgZm91bmQuCiAgICAgKi8KCgogICAgZ2V0Q29udGFjdE1hdGVyaWFsKG0xLCBtMikgewogICAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQobTEuaWQsIG0yLmlkKTsKICAgIH0KICAgIC8qKgogICAgICogU3RvcmUgb2xkIGNvbGxpc2lvbiBzdGF0ZSBpbmZvCiAgICAgKi8KCgogICAgY29sbGlzaW9uTWF0cml4VGljaygpIHsKICAgICAgY29uc3QgdGVtcCA9IHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXM7CiAgICAgIHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXMgPSB0aGlzLmNvbGxpc2lvbk1hdHJpeDsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSB0ZW1wOwogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5yZXNldCgpOwogICAgICB0aGlzLmJvZHlPdmVybGFwS2VlcGVyLnRpY2soKTsKICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIudGljaygpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBzaW11bGF0aW9uLgogICAgICovCgoKICAgIGFkZENvbnN0cmFpbnQoYykgewogICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYSBjb25zdHJhaW50CiAgICAgKi8KCgogICAgcmVtb3ZlQ29uc3RyYWludChjKSB7CiAgICAgIGNvbnN0IGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTsKCiAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgdGhpcy5jb25zdHJhaW50cy5zcGxpY2UoaWR4LCAxKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSYXljYXN0IHRlc3QKICAgICAqIEBkZXByZWNhdGVkIFVzZSAucmF5Y2FzdEFsbCwgLnJheWNhc3RDbG9zZXN0IG9yIC5yYXljYXN0QW55IGluc3RlYWQuCiAgICAgKi8KCgogICAgcmF5VGVzdChmcm9tLCB0bywgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSYXljYXN0UmVzdWx0KSB7CiAgICAgICAgLy8gRG8gcmF5Y2FzdENsb3Nlc3QKICAgICAgICB0aGlzLnJheWNhc3RDbG9zZXN0KGZyb20sIHRvLCB7CiAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlCiAgICAgICAgfSwgcmVzdWx0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBEbyByYXljYXN0QWxsCiAgICAgICAgdGhpcy5yYXljYXN0QWxsKGZyb20sIHRvLCB7CiAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlCiAgICAgICAgfSwgcmVzdWx0KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuCiAgICAgKiBAcmV0dXJuIFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC4KICAgICAqLwoKCiAgICByYXljYXN0QWxsKGZyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zLm1vZGUgPSBSYXkuQUxMOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBjYWxsYmFjazsKICAgICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogUmF5IGNhc3QsIGFuZCBzdG9wIGF0IHRoZSBmaXJzdCByZXN1bHQuIE5vdGUgdGhhdCB0aGUgb3JkZXIgaXMgcmFuZG9tIC0gYnV0IHRoZSBtZXRob2QgaXMgZmFzdC4KICAgICAqIEByZXR1cm4gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LgogICAgICovCgoKICAgIHJheWNhc3RBbnkoZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCkgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zLm1vZGUgPSBSYXkuQU5ZOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0OwogICAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBSYXkgY2FzdCwgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBvZiB0aGUgY2xvc2VzdCBoaXQuCiAgICAgKiBAcmV0dXJuIFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC4KICAgICAqLwoKCiAgICByYXljYXN0Q2xvc2VzdChmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMubW9kZSA9IFJheS5DTE9TRVNUOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0OwogICAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYSByaWdpZCBib2R5IHRvIHRoZSBzaW11bGF0aW9uLgogICAgICogQHRvZG8gSWYgdGhlIHNpbXVsYXRpb24gaGFzIG5vdCB5ZXQgc3RhcnRlZCwgd2h5IHJlY3JldGUgYW5kIGNvcHkgYXJyYXlzIGZvciBlYWNoIGJvZHk/IEFjY3VtdWxhdGUgaW4gZHluYW1pYyBhcnJheXMgaW4gdGhpcyBjYXNlLgogICAgICogQHRvZG8gQWRkaW5nIGFuIGFycmF5IG9mIGJvZGllcyBzaG91bGQgYmUgcG9zc2libGUuIFRoaXMgd291bGQgc2F2ZSBzb21lIGxvb3BzIHRvbwogICAgICovCgoKICAgIGFkZEJvZHkoYm9keSkgewogICAgICBpZiAodGhpcy5ib2RpZXMuaW5jbHVkZXMoYm9keSkpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGJvZHkuaW5kZXggPSB0aGlzLmJvZGllcy5sZW5ndGg7CiAgICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7CiAgICAgIGJvZHkud29ybGQgPSB0aGlzOwogICAgICBib2R5LmluaXRQb3NpdGlvbi5jb3B5KGJvZHkucG9zaXRpb24pOwogICAgICBib2R5LmluaXRWZWxvY2l0eS5jb3B5KGJvZHkudmVsb2NpdHkpOwogICAgICBib2R5LnRpbWVMYXN0U2xlZXB5ID0gdGhpcy50aW1lOwoKICAgICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBCb2R5KSB7CiAgICAgICAgYm9keS5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkoYm9keS5hbmd1bGFyVmVsb2NpdHkpOwogICAgICAgIGJvZHkuaW5pdFF1YXRlcm5pb24uY29weShib2R5LnF1YXRlcm5pb24pOwogICAgICB9CgogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXROdW1PYmplY3RzKHRoaXMuYm9kaWVzLmxlbmd0aCk7CiAgICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5OwogICAgICB0aGlzLmlkVG9Cb2R5TWFwW2JvZHkuaWRdID0gYm9keTsKICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuYWRkQm9keUV2ZW50KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLgogICAgICovCgoKICAgIHJlbW92ZUJvZHkoYm9keSkgewogICAgICBib2R5LndvcmxkID0gbnVsbDsKICAgICAgY29uc3QgbiA9IHRoaXMuYm9kaWVzLmxlbmd0aCAtIDE7CiAgICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYm9kaWVzOwogICAgICBjb25zdCBpZHggPSBib2RpZXMuaW5kZXhPZihib2R5KTsKCiAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgYm9kaWVzLnNwbGljZShpZHgsIDEpOyAvLyBUb2RvOiBzaG91bGQgdXNlIGEgZ2FyYmFnZSBmcmVlIG1ldGhvZAogICAgICAgIC8vIFJlY29tcHV0ZSBpbmRleAoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gYm9kaWVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBib2RpZXNbaV0uaW5kZXggPSBpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhuKTsKICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTsKICAgICAgICBkZWxldGUgdGhpcy5pZFRvQm9keU1hcFtib2R5LmlkXTsKICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5yZW1vdmVCb2R5RXZlbnQpOwogICAgICB9CiAgICB9CgogICAgZ2V0Qm9keUJ5SWQoaWQpIHsKICAgICAgcmV0dXJuIHRoaXMuaWRUb0JvZHlNYXBbaWRdOwogICAgfQogICAgLyoqCiAgICAgKiBAdG9kbyBNYWtlIGEgZmFzdGVyIG1hcAogICAgICovCgoKICAgIGdldFNoYXBlQnlJZChpZCkgewogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmJvZGllczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3Qgc2hhcGVzID0gYm9kaWVzW2ldLnNoYXBlczsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGFwZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2pdOwoKICAgICAgICAgIGlmIChzaGFwZS5pZCA9PT0gaWQpIHsKICAgICAgICAgICAgcmV0dXJuIHNoYXBlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgYSBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBXb3JsZAogICAgICovCgoKICAgIGFkZENvbnRhY3RNYXRlcmlhbChjbWF0KSB7CiAgICAgIC8vIEFkZCBjb250YWN0IG1hdGVyaWFsCiAgICAgIHRoaXMuY29udGFjdG1hdGVyaWFscy5wdXNoKGNtYXQpOyAvLyBBZGQgY3VycmVudCBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBtYXRlcmlhbCB0YWJsZQoKICAgICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5zZXQoY21hdC5tYXRlcmlhbHNbMF0uaWQsIGNtYXQubWF0ZXJpYWxzWzFdLmlkLCBjbWF0KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhIGNvbnRhY3QgbWF0ZXJpYWwgZnJvbSB0aGUgV29ybGQuCiAgICAgKi8KCgogICAgcmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtYXQpIHsKICAgICAgY29uc3QgaWR4ID0gdGhpcy5jb250YWN0bWF0ZXJpYWxzLmluZGV4T2YoY21hdCk7CgogICAgICBpZiAoaWR4ID09PSAtMSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzLnNwbGljZShpZHgsIDEpOwogICAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLmRlbGV0ZShjbWF0Lm1hdGVyaWFsc1swXS5pZCwgY21hdC5tYXRlcmlhbHNbMV0uaWQpOwogICAgfQogICAgLyoqCiAgICAgKiBTdGVwIHRoZSBzaW11bGF0aW9uIGZvcndhcmQga2VlcGluZyB0cmFjayBvZiBsYXN0IGNhbGxlZCB0aW1lCiAgICAgKiB0byBiZSBhYmxlIHRvIHN0ZXAgdGhlIHdvcmxkIGF0IGEgZml4ZWQgcmF0ZSwgaW5kZXBlbmRlbnRseSBvZiBmcmFtZXJhdGUuCiAgICAgKgogICAgICogQHBhcmFtIGR0IFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UgKGRlZmF1bHQ6IDEgLyA2MCkuCiAgICAgKiBAcGFyYW0gbWF4U3ViU3RlcHMgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbCAoZGVmYXVsdDogMTApLgogICAgICogQHNlZSBodHRwczovL2dhZmZlcm9uZ2FtZXMuY29tL3Bvc3QvZml4X3lvdXJfdGltZXN0ZXAvCiAgICAgKiBAZXhhbXBsZQogICAgICogICAgIC8vIFJ1biB0aGUgc2ltdWxhdGlvbiBpbmRlcGVuZGVudGx5IG9mIGZyYW1lcmF0ZSBldmVyeSAxIC8gNjAgbXMKICAgICAqICAgICB3b3JsZC5maXhlZFN0ZXAoKQogICAgICovCgoKICAgIGZpeGVkU3RlcChkdCwgbWF4U3ViU3RlcHMpIHsKICAgICAgaWYgKGR0ID09PSB2b2lkIDApIHsKICAgICAgICBkdCA9IDEgLyA2MDsKICAgICAgfQoKICAgICAgaWYgKG1heFN1YlN0ZXBzID09PSB2b2lkIDApIHsKICAgICAgICBtYXhTdWJTdGVwcyA9IDEwOwogICAgICB9CgogICAgICBjb25zdCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwOyAvLyBzZWNvbmRzCgogICAgICBpZiAoIXRoaXMubGFzdENhbGxUaW1lKSB7CiAgICAgICAgdGhpcy5zdGVwKGR0LCB1bmRlZmluZWQsIG1heFN1YlN0ZXBzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZSAtIHRoaXMubGFzdENhbGxUaW1lOwogICAgICAgIHRoaXMuc3RlcChkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpOwogICAgICB9CgogICAgICB0aGlzLmxhc3RDYWxsVGltZSA9IHRpbWU7CiAgICB9CiAgICAvKioKICAgICAqIFN0ZXAgdGhlIHBoeXNpY3Mgd29ybGQgZm9yd2FyZCBpbiB0aW1lLgogICAgICoKICAgICAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLgogICAgICoKICAgICAqIEBwYXJhbSBkdCBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLgogICAgICogQHBhcmFtIHRpbWVTaW5jZUxhc3RDYWxsZWQgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgY2FsbGVkLgogICAgICogQHBhcmFtIG1heFN1YlN0ZXBzIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwgKGRlZmF1bHQ6IDEwKS4KICAgICAqIEBzZWUgaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTgwNDI2MTU0NTMxL2h0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZCNXaGF0X2RvX3RoZV9wYXJhbWV0ZXJzX3RvX2J0RHluYW1pY3NXb3JsZDo6c3RlcFNpbXVsYXRpb25fbWVhbi4zRgogICAgICogQGV4YW1wbGUKICAgICAqICAgICAvLyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uCiAgICAgKiAgICAgd29ybGQuc3RlcCgxIC8gNjApCiAgICAgKi8KCgogICAgc3RlcChkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpIHsKICAgICAgaWYgKG1heFN1YlN0ZXBzID09PSB2b2lkIDApIHsKICAgICAgICBtYXhTdWJTdGVwcyA9IDEwOwogICAgICB9CgogICAgICBpZiAodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgLy8gRml4ZWQsIHNpbXBsZSBzdGVwcGluZwogICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTsgLy8gSW5jcmVtZW50IHRpbWUKCiAgICAgICAgdGhpcy50aW1lICs9IGR0OwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYWNjdW11bGF0b3IgKz0gdGltZVNpbmNlTGFzdENhbGxlZDsKICAgICAgICBjb25zdCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICAgIGxldCBzdWJzdGVwcyA9IDA7CgogICAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHN1YnN0ZXBzIDwgbWF4U3ViU3RlcHMpIHsKICAgICAgICAgIC8vIERvIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwCiAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7CiAgICAgICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IGR0OwogICAgICAgICAgc3Vic3RlcHMrKzsKCiAgICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSB0MCA+IGR0ICogMTAwMCkgewogICAgICAgICAgICAvLyBUaGUgZnJhbWVyYXRlIGlzIG5vdCBpbnRlcmFjdGl2ZSBhbnltb3JlLgogICAgICAgICAgICAvLyBXZSBhcmUgYmVsb3cgdGhlIHRhcmdldCBmcmFtZXJhdGUuCiAgICAgICAgICAgIC8vIEJldHRlciBiYWlsIG91dC4KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBSZW1vdmUgdGhlIGV4Y2VzcyBhY2N1bXVsYXRvciwgc2luY2Ugd2UgbWF5IG5vdAogICAgICAgIC8vIGhhdmUgaGFkIGVub3VnaCBzdWJzdGVwcyBhdmFpbGFibGUgdG8gY2F0Y2ggdXAKCgogICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSB0aGlzLmFjY3VtdWxhdG9yICUgZHQ7CiAgICAgICAgY29uc3QgdCA9IHRoaXMuYWNjdW11bGF0b3IgLyBkdDsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IHRoaXMuYm9kaWVzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCBiID0gdGhpcy5ib2RpZXNbal07CiAgICAgICAgICBiLnByZXZpb3VzUG9zaXRpb24ubGVycChiLnBvc2l0aW9uLCB0LCBiLmludGVycG9sYXRlZFBvc2l0aW9uKTsKICAgICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLnNsZXJwKGIucXVhdGVybmlvbiwgdCwgYi5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uKTsKICAgICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLm5vcm1hbGl6ZSgpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy50aW1lICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7CiAgICAgIH0KICAgIH0KCiAgICBpbnRlcm5hbFN0ZXAoZHQpIHsKICAgICAgdGhpcy5kdCA9IGR0OwogICAgICBjb25zdCBjb250YWN0cyA9IHRoaXMuY29udGFjdHM7CiAgICAgIGNvbnN0IHAxID0gV29ybGRfc3RlcF9wMTsKICAgICAgY29uc3QgcDIgPSBXb3JsZF9zdGVwX3AyOwogICAgICBjb25zdCBOID0gdGhpcy5ib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmJvZGllczsKICAgICAgY29uc3Qgc29sdmVyID0gdGhpcy5zb2x2ZXI7CiAgICAgIGNvbnN0IGdyYXZpdHkgPSB0aGlzLmdyYXZpdHk7CiAgICAgIGNvbnN0IGRvUHJvZmlsaW5nID0gdGhpcy5kb1Byb2ZpbGluZzsKICAgICAgY29uc3QgcHJvZmlsZSA9IHRoaXMucHJvZmlsZTsKICAgICAgY29uc3QgRFlOQU1JQyA9IEJvZHkuRFlOQU1JQzsKICAgICAgbGV0IHByb2ZpbGluZ1N0YXJ0ID0gLUluZmluaXR5OwogICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7CiAgICAgIGNvbnN0IGZyaWN0aW9uRXF1YXRpb25Qb29sID0gV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbDsKICAgICAgZ3Jhdml0eS5sZW5ndGgoKTsKICAgICAgY29uc3QgZ3ggPSBncmF2aXR5Lng7CiAgICAgIGNvbnN0IGd5ID0gZ3Jhdml0eS55OwogICAgICBjb25zdCBneiA9IGdyYXZpdHkuejsKICAgICAgbGV0IGkgPSAwOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgfSAvLyBBZGQgZ3Jhdml0eSB0byBhbGwgb2JqZWN0cwoKCiAgICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IGJpID0gYm9kaWVzW2ldOwoKICAgICAgICBpZiAoYmkudHlwZSA9PT0gRFlOQU1JQykgewogICAgICAgICAgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXMKICAgICAgICAgIGNvbnN0IGYgPSBiaS5mb3JjZTsKICAgICAgICAgIGNvbnN0IG0gPSBiaS5tYXNzOwogICAgICAgICAgZi54ICs9IG0gKiBneDsKICAgICAgICAgIGYueSArPSBtICogZ3k7CiAgICAgICAgICBmLnogKz0gbSAqIGd6OwogICAgICAgIH0KICAgICAgfSAvLyBVcGRhdGUgc3Vic3lzdGVtcwoKCiAgICAgIGZvciAobGV0IGkgPSAwLCBOc3Vic3lzdGVtcyA9IHRoaXMuc3Vic3lzdGVtcy5sZW5ndGg7IGkgIT09IE5zdWJzeXN0ZW1zOyBpKyspIHsKICAgICAgICB0aGlzLnN1YnN5c3RlbXNbaV0udXBkYXRlKCk7CiAgICAgIH0gLy8gQ29sbGlzaW9uIGRldGVjdGlvbgoKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICAgIH0KCiAgICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwCgogICAgICBwMi5sZW5ndGggPSAwOwogICAgICB0aGlzLmJyb2FkcGhhc2UuY29sbGlzaW9uUGFpcnModGhpcywgcDEsIHAyKTsKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGUuYnJvYWRwaGFzZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7CiAgICAgIH0gLy8gUmVtb3ZlIGNvbnN0cmFpbmVkIHBhaXJzIHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZQoKCiAgICAgIGxldCBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBjb25zdHJhaW50c1tpXTsKCiAgICAgICAgaWYgKCFjLmNvbGxpZGVDb25uZWN0ZWQpIHsKICAgICAgICAgIGZvciAobGV0IGogPSBwMS5sZW5ndGggLSAxOyBqID49IDA7IGogLT0gMSkgewogICAgICAgICAgICBpZiAoYy5ib2R5QSA9PT0gcDFbal0gJiYgYy5ib2R5QiA9PT0gcDJbal0gfHwgYy5ib2R5QiA9PT0gcDFbal0gJiYgYy5ib2R5QSA9PT0gcDJbal0pIHsKICAgICAgICAgICAgICBwMS5zcGxpY2UoaiwgMSk7CiAgICAgICAgICAgICAgcDIuc3BsaWNlKGosIDEpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFRpY2soKTsgLy8gR2VuZXJhdGUgY29udGFjdHMKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IG9sZGNvbnRhY3RzID0gV29ybGRfc3RlcF9vbGRDb250YWN0czsKICAgICAgY29uc3QgTm9sZENvbnRhY3RzID0gY29udGFjdHMubGVuZ3RoOwoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTm9sZENvbnRhY3RzOyBpKyspIHsKICAgICAgICBvbGRjb250YWN0cy5wdXNoKGNvbnRhY3RzW2ldKTsKICAgICAgfQoKICAgICAgY29udGFjdHMubGVuZ3RoID0gMDsgLy8gVHJhbnNmZXIgRnJpY3Rpb25FcXVhdGlvbiBmcm9tIGN1cnJlbnQgbGlzdCB0byB0aGUgcG9vbCBmb3IgcmV1c2UKCiAgICAgIGNvbnN0IE5vbGRGcmljdGlvbkVxdWF0aW9ucyA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOwoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTm9sZEZyaWN0aW9uRXF1YXRpb25zOyBpKyspIHsKICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbC5wdXNoKHRoaXMuZnJpY3Rpb25FcXVhdGlvbnNbaV0pOwogICAgICB9CgogICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA9IDA7CiAgICAgIHRoaXMubmFycm93cGhhc2UuZ2V0Q29udGFjdHMocDEsIHAyLCB0aGlzLCBjb250YWN0cywgb2xkY29udGFjdHMsIC8vIFRvIGJlIHJldXNlZAogICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLCBmcmljdGlvbkVxdWF0aW9uUG9vbCk7CgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxlLm5hcnJvd3BoYXNlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDsKICAgICAgfSAvLyBMb29wIG92ZXIgYWxsIGNvbGxpc2lvbnMKCgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9IC8vIEFkZCBhbGwgZnJpY3Rpb24gZXFzCgoKICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24odGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IG5jb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGsgPSAwOyBrICE9PSBuY29udGFjdHM7IGsrKykgewogICAgICAgIC8vIEN1cnJlbnQgY29udGFjdAogICAgICAgIGNvbnN0IGMgPSBjb250YWN0c1trXTsgLy8gR2V0IGN1cnJlbnQgY29sbGlzaW9uIGluZGVjZXMKCiAgICAgICAgY29uc3QgYmkgPSBjLmJpOwogICAgICAgIGNvbnN0IGJqID0gYy5iajsKICAgICAgICBjb25zdCBzaSA9IGMuc2k7CiAgICAgICAgY29uc3Qgc2ogPSBjLnNqOyAvLyBHZXQgY29sbGlzaW9uIHByb3BlcnRpZXMKCiAgICAgICAgbGV0IGNtOwoKICAgICAgICBpZiAoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpIHsKICAgICAgICAgIGNtID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoYmkubWF0ZXJpYWwsIGJqLm1hdGVyaWFsKSB8fCB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsOwogICAgICAgIH0gLy8gYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7CgoKICAgICAgICBjbS5mcmljdGlvbjsgLy8gYy5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uOwogICAgICAgIC8vIElmIGZyaWN0aW9uIG9yIHJlc3RpdHV0aW9uIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBtYXRlcmlhbCwgdXNlIHRoZW0KCiAgICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7CiAgICAgICAgICBpZiAoYmkubWF0ZXJpYWwuZnJpY3Rpb24gPj0gMCAmJiBiai5tYXRlcmlhbC5mcmljdGlvbiA+PSAwKSB7CiAgICAgICAgICAgIGJpLm1hdGVyaWFsLmZyaWN0aW9uICogYmoubWF0ZXJpYWwuZnJpY3Rpb247CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGJpLm1hdGVyaWFsLnJlc3RpdHV0aW9uID49IDAgJiYgYmoubWF0ZXJpYWwucmVzdGl0dXRpb24gPj0gMCkgewogICAgICAgICAgICBjLnJlc3RpdHV0aW9uID0gYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gKiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbjsKICAgICAgICAgIH0KICAgICAgICB9IC8vIGMuc2V0U3Bvb2tQYXJhbXMoCiAgICAgICAgLy8gICAgICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcywKICAgICAgICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiwKICAgICAgICAvLyAgICAgICAgICAgZHQKICAgICAgICAvLyAgICAgICApOwoKCiAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKGMpOyAvLyAvLyBBZGQgZnJpY3Rpb24gY29uc3RyYWludCBlcXVhdGlvbgogICAgICAgIC8vIGlmKG11ID4gMCl7CiAgICAgICAgLy8gCS8vIENyZWF0ZSAyIHRhbmdlbnQgZXF1YXRpb25zCiAgICAgICAgLy8gCWNvbnN0IG11ZyA9IG11ICogZ25vcm07CiAgICAgICAgLy8gCWNvbnN0IHJlZHVjZWRNYXNzID0gKGJpLmludk1hc3MgKyBiai5pbnZNYXNzKTsKICAgICAgICAvLyAJaWYocmVkdWNlZE1hc3MgPiAwKXsKICAgICAgICAvLyAJCXJlZHVjZWRNYXNzID0gMS9yZWR1Y2VkTWFzczsKICAgICAgICAvLyAJfQogICAgICAgIC8vIAljb25zdCBwb29sID0gZnJpY3Rpb25FcXVhdGlvblBvb2w7CiAgICAgICAgLy8gCWNvbnN0IGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYmksYmosbXVnKnJlZHVjZWRNYXNzKTsKICAgICAgICAvLyAJY29uc3QgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihiaSxiaixtdWcqcmVkdWNlZE1hc3MpOwogICAgICAgIC8vIAl0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goYzEsIGMyKTsKICAgICAgICAvLyAJYzEuYmkgPSBjMi5iaSA9IGJpOwogICAgICAgIC8vIAljMS5iaiA9IGMyLmJqID0gYmo7CiAgICAgICAgLy8gCWMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzOwogICAgICAgIC8vIAljMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzOwogICAgICAgIC8vIAkvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnMKICAgICAgICAvLyAJYzEucmkuY29weShjLnJpKTsKICAgICAgICAvLyAJYzEucmouY29weShjLnJqKTsKICAgICAgICAvLyAJYzIucmkuY29weShjLnJpKTsKICAgICAgICAvLyAJYzIucmouY29weShjLnJqKTsKICAgICAgICAvLyAJLy8gQ29uc3RydWN0IHRhbmdlbnRzCiAgICAgICAgLy8gCWMubmkudGFuZ2VudHMoYzEudCwgYzIudCk7CiAgICAgICAgLy8gICAgICAgICAgIC8vIFNldCBzcG9vayBwYXJhbXMKICAgICAgICAvLyAgICAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTsKICAgICAgICAvLyAgICAgICAgICAgYzIuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTsKICAgICAgICAvLyAgICAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjLmVuYWJsZWQ7CiAgICAgICAgLy8gCS8vIEFkZCBlcXVhdGlvbnMgdG8gc29sdmVyCiAgICAgICAgLy8gCXNvbHZlci5hZGRFcXVhdGlvbihjMSk7CiAgICAgICAgLy8gCXNvbHZlci5hZGRFcXVhdGlvbihjMik7CiAgICAgICAgLy8gfQoKICAgICAgICBpZiAoYmkuYWxsb3dTbGVlcCAmJiBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgYmkuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBiai5zbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmIGJqLnR5cGUgIT09IEJvZHkuU1RBVElDKSB7CiAgICAgICAgICBjb25zdCBzcGVlZFNxdWFyZWRCID0gYmoudmVsb2NpdHkubGVuZ3RoU3F1YXJlZCgpICsgYmouYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKTsKICAgICAgICAgIGNvbnN0IHNwZWVkTGltaXRTcXVhcmVkQiA9IGJqLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRCID49IHNwZWVkTGltaXRTcXVhcmVkQiAqIDIpIHsKICAgICAgICAgICAgYmkud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoYmouYWxsb3dTbGVlcCAmJiBiai50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgYmouc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBiaS5zbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmIGJpLnR5cGUgIT09IEJvZHkuU1RBVElDKSB7CiAgICAgICAgICBjb25zdCBzcGVlZFNxdWFyZWRBID0gYmkudmVsb2NpdHkubGVuZ3RoU3F1YXJlZCgpICsgYmkuYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKTsKICAgICAgICAgIGNvbnN0IHNwZWVkTGltaXRTcXVhcmVkQSA9IGJpLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSAqIDIpIHsKICAgICAgICAgICAgYmoud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBOb3cgd2Uga25vdyB0aGF0IGkgYW5kIGogYXJlIGluIGNvbnRhY3QuIFNldCBjb2xsaXNpb24gbWF0cml4IHN0YXRlCgoKICAgICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoYmksIGJqLCB0cnVlKTsKCiAgICAgICAgaWYgKCF0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzLmdldChiaSwgYmopKSB7CiAgICAgICAgICAvLyBGaXJzdCBjb250YWN0IQogICAgICAgICAgLy8gV2UgcmV1c2UgdGhlIGNvbGxpZGVFdmVudCBvYmplY3QsIG90aGVyd2lzZSB3ZSB3aWxsIGVuZCB1cCBjcmVhdGluZyBuZXcgb2JqZWN0cyBmb3IgZWFjaCBuZXcgY29udGFjdCwgZXZlbiBpZiB0aGVyZSdzIG5vIGV2ZW50IGxpc3RlbmVyIGF0dGFjaGVkLgogICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJqOwogICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuY29udGFjdCA9IGM7CiAgICAgICAgICBiaS5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTsKICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJvZHkgPSBiaTsKICAgICAgICAgIGJqLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5zZXQoYmkuaWQsIGJqLmlkKTsKICAgICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQoc2kuaWQsIHNqLmlkKTsKICAgICAgfQoKICAgICAgdGhpcy5lbWl0Q29udGFjdEV2ZW50cygpOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5tYWtlQ29udGFjdENvbnN0cmFpbnRzID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9IC8vIFdha2UgdXAgYm9kaWVzCgoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYmkgPSBib2RpZXNbaV07CgogICAgICAgIGlmIChiaS53YWtlVXBBZnRlck5hcnJvd3BoYXNlKSB7CiAgICAgICAgICBiaS53YWtlVXAoKTsKICAgICAgICAgIGJpLndha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTsKICAgICAgICB9CiAgICAgIH0gLy8gQWRkIHVzZXItYWRkZWQgY29uc3RyYWludHMKCgogICAgICBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBjb25zdHJhaW50c1tpXTsKICAgICAgICBjLnVwZGF0ZSgpOwoKICAgICAgICBmb3IgKGxldCBqID0gMCwgTmVxID0gYy5lcXVhdGlvbnMubGVuZ3RoOyBqICE9PSBOZXE7IGorKykgewogICAgICAgICAgY29uc3QgZXEgPSBjLmVxdWF0aW9uc1tqXTsKICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcSk7CiAgICAgICAgfQogICAgICB9IC8vIFNvbHZlIHRoZSBjb25zdHJhaW5lZCBzeXN0ZW0KCgogICAgICBzb2x2ZXIuc29sdmUoZHQsIHRoaXMpOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5zb2x2ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7CiAgICAgIH0gLy8gUmVtb3ZlIGFsbCBjb250YWN0cyBmcm9tIHNvbHZlcgoKCiAgICAgIHNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTsgLy8gQXBwbHkgZGFtcGluZywgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NCBmb3IgZGV0YWlscwoKICAgICAgY29uc3QgcG93ID0gTWF0aC5wb3c7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKCiAgICAgICAgaWYgKGJpLnR5cGUgJiBEWU5BTUlDKSB7CiAgICAgICAgICAvLyBPbmx5IGZvciBkeW5hbWljIGJvZGllcwogICAgICAgICAgY29uc3QgbGQgPSBwb3coMS4wIC0gYmkubGluZWFyRGFtcGluZywgZHQpOwogICAgICAgICAgY29uc3QgdiA9IGJpLnZlbG9jaXR5OwogICAgICAgICAgdi5zY2FsZShsZCwgdik7CiAgICAgICAgICBjb25zdCBhdiA9IGJpLmFuZ3VsYXJWZWxvY2l0eTsKCiAgICAgICAgICBpZiAoYXYpIHsKICAgICAgICAgICAgY29uc3QgYWQgPSBwb3coMS4wIC0gYmkuYW5ndWxhckRhbXBpbmcsIGR0KTsKICAgICAgICAgICAgYXYuc2NhbGUoYWQsIGF2KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX3ByZVN0ZXBFdmVudCk7IC8vIExlYXAgZnJvZwogICAgICAvLyB2bmV3ID0gdiArIGgqZi9tCiAgICAgIC8vIHhuZXcgPSB4ICsgaCp2bmV3CgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9CgogICAgICBjb25zdCBzdGVwbnVtYmVyID0gdGhpcy5zdGVwbnVtYmVyOwogICAgICBjb25zdCBxdWF0Tm9ybWFsaXplID0gc3RlcG51bWJlciAlICh0aGlzLnF1YXROb3JtYWxpemVTa2lwICsgMSkgPT09IDA7CiAgICAgIGNvbnN0IHF1YXROb3JtYWxpemVGYXN0ID0gdGhpcy5xdWF0Tm9ybWFsaXplRmFzdDsKCiAgICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGJvZGllc1tpXS5pbnRlZ3JhdGUoZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KTsKICAgICAgfQoKICAgICAgdGhpcy5jbGVhckZvcmNlcygpOwogICAgICB0aGlzLmJyb2FkcGhhc2UuZGlydHkgPSB0cnVlOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5pbnRlZ3JhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0OwogICAgICB9IC8vIFVwZGF0ZSBzdGVwIG51bWJlcgoKCiAgICAgIHRoaXMuc3RlcG51bWJlciArPSAxOwogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50KTsgLy8gU2xlZXBpbmcgdXBkYXRlCgogICAgICBsZXQgaGFzQWN0aXZlQm9kaWVzID0gdHJ1ZTsKCiAgICAgIGlmICh0aGlzLmFsbG93U2xlZXApIHsKICAgICAgICBoYXNBY3RpdmVCb2RpZXMgPSBmYWxzZTsKCiAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKICAgICAgICAgIGJpLnNsZWVwVGljayh0aGlzLnRpbWUpOwoKICAgICAgICAgIGlmIChiaS5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQSU5HKSB7CiAgICAgICAgICAgIGhhc0FjdGl2ZUJvZGllcyA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmhhc0FjdGl2ZUJvZGllcyA9IGhhc0FjdGl2ZUJvZGllczsKICAgIH0KCiAgICBlbWl0Q29udGFjdEV2ZW50cygpIHsKICAgICAgY29uc3QgaGFzQmVnaW5Db250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdiZWdpbkNvbnRhY3QnKTsKICAgICAgY29uc3QgaGFzRW5kQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignZW5kQ29udGFjdCcpOwoKICAgICAgaWYgKGhhc0JlZ2luQ29udGFjdCB8fCBoYXNFbmRDb250YWN0KSB7CiAgICAgICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpOwogICAgICB9CgogICAgICBpZiAoaGFzQmVnaW5Db250YWN0KSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhZGRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7CiAgICAgICAgICBiZWdpbkNvbnRhY3RFdmVudC5ib2R5QSA9IHRoaXMuZ2V0Qm9keUJ5SWQoYWRkaXRpb25zW2ldKTsKICAgICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gdGhpcy5nZXRCb2R5QnlJZChhZGRpdGlvbnNbaSArIDFdKTsKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChiZWdpbkNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBiZWdpbkNvbnRhY3RFdmVudC5ib2R5QSA9IGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gbnVsbDsKICAgICAgfQoKICAgICAgaWYgKGhhc0VuZENvbnRhY3QpIHsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHJlbW92YWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikgewogICAgICAgICAgZW5kQ29udGFjdEV2ZW50LmJvZHlBID0gdGhpcy5nZXRCb2R5QnlJZChyZW1vdmFsc1tpXSk7CiAgICAgICAgICBlbmRDb250YWN0RXZlbnQuYm9keUIgPSB0aGlzLmdldEJvZHlCeUlkKHJlbW92YWxzW2kgKyAxXSk7CiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZW5kQ29udGFjdEV2ZW50KTsKICAgICAgICB9CgogICAgICAgIGVuZENvbnRhY3RFdmVudC5ib2R5QSA9IGVuZENvbnRhY3RFdmVudC5ib2R5QiA9IG51bGw7CiAgICAgIH0KCiAgICAgIGFkZGl0aW9ucy5sZW5ndGggPSByZW1vdmFscy5sZW5ndGggPSAwOwogICAgICBjb25zdCBoYXNCZWdpblNoYXBlQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignYmVnaW5TaGFwZUNvbnRhY3QnKTsKICAgICAgY29uc3QgaGFzRW5kU2hhcGVDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdlbmRTaGFwZUNvbnRhY3QnKTsKCiAgICAgIGlmIChoYXNCZWdpblNoYXBlQ29udGFjdCB8fCBoYXNFbmRTaGFwZUNvbnRhY3QpIHsKICAgICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpOwogICAgICB9CgogICAgICBpZiAoaGFzQmVnaW5TaGFwZUNvbnRhY3QpIHsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFkZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHsKICAgICAgICAgIGNvbnN0IHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKGFkZGl0aW9uc1tpXSk7CiAgICAgICAgICBjb25zdCBzaGFwZUIgPSB0aGlzLmdldFNoYXBlQnlJZChhZGRpdGlvbnNbaSArIDFdKTsKICAgICAgICAgIGJlZ2luU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gc2hhcGVBOwogICAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBzaGFwZUI7CiAgICAgICAgICBpZiAoc2hhcGVBKSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gc2hhcGVBLmJvZHk7CiAgICAgICAgICBpZiAoc2hhcGVCKSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gc2hhcGVCLmJvZHk7CiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoYmVnaW5TaGFwZUNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5ib2R5QiA9IGJlZ2luU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBudWxsOwogICAgICB9CgogICAgICBpZiAoaGFzRW5kU2hhcGVDb250YWN0KSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSByZW1vdmFscy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHsKICAgICAgICAgIGNvbnN0IHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2ldKTsKICAgICAgICAgIGNvbnN0IHNoYXBlQiA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2kgKyAxXSk7CiAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUEgPSBzaGFwZUE7CiAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBzaGFwZUI7CiAgICAgICAgICBpZiAoc2hhcGVBKSBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IHNoYXBlQS5ib2R5OwogICAgICAgICAgaWYgKHNoYXBlQikgZW5kU2hhcGVDb250YWN0RXZlbnQuYm9keUIgPSBzaGFwZUIuYm9keTsKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlbmRTaGFwZUNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IGVuZFNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVCID0gbnVsbDsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGFsbCBib2R5IGZvcmNlcyBpbiB0aGUgd29ybGQgdG8gemVyby4KICAgICAqLwoKCiAgICBjbGVhckZvcmNlcygpIHsKICAgICAgY29uc3QgYm9kaWVzID0gdGhpcy5ib2RpZXM7CiAgICAgIGNvbnN0IE4gPSBib2RpZXMubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IGIgPSBib2RpZXNbaV07CiAgICAgICAgYi5mb3JjZTsKICAgICAgICBiLnRvcnF1ZTsKICAgICAgICBiLmZvcmNlLnNldCgwLCAwLCAwKTsKICAgICAgICBiLnRvcnF1ZS5zZXQoMCwgMCwgMCk7CiAgICAgIH0KICAgIH0KCiAgfSAvLyBUZW1wIHN0dWZmCgogIG5ldyBBQUJCKCk7CiAgY29uc3QgdG1wUmF5ID0gbmV3IFJheSgpOyAvLyBwZXJmb3JtYW5jZS5ub3coKSBmYWxsYmFjayBvbiBEYXRlLm5vdygpCgogIGNvbnN0IHBlcmZvcm1hbmNlID0gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSB8fCB7fTsKCiAgaWYgKCFwZXJmb3JtYW5jZS5ub3cpIHsKICAgIGxldCBub3dPZmZzZXQgPSBEYXRlLm5vdygpOwoKICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCkgewogICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0OwogICAgfQoKICAgIHBlcmZvcm1hbmNlLm5vdyA9ICgpID0+IERhdGUubm93KCkgLSBub3dPZmZzZXQ7CiAgfQoKICBuZXcgVmVjMygpOyAvLyBEaXNwYXRjaGVkIGFmdGVyIHRoZSB3b3JsZCBoYXMgc3RlcHBlZCBmb3J3YXJkIGluIHRpbWUuCiAgLy8gUmV1c2FibGUgZXZlbnQgb2JqZWN0cyB0byBzYXZlIG1lbW9yeS4KCiAgY29uc3QgV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50ID0gewogICAgdHlwZTogJ3Bvc3RTdGVwJwogIH07IC8vIERpc3BhdGNoZWQgYmVmb3JlIHRoZSB3b3JsZCBzdGVwcyBmb3J3YXJkIGluIHRpbWUuCgogIGNvbnN0IFdvcmxkX3N0ZXBfcHJlU3RlcEV2ZW50ID0gewogICAgdHlwZTogJ3ByZVN0ZXAnCiAgfTsKICBjb25zdCBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCA9IHsKICAgIHR5cGU6IEJvZHkuQ09MTElERV9FVkVOVF9OQU1FLAogICAgYm9keTogbnVsbCwKICAgIGNvbnRhY3Q6IG51bGwKICB9OyAvLyBQb29scyBmb3IgdW51c2VkIG9iamVjdHMKCiAgY29uc3QgV29ybGRfc3RlcF9vbGRDb250YWN0cyA9IFtdOwogIGNvbnN0IFdvcmxkX3N0ZXBfZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTsgLy8gUmV1c2FibGUgYXJyYXlzIGZvciBjb2xsaXNpb24gcGFpcnMKCiAgY29uc3QgV29ybGRfc3RlcF9wMSA9IFtdOwogIGNvbnN0IFdvcmxkX3N0ZXBfcDIgPSBbXTsgLy8gU3R1ZmYgZm9yIGVtaXRDb250YWN0RXZlbnRzCgogIGNvbnN0IGFkZGl0aW9ucyA9IFtdOwogIGNvbnN0IHJlbW92YWxzID0gW107CiAgY29uc3QgYmVnaW5Db250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnYmVnaW5Db250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwKICB9OwogIGNvbnN0IGVuZENvbnRhY3RFdmVudCA9IHsKICAgIHR5cGU6ICdlbmRDb250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwKICB9OwogIGNvbnN0IGJlZ2luU2hhcGVDb250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnYmVnaW5TaGFwZUNvbnRhY3QnLAogICAgYm9keUE6IG51bGwsCiAgICBib2R5QjogbnVsbCwKICAgIHNoYXBlQTogbnVsbCwKICAgIHNoYXBlQjogbnVsbAogIH07CiAgY29uc3QgZW5kU2hhcGVDb250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnZW5kU2hhcGVDb250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwsCiAgICBzaGFwZUE6IG51bGwsCiAgICBzaGFwZUI6IG51bGwKICB9OwoKICBjb25zdCBhZGRDb250YWN0TWF0ZXJpYWwgPSAod29ybGQsIGNyZWF0ZU1hdGVyaWFsLCBfcmVmLCB1dWlkKSA9PiB7CiAgICBsZXQgW21hdGVyaWFsQSwgbWF0ZXJpYWxCLCBvcHRpb25zXSA9IF9yZWY7CiAgICBjb25zdCBtYXRBID0gY3JlYXRlTWF0ZXJpYWwobWF0ZXJpYWxBKTsKICAgIGNvbnN0IG1hdEIgPSBjcmVhdGVNYXRlcmlhbChtYXRlcmlhbEIpOwogICAgY29uc3QgY29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbChtYXRBLCBtYXRCLCBvcHRpb25zKTsKICAgIGNvbnRhY3RNYXRlcmlhbC51dWlkID0gdXVpZDsKICAgIHdvcmxkLmFkZENvbnRhY3RNYXRlcmlhbChjb250YWN0TWF0ZXJpYWwpOwogIH07CiAgY29uc3QgcmVtb3ZlQ29udGFjdE1hdGVyaWFsID0gKHdvcmxkLCBjbVVVSUQpID0+IHsKICAgIGNvbnN0IGluZGV4ID0gd29ybGQuY29udGFjdG1hdGVyaWFscy5maW5kSW5kZXgoX3JlZjIgPT4gewogICAgICBsZXQgewogICAgICAgIHV1aWQKICAgICAgfSA9IF9yZWYyOwogICAgICByZXR1cm4gdXVpZCA9PT0gY21VVUlEOwogICAgfSk7CiAgICBjb25zdCBbewogICAgICBpZDogaQogICAgfSwgewogICAgICBpZDogagogICAgfV0gPSB3b3JsZC5jb250YWN0bWF0ZXJpYWxzW2luZGV4XS5tYXRlcmlhbHM7CiAgICB3b3JsZC5jb250YWN0bWF0ZXJpYWxzLnNwbGljZShpbmRleCwgMSk7CiAgICBkZWxldGUgd29ybGQuY29udGFjdE1hdGVyaWFsVGFibGUuZGF0YVtpIDwgaiA/IGAke2l9LSR7an1gIDogYCR7an0tJHtpfWBdOwogIH07CgogIGxldCBtYXRlcmlhbElkID0gMDsKICBjb25zdCBjcmVhdGVNYXRlcmlhbEZhY3RvcnkgPSBtYXRlcmlhbHMgPT4gZnVuY3Rpb24gKG5hbWVPck9wdGlvbnMpIHsKICAgIGlmIChuYW1lT3JPcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgbmFtZU9yT3B0aW9ucyA9IHt9OwogICAgfQogICAgY29uc3QgbWF0ZXJpYWxPcHRpb25zID0gdHlwZW9mIG5hbWVPck9wdGlvbnMgPT09ICdzdHJpbmcnID8gewogICAgICBuYW1lOiBuYW1lT3JPcHRpb25zCiAgICB9IDogewogICAgICBuYW1lOiBTeW1ib2wuZm9yKGBNYXRlcmlhbCR7bWF0ZXJpYWxJZCsrfWApLAogICAgICAuLi5uYW1lT3JPcHRpb25zCiAgICB9OwogICAgY29uc3QgewogICAgICBuYW1lCiAgICB9ID0gbWF0ZXJpYWxPcHRpb25zOwogICAgbWF0ZXJpYWxzW25hbWVdID0gbWF0ZXJpYWxzW25hbWVdIHx8IG5ldyBNYXRlcmlhbChtYXRlcmlhbE9wdGlvbnMpOwogICAgcmV0dXJuIG1hdGVyaWFsc1tuYW1lXTsKICB9OwoKICAvKioKICAgKiBAdHlwZWRlZiB7IGltcG9ydCgnY2Fubm9uLWVzJykuTWF0ZXJpYWxPcHRpb25zIH0gTWF0ZXJpYWxPcHRpb25zCiAgICovCgogIGNvbnN0IG1ha2VWZWMzID0gX3JlZiA9PiB7CiAgICBsZXQgW3gsIHksIHpdID0gX3JlZjsKICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTsKICB9OwogIGNvbnN0IHByZXBhcmVTcGhlcmUgPSBhcmdzID0+IEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdOwogIGNvbnN0IHByZXBhcmVDb252ZXhQb2x5aGVkcm9uID0gX3JlZjIgPT4gewogICAgbGV0IFt2LCBmYWNlcywgbiwgYSwgYm91bmRpbmdTcGhlcmVSYWRpdXNdID0gX3JlZjI7CiAgICByZXR1cm4gW3sKICAgICAgYXhlczogYSA/IGEubWFwKG1ha2VWZWMzKSA6IHVuZGVmaW5lZCwKICAgICAgYm91bmRpbmdTcGhlcmVSYWRpdXMsCiAgICAgIGZhY2VzLAogICAgICBub3JtYWxzOiBuID8gbi5tYXAobWFrZVZlYzMpIDogdW5kZWZpbmVkLAogICAgICB2ZXJ0aWNlczogdiA/IHYubWFwKG1ha2VWZWMzKSA6IHVuZGVmaW5lZAogICAgfV07CiAgfTsKICBmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBhcmdzKSB7CiAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgY2FzZSAnQm94JzoKICAgICAgICByZXR1cm4gbmV3IEJveChuZXcgVmVjMyguLi5hcmdzLm1hcCh2ID0+IHYgLyAyKSkpOwogICAgICAvLyBleHRlbnRzID0+IGhhbGZFeHRlbnRzCiAgICAgIGNhc2UgJ0NvbnZleFBvbHloZWRyb24nOgogICAgICAgIHJldHVybiBuZXcgQ29udmV4UG9seWhlZHJvbiguLi5wcmVwYXJlQ29udmV4UG9seWhlZHJvbihhcmdzKSk7CiAgICAgIGNhc2UgJ0N5bGluZGVyJzoKICAgICAgICByZXR1cm4gbmV3IEN5bGluZGVyKC4uLmFyZ3MpOwogICAgICAvLyBbIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIG51bVNlZ21lbnRzIF0gPSBhcmdzCiAgICAgIGNhc2UgJ0hlaWdodGZpZWxkJzoKICAgICAgICByZXR1cm4gbmV3IEhlaWdodGZpZWxkKC4uLmFyZ3MpOwogICAgICAvLyBbIEFycmF5IGRhdGEsIG9wdGlvbnM6IHttaW5WYWx1ZSwgbWF4VmFsdWUsIGVsZW1lbnRTaXplfSAgXSA9IGFyZ3MKICAgICAgY2FzZSAnUGFydGljbGUnOgogICAgICAgIHJldHVybiBuZXcgUGFydGljbGUoKTsKICAgICAgLy8gbm8gYXJncwogICAgICBjYXNlICdQbGFuZSc6CiAgICAgICAgcmV0dXJuIG5ldyBQbGFuZSgpOwogICAgICAvLyBubyBhcmdzLCBpbmZpbml0ZSB4IGFuZCB5CiAgICAgIGNhc2UgJ1NwaGVyZSc6CiAgICAgICAgcmV0dXJuIG5ldyBTcGhlcmUoLi4ucHJlcGFyZVNwaGVyZShhcmdzKSk7CiAgICAgIC8vIHJhZGl1cyA9IGFyZ3MKICAgICAgY2FzZSAnVHJpbWVzaCc6CiAgICAgICAgcmV0dXJuIG5ldyBUcmltZXNoKC4uLmFyZ3MpOwogICAgICAvLyBbdmVydGljZXMsIGluZGljZXNdID0gYXJncwogICAgfQogIH0KCiAgLyoqCiAgICogQHBhcmFtIHtUSFJFRS5RdWF0ZXJuaW9ufSB0YXJnZXQKICAgKiBAcGFyYW0ge3sgcm90YXRpb24/OiBUSFJFRS5WZWN0b3IzVHVwbGUgcXVhdGVybmlvbj86IFRIUkVFLlZlY3RvcjRUdXBsZSB9fSBwcm9wcwogICAqIEByZXR1cm5zIHtUSFJFRS5RdWF0ZXJuaW9ufQogICAqLwogIGNvbnN0IHNldFF1YXRlcm5pb24gPSAodGFyZ2V0LCBfcmVmMykgPT4gewogICAgbGV0IHsKICAgICAgcXVhdGVybmlvbiwKICAgICAgcm90YXRpb24KICAgIH0gPSBfcmVmMzsKICAgIGlmIChxdWF0ZXJuaW9uKSB7CiAgICAgIHRhcmdldC5zZXQoLi4ucXVhdGVybmlvbik7CiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uKSB7CiAgICAgIHRhcmdldC5zZXRGcm9tRXVsZXIoLi4ucm90YXRpb24pOwogICAgfQogICAgcmV0dXJuIHRhcmdldDsKICB9OwoKICAvKioKICAgKiBAZnVuY3Rpb24KICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucwogICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnV1aWQKICAgKiBAcGFyYW0ge0JvZHlQcm9wc30gb3B0aW9ucy5wcm9wcwogICAqIEBwYXJhbSB7Qm9keVNoYXBlVHlwZX0gb3B0aW9ucy50eXBlCiAgICogQHBhcmFtIHsobWF0ZXJpYWxPcHRpb25zOiBNYXRlcmlhbE9wdGlvbnMpID0+IE1hdGVyaWFsID19IG9wdGlvbnMuY3JlYXRlTWF0ZXJpYWwKICAgKiBAcmV0dXJucyB7Qm9keX0KICAgKi8KICBjb25zdCBwcm9wc1RvQm9keSA9IG9wdGlvbnMgPT4gewogICAgY29uc3QgewogICAgICB1dWlkLAogICAgICBwcm9wcywKICAgICAgdHlwZSwKICAgICAgY3JlYXRlTWF0ZXJpYWwgPSBtYXRlcmlhbE9wdGlvbnMgPT4gbmV3IE1hdGVyaWFsKG1hdGVyaWFsT3B0aW9ucykKICAgIH0gPSBvcHRpb25zOwogICAgY29uc3QgewogICAgICBhbmd1bGFyRmFjdG9yID0gWzEsIDEsIDFdLAogICAgICBhbmd1bGFyVmVsb2NpdHkgPSBbMCwgMCwgMF0sCiAgICAgIGFyZ3MgPSBbXSwKICAgICAgY29sbGlzaW9uUmVzcG9uc2UsCiAgICAgIGxpbmVhckZhY3RvciA9IFsxLCAxLCAxXSwKICAgICAgbWFzcywKICAgICAgbWF0ZXJpYWwsCiAgICAgIG9uQ29sbGlkZSwKICAgICAgcG9zaXRpb24gPSBbMCwgMCwgMF0sCiAgICAgIHJvdGF0aW9uLAogICAgICBxdWF0ZXJuaW9uLAogICAgICBzaGFwZXMsCiAgICAgIHR5cGU6IGJvZHlUeXBlLAogICAgICB2ZWxvY2l0eSA9IFswLCAwLCAwXSwKICAgICAgLi4uZXh0cmEKICAgIH0gPSBwcm9wczsKICAgIGNvbnN0IGJvZHkgPSBuZXcgQm9keSh7CiAgICAgIC4uLmV4dHJhLAogICAgICBtYXNzOiBib2R5VHlwZSA9PT0gJ1N0YXRpYycgPyAwIDogbWFzcywKICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsID8gY3JlYXRlTWF0ZXJpYWwobWF0ZXJpYWwpIDogdW5kZWZpbmVkLAogICAgICB0eXBlOiBib2R5VHlwZSA/IEJvZHlbYm9keVR5cGUudG9VcHBlckNhc2UoKV0gOiB1bmRlZmluZWQKICAgIH0pOwogICAgYm9keS51dWlkID0gdXVpZDsKICAgIGlmIChjb2xsaXNpb25SZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgIGJvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSBjb2xsaXNpb25SZXNwb25zZTsKICAgIH0KICAgIGlmICh0eXBlID09PSAnQ29tcG91bmQnKSB7CiAgICAgIHNoYXBlcy5mb3JFYWNoKF9yZWY0ID0+IHsKICAgICAgICBsZXQgewogICAgICAgICAgdHlwZSwKICAgICAgICAgIGFyZ3MsCiAgICAgICAgICBwb3NpdGlvbiwKICAgICAgICAgIHJvdGF0aW9uLAogICAgICAgICAgcXVhdGVybmlvbiwKICAgICAgICAgIG1hdGVyaWFsLAogICAgICAgICAgLi4uZXh0cmEKICAgICAgICB9ID0gX3JlZjQ7CiAgICAgICAgY29uc3Qgc2hhcGVCb2R5ID0gYm9keS5hZGRTaGFwZShjcmVhdGVTaGFwZSh0eXBlLCBhcmdzKSwgcG9zaXRpb24gPyBuZXcgVmVjMyguLi5wb3NpdGlvbikgOiB1bmRlZmluZWQsIHNldFF1YXRlcm5pb24obmV3IFF1YXRlcm5pb24oMCwgMCwgMCwgMSksIHsKICAgICAgICAgIHF1YXRlcm5pb24sCiAgICAgICAgICByb3RhdGlvbgogICAgICAgIH0pKTsKICAgICAgICBpZiAobWF0ZXJpYWwpIHNoYXBlQm9keS5tYXRlcmlhbCA9IGNyZWF0ZU1hdGVyaWFsKG1hdGVyaWFsKTsKICAgICAgICBPYmplY3QuYXNzaWduKHNoYXBlQm9keSwgZXh0cmEpOwogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIGJvZHkuYWRkU2hhcGUoY3JlYXRlU2hhcGUodHlwZSwgYXJncykpOwogICAgfQogICAgYm9keS5wb3NpdGlvbi5zZXQocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCBwb3NpdGlvblsyXSk7CiAgICBib2R5LnZlbG9jaXR5LnNldCh2ZWxvY2l0eVswXSwgdmVsb2NpdHlbMV0sIHZlbG9jaXR5WzJdKTsKICAgIGJvZHkuYW5ndWxhclZlbG9jaXR5LnNldChhbmd1bGFyVmVsb2NpdHlbMF0sIGFuZ3VsYXJWZWxvY2l0eVsxXSwgYW5ndWxhclZlbG9jaXR5WzJdKTsKICAgIGJvZHkubGluZWFyRmFjdG9yLnNldChsaW5lYXJGYWN0b3JbMF0sIGxpbmVhckZhY3RvclsxXSwgbGluZWFyRmFjdG9yWzJdKTsKICAgIGJvZHkuYW5ndWxhckZhY3Rvci5zZXQoYW5ndWxhckZhY3RvclswXSwgYW5ndWxhckZhY3RvclsxXSwgYW5ndWxhckZhY3RvclsyXSk7CiAgICBzZXRRdWF0ZXJuaW9uKGJvZHkucXVhdGVybmlvbiwgewogICAgICBxdWF0ZXJuaW9uLAogICAgICByb3RhdGlvbgogICAgfSk7CiAgICByZXR1cm4gYm9keTsKICB9OwoKICBjb25zdCBhZGRCb2RpZXMgPSAoc3RhdGUsIGNyZWF0ZU1hdGVyaWFsLCBfcmVmKSA9PiB7CiAgICBsZXQgewogICAgICBwcm9wcywKICAgICAgdHlwZSwKICAgICAgdXVpZAogICAgfSA9IF9yZWY7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV1aWQubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgYm9keSA9IHByb3BzVG9Cb2R5KHsKICAgICAgICBjcmVhdGVNYXRlcmlhbCwKICAgICAgICBwcm9wczogcHJvcHNbaV0sCiAgICAgICAgdHlwZSwKICAgICAgICB1dWlkOiB1dWlkW2ldCiAgICAgIH0pOwogICAgICBzdGF0ZS53b3JsZC5hZGRCb2R5KGJvZHkpOwogICAgICBpZiAocHJvcHNbaV0ub25Db2xsaWRlKSBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbGxpZGUnLCBfcmVmMiA9PiB7CiAgICAgICAgbGV0IHsKICAgICAgICAgIHR5cGUsCiAgICAgICAgICBib2R5LAogICAgICAgICAgdGFyZ2V0LAogICAgICAgICAgY29udGFjdAogICAgICAgIH0gPSBfcmVmMjsKICAgICAgICBpZiAoIWJvZHkudXVpZCB8fCAhdGFyZ2V0LnV1aWQpIHJldHVybjsKICAgICAgICBjb25zdCB7CiAgICAgICAgICBuaSwKICAgICAgICAgIHJpLAogICAgICAgICAgcmosCiAgICAgICAgICBiaSwKICAgICAgICAgIGJqLAogICAgICAgICAgaWQKICAgICAgICB9ID0gY29udGFjdDsKICAgICAgICBjb25zdCBjb250YWN0UG9pbnQgPSBiaS5wb3NpdGlvbi52YWRkKHJpKTsKICAgICAgICBjb25zdCBjb250YWN0Tm9ybWFsID0gYmkgPT09IGJvZHkgPyBuaSA6IG5pLnNjYWxlKC0xKTsKICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgICAgIGJvZHk6IGJvZHkudXVpZCwKICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcnM6IHsKICAgICAgICAgICAgYm9keUZpbHRlckdyb3VwOiBib2R5LmNvbGxpc2lvbkZpbHRlckdyb3VwLAogICAgICAgICAgICBib2R5RmlsdGVyTWFzazogYm9keS5jb2xsaXNpb25GaWx0ZXJNYXNrLAogICAgICAgICAgICB0YXJnZXRGaWx0ZXJHcm91cDogdGFyZ2V0LmNvbGxpc2lvbkZpbHRlckdyb3VwLAogICAgICAgICAgICB0YXJnZXRGaWx0ZXJNYXNrOiB0YXJnZXQuY29sbGlzaW9uRmlsdGVyTWFzawogICAgICAgICAgfSwKICAgICAgICAgIGNvbnRhY3Q6IHsKICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiB1c2UgaWQgaW5zdGVhZCBvZiB1dWlkCiAgICAgICAgICAgIGJpOiBiaS51dWlkLAogICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IHVzZSBpZCBpbnN0ZWFkIG9mIHV1aWQKICAgICAgICAgICAgYmo6IGJqLnV1aWQsCiAgICAgICAgICAgIC8vIE5vcm1hbCBvZiB0aGUgY29udGFjdCwgcmVsYXRpdmUgdG8gdGhlIGNvbGxpZGluZyBib2R5CiAgICAgICAgICAgIGNvbnRhY3ROb3JtYWw6IGNvbnRhY3ROb3JtYWwudG9BcnJheSgpLAogICAgICAgICAgICAvLyBXb3JsZCBwb3NpdGlvbiBvZiB0aGUgY29udGFjdAogICAgICAgICAgICBjb250YWN0UG9pbnQ6IGNvbnRhY3RQb2ludC50b0FycmF5KCksCiAgICAgICAgICAgIGlkLAogICAgICAgICAgICBpbXBhY3RWZWxvY2l0eTogY29udGFjdC5nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsKCksCiAgICAgICAgICAgIG5pOiBuaS50b0FycmF5KCksCiAgICAgICAgICAgIHJpOiByaS50b0FycmF5KCksCiAgICAgICAgICAgIHJqOiByai50b0FycmF5KCkKICAgICAgICAgIH0sCiAgICAgICAgICBvcDogJ2V2ZW50JywKICAgICAgICAgIHRhcmdldDogdGFyZ2V0LnV1aWQsCiAgICAgICAgICB0eXBlCiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgfQogIH07CgogIGNvbnN0IHRyaXBsZXRUb1ZlYzMgPSB0ID0+IHQgPyBuZXcgVmVjMyguLi50KSA6IHVuZGVmaW5lZDsKCiAgY29uc3QgYWRkQ29uc3RyYWludCA9IChzdGF0ZSwgX3JlZikgPT4gewogICAgbGV0IHsKICAgICAgcHJvcHM6IFtib2R5QSwgYm9keUIsIHsKICAgICAgICBhbmdsZSwKICAgICAgICBheGlzQSwKICAgICAgICBheGlzQiwKICAgICAgICBjb2xsaWRlQ29ubmVjdGVkLAogICAgICAgIGRpc3RhbmNlLAogICAgICAgIG1heEZvcmNlLAogICAgICAgIG1heE11bHRpcGxpZXIsCiAgICAgICAgcGl2b3RBLAogICAgICAgIHBpdm90QiwKICAgICAgICB0d2lzdEFuZ2xlLAogICAgICAgIHdha2VVcEJvZGllcwogICAgICB9XSwKICAgICAgdHlwZSwKICAgICAgdXVpZAogICAgfSA9IF9yZWY7CiAgICBsZXQgY29uc3RyYWludDsKICAgIHN3aXRjaCAodHlwZSkgewogICAgICBjYXNlICdQb2ludFRvUG9pbnQnOgogICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCB0cmlwbGV0VG9WZWMzKHBpdm90QSksIHN0YXRlLmJvZGllc1tib2R5Ql0sIHRyaXBsZXRUb1ZlYzMocGl2b3RCKSwgbWF4Rm9yY2UpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdDb25lVHdpc3QnOgogICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQ29uZVR3aXN0Q29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCB7CiAgICAgICAgICBhbmdsZSwKICAgICAgICAgIGF4aXNBOiB0cmlwbGV0VG9WZWMzKGF4aXNBKSwKICAgICAgICAgIGF4aXNCOiB0cmlwbGV0VG9WZWMzKGF4aXNCKSwKICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQsCiAgICAgICAgICBtYXhGb3JjZSwKICAgICAgICAgIHBpdm90QTogdHJpcGxldFRvVmVjMyhwaXZvdEEpLAogICAgICAgICAgcGl2b3RCOiB0cmlwbGV0VG9WZWMzKHBpdm90QiksCiAgICAgICAgICB0d2lzdEFuZ2xlCiAgICAgICAgfSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ0hpbmdlJzoKICAgICAgICBjb25zdHJhaW50ID0gbmV3IEhpbmdlQ29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCB7CiAgICAgICAgICBheGlzQTogdHJpcGxldFRvVmVjMyhheGlzQSksCiAgICAgICAgICBheGlzQjogdHJpcGxldFRvVmVjMyhheGlzQiksCiAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkLAogICAgICAgICAgbWF4Rm9yY2UsCiAgICAgICAgICBwaXZvdEE6IHRyaXBsZXRUb1ZlYzMocGl2b3RBKSwKICAgICAgICAgIHBpdm90QjogdHJpcGxldFRvVmVjMyhwaXZvdEIpCiAgICAgICAgfSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ0Rpc3RhbmNlJzoKICAgICAgICBjb25zdHJhaW50ID0gbmV3IERpc3RhbmNlQ29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCBkaXN0YW5jZSwgbWF4Rm9yY2UpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdMb2NrJzoKICAgICAgICBjb25zdHJhaW50ID0gbmV3IExvY2tDb25zdHJhaW50KHN0YXRlLmJvZGllc1tib2R5QV0sIHN0YXRlLmJvZGllc1tib2R5Ql0sIHsKICAgICAgICAgIG1heEZvcmNlCiAgICAgICAgfSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgY29uc3RyYWludCA9IG5ldyBDb25zdHJhaW50KHN0YXRlLmJvZGllc1tib2R5QV0sIHN0YXRlLmJvZGllc1tib2R5Ql0sIHsKICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQsCiAgICAgICAgICB3YWtlVXBCb2RpZXMKICAgICAgICB9KTsKICAgICAgICBicmVhazsKICAgIH0KICAgIGNvbnN0cmFpbnQudXVpZCA9IHV1aWQ7CiAgICBzdGF0ZS53b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpOwogICAgaWYgKG1heE11bHRpcGxpZXIgIT09IHVuZGVmaW5lZCkgewogICAgICBjb25zdCBwb3N0U3RlcENvbnN0cmFpbnQgPSAoKSA9PiB7CiAgICAgICAgLy8gVGhlIG11bHRpcGxpZXIgaXMgcHJvcG9ydGlvbmFsIHRvIGhvdyBtdWNoIGZvcmNlIGlzIGFkZGVkIHRvIHRoZSBib2RpZXMgYnkgdGhlIGNvbnN0cmFpbnQuCiAgICAgICAgLy8gSWYgdGhpcyBleGNlZWRzIGEgbGltaXQgdGhlIGNvbnN0cmFpbnQgaXMgZGlzYWJsZWQuCiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IE1hdGguYWJzKGNvbnN0cmFpbnQuZXF1YXRpb25zWzBdLm11bHRpcGxpZXIpOwogICAgICAgIGlmIChtdWx0aXBsaWVyID4gbWF4TXVsdGlwbGllcikgewogICAgICAgICAgY29uc3RyYWludC5kaXNhYmxlKCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBzdGF0ZS5jb25zdHJhaW50c1t1dWlkXSA9IHBvc3RTdGVwQ29uc3RyYWludDsKICAgICAgc3RhdGUud29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncG9zdFN0ZXAnLCBzdGF0ZS5jb25zdHJhaW50c1t1dWlkXSk7CiAgICB9CiAgfTsKCiAgZnVuY3Rpb24gdG9VcHBlcmNhc2Uoc3RyKSB7CiAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7CiAgfQogIGNvbnN0IGFkZFJheSA9IChzdGF0ZSwgX3JlZikgPT4gewogICAgbGV0IHsKICAgICAgcHJvcHM6IHsKICAgICAgICBmcm9tLAogICAgICAgIG1vZGUsCiAgICAgICAgdG8sCiAgICAgICAgLi4ucmF5T3B0aW9ucwogICAgICB9LAogICAgICB1dWlkCiAgICB9ID0gX3JlZjsKICAgIGNvbnN0IHJheSA9IG5ldyBSYXkodHJpcGxldFRvVmVjMyhmcm9tKSwgdHJpcGxldFRvVmVjMyh0bykpOwogICAgY29uc3Qgb3B0aW9ucyA9IHsKICAgICAgbW9kZTogUkFZX01PREVTW3RvVXBwZXJjYXNlKG1vZGUpXSwKICAgICAgcmVzdWx0OiBuZXcgUmF5Y2FzdFJlc3VsdCgpLAogICAgICAuLi5yYXlPcHRpb25zCiAgICB9OwogICAgc3RhdGUucmF5c1t1dWlkXSA9ICgpID0+IHsKICAgICAgcmF5LmludGVyc2VjdFdvcmxkKHN0YXRlLndvcmxkLCBvcHRpb25zKTsKICAgICAgaWYgKCFvcHRpb25zLnJlc3VsdCB8fCAhb3B0aW9ucy5yZXN1bHQuYm9keSkgcmV0dXJuOwogICAgICBjb25zdCB7CiAgICAgICAgYm9keSwKICAgICAgICBzaGFwZSwKICAgICAgICByYXlGcm9tV29ybGQsCiAgICAgICAgcmF5VG9Xb3JsZCwKICAgICAgICBoaXROb3JtYWxXb3JsZCwKICAgICAgICBoaXRQb2ludFdvcmxkLAogICAgICAgIC4uLnJlc3QKICAgICAgfSA9IG9wdGlvbnMucmVzdWx0OwogICAgICBjb25zdCBib2R5VVVJRCA9IGJvZHkudXVpZDsKICAgICAgaWYgKCFib2R5VVVJRCkgcmV0dXJuOwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgICBib2R5OiBib2R5VVVJRCwKICAgICAgICBoaXROb3JtYWxXb3JsZDogaGl0Tm9ybWFsV29ybGQudG9BcnJheSgpLAogICAgICAgIGhpdFBvaW50V29ybGQ6IGhpdFBvaW50V29ybGQudG9BcnJheSgpLAogICAgICAgIG9wOiAnZXZlbnQnLAogICAgICAgIHJheTogewogICAgICAgICAgY29sbGlzaW9uRmlsdGVyR3JvdXA6IHJheS5jb2xsaXNpb25GaWx0ZXJHcm91cCwKICAgICAgICAgIGNvbGxpc2lvbkZpbHRlck1hc2s6IHJheS5jb2xsaXNpb25GaWx0ZXJNYXNrLAogICAgICAgICAgZGlyZWN0aW9uOiByYXkuZGlyZWN0aW9uLnRvQXJyYXkoKSwKICAgICAgICAgIGZyb20sCiAgICAgICAgICB0bywKICAgICAgICAgIHV1aWQKICAgICAgICB9LAogICAgICAgIHJheUZyb21Xb3JsZDogcmF5RnJvbVdvcmxkLnRvQXJyYXkoKSwKICAgICAgICByYXlUb1dvcmxkOiByYXlUb1dvcmxkLnRvQXJyYXkoKSwKICAgICAgICBzaGFwZTogc2hhcGUgPyB7CiAgICAgICAgICAuLi5zaGFwZSwKICAgICAgICAgIGJvZHk6IGJvZHlVVUlECiAgICAgICAgfSA6IG51bGwsCiAgICAgICAgdHlwZTogJ3JheWhpdCcsCiAgICAgICAgLi4ucmVzdAogICAgICB9KTsKICAgIH07CiAgICBzdGF0ZS53b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgc3RhdGUucmF5c1t1dWlkXSk7CiAgfTsKCiAgY29uc3QgYWRkUmF5Y2FzdFZlaGljbGUgPSAoc3RhdGUsIGRhdGEpID0+IHsKICAgIGNvbnN0IFtjaGFzc2lzQm9keSwgd2hlZWxzLCB3aGVlbEluZm9zLCBpbmRleEZvcndhcmRBeGlzLCBpbmRleFJpZ2h0QXhpcywgaW5kZXhVcEF4aXNdID0gZGF0YS5wcm9wczsKICAgIGNvbnN0IHZlaGljbGUgPSBuZXcgUmF5Y2FzdFZlaGljbGUoewogICAgICBjaGFzc2lzQm9keTogc3RhdGUuYm9kaWVzW2NoYXNzaXNCb2R5XSwKICAgICAgaW5kZXhGb3J3YXJkQXhpcywKICAgICAgaW5kZXhSaWdodEF4aXMsCiAgICAgIGluZGV4VXBBeGlzCiAgICB9KTsKICAgIHZlaGljbGUud29ybGQgPSBzdGF0ZS53b3JsZDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2hlZWxJbmZvcy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCB7CiAgICAgICAgYXhsZUxvY2FsLAogICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbCwKICAgICAgICBkaXJlY3Rpb25Mb2NhbCwKICAgICAgICAuLi5yZXN0CiAgICAgIH0gPSB3aGVlbEluZm9zW2ldOwogICAgICB2ZWhpY2xlLmFkZFdoZWVsKHsKICAgICAgICBheGxlTG9jYWw6IHRyaXBsZXRUb1ZlYzMoYXhsZUxvY2FsKSwKICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWw6IHRyaXBsZXRUb1ZlYzMoY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsKSwKICAgICAgICBkaXJlY3Rpb25Mb2NhbDogdHJpcGxldFRvVmVjMyhkaXJlY3Rpb25Mb2NhbCksCiAgICAgICAgLi4ucmVzdAogICAgICB9KTsKICAgIH0KICAgIGNvbnN0IHByZVN0ZXAgPSAoKSA9PiB7CiAgICAgIHZlaGljbGUudXBkYXRlVmVoaWNsZShzdGF0ZS53b3JsZC5kdCk7CiAgICB9OwogICAgY29uc3QgcG9zdFN0ZXAgPSAoKSA9PiB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVoaWNsZS53aGVlbEluZm9zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmVoaWNsZS51cGRhdGVXaGVlbFRyYW5zZm9ybShpKTsKICAgICAgICBjb25zdCB0ID0gdmVoaWNsZS53aGVlbEluZm9zW2ldLndvcmxkVHJhbnNmb3JtOwogICAgICAgIGNvbnN0IHdoZWVsQm9keSA9IHN0YXRlLmJvZGllc1t3aGVlbHNbaV1dOwogICAgICAgIHdoZWVsQm9keS5wb3NpdGlvbi5jb3B5KHQucG9zaXRpb24pOwogICAgICAgIHdoZWVsQm9keS5xdWF0ZXJuaW9uLmNvcHkodC5xdWF0ZXJuaW9uKTsKICAgICAgfQogICAgfTsKICAgIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF0gPSB7CiAgICAgIHBvc3RTdGVwLAogICAgICBwcmVTdGVwLAogICAgICB2ZWhpY2xlCiAgICB9OwogICAgc3RhdGUud29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHByZVN0ZXApOwogICAgc3RhdGUud29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncG9zdFN0ZXAnLCBwb3N0U3RlcCk7CiAgfTsKCiAgY29uc3QgYWRkU3ByaW5nID0gKHN0YXRlLCBfcmVmKSA9PiB7CiAgICBsZXQgewogICAgICBwcm9wczogW2JvZHlBLCBib2R5QiwgewogICAgICAgIGRhbXBpbmcsCiAgICAgICAgbG9jYWxBbmNob3JBLAogICAgICAgIGxvY2FsQW5jaG9yQiwKICAgICAgICByZXN0TGVuZ3RoLAogICAgICAgIHN0aWZmbmVzcywKICAgICAgICB3b3JsZEFuY2hvckEsCiAgICAgICAgd29ybGRBbmNob3JCCiAgICAgIH1dLAogICAgICB1dWlkCiAgICB9ID0gX3JlZjsKICAgIGNvbnN0IHNwcmluZyA9IG5ldyBTcHJpbmcoc3RhdGUuYm9kaWVzW2JvZHlBXSwgc3RhdGUuYm9kaWVzW2JvZHlCXSwgewogICAgICBkYW1waW5nLAogICAgICBsb2NhbEFuY2hvckE6IHRyaXBsZXRUb1ZlYzMobG9jYWxBbmNob3JBKSwKICAgICAgbG9jYWxBbmNob3JCOiB0cmlwbGV0VG9WZWMzKGxvY2FsQW5jaG9yQiksCiAgICAgIHJlc3RMZW5ndGgsCiAgICAgIHN0aWZmbmVzcywKICAgICAgd29ybGRBbmNob3JBOiB0cmlwbGV0VG9WZWMzKHdvcmxkQW5jaG9yQSksCiAgICAgIHdvcmxkQW5jaG9yQjogdHJpcGxldFRvVmVjMyh3b3JsZEFuY2hvckIpCiAgICB9KTsKICAgIHNwcmluZy51dWlkID0gdXVpZDsKICAgIGNvbnN0IHBvc3RTdGVwU3ByaW5nID0gKCkgPT4gc3ByaW5nLmFwcGx5Rm9yY2UoKTsKICAgIHN0YXRlLnNwcmluZ3NbdXVpZF0gPSBwb3N0U3RlcFNwcmluZzsKICAgIHN0YXRlLnNwcmluZ0luc3RhbmNlc1t1dWlkXSA9IHNwcmluZzsKCiAgICAvLyBDb21wdXRlIHRoZSBmb3JjZSBhZnRlciBlYWNoIHN0ZXAKICAgIHN0YXRlLndvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgc3RhdGUuc3ByaW5nc1t1dWlkXSk7CiAgfTsKCiAgZnVuY3Rpb24gZW1pdEJlZ2luQ29udGFjdChfcmVmKSB7CiAgICBsZXQgewogICAgICBib2R5QSwKICAgICAgYm9keUIKICAgIH0gPSBfcmVmOwogICAgaWYgKCEoYm9keUEgIT0gbnVsbCAmJiBib2R5QS51dWlkKSB8fCAhKGJvZHlCICE9IG51bGwgJiYgYm9keUIudXVpZCkpIHJldHVybjsKICAgIHNlbGYucG9zdE1lc3NhZ2UoewogICAgICBib2R5QTogYm9keUEudXVpZCwKICAgICAgYm9keUI6IGJvZHlCLnV1aWQsCiAgICAgIG9wOiAnZXZlbnQnLAogICAgICB0eXBlOiAnY29sbGlkZUJlZ2luJwogICAgfSk7CiAgfQogIGZ1bmN0aW9uIGVtaXRFbmRDb250YWN0KF9yZWYyKSB7CiAgICBsZXQgewogICAgICBib2R5QSwKICAgICAgYm9keUIKICAgIH0gPSBfcmVmMjsKICAgIGlmICghKGJvZHlBICE9IG51bGwgJiYgYm9keUEudXVpZCkgfHwgIShib2R5QiAhPSBudWxsICYmIGJvZHlCLnV1aWQpKSByZXR1cm47CiAgICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgYm9keUE6IGJvZHlBLnV1aWQsCiAgICAgIGJvZHlCOiBib2R5Qi51dWlkLAogICAgICBvcDogJ2V2ZW50JywKICAgICAgdHlwZTogJ2NvbGxpZGVFbmQnCiAgICB9KTsKICB9CiAgY29uc3QgaW5pdCA9ICh3b3JsZCwgX3JlZjMpID0+IHsKICAgIGxldCB7CiAgICAgIGFsbG93U2xlZXAsCiAgICAgIGF4aXNJbmRleCA9IDAsCiAgICAgIGJyb2FkcGhhc2UsCiAgICAgIGRlZmF1bHRDb250YWN0TWF0ZXJpYWwsCiAgICAgIGZyaWN0aW9uR3Jhdml0eSwKICAgICAgZ3Jhdml0eSwKICAgICAgaXRlcmF0aW9ucywKICAgICAgcXVhdE5vcm1hbGl6ZUZhc3QsCiAgICAgIHF1YXROb3JtYWxpemVTa2lwLAogICAgICBzb2x2ZXIsCiAgICAgIHRvbGVyYW5jZQogICAgfSA9IF9yZWYzOwogICAgd29ybGQuYWxsb3dTbGVlcCA9IGFsbG93U2xlZXA7CiAgICB3b3JsZC5ncmF2aXR5LnNldCguLi5ncmF2aXR5KTsKICAgIHdvcmxkLmZyaWN0aW9uR3Jhdml0eSA9IGZyaWN0aW9uR3Jhdml0eSA/IG5ldyBWZWMzKC4uLmZyaWN0aW9uR3Jhdml0eSkgOiB1bmRlZmluZWQ7CiAgICB3b3JsZC5xdWF0Tm9ybWFsaXplRmFzdCA9IHF1YXROb3JtYWxpemVGYXN0OwogICAgd29ybGQucXVhdE5vcm1hbGl6ZVNraXAgPSBxdWF0Tm9ybWFsaXplU2tpcDsKICAgIGlmIChzb2x2ZXIgPT09ICdTcGxpdCcpIHsKICAgICAgd29ybGQuc29sdmVyID0gbmV3IFNwbGl0U29sdmVyKG5ldyBHU1NvbHZlcigpKTsKICAgIH0KICAgIGlmICh3b3JsZC5zb2x2ZXIgaW5zdGFuY2VvZiBHU1NvbHZlcikgewogICAgICB3b3JsZC5zb2x2ZXIudG9sZXJhbmNlID0gdG9sZXJhbmNlOwogICAgICB3b3JsZC5zb2x2ZXIuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7CiAgICB9CiAgICB3b3JsZC5icm9hZHBoYXNlID0gYnJvYWRwaGFzZSA9PT0gJ1NBUCcgPyBuZXcgU0FQQnJvYWRwaGFzZSh3b3JsZCkgOiBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7CiAgICBpZiAod29ybGQuYnJvYWRwaGFzZSBpbnN0YW5jZW9mIFNBUEJyb2FkcGhhc2UpIHsKICAgICAgd29ybGQuYnJvYWRwaGFzZS5heGlzSW5kZXggPSBheGlzSW5kZXg7CiAgICB9CiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdiZWdpbkNvbnRhY3QnLCBlbWl0QmVnaW5Db250YWN0KTsKICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZENvbnRhY3QnLCBlbWl0RW5kQ29udGFjdCk7CiAgICBPYmplY3QuYXNzaWduKHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwsIGRlZmF1bHRDb250YWN0TWF0ZXJpYWwpOwogIH07CgogIGNvbnN0IGlzUW9yViA9IHYgPT4gdiBpbnN0YW5jZW9mIFF1YXRlcm5pb24gfHwgdiBpbnN0YW5jZW9mIFZlYzM7CiAgY29uc3Qgc3RlcCA9IChzdGF0ZSwgX3JlZikgPT4gewogICAgbGV0IHsKICAgICAgcG9zaXRpb25zLAogICAgICBwcm9wczogewogICAgICAgIG1heFN1YlN0ZXBzLAogICAgICAgIHN0ZXBTaXplLAogICAgICAgIHRpbWVTaW5jZUxhc3RDYWxsZWQKICAgICAgfSwKICAgICAgcXVhdGVybmlvbnMKICAgIH0gPSBfcmVmOwogICAgc3RhdGUud29ybGQuc3RlcChzdGVwU2l6ZSwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS53b3JsZC5ib2RpZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgY29uc3QgcCA9IHN0YXRlLndvcmxkLmJvZGllc1tpXS5wb3NpdGlvbjsKICAgICAgY29uc3QgcSA9IHN0YXRlLndvcmxkLmJvZGllc1tpXS5xdWF0ZXJuaW9uOwogICAgICBwb3NpdGlvbnNbMyAqIGkgKyAwXSA9IHAueDsKICAgICAgcG9zaXRpb25zWzMgKiBpICsgMV0gPSBwLnk7CiAgICAgIHBvc2l0aW9uc1szICogaSArIDJdID0gcC56OwogICAgICBxdWF0ZXJuaW9uc1s0ICogaSArIDBdID0gcS54OwogICAgICBxdWF0ZXJuaW9uc1s0ICogaSArIDFdID0gcS55OwogICAgICBxdWF0ZXJuaW9uc1s0ICogaSArIDJdID0gcS56OwogICAgICBxdWF0ZXJuaW9uc1s0ICogaSArIDNdID0gcS53OwogICAgfQogICAgY29uc3Qgb2JzZXJ2YXRpb25zID0gW107CiAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHN0YXRlLnN1YnNjcmlwdGlvbnMpKSB7CiAgICAgIGNvbnN0IFt1dWlkLCB0eXBlLCB0YXJnZXQgPSAnYm9kaWVzJ10gPSBzdGF0ZS5zdWJzY3JpcHRpb25zW2lkXTsKICAgICAgY29uc3QgewogICAgICAgIGJvZGllcywKICAgICAgICB2ZWhpY2xlcwogICAgICB9ID0gc3RhdGU7CiAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0ID09PSAndmVoaWNsZXMnID8KICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBEaWZmZXJlbnRpYXRlIHRoZXNlICJ0eXBlcyIKICAgICAgdmVoaWNsZXNbdXVpZF0udmVoaWNsZVt0eXBlXSA6CiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogRGlmZmVyZW50aWF0ZSB0aGVzZSAidHlwZXMiCiAgICAgIGJvZGllc1t1dWlkXVt0eXBlXTsKICAgICAgY29uc3Qgc2VyaWFsaXphYmxlVmFsdWUgPSBpc1FvclYodmFsdWUpID8gdmFsdWUudG9BcnJheSgpIDogdmFsdWU7CiAgICAgIG9ic2VydmF0aW9ucy5wdXNoKFtOdW1iZXIoaWQpLCBzZXJpYWxpemFibGVWYWx1ZSwKICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBEaWZmZXJlbnRpYXRlIHRoZXNlICJ0eXBlcyIKICAgICAgdHlwZV0pOwogICAgfQogICAgY29uc3QgbWVzc2FnZSA9IHsKICAgICAgYWN0aXZlOiBzdGF0ZS53b3JsZC5oYXNBY3RpdmVCb2RpZXMsCiAgICAgIG9ic2VydmF0aW9ucywKICAgICAgb3A6ICdmcmFtZScsCiAgICAgIHBvc2l0aW9ucywKICAgICAgcXVhdGVybmlvbnMKICAgIH07CiAgICBpZiAoc3RhdGUuYm9kaWVzTmVlZFN5bmNpbmcpIHsKICAgICAgbWVzc2FnZS5ib2RpZXMgPSBzdGF0ZS53b3JsZC5ib2RpZXMucmVkdWNlKChib2RpZXMsIGJvZHkpID0+IHsKICAgICAgICBpZiAoYm9keS51dWlkKSBib2RpZXMucHVzaChib2R5LnV1aWQpOwogICAgICAgIHJldHVybiBib2RpZXM7CiAgICAgIH0sIFtdKTsKICAgICAgc3RhdGUuYm9kaWVzTmVlZFN5bmNpbmcgPSBmYWxzZTsKICAgIH0KICAgIHNlbGYucG9zdE1lc3NhZ2UobWVzc2FnZSwgW3Bvc2l0aW9ucy5idWZmZXIsIHF1YXRlcm5pb25zLmJ1ZmZlcl0pOwogIH07CgogIGNvbnN0IHN0YXRlID0gewogICAgYm9kaWVzOiB7fSwKICAgIGJvZGllc05lZWRTeW5jaW5nOiBmYWxzZSwKICAgIGNvbnN0cmFpbnRzOiB7fSwKICAgIG1hdGVyaWFsczoge30sCiAgICByYXlzOiB7fSwKICAgIHNwcmluZ0luc3RhbmNlczoge30sCiAgICBzcHJpbmdzOiB7fSwKICAgIHN1YnNjcmlwdGlvbnM6IHt9LAogICAgdmVoaWNsZXM6IHt9LAogICAgd29ybGQ6IG5ldyBXb3JsZCgpCiAgfTsKCiAgLy8vIDxyZWZlcmVuY2Ugbm8tZGVmYXVsdC1saWI9InRydWUiLz4KICBjb25zdCBpc0hpbmdlQ29uc3RyYWludCA9IGMgPT4gYyBpbnN0YW5jZW9mIEhpbmdlQ29uc3RyYWludDsKICBmdW5jdGlvbiBzeW5jQm9kaWVzKCkgewogICAgc3RhdGUuYm9kaWVzTmVlZFN5bmNpbmcgPSB0cnVlOwogICAgc3RhdGUuYm9kaWVzID0gc3RhdGUud29ybGQuYm9kaWVzLnJlZHVjZSgoYm9kaWVzLCBib2R5KSA9PiBib2R5LnV1aWQgPyB7CiAgICAgIC4uLmJvZGllcywKICAgICAgW2JvZHkudXVpZF06IGJvZHkKICAgIH0gOiBib2RpZXMsIHt9KTsKICB9CiAgY29uc3QgYnJvYWRwaGFzZXMgPSB7CiAgICBOYWl2ZUJyb2FkcGhhc2UsCiAgICBTQVBCcm9hZHBoYXNlCiAgfTsKICBjb25zdCBjcmVhdGVNYXRlcmlhbCA9IGNyZWF0ZU1hdGVyaWFsRmFjdG9yeShzdGF0ZS5tYXRlcmlhbHMpOwogIHNlbGYub25tZXNzYWdlID0gX3JlZiA9PiB7CiAgICBsZXQgewogICAgICBkYXRhCiAgICB9ID0gX3JlZjsKICAgIHN3aXRjaCAoZGF0YS5vcCkgewogICAgICBjYXNlICdpbml0JzoKICAgICAgICB7CiAgICAgICAgICBpbml0KHN0YXRlLndvcmxkLCBkYXRhLnByb3BzKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc3RlcCc6CiAgICAgICAgewogICAgICAgICAgc3RlcChzdGF0ZSwgZGF0YSk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ2FkZEJvZGllcyc6CiAgICAgICAgewogICAgICAgICAgYWRkQm9kaWVzKHN0YXRlLCBjcmVhdGVNYXRlcmlhbCwgZGF0YSk7CiAgICAgICAgICBzeW5jQm9kaWVzKCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3JlbW92ZUJvZGllcyc6CiAgICAgICAgewogICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLnV1aWQubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgc3RhdGUud29ybGQucmVtb3ZlQm9keShzdGF0ZS5ib2RpZXNbZGF0YS51dWlkW2ldXSk7CiAgICAgICAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKHN0YXRlLnN1YnNjcmlwdGlvbnMpLmZpbmQoayA9PiBzdGF0ZS5zdWJzY3JpcHRpb25zW2tdWzBdID09PSBkYXRhLnV1aWRbaV0pOwogICAgICAgICAgICBpZiAoa2V5KSB7CiAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnN1YnNjcmlwdGlvbnNba2V5XTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgc3luY0JvZGllcygpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzdWJzY3JpYmUnOgogICAgICAgIHsKICAgICAgICAgIGNvbnN0IHsKICAgICAgICAgICAgaWQsCiAgICAgICAgICAgIHRhcmdldCwKICAgICAgICAgICAgdHlwZQogICAgICAgICAgfSA9IGRhdGEucHJvcHM7CiAgICAgICAgICBzdGF0ZS5zdWJzY3JpcHRpb25zW2lkXSA9IFtkYXRhLnV1aWQsIHR5cGUsIHRhcmdldF07CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlJzoKICAgICAgICB7CiAgICAgICAgICBkZWxldGUgc3RhdGUuc3Vic2NyaXB0aW9uc1tkYXRhLnByb3BzXTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc2V0UG9zaXRpb24nOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLnBvc2l0aW9uLnNldChkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0UXVhdGVybmlvbic6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ucXVhdGVybmlvbi5zZXQoZGF0YS5wcm9wc1swXSwgZGF0YS5wcm9wc1sxXSwgZGF0YS5wcm9wc1syXSwgZGF0YS5wcm9wc1szXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldFJvdGF0aW9uJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0VmVsb2NpdHknOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLnZlbG9jaXR5LnNldChkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QW5ndWxhclZlbG9jaXR5JzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hbmd1bGFyVmVsb2NpdHkuc2V0KGRhdGEucHJvcHNbMF0sIGRhdGEucHJvcHNbMV0sIGRhdGEucHJvcHNbMl0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRMaW5lYXJGYWN0b3InOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmxpbmVhckZhY3Rvci5zZXQoZGF0YS5wcm9wc1swXSwgZGF0YS5wcm9wc1sxXSwgZGF0YS5wcm9wc1syXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEFuZ3VsYXJGYWN0b3InOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFuZ3VsYXJGYWN0b3Iuc2V0KGRhdGEucHJvcHNbMF0sIGRhdGEucHJvcHNbMV0sIGRhdGEucHJvcHNbMl0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRNYXNzJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5tYXNzID0gZGF0YS5wcm9wczsKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS51cGRhdGVNYXNzUHJvcGVydGllcygpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRNYXRlcmlhbCc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ubWF0ZXJpYWwgPSBkYXRhLnByb3BzID8gY3JlYXRlTWF0ZXJpYWwoZGF0YS5wcm9wcykgOiBudWxsOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRMaW5lYXJEYW1waW5nJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5saW5lYXJEYW1waW5nID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QW5ndWxhckRhbXBpbmcnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFuZ3VsYXJEYW1waW5nID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QWxsb3dTbGVlcCc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uYWxsb3dTbGVlcCA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldFNsZWVwU3BlZWRMaW1pdCc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uc2xlZXBTcGVlZExpbWl0ID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0U2xlZXBUaW1lTGltaXQnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLnNsZWVwVGltZUxpbWl0ID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0Q29sbGlzaW9uRmlsdGVyR3JvdXAnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0Q29sbGlzaW9uRmlsdGVyTWFzayc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uY29sbGlzaW9uRmlsdGVyTWFzayA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldENvbGxpc2lvblJlc3BvbnNlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5jb2xsaXNpb25SZXNwb25zZSA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEZpeGVkUm90YXRpb24nOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmZpeGVkUm90YXRpb24gPSBkYXRhLnByb3BzOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRGcmljdGlvbkdyYXZpdHknOgogICAgICAgIHN0YXRlLndvcmxkLmZyaWN0aW9uR3Jhdml0eSA9IGRhdGEucHJvcHMgPyBuZXcgVmVjMyguLi5kYXRhLnByb3BzKSA6IHVuZGVmaW5lZDsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0SXNUcmlnZ2VyJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5pc1RyaWdnZXIgPSBkYXRhLnByb3BzOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRHcmF2aXR5JzoKICAgICAgICBzdGF0ZS53b3JsZC5ncmF2aXR5LnNldChkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0VG9sZXJhbmNlJzoKICAgICAgICBpZiAoc3RhdGUud29ybGQuc29sdmVyIGluc3RhbmNlb2YgR1NTb2x2ZXIpIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnNvbHZlci50b2xlcmFuY2UgPSBkYXRhLnByb3BzOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0SXRlcmF0aW9ucyc6CiAgICAgICAgaWYgKHN0YXRlLndvcmxkLnNvbHZlciBpbnN0YW5jZW9mIEdTU29sdmVyKSB7CiAgICAgICAgICBzdGF0ZS53b3JsZC5zb2x2ZXIuaXRlcmF0aW9ucyA9IGRhdGEucHJvcHM7CiAgICAgICAgfQogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRCcm9hZHBoYXNlJzoKICAgICAgICBzdGF0ZS53b3JsZC5icm9hZHBoYXNlID0gbmV3IChicm9hZHBoYXNlc1tgJHtkYXRhLnByb3BzfUJyb2FkcGhhc2VgXSB8fCBOYWl2ZUJyb2FkcGhhc2UpKHN0YXRlLndvcmxkKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QXhpc0luZGV4JzoKICAgICAgICBpZiAoc3RhdGUud29ybGQuYnJvYWRwaGFzZSBpbnN0YW5jZW9mIFNBUEJyb2FkcGhhc2UpIHsKICAgICAgICAgIHN0YXRlLndvcmxkLmJyb2FkcGhhc2UuYXhpc0luZGV4ID0gZGF0YS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8IGRhdGEucHJvcHMgPT09IG51bGwgPyAwIDogZGF0YS5wcm9wczsKICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FwcGx5Rm9yY2UnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFwcGx5Rm9yY2UobmV3IFZlYzMoLi4uZGF0YS5wcm9wc1swXSksIG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMV0pKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnYXBwbHlJbXB1bHNlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hcHBseUltcHVsc2UobmV3IFZlYzMoLi4uZGF0YS5wcm9wc1swXSksIG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMV0pKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnYXBwbHlMb2NhbEZvcmNlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hcHBseUxvY2FsRm9yY2UobmV3IFZlYzMoLi4uZGF0YS5wcm9wc1swXSksIG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMV0pKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnYXBwbHlMb2NhbEltcHVsc2UnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFwcGx5TG9jYWxJbXB1bHNlKG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMF0pLCBuZXcgVmVjMyguLi5kYXRhLnByb3BzWzFdKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FwcGx5VG9ycXVlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hcHBseVRvcnF1ZShuZXcgVmVjMyguLi5kYXRhLnByb3BzWzBdKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FkZENvbnN0cmFpbnQnOgogICAgICAgIHsKICAgICAgICAgIGFkZENvbnN0cmFpbnQoc3RhdGUsIGRhdGEpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdyZW1vdmVDb25zdHJhaW50JzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoX3JlZjIgPT4gewogICAgICAgICAgbGV0IHsKICAgICAgICAgICAgdXVpZAogICAgICAgICAgfSA9IF9yZWYyOwogICAgICAgICAgcmV0dXJuIHV1aWQgPT09IGRhdGEudXVpZDsKICAgICAgICB9KS5tYXAoYyA9PiBzdGF0ZS53b3JsZC5yZW1vdmVDb25zdHJhaW50KGMpKTsKICAgICAgICBpZiAoc3RhdGUuY29uc3RyYWludHNbZGF0YS51dWlkXSkgewogICAgICAgICAgc3RhdGUud29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9zdFN0ZXAnLCBzdGF0ZS5jb25zdHJhaW50c1tkYXRhLnV1aWRdKTsKICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jb25zdHJhaW50c1tkYXRhLnV1aWRdOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgY2FzZSAnZW5hYmxlQ29uc3RyYWludCc6CiAgICAgICAgc3RhdGUud29ybGQuY29uc3RyYWludHMuZmlsdGVyKGMgPT4gYy51dWlkID09PSBkYXRhLnV1aWQpLm1hcChjID0+IGMuZW5hYmxlKCkpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdkaXNhYmxlQ29uc3RyYWludCc6CiAgICAgICAgc3RhdGUud29ybGQuY29uc3RyYWludHMuZmlsdGVyKGMgPT4gYy51dWlkID09PSBkYXRhLnV1aWQpLm1hcChjID0+IGMuZGlzYWJsZSgpKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnZW5hYmxlQ29uc3RyYWludE1vdG9yJzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoYyA9PiBjLnV1aWQgPT09IGRhdGEudXVpZCkuZmlsdGVyKGlzSGluZ2VDb25zdHJhaW50KS5tYXAoYyA9PiBjLmVuYWJsZU1vdG9yKCkpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdkaXNhYmxlQ29uc3RyYWludE1vdG9yJzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoYyA9PiBjLnV1aWQgPT09IGRhdGEudXVpZCkuZmlsdGVyKGlzSGluZ2VDb25zdHJhaW50KS5tYXAoYyA9PiBjLmRpc2FibGVNb3RvcigpKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0Q29uc3RyYWludE1vdG9yU3BlZWQnOgogICAgICAgIHN0YXRlLndvcmxkLmNvbnN0cmFpbnRzLmZpbHRlcihjID0+IGMudXVpZCA9PT0gZGF0YS51dWlkKS5maWx0ZXIoaXNIaW5nZUNvbnN0cmFpbnQpLm1hcChjID0+IGMuc2V0TW90b3JTcGVlZChkYXRhLnByb3BzKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldENvbnN0cmFpbnRNb3Rvck1heEZvcmNlJzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoYyA9PiBjLnV1aWQgPT09IGRhdGEudXVpZCkuZmlsdGVyKGlzSGluZ2VDb25zdHJhaW50KS5tYXAoYyA9PiBjLnNldE1vdG9yTWF4Rm9yY2UoZGF0YS5wcm9wcykpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdhZGRTcHJpbmcnOgogICAgICAgIHsKICAgICAgICAgIGFkZFNwcmluZyhzdGF0ZSwgZGF0YSk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3NldFNwcmluZ1N0aWZmbmVzcyc6CiAgICAgICAgewogICAgICAgICAgc3RhdGUuc3ByaW5nSW5zdGFuY2VzW2RhdGEudXVpZF0uc3RpZmZuZXNzID0gZGF0YS5wcm9wczsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc2V0U3ByaW5nUmVzdExlbmd0aCc6CiAgICAgICAgewogICAgICAgICAgc3RhdGUuc3ByaW5nSW5zdGFuY2VzW2RhdGEudXVpZF0ucmVzdExlbmd0aCA9IGRhdGEucHJvcHM7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3NldFNwcmluZ0RhbXBpbmcnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLnNwcmluZ0luc3RhbmNlc1tkYXRhLnV1aWRdLmRhbXBpbmcgPSBkYXRhLnByb3BzOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdyZW1vdmVTcHJpbmcnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgc3RhdGUuc3ByaW5nc1tkYXRhLnV1aWRdKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnYWRkUmF5JzoKICAgICAgICB7CiAgICAgICAgICBhZGRSYXkoc3RhdGUsIGRhdGEpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdyZW1vdmVSYXknOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCBzdGF0ZS5yYXlzW2RhdGEudXVpZF0pOwogICAgICAgICAgZGVsZXRlIHN0YXRlLnJheXNbZGF0YS51dWlkXTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnYWRkUmF5Y2FzdFZlaGljbGUnOgogICAgICAgIHsKICAgICAgICAgIGFkZFJheWNhc3RWZWhpY2xlKHN0YXRlLCBkYXRhKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAncmVtb3ZlUmF5Y2FzdFZlaGljbGUnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCBzdGF0ZS52ZWhpY2xlc1tkYXRhLnV1aWRdLnByZVN0ZXApOwogICAgICAgICAgc3RhdGUud29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9zdFN0ZXAnLCBzdGF0ZS52ZWhpY2xlc1tkYXRhLnV1aWRdLnBvc3RTdGVwKTsKICAgICAgICAgIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF0udmVoaWNsZS53b3JsZCA9IG51bGw7CiAgICAgICAgICBkZWxldGUgc3RhdGUudmVoaWNsZXNbZGF0YS51dWlkXTsKICAgICAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKHN0YXRlLnN1YnNjcmlwdGlvbnMpLmZpbmQoayA9PiBzdGF0ZS5zdWJzY3JpcHRpb25zW2tdWzBdID09PSBkYXRhLnV1aWQpOwogICAgICAgICAgaWYgKGtleSkgewogICAgICAgICAgICBkZWxldGUgc3RhdGUuc3Vic2NyaXB0aW9uc1trZXldOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzZXRSYXljYXN0VmVoaWNsZVN0ZWVyaW5nVmFsdWUnOgogICAgICAgIHsKICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgd2hlZWxJbmRleF0gPSBkYXRhLnByb3BzOwogICAgICAgICAgc3RhdGUudmVoaWNsZXNbZGF0YS51dWlkXS52ZWhpY2xlLnNldFN0ZWVyaW5nVmFsdWUodmFsdWUsIHdoZWVsSW5kZXgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdhcHBseVJheWNhc3RWZWhpY2xlRW5naW5lRm9yY2UnOgogICAgICAgIHsKICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgd2hlZWxJbmRleF0gPSBkYXRhLnByb3BzOwogICAgICAgICAgc3RhdGUudmVoaWNsZXNbZGF0YS51dWlkXS52ZWhpY2xlLmFwcGx5RW5naW5lRm9yY2UodmFsdWUsIHdoZWVsSW5kZXgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzZXRSYXljYXN0VmVoaWNsZUJyYWtlJzoKICAgICAgICB7CiAgICAgICAgICBjb25zdCBbYnJha2UsIHdoZWVsSW5kZXhdID0gZGF0YS5wcm9wczsKICAgICAgICAgIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF0udmVoaWNsZS5zZXRCcmFrZShicmFrZSwgd2hlZWxJbmRleCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ2FkZENvbnRhY3RNYXRlcmlhbCc6CiAgICAgICAgewogICAgICAgICAgYWRkQ29udGFjdE1hdGVyaWFsKHN0YXRlLndvcmxkLCBjcmVhdGVNYXRlcmlhbCwgZGF0YS5wcm9wcywgZGF0YS51dWlkKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAncmVtb3ZlQ29udGFjdE1hdGVyaWFsJzoKICAgICAgICB7CiAgICAgICAgICByZW1vdmVDb250YWN0TWF0ZXJpYWwoc3RhdGUud29ybGQsIGRhdGEudXVpZCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3dha2VVcCc6CiAgICAgICAgewogICAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ud2FrZVVwKCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3NsZWVwJzoKICAgICAgICB7CiAgICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5zbGVlcCgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgfQogIH07Cgp9KSgpOwoK", null, !1);
class Ote extends Kte {
  get axisIndex() {
    return this.config.axisIndex;
  }
  set axisIndex(e) {
    this.config.axisIndex = e, this.postMessage({
      op: "setAxisIndex",
      props: e
    });
  }
  get broadphase() {
    return this.config.broadphase;
  }
  set broadphase(e) {
    this.config.broadphase = e, this.postMessage({
      op: "setBroadphase",
      props: e
    });
  }
  get frictionGravity() {
    return this.config.frictionGravity;
  }
  set frictionGravity(e) {
    this.config.frictionGravity = e, this.postMessage({
      op: "setFrictionGravity",
      props: e
    });
  }
  get gravity() {
    return this.config.gravity;
  }
  set gravity(e) {
    this.config.gravity = e, this.postMessage({
      op: "setGravity",
      props: e
    });
  }
  get iterations() {
    return this.config.iterations;
  }
  set iterations(e) {
    this.config.iterations = e, this.postMessage({
      op: "setIterations",
      props: e
    });
  }
  get tolerance() {
    return this.config.tolerance;
  }
  set tolerance(e) {
    this.config.tolerance = e, this.postMessage({
      op: "setTolerance",
      props: e
    });
  }
  messageQueue = [];
  worker = null;
  constructor(e) {
    let {
      allowSleep: t = !1,
      axisIndex: n = 0,
      broadphase: i = "Naive",
      defaultContactMaterial: o = {
        contactEquationStiffness: 1e6
      },
      frictionGravity: l = null,
      gravity: u = [0, -9.81, 0],
      iterations: I = 5,
      quatNormalizeFast: C = !1,
      quatNormalizeSkip: f = 0,
      size: v = 1e3,
      solver: b = "GS",
      tolerance: S = 1e-3
    } = e;
    super(), this.config = {
      allowSleep: t,
      axisIndex: n,
      broadphase: i,
      defaultContactMaterial: o,
      frictionGravity: l,
      gravity: u,
      iterations: I,
      quatNormalizeFast: C,
      quatNormalizeSkip: f,
      size: v,
      solver: b,
      tolerance: S
    }, this.buffers = {
      positions: new Float32Array(v * 3),
      quaternions: new Float32Array(v * 4)
    };
  }
  addBodies(e) {
    let {
      props: t,
      type: n,
      uuid: i
    } = e;
    this.postMessage({
      op: "addBodies",
      props: t,
      type: n,
      uuid: i
    });
  }
  addConstraint(e) {
    let {
      props: [t, n, i],
      type: o,
      uuid: l
    } = e;
    this.postMessage({
      op: "addConstraint",
      props: [t, n, i],
      type: o,
      uuid: l
    });
  }
  addContactMaterial(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "addContactMaterial",
      props: t,
      uuid: n
    });
  }
  addRay(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "addRay",
      props: t,
      uuid: n
    });
  }
  addRaycastVehicle(e) {
    let {
      props: [t, n, i, o, l, u],
      uuid: I
    } = e;
    this.postMessage({
      op: "addRaycastVehicle",
      props: [t, n, i, o, l, u],
      uuid: I
    });
  }
  addSpring(e) {
    let {
      props: [t, n, i],
      uuid: o
    } = e;
    this.postMessage({
      op: "addSpring",
      props: [t, n, i],
      uuid: o
    });
  }
  applyForce(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyForce",
      props: t,
      uuid: n
    });
  }
  applyImpulse(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyImpulse",
      props: t,
      uuid: n
    });
  }
  applyLocalForce(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyLocalForce",
      props: t,
      uuid: n
    });
  }
  applyLocalImpulse(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyLocalImpulse",
      props: t,
      uuid: n
    });
  }
  applyRaycastVehicleEngineForce(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyRaycastVehicleEngineForce",
      props: t,
      uuid: n
    });
  }
  applyTorque(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyTorque",
      props: t,
      uuid: n
    });
  }
  connect() {
    this.worker = new Ute(), this.worker.onmessage = (e) => {
      if (e.data.op === "frame") {
        this.buffers.positions = e.data.positions, this.buffers.quaternions = e.data.quaternions, this.emit(e.data.op, e.data);
        return;
      }
      this.emit(e.data.type, e.data);
    };
    for (const e of this.messageQueue)
      this.worker.postMessage(e);
    this.messageQueue.length = 0;
  }
  disableConstraint(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "disableConstraint",
      uuid: t
    });
  }
  disableConstraintMotor(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "disableConstraintMotor",
      uuid: t
    });
  }
  disconnect() {
    this.worker && (this.worker.onmessage = null);
  }
  enableConstraint(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "enableConstraint",
      uuid: t
    });
  }
  enableConstraintMotor(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "enableConstraintMotor",
      uuid: t
    });
  }
  init() {
    const {
      allowSleep: e,
      axisIndex: t,
      broadphase: n,
      defaultContactMaterial: i,
      frictionGravity: o,
      gravity: l,
      iterations: u,
      quatNormalizeFast: I,
      quatNormalizeSkip: C,
      solver: f,
      tolerance: v
    } = this.config;
    this.postMessage({
      op: "init",
      props: {
        allowSleep: e,
        axisIndex: t,
        broadphase: n,
        defaultContactMaterial: i,
        frictionGravity: o,
        gravity: l,
        iterations: u,
        quatNormalizeFast: I,
        quatNormalizeSkip: C,
        solver: f,
        tolerance: v
      }
    });
  }
  removeBodies(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeBodies",
      uuid: t
    });
  }
  removeConstraint(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeConstraint",
      uuid: t
    });
  }
  removeContactMaterial(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeContactMaterial",
      uuid: t
    });
  }
  removeRay(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeRay",
      uuid: t
    });
  }
  removeRaycastVehicle(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeRaycastVehicle",
      uuid: t
    });
  }
  removeSpring(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeSpring",
      uuid: t
    });
  }
  setAllowSleep(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setAllowSleep",
      props: t,
      uuid: n
    });
  }
  setAngularDamping(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setAngularDamping",
      props: t,
      uuid: n
    });
  }
  setAngularFactor(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setAngularFactor",
      props: t,
      uuid: n
    });
  }
  setAngularVelocity(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setAngularVelocity",
      props: t,
      uuid: n
    });
  }
  setCollisionFilterGroup(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setCollisionFilterGroup",
      props: t,
      uuid: n
    });
  }
  setCollisionFilterMask(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setCollisionFilterMask",
      props: t,
      uuid: n
    });
  }
  setCollisionResponse(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setCollisionResponse",
      props: t,
      uuid: n
    });
  }
  setConstraintMotorMaxForce(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setConstraintMotorMaxForce",
      props: t,
      uuid: n
    });
  }
  setConstraintMotorSpeed(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setConstraintMotorSpeed",
      props: t,
      uuid: n
    });
  }
  setFixedRotation(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setFixedRotation",
      props: t,
      uuid: n
    });
  }
  setIsTrigger(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setIsTrigger",
      props: t,
      uuid: n
    });
  }
  setLinearDamping(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setLinearDamping",
      props: t,
      uuid: n
    });
  }
  setLinearFactor(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setLinearFactor",
      props: t,
      uuid: n
    });
  }
  setMass(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setMass",
      props: t,
      uuid: n
    });
  }
  setMaterial(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setMaterial",
      props: t,
      uuid: n
    });
  }
  setPosition(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setPosition",
      props: t,
      uuid: n
    });
  }
  setQuaternion(e) {
    let {
      props: [t, n, i, o],
      uuid: l
    } = e;
    this.postMessage({
      op: "setQuaternion",
      props: [t, n, i, o],
      uuid: l
    });
  }
  setRaycastVehicleBrake(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setRaycastVehicleBrake",
      props: t,
      uuid: n
    });
  }
  setRaycastVehicleSteeringValue(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setRaycastVehicleSteeringValue",
      props: t,
      uuid: n
    });
  }
  setRotation(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setRotation",
      props: t,
      uuid: n
    });
  }
  setSleepSpeedLimit(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSleepSpeedLimit",
      props: t,
      uuid: n
    });
  }
  setSleepTimeLimit(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSleepTimeLimit",
      props: t,
      uuid: n
    });
  }
  setSpringDamping(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSpringDamping",
      props: t,
      uuid: n
    });
  }
  setSpringRestLength(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSpringRestLength",
      props: t,
      uuid: n
    });
  }
  setSpringStiffness(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSpringStiffness",
      props: t,
      uuid: n
    });
  }
  setUserData(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setUserData",
      props: t,
      uuid: n
    });
  }
  setVelocity(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setVelocity",
      props: t,
      uuid: n
    });
  }
  sleep(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "sleep",
      uuid: t
    });
  }
  step(e) {
    var t;
    const {
      buffers: {
        positions: n,
        quaternions: i
      }
    } = this;
    !n.byteLength && !i.byteLength || (t = this.worker) == null || t.postMessage({
      op: "step",
      positions: n,
      props: e,
      quaternions: i
    }, [n.buffer, i.buffer]);
  }
  subscribe(e) {
    let {
      props: {
        id: t,
        target: n,
        type: i
      },
      uuid: o
    } = e;
    this.postMessage({
      op: "subscribe",
      props: {
        id: t,
        target: n,
        type: i
      },
      uuid: o
    });
  }
  terminate() {
    var e;
    (e = this.worker) == null || e.terminate(), this.worker = null;
  }
  unsubscribe(e) {
    let {
      props: t
    } = e;
    this.postMessage({
      op: "unsubscribe",
      props: t
    });
  }
  wakeUp(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "wakeUp",
      uuid: t
    });
  }
  postMessage(e) {
    if (this.worker) return this.worker.postMessage(e);
    this.messageQueue.push(e);
  }
}
class Lm {
  /**
   * A vector of length 9, containing all matrix elements.
   */
  /**
   * @param elements A vector of length 9, containing all matrix elements.
   */
  constructor(e) {
    e === void 0 && (e = [0, 0, 0, 0, 0, 0, 0, 0, 0]), this.elements = e;
  }
  /**
   * Sets the matrix to identity
   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
   * @todo Create another function that immediately creates an identity matrix eg. `eye()`
   */
  identity() {
    const e = this.elements;
    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1;
  }
  /**
   * Set all elements to zero
   */
  setZero() {
    const e = this.elements;
    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 0;
  }
  /**
   * Sets the matrix diagonal elements from a Vec3
   */
  setTrace(e) {
    const t = this.elements;
    t[0] = e.x, t[4] = e.y, t[8] = e.z;
  }
  /**
   * Gets the matrix diagonal elements
   */
  getTrace(e) {
    e === void 0 && (e = new be());
    const t = this.elements;
    return e.x = t[0], e.y = t[4], e.z = t[8], e;
  }
  /**
   * Matrix-Vector multiplication
   * @param v The vector to multiply with
   * @param target Optional, target to save the result in.
   */
  vmult(e, t) {
    t === void 0 && (t = new be());
    const n = this.elements, i = e.x, o = e.y, l = e.z;
    return t.x = n[0] * i + n[1] * o + n[2] * l, t.y = n[3] * i + n[4] * o + n[5] * l, t.z = n[6] * i + n[7] * o + n[8] * l, t;
  }
  /**
   * Matrix-scalar multiplication
   */
  smult(e) {
    for (let t = 0; t < this.elements.length; t++)
      this.elements[t] *= e;
  }
  /**
   * Matrix multiplication
   * @param matrix Matrix to multiply with from left side.
   */
  mmult(e, t) {
    t === void 0 && (t = new Lm());
    const n = this.elements, i = e.elements, o = t.elements, l = n[0], u = n[1], I = n[2], C = n[3], f = n[4], v = n[5], b = n[6], S = n[7], R = n[8], W = i[0], x = i[1], N = i[2], Y = i[3], F = i[4], T = i[5], P = i[6], D = i[7], L = i[8];
    return o[0] = l * W + u * Y + I * P, o[1] = l * x + u * F + I * D, o[2] = l * N + u * T + I * L, o[3] = C * W + f * Y + v * P, o[4] = C * x + f * F + v * D, o[5] = C * N + f * T + v * L, o[6] = b * W + S * Y + R * P, o[7] = b * x + S * F + R * D, o[8] = b * N + S * T + R * L, t;
  }
  /**
   * Scale each column of the matrix
   */
  scale(e, t) {
    t === void 0 && (t = new Lm());
    const n = this.elements, i = t.elements;
    for (let o = 0; o !== 3; o++)
      i[3 * o + 0] = e.x * n[3 * o + 0], i[3 * o + 1] = e.y * n[3 * o + 1], i[3 * o + 2] = e.z * n[3 * o + 2];
    return t;
  }
  /**
   * Solve Ax=b
   * @param b The right hand side
   * @param target Optional. Target vector to save in.
   * @return The solution x
   * @todo should reuse arrays
   */
  solve(e, t) {
    t === void 0 && (t = new be());
    const n = 3, i = 4, o = [];
    let l, u;
    for (l = 0; l < n * i; l++)
      o.push(0);
    for (l = 0; l < 3; l++)
      for (u = 0; u < 3; u++)
        o[l + i * u] = this.elements[l + 3 * u];
    o[3 + 4 * 0] = e.x, o[3 + 4 * 1] = e.y, o[3 + 4 * 2] = e.z;
    let I = 3;
    const C = I;
    let f;
    const v = 4;
    let b;
    do {
      if (l = C - I, o[l + i * l] === 0) {
        for (u = l + 1; u < C; u++)
          if (o[l + i * u] !== 0) {
            f = v;
            do
              b = v - f, o[b + i * l] += o[b + i * u];
            while (--f);
            break;
          }
      }
      if (o[l + i * l] !== 0)
        for (u = l + 1; u < C; u++) {
          const S = o[l + i * u] / o[l + i * l];
          f = v;
          do
            b = v - f, o[b + i * u] = b <= l ? 0 : o[b + i * u] - o[b + i * l] * S;
          while (--f);
        }
    } while (--I);
    if (t.z = o[2 * i + 3] / o[2 * i + 2], t.y = (o[1 * i + 3] - o[1 * i + 2] * t.z) / o[1 * i + 1], t.x = (o[0 * i + 3] - o[0 * i + 2] * t.z - o[0 * i + 1] * t.y) / o[0 * i + 0], isNaN(t.x) || isNaN(t.y) || isNaN(t.z) || t.x === 1 / 0 || t.y === 1 / 0 || t.z === 1 / 0)
      throw `Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;
    return t;
  }
  /**
   * Get an element in the matrix by index. Index starts at 0, not 1!!!
   * @param value If provided, the matrix element will be set to this value.
   */
  e(e, t, n) {
    if (n === void 0)
      return this.elements[t + 3 * e];
    this.elements[t + 3 * e] = n;
  }
  /**
   * Copy another matrix into this matrix object.
   */
  copy(e) {
    for (let t = 0; t < e.elements.length; t++)
      this.elements[t] = e.elements[t];
    return this;
  }
  /**
   * Returns a string representation of the matrix.
   */
  toString() {
    let e = "";
    const t = ",";
    for (let n = 0; n < 9; n++)
      e += this.elements[n] + t;
    return e;
  }
  /**
   * reverse the matrix
   * @param target Target matrix to save in.
   * @return The solution x
   */
  reverse(e) {
    e === void 0 && (e = new Lm());
    const t = 3, n = 6, i = Pte;
    let o, l;
    for (o = 0; o < 3; o++)
      for (l = 0; l < 3; l++)
        i[o + n * l] = this.elements[o + 3 * l];
    i[3 + 6 * 0] = 1, i[3 + 6 * 1] = 0, i[3 + 6 * 2] = 0, i[4 + 6 * 0] = 0, i[4 + 6 * 1] = 1, i[4 + 6 * 2] = 0, i[5 + 6 * 0] = 0, i[5 + 6 * 1] = 0, i[5 + 6 * 2] = 1;
    let u = 3;
    const I = u;
    let C;
    const f = n;
    let v;
    do {
      if (o = I - u, i[o + n * o] === 0) {
        for (l = o + 1; l < I; l++)
          if (i[o + n * l] !== 0) {
            C = f;
            do
              v = f - C, i[v + n * o] += i[v + n * l];
            while (--C);
            break;
          }
      }
      if (i[o + n * o] !== 0)
        for (l = o + 1; l < I; l++) {
          const b = i[o + n * l] / i[o + n * o];
          C = f;
          do
            v = f - C, i[v + n * l] = v <= o ? 0 : i[v + n * l] - i[v + n * o] * b;
          while (--C);
        }
    } while (--u);
    o = 2;
    do {
      l = o - 1;
      do {
        const b = i[o + n * l] / i[o + n * o];
        C = n;
        do
          v = n - C, i[v + n * l] = i[v + n * l] - i[v + n * o] * b;
        while (--C);
      } while (l--);
    } while (--o);
    o = 2;
    do {
      const b = 1 / i[o + n * o];
      C = n;
      do
        v = n - C, i[v + n * o] = i[v + n * o] * b;
      while (--C);
    } while (o--);
    o = 2;
    do {
      l = 2;
      do {
        if (v = i[t + l + n * o], isNaN(v) || v === 1 / 0)
          throw `Could not reverse! A=[${this.toString()}]`;
        e.e(o, l, v);
      } while (l--);
    } while (o--);
    return e;
  }
  /**
   * Set the matrix from a quaterion
   */
  setRotationFromQuaternion(e) {
    const t = e.x, n = e.y, i = e.z, o = e.w, l = t + t, u = n + n, I = i + i, C = t * l, f = t * u, v = t * I, b = n * u, S = n * I, R = i * I, W = o * l, x = o * u, N = o * I, Y = this.elements;
    return Y[3 * 0 + 0] = 1 - (b + R), Y[3 * 0 + 1] = f - N, Y[3 * 0 + 2] = v + x, Y[3 * 1 + 0] = f + N, Y[3 * 1 + 1] = 1 - (C + R), Y[3 * 1 + 2] = S - W, Y[3 * 2 + 0] = v - x, Y[3 * 2 + 1] = S + W, Y[3 * 2 + 2] = 1 - (C + b), this;
  }
  /**
   * Transpose the matrix
   * @param target Optional. Where to store the result.
   * @return The target Mat3, or a new Mat3 if target was omitted.
   */
  transpose(e) {
    e === void 0 && (e = new Lm());
    const t = this.elements, n = e.elements;
    let i;
    return n[0] = t[0], n[4] = t[4], n[8] = t[8], i = t[1], n[1] = t[3], n[3] = i, i = t[2], n[2] = t[6], n[6] = i, i = t[5], n[5] = t[7], n[7] = i, e;
  }
}
const Pte = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
class be {
  constructor(e, t, n) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), this.x = e, this.y = t, this.z = n;
  }
  /**
   * Vector cross product
   * @param target Optional target to save in.
   */
  cross(e, t) {
    t === void 0 && (t = new be());
    const n = e.x, i = e.y, o = e.z, l = this.x, u = this.y, I = this.z;
    return t.x = u * o - I * i, t.y = I * n - l * o, t.z = l * i - u * n, t;
  }
  /**
   * Set the vectors' 3 elements
   */
  set(e, t, n) {
    return this.x = e, this.y = t, this.z = n, this;
  }
  /**
   * Set all components of the vector to zero.
   */
  setZero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Vector addition
   */
  vadd(e, t) {
    if (t)
      t.x = e.x + this.x, t.y = e.y + this.y, t.z = e.z + this.z;
    else
      return new be(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  /**
   * Vector subtraction
   * @param target Optional target to save in.
   */
  vsub(e, t) {
    if (t)
      t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z;
    else
      return new be(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  /**
   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
   *
   * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Ume University Lecture}
   */
  crossmat() {
    return new Lm([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  /**
   * Normalize the vector. Note that this changes the values in the vector.
    * @return Returns the norm of the vector
   */
  normalize() {
    const e = this.x, t = this.y, n = this.z, i = Math.sqrt(e * e + t * t + n * n);
    if (i > 0) {
      const o = 1 / i;
      this.x *= o, this.y *= o, this.z *= o;
    } else
      this.x = 0, this.y = 0, this.z = 0;
    return i;
  }
  /**
   * Get the version of this vector that is of length 1.
   * @param target Optional target to save in
   * @return Returns the unit vector
   */
  unit(e) {
    e === void 0 && (e = new be());
    const t = this.x, n = this.y, i = this.z;
    let o = Math.sqrt(t * t + n * n + i * i);
    return o > 0 ? (o = 1 / o, e.x = t * o, e.y = n * o, e.z = i * o) : (e.x = 1, e.y = 0, e.z = 0), e;
  }
  /**
   * Get the length of the vector
   */
  length() {
    const e = this.x, t = this.y, n = this.z;
    return Math.sqrt(e * e + t * t + n * n);
  }
  /**
   * Get the squared length of the vector.
   */
  lengthSquared() {
    return this.dot(this);
  }
  /**
   * Get distance from this point to another point
   */
  distanceTo(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z;
    return Math.sqrt((o - t) * (o - t) + (l - n) * (l - n) + (u - i) * (u - i));
  }
  /**
   * Get squared distance from this point to another point
   */
  distanceSquared(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z;
    return (o - t) * (o - t) + (l - n) * (l - n) + (u - i) * (u - i);
  }
  /**
   * Multiply all the components of the vector with a scalar.
   * @param target The vector to save the result in.
   */
  scale(e, t) {
    t === void 0 && (t = new be());
    const n = this.x, i = this.y, o = this.z;
    return t.x = e * n, t.y = e * i, t.z = e * o, t;
  }
  /**
   * Multiply the vector with an other vector, component-wise.
   * @param target The vector to save the result in.
   */
  vmul(e, t) {
    return t === void 0 && (t = new be()), t.x = e.x * this.x, t.y = e.y * this.y, t.z = e.z * this.z, t;
  }
  /**
   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
   * @param target The vector to save the result in.
   */
  addScaledVector(e, t, n) {
    return n === void 0 && (n = new be()), n.x = this.x + e * t.x, n.y = this.y + e * t.y, n.z = this.z + e * t.z, n;
  }
  /**
   * Calculate dot product
   * @param vector
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  /**
   * Make the vector point in the opposite direction.
   * @param target Optional target to save in
   */
  negate(e) {
    return e === void 0 && (e = new be()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e;
  }
  /**
   * Compute two artificial tangents to the vector
   * @param t1 Vector object to save the first tangent in
   * @param t2 Vector object to save the second tangent in
   */
  tangents(e, t) {
    const n = this.length();
    if (n > 0) {
      const i = Jte, o = 1 / n;
      i.set(this.x * o, this.y * o, this.z * o);
      const l = Qte;
      Math.abs(i.x) < 0.9 ? (l.set(1, 0, 0), i.cross(l, e)) : (l.set(0, 1, 0), i.cross(l, e)), i.cross(e, t);
    } else
      e.set(1, 0, 0), t.set(0, 1, 0);
  }
  /**
   * Converts to a more readable format
   */
  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  /**
   * Converts to an array
   */
  toArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * Copies value of source to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Do a linear interpolation between two vectors
   * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
   */
  lerp(e, t, n) {
    const i = this.x, o = this.y, l = this.z;
    n.x = i + (e.x - i) * t, n.y = o + (e.y - o) * t, n.z = l + (e.z - l) * t;
  }
  /**
   * Check if a vector equals is almost equal to another one.
   */
  almostEquals(e, t) {
    return t === void 0 && (t = 1e-6), !(Math.abs(this.x - e.x) > t || Math.abs(this.y - e.y) > t || Math.abs(this.z - e.z) > t);
  }
  /**
   * Check if a vector is almost zero
   */
  almostZero(e) {
    return e === void 0 && (e = 1e-6), !(Math.abs(this.x) > e || Math.abs(this.y) > e || Math.abs(this.z) > e);
  }
  /**
   * Check if the vector is anti-parallel to another vector.
   * @param precision Set to zero for exact comparisons
   */
  isAntiparallelTo(e, t) {
    return this.negate(U5), U5.almostEquals(e, t);
  }
  /**
   * Clone the vector
   */
  clone() {
    return new be(this.x, this.y, this.z);
  }
}
be.ZERO = new be(0, 0, 0);
be.UNIT_X = new be(1, 0, 0);
be.UNIT_Y = new be(0, 1, 0);
be.UNIT_Z = new be(0, 0, 1);
const Jte = new be(), Qte = new be(), U5 = new be();
class $C {
  /**
   * The lower bound of the bounding box
   */
  /**
   * The upper bound of the bounding box
   */
  constructor(e) {
    e === void 0 && (e = {}), this.lowerBound = new be(), this.upperBound = new be(), e.lowerBound && this.lowerBound.copy(e.lowerBound), e.upperBound && this.upperBound.copy(e.upperBound);
  }
  /**
   * Set the AABB bounds from a set of points.
   * @param points An array of Vec3's.
   * @return The self object
   */
  setFromPoints(e, t, n, i) {
    const o = this.lowerBound, l = this.upperBound, u = n;
    o.copy(e[0]), u && u.vmult(o, o), l.copy(o);
    for (let I = 1; I < e.length; I++) {
      let C = e[I];
      u && (u.vmult(C, O5), C = O5), C.x > l.x && (l.x = C.x), C.x < o.x && (o.x = C.x), C.y > l.y && (l.y = C.y), C.y < o.y && (o.y = C.y), C.z > l.z && (l.z = C.z), C.z < o.z && (o.z = C.z);
    }
    return t && (t.vadd(o, o), t.vadd(l, l)), i && (o.x -= i, o.y -= i, o.z -= i, l.x += i, l.y += i, l.z += i), this;
  }
  /**
   * Copy bounds from an AABB to this AABB
   * @param aabb Source to copy from
   * @return The this object, for chainability
   */
  copy(e) {
    return this.lowerBound.copy(e.lowerBound), this.upperBound.copy(e.upperBound), this;
  }
  /**
   * Clone an AABB
   */
  clone() {
    return new $C().copy(this);
  }
  /**
   * Extend this AABB so that it covers the given AABB too.
   */
  extend(e) {
    this.lowerBound.x = Math.min(this.lowerBound.x, e.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, e.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, e.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, e.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, e.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, e.upperBound.z);
  }
  /**
   * Returns true if the given AABB overlaps this AABB.
   */
  overlaps(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, o = e.upperBound, l = i.x <= n.x && n.x <= o.x || t.x <= o.x && o.x <= n.x, u = i.y <= n.y && n.y <= o.y || t.y <= o.y && o.y <= n.y, I = i.z <= n.z && n.z <= o.z || t.z <= o.z && o.z <= n.z;
    return l && u && I;
  }
  // Mostly for debugging
  volume() {
    const e = this.lowerBound, t = this.upperBound;
    return (t.x - e.x) * (t.y - e.y) * (t.z - e.z);
  }
  /**
   * Returns true if the given AABB is fully contained in this AABB.
   */
  contains(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, o = e.upperBound;
    return t.x <= i.x && n.x >= o.x && t.y <= i.y && n.y >= o.y && t.z <= i.z && n.z >= o.z;
  }
  getCorners(e, t, n, i, o, l, u, I) {
    const C = this.lowerBound, f = this.upperBound;
    e.copy(C), t.set(f.x, C.y, C.z), n.set(f.x, f.y, C.z), i.set(C.x, f.y, f.z), o.set(f.x, C.y, f.z), l.set(C.x, f.y, C.z), u.set(C.x, C.y, f.z), I.copy(f);
  }
  /**
   * Get the representation of an AABB in another frame.
   * @return The "target" AABB object.
   */
  toLocalFrame(e, t) {
    const n = P5, i = n[0], o = n[1], l = n[2], u = n[3], I = n[4], C = n[5], f = n[6], v = n[7];
    this.getCorners(i, o, l, u, I, C, f, v);
    for (let b = 0; b !== 8; b++) {
      const S = n[b];
      e.pointToLocal(S, S);
    }
    return t.setFromPoints(n);
  }
  /**
   * Get the representation of an AABB in the global frame.
   * @return The "target" AABB object.
   */
  toWorldFrame(e, t) {
    const n = P5, i = n[0], o = n[1], l = n[2], u = n[3], I = n[4], C = n[5], f = n[6], v = n[7];
    this.getCorners(i, o, l, u, I, C, f, v);
    for (let b = 0; b !== 8; b++) {
      const S = n[b];
      e.pointToWorld(S, S);
    }
    return t.setFromPoints(n);
  }
  /**
   * Check if the AABB is hit by a ray.
   */
  overlapsRay(e) {
    const {
      direction: t,
      from: n
    } = e, i = 1 / t.x, o = 1 / t.y, l = 1 / t.z, u = (this.lowerBound.x - n.x) * i, I = (this.upperBound.x - n.x) * i, C = (this.lowerBound.y - n.y) * o, f = (this.upperBound.y - n.y) * o, v = (this.lowerBound.z - n.z) * l, b = (this.upperBound.z - n.z) * l, S = Math.max(Math.max(Math.min(u, I), Math.min(C, f)), Math.min(v, b)), R = Math.min(Math.min(Math.max(u, I), Math.max(C, f)), Math.max(v, b));
    return !(R < 0 || S > R);
  }
}
const O5 = new be(), P5 = [new be(), new be(), new be(), new be(), new be(), new be(), new be(), new be()];
class Qg {
  constructor(e, t, n, i) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), i === void 0 && (i = 1), this.x = e, this.y = t, this.z = n, this.w = i;
  }
  /**
   * Set the value of the quaternion.
   */
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  /**
   * Convert to a readable format
   * @return "x,y,z,w"
   */
  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  /**
   * Convert to an Array
   * @return [x, y, z, w]
   */
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * Set the quaternion components given an axis and an angle in radians.
   */
  setFromAxisAngle(e, t) {
    const n = Math.sin(t * 0.5);
    return this.x = e.x * n, this.y = e.y * n, this.z = e.z * n, this.w = Math.cos(t * 0.5), this;
  }
  /**
   * Converts the quaternion to [ axis, angle ] representation.
   * @param targetAxis A vector object to reuse for storing the axis.
   * @return An array, first element is the axis and the second is the angle in radians.
   */
  toAxisAngle(e) {
    e === void 0 && (e = new be()), this.normalize();
    const t = 2 * Math.acos(this.w), n = Math.sqrt(1 - this.w * this.w);
    return n < 1e-3 ? (e.x = this.x, e.y = this.y, e.z = this.z) : (e.x = this.x / n, e.y = this.y / n, e.z = this.z / n), [e, t];
  }
  /**
   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
   */
  setFromVectors(e, t) {
    if (e.isAntiparallelTo(t)) {
      const n = jte, i = qte;
      e.tangents(n, i), this.setFromAxisAngle(n, Math.PI);
    } else {
      const n = e.cross(t);
      this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(e.length() ** 2 * t.length() ** 2) + e.dot(t), this.normalize();
    }
    return this;
  }
  /**
   * Multiply the quaternion with an other quaternion.
   */
  mult(e, t) {
    t === void 0 && (t = new Qg());
    const n = this.x, i = this.y, o = this.z, l = this.w, u = e.x, I = e.y, C = e.z, f = e.w;
    return t.x = n * f + l * u + i * C - o * I, t.y = i * f + l * I + o * u - n * C, t.z = o * f + l * C + n * I - i * u, t.w = l * f - n * u - i * I - o * C, t;
  }
  /**
   * Get the inverse quaternion rotation.
   */
  inverse(e) {
    e === void 0 && (e = new Qg());
    const t = this.x, n = this.y, i = this.z, o = this.w;
    this.conjugate(e);
    const l = 1 / (t * t + n * n + i * i + o * o);
    return e.x *= l, e.y *= l, e.z *= l, e.w *= l, e;
  }
  /**
   * Get the quaternion conjugate
   */
  conjugate(e) {
    return e === void 0 && (e = new Qg()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e.w = this.w, e;
  }
  /**
   * Normalize the quaternion. Note that this changes the values of the quaternion.
   */
  normalize() {
    let e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  /**
   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
   * @author unphased, https://github.com/unphased
   */
  normalizeFast() {
    const e = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  /**
   * Multiply the quaternion by a vector
   */
  vmult(e, t) {
    t === void 0 && (t = new be());
    const n = e.x, i = e.y, o = e.z, l = this.x, u = this.y, I = this.z, C = this.w, f = C * n + u * o - I * i, v = C * i + I * n - l * o, b = C * o + l * i - u * n, S = -l * n - u * i - I * o;
    return t.x = f * C + S * -l + v * -I - b * -u, t.y = v * C + S * -u + b * -l - f * -I, t.z = b * C + S * -I + f * -u - v * -l, t;
  }
  /**
   * Copies value of source to this quaternion.
   * @return this
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  /**
   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
   * @param order Three-character string, defaults to "YZX"
   */
  toEuler(e, t) {
    t === void 0 && (t = "YZX");
    let n, i, o;
    const l = this.x, u = this.y, I = this.z, C = this.w;
    switch (t) {
      case "YZX":
        const f = l * u + I * C;
        if (f > 0.499 && (n = 2 * Math.atan2(l, C), i = Math.PI / 2, o = 0), f < -0.499 && (n = -2 * Math.atan2(l, C), i = -Math.PI / 2, o = 0), n === void 0) {
          const v = l * l, b = u * u, S = I * I;
          n = Math.atan2(2 * u * C - 2 * l * I, 1 - 2 * b - 2 * S), i = Math.asin(2 * f), o = Math.atan2(2 * l * C - 2 * u * I, 1 - 2 * v - 2 * S);
        }
        break;
      default:
        throw new Error(`Euler order ${t} not supported yet.`);
    }
    e.y = n, e.z = i, e.x = o;
  }
  /**
   * Set the quaternion components given Euler angle representation.
   *
   * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
   *
   * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
   */
  setFromEuler(e, t, n, i) {
    i === void 0 && (i = "XYZ");
    const o = Math.cos(e / 2), l = Math.cos(t / 2), u = Math.cos(n / 2), I = Math.sin(e / 2), C = Math.sin(t / 2), f = Math.sin(n / 2);
    return i === "XYZ" ? (this.x = I * l * u + o * C * f, this.y = o * C * u - I * l * f, this.z = o * l * f + I * C * u, this.w = o * l * u - I * C * f) : i === "YXZ" ? (this.x = I * l * u + o * C * f, this.y = o * C * u - I * l * f, this.z = o * l * f - I * C * u, this.w = o * l * u + I * C * f) : i === "ZXY" ? (this.x = I * l * u - o * C * f, this.y = o * C * u + I * l * f, this.z = o * l * f + I * C * u, this.w = o * l * u - I * C * f) : i === "ZYX" ? (this.x = I * l * u - o * C * f, this.y = o * C * u + I * l * f, this.z = o * l * f - I * C * u, this.w = o * l * u + I * C * f) : i === "YZX" ? (this.x = I * l * u + o * C * f, this.y = o * C * u + I * l * f, this.z = o * l * f - I * C * u, this.w = o * l * u - I * C * f) : i === "XZY" && (this.x = I * l * u - o * C * f, this.y = o * C * u - I * l * f, this.z = o * l * f + I * C * u, this.w = o * l * u + I * C * f), this;
  }
  clone() {
    return new Qg(this.x, this.y, this.z, this.w);
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param toQuat second operand
   * @param t interpolation amount between the self quaternion and toQuat
   * @param target A quaternion to store the result in. If not provided, a new one will be created.
   * @returns {Quaternion} The "target" object
   */
  slerp(e, t, n) {
    n === void 0 && (n = new Qg());
    const i = this.x, o = this.y, l = this.z, u = this.w;
    let I = e.x, C = e.y, f = e.z, v = e.w, b, S, R, W, x;
    return S = i * I + o * C + l * f + u * v, S < 0 && (S = -S, I = -I, C = -C, f = -f, v = -v), 1 - S > 1e-6 ? (b = Math.acos(S), R = Math.sin(b), W = Math.sin((1 - t) * b) / R, x = Math.sin(t * b) / R) : (W = 1 - t, x = t), n.x = W * i + x * I, n.y = W * o + x * C, n.z = W * l + x * f, n.w = W * u + x * v, n;
  }
  /**
   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
   */
  integrate(e, t, n, i) {
    i === void 0 && (i = new Qg());
    const o = e.x * n.x, l = e.y * n.y, u = e.z * n.z, I = this.x, C = this.y, f = this.z, v = this.w, b = t * 0.5;
    return i.x += b * (o * v + l * f - u * C), i.y += b * (l * v + u * I - o * f), i.z += b * (u * v + o * C - l * I), i.w += b * (-o * I - l * C - u * f), i;
  }
}
const jte = new be(), qte = new be(), $te = {
  /** SPHERE */
  SPHERE: 1,
  /** PLANE */
  PLANE: 2,
  /** BOX */
  BOX: 4,
  /** COMPOUND */
  COMPOUND: 8,
  /** CONVEXPOLYHEDRON */
  CONVEXPOLYHEDRON: 16,
  /** HEIGHTFIELD */
  HEIGHTFIELD: 32,
  /** PARTICLE */
  PARTICLE: 64,
  /** CYLINDER */
  CYLINDER: 128,
  /** TRIMESH */
  TRIMESH: 256
};
class bi {
  /**
   * Identifier of the Shape.
   */
  /**
   * The type of this shape. Must be set to an int > 0 by subclasses.
   */
  /**
   * The local bounding sphere radius of this shape.
   */
  /**
   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
   * @default true
   */
  /**
   * @default 1
   */
  /**
   * @default -1
   */
  /**
   * Optional material of the shape that regulates contact properties.
   */
  /**
   * The body to which the shape is added to.
   */
  /**
   * All the Shape types.
   */
  constructor(e) {
    e === void 0 && (e = {}), this.id = bi.idCounter++, this.type = e.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = e.collisionResponse ? e.collisionResponse : !0, this.collisionFilterGroup = e.collisionFilterGroup !== void 0 ? e.collisionFilterGroup : 1, this.collisionFilterMask = e.collisionFilterMask !== void 0 ? e.collisionFilterMask : -1, this.material = e.material ? e.material : null, this.body = null;
  }
  /**
   * Computes the bounding sphere radius.
   * The result is stored in the property `.boundingSphereRadius`
   */
  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  /**
   * Get the volume of this shape
   */
  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  /**
   * Calculates the inertia in the local frame for this shape.
   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  calculateLocalInertia(e, t) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  /**
   * @todo use abstract for these kind of methods
   */
  calculateWorldAABB(e, t, n, i) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }
}
bi.idCounter = 0;
bi.types = $te;
class nI {
  /**
   * position
   */
  /**
   * quaternion
   */
  constructor(e) {
    e === void 0 && (e = {}), this.position = new be(), this.quaternion = new Qg(), e.position && this.position.copy(e.position), e.quaternion && this.quaternion.copy(e.quaternion);
  }
  /**
   * Get a global point in local transform coordinates.
   */
  pointToLocal(e, t) {
    return nI.pointToLocalFrame(this.position, this.quaternion, e, t);
  }
  /**
   * Get a local point in global transform coordinates.
   */
  pointToWorld(e, t) {
    return nI.pointToWorldFrame(this.position, this.quaternion, e, t);
  }
  /**
   * vectorToWorldFrame
   */
  vectorToWorldFrame(e, t) {
    return t === void 0 && (t = new be()), this.quaternion.vmult(e, t), t;
  }
  /**
   * pointToLocalFrame
   */
  static pointToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new be()), n.vsub(e, i), t.conjugate(J5), J5.vmult(i, i), i;
  }
  /**
   * pointToWorldFrame
   */
  static pointToWorldFrame(e, t, n, i) {
    return i === void 0 && (i = new be()), t.vmult(n, i), i.vadd(e, i), i;
  }
  /**
   * vectorToWorldFrame
   */
  static vectorToWorldFrame(e, t, n) {
    return n === void 0 && (n = new be()), e.vmult(t, n), n;
  }
  /**
   * vectorToLocalFrame
   */
  static vectorToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new be()), t.w *= -1, t.vmult(n, i), t.w *= -1, i;
  }
}
const J5 = new Qg();
new be();
new be();
new be();
new be();
new be(), new be(), new be(), new be(), new be(), new be(), new be(), new be();
new be();
new Qg();
new $C();
new Lm();
new Lm();
new Lm();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new Qg();
new be();
new be();
new be();
new be();
class sX {
  /**
   * rayFromWorld
   */
  /**
   * rayToWorld
   */
  /**
   * hitNormalWorld
   */
  /**
   * hitPointWorld
   */
  /**
   * hasHit
   */
  /**
   * shape
   */
  /**
   * body
   */
  /**
   * The index of the hit triangle, if the hit shape was a trimesh
   */
  /**
   * Distance to the hit. Will be set to -1 if there was no hit
   */
  /**
   * If the ray should stop traversing the bodies
   */
  constructor() {
    this.rayFromWorld = new be(), this.rayToWorld = new be(), this.hitNormalWorld = new be(), this.hitPointWorld = new be(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  /**
   * Reset all result data.
   */
  reset() {
    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  /**
   * abort
   */
  abort() {
    this.shouldStop = !0;
  }
  /**
   * Set result data.
   */
  set(e, t, n, i, o, l, u) {
    this.rayFromWorld.copy(e), this.rayToWorld.copy(t), this.hitNormalWorld.copy(n), this.hitPointWorld.copy(i), this.shape = o, this.body = l, this.distance = u;
  }
}
let p9, m9, A9, v9, y9, b9, G9;
const DY = {
  /** CLOSEST */
  CLOSEST: 1,
  /** ANY */
  ANY: 2,
  /** ALL */
  ALL: 4
};
p9 = bi.types.SPHERE;
m9 = bi.types.PLANE;
A9 = bi.types.BOX;
v9 = bi.types.CYLINDER;
y9 = bi.types.CONVEXPOLYHEDRON;
b9 = bi.types.HEIGHTFIELD;
G9 = bi.types.TRIMESH;
class rg {
  /**
   * from
   */
  /**
   * to
   */
  /**
   * direction
   */
  /**
   * The precision of the ray. Used when checking parallelity etc.
   * @default 0.0001
   */
  /**
   * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
   * @default true
   */
  /**
   * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
   * @default false
   */
  /**
   * collisionFilterMask
   * @default -1
   */
  /**
   * collisionFilterGroup
   * @default -1
   */
  /**
   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
   * @default RAY.ANY
   */
  /**
   * Current result object.
   */
  /**
   * Will be set to `true` during intersectWorld() if the ray hit anything.
   */
  /**
   * User-provided result callback. Will be used if mode is Ray.ALL.
   */
  /**
   * CLOSEST
   */
  /**
   * ANY
   */
  /**
   * ALL
   */
  get [p9]() {
    return this._intersectSphere;
  }
  get [m9]() {
    return this._intersectPlane;
  }
  get [A9]() {
    return this._intersectBox;
  }
  get [v9]() {
    return this._intersectConvex;
  }
  get [y9]() {
    return this._intersectConvex;
  }
  get [b9]() {
    return this._intersectHeightfield;
  }
  get [G9]() {
    return this._intersectTrimesh;
  }
  constructor(e, t) {
    e === void 0 && (e = new be()), t === void 0 && (t = new be()), this.from = e.clone(), this.to = t.clone(), this.direction = new be(), this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = rg.ANY, this.result = new sX(), this.hasHit = !1, this.callback = (n) => {
    };
  }
  /**
   * Do itersection against all bodies in the given World.
   * @return True if the ray hit anything, otherwise false.
   */
  intersectWorld(e, t) {
    return this.mode = t.mode || rg.ANY, this.result = t.result || new sX(), this.skipBackfaces = !!t.skipBackfaces, this.collisionFilterMask = typeof t.collisionFilterMask < "u" ? t.collisionFilterMask : -1, this.collisionFilterGroup = typeof t.collisionFilterGroup < "u" ? t.collisionFilterGroup : -1, this.checkCollisionResponse = typeof t.checkCollisionResponse < "u" ? t.checkCollisionResponse : !0, t.from && this.from.copy(t.from), t.to && this.to.copy(t.to), this.callback = t.callback || (() => {
    }), this.hasHit = !1, this.result.reset(), this.updateDirection(), this.getAABB(Q5), mH.length = 0, e.broadphase.aabbQuery(e, Q5, mH), this.intersectBodies(mH), this.hasHit;
  }
  /**
   * Shoot a ray at a body, get back information about the hit.
   * @deprecated @param result set the result property of the Ray instead.
   */
  intersectBody(e, t) {
    t && (this.result = t, this.updateDirection());
    const n = this.checkCollisionResponse;
    if (n && !e.collisionResponse || (this.collisionFilterGroup & e.collisionFilterMask) === 0 || (e.collisionFilterGroup & this.collisionFilterMask) === 0)
      return;
    const i = ene, o = tne;
    for (let l = 0, u = e.shapes.length; l < u; l++) {
      const I = e.shapes[l];
      if (!(n && !I.collisionResponse) && (e.quaternion.mult(e.shapeOrientations[l], o), e.quaternion.vmult(e.shapeOffsets[l], i), i.vadd(e.position, i), this.intersectShape(I, o, i, e), this.result.shouldStop))
        break;
    }
  }
  /**
   * Shoot a ray at an array bodies, get back information about the hit.
   * @param bodies An array of Body objects.
   * @deprecated @param result set the result property of the Ray instead.
   *
   */
  intersectBodies(e, t) {
    t && (this.result = t, this.updateDirection());
    for (let n = 0, i = e.length; !this.result.shouldStop && n < i; n++)
      this.intersectBody(e[n]);
  }
  /**
   * Updates the direction vector.
   */
  updateDirection() {
    this.to.vsub(this.from, this.direction), this.direction.normalize();
  }
  intersectShape(e, t, n, i) {
    const o = this.from;
    if (hne(o, this.direction, n) > e.boundingSphereRadius)
      return;
    const u = this[e.type];
    u && u.call(this, e, t, n, i, e);
  }
  _intersectBox(e, t, n, i, o) {
    return this._intersectConvex(e.convexPolyhedronRepresentation, t, n, i, o);
  }
  _intersectPlane(e, t, n, i, o) {
    const l = this.from, u = this.to, I = this.direction, C = new be(0, 0, 1);
    t.vmult(C, C);
    const f = new be();
    l.vsub(n, f);
    const v = f.dot(C);
    u.vsub(n, f);
    const b = f.dot(C);
    if (v * b > 0 || l.distanceTo(u) < v)
      return;
    const S = C.dot(I);
    if (Math.abs(S) < this.precision)
      return;
    const R = new be(), W = new be(), x = new be();
    l.vsub(n, R);
    const N = -C.dot(R) / S;
    I.scale(N, W), l.vadd(W, x), this.reportIntersection(C, x, o, i, -1);
  }
  /**
   * Get the world AABB of the ray.
   */
  getAABB(e) {
    const {
      lowerBound: t,
      upperBound: n
    } = e, i = this.to, o = this.from;
    t.x = Math.min(i.x, o.x), t.y = Math.min(i.y, o.y), t.z = Math.min(i.z, o.z), n.x = Math.max(i.x, o.x), n.y = Math.max(i.y, o.y), n.z = Math.max(i.z, o.z);
  }
  _intersectHeightfield(e, t, n, i, o) {
    e.data, e.elementSize;
    const l = nne;
    l.from.copy(this.from), l.to.copy(this.to), nI.pointToLocalFrame(n, t, l.from, l.from), nI.pointToLocalFrame(n, t, l.to, l.to), l.updateDirection();
    const u = ine;
    let I, C, f, v;
    I = C = 0, f = v = e.data.length - 1;
    const b = new $C();
    l.getAABB(b), e.getIndexOfPosition(b.lowerBound.x, b.lowerBound.y, u, !0), I = Math.max(I, u[0]), C = Math.max(C, u[1]), e.getIndexOfPosition(b.upperBound.x, b.upperBound.y, u, !0), f = Math.min(f, u[0] + 1), v = Math.min(v, u[1] + 1);
    for (let S = I; S < f; S++)
      for (let R = C; R < v; R++) {
        if (this.result.shouldStop)
          return;
        if (e.getAabbAtIndex(S, R, b), !!b.overlapsRay(l)) {
          if (e.getConvexTrianglePillar(S, R, !1), nI.pointToWorldFrame(n, t, e.pillarOffset, e2), this._intersectConvex(e.pillarConvex, t, e2, i, o, j5), this.result.shouldStop)
            return;
          e.getConvexTrianglePillar(S, R, !0), nI.pointToWorldFrame(n, t, e.pillarOffset, e2), this._intersectConvex(e.pillarConvex, t, e2, i, o, j5);
        }
      }
  }
  _intersectSphere(e, t, n, i, o) {
    const l = this.from, u = this.to, I = e.radius, C = (u.x - l.x) ** 2 + (u.y - l.y) ** 2 + (u.z - l.z) ** 2, f = 2 * ((u.x - l.x) * (l.x - n.x) + (u.y - l.y) * (l.y - n.y) + (u.z - l.z) * (l.z - n.z)), v = (l.x - n.x) ** 2 + (l.y - n.y) ** 2 + (l.z - n.z) ** 2 - I ** 2, b = f ** 2 - 4 * C * v, S = rne, R = ane;
    if (!(b < 0))
      if (b === 0)
        l.lerp(u, b, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1);
      else {
        const W = (-f - Math.sqrt(b)) / (2 * C), x = (-f + Math.sqrt(b)) / (2 * C);
        if (W >= 0 && W <= 1 && (l.lerp(u, W, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1)), this.result.shouldStop)
          return;
        x >= 0 && x <= 1 && (l.lerp(u, x, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1));
      }
  }
  _intersectConvex(e, t, n, i, o, l) {
    const u = one, I = q5, C = l && l.faceList || null, f = e.faces, v = e.vertices, b = e.faceNormals, S = this.direction, R = this.from, W = this.to, x = R.distanceTo(W), N = C ? C.length : f.length, Y = this.result;
    for (let F = 0; !Y.shouldStop && F < N; F++) {
      const T = C ? C[F] : F, P = f[T], D = b[T], L = t, j = n;
      I.copy(v[P[0]]), L.vmult(I, I), I.vadd(j, I), I.vsub(R, I), L.vmult(D, u);
      const J = S.dot(u);
      if (Math.abs(J) < this.precision)
        continue;
      const O = u.dot(I) / J;
      if (!(O < 0)) {
        S.scale(O, qd), qd.vadd(R, qd), Qh.copy(v[P[0]]), L.vmult(Qh, Qh), j.vadd(Qh, Qh);
        for (let ne = 1; !Y.shouldStop && ne < P.length - 1; ne++) {
          qf.copy(v[P[ne]]), $f.copy(v[P[ne + 1]]), L.vmult(qf, qf), L.vmult($f, $f), j.vadd(qf, qf), j.vadd($f, $f);
          const he = qd.distanceTo(R);
          !(rg.pointInTriangle(qd, Qh, qf, $f) || rg.pointInTriangle(qd, qf, Qh, $f)) || he > x || this.reportIntersection(u, qd, o, i, T);
        }
      }
    }
  }
  /**
   * @todo Optimize by transforming the world to local space first.
   * @todo Use Octree lookup
   */
  _intersectTrimesh(e, t, n, i, o, l) {
    const u = sne, I = Ine, C = Cne, f = q5, v = lne, b = une, S = cne, R = dne, W = gne, x = e.indices;
    e.vertices;
    const N = this.from, Y = this.to, F = this.direction;
    C.position.copy(n), C.quaternion.copy(t), nI.vectorToLocalFrame(n, t, F, v), nI.pointToLocalFrame(n, t, N, b), nI.pointToLocalFrame(n, t, Y, S), S.x *= e.scale.x, S.y *= e.scale.y, S.z *= e.scale.z, b.x *= e.scale.x, b.y *= e.scale.y, b.z *= e.scale.z, S.vsub(b, v), v.normalize();
    const T = b.distanceSquared(S);
    e.tree.rayQuery(this, C, I);
    for (let P = 0, D = I.length; !this.result.shouldStop && P !== D; P++) {
      const L = I[P];
      e.getNormal(L, u), e.getVertex(x[L * 3], Qh), Qh.vsub(b, f);
      const j = v.dot(u), J = u.dot(f) / j;
      if (J < 0)
        continue;
      v.scale(J, qd), qd.vadd(b, qd), e.getVertex(x[L * 3 + 1], qf), e.getVertex(x[L * 3 + 2], $f);
      const O = qd.distanceSquared(b);
      !(rg.pointInTriangle(qd, qf, Qh, $f) || rg.pointInTriangle(qd, Qh, qf, $f)) || O > T || (nI.vectorToWorldFrame(t, u, W), nI.pointToWorldFrame(n, t, qd, R), this.reportIntersection(W, R, o, i, L));
    }
    I.length = 0;
  }
  /**
   * @return True if the intersections should continue
   */
  reportIntersection(e, t, n, i, o) {
    const l = this.from, u = this.to, I = l.distanceTo(t), C = this.result;
    if (!(this.skipBackfaces && e.dot(this.direction) > 0))
      switch (C.hitFaceIndex = typeof o < "u" ? o : -1, this.mode) {
        case rg.ALL:
          this.hasHit = !0, C.set(l, u, e, t, n, i, I), C.hasHit = !0, this.callback(C);
          break;
        case rg.CLOSEST:
          (I < C.distance || !C.hasHit) && (this.hasHit = !0, C.hasHit = !0, C.set(l, u, e, t, n, i, I));
          break;
        case rg.ANY:
          this.hasHit = !0, C.hasHit = !0, C.set(l, u, e, t, n, i, I), C.shouldStop = !0;
          break;
      }
  }
  /**
   * As per "Barycentric Technique" as named
   * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
   */
  static pointInTriangle(e, t, n, i) {
    i.vsub(t, ob), n.vsub(t, FZ), e.vsub(t, AH);
    const o = ob.dot(ob), l = ob.dot(FZ), u = ob.dot(AH), I = FZ.dot(FZ), C = FZ.dot(AH);
    let f, v;
    return (f = I * u - l * C) >= 0 && (v = o * C - l * u) >= 0 && f + v < o * I - l * l;
  }
}
rg.CLOSEST = DY.CLOSEST;
rg.ANY = DY.ANY;
rg.ALL = DY.ALL;
const Q5 = new $C(), mH = [], FZ = new be(), AH = new be(), ene = new be(), tne = new Qg(), qd = new be(), Qh = new be(), qf = new be(), $f = new be();
new be();
new sX();
const j5 = {
  faceList: [0]
}, e2 = new be(), nne = new rg(), ine = [], rne = new be(), ane = new be(), one = new be();
new be();
new be();
const q5 = new be(), sne = new be(), lne = new be(), une = new be(), cne = new be(), gne = new be(), dne = new be();
new $C();
const Ine = [], Cne = new nI(), ob = new be(), t2 = new be();
function hne(r, e, t) {
  t.vsub(r, ob);
  const n = ob.dot(e);
  return e.scale(n, t2), t2.vadd(r, t2), t.distanceTo(t2);
}
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new rg();
new be();
new be();
new be();
new be(1, 0, 0), new be(0, 1, 0), new be(0, 0, 1);
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new $C();
new be();
new $C();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new $C();
new be();
new nI();
new $C();
bi.types.SPHERE, bi.types.SPHERE | bi.types.PLANE, bi.types.BOX | bi.types.BOX, bi.types.SPHERE | bi.types.BOX, bi.types.PLANE | bi.types.BOX, bi.types.CONVEXPOLYHEDRON, bi.types.SPHERE | bi.types.CONVEXPOLYHEDRON, bi.types.PLANE | bi.types.CONVEXPOLYHEDRON, bi.types.BOX | bi.types.CONVEXPOLYHEDRON, bi.types.SPHERE | bi.types.HEIGHTFIELD, bi.types.BOX | bi.types.HEIGHTFIELD, bi.types.CONVEXPOLYHEDRON | bi.types.HEIGHTFIELD, bi.types.PARTICLE | bi.types.SPHERE, bi.types.PLANE | bi.types.PARTICLE, bi.types.BOX | bi.types.PARTICLE, bi.types.PARTICLE | bi.types.CONVEXPOLYHEDRON, bi.types.CYLINDER, bi.types.SPHERE | bi.types.CYLINDER, bi.types.PLANE | bi.types.CYLINDER, bi.types.BOX | bi.types.CYLINDER, bi.types.CONVEXPOLYHEDRON | bi.types.CYLINDER, bi.types.HEIGHTFIELD | bi.types.CYLINDER, bi.types.PARTICLE | bi.types.CYLINDER, bi.types.SPHERE | bi.types.TRIMESH, bi.types.PLANE | bi.types.TRIMESH;
new be();
new be();
new be();
new be();
new be();
new Qg();
new Qg();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new $C();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be(), new be(), new be(), new be(), new be(), new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new Qg();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new be();
new $C();
new rg();
const EZ = globalThis.performance || {};
if (!EZ.now) {
  let r = Date.now();
  EZ.timing && EZ.timing.navigationStart && (r = EZ.timing.navigationStart), EZ.now = () => Date.now() - r;
}
new be();
class km {
  /**
   * A vector of length 9, containing all matrix elements.
   */
  /**
   * @param elements A vector of length 9, containing all matrix elements.
   */
  constructor(e) {
    e === void 0 && (e = [0, 0, 0, 0, 0, 0, 0, 0, 0]), this.elements = e;
  }
  /**
   * Sets the matrix to identity
   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
   * @todo Create another function that immediately creates an identity matrix eg. `eye()`
   */
  identity() {
    const e = this.elements;
    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1;
  }
  /**
   * Set all elements to zero
   */
  setZero() {
    const e = this.elements;
    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 0;
  }
  /**
   * Sets the matrix diagonal elements from a Vec3
   */
  setTrace(e) {
    const t = this.elements;
    t[0] = e.x, t[4] = e.y, t[8] = e.z;
  }
  /**
   * Gets the matrix diagonal elements
   */
  getTrace(e) {
    e === void 0 && (e = new Ge());
    const t = this.elements;
    return e.x = t[0], e.y = t[4], e.z = t[8], e;
  }
  /**
   * Matrix-Vector multiplication
   * @param v The vector to multiply with
   * @param target Optional, target to save the result in.
   */
  vmult(e, t) {
    t === void 0 && (t = new Ge());
    const n = this.elements, i = e.x, o = e.y, l = e.z;
    return t.x = n[0] * i + n[1] * o + n[2] * l, t.y = n[3] * i + n[4] * o + n[5] * l, t.z = n[6] * i + n[7] * o + n[8] * l, t;
  }
  /**
   * Matrix-scalar multiplication
   */
  smult(e) {
    for (let t = 0; t < this.elements.length; t++)
      this.elements[t] *= e;
  }
  /**
   * Matrix multiplication
   * @param matrix Matrix to multiply with from left side.
   */
  mmult(e, t) {
    t === void 0 && (t = new km());
    const n = this.elements, i = e.elements, o = t.elements, l = n[0], u = n[1], I = n[2], C = n[3], f = n[4], v = n[5], b = n[6], S = n[7], R = n[8], W = i[0], x = i[1], N = i[2], Y = i[3], F = i[4], T = i[5], P = i[6], D = i[7], L = i[8];
    return o[0] = l * W + u * Y + I * P, o[1] = l * x + u * F + I * D, o[2] = l * N + u * T + I * L, o[3] = C * W + f * Y + v * P, o[4] = C * x + f * F + v * D, o[5] = C * N + f * T + v * L, o[6] = b * W + S * Y + R * P, o[7] = b * x + S * F + R * D, o[8] = b * N + S * T + R * L, t;
  }
  /**
   * Scale each column of the matrix
   */
  scale(e, t) {
    t === void 0 && (t = new km());
    const n = this.elements, i = t.elements;
    for (let o = 0; o !== 3; o++)
      i[3 * o + 0] = e.x * n[3 * o + 0], i[3 * o + 1] = e.y * n[3 * o + 1], i[3 * o + 2] = e.z * n[3 * o + 2];
    return t;
  }
  /**
   * Solve Ax=b
   * @param b The right hand side
   * @param target Optional. Target vector to save in.
   * @return The solution x
   * @todo should reuse arrays
   */
  solve(e, t) {
    t === void 0 && (t = new Ge());
    const n = 3, i = 4, o = [];
    let l, u;
    for (l = 0; l < n * i; l++)
      o.push(0);
    for (l = 0; l < 3; l++)
      for (u = 0; u < 3; u++)
        o[l + i * u] = this.elements[l + 3 * u];
    o[3 + 4 * 0] = e.x, o[3 + 4 * 1] = e.y, o[3 + 4 * 2] = e.z;
    let I = 3;
    const C = I;
    let f;
    const v = 4;
    let b;
    do {
      if (l = C - I, o[l + i * l] === 0) {
        for (u = l + 1; u < C; u++)
          if (o[l + i * u] !== 0) {
            f = v;
            do
              b = v - f, o[b + i * l] += o[b + i * u];
            while (--f);
            break;
          }
      }
      if (o[l + i * l] !== 0)
        for (u = l + 1; u < C; u++) {
          const S = o[l + i * u] / o[l + i * l];
          f = v;
          do
            b = v - f, o[b + i * u] = b <= l ? 0 : o[b + i * u] - o[b + i * l] * S;
          while (--f);
        }
    } while (--I);
    if (t.z = o[2 * i + 3] / o[2 * i + 2], t.y = (o[1 * i + 3] - o[1 * i + 2] * t.z) / o[1 * i + 1], t.x = (o[0 * i + 3] - o[0 * i + 2] * t.z - o[0 * i + 1] * t.y) / o[0 * i + 0], isNaN(t.x) || isNaN(t.y) || isNaN(t.z) || t.x === 1 / 0 || t.y === 1 / 0 || t.z === 1 / 0)
      throw `Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;
    return t;
  }
  /**
   * Get an element in the matrix by index. Index starts at 0, not 1!!!
   * @param value If provided, the matrix element will be set to this value.
   */
  e(e, t, n) {
    if (n === void 0)
      return this.elements[t + 3 * e];
    this.elements[t + 3 * e] = n;
  }
  /**
   * Copy another matrix into this matrix object.
   */
  copy(e) {
    for (let t = 0; t < e.elements.length; t++)
      this.elements[t] = e.elements[t];
    return this;
  }
  /**
   * Returns a string representation of the matrix.
   */
  toString() {
    let e = "";
    const t = ",";
    for (let n = 0; n < 9; n++)
      e += this.elements[n] + t;
    return e;
  }
  /**
   * reverse the matrix
   * @param target Target matrix to save in.
   * @return The solution x
   */
  reverse(e) {
    e === void 0 && (e = new km());
    const t = 3, n = 6, i = fne;
    let o, l;
    for (o = 0; o < 3; o++)
      for (l = 0; l < 3; l++)
        i[o + n * l] = this.elements[o + 3 * l];
    i[3 + 6 * 0] = 1, i[3 + 6 * 1] = 0, i[3 + 6 * 2] = 0, i[4 + 6 * 0] = 0, i[4 + 6 * 1] = 1, i[4 + 6 * 2] = 0, i[5 + 6 * 0] = 0, i[5 + 6 * 1] = 0, i[5 + 6 * 2] = 1;
    let u = 3;
    const I = u;
    let C;
    const f = n;
    let v;
    do {
      if (o = I - u, i[o + n * o] === 0) {
        for (l = o + 1; l < I; l++)
          if (i[o + n * l] !== 0) {
            C = f;
            do
              v = f - C, i[v + n * o] += i[v + n * l];
            while (--C);
            break;
          }
      }
      if (i[o + n * o] !== 0)
        for (l = o + 1; l < I; l++) {
          const b = i[o + n * l] / i[o + n * o];
          C = f;
          do
            v = f - C, i[v + n * l] = v <= o ? 0 : i[v + n * l] - i[v + n * o] * b;
          while (--C);
        }
    } while (--u);
    o = 2;
    do {
      l = o - 1;
      do {
        const b = i[o + n * l] / i[o + n * o];
        C = n;
        do
          v = n - C, i[v + n * l] = i[v + n * l] - i[v + n * o] * b;
        while (--C);
      } while (l--);
    } while (--o);
    o = 2;
    do {
      const b = 1 / i[o + n * o];
      C = n;
      do
        v = n - C, i[v + n * o] = i[v + n * o] * b;
      while (--C);
    } while (o--);
    o = 2;
    do {
      l = 2;
      do {
        if (v = i[t + l + n * o], isNaN(v) || v === 1 / 0)
          throw `Could not reverse! A=[${this.toString()}]`;
        e.e(o, l, v);
      } while (l--);
    } while (o--);
    return e;
  }
  /**
   * Set the matrix from a quaterion
   */
  setRotationFromQuaternion(e) {
    const t = e.x, n = e.y, i = e.z, o = e.w, l = t + t, u = n + n, I = i + i, C = t * l, f = t * u, v = t * I, b = n * u, S = n * I, R = i * I, W = o * l, x = o * u, N = o * I, Y = this.elements;
    return Y[3 * 0 + 0] = 1 - (b + R), Y[3 * 0 + 1] = f - N, Y[3 * 0 + 2] = v + x, Y[3 * 1 + 0] = f + N, Y[3 * 1 + 1] = 1 - (C + R), Y[3 * 1 + 2] = S - W, Y[3 * 2 + 0] = v - x, Y[3 * 2 + 1] = S + W, Y[3 * 2 + 2] = 1 - (C + b), this;
  }
  /**
   * Transpose the matrix
   * @param target Optional. Where to store the result.
   * @return The target Mat3, or a new Mat3 if target was omitted.
   */
  transpose(e) {
    e === void 0 && (e = new km());
    const t = this.elements, n = e.elements;
    let i;
    return n[0] = t[0], n[4] = t[4], n[8] = t[8], i = t[1], n[1] = t[3], n[3] = i, i = t[2], n[2] = t[6], n[6] = i, i = t[5], n[5] = t[7], n[7] = i, e;
  }
}
const fne = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
class Ge {
  constructor(e, t, n) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), this.x = e, this.y = t, this.z = n;
  }
  /**
   * Vector cross product
   * @param target Optional target to save in.
   */
  cross(e, t) {
    t === void 0 && (t = new Ge());
    const n = e.x, i = e.y, o = e.z, l = this.x, u = this.y, I = this.z;
    return t.x = u * o - I * i, t.y = I * n - l * o, t.z = l * i - u * n, t;
  }
  /**
   * Set the vectors' 3 elements
   */
  set(e, t, n) {
    return this.x = e, this.y = t, this.z = n, this;
  }
  /**
   * Set all components of the vector to zero.
   */
  setZero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Vector addition
   */
  vadd(e, t) {
    if (t)
      t.x = e.x + this.x, t.y = e.y + this.y, t.z = e.z + this.z;
    else
      return new Ge(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  /**
   * Vector subtraction
   * @param target Optional target to save in.
   */
  vsub(e, t) {
    if (t)
      t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z;
    else
      return new Ge(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  /**
   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
   *
   * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Ume University Lecture}
   */
  crossmat() {
    return new km([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  /**
   * Normalize the vector. Note that this changes the values in the vector.
    * @return Returns the norm of the vector
   */
  normalize() {
    const e = this.x, t = this.y, n = this.z, i = Math.sqrt(e * e + t * t + n * n);
    if (i > 0) {
      const o = 1 / i;
      this.x *= o, this.y *= o, this.z *= o;
    } else
      this.x = 0, this.y = 0, this.z = 0;
    return i;
  }
  /**
   * Get the version of this vector that is of length 1.
   * @param target Optional target to save in
   * @return Returns the unit vector
   */
  unit(e) {
    e === void 0 && (e = new Ge());
    const t = this.x, n = this.y, i = this.z;
    let o = Math.sqrt(t * t + n * n + i * i);
    return o > 0 ? (o = 1 / o, e.x = t * o, e.y = n * o, e.z = i * o) : (e.x = 1, e.y = 0, e.z = 0), e;
  }
  /**
   * Get the length of the vector
   */
  length() {
    const e = this.x, t = this.y, n = this.z;
    return Math.sqrt(e * e + t * t + n * n);
  }
  /**
   * Get the squared length of the vector.
   */
  lengthSquared() {
    return this.dot(this);
  }
  /**
   * Get distance from this point to another point
   */
  distanceTo(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z;
    return Math.sqrt((o - t) * (o - t) + (l - n) * (l - n) + (u - i) * (u - i));
  }
  /**
   * Get squared distance from this point to another point
   */
  distanceSquared(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z;
    return (o - t) * (o - t) + (l - n) * (l - n) + (u - i) * (u - i);
  }
  /**
   * Multiply all the components of the vector with a scalar.
   * @param target The vector to save the result in.
   */
  scale(e, t) {
    t === void 0 && (t = new Ge());
    const n = this.x, i = this.y, o = this.z;
    return t.x = e * n, t.y = e * i, t.z = e * o, t;
  }
  /**
   * Multiply the vector with an other vector, component-wise.
   * @param target The vector to save the result in.
   */
  vmul(e, t) {
    return t === void 0 && (t = new Ge()), t.x = e.x * this.x, t.y = e.y * this.y, t.z = e.z * this.z, t;
  }
  /**
   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
   * @param target The vector to save the result in.
   */
  addScaledVector(e, t, n) {
    return n === void 0 && (n = new Ge()), n.x = this.x + e * t.x, n.y = this.y + e * t.y, n.z = this.z + e * t.z, n;
  }
  /**
   * Calculate dot product
   * @param vector
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  /**
   * Make the vector point in the opposite direction.
   * @param target Optional target to save in
   */
  negate(e) {
    return e === void 0 && (e = new Ge()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e;
  }
  /**
   * Compute two artificial tangents to the vector
   * @param t1 Vector object to save the first tangent in
   * @param t2 Vector object to save the second tangent in
   */
  tangents(e, t) {
    const n = this.length();
    if (n > 0) {
      const i = pne, o = 1 / n;
      i.set(this.x * o, this.y * o, this.z * o);
      const l = mne;
      Math.abs(i.x) < 0.9 ? (l.set(1, 0, 0), i.cross(l, e)) : (l.set(0, 1, 0), i.cross(l, e)), i.cross(e, t);
    } else
      e.set(1, 0, 0), t.set(0, 1, 0);
  }
  /**
   * Converts to a more readable format
   */
  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  /**
   * Converts to an array
   */
  toArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * Copies value of source to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Do a linear interpolation between two vectors
   * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
   */
  lerp(e, t, n) {
    const i = this.x, o = this.y, l = this.z;
    n.x = i + (e.x - i) * t, n.y = o + (e.y - o) * t, n.z = l + (e.z - l) * t;
  }
  /**
   * Check if a vector equals is almost equal to another one.
   */
  almostEquals(e, t) {
    return t === void 0 && (t = 1e-6), !(Math.abs(this.x - e.x) > t || Math.abs(this.y - e.y) > t || Math.abs(this.z - e.z) > t);
  }
  /**
   * Check if a vector is almost zero
   */
  almostZero(e) {
    return e === void 0 && (e = 1e-6), !(Math.abs(this.x) > e || Math.abs(this.y) > e || Math.abs(this.z) > e);
  }
  /**
   * Check if the vector is anti-parallel to another vector.
   * @param precision Set to zero for exact comparisons
   */
  isAntiparallelTo(e, t) {
    return this.negate($5), $5.almostEquals(e, t);
  }
  /**
   * Clone the vector
   */
  clone() {
    return new Ge(this.x, this.y, this.z);
  }
}
Ge.ZERO = new Ge(0, 0, 0);
Ge.UNIT_X = new Ge(1, 0, 0);
Ge.UNIT_Y = new Ge(0, 1, 0);
Ge.UNIT_Z = new Ge(0, 0, 1);
const pne = new Ge(), mne = new Ge(), $5 = new Ge();
class eh {
  /**
   * The lower bound of the bounding box
   */
  /**
   * The upper bound of the bounding box
   */
  constructor(e) {
    e === void 0 && (e = {}), this.lowerBound = new Ge(), this.upperBound = new Ge(), e.lowerBound && this.lowerBound.copy(e.lowerBound), e.upperBound && this.upperBound.copy(e.upperBound);
  }
  /**
   * Set the AABB bounds from a set of points.
   * @param points An array of Vec3's.
   * @return The self object
   */
  setFromPoints(e, t, n, i) {
    const o = this.lowerBound, l = this.upperBound, u = n;
    o.copy(e[0]), u && u.vmult(o, o), l.copy(o);
    for (let I = 1; I < e.length; I++) {
      let C = e[I];
      u && (u.vmult(C, e_), C = e_), C.x > l.x && (l.x = C.x), C.x < o.x && (o.x = C.x), C.y > l.y && (l.y = C.y), C.y < o.y && (o.y = C.y), C.z > l.z && (l.z = C.z), C.z < o.z && (o.z = C.z);
    }
    return t && (t.vadd(o, o), t.vadd(l, l)), i && (o.x -= i, o.y -= i, o.z -= i, l.x += i, l.y += i, l.z += i), this;
  }
  /**
   * Copy bounds from an AABB to this AABB
   * @param aabb Source to copy from
   * @return The this object, for chainability
   */
  copy(e) {
    return this.lowerBound.copy(e.lowerBound), this.upperBound.copy(e.upperBound), this;
  }
  /**
   * Clone an AABB
   */
  clone() {
    return new eh().copy(this);
  }
  /**
   * Extend this AABB so that it covers the given AABB too.
   */
  extend(e) {
    this.lowerBound.x = Math.min(this.lowerBound.x, e.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, e.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, e.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, e.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, e.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, e.upperBound.z);
  }
  /**
   * Returns true if the given AABB overlaps this AABB.
   */
  overlaps(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, o = e.upperBound, l = i.x <= n.x && n.x <= o.x || t.x <= o.x && o.x <= n.x, u = i.y <= n.y && n.y <= o.y || t.y <= o.y && o.y <= n.y, I = i.z <= n.z && n.z <= o.z || t.z <= o.z && o.z <= n.z;
    return l && u && I;
  }
  // Mostly for debugging
  volume() {
    const e = this.lowerBound, t = this.upperBound;
    return (t.x - e.x) * (t.y - e.y) * (t.z - e.z);
  }
  /**
   * Returns true if the given AABB is fully contained in this AABB.
   */
  contains(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, o = e.upperBound;
    return t.x <= i.x && n.x >= o.x && t.y <= i.y && n.y >= o.y && t.z <= i.z && n.z >= o.z;
  }
  getCorners(e, t, n, i, o, l, u, I) {
    const C = this.lowerBound, f = this.upperBound;
    e.copy(C), t.set(f.x, C.y, C.z), n.set(f.x, f.y, C.z), i.set(C.x, f.y, f.z), o.set(f.x, C.y, f.z), l.set(C.x, f.y, C.z), u.set(C.x, C.y, f.z), I.copy(f);
  }
  /**
   * Get the representation of an AABB in another frame.
   * @return The "target" AABB object.
   */
  toLocalFrame(e, t) {
    const n = t_, i = n[0], o = n[1], l = n[2], u = n[3], I = n[4], C = n[5], f = n[6], v = n[7];
    this.getCorners(i, o, l, u, I, C, f, v);
    for (let b = 0; b !== 8; b++) {
      const S = n[b];
      e.pointToLocal(S, S);
    }
    return t.setFromPoints(n);
  }
  /**
   * Get the representation of an AABB in the global frame.
   * @return The "target" AABB object.
   */
  toWorldFrame(e, t) {
    const n = t_, i = n[0], o = n[1], l = n[2], u = n[3], I = n[4], C = n[5], f = n[6], v = n[7];
    this.getCorners(i, o, l, u, I, C, f, v);
    for (let b = 0; b !== 8; b++) {
      const S = n[b];
      e.pointToWorld(S, S);
    }
    return t.setFromPoints(n);
  }
  /**
   * Check if the AABB is hit by a ray.
   */
  overlapsRay(e) {
    const {
      direction: t,
      from: n
    } = e, i = 1 / t.x, o = 1 / t.y, l = 1 / t.z, u = (this.lowerBound.x - n.x) * i, I = (this.upperBound.x - n.x) * i, C = (this.lowerBound.y - n.y) * o, f = (this.upperBound.y - n.y) * o, v = (this.lowerBound.z - n.z) * l, b = (this.upperBound.z - n.z) * l, S = Math.max(Math.max(Math.min(u, I), Math.min(C, f)), Math.min(v, b)), R = Math.min(Math.min(Math.max(u, I), Math.max(C, f)), Math.max(v, b));
    return !(R < 0 || S > R);
  }
}
const e_ = new Ge(), t_ = [new Ge(), new Ge(), new Ge(), new Ge(), new Ge(), new Ge(), new Ge(), new Ge()];
class jg {
  constructor(e, t, n, i) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), i === void 0 && (i = 1), this.x = e, this.y = t, this.z = n, this.w = i;
  }
  /**
   * Set the value of the quaternion.
   */
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  /**
   * Convert to a readable format
   * @return "x,y,z,w"
   */
  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  /**
   * Convert to an Array
   * @return [x, y, z, w]
   */
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * Set the quaternion components given an axis and an angle in radians.
   */
  setFromAxisAngle(e, t) {
    const n = Math.sin(t * 0.5);
    return this.x = e.x * n, this.y = e.y * n, this.z = e.z * n, this.w = Math.cos(t * 0.5), this;
  }
  /**
   * Converts the quaternion to [ axis, angle ] representation.
   * @param targetAxis A vector object to reuse for storing the axis.
   * @return An array, first element is the axis and the second is the angle in radians.
   */
  toAxisAngle(e) {
    e === void 0 && (e = new Ge()), this.normalize();
    const t = 2 * Math.acos(this.w), n = Math.sqrt(1 - this.w * this.w);
    return n < 1e-3 ? (e.x = this.x, e.y = this.y, e.z = this.z) : (e.x = this.x / n, e.y = this.y / n, e.z = this.z / n), [e, t];
  }
  /**
   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
   */
  setFromVectors(e, t) {
    if (e.isAntiparallelTo(t)) {
      const n = Ane, i = vne;
      e.tangents(n, i), this.setFromAxisAngle(n, Math.PI);
    } else {
      const n = e.cross(t);
      this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(e.length() ** 2 * t.length() ** 2) + e.dot(t), this.normalize();
    }
    return this;
  }
  /**
   * Multiply the quaternion with an other quaternion.
   */
  mult(e, t) {
    t === void 0 && (t = new jg());
    const n = this.x, i = this.y, o = this.z, l = this.w, u = e.x, I = e.y, C = e.z, f = e.w;
    return t.x = n * f + l * u + i * C - o * I, t.y = i * f + l * I + o * u - n * C, t.z = o * f + l * C + n * I - i * u, t.w = l * f - n * u - i * I - o * C, t;
  }
  /**
   * Get the inverse quaternion rotation.
   */
  inverse(e) {
    e === void 0 && (e = new jg());
    const t = this.x, n = this.y, i = this.z, o = this.w;
    this.conjugate(e);
    const l = 1 / (t * t + n * n + i * i + o * o);
    return e.x *= l, e.y *= l, e.z *= l, e.w *= l, e;
  }
  /**
   * Get the quaternion conjugate
   */
  conjugate(e) {
    return e === void 0 && (e = new jg()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e.w = this.w, e;
  }
  /**
   * Normalize the quaternion. Note that this changes the values of the quaternion.
   */
  normalize() {
    let e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  /**
   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
   * @author unphased, https://github.com/unphased
   */
  normalizeFast() {
    const e = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  /**
   * Multiply the quaternion by a vector
   */
  vmult(e, t) {
    t === void 0 && (t = new Ge());
    const n = e.x, i = e.y, o = e.z, l = this.x, u = this.y, I = this.z, C = this.w, f = C * n + u * o - I * i, v = C * i + I * n - l * o, b = C * o + l * i - u * n, S = -l * n - u * i - I * o;
    return t.x = f * C + S * -l + v * -I - b * -u, t.y = v * C + S * -u + b * -l - f * -I, t.z = b * C + S * -I + f * -u - v * -l, t;
  }
  /**
   * Copies value of source to this quaternion.
   * @return this
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  /**
   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
   * @param order Three-character string, defaults to "YZX"
   */
  toEuler(e, t) {
    t === void 0 && (t = "YZX");
    let n, i, o;
    const l = this.x, u = this.y, I = this.z, C = this.w;
    switch (t) {
      case "YZX":
        const f = l * u + I * C;
        if (f > 0.499 && (n = 2 * Math.atan2(l, C), i = Math.PI / 2, o = 0), f < -0.499 && (n = -2 * Math.atan2(l, C), i = -Math.PI / 2, o = 0), n === void 0) {
          const v = l * l, b = u * u, S = I * I;
          n = Math.atan2(2 * u * C - 2 * l * I, 1 - 2 * b - 2 * S), i = Math.asin(2 * f), o = Math.atan2(2 * l * C - 2 * u * I, 1 - 2 * v - 2 * S);
        }
        break;
      default:
        throw new Error(`Euler order ${t} not supported yet.`);
    }
    e.y = n, e.z = i, e.x = o;
  }
  /**
   * Set the quaternion components given Euler angle representation.
   *
   * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
   *
   * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
   */
  setFromEuler(e, t, n, i) {
    i === void 0 && (i = "XYZ");
    const o = Math.cos(e / 2), l = Math.cos(t / 2), u = Math.cos(n / 2), I = Math.sin(e / 2), C = Math.sin(t / 2), f = Math.sin(n / 2);
    return i === "XYZ" ? (this.x = I * l * u + o * C * f, this.y = o * C * u - I * l * f, this.z = o * l * f + I * C * u, this.w = o * l * u - I * C * f) : i === "YXZ" ? (this.x = I * l * u + o * C * f, this.y = o * C * u - I * l * f, this.z = o * l * f - I * C * u, this.w = o * l * u + I * C * f) : i === "ZXY" ? (this.x = I * l * u - o * C * f, this.y = o * C * u + I * l * f, this.z = o * l * f + I * C * u, this.w = o * l * u - I * C * f) : i === "ZYX" ? (this.x = I * l * u - o * C * f, this.y = o * C * u + I * l * f, this.z = o * l * f - I * C * u, this.w = o * l * u + I * C * f) : i === "YZX" ? (this.x = I * l * u + o * C * f, this.y = o * C * u + I * l * f, this.z = o * l * f - I * C * u, this.w = o * l * u - I * C * f) : i === "XZY" && (this.x = I * l * u - o * C * f, this.y = o * C * u - I * l * f, this.z = o * l * f + I * C * u, this.w = o * l * u + I * C * f), this;
  }
  clone() {
    return new jg(this.x, this.y, this.z, this.w);
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param toQuat second operand
   * @param t interpolation amount between the self quaternion and toQuat
   * @param target A quaternion to store the result in. If not provided, a new one will be created.
   * @returns {Quaternion} The "target" object
   */
  slerp(e, t, n) {
    n === void 0 && (n = new jg());
    const i = this.x, o = this.y, l = this.z, u = this.w;
    let I = e.x, C = e.y, f = e.z, v = e.w, b, S, R, W, x;
    return S = i * I + o * C + l * f + u * v, S < 0 && (S = -S, I = -I, C = -C, f = -f, v = -v), 1 - S > 1e-6 ? (b = Math.acos(S), R = Math.sin(b), W = Math.sin((1 - t) * b) / R, x = Math.sin(t * b) / R) : (W = 1 - t, x = t), n.x = W * i + x * I, n.y = W * o + x * C, n.z = W * l + x * f, n.w = W * u + x * v, n;
  }
  /**
   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
   */
  integrate(e, t, n, i) {
    i === void 0 && (i = new jg());
    const o = e.x * n.x, l = e.y * n.y, u = e.z * n.z, I = this.x, C = this.y, f = this.z, v = this.w, b = t * 0.5;
    return i.x += b * (o * v + l * f - u * C), i.y += b * (l * v + u * I - o * f), i.z += b * (u * v + o * C - l * I), i.w += b * (-o * I - l * C - u * f), i;
  }
}
const Ane = new Ge(), vne = new Ge(), yne = {
  /** SPHERE */
  SPHERE: 1,
  /** PLANE */
  PLANE: 2,
  /** BOX */
  BOX: 4,
  /** COMPOUND */
  COMPOUND: 8,
  /** CONVEXPOLYHEDRON */
  CONVEXPOLYHEDRON: 16,
  /** HEIGHTFIELD */
  HEIGHTFIELD: 32,
  /** PARTICLE */
  PARTICLE: 64,
  /** CYLINDER */
  CYLINDER: 128,
  /** TRIMESH */
  TRIMESH: 256
};
class Gi {
  /**
   * Identifier of the Shape.
   */
  /**
   * The type of this shape. Must be set to an int > 0 by subclasses.
   */
  /**
   * The local bounding sphere radius of this shape.
   */
  /**
   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
   * @default true
   */
  /**
   * @default 1
   */
  /**
   * @default -1
   */
  /**
   * Optional material of the shape that regulates contact properties.
   */
  /**
   * The body to which the shape is added to.
   */
  /**
   * All the Shape types.
   */
  constructor(e) {
    e === void 0 && (e = {}), this.id = Gi.idCounter++, this.type = e.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = e.collisionResponse ? e.collisionResponse : !0, this.collisionFilterGroup = e.collisionFilterGroup !== void 0 ? e.collisionFilterGroup : 1, this.collisionFilterMask = e.collisionFilterMask !== void 0 ? e.collisionFilterMask : -1, this.material = e.material ? e.material : null, this.body = null;
  }
  /**
   * Computes the bounding sphere radius.
   * The result is stored in the property `.boundingSphereRadius`
   */
  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  /**
   * Get the volume of this shape
   */
  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  /**
   * Calculates the inertia in the local frame for this shape.
   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  calculateLocalInertia(e, t) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  /**
   * @todo use abstract for these kind of methods
   */
  calculateWorldAABB(e, t, n, i) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }
}
Gi.idCounter = 0;
Gi.types = yne;
class iI {
  /**
   * position
   */
  /**
   * quaternion
   */
  constructor(e) {
    e === void 0 && (e = {}), this.position = new Ge(), this.quaternion = new jg(), e.position && this.position.copy(e.position), e.quaternion && this.quaternion.copy(e.quaternion);
  }
  /**
   * Get a global point in local transform coordinates.
   */
  pointToLocal(e, t) {
    return iI.pointToLocalFrame(this.position, this.quaternion, e, t);
  }
  /**
   * Get a local point in global transform coordinates.
   */
  pointToWorld(e, t) {
    return iI.pointToWorldFrame(this.position, this.quaternion, e, t);
  }
  /**
   * vectorToWorldFrame
   */
  vectorToWorldFrame(e, t) {
    return t === void 0 && (t = new Ge()), this.quaternion.vmult(e, t), t;
  }
  /**
   * pointToLocalFrame
   */
  static pointToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new Ge()), n.vsub(e, i), t.conjugate(n_), n_.vmult(i, i), i;
  }
  /**
   * pointToWorldFrame
   */
  static pointToWorldFrame(e, t, n, i) {
    return i === void 0 && (i = new Ge()), t.vmult(n, i), i.vadd(e, i), i;
  }
  /**
   * vectorToWorldFrame
   */
  static vectorToWorldFrame(e, t, n) {
    return n === void 0 && (n = new Ge()), e.vmult(t, n), n;
  }
  /**
   * vectorToLocalFrame
   */
  static vectorToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new Ge()), t.w *= -1, t.vmult(n, i), t.w *= -1, i;
  }
}
const n_ = new jg();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge(), new Ge(), new Ge(), new Ge(), new Ge(), new Ge(), new Ge(), new Ge();
new Ge();
new jg();
new eh();
new km();
new km();
new km();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new jg();
new Ge();
new Ge();
new Ge();
new Ge();
class lX {
  /**
   * rayFromWorld
   */
  /**
   * rayToWorld
   */
  /**
   * hitNormalWorld
   */
  /**
   * hitPointWorld
   */
  /**
   * hasHit
   */
  /**
   * shape
   */
  /**
   * body
   */
  /**
   * The index of the hit triangle, if the hit shape was a trimesh
   */
  /**
   * Distance to the hit. Will be set to -1 if there was no hit
   */
  /**
   * If the ray should stop traversing the bodies
   */
  constructor() {
    this.rayFromWorld = new Ge(), this.rayToWorld = new Ge(), this.hitNormalWorld = new Ge(), this.hitPointWorld = new Ge(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  /**
   * Reset all result data.
   */
  reset() {
    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  /**
   * abort
   */
  abort() {
    this.shouldStop = !0;
  }
  /**
   * Set result data.
   */
  set(e, t, n, i, o, l, u) {
    this.rayFromWorld.copy(e), this.rayToWorld.copy(t), this.hitNormalWorld.copy(n), this.hitPointWorld.copy(i), this.shape = o, this.body = l, this.distance = u;
  }
}
let B9, S9, Z9, w9, R9, x9, W9;
const UY = {
  /** CLOSEST */
  CLOSEST: 1,
  /** ANY */
  ANY: 2,
  /** ALL */
  ALL: 4
};
B9 = Gi.types.SPHERE;
S9 = Gi.types.PLANE;
Z9 = Gi.types.BOX;
w9 = Gi.types.CYLINDER;
R9 = Gi.types.CONVEXPOLYHEDRON;
x9 = Gi.types.HEIGHTFIELD;
W9 = Gi.types.TRIMESH;
class ag {
  /**
   * from
   */
  /**
   * to
   */
  /**
   * direction
   */
  /**
   * The precision of the ray. Used when checking parallelity etc.
   * @default 0.0001
   */
  /**
   * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
   * @default true
   */
  /**
   * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
   * @default false
   */
  /**
   * collisionFilterMask
   * @default -1
   */
  /**
   * collisionFilterGroup
   * @default -1
   */
  /**
   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
   * @default RAY.ANY
   */
  /**
   * Current result object.
   */
  /**
   * Will be set to `true` during intersectWorld() if the ray hit anything.
   */
  /**
   * User-provided result callback. Will be used if mode is Ray.ALL.
   */
  /**
   * CLOSEST
   */
  /**
   * ANY
   */
  /**
   * ALL
   */
  get [B9]() {
    return this._intersectSphere;
  }
  get [S9]() {
    return this._intersectPlane;
  }
  get [Z9]() {
    return this._intersectBox;
  }
  get [w9]() {
    return this._intersectConvex;
  }
  get [R9]() {
    return this._intersectConvex;
  }
  get [x9]() {
    return this._intersectHeightfield;
  }
  get [W9]() {
    return this._intersectTrimesh;
  }
  constructor(e, t) {
    e === void 0 && (e = new Ge()), t === void 0 && (t = new Ge()), this.from = e.clone(), this.to = t.clone(), this.direction = new Ge(), this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = ag.ANY, this.result = new lX(), this.hasHit = !1, this.callback = (n) => {
    };
  }
  /**
   * Do itersection against all bodies in the given World.
   * @return True if the ray hit anything, otherwise false.
   */
  intersectWorld(e, t) {
    return this.mode = t.mode || ag.ANY, this.result = t.result || new lX(), this.skipBackfaces = !!t.skipBackfaces, this.collisionFilterMask = typeof t.collisionFilterMask < "u" ? t.collisionFilterMask : -1, this.collisionFilterGroup = typeof t.collisionFilterGroup < "u" ? t.collisionFilterGroup : -1, this.checkCollisionResponse = typeof t.checkCollisionResponse < "u" ? t.checkCollisionResponse : !0, t.from && this.from.copy(t.from), t.to && this.to.copy(t.to), this.callback = t.callback || (() => {
    }), this.hasHit = !1, this.result.reset(), this.updateDirection(), this.getAABB(i_), vH.length = 0, e.broadphase.aabbQuery(e, i_, vH), this.intersectBodies(vH), this.hasHit;
  }
  /**
   * Shoot a ray at a body, get back information about the hit.
   * @deprecated @param result set the result property of the Ray instead.
   */
  intersectBody(e, t) {
    t && (this.result = t, this.updateDirection());
    const n = this.checkCollisionResponse;
    if (n && !e.collisionResponse || (this.collisionFilterGroup & e.collisionFilterMask) === 0 || (e.collisionFilterGroup & this.collisionFilterMask) === 0)
      return;
    const i = bne, o = Gne;
    for (let l = 0, u = e.shapes.length; l < u; l++) {
      const I = e.shapes[l];
      if (!(n && !I.collisionResponse) && (e.quaternion.mult(e.shapeOrientations[l], o), e.quaternion.vmult(e.shapeOffsets[l], i), i.vadd(e.position, i), this.intersectShape(I, o, i, e), this.result.shouldStop))
        break;
    }
  }
  /**
   * Shoot a ray at an array bodies, get back information about the hit.
   * @param bodies An array of Body objects.
   * @deprecated @param result set the result property of the Ray instead.
   *
   */
  intersectBodies(e, t) {
    t && (this.result = t, this.updateDirection());
    for (let n = 0, i = e.length; !this.result.shouldStop && n < i; n++)
      this.intersectBody(e[n]);
  }
  /**
   * Updates the direction vector.
   */
  updateDirection() {
    this.to.vsub(this.from, this.direction), this.direction.normalize();
  }
  intersectShape(e, t, n, i) {
    const o = this.from;
    if (Fne(o, this.direction, n) > e.boundingSphereRadius)
      return;
    const u = this[e.type];
    u && u.call(this, e, t, n, i, e);
  }
  _intersectBox(e, t, n, i, o) {
    return this._intersectConvex(e.convexPolyhedronRepresentation, t, n, i, o);
  }
  _intersectPlane(e, t, n, i, o) {
    const l = this.from, u = this.to, I = this.direction, C = new Ge(0, 0, 1);
    t.vmult(C, C);
    const f = new Ge();
    l.vsub(n, f);
    const v = f.dot(C);
    u.vsub(n, f);
    const b = f.dot(C);
    if (v * b > 0 || l.distanceTo(u) < v)
      return;
    const S = C.dot(I);
    if (Math.abs(S) < this.precision)
      return;
    const R = new Ge(), W = new Ge(), x = new Ge();
    l.vsub(n, R);
    const N = -C.dot(R) / S;
    I.scale(N, W), l.vadd(W, x), this.reportIntersection(C, x, o, i, -1);
  }
  /**
   * Get the world AABB of the ray.
   */
  getAABB(e) {
    const {
      lowerBound: t,
      upperBound: n
    } = e, i = this.to, o = this.from;
    t.x = Math.min(i.x, o.x), t.y = Math.min(i.y, o.y), t.z = Math.min(i.z, o.z), n.x = Math.max(i.x, o.x), n.y = Math.max(i.y, o.y), n.z = Math.max(i.z, o.z);
  }
  _intersectHeightfield(e, t, n, i, o) {
    e.data, e.elementSize;
    const l = Bne;
    l.from.copy(this.from), l.to.copy(this.to), iI.pointToLocalFrame(n, t, l.from, l.from), iI.pointToLocalFrame(n, t, l.to, l.to), l.updateDirection();
    const u = Sne;
    let I, C, f, v;
    I = C = 0, f = v = e.data.length - 1;
    const b = new eh();
    l.getAABB(b), e.getIndexOfPosition(b.lowerBound.x, b.lowerBound.y, u, !0), I = Math.max(I, u[0]), C = Math.max(C, u[1]), e.getIndexOfPosition(b.upperBound.x, b.upperBound.y, u, !0), f = Math.min(f, u[0] + 1), v = Math.min(v, u[1] + 1);
    for (let S = I; S < f; S++)
      for (let R = C; R < v; R++) {
        if (this.result.shouldStop)
          return;
        if (e.getAabbAtIndex(S, R, b), !!b.overlapsRay(l)) {
          if (e.getConvexTrianglePillar(S, R, !1), iI.pointToWorldFrame(n, t, e.pillarOffset, n2), this._intersectConvex(e.pillarConvex, t, n2, i, o, r_), this.result.shouldStop)
            return;
          e.getConvexTrianglePillar(S, R, !0), iI.pointToWorldFrame(n, t, e.pillarOffset, n2), this._intersectConvex(e.pillarConvex, t, n2, i, o, r_);
        }
      }
  }
  _intersectSphere(e, t, n, i, o) {
    const l = this.from, u = this.to, I = e.radius, C = (u.x - l.x) ** 2 + (u.y - l.y) ** 2 + (u.z - l.z) ** 2, f = 2 * ((u.x - l.x) * (l.x - n.x) + (u.y - l.y) * (l.y - n.y) + (u.z - l.z) * (l.z - n.z)), v = (l.x - n.x) ** 2 + (l.y - n.y) ** 2 + (l.z - n.z) ** 2 - I ** 2, b = f ** 2 - 4 * C * v, S = Zne, R = wne;
    if (!(b < 0))
      if (b === 0)
        l.lerp(u, b, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1);
      else {
        const W = (-f - Math.sqrt(b)) / (2 * C), x = (-f + Math.sqrt(b)) / (2 * C);
        if (W >= 0 && W <= 1 && (l.lerp(u, W, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1)), this.result.shouldStop)
          return;
        x >= 0 && x <= 1 && (l.lerp(u, x, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1));
      }
  }
  _intersectConvex(e, t, n, i, o, l) {
    const u = Rne, I = a_, C = l && l.faceList || null, f = e.faces, v = e.vertices, b = e.faceNormals, S = this.direction, R = this.from, W = this.to, x = R.distanceTo(W), N = C ? C.length : f.length, Y = this.result;
    for (let F = 0; !Y.shouldStop && F < N; F++) {
      const T = C ? C[F] : F, P = f[T], D = b[T], L = t, j = n;
      I.copy(v[P[0]]), L.vmult(I, I), I.vadd(j, I), I.vsub(R, I), L.vmult(D, u);
      const J = S.dot(u);
      if (Math.abs(J) < this.precision)
        continue;
      const O = u.dot(I) / J;
      if (!(O < 0)) {
        S.scale(O, $d), $d.vadd(R, $d), jh.copy(v[P[0]]), L.vmult(jh, jh), j.vadd(jh, jh);
        for (let ne = 1; !Y.shouldStop && ne < P.length - 1; ne++) {
          ep.copy(v[P[ne]]), tp.copy(v[P[ne + 1]]), L.vmult(ep, ep), L.vmult(tp, tp), j.vadd(ep, ep), j.vadd(tp, tp);
          const he = $d.distanceTo(R);
          !(ag.pointInTriangle($d, jh, ep, tp) || ag.pointInTriangle($d, ep, jh, tp)) || he > x || this.reportIntersection(u, $d, o, i, T);
        }
      }
    }
  }
  /**
   * @todo Optimize by transforming the world to local space first.
   * @todo Use Octree lookup
   */
  _intersectTrimesh(e, t, n, i, o, l) {
    const u = xne, I = Xne, C = Yne, f = a_, v = Wne, b = Vne, S = Nne, R = Hne, W = Mne, x = e.indices;
    e.vertices;
    const N = this.from, Y = this.to, F = this.direction;
    C.position.copy(n), C.quaternion.copy(t), iI.vectorToLocalFrame(n, t, F, v), iI.pointToLocalFrame(n, t, N, b), iI.pointToLocalFrame(n, t, Y, S), S.x *= e.scale.x, S.y *= e.scale.y, S.z *= e.scale.z, b.x *= e.scale.x, b.y *= e.scale.y, b.z *= e.scale.z, S.vsub(b, v), v.normalize();
    const T = b.distanceSquared(S);
    e.tree.rayQuery(this, C, I);
    for (let P = 0, D = I.length; !this.result.shouldStop && P !== D; P++) {
      const L = I[P];
      e.getNormal(L, u), e.getVertex(x[L * 3], jh), jh.vsub(b, f);
      const j = v.dot(u), J = u.dot(f) / j;
      if (J < 0)
        continue;
      v.scale(J, $d), $d.vadd(b, $d), e.getVertex(x[L * 3 + 1], ep), e.getVertex(x[L * 3 + 2], tp);
      const O = $d.distanceSquared(b);
      !(ag.pointInTriangle($d, ep, jh, tp) || ag.pointInTriangle($d, jh, ep, tp)) || O > T || (iI.vectorToWorldFrame(t, u, W), iI.pointToWorldFrame(n, t, $d, R), this.reportIntersection(W, R, o, i, L));
    }
    I.length = 0;
  }
  /**
   * @return True if the intersections should continue
   */
  reportIntersection(e, t, n, i, o) {
    const l = this.from, u = this.to, I = l.distanceTo(t), C = this.result;
    if (!(this.skipBackfaces && e.dot(this.direction) > 0))
      switch (C.hitFaceIndex = typeof o < "u" ? o : -1, this.mode) {
        case ag.ALL:
          this.hasHit = !0, C.set(l, u, e, t, n, i, I), C.hasHit = !0, this.callback(C);
          break;
        case ag.CLOSEST:
          (I < C.distance || !C.hasHit) && (this.hasHit = !0, C.hasHit = !0, C.set(l, u, e, t, n, i, I));
          break;
        case ag.ANY:
          this.hasHit = !0, C.hasHit = !0, C.set(l, u, e, t, n, i, I), C.shouldStop = !0;
          break;
      }
  }
  /**
   * As per "Barycentric Technique" as named
   * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
   */
  static pointInTriangle(e, t, n, i) {
    i.vsub(t, sb), n.vsub(t, TZ), e.vsub(t, yH);
    const o = sb.dot(sb), l = sb.dot(TZ), u = sb.dot(yH), I = TZ.dot(TZ), C = TZ.dot(yH);
    let f, v;
    return (f = I * u - l * C) >= 0 && (v = o * C - l * u) >= 0 && f + v < o * I - l * l;
  }
}
ag.CLOSEST = UY.CLOSEST;
ag.ANY = UY.ANY;
ag.ALL = UY.ALL;
const i_ = new eh(), vH = [], TZ = new Ge(), yH = new Ge(), bne = new Ge(), Gne = new jg(), $d = new Ge(), jh = new Ge(), ep = new Ge(), tp = new Ge();
new Ge();
new lX();
const r_ = {
  faceList: [0]
}, n2 = new Ge(), Bne = new ag(), Sne = [], Zne = new Ge(), wne = new Ge(), Rne = new Ge();
new Ge();
new Ge();
const a_ = new Ge(), xne = new Ge(), Wne = new Ge(), Vne = new Ge(), Nne = new Ge(), Mne = new Ge(), Hne = new Ge();
new eh();
const Xne = [], Yne = new iI(), sb = new Ge(), i2 = new Ge();
function Fne(r, e, t) {
  t.vsub(r, sb);
  const n = sb.dot(e);
  return e.scale(n, i2), i2.vadd(r, i2), t.distanceTo(i2);
}
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new ag();
new Ge();
new Ge();
new Ge();
new Ge(1, 0, 0), new Ge(0, 1, 0), new Ge(0, 0, 1);
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new eh();
new Ge();
new eh();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new eh();
new Ge();
new iI();
new eh();
Gi.types.SPHERE, Gi.types.SPHERE | Gi.types.PLANE, Gi.types.BOX | Gi.types.BOX, Gi.types.SPHERE | Gi.types.BOX, Gi.types.PLANE | Gi.types.BOX, Gi.types.CONVEXPOLYHEDRON, Gi.types.SPHERE | Gi.types.CONVEXPOLYHEDRON, Gi.types.PLANE | Gi.types.CONVEXPOLYHEDRON, Gi.types.BOX | Gi.types.CONVEXPOLYHEDRON, Gi.types.SPHERE | Gi.types.HEIGHTFIELD, Gi.types.BOX | Gi.types.HEIGHTFIELD, Gi.types.CONVEXPOLYHEDRON | Gi.types.HEIGHTFIELD, Gi.types.PARTICLE | Gi.types.SPHERE, Gi.types.PLANE | Gi.types.PARTICLE, Gi.types.BOX | Gi.types.PARTICLE, Gi.types.PARTICLE | Gi.types.CONVEXPOLYHEDRON, Gi.types.CYLINDER, Gi.types.SPHERE | Gi.types.CYLINDER, Gi.types.PLANE | Gi.types.CYLINDER, Gi.types.BOX | Gi.types.CYLINDER, Gi.types.CONVEXPOLYHEDRON | Gi.types.CYLINDER, Gi.types.HEIGHTFIELD | Gi.types.CYLINDER, Gi.types.PARTICLE | Gi.types.CYLINDER, Gi.types.SPHERE | Gi.types.TRIMESH, Gi.types.PLANE | Gi.types.TRIMESH;
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new jg();
new jg();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new eh();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge(), new Ge(), new Ge(), new Ge(), new Ge(), new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new jg();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new Ge();
new eh();
new ag();
const _Z = globalThis.performance || {};
if (!_Z.now) {
  let r = Date.now();
  _Z.timing && _Z.timing.navigationStart && (r = _Z.timing.navigationStart), _Z.now = () => Date.now() - r;
}
new Ge();
const Ene = /* @__PURE__ */ ye.createContext(null), Tne = () => ye.useContext(Ene), V9 = /* @__PURE__ */ ye.createContext(null), _ne = () => {
  const r = ye.useContext(V9);
  if (!r) throw new Error("Physics context not found. @react-three/cannon & components can only be used within a Physics provider");
  return r;
};
new fe(1, 1, 1);
new fe();
new _i();
const o_ = new qr();
function zne(r) {
  const e = ye.useRef(null);
  return r && typeof r != "function" ? r : e;
}
function s_(r) {
  return r.charAt(0).toUpperCase() + r.slice(1);
}
function Zc(r, e) {
  const t = e === void 0 ? "" : `/${e}`;
  return typeof r == "function" ? null : r && r.current && `${r.current.uuid}${t}`;
}
const Kne = new uI(), Lne = new ku(), kne = (r) => (e) => r(Kne.setFromQuaternion(Lne.fromArray(e)).toArray());
let N9 = 0;
function bH(r, e, t, n, i, o) {
  return o === void 0 && (o = "bodies"), (l) => {
    const u = N9++;
    t[u] = {
      [n]: l
    };
    const I = Zc(r, i);
    return I && e.subscribe({
      props: {
        id: u,
        target: o,
        type: n
      },
      uuid: I
    }), () => {
      delete t[u], e.unsubscribe({
        props: u
      });
    };
  };
}
function l_(r, e) {
  let {
    position: t = [0, 0, 0],
    rotation: n = [0, 0, 0],
    userData: i = {}
  } = e;
  r.userData = i, r.position.set(...t), r.rotation.set(...n), r.updateMatrix();
}
function u_(r, e, t) {
  let {
    onCollide: n,
    onCollideBegin: i,
    onCollideEnd: o
  } = e;
  r[t] = {
    collide: n,
    collideBegin: i,
    collideEnd: o
  };
}
function M9(r, e, t, n, i) {
  n === void 0 && (n = null), i === void 0 && (i = []);
  const o = zne(n), {
    events: l,
    refs: u,
    scaleOverrides: I,
    subscriptions: C,
    worker: f
  } = _ne(), v = Tne();
  ye.useLayoutEffect(() => {
    o.current || (o.current = new qr());
    const S = o.current, R = f, W = S instanceof lB ? (S.instanceMatrix.setUsage(HK), S.count) : 1, x = S instanceof lB ? new Array(W).fill(0).map((Y, F) => `${S.uuid}/${F}`) : [S.uuid], N = S instanceof lB ? x.map((Y, F) => {
      const T = e(F);
      return l_(o_, T), S.setMatrixAt(F, o_.matrix), S.instanceMatrix.needsUpdate = !0, u[Y] = S, v?.add(Y, T, r), u_(l, T, Y), {
        ...T,
        args: t(T.args)
      };
    }) : x.map((Y, F) => {
      const T = e(F);
      return l_(S, T), u[Y] = S, v?.add(Y, T, r), u_(l, T, Y), {
        ...T,
        args: t(T.args)
      };
    });
    return R.addBodies({
      props: N.map((Y) => {
        let {
          onCollide: F,
          onCollideBegin: T,
          onCollideEnd: P,
          ...D
        } = Y;
        return {
          onCollide: !!F,
          ...D
        };
      }),
      type: r,
      uuid: x
    }), () => {
      x.forEach((Y) => {
        delete u[Y], v?.remove(Y), delete l[Y];
      }), R.removeBodies({
        uuid: x
      });
    };
  }, i);
  const b = ye.useMemo(() => {
    const S = (F, T) => {
      const P = `set${s_(F)}`;
      return {
        set: (D) => {
          const L = Zc(o, T);
          L && f[P]({
            props: D,
            uuid: L
          });
        },
        subscribe: bH(o, f, C, F, T)
      };
    }, R = (F) => ({
      copy: (P) => {
        let {
          w: D,
          x: L,
          y: j,
          z: J
        } = P;
        const O = Zc(o, F);
        O && f.setQuaternion({
          props: [L, j, J, D],
          uuid: O
        });
      },
      set: (P, D, L, j) => {
        const J = Zc(o, F);
        J && f.setQuaternion({
          props: [P, D, L, j],
          uuid: J
        });
      },
      subscribe: bH(o, f, C, "quaternion", F)
    }), W = (F) => ({
      copy: (T) => {
        let {
          x: P,
          y: D,
          z: L
        } = T;
        const j = Zc(o, F);
        j && f.setRotation({
          props: [P, D, L],
          uuid: j
        });
      },
      set: (T, P, D) => {
        const L = Zc(o, F);
        L && f.setRotation({
          props: [T, P, D],
          uuid: L
        });
      },
      subscribe: (T) => {
        const P = N9++, D = "bodies", L = "quaternion", j = Zc(o, F);
        return C[P] = {
          [L]: kne(T)
        }, j && f.subscribe({
          props: {
            id: P,
            target: D,
            type: L
          },
          uuid: j
        }), () => {
          delete C[P], f.unsubscribe({
            props: P
          });
        };
      }
    }), x = (F, T) => {
      const P = `set${s_(F)}`;
      return {
        copy: (D) => {
          let {
            x: L,
            y: j,
            z: J
          } = D;
          const O = Zc(o, T);
          O && f[P]({
            props: [L, j, J],
            uuid: O
          });
        },
        set: (D, L, j) => {
          const J = Zc(o, T);
          J && f[P]({
            props: [D, L, j],
            uuid: J
          });
        },
        subscribe: bH(o, f, C, F, T)
      };
    };
    function N(F) {
      return {
        allowSleep: S("allowSleep", F),
        angularDamping: S("angularDamping", F),
        angularFactor: x("angularFactor", F),
        angularVelocity: x("angularVelocity", F),
        applyForce(T, P) {
          const D = Zc(o, F);
          D && f.applyForce({
            props: [T, P],
            uuid: D
          });
        },
        applyImpulse(T, P) {
          const D = Zc(o, F);
          D && f.applyImpulse({
            props: [T, P],
            uuid: D
          });
        },
        applyLocalForce(T, P) {
          const D = Zc(o, F);
          D && f.applyLocalForce({
            props: [T, P],
            uuid: D
          });
        },
        applyLocalImpulse(T, P) {
          const D = Zc(o, F);
          D && f.applyLocalImpulse({
            props: [T, P],
            uuid: D
          });
        },
        applyTorque(T) {
          const P = Zc(o, F);
          P && f.applyTorque({
            props: [T],
            uuid: P
          });
        },
        collisionFilterGroup: S("collisionFilterGroup", F),
        collisionFilterMask: S("collisionFilterMask", F),
        collisionResponse: S("collisionResponse", F),
        fixedRotation: S("fixedRotation", F),
        isTrigger: S("isTrigger", F),
        linearDamping: S("linearDamping", F),
        linearFactor: x("linearFactor", F),
        mass: S("mass", F),
        material: S("material", F),
        position: x("position", F),
        quaternion: R(F),
        rotation: W(F),
        scaleOverride(T) {
          const P = Zc(o, F);
          P && (I[P] = new fe(...T));
        },
        sleep() {
          const T = Zc(o, F);
          T && f.sleep({
            uuid: T
          });
        },
        sleepSpeedLimit: S("sleepSpeedLimit", F),
        sleepTimeLimit: S("sleepTimeLimit", F),
        userData: S("userData", F),
        velocity: x("velocity", F),
        wakeUp() {
          const T = Zc(o, F);
          T && f.wakeUp({
            uuid: T
          });
        }
      };
    }
    const Y = {};
    return {
      ...N(void 0),
      at: (F) => Y[F] || (Y[F] = N(F))
    };
  }, []);
  return [o, b];
}
function H9(r, e, t) {
  return M9("Plane", r, () => [], e, t);
}
function Dne(r, e, t) {
  const n = [1, 1, 1];
  return M9("Box", r, function(i) {
    return i === void 0 && (i = n), i;
  }, e, t);
}
const Une = new fe(), One = new fe(1, 1, 1), Pne = new ku(), r2 = new _i();
function c_(r, e, t, n, i) {
  return n === void 0 && (n = One), r !== void 0 ? (r2.compose(Une.fromArray(e, r * 3), Pne.fromArray(t, r * 4), n), i && (i.matrixAutoUpdate = !1, i.matrix.copy(r2)), r2) : r2.identity();
}
const Jne = () => {
  const r = [];
  return (e) => r.includes(e) ? !1 : !!r.push(e);
};
function Qne(r) {
  let {
    allowSleep: e = !1,
    axisIndex: t = 0,
    broadphase: n = "Naive",
    children: i,
    defaultContactMaterial: o = {
      contactEquationStiffness: 1e6
    },
    frictionGravity: l = null,
    gravity: u = [0, -9.81, 0],
    isPaused: I = !1,
    iterations: C = 5,
    maxSubSteps: f = 10,
    quatNormalizeFast: v = !1,
    quatNormalizeSkip: b = 0,
    shouldInvalidate: S = !0,
    size: R = 1e3,
    solver: W = "GS",
    stepSize: x = 1 / 60,
    tolerance: N = 1e-3
  } = r;
  const {
    invalidate: Y
  } = Jg(), [{
    bodies: F,
    events: T,
    refs: P,
    scaleOverrides: D,
    subscriptions: L,
    worker: j
  }] = ye.useState(() => ({
    bodies: {},
    events: {},
    refs: {},
    scaleOverrides: {},
    subscriptions: {},
    worker: new Ote({
      allowSleep: e,
      axisIndex: t,
      broadphase: n,
      defaultContactMaterial: o,
      frictionGravity: l,
      gravity: u,
      iterations: C,
      quatNormalizeFast: v,
      quatNormalizeSkip: b,
      size: R,
      solver: W,
      tolerance: N
    })
  }));
  let J = 0;
  const O = ye.useCallback((Xe, re) => {
    I || (J += re, j.step({
      maxSubSteps: f,
      stepSize: x,
      timeSinceLastCalled: J
    }), J = 0);
  }, [I, f, x]), ne = (Xe) => {
    var re;
    let {
      body: Se,
      contact: {
        bi: Be,
        bj: le,
        ...Ye
      },
      target: nt,
      ...ze
    } = Xe;
    const Je = (re = T[nt]) == null ? void 0 : re.collide;
    Je && Je({
      body: P[Se],
      contact: {
        bi: P[Be],
        bj: P[le],
        ...Ye
      },
      target: P[nt],
      ...ze
    });
  }, he = (Xe) => {
    var re, Se;
    let {
      bodyA: Be,
      bodyB: le
    } = Xe;
    const Ye = (re = T[Be]) == null ? void 0 : re.collideBegin;
    Ye && Ye({
      body: P[le],
      op: "event",
      target: P[Be],
      type: "collideBegin"
    });
    const nt = (Se = T[le]) == null ? void 0 : Se.collideBegin;
    nt && nt({
      body: P[Be],
      op: "event",
      target: P[le],
      type: "collideBegin"
    });
  }, pe = (Xe) => {
    var re, Se;
    let {
      bodyA: Be,
      bodyB: le
    } = Xe;
    const Ye = (re = T[Be]) == null ? void 0 : re.collideEnd;
    Ye && Ye({
      body: P[le],
      op: "event",
      target: P[Be],
      type: "collideEnd"
    });
    const nt = (Se = T[le]) == null ? void 0 : Se.collideEnd;
    nt && nt({
      body: P[Be],
      op: "event",
      target: P[le],
      type: "collideEnd"
    });
  }, Ae = (Xe) => {
    let {
      active: re,
      bodies: Se = [],
      observations: Be,
      positions: le,
      quaternions: Ye
    } = Xe;
    for (let nt = 0; nt < Se.length; nt++)
      F[Se[nt]] = nt;
    if (Be.forEach((nt) => {
      let [ze, Je, wt] = nt;
      const Dt = (L[ze] || {})[wt];
      Dt && Dt(Je);
    }), !!re) {
      for (const nt of Object.values(P).filter(Jne()))
        if (nt instanceof lB)
          for (let ze = 0; ze < nt.count; ze++) {
            const Je = `${nt.uuid}/${ze}`, wt = F[Je];
            wt !== void 0 && (nt.setMatrixAt(ze, c_(wt, le, Ye, D[Je])), nt.instanceMatrix.needsUpdate = !0);
          }
        else {
          const ze = D[nt.uuid] || nt.scale;
          c_(F[nt.uuid], le, Ye, ze, nt);
        }
      S && Y();
    }
  }, ke = (Xe) => {
    var re;
    let {
      body: Se,
      ray: {
        uuid: Be,
        ...le
      },
      ...Ye
    } = Xe;
    const nt = (re = T[Be]) == null ? void 0 : re.rayhit;
    nt && nt({
      body: Se ? P[Se] : null,
      ray: {
        uuid: Be,
        ...le
      },
      ...Ye
    });
  };
  cV(O), ye.useEffect(() => (j.connect(), j.init(), j.on("collide", ne), j.on("collideBegin", he), j.on("collideEnd", pe), j.on("frame", Ae), j.on("rayhit", ke), () => {
    j.terminate(), j.removeAllListeners();
  }), []), ye.useEffect(() => {
    j.axisIndex = t;
  }, [t]), ye.useEffect(() => {
    j.broadphase = n;
  }, [n]), ye.useEffect(() => {
    j.gravity = u;
  }, [u]), ye.useEffect(() => {
    j.iterations = C;
  }, [C]), ye.useEffect(() => {
    j.tolerance = N;
  }, [N]);
  const Re = ye.useMemo(() => ({
    bodies: F,
    events: T,
    refs: P,
    scaleOverrides: D,
    subscriptions: L,
    worker: j
  }), [F, T, P, L, j]);
  return /* @__PURE__ */ We.jsx(V9.Provider, {
    value: Re,
    children: i
  });
}
const X9 = {
  [id.DEFAULT]: "#22303c",
  [id.DARK]: "#0e0d0c",
  [id.LIGHT]: "#a9e5e0"
}, jne = {
  [id.DEFAULT]: "#b26c41",
  [id.DARK]: "#30d5c8",
  [id.LIGHT]: "#588d67"
}, qne = {
  [id.DEFAULT]: "#efcb2d",
  [id.DARK]: "#bac8c6",
  [id.LIGHT]: "#494544"
};
function Fm(r) {
  if (r === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function Y9(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e;
}
/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var JI = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, vB = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, OY, Rc, rs, Ip = 1e8, gg = 1 / Ip, uX = Math.PI * 2, $ne = uX / 4, eie = 0, F9 = Math.sqrt, tie = Math.cos, nie = Math.sin, Du = function(e) {
  return typeof e == "string";
}, Ls = function(e) {
  return typeof e == "function";
}, Qm = function(e) {
  return typeof e == "number";
}, PY = function(e) {
  return typeof e > "u";
}, hp = function(e) {
  return typeof e == "object";
}, rI = function(e) {
  return e !== !1;
}, JY = function() {
  return typeof window < "u";
}, a2 = function(e) {
  return Ls(e) || Du(e);
}, E9 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, Ig = Array.isArray, cX = /(?:-?\.?\d|\.)+/gi, T9 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, rB = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, GH = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _9 = /[+-]=-?[.\d]+/, z9 = /[^,'"\[\]\s]+/gi, iie = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, As, np, gX, QY, QI = {}, aW = {}, K9, L9 = function(e) {
  return (aW = yB(e, QI)) && cI;
}, jY = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, _w = function(e, t) {
  return !t && console.warn(e);
}, k9 = function(e, t) {
  return e && (QI[e] = t) && aW && (aW[e] = t) || QI;
}, zw = function() {
  return 0;
}, rie = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, h2 = {
  suppressEvents: !0,
  kill: !1
}, aie = {
  suppressEvents: !0
}, qY = {}, mv = [], dX = {}, D9, kI = {}, BH = {}, g_ = 30, f2 = [], $Y = "", eF = function(e) {
  var t = e[0], n, i;
  if (hp(t) || Ls(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
    for (i = f2.length; i-- && !f2[i].targetTest(t); )
      ;
    n = f2[i];
  }
  for (i = e.length; i--; )
    e[i] && (e[i]._gsap || (e[i]._gsap = new hk(e[i], n))) || e.splice(i, 1);
  return e;
}, Ab = function(e) {
  return e._gsap || eF(JC(e))[0]._gsap;
}, U9 = function(e, t, n) {
  return (n = e[t]) && Ls(n) ? e[t]() : PY(n) && e.getAttribute && e.getAttribute(t) || n;
}, aI = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, Cl = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, Ll = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, cB = function(e, t) {
  var n = t.charAt(0), i = parseFloat(t.substr(2));
  return e = parseFloat(e), n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i;
}, oie = function(e, t) {
  for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; )
    ;
  return i < n;
}, oW = function() {
  var e = mv.length, t = mv.slice(0), n, i;
  for (dX = {}, mv.length = 0, n = 0; n < e; n++)
    i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
}, O9 = function(e, t, n, i) {
  mv.length && !Rc && oW(), e.render(t, n, Rc && t < 0 && (e._initted || e._startAt)), mv.length && !Rc && oW();
}, P9 = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(z9).length < 2 ? t : Du(e) ? e.trim() : e;
}, J9 = function(e) {
  return e;
}, jI = function(e, t) {
  for (var n in t)
    n in e || (e[n] = t[n]);
  return e;
}, sie = function(e) {
  return function(t, n) {
    for (var i in n)
      i in t || i === "duration" && e || i === "ease" || (t[i] = n[i]);
  };
}, yB = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, d_ = function r(e, t) {
  for (var n in t)
    n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = hp(t[n]) ? r(e[n] || (e[n] = {}), t[n]) : t[n]);
  return e;
}, sW = function(e, t) {
  var n = {}, i;
  for (i in e)
    i in t || (n[i] = e[i]);
  return n;
}, sw = function(e) {
  var t = e.parent || As, n = e.keyframes ? sie(Ig(e.keyframes)) : jI;
  if (rI(e.inherit))
    for (; t; )
      n(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, lie = function(e, t) {
  for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; )
    ;
  return n < 0;
}, Q9 = function(e, t, n, i, o) {
  var l = e[i], u;
  if (o)
    for (u = t[o]; l && l[o] > u; )
      l = l._prev;
  return l ? (t._next = l._next, l._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = l, t.parent = t._dp = e, t;
}, dV = function(e, t, n, i) {
  n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
  var o = t._prev, l = t._next;
  o ? o._next = l : e[n] === t && (e[n] = l), l ? l._prev = o : e[i] === t && (e[i] = o), t._next = t._prev = t.parent = null;
}, Bv = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, vb = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0))
    for (var n = e; n; )
      n._dirty = 1, n = n.parent;
  return e;
}, uie = function(e) {
  for (var t = e.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, IX = function(e, t, n, i) {
  return e._startAt && (Rc ? e._startAt.revert(h2) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i));
}, cie = function r(e) {
  return !e || e._ts && r(e.parent);
}, I_ = function(e) {
  return e._repeat ? bB(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, bB = function(e, t) {
  var n = Math.floor(e = Ll(e / t));
  return e && n === e ? n - 1 : n;
}, lW = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, IV = function(e) {
  return e._end = Ll(e._start + (e._tDur / Math.abs(e._ts || e._rts || gg) || 0));
}, CV = function(e, t) {
  var n = e._dp;
  return n && n.smoothChildTiming && e._ts && (e._start = Ll(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), IV(e), n._dirty || vb(n, e)), e;
}, j9 = function(e, t) {
  var n;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = lW(e.rawTime(), t), (!t._dur || lR(0, t.totalDuration(), n) - t._tTime > gg) && t.render(n, !0)), vb(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration())
      for (n = e; n._dp; )
        n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
    e._zTime = -1e-8;
  }
}, rp = function(e, t, n, i) {
  return t.parent && Bv(t), t._start = Ll((Qm(n) ? n : n || e !== As ? UC(e, n, t) : e._time) + t._delay), t._end = Ll(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), Q9(e, t, "_first", "_last", e._sort ? "_start" : 0), CX(t) || (e._recent = t), i || j9(e, t), e._ts < 0 && CV(e, e._tTime), e;
}, q9 = function(e, t) {
  return (QI.ScrollTrigger || jY("scrollTrigger", t)) && QI.ScrollTrigger.create(t, e);
}, $9 = function(e, t, n, i, o) {
  if (nF(e, t, o), !e._initted)
    return 1;
  if (!n && e._pt && !Rc && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && D9 !== UI.frame)
    return mv.push(e), e._lazy = [o, i], 1;
}, gie = function r(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t));
}, CX = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, die = function(e, t, n, i) {
  var o = e.ratio, l = t < 0 || !t && (!e._start && gie(e) && !(!e._initted && CX(e)) || (e._ts < 0 || e._dp._ts < 0) && !CX(e)) ? 0 : 1, u = e._rDelay, I = 0, C, f, v;
  if (u && e._repeat && (I = lR(0, e._tDur, t), f = bB(I, u), e._yoyo && f & 1 && (l = 1 - l), f !== bB(e._tTime, u) && (o = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== o || Rc || i || e._zTime === gg || !t && e._zTime) {
    if (!e._initted && $9(e, t, i, n, I))
      return;
    for (v = e._zTime, e._zTime = t || (n ? gg : 0), n || (n = t && !v), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = I, C = e._pt; C; )
      C.r(l, C.d), C = C._next;
    t < 0 && IX(e, t, n, !0), e._onUpdate && !n && OI(e, "onUpdate"), I && e._repeat && !n && e.parent && OI(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && Bv(e, 1), !n && !Rc && (OI(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, Iie = function(e, t, n) {
  var i;
  if (n > t)
    for (i = e._first; i && i._start <= n; ) {
      if (i.data === "isPause" && i._start > t)
        return i;
      i = i._next;
    }
  else
    for (i = e._last; i && i._start >= n; ) {
      if (i.data === "isPause" && i._start < t)
        return i;
      i = i._prev;
    }
}, GB = function(e, t, n, i) {
  var o = e._repeat, l = Ll(t) || 0, u = e._tTime / e._tDur;
  return u && !i && (e._time *= l / e._dur), e._dur = l, e._tDur = o ? o < 0 ? 1e10 : Ll(l * (o + 1) + e._rDelay * o) : l, u > 0 && !i && CV(e, e._tTime = e._tDur * u), e.parent && IV(e), n || vb(e.parent, e), e;
}, C_ = function(e) {
  return e instanceof $g ? vb(e) : GB(e, e._dur);
}, Cie = {
  _start: 0,
  endTime: zw,
  totalDuration: zw
}, UC = function r(e, t, n) {
  var i = e.labels, o = e._recent || Cie, l = e.duration() >= Ip ? o.endTime(!1) : e._dur, u, I, C;
  return Du(t) && (isNaN(t) || t in i) ? (I = t.charAt(0), C = t.substr(-1) === "%", u = t.indexOf("="), I === "<" || I === ">" ? (u >= 0 && (t = t.replace(/=/, "")), (I === "<" ? o._start : o.endTime(o._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (C ? (u < 0 ? o : n).totalDuration() / 100 : 1)) : u < 0 ? (t in i || (i[t] = l), i[t]) : (I = parseFloat(t.charAt(u - 1) + t.substr(u + 1)), C && n && (I = I / 100 * (Ig(n) ? n[0] : n).totalDuration()), u > 1 ? r(e, t.substr(0, u - 1), n) + I : l + I)) : t == null ? l : +t;
}, lw = function(e, t, n) {
  var i = Qm(t[1]), o = (i ? 2 : 1) + (e < 2 ? 0 : 1), l = t[o], u, I;
  if (i && (l.duration = t[1]), l.parent = n, e) {
    for (u = l, I = n; I && !("immediateRender" in u); )
      u = I.vars.defaults || {}, I = rI(I.vars.inherit) && I.parent;
    l.immediateRender = rI(u.immediateRender), e < 2 ? l.runBackwards = 1 : l.startAt = t[o - 1];
  }
  return new Kl(t[0], l, t[o + 1]);
}, Wv = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, lR = function(e, t, n) {
  return n < e ? e : n > t ? t : n;
}, ug = function(e, t) {
  return !Du(e) || !(t = iie.exec(e)) ? "" : t[1];
}, hie = function(e, t, n) {
  return Wv(n, function(i) {
    return lR(e, t, i);
  });
}, hX = [].slice, ek = function(e, t) {
  return e && hp(e) && "length" in e && (!t && !e.length || e.length - 1 in e && hp(e[0])) && !e.nodeType && e !== np;
}, fie = function(e, t, n) {
  return n === void 0 && (n = []), e.forEach(function(i) {
    var o;
    return Du(i) && !t || ek(i, 1) ? (o = n).push.apply(o, JC(i)) : n.push(i);
  }) || n;
}, JC = function(e, t, n) {
  return rs && !t && rs.selector ? rs.selector(e) : Du(e) && !n && (gX || !BB()) ? hX.call((t || QY).querySelectorAll(e), 0) : Ig(e) ? fie(e, n) : ek(e) ? hX.call(e, 0) : e ? [e] : [];
}, fX = function(e) {
  return e = JC(e)[0] || _w("Invalid scope") || {}, function(t) {
    var n = e.current || e.nativeElement || e;
    return JC(t, n.querySelectorAll ? n : n === e ? _w("Invalid scope") || QY.createElement("div") : e);
  };
}, tk = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, nk = function(e) {
  if (Ls(e))
    return e;
  var t = hp(e) ? e : {
    each: e
  }, n = yb(t.ease), i = t.from || 0, o = parseFloat(t.base) || 0, l = {}, u = i > 0 && i < 1, I = isNaN(i) || u, C = t.axis, f = i, v = i;
  return Du(i) ? f = v = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[i] || 0 : !u && I && (f = i[0], v = i[1]), function(b, S, R) {
    var W = (R || t).length, x = l[W], N, Y, F, T, P, D, L, j, J;
    if (!x) {
      if (J = t.grid === "auto" ? 0 : (t.grid || [1, Ip])[1], !J) {
        for (L = -1e8; L < (L = R[J++].getBoundingClientRect().left) && J < W; )
          ;
        J < W && J--;
      }
      for (x = l[W] = [], N = I ? Math.min(J, W) * f - 0.5 : i % J, Y = J === Ip ? 0 : I ? W * v / J - 0.5 : i / J | 0, L = 0, j = Ip, D = 0; D < W; D++)
        F = D % J - N, T = Y - (D / J | 0), x[D] = P = C ? Math.abs(C === "y" ? T : F) : F9(F * F + T * T), P > L && (L = P), P < j && (j = P);
      i === "random" && tk(x), x.max = L - j, x.min = j, x.v = W = (parseFloat(t.amount) || parseFloat(t.each) * (J > W ? W - 1 : C ? C === "y" ? W / J : J : Math.max(J, W / J)) || 0) * (i === "edges" ? -1 : 1), x.b = W < 0 ? o - W : o, x.u = ug(t.amount || t.each) || 0, n = n && W < 0 ? dk(n) : n;
    }
    return W = (x[b] - x.min) / x.max || 0, Ll(x.b + (n ? n(W) : W) * x.v) + x.u;
  };
}, pX = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(n) {
    var i = Ll(Math.round(parseFloat(n) / e) * e * t);
    return (i - i % 1) / t + (Qm(n) ? 0 : ug(n));
  };
}, ik = function(e, t) {
  var n = Ig(e), i, o;
  return !n && hp(e) && (i = n = e.radius || Ip, e.values ? (e = JC(e.values), (o = !Qm(e[0])) && (i *= i)) : e = pX(e.increment)), Wv(t, n ? Ls(e) ? function(l) {
    return o = e(l), Math.abs(o - l) <= i ? o : l;
  } : function(l) {
    for (var u = parseFloat(o ? l.x : l), I = parseFloat(o ? l.y : 0), C = Ip, f = 0, v = e.length, b, S; v--; )
      o ? (b = e[v].x - u, S = e[v].y - I, b = b * b + S * S) : b = Math.abs(e[v] - u), b < C && (C = b, f = v);
    return f = !i || C <= i ? e[f] : l, o || f === l || Qm(l) ? f : f + ug(l);
  } : pX(e));
}, rk = function(e, t, n, i) {
  return Wv(Ig(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
    return Ig(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) * n * i) / i;
  });
}, pie = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(i) {
    return t.reduce(function(o, l) {
      return l(o);
    }, i);
  };
}, mie = function(e, t) {
  return function(n) {
    return e(parseFloat(n)) + (t || ug(n));
  };
}, Aie = function(e, t, n) {
  return ok(e, t, 0, 1, n);
}, ak = function(e, t, n) {
  return Wv(n, function(i) {
    return e[~~t(i)];
  });
}, vie = function r(e, t, n) {
  var i = t - e;
  return Ig(e) ? ak(e, r(0, e.length), t) : Wv(n, function(o) {
    return (i + (o - e) % i) % i + e;
  });
}, yie = function r(e, t, n) {
  var i = t - e, o = i * 2;
  return Ig(e) ? ak(e, r(0, e.length - 1), t) : Wv(n, function(l) {
    return l = (o + (l - e) % o) % o || 0, e + (l > i ? o - l : l);
  });
}, Kw = function(e) {
  for (var t = 0, n = "", i, o, l, u; ~(i = e.indexOf("random(", t)); )
    l = e.indexOf(")", i), u = e.charAt(i + 7) === "[", o = e.substr(i + 7, l - i - 7).match(u ? z9 : cX), n += e.substr(t, i - t) + rk(u ? o : +o[0], u ? 0 : +o[1], +o[2] || 1e-5), t = l + 1;
  return n + e.substr(t, e.length - t);
}, ok = function(e, t, n, i, o) {
  var l = t - e, u = i - n;
  return Wv(o, function(I) {
    return n + ((I - e) / l * u || 0);
  });
}, bie = function r(e, t, n, i) {
  var o = isNaN(e + t) ? 0 : function(S) {
    return (1 - S) * e + S * t;
  };
  if (!o) {
    var l = Du(e), u = {}, I, C, f, v, b;
    if (n === !0 && (i = 1) && (n = null), l)
      e = {
        p: e
      }, t = {
        p: t
      };
    else if (Ig(e) && !Ig(t)) {
      for (f = [], v = e.length, b = v - 2, C = 1; C < v; C++)
        f.push(r(e[C - 1], e[C]));
      v--, o = function(R) {
        R *= v;
        var W = Math.min(b, ~~R);
        return f[W](R - W);
      }, n = t;
    } else i || (e = yB(Ig(e) ? [] : {}, e));
    if (!f) {
      for (I in t)
        tF.call(u, e, I, "get", t[I]);
      o = function(R) {
        return aF(R, u) || (l ? e.p : e);
      };
    }
  }
  return Wv(n, o);
}, h_ = function(e, t, n) {
  var i = e.labels, o = Ip, l, u, I;
  for (l in i)
    u = i[l] - t, u < 0 == !!n && u && o > (u = Math.abs(u)) && (I = l, o = u);
  return I;
}, OI = function(e, t, n) {
  var i = e.vars, o = i[t], l = rs, u = e._ctx, I, C, f;
  if (o)
    return I = i[t + "Params"], C = i.callbackScope || e, n && mv.length && oW(), u && (rs = u), f = I ? o.apply(C, I) : o.call(C), rs = l, f;
}, PZ = function(e) {
  return Bv(e), e.scrollTrigger && e.scrollTrigger.kill(!!Rc), e.progress() < 1 && OI(e, "onInterrupt"), e;
}, aB, sk = [], lk = function(e) {
  if (e)
    if (e = !e.name && e.default || e, JY() || e.headless) {
      var t = e.name, n = Ls(e), i = t && !n && e.init ? function() {
        this._props = [];
      } : e, o = {
        init: zw,
        render: aF,
        add: tF,
        kill: Eie,
        modifier: Fie,
        rawVars: 0
      }, l = {
        targetTest: 0,
        get: 0,
        getSetter: rF,
        aliases: {},
        register: 0
      };
      if (BB(), e !== i) {
        if (kI[t])
          return;
        jI(i, jI(sW(e, o), l)), yB(i.prototype, yB(o, sW(e, l))), kI[i.prop = t] = i, e.targetTest && (f2.push(i), qY[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      k9(t, i), e.register && e.register(cI, i, oI);
    } else
      sk.push(e);
}, mo = 255, JZ = {
  aqua: [0, mo, mo],
  lime: [0, mo, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, mo],
  navy: [0, 0, 128],
  white: [mo, mo, mo],
  olive: [128, 128, 0],
  yellow: [mo, mo, 0],
  orange: [mo, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [mo, 0, 0],
  pink: [mo, 192, 203],
  cyan: [0, mo, mo],
  transparent: [mo, mo, mo, 0]
}, SH = function(e, t, n) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < 0.5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * mo + 0.5 | 0;
}, uk = function(e, t, n) {
  var i = e ? Qm(e) ? [e >> 16, e >> 8 & mo, e & mo] : 0 : JZ.black, o, l, u, I, C, f, v, b, S, R;
  if (!i) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), JZ[e])
      i = JZ[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (o = e.charAt(1), l = e.charAt(2), u = e.charAt(3), e = "#" + o + o + l + l + u + u + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9)
        return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & mo, i & mo, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & mo, e & mo];
    } else if (e.substr(0, 3) === "hsl") {
      if (i = R = e.match(cX), !t)
        I = +i[0] % 360 / 360, C = +i[1] / 100, f = +i[2] / 100, l = f <= 0.5 ? f * (C + 1) : f + C - f * C, o = f * 2 - l, i.length > 3 && (i[3] *= 1), i[0] = SH(I + 1 / 3, o, l), i[1] = SH(I, o, l), i[2] = SH(I - 1 / 3, o, l);
      else if (~e.indexOf("="))
        return i = e.match(T9), n && i.length < 4 && (i[3] = 1), i;
    } else
      i = e.match(cX) || JZ.transparent;
    i = i.map(Number);
  }
  return t && !R && (o = i[0] / mo, l = i[1] / mo, u = i[2] / mo, v = Math.max(o, l, u), b = Math.min(o, l, u), f = (v + b) / 2, v === b ? I = C = 0 : (S = v - b, C = f > 0.5 ? S / (2 - v - b) : S / (v + b), I = v === o ? (l - u) / S + (l < u ? 6 : 0) : v === l ? (u - o) / S + 2 : (o - l) / S + 4, I *= 60), i[0] = ~~(I + 0.5), i[1] = ~~(C * 100 + 0.5), i[2] = ~~(f * 100 + 0.5)), n && i.length < 4 && (i[3] = 1), i;
}, ck = function(e) {
  var t = [], n = [], i = -1;
  return e.split(Av).forEach(function(o) {
    var l = o.match(rB) || [];
    t.push.apply(t, l), n.push(i += l.length + 1);
  }), t.c = n, t;
}, f_ = function(e, t, n) {
  var i = "", o = (e + i).match(Av), l = t ? "hsla(" : "rgba(", u = 0, I, C, f, v;
  if (!o)
    return e;
  if (o = o.map(function(b) {
    return (b = uk(b, t, 1)) && l + (t ? b[0] + "," + b[1] + "%," + b[2] + "%," + b[3] : b.join(",")) + ")";
  }), n && (f = ck(e), I = n.c, I.join(i) !== f.c.join(i)))
    for (C = e.replace(Av, "1").split(rB), v = C.length - 1; u < v; u++)
      i += C[u] + (~I.indexOf(u) ? o.shift() || l + "0,0,0,0)" : (f.length ? f : o.length ? o : n).shift());
  if (!C)
    for (C = e.split(Av), v = C.length - 1; u < v; u++)
      i += C[u] + o[u];
  return i + C[v];
}, Av = function() {
  var r = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in JZ)
    r += "|" + e + "\\b";
  return new RegExp(r + ")", "gi");
}(), Gie = /hsl[a]?\(/, gk = function(e) {
  var t = e.join(" "), n;
  if (Av.lastIndex = 0, Av.test(t))
    return n = Gie.test(t), e[1] = f_(e[1], n), e[0] = f_(e[0], n, ck(e[1])), !0;
}, Lw, UI = function() {
  var r = Date.now, e = 500, t = 33, n = r(), i = n, o = 1e3 / 240, l = o, u = [], I, C, f, v, b, S, R = function W(x) {
    var N = r() - i, Y = x === !0, F, T, P, D;
    if ((N > e || N < 0) && (n += N - t), i += N, P = i - n, F = P - l, (F > 0 || Y) && (D = ++v.frame, b = P - v.time * 1e3, v.time = P = P / 1e3, l += F + (F >= o ? 4 : o - F), T = 1), Y || (I = C(W)), T)
      for (S = 0; S < u.length; S++)
        u[S](P, b, D, x);
  };
  return v = {
    time: 0,
    frame: 0,
    tick: function() {
      R(!0);
    },
    deltaRatio: function(x) {
      return b / (1e3 / (x || 60));
    },
    wake: function() {
      K9 && (!gX && JY() && (np = gX = window, QY = np.document || {}, QI.gsap = cI, (np.gsapVersions || (np.gsapVersions = [])).push(cI.version), L9(aW || np.GreenSockGlobals || !np.gsap && np || {}), sk.forEach(lk)), f = typeof requestAnimationFrame < "u" && requestAnimationFrame, I && v.sleep(), C = f || function(x) {
        return setTimeout(x, l - v.time * 1e3 + 1 | 0);
      }, Lw = 1, R(2));
    },
    sleep: function() {
      (f ? cancelAnimationFrame : clearTimeout)(I), Lw = 0, C = zw;
    },
    lagSmoothing: function(x, N) {
      e = x || 1 / 0, t = Math.min(N || 33, e);
    },
    fps: function(x) {
      o = 1e3 / (x || 240), l = v.time * 1e3 + o;
    },
    add: function(x, N, Y) {
      var F = N ? function(T, P, D, L) {
        x(T, P, D, L), v.remove(F);
      } : x;
      return v.remove(x), u[Y ? "unshift" : "push"](F), BB(), F;
    },
    remove: function(x, N) {
      ~(N = u.indexOf(x)) && u.splice(N, 1) && S >= N && S--;
    },
    _listeners: u
  }, v;
}(), BB = function() {
  return !Lw && UI.wake();
}, jr = {}, Bie = /^[\d.\-M][\d.\-,\s]/, Sie = /["']/g, Zie = function(e) {
  for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], o = 1, l = n.length, u, I, C; o < l; o++)
    I = n[o], u = o !== l - 1 ? I.lastIndexOf(",") : I.length, C = I.substr(0, u), t[i] = isNaN(C) ? C.replace(Sie, "").trim() : +C, i = I.substr(u + 1).trim();
  return t;
}, wie = function(e) {
  var t = e.indexOf("(") + 1, n = e.indexOf(")"), i = e.indexOf("(", t);
  return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
}, Rie = function(e) {
  var t = (e + "").split("("), n = jr[t[0]];
  return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [Zie(t[1])] : wie(e).split(",").map(P9)) : jr._CE && Bie.test(e) ? jr._CE("", e) : n;
}, dk = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, Ik = function r(e, t) {
  for (var n = e._first, i; n; )
    n instanceof $g ? r(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? r(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next;
}, yb = function(e, t) {
  return e && (Ls(e) ? e : jr[e] || Rie(e)) || t;
}, Fb = function(e, t, n, i) {
  n === void 0 && (n = function(I) {
    return 1 - t(1 - I);
  }), i === void 0 && (i = function(I) {
    return I < 0.5 ? t(I * 2) / 2 : 1 - t((1 - I) * 2) / 2;
  });
  var o = {
    easeIn: t,
    easeOut: n,
    easeInOut: i
  }, l;
  return aI(e, function(u) {
    jr[u] = QI[u] = o, jr[l = u.toLowerCase()] = n;
    for (var I in o)
      jr[l + (I === "easeIn" ? ".in" : I === "easeOut" ? ".out" : ".inOut")] = jr[u + "." + I] = o[I];
  }), o;
}, Ck = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, ZH = function r(e, t, n) {
  var i = t >= 1 ? t : 1, o = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), l = o / uX * (Math.asin(1 / i) || 0), u = function(f) {
    return f === 1 ? 1 : i * Math.pow(2, -10 * f) * nie((f - l) * o) + 1;
  }, I = e === "out" ? u : e === "in" ? function(C) {
    return 1 - u(1 - C);
  } : Ck(u);
  return o = uX / o, I.config = function(C, f) {
    return r(e, C, f);
  }, I;
}, wH = function r(e, t) {
  t === void 0 && (t = 1.70158);
  var n = function(l) {
    return l ? --l * l * ((t + 1) * l + t) + 1 : 0;
  }, i = e === "out" ? n : e === "in" ? function(o) {
    return 1 - n(1 - o);
  } : Ck(n);
  return i.config = function(o) {
    return r(e, o);
  }, i;
};
aI("Linear,Quad,Cubic,Quart,Quint,Strong", function(r, e) {
  var t = e < 5 ? e + 1 : e;
  Fb(r + ",Power" + (t - 1), e ? function(n) {
    return Math.pow(n, t);
  } : function(n) {
    return n;
  }, function(n) {
    return 1 - Math.pow(1 - n, t);
  }, function(n) {
    return n < 0.5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2;
  });
});
jr.Linear.easeNone = jr.none = jr.Linear.easeIn;
Fb("Elastic", ZH("in"), ZH("out"), ZH());
(function(r, e) {
  var t = 1 / e, n = 2 * t, i = 2.5 * t, o = function(u) {
    return u < t ? r * u * u : u < n ? r * Math.pow(u - 1.5 / e, 2) + 0.75 : u < i ? r * (u -= 2.25 / e) * u + 0.9375 : r * Math.pow(u - 2.625 / e, 2) + 0.984375;
  };
  Fb("Bounce", function(l) {
    return 1 - o(1 - l);
  }, o);
})(7.5625, 2.75);
Fb("Expo", function(r) {
  return Math.pow(2, 10 * (r - 1)) * r + r * r * r * r * r * r * (1 - r);
});
Fb("Circ", function(r) {
  return -(F9(1 - r * r) - 1);
});
Fb("Sine", function(r) {
  return r === 1 ? 1 : -tie(r * $ne) + 1;
});
Fb("Back", wH("in"), wH("out"), wH());
jr.SteppedEase = jr.steps = QI.SteppedEase = {
  config: function(e, t) {
    e === void 0 && (e = 1);
    var n = 1 / e, i = e + (t ? 0 : 1), o = t ? 1 : 0, l = 1 - gg;
    return function(u) {
      return ((i * lR(0, l, u) | 0) + o) * n;
    };
  }
};
vB.ease = jr["quad.out"];
aI("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(r) {
  return $Y += r + "," + r + "Params,";
});
var hk = function(e, t) {
  this.id = eie++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : U9, this.set = t ? t.getSetter : rF;
}, kw = /* @__PURE__ */ function() {
  function r(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, GB(this, +t.duration, 1, 1), this.data = t.data, rs && (this._ctx = rs, rs.data.push(this)), Lw || UI.wake();
  }
  var e = r.prototype;
  return e.delay = function(n) {
    return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay;
  }, e.duration = function(n) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(n) {
    return arguments.length ? (this._dirty = 0, GB(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(n, i) {
    if (BB(), !arguments.length)
      return this._tTime;
    var o = this._dp;
    if (o && o.smoothChildTiming && this._ts) {
      for (CV(this, n), !o._dp || o.parent || j9(o, this); o && o.parent; )
        o.parent._time !== o._start + (o._ts >= 0 ? o._tTime / o._ts : (o.totalDuration() - o._tTime) / -o._ts) && o.totalTime(o._tTime, !0), o = o.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && rp(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === gg || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), O9(this, n, i)), this;
  }, e.time = function(n, i) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + I_(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time;
  }, e.totalProgress = function(n, i) {
    return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, e.progress = function(n, i) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + I_(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(n, i) {
    var o = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (n - 1) * o, i) : this._repeat ? bB(this._tTime, o) + 1 : 1;
  }, e.timeScale = function(n, i) {
    if (!arguments.length)
      return this._rts === -1e-8 ? 0 : this._rts;
    if (this._rts === n)
      return this;
    var o = this.parent && this._ts ? lW(this.parent._time, this) : this._tTime;
    return this._rts = +n || 0, this._ts = this._ps || n === -1e-8 ? 0 : this._rts, this.totalTime(lR(-Math.abs(this._delay), this._tDur, o), i !== !1), IV(this), uie(this);
  }, e.paused = function(n) {
    return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (BB(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== gg && (this._tTime -= gg)))), this) : this._ps;
  }, e.startTime = function(n) {
    if (arguments.length) {
      this._start = n;
      var i = this.parent || this._dp;
      return i && (i._sort || !this.parent) && rp(i, this, n - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(n) {
    return this._start + (rI(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(n) {
    var i = this.parent || this._dp;
    return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? lW(i.rawTime(n), this) : this._tTime : this._tTime;
  }, e.revert = function(n) {
    n === void 0 && (n = aie);
    var i = Rc;
    return Rc = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), Rc = i, this;
  }, e.globalTime = function(n) {
    for (var i = this, o = arguments.length ? n : i.rawTime(); i; )
      o = i._start + o / (Math.abs(i._ts) || 1), i = i._dp;
    return !this.parent && this._sat ? this._sat.globalTime(n) : o;
  }, e.repeat = function(n) {
    return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, C_(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(n) {
    if (arguments.length) {
      var i = this._time;
      return this._rDelay = n, C_(this), i ? this.time(i) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(n) {
    return arguments.length ? (this._yoyo = n, this) : this._yoyo;
  }, e.seek = function(n, i) {
    return this.totalTime(UC(this, n), rI(i));
  }, e.restart = function(n, i) {
    return this.play().totalTime(n ? -this._delay : 0, rI(i)), this._dur || (this._zTime = -1e-8), this;
  }, e.play = function(n, i) {
    return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
  }, e.reverse = function(n, i) {
    return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1);
  }, e.pause = function(n, i) {
    return n != null && this.seek(n, i), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(n) {
    return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -1e-8 : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -1e-8, this;
  }, e.isActive = function() {
    var n = this.parent || this._dp, i = this._start, o;
    return !!(!n || this._ts && this._initted && n.isActive() && (o = n.rawTime(!0)) >= i && o < this.endTime(!0) - gg);
  }, e.eventCallback = function(n, i, o) {
    var l = this.vars;
    return arguments.length > 1 ? (i ? (l[n] = i, o && (l[n + "Params"] = o), n === "onUpdate" && (this._onUpdate = i)) : delete l[n], this) : l[n];
  }, e.then = function(n) {
    var i = this;
    return new Promise(function(o) {
      var l = Ls(n) ? n : J9, u = function() {
        var C = i.then;
        i.then = null, Ls(l) && (l = l(i)) && (l.then || l === i) && (i.then = C), o(l), i.then = C;
      };
      i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? u() : i._prom = u;
    });
  }, e.kill = function() {
    PZ(this);
  }, r;
}();
jI(kw.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -1e-8,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var $g = /* @__PURE__ */ function(r) {
  Y9(e, r);
  function e(n, i) {
    var o;
    return n === void 0 && (n = {}), o = r.call(this, n) || this, o.labels = {}, o.smoothChildTiming = !!n.smoothChildTiming, o.autoRemoveChildren = !!n.autoRemoveChildren, o._sort = rI(n.sortChildren), As && rp(n.parent || As, Fm(o), i), n.reversed && o.reverse(), n.paused && o.paused(!0), n.scrollTrigger && q9(Fm(o), n.scrollTrigger), o;
  }
  var t = e.prototype;
  return t.to = function(i, o, l) {
    return lw(0, arguments, this), this;
  }, t.from = function(i, o, l) {
    return lw(1, arguments, this), this;
  }, t.fromTo = function(i, o, l, u) {
    return lw(2, arguments, this), this;
  }, t.set = function(i, o, l) {
    return o.duration = 0, o.parent = this, sw(o).repeatDelay || (o.repeat = 0), o.immediateRender = !!o.immediateRender, new Kl(i, o, UC(this, l), 1), this;
  }, t.call = function(i, o, l) {
    return rp(this, Kl.delayedCall(0, i, o), l);
  }, t.staggerTo = function(i, o, l, u, I, C, f) {
    return l.duration = o, l.stagger = l.stagger || u, l.onComplete = C, l.onCompleteParams = f, l.parent = this, new Kl(i, l, UC(this, I)), this;
  }, t.staggerFrom = function(i, o, l, u, I, C, f) {
    return l.runBackwards = 1, sw(l).immediateRender = rI(l.immediateRender), this.staggerTo(i, o, l, u, I, C, f);
  }, t.staggerFromTo = function(i, o, l, u, I, C, f, v) {
    return u.startAt = l, sw(u).immediateRender = rI(u.immediateRender), this.staggerTo(i, o, u, I, C, f, v);
  }, t.render = function(i, o, l) {
    var u = this._time, I = this._dirty ? this.totalDuration() : this._tDur, C = this._dur, f = i <= 0 ? 0 : Ll(i), v = this._zTime < 0 != i < 0 && (this._initted || !C), b, S, R, W, x, N, Y, F, T, P, D, L;
    if (this !== As && f > I && i >= 0 && (f = I), f !== this._tTime || l || v) {
      if (u !== this._time && C && (f += this._time - u, i += this._time - u), b = f, T = this._start, F = this._ts, N = !F, v && (C || (u = this._zTime), (i || !o) && (this._zTime = i)), this._repeat) {
        if (D = this._yoyo, x = C + this._rDelay, this._repeat < -1 && i < 0)
          return this.totalTime(x * 100 + i, o, l);
        if (b = Ll(f % x), f === I ? (W = this._repeat, b = C) : (P = Ll(f / x), W = ~~P, W && W === P && (b = C, W--), b > C && (b = C)), P = bB(this._tTime, x), !u && this._tTime && P !== W && this._tTime - P * x - this._dur <= 0 && (P = W), D && W & 1 && (b = C - b, L = 1), W !== P && !this._lock) {
          var j = D && P & 1, J = j === (D && W & 1);
          if (W < P && (j = !j), u = j ? 0 : f % C ? C : f, this._lock = 1, this.render(u || (L ? 0 : Ll(W * x)), o, !C)._lock = 0, this._tTime = f, !o && this.parent && OI(this, "onRepeat"), this.vars.repeatRefresh && !L && (this.invalidate()._lock = 1), u && u !== this._time || N !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (C = this._dur, I = this._tDur, J && (this._lock = 2, u = j ? C : -1e-4, this.render(u, !0), this.vars.repeatRefresh && !L && this.invalidate()), this._lock = 0, !this._ts && !N)
            return this;
          Ik(this, L);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (Y = Iie(this, Ll(u), Ll(b)), Y && (f -= b - (b = Y._start))), this._tTime = f, this._time = b, this._act = !F, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, u = 0), !u && b && !o && !W && (OI(this, "onStart"), this._tTime !== f))
        return this;
      if (b >= u && i >= 0)
        for (S = this._first; S; ) {
          if (R = S._next, (S._act || b >= S._start) && S._ts && Y !== S) {
            if (S.parent !== this)
              return this.render(i, o, l);
            if (S.render(S._ts > 0 ? (b - S._start) * S._ts : (S._dirty ? S.totalDuration() : S._tDur) + (b - S._start) * S._ts, o, l), b !== this._time || !this._ts && !N) {
              Y = 0, R && (f += this._zTime = -1e-8);
              break;
            }
          }
          S = R;
        }
      else {
        S = this._last;
        for (var O = i < 0 ? i : b; S; ) {
          if (R = S._prev, (S._act || O <= S._end) && S._ts && Y !== S) {
            if (S.parent !== this)
              return this.render(i, o, l);
            if (S.render(S._ts > 0 ? (O - S._start) * S._ts : (S._dirty ? S.totalDuration() : S._tDur) + (O - S._start) * S._ts, o, l || Rc && (S._initted || S._startAt)), b !== this._time || !this._ts && !N) {
              Y = 0, R && (f += this._zTime = O ? -1e-8 : gg);
              break;
            }
          }
          S = R;
        }
      }
      if (Y && !o && (this.pause(), Y.render(b >= u ? 0 : -1e-8)._zTime = b >= u ? 1 : -1, this._ts))
        return this._start = T, IV(this), this.render(i, o, l);
      this._onUpdate && !o && OI(this, "onUpdate", !0), (f === I && this._tTime >= this.totalDuration() || !f && u) && (T === this._start || Math.abs(F) !== Math.abs(this._ts)) && (this._lock || ((i || !C) && (f === I && this._ts > 0 || !f && this._ts < 0) && Bv(this, 1), !o && !(i < 0 && !u) && (f || u || !I) && (OI(this, f === I && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < I && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(i, o) {
    var l = this;
    if (Qm(o) || (o = UC(this, o, i)), !(i instanceof kw)) {
      if (Ig(i))
        return i.forEach(function(u) {
          return l.add(u, o);
        }), this;
      if (Du(i))
        return this.addLabel(i, o);
      if (Ls(i))
        i = Kl.delayedCall(0, i);
      else
        return this;
    }
    return this !== i ? rp(this, i, o) : this;
  }, t.getChildren = function(i, o, l, u) {
    i === void 0 && (i = !0), o === void 0 && (o = !0), l === void 0 && (l = !0), u === void 0 && (u = -1e8);
    for (var I = [], C = this._first; C; )
      C._start >= u && (C instanceof Kl ? o && I.push(C) : (l && I.push(C), i && I.push.apply(I, C.getChildren(!0, o, l)))), C = C._next;
    return I;
  }, t.getById = function(i) {
    for (var o = this.getChildren(1, 1, 1), l = o.length; l--; )
      if (o[l].vars.id === i)
        return o[l];
  }, t.remove = function(i) {
    return Du(i) ? this.removeLabel(i) : Ls(i) ? this.killTweensOf(i) : (i.parent === this && dV(this, i), i === this._recent && (this._recent = this._last), vb(this));
  }, t.totalTime = function(i, o) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Ll(UI.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), r.prototype.totalTime.call(this, i, o), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(i, o) {
    return this.labels[i] = UC(this, o), this;
  }, t.removeLabel = function(i) {
    return delete this.labels[i], this;
  }, t.addPause = function(i, o, l) {
    var u = Kl.delayedCall(0, o || zw, l);
    return u.data = "isPause", this._hasPause = 1, rp(this, u, UC(this, i));
  }, t.removePause = function(i) {
    var o = this._first;
    for (i = UC(this, i); o; )
      o._start === i && o.data === "isPause" && Bv(o), o = o._next;
  }, t.killTweensOf = function(i, o, l) {
    for (var u = this.getTweensOf(i, l), I = u.length; I--; )
      Cv !== u[I] && u[I].kill(i, o);
    return this;
  }, t.getTweensOf = function(i, o) {
    for (var l = [], u = JC(i), I = this._first, C = Qm(o), f; I; )
      I instanceof Kl ? oie(I._targets, u) && (C ? (!Cv || I._initted && I._ts) && I.globalTime(0) <= o && I.globalTime(I.totalDuration()) > o : !o || I.isActive()) && l.push(I) : (f = I.getTweensOf(u, o)).length && l.push.apply(l, f), I = I._next;
    return l;
  }, t.tweenTo = function(i, o) {
    o = o || {};
    var l = this, u = UC(l, i), I = o, C = I.startAt, f = I.onStart, v = I.onStartParams, b = I.immediateRender, S, R = Kl.to(l, jI({
      ease: o.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: u,
      overwrite: "auto",
      duration: o.duration || Math.abs((u - (C && "time" in C ? C.time : l._time)) / l.timeScale()) || gg,
      onStart: function() {
        if (l.pause(), !S) {
          var x = o.duration || Math.abs((u - (C && "time" in C ? C.time : l._time)) / l.timeScale());
          R._dur !== x && GB(R, x, 0, 1).render(R._time, !0, !0), S = 1;
        }
        f && f.apply(R, v || []);
      }
    }, o));
    return b ? R.render(0) : R;
  }, t.tweenFromTo = function(i, o, l) {
    return this.tweenTo(o, jI({
      startAt: {
        time: UC(this, i)
      }
    }, l));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(i) {
    return i === void 0 && (i = this._time), h_(this, UC(this, i));
  }, t.previousLabel = function(i) {
    return i === void 0 && (i = this._time), h_(this, UC(this, i), 1);
  }, t.currentLabel = function(i) {
    return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + gg);
  }, t.shiftChildren = function(i, o, l) {
    l === void 0 && (l = 0);
    for (var u = this._first, I = this.labels, C; u; )
      u._start >= l && (u._start += i, u._end += i), u = u._next;
    if (o)
      for (C in I)
        I[C] >= l && (I[C] += i);
    return vb(this);
  }, t.invalidate = function(i) {
    var o = this._first;
    for (this._lock = 0; o; )
      o.invalidate(i), o = o._next;
    return r.prototype.invalidate.call(this, i);
  }, t.clear = function(i) {
    i === void 0 && (i = !0);
    for (var o = this._first, l; o; )
      l = o._next, this.remove(o), o = l;
    return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), vb(this);
  }, t.totalDuration = function(i) {
    var o = 0, l = this, u = l._last, I = Ip, C, f, v;
    if (arguments.length)
      return l.timeScale((l._repeat < 0 ? l.duration() : l.totalDuration()) / (l.reversed() ? -i : i));
    if (l._dirty) {
      for (v = l.parent; u; )
        C = u._prev, u._dirty && u.totalDuration(), f = u._start, f > I && l._sort && u._ts && !l._lock ? (l._lock = 1, rp(l, u, f - u._delay, 1)._lock = 0) : I = f, f < 0 && u._ts && (o -= f, (!v && !l._dp || v && v.smoothChildTiming) && (l._start += f / l._ts, l._time -= f, l._tTime -= f), l.shiftChildren(-f, !1, -1 / 0), I = 0), u._end > o && u._ts && (o = u._end), u = C;
      GB(l, l === As && l._time > o ? l._time : o, 1, 1), l._dirty = 0;
    }
    return l._tDur;
  }, e.updateRoot = function(i) {
    if (As._ts && (O9(As, lW(i, As)), D9 = UI.frame), UI.frame >= g_) {
      g_ += JI.autoSleep || 120;
      var o = As._first;
      if ((!o || !o._ts) && JI.autoSleep && UI._listeners.length < 2) {
        for (; o && !o._ts; )
          o = o._next;
        o || UI.sleep();
      }
    }
  }, e;
}(kw);
jI($g.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var xie = function(e, t, n, i, o, l, u) {
  var I = new oI(this._pt, e, t, 0, 1, yk, null, o), C = 0, f = 0, v, b, S, R, W, x, N, Y;
  for (I.b = n, I.e = i, n += "", i += "", (N = ~i.indexOf("random(")) && (i = Kw(i)), l && (Y = [n, i], l(Y, e, t), n = Y[0], i = Y[1]), b = n.match(GH) || []; v = GH.exec(i); )
    R = v[0], W = i.substring(C, v.index), S ? S = (S + 1) % 5 : W.substr(-5) === "rgba(" && (S = 1), R !== b[f++] && (x = parseFloat(b[f - 1]) || 0, I._pt = {
      _next: I._pt,
      p: W || f === 1 ? W : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: x,
      c: R.charAt(1) === "=" ? cB(x, R) - x : parseFloat(R) - x,
      m: S && S < 4 ? Math.round : 0
    }, C = GH.lastIndex);
  return I.c = C < i.length ? i.substring(C, i.length) : "", I.fp = u, (_9.test(i) || N) && (I.e = 0), this._pt = I, I;
}, tF = function(e, t, n, i, o, l, u, I, C, f) {
  Ls(i) && (i = i(o || 0, e, l));
  var v = e[t], b = n !== "get" ? n : Ls(v) ? C ? e[t.indexOf("set") || !Ls(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](C) : e[t]() : v, S = Ls(v) ? C ? Hie : Ak : iF, R;
  if (Du(i) && (~i.indexOf("random(") && (i = Kw(i)), i.charAt(1) === "=" && (R = cB(b, i) + (ug(b) || 0), (R || R === 0) && (i = R))), !f || b !== i || mX)
    return !isNaN(b * i) && i !== "" ? (R = new oI(this._pt, e, t, +b || 0, i - (b || 0), typeof v == "boolean" ? Yie : vk, 0, S), C && (R.fp = C), u && R.modifier(u, this, e), this._pt = R) : (!v && !(t in e) && jY(t, i), xie.call(this, e, t, b, i, S, I || JI.stringFilter, C));
}, Wie = function(e, t, n, i, o) {
  if (Ls(e) && (e = uw(e, o, t, n, i)), !hp(e) || e.style && e.nodeType || Ig(e) || E9(e))
    return Du(e) ? uw(e, o, t, n, i) : e;
  var l = {}, u;
  for (u in e)
    l[u] = uw(e[u], o, t, n, i);
  return l;
}, fk = function(e, t, n, i, o, l) {
  var u, I, C, f;
  if (kI[e] && (u = new kI[e]()).init(o, u.rawVars ? t[e] : Wie(t[e], i, o, l, n), n, i, l) !== !1 && (n._pt = I = new oI(n._pt, o, e, 0, 1, u.render, u, 0, u.priority), n !== aB))
    for (C = n._ptLookup[n._targets.indexOf(o)], f = u._props.length; f--; )
      C[u._props[f]] = I;
  return u;
}, Cv, mX, nF = function r(e, t, n) {
  var i = e.vars, o = i.ease, l = i.startAt, u = i.immediateRender, I = i.lazy, C = i.onUpdate, f = i.runBackwards, v = i.yoyoEase, b = i.keyframes, S = i.autoRevert, R = e._dur, W = e._startAt, x = e._targets, N = e.parent, Y = N && N.data === "nested" ? N.vars.targets : x, F = e._overwrite === "auto" && !OY, T = e.timeline, P, D, L, j, J, O, ne, he, pe, Ae, ke, Re, Xe;
  if (T && (!b || !o) && (o = "none"), e._ease = yb(o, vB.ease), e._yEase = v ? dk(yb(v === !0 ? o : v, vB.ease)) : 0, v && e._yoyo && !e._repeat && (v = e._yEase, e._yEase = e._ease, e._ease = v), e._from = !T && !!i.runBackwards, !T || b && !i.stagger) {
    if (he = x[0] ? Ab(x[0]).harness : 0, Re = he && i[he.prop], P = sW(i, qY), W && (W._zTime < 0 && W.progress(1), t < 0 && f && u && !S ? W.render(-1, !0) : W.revert(f && R ? h2 : rie), W._lazy = 0), l) {
      if (Bv(e._startAt = Kl.set(x, jI({
        data: "isStart",
        overwrite: !1,
        parent: N,
        immediateRender: !0,
        lazy: !W && rI(I),
        startAt: null,
        delay: 0,
        onUpdate: C && function() {
          return OI(e, "onUpdate");
        },
        stagger: 0
      }, l))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Rc || !u && !S) && e._startAt.revert(h2), u && R && t <= 0 && n <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (f && R && !W) {
      if (t && (u = !1), L = jI({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: u && !W && rI(I),
        immediateRender: u,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: N
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, P), Re && (L[he.prop] = Re), Bv(e._startAt = Kl.set(x, L)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Rc ? e._startAt.revert(h2) : e._startAt.render(-1, !0)), e._zTime = t, !u)
        r(e._startAt, gg, gg);
      else if (!t)
        return;
    }
    for (e._pt = e._ptCache = 0, I = R && rI(I) || I && !R, D = 0; D < x.length; D++) {
      if (J = x[D], ne = J._gsap || eF(x)[D]._gsap, e._ptLookup[D] = Ae = {}, dX[ne.id] && mv.length && oW(), ke = Y === x ? D : Y.indexOf(J), he && (pe = new he()).init(J, Re || P, e, ke, Y) !== !1 && (e._pt = j = new oI(e._pt, J, pe.name, 0, 1, pe.render, pe, 0, pe.priority), pe._props.forEach(function(re) {
        Ae[re] = j;
      }), pe.priority && (O = 1)), !he || Re)
        for (L in P)
          kI[L] && (pe = fk(L, P, e, ke, J, Y)) ? pe.priority && (O = 1) : Ae[L] = j = tF.call(e, J, L, "get", P[L], ke, Y, 0, i.stringFilter);
      e._op && e._op[D] && e.kill(J, e._op[D]), F && e._pt && (Cv = e, As.killTweensOf(J, Ae, e.globalTime(t)), Xe = !e.parent, Cv = 0), e._pt && I && (dX[ne.id] = 1);
    }
    O && bk(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = C, e._initted = (!e._op || e._pt) && !Xe, b && t <= 0 && T.render(Ip, !0, !0);
}, Vie = function(e, t, n, i, o, l, u, I) {
  var C = (e._pt && e._ptCache || (e._ptCache = {}))[t], f, v, b, S;
  if (!C)
    for (C = e._ptCache[t] = [], b = e._ptLookup, S = e._targets.length; S--; ) {
      if (f = b[S][t], f && f.d && f.d._pt)
        for (f = f.d._pt; f && f.p !== t && f.fp !== t; )
          f = f._next;
      if (!f)
        return mX = 1, e.vars[t] = "+=0", nF(e, u), mX = 0, I ? _w(t + " not eligible for reset") : 1;
      C.push(f);
    }
  for (S = C.length; S--; )
    v = C[S], f = v._pt || v, f.s = (i || i === 0) && !o ? i : f.s + (i || 0) + l * f.c, f.c = n - f.s, v.e && (v.e = Cl(n) + ug(v.e)), v.b && (v.b = f.s + ug(v.b));
}, Nie = function(e, t) {
  var n = e[0] ? Ab(e[0]).harness : 0, i = n && n.aliases, o, l, u, I;
  if (!i)
    return t;
  o = yB({}, t);
  for (l in i)
    if (l in o)
      for (I = i[l].split(","), u = I.length; u--; )
        o[I[u]] = o[l];
  return o;
}, Mie = function(e, t, n, i) {
  var o = t.ease || i || "power1.inOut", l, u;
  if (Ig(t))
    u = n[e] || (n[e] = []), t.forEach(function(I, C) {
      return u.push({
        t: C / (t.length - 1) * 100,
        v: I,
        e: o
      });
    });
  else
    for (l in t)
      u = n[l] || (n[l] = []), l === "ease" || u.push({
        t: parseFloat(e),
        v: t[l],
        e: o
      });
}, uw = function(e, t, n, i, o) {
  return Ls(e) ? e.call(t, n, i, o) : Du(e) && ~e.indexOf("random(") ? Kw(e) : e;
}, pk = $Y + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", mk = {};
aI(pk + ",id,stagger,delay,duration,paused,scrollTrigger", function(r) {
  return mk[r] = 1;
});
var Kl = /* @__PURE__ */ function(r) {
  Y9(e, r);
  function e(n, i, o, l) {
    var u;
    typeof i == "number" && (o.duration = i, i = o, o = null), u = r.call(this, l ? i : sw(i)) || this;
    var I = u.vars, C = I.duration, f = I.delay, v = I.immediateRender, b = I.stagger, S = I.overwrite, R = I.keyframes, W = I.defaults, x = I.scrollTrigger, N = I.yoyoEase, Y = i.parent || As, F = (Ig(n) || E9(n) ? Qm(n[0]) : "length" in i) ? [n] : JC(n), T, P, D, L, j, J, O, ne;
    if (u._targets = F.length ? eF(F) : _w("GSAP target " + n + " not found. https://gsap.com", !JI.nullTargetWarn) || [], u._ptLookup = [], u._overwrite = S, R || b || a2(C) || a2(f)) {
      if (i = u.vars, T = u.timeline = new $g({
        data: "nested",
        defaults: W || {},
        targets: Y && Y.data === "nested" ? Y.vars.targets : F
      }), T.kill(), T.parent = T._dp = Fm(u), T._start = 0, b || a2(C) || a2(f)) {
        if (L = F.length, O = b && nk(b), hp(b))
          for (j in b)
            ~pk.indexOf(j) && (ne || (ne = {}), ne[j] = b[j]);
        for (P = 0; P < L; P++)
          D = sW(i, mk), D.stagger = 0, N && (D.yoyoEase = N), ne && yB(D, ne), J = F[P], D.duration = +uw(C, Fm(u), P, J, F), D.delay = (+uw(f, Fm(u), P, J, F) || 0) - u._delay, !b && L === 1 && D.delay && (u._delay = f = D.delay, u._start += f, D.delay = 0), T.to(J, D, O ? O(P, J, F) : 0), T._ease = jr.none;
        T.duration() ? C = f = 0 : u.timeline = 0;
      } else if (R) {
        sw(jI(T.vars.defaults, {
          ease: "none"
        })), T._ease = yb(R.ease || i.ease || "none");
        var he = 0, pe, Ae, ke;
        if (Ig(R))
          R.forEach(function(Re) {
            return T.to(F, Re, ">");
          }), T.duration();
        else {
          D = {};
          for (j in R)
            j === "ease" || j === "easeEach" || Mie(j, R[j], D, R.easeEach);
          for (j in D)
            for (pe = D[j].sort(function(Re, Xe) {
              return Re.t - Xe.t;
            }), he = 0, P = 0; P < pe.length; P++)
              Ae = pe[P], ke = {
                ease: Ae.e,
                duration: (Ae.t - (P ? pe[P - 1].t : 0)) / 100 * C
              }, ke[j] = Ae.v, T.to(F, ke, he), he += ke.duration;
          T.duration() < C && T.to({}, {
            duration: C - T.duration()
          });
        }
      }
      C || u.duration(C = T.duration());
    } else
      u.timeline = 0;
    return S === !0 && !OY && (Cv = Fm(u), As.killTweensOf(F), Cv = 0), rp(Y, Fm(u), o), i.reversed && u.reverse(), i.paused && u.paused(!0), (v || !C && !R && u._start === Ll(Y._time) && rI(v) && cie(Fm(u)) && Y.data !== "nested") && (u._tTime = -1e-8, u.render(Math.max(0, -f) || 0)), x && q9(Fm(u), x), u;
  }
  var t = e.prototype;
  return t.render = function(i, o, l) {
    var u = this._time, I = this._tDur, C = this._dur, f = i < 0, v = i > I - gg && !f ? I : i < gg ? 0 : i, b, S, R, W, x, N, Y, F, T;
    if (!C)
      die(this, i, o, l);
    else if (v !== this._tTime || !i || l || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== f || this._lazy) {
      if (b = v, F = this.timeline, this._repeat) {
        if (W = C + this._rDelay, this._repeat < -1 && f)
          return this.totalTime(W * 100 + i, o, l);
        if (b = Ll(v % W), v === I ? (R = this._repeat, b = C) : (x = Ll(v / W), R = ~~x, R && R === x ? (b = C, R--) : b > C && (b = C)), N = this._yoyo && R & 1, N && (T = this._yEase, b = C - b), x = bB(this._tTime, W), b === u && !l && this._initted && R === x)
          return this._tTime = v, this;
        R !== x && (F && this._yEase && Ik(F, N), this.vars.repeatRefresh && !N && !this._lock && b !== W && this._initted && (this._lock = l = 1, this.render(Ll(W * R), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if ($9(this, f ? i : b, l, o, v))
          return this._tTime = 0, this;
        if (u !== this._time && !(l && this.vars.repeatRefresh && R !== x))
          return this;
        if (C !== this._dur)
          return this.render(i, o, l);
      }
      if (this._tTime = v, this._time = b, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = Y = (T || this._ease)(b / C), this._from && (this.ratio = Y = 1 - Y), b && !u && !o && !R && (OI(this, "onStart"), this._tTime !== v))
        return this;
      for (S = this._pt; S; )
        S.r(Y, S.d), S = S._next;
      F && F.render(i < 0 ? i : F._dur * F._ease(b / this._dur), o, l) || this._startAt && (this._zTime = i), this._onUpdate && !o && (f && IX(this, i, o, l), OI(this, "onUpdate")), this._repeat && R !== x && this.vars.onRepeat && !o && this.parent && OI(this, "onRepeat"), (v === this._tDur || !v) && this._tTime === v && (f && !this._onUpdate && IX(this, i, !0, !0), (i || !C) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && Bv(this, 1), !o && !(f && !u) && (v || u || N) && (OI(this, v === I ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < I && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(i) {
    return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), r.prototype.invalidate.call(this, i);
  }, t.resetTo = function(i, o, l, u, I) {
    Lw || UI.wake(), this._ts || this.play();
    var C = Math.min(this._dur, (this._dp._time - this._start) * this._ts), f;
    return this._initted || nF(this, C), f = this._ease(C / this._dur), Vie(this, i, o, l, u, f, C, I) ? this.resetTo(i, o, l, u, 1) : (CV(this, 0), this.parent || Q9(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(i, o) {
    if (o === void 0 && (o = "all"), !i && (!o || o === "all"))
      return this._lazy = this._pt = 0, this.parent ? PZ(this) : this.scrollTrigger && this.scrollTrigger.kill(!!Rc), this;
    if (this.timeline) {
      var l = this.timeline.totalDuration();
      return this.timeline.killTweensOf(i, o, Cv && Cv.vars.overwrite !== !0)._first || PZ(this), this.parent && l !== this.timeline.totalDuration() && GB(this, this._dur * this.timeline._tDur / l, 0, 1), this;
    }
    var u = this._targets, I = i ? JC(i) : u, C = this._ptLookup, f = this._pt, v, b, S, R, W, x, N;
    if ((!o || o === "all") && lie(u, I))
      return o === "all" && (this._pt = 0), PZ(this);
    for (v = this._op = this._op || [], o !== "all" && (Du(o) && (W = {}, aI(o, function(Y) {
      return W[Y] = 1;
    }), o = W), o = Nie(u, o)), N = u.length; N--; )
      if (~I.indexOf(u[N])) {
        b = C[N], o === "all" ? (v[N] = o, R = b, S = {}) : (S = v[N] = v[N] || {}, R = o);
        for (W in R)
          x = b && b[W], x && ((!("kill" in x.d) || x.d.kill(W) === !0) && dV(this, x, "_pt"), delete b[W]), S !== "all" && (S[W] = 1);
      }
    return this._initted && !this._pt && f && PZ(this), this;
  }, e.to = function(i, o) {
    return new e(i, o, arguments[2]);
  }, e.from = function(i, o) {
    return lw(1, arguments);
  }, e.delayedCall = function(i, o, l, u) {
    return new e(o, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: i,
      onComplete: o,
      onReverseComplete: o,
      onCompleteParams: l,
      onReverseCompleteParams: l,
      callbackScope: u
    });
  }, e.fromTo = function(i, o, l) {
    return lw(2, arguments);
  }, e.set = function(i, o) {
    return o.duration = 0, o.repeatDelay || (o.repeat = 0), new e(i, o);
  }, e.killTweensOf = function(i, o, l) {
    return As.killTweensOf(i, o, l);
  }, e;
}(kw);
jI(Kl.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
aI("staggerTo,staggerFrom,staggerFromTo", function(r) {
  Kl[r] = function() {
    var e = new $g(), t = hX.call(arguments, 0);
    return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0), e[r].apply(e, t);
  };
});
var iF = function(e, t, n) {
  return e[t] = n;
}, Ak = function(e, t, n) {
  return e[t](n);
}, Hie = function(e, t, n, i) {
  return e[t](i.fp, n);
}, Xie = function(e, t, n) {
  return e.setAttribute(t, n);
}, rF = function(e, t) {
  return Ls(e[t]) ? Ak : PY(e[t]) && e.setAttribute ? Xie : iF;
}, vk = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, Yie = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, yk = function(e, t) {
  var n = t._pt, i = "";
  if (!e && t.b)
    i = t.b;
  else if (e === 1 && t.e)
    i = t.e;
  else {
    for (; n; )
      i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
    i += t.c;
  }
  t.set(t.t, t.p, i, t);
}, aF = function(e, t) {
  for (var n = t._pt; n; )
    n.r(e, n.d), n = n._next;
}, Fie = function(e, t, n, i) {
  for (var o = this._pt, l; o; )
    l = o._next, o.p === i && o.modifier(e, t, n), o = l;
}, Eie = function(e) {
  for (var t = this._pt, n, i; t; )
    i = t._next, t.p === e && !t.op || t.op === e ? dV(this, t, "_pt") : t.dep || (n = 1), t = i;
  return !n;
}, Tie = function(e, t, n, i) {
  i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
}, bk = function(e) {
  for (var t = e._pt, n, i, o, l; t; ) {
    for (n = t._next, i = o; i && i.pr > t.pr; )
      i = i._next;
    (t._prev = i ? i._prev : l) ? t._prev._next = t : o = t, (t._next = i) ? i._prev = t : l = t, t = n;
  }
  e._pt = o;
}, oI = /* @__PURE__ */ function() {
  function r(t, n, i, o, l, u, I, C, f) {
    this.t = n, this.s = o, this.c = l, this.p = i, this.r = u || vk, this.d = I || this, this.set = C || iF, this.pr = f || 0, this._next = t, t && (t._prev = this);
  }
  var e = r.prototype;
  return e.modifier = function(n, i, o) {
    this.mSet = this.mSet || this.set, this.set = Tie, this.m = n, this.mt = o, this.tween = i;
  }, r;
}();
aI($Y + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(r) {
  return qY[r] = 1;
});
QI.TweenMax = QI.TweenLite = Kl;
QI.TimelineLite = QI.TimelineMax = $g;
As = new $g({
  sortChildren: !1,
  defaults: vB,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
JI.stringFilter = gk;
var bb = [], p2 = {}, _ie = [], p_ = 0, zie = 0, RH = function(e) {
  return (p2[e] || _ie).map(function(t) {
    return t();
  });
}, AX = function() {
  var e = Date.now(), t = [];
  e - p_ > 2 && (RH("matchMediaInit"), bb.forEach(function(n) {
    var i = n.queries, o = n.conditions, l, u, I, C;
    for (u in i)
      l = np.matchMedia(i[u]).matches, l && (I = 1), l !== o[u] && (o[u] = l, C = 1);
    C && (n.revert(), I && t.push(n));
  }), RH("matchMediaRevert"), t.forEach(function(n) {
    return n.onMatch(n, function(i) {
      return n.add(null, i);
    });
  }), p_ = e, RH("matchMedia"));
}, Gk = /* @__PURE__ */ function() {
  function r(t, n) {
    this.selector = n && fX(n), this.data = [], this._r = [], this.isReverted = !1, this.id = zie++, t && this.add(t);
  }
  var e = r.prototype;
  return e.add = function(n, i, o) {
    Ls(n) && (o = i, i = n, n = Ls);
    var l = this, u = function() {
      var C = rs, f = l.selector, v;
      return C && C !== l && C.data.push(l), o && (l.selector = fX(o)), rs = l, v = i.apply(l, arguments), Ls(v) && l._r.push(v), rs = C, l.selector = f, l.isReverted = !1, v;
    };
    return l.last = u, n === Ls ? u(l, function(I) {
      return l.add(null, I);
    }) : n ? l[n] = u : u;
  }, e.ignore = function(n) {
    var i = rs;
    rs = null, n(this), rs = i;
  }, e.getTweens = function() {
    var n = [];
    return this.data.forEach(function(i) {
      return i instanceof r ? n.push.apply(n, i.getTweens()) : i instanceof Kl && !(i.parent && i.parent.data === "nested") && n.push(i);
    }), n;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(n, i) {
    var o = this;
    if (n ? function() {
      for (var u = o.getTweens(), I = o.data.length, C; I--; )
        C = o.data[I], C.data === "isFlip" && (C.revert(), C.getChildren(!0, !0, !1).forEach(function(f) {
          return u.splice(u.indexOf(f), 1);
        }));
      for (u.map(function(f) {
        return {
          g: f._dur || f._delay || f._sat && !f._sat.vars.immediateRender ? f.globalTime(0) : -1 / 0,
          t: f
        };
      }).sort(function(f, v) {
        return v.g - f.g || -1 / 0;
      }).forEach(function(f) {
        return f.t.revert(n);
      }), I = o.data.length; I--; )
        C = o.data[I], C instanceof $g ? C.data !== "nested" && (C.scrollTrigger && C.scrollTrigger.revert(), C.kill()) : !(C instanceof Kl) && C.revert && C.revert(n);
      o._r.forEach(function(f) {
        return f(n, o);
      }), o.isReverted = !0;
    }() : this.data.forEach(function(u) {
      return u.kill && u.kill();
    }), this.clear(), i)
      for (var l = bb.length; l--; )
        bb[l].id === this.id && bb.splice(l, 1);
  }, e.revert = function(n) {
    this.kill(n || {});
  }, r;
}(), Kie = /* @__PURE__ */ function() {
  function r(t) {
    this.contexts = [], this.scope = t, rs && rs.data.push(this);
  }
  var e = r.prototype;
  return e.add = function(n, i, o) {
    hp(n) || (n = {
      matches: n
    });
    var l = new Gk(0, o || this.scope), u = l.conditions = {}, I, C, f;
    rs && !l.selector && (l.selector = rs.selector), this.contexts.push(l), i = l.add("onMatch", i), l.queries = n;
    for (C in n)
      C === "all" ? f = 1 : (I = np.matchMedia(n[C]), I && (bb.indexOf(l) < 0 && bb.push(l), (u[C] = I.matches) && (f = 1), I.addListener ? I.addListener(AX) : I.addEventListener("change", AX)));
    return f && i(l, function(v) {
      return l.add(null, v);
    }), this;
  }, e.revert = function(n) {
    this.kill(n || {});
  }, e.kill = function(n) {
    this.contexts.forEach(function(i) {
      return i.kill(n, !0);
    });
  }, r;
}(), uW = {
  registerPlugin: function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    t.forEach(function(i) {
      return lk(i);
    });
  },
  timeline: function(e) {
    return new $g(e);
  },
  getTweensOf: function(e, t) {
    return As.getTweensOf(e, t);
  },
  getProperty: function(e, t, n, i) {
    Du(e) && (e = JC(e)[0]);
    var o = Ab(e || {}).get, l = n ? J9 : P9;
    return n === "native" && (n = ""), e && (t ? l((kI[t] && kI[t].get || o)(e, t, n, i)) : function(u, I, C) {
      return l((kI[u] && kI[u].get || o)(e, u, I, C));
    });
  },
  quickSetter: function(e, t, n) {
    if (e = JC(e), e.length > 1) {
      var i = e.map(function(f) {
        return cI.quickSetter(f, t, n);
      }), o = i.length;
      return function(f) {
        for (var v = o; v--; )
          i[v](f);
      };
    }
    e = e[0] || {};
    var l = kI[t], u = Ab(e), I = u.harness && (u.harness.aliases || {})[t] || t, C = l ? function(f) {
      var v = new l();
      aB._pt = 0, v.init(e, n ? f + n : f, aB, 0, [e]), v.render(1, v), aB._pt && aF(1, aB);
    } : u.set(e, I);
    return l ? C : function(f) {
      return C(e, I, n ? f + n : f, u, 1);
    };
  },
  quickTo: function(e, t, n) {
    var i, o = cI.to(e, jI((i = {}, i[t] = "+=0.1", i.paused = !0, i.stagger = 0, i), n || {})), l = function(I, C, f) {
      return o.resetTo(t, I, C, f);
    };
    return l.tween = o, l;
  },
  isTweening: function(e) {
    return As.getTweensOf(e, !0).length > 0;
  },
  defaults: function(e) {
    return e && e.ease && (e.ease = yb(e.ease, vB.ease)), d_(vB, e || {});
  },
  config: function(e) {
    return d_(JI, e || {});
  },
  registerEffect: function(e) {
    var t = e.name, n = e.effect, i = e.plugins, o = e.defaults, l = e.extendTimeline;
    (i || "").split(",").forEach(function(u) {
      return u && !kI[u] && !QI[u] && _w(t + " effect requires " + u + " plugin.");
    }), BH[t] = function(u, I, C) {
      return n(JC(u), jI(I || {}, o), C);
    }, l && ($g.prototype[t] = function(u, I, C) {
      return this.add(BH[t](u, hp(I) ? I : (C = I) && {}, this), C);
    });
  },
  registerEase: function(e, t) {
    jr[e] = yb(t);
  },
  parseEase: function(e, t) {
    return arguments.length ? yb(e, t) : jr;
  },
  getById: function(e) {
    return As.getById(e);
  },
  exportRoot: function(e, t) {
    e === void 0 && (e = {});
    var n = new $g(e), i, o;
    for (n.smoothChildTiming = rI(e.smoothChildTiming), As.remove(n), n._dp = 0, n._time = n._tTime = As._time, i = As._first; i; )
      o = i._next, (t || !(!i._dur && i instanceof Kl && i.vars.onComplete === i._targets[0])) && rp(n, i, i._start - i._delay), i = o;
    return rp(As, n, 0), n;
  },
  context: function(e, t) {
    return e ? new Gk(e, t) : rs;
  },
  matchMedia: function(e) {
    return new Kie(e);
  },
  matchMediaRefresh: function() {
    return bb.forEach(function(e) {
      var t = e.conditions, n, i;
      for (i in t)
        t[i] && (t[i] = !1, n = 1);
      n && e.revert();
    }) || AX();
  },
  addEventListener: function(e, t) {
    var n = p2[e] || (p2[e] = []);
    ~n.indexOf(t) || n.push(t);
  },
  removeEventListener: function(e, t) {
    var n = p2[e], i = n && n.indexOf(t);
    i >= 0 && n.splice(i, 1);
  },
  utils: {
    wrap: vie,
    wrapYoyo: yie,
    distribute: nk,
    random: rk,
    snap: ik,
    normalize: Aie,
    getUnit: ug,
    clamp: hie,
    splitColor: uk,
    toArray: JC,
    selector: fX,
    mapRange: ok,
    pipe: pie,
    unitize: mie,
    interpolate: bie,
    shuffle: tk
  },
  install: L9,
  effects: BH,
  ticker: UI,
  updateRoot: $g.updateRoot,
  plugins: kI,
  globalTimeline: As,
  core: {
    PropTween: oI,
    globals: k9,
    Tween: Kl,
    Timeline: $g,
    Animation: kw,
    getCache: Ab,
    _removeLinkedListItem: dV,
    reverting: function() {
      return Rc;
    },
    context: function(e) {
      return e && rs && (rs.data.push(e), e._ctx = rs), rs;
    },
    suppressOverwrites: function(e) {
      return OY = e;
    }
  }
};
aI("to,from,fromTo,delayedCall,set,killTweensOf", function(r) {
  return uW[r] = Kl[r];
});
UI.add($g.updateRoot);
aB = uW.to({}, {
  duration: 0
});
var Lie = function(e, t) {
  for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
    n = n._next;
  return n;
}, kie = function(e, t) {
  var n = e._targets, i, o, l;
  for (i in t)
    for (o = n.length; o--; )
      l = e._ptLookup[o][i], l && (l = l.d) && (l._pt && (l = Lie(l, i)), l && l.modifier && l.modifier(t[i], e, n[o], i));
}, xH = function(e, t) {
  return {
    name: e,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(i, o, l) {
      l._onInit = function(u) {
        var I, C;
        if (Du(o) && (I = {}, aI(o, function(f) {
          return I[f] = 1;
        }), o = I), t) {
          I = {};
          for (C in o)
            I[C] = t(o[C]);
          o = I;
        }
        kie(u, o);
      };
    }
  };
}, cI = uW.registerPlugin({
  name: "attr",
  init: function(e, t, n, i, o) {
    var l, u, I;
    this.tween = n;
    for (l in t)
      I = e.getAttribute(l) || "", u = this.add(e, "setAttribute", (I || 0) + "", t[l], i, o, 0, 0, l), u.op = l, u.b = I, this._props.push(l);
  },
  render: function(e, t) {
    for (var n = t._pt; n; )
      Rc ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next;
  }
}, {
  name: "endArray",
  init: function(e, t) {
    for (var n = t.length; n--; )
      this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
  }
}, xH("roundProps", pX), xH("modifiers"), xH("snap", ik)) || uW;
Kl.version = $g.version = cI.version = "3.12.7";
K9 = 1;
JY() && BB();
jr.Power0;
jr.Power1;
jr.Power2;
jr.Power3;
jr.Power4;
jr.Linear;
jr.Quad;
jr.Cubic;
jr.Quart;
jr.Quint;
jr.Strong;
jr.Elastic;
jr.Back;
jr.SteppedEase;
jr.Bounce;
jr.Sine;
jr.Expo;
jr.Circ;
/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var m_, hv, gB, oF, Ib, A_, sF, Die = function() {
  return typeof window < "u";
}, jm = {}, nb = 180 / Math.PI, dB = Math.PI / 180, DG = Math.atan2, v_ = 1e8, lF = /([A-Z])/g, Uie = /(left|right|width|margin|padding|x)/i, Oie = /[\s,\(]\S/, sp = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, vX = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, Pie = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, Jie = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, Qie = function(e, t) {
  var n = t.s + t.c * e;
  t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
}, Bk = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, Sk = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, jie = function(e, t, n) {
  return e.style[t] = n;
}, qie = function(e, t, n) {
  return e.style.setProperty(t, n);
}, $ie = function(e, t, n) {
  return e._gsap[t] = n;
}, ere = function(e, t, n) {
  return e._gsap.scaleX = e._gsap.scaleY = n;
}, tre = function(e, t, n, i, o) {
  var l = e._gsap;
  l.scaleX = l.scaleY = n, l.renderTransform(o, l);
}, nre = function(e, t, n, i, o) {
  var l = e._gsap;
  l[t] = n, l.renderTransform(o, l);
}, ys = "transform", sI = ys + "Origin", ire = function r(e, t) {
  var n = this, i = this.target, o = i.style, l = i._gsap;
  if (e in jm && o) {
    if (this.tfm = this.tfm || {}, e !== "transform")
      e = sp[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(u) {
        return n.tfm[u] = Tm(i, u);
      }) : this.tfm[e] = l.x ? l[e] : Tm(i, e), e === sI && (this.tfm.zOrigin = l.zOrigin);
    else
      return sp.transform.split(",").forEach(function(u) {
        return r.call(n, u, t);
      });
    if (this.props.indexOf(ys) >= 0)
      return;
    l.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(sI, t, "")), e = ys;
  }
  (o || t) && this.props.push(e, t, o[e]);
}, Zk = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, rre = function() {
  var e = this.props, t = this.target, n = t.style, i = t._gsap, o, l;
  for (o = 0; o < e.length; o += 3)
    e[o + 1] ? e[o + 1] === 2 ? t[e[o]](e[o + 2]) : t[e[o]] = e[o + 2] : e[o + 2] ? n[e[o]] = e[o + 2] : n.removeProperty(e[o].substr(0, 2) === "--" ? e[o] : e[o].replace(lF, "-$1").toLowerCase());
  if (this.tfm) {
    for (l in this.tfm)
      i[l] = this.tfm[l];
    i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), o = sF(), (!o || !o.isStart) && !n[ys] && (Zk(n), i.zOrigin && n[sI] && (n[sI] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
  }
}, wk = function(e, t) {
  var n = {
    target: e,
    props: [],
    revert: rre,
    save: ire
  };
  return e._gsap || cI.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(i) {
    return n.save(i);
  }), n;
}, Rk, yX = function(e, t) {
  var n = hv.createElementNS ? hv.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : hv.createElement(e);
  return n && n.style ? n : hv.createElement(e);
}, Cp = function r(e, t, n) {
  var i = getComputedStyle(e);
  return i[t] || i.getPropertyValue(t.replace(lF, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && r(e, SB(t) || t, 1) || "";
}, y_ = "O,Moz,ms,Ms,Webkit".split(","), SB = function(e, t, n) {
  var i = t || Ib, o = i.style, l = 5;
  if (e in o && !n)
    return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); l-- && !(y_[l] + e in o); )
    ;
  return l < 0 ? null : (l === 3 ? "ms" : l >= 0 ? y_[l] : "") + e;
}, bX = function() {
  Die() && window.document && (m_ = window, hv = m_.document, gB = hv.documentElement, Ib = yX("div") || {
    style: {}
  }, yX("div"), ys = SB(ys), sI = ys + "Origin", Ib.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Rk = !!SB("perspective"), sF = cI.core.reverting, oF = 1);
}, b_ = function(e) {
  var t = e.ownerSVGElement, n = yX("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = e.cloneNode(!0), o;
  i.style.display = "block", n.appendChild(i), gB.appendChild(n);
  try {
    o = i.getBBox();
  } catch {
  }
  return n.removeChild(i), gB.removeChild(n), o;
}, G_ = function(e, t) {
  for (var n = t.length; n--; )
    if (e.hasAttribute(t[n]))
      return e.getAttribute(t[n]);
}, xk = function(e) {
  var t, n;
  try {
    t = e.getBBox();
  } catch {
    t = b_(e), n = 1;
  }
  return t && (t.width || t.height) || n || (t = b_(e)), t && !t.width && !t.x && !t.y ? {
    x: +G_(e, ["x", "cx", "x1"]) || 0,
    y: +G_(e, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, Wk = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && xk(e));
}, Rb = function(e, t) {
  if (t) {
    var n = e.style, i;
    t in jm && t !== sI && (t = ys), n.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(i === "--" ? t : t.replace(lF, "-$1").toLowerCase())) : n.removeAttribute(t);
  }
}, fv = function(e, t, n, i, o, l) {
  var u = new oI(e._pt, t, n, 0, 1, l ? Sk : Bk);
  return e._pt = u, u.b = i, u.e = o, e._props.push(n), u;
}, B_ = {
  deg: 1,
  rad: 1,
  turn: 1
}, are = {
  grid: 1,
  flex: 1
}, Sv = function r(e, t, n, i) {
  var o = parseFloat(n) || 0, l = (n + "").trim().substr((o + "").length) || "px", u = Ib.style, I = Uie.test(t), C = e.tagName.toLowerCase() === "svg", f = (C ? "client" : "offset") + (I ? "Width" : "Height"), v = 100, b = i === "px", S = i === "%", R, W, x, N;
  if (i === l || !o || B_[i] || B_[l])
    return o;
  if (l !== "px" && !b && (o = r(e, t, n, "px")), N = e.getCTM && Wk(e), (S || l === "%") && (jm[t] || ~t.indexOf("adius")))
    return R = N ? e.getBBox()[I ? "width" : "height"] : e[f], Cl(S ? o / R * v : o / 100 * R);
  if (u[I ? "width" : "height"] = v + (b ? l : i), W = i !== "rem" && ~t.indexOf("adius") || i === "em" && e.appendChild && !C ? e : e.parentNode, N && (W = (e.ownerSVGElement || {}).parentNode), (!W || W === hv || !W.appendChild) && (W = hv.body), x = W._gsap, x && S && x.width && I && x.time === UI.time && !x.uncache)
    return Cl(o / x.width * v);
  if (S && (t === "height" || t === "width")) {
    var Y = e.style[t];
    e.style[t] = v + i, R = e[f], Y ? e.style[t] = Y : Rb(e, t);
  } else
    (S || l === "%") && !are[Cp(W, "display")] && (u.position = Cp(e, "position")), W === e && (u.position = "static"), W.appendChild(Ib), R = Ib[f], W.removeChild(Ib), u.position = "absolute";
  return I && S && (x = Ab(W), x.time = UI.time, x.width = W[f]), Cl(b ? R * o / v : R && o ? v / R * o : 0);
}, Tm = function(e, t, n, i) {
  var o;
  return oF || bX(), t in sp && t !== "transform" && (t = sp[t], ~t.indexOf(",") && (t = t.split(",")[0])), jm[t] && t !== "transform" ? (o = Uw(e, i), o = t !== "transformOrigin" ? o[t] : o.svg ? o.origin : gW(Cp(e, sI)) + " " + o.zOrigin + "px") : (o = e.style[t], (!o || o === "auto" || i || ~(o + "").indexOf("calc(")) && (o = cW[t] && cW[t](e, t, n) || Cp(e, t) || U9(e, t) || (t === "opacity" ? 1 : 0))), n && !~(o + "").trim().indexOf(" ") ? Sv(e, t, o, n) + n : o;
}, ore = function(e, t, n, i) {
  if (!n || n === "none") {
    var o = SB(t, e, 1), l = o && Cp(e, o, 1);
    l && l !== n ? (t = o, n = l) : t === "borderColor" && (n = Cp(e, "borderTopColor"));
  }
  var u = new oI(this._pt, e.style, t, 0, 1, yk), I = 0, C = 0, f, v, b, S, R, W, x, N, Y, F, T, P;
  if (u.b = n, u.e = i, n += "", i += "", i === "auto" && (W = e.style[t], e.style[t] = i, i = Cp(e, t) || i, W ? e.style[t] = W : Rb(e, t)), f = [n, i], gk(f), n = f[0], i = f[1], b = n.match(rB) || [], P = i.match(rB) || [], P.length) {
    for (; v = rB.exec(i); )
      x = v[0], Y = i.substring(I, v.index), R ? R = (R + 1) % 5 : (Y.substr(-5) === "rgba(" || Y.substr(-5) === "hsla(") && (R = 1), x !== (W = b[C++] || "") && (S = parseFloat(W) || 0, T = W.substr((S + "").length), x.charAt(1) === "=" && (x = cB(S, x) + T), N = parseFloat(x), F = x.substr((N + "").length), I = rB.lastIndex - F.length, F || (F = F || JI.units[t] || T, I === i.length && (i += F, u.e += F)), T !== F && (S = Sv(e, t, W, F) || 0), u._pt = {
        _next: u._pt,
        p: Y || C === 1 ? Y : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: S,
        c: N - S,
        m: R && R < 4 || t === "zIndex" ? Math.round : 0
      });
    u.c = I < i.length ? i.substring(I, i.length) : "";
  } else
    u.r = t === "display" && i === "none" ? Sk : Bk;
  return _9.test(i) && (u.e = 0), this._pt = u, u;
}, S_ = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, sre = function(e) {
  var t = e.split(" "), n = t[0], i = t[1] || "50%";
  return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = S_[n] || n, t[1] = S_[i] || i, t.join(" ");
}, lre = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var n = t.t, i = n.style, o = t.u, l = n._gsap, u, I, C;
    if (o === "all" || o === !0)
      i.cssText = "", I = 1;
    else
      for (o = o.split(","), C = o.length; --C > -1; )
        u = o[C], jm[u] && (I = 1, u = u === "transformOrigin" ? sI : ys), Rb(n, u);
    I && (Rb(n, ys), l && (l.svg && n.removeAttribute("transform"), i.scale = i.rotate = i.translate = "none", Uw(n, 1), l.uncache = 1, Zk(i)));
  }
}, cW = {
  clearProps: function(e, t, n, i, o) {
    if (o.data !== "isFromStart") {
      var l = e._pt = new oI(e._pt, t, n, 0, 0, lre);
      return l.u = i, l.pr = -10, l.tween = o, e._props.push(n), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, Dw = [1, 0, 0, 1, 0, 0], Vk = {}, Nk = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, Z_ = function(e) {
  var t = Cp(e, ys);
  return Nk(t) ? Dw : t.substr(7).match(T9).map(Cl);
}, uF = function(e, t) {
  var n = e._gsap || Ab(e), i = e.style, o = Z_(e), l, u, I, C;
  return n.svg && e.getAttribute("transform") ? (I = e.transform.baseVal.consolidate().matrix, o = [I.a, I.b, I.c, I.d, I.e, I.f], o.join(",") === "1,0,0,1,0,0" ? Dw : o) : (o === Dw && !e.offsetParent && e !== gB && !n.svg && (I = i.display, i.display = "block", l = e.parentNode, (!l || !e.offsetParent && !e.getBoundingClientRect().width) && (C = 1, u = e.nextElementSibling, gB.appendChild(e)), o = Z_(e), I ? i.display = I : Rb(e, "display"), C && (u ? l.insertBefore(e, u) : l ? l.appendChild(e) : gB.removeChild(e))), t && o.length > 6 ? [o[0], o[1], o[4], o[5], o[12], o[13]] : o);
}, GX = function(e, t, n, i, o, l) {
  var u = e._gsap, I = o || uF(e, !0), C = u.xOrigin || 0, f = u.yOrigin || 0, v = u.xOffset || 0, b = u.yOffset || 0, S = I[0], R = I[1], W = I[2], x = I[3], N = I[4], Y = I[5], F = t.split(" "), T = parseFloat(F[0]) || 0, P = parseFloat(F[1]) || 0, D, L, j, J;
  n ? I !== Dw && (L = S * x - R * W) && (j = T * (x / L) + P * (-W / L) + (W * Y - x * N) / L, J = T * (-R / L) + P * (S / L) - (S * Y - R * N) / L, T = j, P = J) : (D = xk(e), T = D.x + (~F[0].indexOf("%") ? T / 100 * D.width : T), P = D.y + (~(F[1] || F[0]).indexOf("%") ? P / 100 * D.height : P)), i || i !== !1 && u.smooth ? (N = T - C, Y = P - f, u.xOffset = v + (N * S + Y * W) - N, u.yOffset = b + (N * R + Y * x) - Y) : u.xOffset = u.yOffset = 0, u.xOrigin = T, u.yOrigin = P, u.smooth = !!i, u.origin = t, u.originIsAbsolute = !!n, e.style[sI] = "0px 0px", l && (fv(l, u, "xOrigin", C, T), fv(l, u, "yOrigin", f, P), fv(l, u, "xOffset", v, u.xOffset), fv(l, u, "yOffset", b, u.yOffset)), e.setAttribute("data-svg-origin", T + " " + P);
}, Uw = function(e, t) {
  var n = e._gsap || new hk(e);
  if ("x" in n && !t && !n.uncache)
    return n;
  var i = e.style, o = n.scaleX < 0, l = "px", u = "deg", I = getComputedStyle(e), C = Cp(e, sI) || "0", f, v, b, S, R, W, x, N, Y, F, T, P, D, L, j, J, O, ne, he, pe, Ae, ke, Re, Xe, re, Se, Be, le, Ye, nt, ze, Je;
  return f = v = b = W = x = N = Y = F = T = 0, S = R = 1, n.svg = !!(e.getCTM && Wk(e)), I.translate && ((I.translate !== "none" || I.scale !== "none" || I.rotate !== "none") && (i[ys] = (I.translate !== "none" ? "translate3d(" + (I.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (I.rotate !== "none" ? "rotate(" + I.rotate + ") " : "") + (I.scale !== "none" ? "scale(" + I.scale.split(" ").join(",") + ") " : "") + (I[ys] !== "none" ? I[ys] : "")), i.scale = i.rotate = i.translate = "none"), L = uF(e, n.svg), n.svg && (n.uncache ? (re = e.getBBox(), C = n.xOrigin - re.x + "px " + (n.yOrigin - re.y) + "px", Xe = "") : Xe = !t && e.getAttribute("data-svg-origin"), GX(e, Xe || C, !!Xe || n.originIsAbsolute, n.smooth !== !1, L)), P = n.xOrigin || 0, D = n.yOrigin || 0, L !== Dw && (ne = L[0], he = L[1], pe = L[2], Ae = L[3], f = ke = L[4], v = Re = L[5], L.length === 6 ? (S = Math.sqrt(ne * ne + he * he), R = Math.sqrt(Ae * Ae + pe * pe), W = ne || he ? DG(he, ne) * nb : 0, Y = pe || Ae ? DG(pe, Ae) * nb + W : 0, Y && (R *= Math.abs(Math.cos(Y * dB))), n.svg && (f -= P - (P * ne + D * pe), v -= D - (P * he + D * Ae))) : (Je = L[6], nt = L[7], Be = L[8], le = L[9], Ye = L[10], ze = L[11], f = L[12], v = L[13], b = L[14], j = DG(Je, Ye), x = j * nb, j && (J = Math.cos(-j), O = Math.sin(-j), Xe = ke * J + Be * O, re = Re * J + le * O, Se = Je * J + Ye * O, Be = ke * -O + Be * J, le = Re * -O + le * J, Ye = Je * -O + Ye * J, ze = nt * -O + ze * J, ke = Xe, Re = re, Je = Se), j = DG(-pe, Ye), N = j * nb, j && (J = Math.cos(-j), O = Math.sin(-j), Xe = ne * J - Be * O, re = he * J - le * O, Se = pe * J - Ye * O, ze = Ae * O + ze * J, ne = Xe, he = re, pe = Se), j = DG(he, ne), W = j * nb, j && (J = Math.cos(j), O = Math.sin(j), Xe = ne * J + he * O, re = ke * J + Re * O, he = he * J - ne * O, Re = Re * J - ke * O, ne = Xe, ke = re), x && Math.abs(x) + Math.abs(W) > 359.9 && (x = W = 0, N = 180 - N), S = Cl(Math.sqrt(ne * ne + he * he + pe * pe)), R = Cl(Math.sqrt(Re * Re + Je * Je)), j = DG(ke, Re), Y = Math.abs(j) > 2e-4 ? j * nb : 0, T = ze ? 1 / (ze < 0 ? -ze : ze) : 0), n.svg && (Xe = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !Nk(Cp(e, ys)), Xe && e.setAttribute("transform", Xe))), Math.abs(Y) > 90 && Math.abs(Y) < 270 && (o ? (S *= -1, Y += W <= 0 ? 180 : -180, W += W <= 0 ? 180 : -180) : (R *= -1, Y += Y <= 0 ? 180 : -180)), t = t || n.uncache, n.x = f - ((n.xPercent = f && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + l, n.y = v - ((n.yPercent = v && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-v) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + l, n.z = b + l, n.scaleX = Cl(S), n.scaleY = Cl(R), n.rotation = Cl(W) + u, n.rotationX = Cl(x) + u, n.rotationY = Cl(N) + u, n.skewX = Y + u, n.skewY = F + u, n.transformPerspective = T + l, (n.zOrigin = parseFloat(C.split(" ")[2]) || !t && n.zOrigin || 0) && (i[sI] = gW(C)), n.xOffset = n.yOffset = 0, n.force3D = JI.force3D, n.renderTransform = n.svg ? cre : Rk ? Mk : ure, n.uncache = 0, n;
}, gW = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, WH = function(e, t, n) {
  var i = ug(t);
  return Cl(parseFloat(t) + parseFloat(Sv(e, "x", n + "px", i))) + i;
}, ure = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Mk(e, t);
}, Jy = "0deg", zZ = "0px", Qy = ") ", Mk = function(e, t) {
  var n = t || this, i = n.xPercent, o = n.yPercent, l = n.x, u = n.y, I = n.z, C = n.rotation, f = n.rotationY, v = n.rotationX, b = n.skewX, S = n.skewY, R = n.scaleX, W = n.scaleY, x = n.transformPerspective, N = n.force3D, Y = n.target, F = n.zOrigin, T = "", P = N === "auto" && e && e !== 1 || N === !0;
  if (F && (v !== Jy || f !== Jy)) {
    var D = parseFloat(f) * dB, L = Math.sin(D), j = Math.cos(D), J;
    D = parseFloat(v) * dB, J = Math.cos(D), l = WH(Y, l, L * J * -F), u = WH(Y, u, -Math.sin(D) * -F), I = WH(Y, I, j * J * -F + F);
  }
  x !== zZ && (T += "perspective(" + x + Qy), (i || o) && (T += "translate(" + i + "%, " + o + "%) "), (P || l !== zZ || u !== zZ || I !== zZ) && (T += I !== zZ || P ? "translate3d(" + l + ", " + u + ", " + I + ") " : "translate(" + l + ", " + u + Qy), C !== Jy && (T += "rotate(" + C + Qy), f !== Jy && (T += "rotateY(" + f + Qy), v !== Jy && (T += "rotateX(" + v + Qy), (b !== Jy || S !== Jy) && (T += "skew(" + b + ", " + S + Qy), (R !== 1 || W !== 1) && (T += "scale(" + R + ", " + W + Qy), Y.style[ys] = T || "translate(0, 0)";
}, cre = function(e, t) {
  var n = t || this, i = n.xPercent, o = n.yPercent, l = n.x, u = n.y, I = n.rotation, C = n.skewX, f = n.skewY, v = n.scaleX, b = n.scaleY, S = n.target, R = n.xOrigin, W = n.yOrigin, x = n.xOffset, N = n.yOffset, Y = n.forceCSS, F = parseFloat(l), T = parseFloat(u), P, D, L, j, J;
  I = parseFloat(I), C = parseFloat(C), f = parseFloat(f), f && (f = parseFloat(f), C += f, I += f), I || C ? (I *= dB, C *= dB, P = Math.cos(I) * v, D = Math.sin(I) * v, L = Math.sin(I - C) * -b, j = Math.cos(I - C) * b, C && (f *= dB, J = Math.tan(C - f), J = Math.sqrt(1 + J * J), L *= J, j *= J, f && (J = Math.tan(f), J = Math.sqrt(1 + J * J), P *= J, D *= J)), P = Cl(P), D = Cl(D), L = Cl(L), j = Cl(j)) : (P = v, j = b, D = L = 0), (F && !~(l + "").indexOf("px") || T && !~(u + "").indexOf("px")) && (F = Sv(S, "x", l, "px"), T = Sv(S, "y", u, "px")), (R || W || x || N) && (F = Cl(F + R - (R * P + W * L) + x), T = Cl(T + W - (R * D + W * j) + N)), (i || o) && (J = S.getBBox(), F = Cl(F + i / 100 * J.width), T = Cl(T + o / 100 * J.height)), J = "matrix(" + P + "," + D + "," + L + "," + j + "," + F + "," + T + ")", S.setAttribute("transform", J), Y && (S.style[ys] = J);
}, gre = function(e, t, n, i, o) {
  var l = 360, u = Du(o), I = parseFloat(o) * (u && ~o.indexOf("rad") ? nb : 1), C = I - i, f = i + C + "deg", v, b;
  return u && (v = o.split("_")[1], v === "short" && (C %= l, C !== C % (l / 2) && (C += C < 0 ? l : -360)), v === "cw" && C < 0 ? C = (C + l * v_) % l - ~~(C / l) * l : v === "ccw" && C > 0 && (C = (C - l * v_) % l - ~~(C / l) * l)), e._pt = b = new oI(e._pt, t, n, i, C, Pie), b.e = f, b.u = "deg", e._props.push(n), b;
}, w_ = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, dre = function(e, t, n) {
  var i = w_({}, n._gsap), o = "perspective,force3D,transformOrigin,svgOrigin", l = n.style, u, I, C, f, v, b, S, R;
  i.svg ? (C = n.getAttribute("transform"), n.setAttribute("transform", ""), l[ys] = t, u = Uw(n, 1), Rb(n, ys), n.setAttribute("transform", C)) : (C = getComputedStyle(n)[ys], l[ys] = t, u = Uw(n, 1), l[ys] = C);
  for (I in jm)
    C = i[I], f = u[I], C !== f && o.indexOf(I) < 0 && (S = ug(C), R = ug(f), v = S !== R ? Sv(n, I, C, R) : parseFloat(C), b = parseFloat(f), e._pt = new oI(e._pt, u, I, v, b - v, vX), e._pt.u = R || 0, e._props.push(I));
  w_(u, i);
};
aI("padding,margin,Width,Radius", function(r, e) {
  var t = "Top", n = "Right", i = "Bottom", o = "Left", l = (e < 3 ? [t, n, i, o] : [t + o, t + n, i + n, i + o]).map(function(u) {
    return e < 2 ? r + u : "border" + u + r;
  });
  cW[e > 1 ? "border" + r : r] = function(u, I, C, f, v) {
    var b, S;
    if (arguments.length < 4)
      return b = l.map(function(R) {
        return Tm(u, R, C);
      }), S = b.join(" "), S.split(b[0]).length === 5 ? b[0] : S;
    b = (f + "").split(" "), S = {}, l.forEach(function(R, W) {
      return S[R] = b[W] = b[W] || b[(W - 1) / 2 | 0];
    }), u.init(I, S, v);
  };
});
var Hk = {
  name: "css",
  register: bX,
  targetTest: function(e) {
    return e.style && e.nodeType;
  },
  init: function(e, t, n, i, o) {
    var l = this._props, u = e.style, I = n.vars.startAt, C, f, v, b, S, R, W, x, N, Y, F, T, P, D, L, j;
    oF || bX(), this.styles = this.styles || wk(e), j = this.styles.props, this.tween = n;
    for (W in t)
      if (W !== "autoRound" && (f = t[W], !(kI[W] && fk(W, t, n, i, e, o)))) {
        if (S = typeof f, R = cW[W], S === "function" && (f = f.call(n, i, e, o), S = typeof f), S === "string" && ~f.indexOf("random(") && (f = Kw(f)), R)
          R(this, e, W, f, n) && (L = 1);
        else if (W.substr(0, 2) === "--")
          C = (getComputedStyle(e).getPropertyValue(W) + "").trim(), f += "", Av.lastIndex = 0, Av.test(C) || (x = ug(C), N = ug(f)), N ? x !== N && (C = Sv(e, W, C, N) + N) : x && (f += x), this.add(u, "setProperty", C, f, i, o, 0, 0, W), l.push(W), j.push(W, 0, u[W]);
        else if (S !== "undefined") {
          if (I && W in I ? (C = typeof I[W] == "function" ? I[W].call(n, i, e, o) : I[W], Du(C) && ~C.indexOf("random(") && (C = Kw(C)), ug(C + "") || C === "auto" || (C += JI.units[W] || ug(Tm(e, W)) || ""), (C + "").charAt(1) === "=" && (C = Tm(e, W))) : C = Tm(e, W), b = parseFloat(C), Y = S === "string" && f.charAt(1) === "=" && f.substr(0, 2), Y && (f = f.substr(2)), v = parseFloat(f), W in sp && (W === "autoAlpha" && (b === 1 && Tm(e, "visibility") === "hidden" && v && (b = 0), j.push("visibility", 0, u.visibility), fv(this, u, "visibility", b ? "inherit" : "hidden", v ? "inherit" : "hidden", !v)), W !== "scale" && W !== "transform" && (W = sp[W], ~W.indexOf(",") && (W = W.split(",")[0]))), F = W in jm, F) {
            if (this.styles.save(W), T || (P = e._gsap, P.renderTransform && !t.parseTransform || Uw(e, t.parseTransform), D = t.smoothOrigin !== !1 && P.smooth, T = this._pt = new oI(this._pt, u, ys, 0, 1, P.renderTransform, P, 0, -1), T.dep = 1), W === "scale")
              this._pt = new oI(this._pt, P, "scaleY", P.scaleY, (Y ? cB(P.scaleY, Y + v) : v) - P.scaleY || 0, vX), this._pt.u = 0, l.push("scaleY", W), W += "X";
            else if (W === "transformOrigin") {
              j.push(sI, 0, u[sI]), f = sre(f), P.svg ? GX(e, f, 0, D, 0, this) : (N = parseFloat(f.split(" ")[2]) || 0, N !== P.zOrigin && fv(this, P, "zOrigin", P.zOrigin, N), fv(this, u, W, gW(C), gW(f)));
              continue;
            } else if (W === "svgOrigin") {
              GX(e, f, 1, D, 0, this);
              continue;
            } else if (W in Vk) {
              gre(this, P, W, b, Y ? cB(b, Y + f) : f);
              continue;
            } else if (W === "smoothOrigin") {
              fv(this, P, "smooth", P.smooth, f);
              continue;
            } else if (W === "force3D") {
              P[W] = f;
              continue;
            } else if (W === "transform") {
              dre(this, f, e);
              continue;
            }
          } else W in u || (W = SB(W) || W);
          if (F || (v || v === 0) && (b || b === 0) && !Oie.test(f) && W in u)
            x = (C + "").substr((b + "").length), v || (v = 0), N = ug(f) || (W in JI.units ? JI.units[W] : x), x !== N && (b = Sv(e, W, C, N)), this._pt = new oI(this._pt, F ? P : u, W, b, (Y ? cB(b, Y + v) : v) - b, !F && (N === "px" || W === "zIndex") && t.autoRound !== !1 ? Qie : vX), this._pt.u = N || 0, x !== N && N !== "%" && (this._pt.b = C, this._pt.r = Jie);
          else if (W in u)
            ore.call(this, e, W, C, Y ? Y + f : f);
          else if (W in e)
            this.add(e, W, C || e[W], Y ? Y + f : f, i, o);
          else if (W !== "parseTransform") {
            jY(W, f);
            continue;
          }
          F || (W in u ? j.push(W, 0, u[W]) : typeof e[W] == "function" ? j.push(W, 2, e[W]()) : j.push(W, 1, C || e[W])), l.push(W);
        }
      }
    L && bk(this);
  },
  render: function(e, t) {
    if (t.tween._time || !sF())
      for (var n = t._pt; n; )
        n.r(e, n.d), n = n._next;
    else
      t.styles.revert();
  },
  get: Tm,
  aliases: sp,
  getSetter: function(e, t, n) {
    var i = sp[t];
    return i && i.indexOf(",") < 0 && (t = i), t in jm && t !== sI && (e._gsap.x || Tm(e, "x")) ? n && A_ === n ? t === "scale" ? ere : $ie : (A_ = n || {}) && (t === "scale" ? tre : nre) : e.style && !PY(e.style[t]) ? jie : ~t.indexOf("-") ? qie : rF(e, t);
  },
  core: {
    _removeProperty: Rb,
    _getMatrix: uF
  }
};
cI.utils.checkPrefix = SB;
cI.core.getStyleSaver = wk;
(function(r, e, t, n) {
  var i = aI(r + "," + e + "," + t, function(o) {
    jm[o] = 1;
  });
  aI(e, function(o) {
    JI.units[o] = "deg", Vk[o] = 1;
  }), sp[i[13]] = r + "," + e, aI(n, function(o) {
    var l = o.split(":");
    sp[l[1]] = i[l[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
aI("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(r) {
  JI.units[r] = "px";
});
cI.registerPlugin(Hk);
var Xk = cI.registerPlugin(Hk) || cI;
Xk.core.Tween;
const hV = (r) => {
  const e = Xte(), [t, n] = ye.useState(!0), i = ye.useRef(null);
  return ye.useEffect(() => {
    if (i.current) {
      const o = r[e];
      Xk.to(i.current.color, {
        r: parseInt(o.slice(1, 3), 16) / 255,
        g: parseInt(o.slice(3, 5), 16) / 255,
        b: parseInt(o.slice(5, 7), 16) / 255,
        duration: t ? 0 : 0.7,
        ease: "power1.inOut"
      });
    }
    t && n(!1);
  }, [e]), i;
}, Yk = (r) => r <= AB ? {
  position: [0, -0.42, 0],
  rotation: [-Math.PI / 2, 0, 0]
} : {
  position: [0, -1.3, 0],
  rotation: [-Math.PI / 2, 0, 0]
}, Ire = (r) => r <= AB ? {
  position: [0, 9.6, -10],
  rotation: [0, 0, 0]
} : {
  position: [0, 8.6, -10],
  rotation: [0, 0, 0]
}, Cre = (r) => r <= AB ? {
  position: [0, -0.7, -0.2],
  rotation: [-Math.PI / 2, 0, 0]
} : {
  position: [0, -1.6, -0.3],
  rotation: [-Math.PI / 2, 0, 0]
}, hre = () => {
  const { width: r } = Yb(), e = Cre(r), t = hV(X9);
  return /* @__PURE__ */ We.jsxs("mesh", { position: e.position, rotation: e.rotation, receiveShadow: !0, castShadow: !0, children: [
    /* @__PURE__ */ We.jsx("planeGeometry", { args: [50, 20, 1, 1] }),
    /* @__PURE__ */ We.jsx("meshStandardMaterial", { ref: t, opacity: 0.5, transparent: !0 })
  ] });
}, fre = (r) => {
  const { width: e } = Yb(), t = Yk(e), [n] = H9(() => t, ye.useRef(null));
  return /* @__PURE__ */ We.jsxs("mesh", { ref: n, receiveShadow: !0, castShadow: !0, ...t, children: [
    /* @__PURE__ */ We.jsx("planeGeometry", { args: [50, 20, 1, 1] }),
    /* @__PURE__ */ We.jsx("meshStandardMaterial", { color: "white", opacity: 0, transparent: !0 })
  ] });
}, pre = (r) => {
  const { width: e } = Yb(), t = Ire(e), n = hV(X9), [i] = H9(() => t, ye.useRef(null));
  return /* @__PURE__ */ We.jsxs("mesh", { ref: i, receiveShadow: !0, castShadow: !0, ...t, children: [
    /* @__PURE__ */ We.jsx("planeGeometry", { args: [54, 20, 1, 1] }),
    /* @__PURE__ */ We.jsx("meshStandardMaterial", { ref: n })
  ] });
}, mre = (r) => {
  const { width: e } = Yb(), t = Yk(e), n = ye.useRef(null), i = hV(jne);
  return cV(({ clock: o }) => {
    if (!n.current)
      return;
    const l = o.getElapsedTime() * 0.12, u = n.current.attributes.position.array;
    for (let I = 0; I < u.length; I += 3) {
      const C = u[I], f = u[I + 1];
      u[I + 2] = Math.sin(C * 2 + l) * Math.cos(f * 2 + l) * 0.1;
    }
    n.current.attributes.position.needsUpdate = !0;
  }), /* @__PURE__ */ We.jsxs("mesh", { castShadow: !0, ...t, children: [
    /* @__PURE__ */ We.jsx("planeGeometry", { ref: n, args: [54, 20, 54, 20] }),
    /* @__PURE__ */ We.jsx("meshStandardMaterial", { ref: i, wireframe: !0 })
  ] });
}, Are = (r) => {
  const [e] = Dne(() => r, ye.useRef(null)), t = hV(qne);
  return /* @__PURE__ */ We.jsxs("mesh", { ref: e, receiveShadow: !0, castShadow: !0, children: [
    /* @__PURE__ */ We.jsx("boxGeometry", { args: r.args }),
    /* @__PURE__ */ We.jsx("meshStandardMaterial", { ref: t })
  ] });
}, vre = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (r) => {
  const e = Math.random() * 16 | 0;
  return (r === "x" ? e : e & 3 | 8).toString(16);
}), yre = () => Math.random() * (2 * Math.PI) - Math.PI, bre = () => {
  const r = [0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.8], e = Math.floor(Math.random() * r.length);
  return r[e];
}, Gre = (r) => 6e-5 * r + -0.1367, Bre = (r) => -44e-5 * r + 0.4336, Sre = () => {
  const { scene: r, camera: e, gl: t } = Jg(), [n, i] = ye.useState([]), o = (l) => {
    const u = new FY(), I = new Lt(), C = Gre(t.domElement.clientWidth), f = Bre(t.domElement.clientHeight);
    I.setX(l.clientX / t.domElement.clientWidth * 2 - 1 + C), I.setY(-(l.clientY / t.domElement.clientHeight * 2 - 1) + f), u.setFromCamera(I, e);
    const v = e.position.clone().add(u.ray.direction.clone().multiplyScalar(2)), b = u.ray.direction.clone().multiplyScalar(30);
    i((S) => {
      const R = bre(), W = yre(), x = {
        key: vre(),
        mass: 5,
        args: [R, R, R],
        position: v.toArray(),
        velocity: b.toArray(),
        rotation: [W, W, W]
      };
      return S.length >= 120 && S.shift(), [...S, x];
    });
  };
  return ye.useEffect(() => (t.domElement.addEventListener("pointerdown", o), () => {
    t.domElement.removeEventListener("pointerdown", o);
  }), [t, e, r]), /* @__PURE__ */ We.jsx(We.Fragment, { children: n.map((l) => /* @__PURE__ */ ye.createElement(Are, { ...l, key: l.key })) });
}, Zre = () => {
  const r = ye.useRef(null);
  return r.current?.shadow.mapSize, ye.useEffect(() => {
    r.current && (r.current.shadow.mapSize.width = 2048, r.current.shadow.mapSize.height = 2048, r.current.shadow.bias = -1e-3, r.current.shadow.camera.left = -26, r.current.shadow.camera.right = 26, r.current.shadow.camera.top = 20, r.current.shadow.camera.bottom = -20, r.current.shadow.camera.near = 0, r.current.shadow.camera.far = 50);
  }, [r.current]), /* @__PURE__ */ We.jsxs(ye.Suspense, { fallback: /* @__PURE__ */ We.jsx(Mte, {}), children: [
    /* @__PURE__ */ We.jsx(Vte, { enableZoom: !1, enablePan: !1, enableRotate: !1, enableDamping: !1 }),
    /* @__PURE__ */ We.jsx("ambientLight", { intensity: 1 }),
    /* @__PURE__ */ We.jsx("directionalLight", { ref: r, position: [0, 5, 8], intensity: 0.8, castShadow: !0 }),
    /* @__PURE__ */ We.jsx(hre, {}),
    /* @__PURE__ */ We.jsx(mre, {}),
    /* @__PURE__ */ We.jsxs(Qne, { children: [
      /* @__PURE__ */ We.jsx(fre, {}),
      /* @__PURE__ */ We.jsx(pre, {}),
      /* @__PURE__ */ We.jsx(Sre, {})
    ] })
  ] });
}, wre = ({ className: r }) => {
  const { width: e } = Yb();
  return /* @__PURE__ */ We.jsxs(Ate, { className: r, shadows: !0, children: [
    /* @__PURE__ */ We.jsx(
      Wte,
      {
        makeDefault: !0,
        rotation: [0, 1, 0],
        fov: 75,
        position: [0, e <= AB ? 0.8 : 0.7, 6],
        near: 1,
        far: 1e3
      }
    ),
    /* @__PURE__ */ We.jsx(Zre, {})
  ] }, String(e <= AB));
}, Rre = () => {
  const [r, e] = ye.useState(!1);
  return ye.useEffect(() => {
    e(window.matchMedia("(pointer: coarse)").matches);
    const n = window.matchMedia("(pointer: coarse)"), i = (o) => {
      e(o.matches);
    };
    return n.addEventListener("change", i), () => {
      n.removeEventListener("change", i);
    };
  }, []), r;
}, Fk = ({ id: r, turnGray: e = !1, title: t, children: n, hoverState: i }) => {
  const [o, l] = i, u = Rre(), I = o === r, C = o === "", f = () => u ? "" : I ? "opacity-100 bg-white/10 xs:bg-white/0 shadow-card xs:shadow-none" : C ? "opacity-80" : "opacity-40", v = () => "";
  return /* @__PURE__ */ We.jsxs("div", { id: r.toString(), className: `cardFrame ${f()}`, onMouseEnter: () => l(r), children: [
    /* @__PURE__ */ We.jsx("div", { className: `cardFrame-title ${v()}`, children: t }),
    /* @__PURE__ */ We.jsx("div", { className: "grow flex flex-col h-auto justify-between gap-2", children: n })
  ] });
}, Ek = ({ tags: r, selectable: e = !1 }) => {
  const [t, n] = Fz(), i = t.get("tags"), o = (l) => {
    if (!e)
      return;
    const u = i ? i.split(",") : [];
    if (u.includes(l.value)) {
      const I = u.filter((C) => C !== l.value);
      I.length > 0 ? t.set("tags", I.join(",")) : t.delete("tags");
    } else
      u.push(l.value), t.set("tags", u.join(","));
    n(t);
  };
  return /* @__PURE__ */ We.jsx("ul", { className: "flex flex-row flex-wrap gap-2", children: r.map((l) => {
    const u = i?.includes(l.value);
    return /* @__PURE__ */ We.jsx(
      "li",
      {
        className: `${u ? "chip-selected" : "chip-normal"} ${e ? "cursor-pointer" : "cursor-default"}`,
        onClick: (I) => {
          I.stopPropagation(), o(l);
        },
        children: l.name
      },
      l.value + u
    );
  }) });
}, xre = () => /* @__PURE__ */ We.jsxs("div", { className: "copyright", children: [
  /* @__PURE__ */ We.jsx("span", { className: "copyright-mark", children: "" }),
  /* @__PURE__ */ We.jsxs("svg", { className: "signature", viewBox: "0 0 134.67 56.18", children: [
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M19.38,41.6l-2.05.62a91.64,91.64,0,0,0-10,3.71,7.43,7.43,0,0,0-2.15,1.28S5,47.3,5,47.35a1,1,0,0,1-1.38-.07,1,1,0,0,1,0-1.39A4.3,4.3,0,0,1,5,44.72a51.66,51.66,0,0,1,8-3.49Q16.47,40,20.07,39a1.3,1.3,0,0,0,1-1,7.48,7.48,0,0,0,.36-2.81,2.84,2.84,0,0,1,0-.41,1,1,0,0,1,.85-1,1,1,0,0,1,1.1.68,4.53,4.53,0,0,1,.14,2.75c0,.17-.08.34-.11.51s.06.3.26.26a3.41,3.41,0,0,0,.46-.1L34.3,35.3a4.35,4.35,0,0,1,.52-.1,1.19,1.19,0,0,1,1.35.84,1.18,1.18,0,0,1-.73,1.37c-.65.29-1.32.55-2,.81-.47.19-1,0-1.44.07C29,39,25.89,39.77,22.85,40.6a.88.88,0,0,0-.63.54c-.3.65-.59,1.31-.92,2-.23.42-.12.61.29.79,1.61.69,3.24,1.32,4.82,2.06A75.71,75.71,0,0,1,35.18,51c3,1.92,6,3.8,8.94,5.7a2.46,2.46,0,0,1,.74.66,1.07,1.07,0,0,1,0,1.3,1.09,1.09,0,0,1-1.23.46,2.09,2.09,0,0,1-.63-.28c-4.69-3.18-9.49-6.2-14.34-9.14a75.19,75.19,0,0,0-8.2-4c-.36-.16-.52-.05-.69.25A36.68,36.68,0,0,1,17,50.2,79.28,79.28,0,0,1,8,60.55a3.08,3.08,0,0,1-1.15.66,1.36,1.36,0,0,1-1.59-.76c-.2-.55.08-1.06.74-1.39a7.92,7.92,0,0,0,2.12-1.88,71.2,71.2,0,0,0,9.76-12.51c.51-.89,1-1.81,1.45-2.72A1.79,1.79,0,0,0,19.38,41.6Z",
        transform: "translate(-4.88 -6.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M64.81,30.91c2.08-.61,4-1.22,6-1.76,2.79-.78,5.59-1.5,8.39-2.24a4.4,4.4,0,0,1,1.73-.2,1.22,1.22,0,0,1,1.2,1.41,1.43,1.43,0,0,1-1.73,1.16,2.45,2.45,0,0,0-1.47.09c-5.34,1.33-10.59,3-15.89,4.44a12.73,12.73,0,0,1-1.36.31,1.6,1.6,0,0,1-1.83-.81,1.54,1.54,0,0,1,.59-1.9c.94-.81,1.91-1.58,2.85-2.39a28.26,28.26,0,0,0,3.38-3.54.72.72,0,0,0,0-.85,24.13,24.13,0,0,1-1.78-4.49,2.18,2.18,0,0,1,.21-1.94c-.14-.18-.3-.09-.44-.1a1.42,1.42,0,0,1-1.39-2,16.39,16.39,0,0,1,1.21-2.45c.87-1.71,1.76-3.42,2.66-5.11a5.52,5.52,0,0,1,.74-1.05,1.12,1.12,0,0,1,1.53-.15,1,1,0,0,1,.12,1.41,16.37,16.37,0,0,0-1.6,3c-.54,1.08-1,2.16-1.57,3.29a1.14,1.14,0,0,0,.75-.18C69.2,14,71.2,13,73.31,12.26A5.5,5.5,0,0,1,74,12a1.11,1.11,0,0,1,1.29.65,1.09,1.09,0,0,1-.46,1.41,3.24,3.24,0,0,1-.63.29c-2.85,1-5.53,2.47-8.52,3.51.92.21,1.11.81,1.23,1.53a11.9,11.9,0,0,0,1.33,3.34c.11.22.24.25.38,0,1.08-1.63,2.51-3,3.07-5A1,1,0,0,1,73,17a1.16,1.16,0,0,1,.8,1.42A8.33,8.33,0,0,1,72.55,21c-.86,1.32-1.73,2.63-2.64,3.92a.9.9,0,0,0-.07,1.16,1.6,1.6,0,0,1,.32.8,1.06,1.06,0,0,1-.52,1,1.1,1.1,0,0,1-1.31-.09c-.21-.16-.36-.35-.61,0A35.21,35.21,0,0,1,65,30.66Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M19.78,16.74c.87-.32,1.74-.66,2.61-1s1.52-.48,2.28-.7a1.24,1.24,0,0,1,1.43.38,1.19,1.19,0,0,1,.08,1.38,1.21,1.21,0,0,1-1.29.7,2.14,2.14,0,0,0-1.08.21c-1.42.51-2.83,1.05-4.26,1.57a13,13,0,0,1-1.38.44c-.47.11-.47.33-.22.65l.07.09a1.05,1.05,0,0,1,0,1.59A1.26,1.26,0,0,1,16.24,22a3.16,3.16,0,0,1-.74-1.37c-.42-1.33-.83-2.67-1.2-4a47.58,47.58,0,0,1-1.22-5.76,1.59,1.59,0,0,0-.3-.74,2.12,2.12,0,0,1-.28-1.73,1.06,1.06,0,0,1,.88-.91A1.13,1.13,0,0,1,14.54,8a6,6,0,0,1,.64,2c.07.33,0,.83.29.93s.49-.37.74-.58A13.38,13.38,0,0,1,23.67,7a4.18,4.18,0,0,1,1.61.2A1.73,1.73,0,0,1,26.4,9.69a7.2,7.2,0,0,1-1.47,2.16,43.87,43.87,0,0,1-3.6,3.21A7.56,7.56,0,0,0,19.78,16.74Zm-3-.33c.24-.08.34-.31.47-.49a18.72,18.72,0,0,1,2.64-2.7,42.1,42.1,0,0,0,3.38-3c.17-.2.52-.44.4-.65s-.53-.1-.8-.05a12.75,12.75,0,0,0-5.34,2.72C16.2,13.29,16.09,14.65,16.81,16.41Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M47.85,34.64a12.72,12.72,0,0,0-1.87,2,1.09,1.09,0,0,1-1.27.6,1.13,1.13,0,0,1-.87-1,2.1,2.1,0,0,1,1.49-2.34,1.49,1.49,0,0,0,.68-.41,1.59,1.59,0,0,1,.29-.29c2.2-1.39,1.81-3.52,1.6-5.6,0-.15-.07-.3-.09-.46a1.11,1.11,0,0,1,.83-1.18,1.12,1.12,0,0,1,1.23.66,3.21,3.21,0,0,1,.26,1.3,4.66,4.66,0,0,0,.18,1.44c.72-.6,1.38-1.16,2-1.7a6.27,6.27,0,0,1,1.47-1,1.21,1.21,0,0,1,1.46.23,1.2,1.2,0,0,1,.21,1.36.74.74,0,0,1-.41.47,9.37,9.37,0,0,0-2.54,1.82c-.65.52-1.26,1.09-1.89,1.64a.92.92,0,0,0-.39.74A46.86,46.86,0,0,1,50,38.34a2.38,2.38,0,0,0,.9-.65c1.58-1.35,3.22-2.62,4.89-3.86a5.55,5.55,0,0,1,1.06-.6A1,1,0,0,1,58,35c-.7.62-1.44,1.19-2.17,1.77a72.28,72.28,0,0,0-6,4.94c-.69.67-1.32,1.42-2,2.1a1.21,1.21,0,0,1-1.42.4c-.94-.41-.86-1.53,0-2.25a2.3,2.3,0,0,0,.69-1.07A21.06,21.06,0,0,0,47.9,35,2.61,2.61,0,0,0,47.85,34.64Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M74.78,53.5l2.92-.63a2.26,2.26,0,0,1,1.21,0,1.18,1.18,0,0,1,.9,1.21,1.14,1.14,0,0,1-1.1,1,16.25,16.25,0,0,0-3,.6c-1.42.39-2.84.82-4.26,1.21a.7.7,0,0,0-.5.51,1.21,1.21,0,0,1-2.11.48,2.74,2.74,0,0,1-.64-1,6,6,0,0,1-.59-3.27,1.5,1.5,0,0,0-.11-.75c-.44-1.47-.89-2.93-1.3-4.41A1.13,1.13,0,0,1,67,47a1,1,0,0,1,1.4,1.13,5.09,5.09,0,0,0,.52,2c.13.38.32.09.44-.07a23.26,23.26,0,0,1,1.53-1.91,12,12,0,0,1,2.45-2,5.64,5.64,0,0,1,1.16-.56,2.15,2.15,0,0,1,3,2.62,10.42,10.42,0,0,1-1.66,4C75.5,52.57,75.18,53,74.78,53.5Zm-4.71,0c0,.19,0,.36.16.45s.25-.05.36-.12l1.31-1A7.86,7.86,0,0,0,75,48.45c0-.18.2-.42,0-.54s-.39.07-.56.18a13.08,13.08,0,0,0-4.2,4.81A3.54,3.54,0,0,0,70.07,53.47Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M24.17,27.29a17.27,17.27,0,0,0-5.35,1.26,53.13,53.13,0,0,1-5.27,1.85,4.37,4.37,0,0,1-1.39.16,2.3,2.3,0,0,1-2.2-2.8,7.54,7.54,0,0,1,1.3-3,1.44,1.44,0,0,1,1.42-.72,1,1,0,0,1,.83.8,1.5,1.5,0,0,1-.57,1.61,2,2,0,0,0-.73,1.27c-.13.48,0,.61.5.5A24.32,24.32,0,0,0,16,27.13a41.66,41.66,0,0,1,5.46-1.83A11,11,0,0,1,25,25a2.75,2.75,0,0,1,2.79,2A3.15,3.15,0,0,1,27,29.53a12.6,12.6,0,0,1-2.41,2.59,1.08,1.08,0,0,1-1.52.09,1.1,1.1,0,0,1,0-1.58c.62-.77,1.27-1.51,1.91-2.27a3.92,3.92,0,0,0,.25-.32c.32-.51.24-.69-.36-.74C24.64,27.28,24.4,27.29,24.17,27.29Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M97.06,45.6c.33-.11.42-.37.56-.56a5,5,0,0,1,2.58-1.81,2,2,0,0,1,2.11.4,1.9,1.9,0,0,1,.41,2.06,9.55,9.55,0,0,1-4.35,5.68,1.15,1.15,0,0,0-.64.77,1.09,1.09,0,0,1-1,.87,1.17,1.17,0,0,1-1.15-.75,1.55,1.55,0,0,1-.19-.84,24.88,24.88,0,0,0-.42-4.56,22.79,22.79,0,0,1,0-3.2A1.19,1.19,0,0,1,96,42.42a1,1,0,0,1,1.08,1.34A4.38,4.38,0,0,0,97.06,45.6Z",
        className: "scale-105 -translate-x-[10px] -translate-y-[7px]",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M96.6,15.72c.86-.4,1.55-.73,2.26-1a8.09,8.09,0,0,1,1.6-.52,1.55,1.55,0,0,1,1.22.26,1,1,0,0,1,.51,1.09,1,1,0,0,1-.83.87c-2.49.44-4.47,1.92-6.53,3.21-.46.29-.89.58-1.44.27A1.08,1.08,0,0,1,93,18.31a41.82,41.82,0,0,0,2.55-5.87,8,8,0,0,1,.63-1.24,1.12,1.12,0,0,1,1.25-.54,1.24,1.24,0,0,1,1,1.11A1,1,0,0,1,97.83,13a.7.7,0,0,0-.37.37C97.19,14.06,96.93,14.81,96.6,15.72Z",
        className: " scale-105 -translate-x-[10px] -translate-y-[7px]",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M100.61,20.76A1.49,1.49,0,0,1,102,22.22a1.14,1.14,0,0,1-1.29,1.23,1.14,1.14,0,0,0-.77.34l-4.21,3.66a3.16,3.16,0,0,1-.83.53,1,1,0,0,1-1.19-.21,1,1,0,0,1-.21-1.18,1.72,1.72,0,0,1,.29-.49c.42-.52.85-1,1.28-1.52.17-.18.34-.44.55-.49,1.27-.29,1.92-1.39,2.86-2.11a8.25,8.25,0,0,1,1.46-1A1.6,1.6,0,0,1,100.61,20.76Z",
        className: " scale-105 -translate-x-[10px] -translate-y-[7px]",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M101.84,29.54a1.39,1.39,0,0,1-.55,1,53.25,53.25,0,0,1-4.64,3.69,1.44,1.44,0,0,1-1.47.29,1,1,0,0,1-.72-.9,1.07,1.07,0,0,1,.63-1.1c1.76-.78,3-2.26,4.44-3.43a2.33,2.33,0,0,1,1-.6A1.13,1.13,0,0,1,101.84,29.54Z",
        className: " scale-105 -translate-x-[10px] -translate-y-[7px]",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M127.86,36.09c.54-1.28,1.06-2.56,1.62-3.81.83-1.82,1.67-3.63,2.52-5.45a3,3,0,0,1,.75-1.09,1,1,0,0,1,1.28-.07,1,1,0,0,1,.3,1.3c-1.89,3.73-3.3,7.66-4.93,11.51a2.52,2.52,0,0,0,0,2.1c1,2.45,2,4.89,3.2,7.25.11.22.24.43.38.69a.87.87,0,0,0,.27-.67,42.06,42.06,0,0,0,.37-4.35c0-1,.07-2,.13-3a2.31,2.31,0,0,1,.15-.68,1,1,0,0,1,1-.7,1.07,1.07,0,0,1,1,.78,1.29,1.29,0,0,1,.08.4,35.67,35.67,0,0,1-.55,8.75,4.64,4.64,0,0,1-.66,1.67A1.73,1.73,0,0,1,132,51a6.73,6.73,0,0,1-1.36-1.94c-1-1.87-1.81-3.78-2.62-5.72-.06-.16-.07-.35-.25-.45-.23.08-.21.31-.28.47-1.49,3.65-2.9,7.34-4.58,10.91a4.09,4.09,0,0,1-.71,1.12,1.44,1.44,0,0,1-1.8.34,1,1,0,0,1-.31-1.49,9,9,0,0,0,1.69-3.09c1.6-3.67,3-7.4,4.54-11.11a1.52,1.52,0,0,0,0-1.13,147.39,147.39,0,0,1-4.86-16.6c-.17-.72-.18-.73-.81-.37a62.64,62.64,0,0,0-6.16,3.77c-.3.22-.44.4-.22.75a.8.8,0,0,1,0,.79c-1,1.89-1.19,4-1.52,6.06-.08.48-.13,1-.21,1.53a9.12,9.12,0,0,1,1.18-.89,1.75,1.75,0,0,1,2.48.76,4.81,4.81,0,0,1,.49,3,10.37,10.37,0,0,1-1,3.39,2.06,2.06,0,0,1-1.26,1.14,1.21,1.21,0,0,1-1.38-.49,1.12,1.12,0,0,1,.25-1.38c.95-1.07,1-2.4,1.11-3.82a1.14,1.14,0,0,0-.65.6,11.12,11.12,0,0,0-2.39,4.73,10.31,10.31,0,0,1-.7,2.23A1.8,1.8,0,0,1,110,45a1.15,1.15,0,0,1-1.77-.44,1.77,1.77,0,0,1-.13-1.24,7.9,7.9,0,0,1,.68-2,12.76,12.76,0,0,0,1.11-4.32,52.64,52.64,0,0,1,1.66-8.81c.11-.32,0-.39-.3-.43a1,1,0,0,1-.86-.83,1,1,0,0,1,.44-1.07,67.81,67.81,0,0,1,7.28-5c.71-.4,1.4-.82,2.13-1.2a.6.6,0,0,0,.37-.78,58.43,58.43,0,0,0-2-7.26,6.07,6.07,0,0,0-.24-.59,1,1,0,0,1,.32-1.47,1.13,1.13,0,0,1,1.55.48,8.19,8.19,0,0,1,.5,1.18,53.65,53.65,0,0,1,1.85,6.19c.2.8.2.79.94.38a8.5,8.5,0,0,1,1.09-.54,1.12,1.12,0,0,1,1.48.54,1.14,1.14,0,0,1-.54,1.53c-.56.31-1.12.63-1.69.92a.68.68,0,0,0-.39.89c.81,3.56,1.72,7.1,2.78,10.59.4,1.32.84,2.63,1.27,3.94C127.65,35.73,127.65,35.94,127.86,36.09Z",
        className: " scale-110 -translate-x-[14px] -translate-y-2",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ We.jsx(
      "path",
      {
        d: "M135,9a1,1,0,0,1-1.26,1,2,2,0,0,1-1.29-1.09,10.24,10.24,0,0,0-1.22-1.9,1.07,1.07,0,0,1,.13-1.68,1.22,1.22,0,0,1,1.66.43c.66.84,1.09,1.83,1.75,2.66A1.18,1.18,0,0,1,135,9Z",
        className: " scale-110 -translate-x-[18px] -translate-y-[6px]",
        transform: "translate(-3.28 -5.08)"
      }
    )
  ] })
] }), Wre = (r, e, t, n) => {
  const i = [t, {
    code: e,
    ...n || {}
  }];
  if (r?.services?.logger?.forward)
    return r.services.logger.forward(i, "warn", "react-i18next::", !0);
  Gb(i[0]) && (i[0] = `react-i18next:: ${i[0]}`), r?.services?.logger?.warn ? r.services.logger.warn(...i) : console?.warn && console.warn(...i);
}, R_ = {}, BX = (r, e, t, n) => {
  Gb(t) && R_[t] || (Gb(t) && (R_[t] = /* @__PURE__ */ new Date()), Wre(r, e, t, n));
}, Tk = (r, e) => () => {
  if (r.isInitialized)
    e();
  else {
    const t = () => {
      setTimeout(() => {
        r.off("initialized", t);
      }, 0), e();
    };
    r.on("initialized", t);
  }
}, SX = (r, e, t) => {
  r.loadNamespaces(e, Tk(r, t));
}, x_ = (r, e, t, n) => {
  if (Gb(t) && (t = [t]), r.options.preload && r.options.preload.indexOf(e) > -1) return SX(r, t, n);
  t.forEach((i) => {
    r.options.ns.indexOf(i) < 0 && r.options.ns.push(i);
  }), r.loadLanguages(e, Tk(r, n));
}, Vre = (r, e, t = {}) => !e.languages || !e.languages.length ? (BX(e, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
  languages: e.languages
}), !0) : e.hasLoadedNamespace(r, {
  lng: t.lng,
  precheck: (n, i) => {
    if (t.bindI18n?.indexOf("languageChanging") > -1 && n.services.backendConnector.backend && n.isLanguageChangingTo && !i(n.isLanguageChangingTo, r)) return !1;
  }
}), Gb = (r) => typeof r == "string", Nre = (r) => typeof r == "object" && r !== null, Mre = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, Hre = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
}, Xre = (r) => Hre[r], Yre = (r) => r.replace(Mre, Xre);
let ZX = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: Yre
};
const Fre = (r = {}) => {
  ZX = {
    ...ZX,
    ...r
  };
}, Ere = () => ZX;
let _k;
const Tre = (r) => {
  _k = r;
}, _re = () => _k, zre = {
  type: "3rdParty",
  init(r) {
    Fre(r.options.react), Tre(r);
  }
}, Kre = ye.createContext();
class Lre {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(e) {
    e.forEach((t) => {
      this.usedNamespaces[t] || (this.usedNamespaces[t] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const kre = (r, e) => {
  const t = ye.useRef();
  return ye.useEffect(() => {
    t.current = r;
  }, [r, e]), t.current;
}, zk = (r, e, t, n) => r.getFixedT(e, t, n), Dre = (r, e, t, n) => ye.useCallback(zk(r, e, t, n), [r, e, t, n]), Uu = (r, e = {}) => {
  const {
    i18n: t
  } = e, {
    i18n: n,
    defaultNS: i
  } = ye.useContext(Kre) || {}, o = t || n || _re();
  if (o && !o.reportNamespaces && (o.reportNamespaces = new Lre()), !o) {
    BX(o, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
    const T = (D, L) => Gb(L) ? L : Nre(L) && Gb(L.defaultValue) ? L.defaultValue : Array.isArray(D) ? D[D.length - 1] : D, P = [T, {}, !1];
    return P.t = T, P.i18n = {}, P.ready = !1, P;
  }
  o.options.react?.wait && BX(o, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const l = {
    ...Ere(),
    ...o.options.react,
    ...e
  }, {
    useSuspense: u,
    keyPrefix: I
  } = l;
  let C = i || o.options?.defaultNS;
  C = Gb(C) ? [C] : C || ["translation"], o.reportNamespaces.addUsedNamespaces?.(C);
  const f = (o.isInitialized || o.initializedStoreOnce) && C.every((T) => Vre(T, o, l)), v = Dre(o, e.lng || null, l.nsMode === "fallback" ? C : C[0], I), b = () => v, S = () => zk(o, e.lng || null, l.nsMode === "fallback" ? C : C[0], I), [R, W] = ye.useState(b);
  let x = C.join();
  e.lng && (x = `${e.lng}${x}`);
  const N = kre(x), Y = ye.useRef(!0);
  ye.useEffect(() => {
    const {
      bindI18n: T,
      bindI18nStore: P
    } = l;
    Y.current = !0, !f && !u && (e.lng ? x_(o, e.lng, C, () => {
      Y.current && W(S);
    }) : SX(o, C, () => {
      Y.current && W(S);
    })), f && N && N !== x && Y.current && W(S);
    const D = () => {
      Y.current && W(S);
    };
    return T && o?.on(T, D), P && o?.store.on(P, D), () => {
      Y.current = !1, o && T?.split(" ").forEach((L) => o.off(L, D)), P && o && P.split(" ").forEach((L) => o.store.off(L, D));
    };
  }, [o, x]), ye.useEffect(() => {
    Y.current && f && W(b);
  }, [o, I, f]);
  const F = [R, o, f];
  if (F.t = R, F.i18n = o, F.ready = f, f || !f && !u) return F;
  throw new Promise((T) => {
    e.lng ? x_(o, e.lng, C, () => T()) : SX(o, C, () => T());
  });
};
var Kk = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, W_ = wc.createContext && /* @__PURE__ */ wc.createContext(Kk), Ure = ["attr", "size", "title"];
function Ore(r, e) {
  if (r == null) return {};
  var t = Pre(r, e), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(r);
    for (i = 0; i < o.length; i++)
      n = o[i], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (t[n] = r[n]);
  }
  return t;
}
function Pre(r, e) {
  if (r == null) return {};
  var t = {};
  for (var n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      if (e.indexOf(n) >= 0) continue;
      t[n] = r[n];
    }
  return t;
}
function dW() {
  return dW = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, dW.apply(this, arguments);
}
function V_(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function IW(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? V_(Object(t), !0).forEach(function(n) {
      Jre(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : V_(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Jre(r, e, t) {
  return e = Qre(e), e in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function Qre(r) {
  var e = jre(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function jre(r, e) {
  if (typeof r != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Lk(r) {
  return r && r.map((e, t) => /* @__PURE__ */ wc.createElement(e.tag, IW({
    key: t
  }, e.attr), Lk(e.child)));
}
function Eb(r) {
  return (e) => /* @__PURE__ */ wc.createElement(qre, dW({
    attr: IW({}, r.attr)
  }, e), Lk(r.child));
}
function qre(r) {
  var e = (t) => {
    var {
      attr: n,
      size: i,
      title: o
    } = r, l = Ore(r, Ure), u = i || t.size || "1em", I;
    return t.className && (I = t.className), r.className && (I = (I ? I + " " : "") + r.className), /* @__PURE__ */ wc.createElement("svg", dW({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, t.attr, n, l, {
      className: I,
      style: IW(IW({
        color: r.color || t.color
      }, t.style), r.style),
      height: u,
      width: u,
      xmlns: "http://www.w3.org/2000/svg"
    }), o && /* @__PURE__ */ wc.createElement("title", null, o), r.children);
  };
  return W_ !== void 0 ? /* @__PURE__ */ wc.createElement(W_.Consumer, null, (t) => e(t)) : e(Kk);
}
function $re(r) {
  return Eb({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z" }, child: [] }] })(r);
}
function eae(r) {
  return Eb({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z" }, child: [] }] })(r);
}
function tae(r) {
  return Eb({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M480 416v16c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V176c0-26.51 21.49-48 48-48h16v48H54a6 6 0 0 0-6 6v244a6 6 0 0 0 6 6h372a6 6 0 0 0 6-6v-10h48zm42-336H150a6 6 0 0 0-6 6v244a6 6 0 0 0 6 6h372a6 6 0 0 0 6-6V86a6 6 0 0 0-6-6zm6-48c26.51 0 48 21.49 48 48v256c0 26.51-21.49 48-48 48H144c-26.51 0-48-21.49-48-48V80c0-26.51 21.49-48 48-48h384zM264 144c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.909-40 40-40 40 17.909 40 40zm-72 96l39.515-39.515c4.686-4.686 12.284-4.686 16.971 0L288 240l103.515-103.515c4.686-4.686 12.284-4.686 16.971 0L480 208v80H192v-48z" }, child: [] }] })(r);
}
const nae = (r, e, t = []) => {
  const { current: n } = ye.useRef({ callback: r, timer: null });
  return ye.useEffect(() => {
    n.callback = r;
  }, [r]), ye.useCallback((...i) => {
    n.timer || (n.timer = setTimeout(() => {
      n.timer = null;
    }, e), n.callback(...i));
  }, t);
}, iae = ({ url: r, children: e }) => {
  const { t } = Uu(), n = Wb(), o = rd().pathname === r, { width: l } = Yb(), u = nae(() => {
    n(o ? lg.HOME : r);
  }, 400);
  return /* @__PURE__ */ We.jsx("button", { className: `linkBtn${o ? "--active" : ""}`, onClick: u, children: o && l > AB ? /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
    /* @__PURE__ */ We.jsx(eae, { size: "14px" }),
    t("nav_home")
  ] }) : t(e) });
}, ar = (r) => typeof r == "string", KZ = () => {
  let r, e;
  const t = new Promise((n, i) => {
    r = n, e = i;
  });
  return t.resolve = r, t.reject = e, t;
}, N_ = (r) => r == null ? "" : "" + r, rae = (r, e, t) => {
  r.forEach((n) => {
    e[n] && (t[n] = e[n]);
  });
}, aae = /###/g, M_ = (r) => r && r.indexOf("###") > -1 ? r.replace(aae, ".") : r, H_ = (r) => !r || ar(r), cw = (r, e, t) => {
  const n = ar(e) ? e.split(".") : e;
  let i = 0;
  for (; i < n.length - 1; ) {
    if (H_(r)) return {};
    const o = M_(n[i]);
    !r[o] && t && (r[o] = new t()), Object.prototype.hasOwnProperty.call(r, o) ? r = r[o] : r = {}, ++i;
  }
  return H_(r) ? {} : {
    obj: r,
    k: M_(n[i])
  };
}, X_ = (r, e, t) => {
  const {
    obj: n,
    k: i
  } = cw(r, e, Object);
  if (n !== void 0 || e.length === 1) {
    n[i] = t;
    return;
  }
  let o = e[e.length - 1], l = e.slice(0, e.length - 1), u = cw(r, l, Object);
  for (; u.obj === void 0 && l.length; )
    o = `${l[l.length - 1]}.${o}`, l = l.slice(0, l.length - 1), u = cw(r, l, Object), u && u.obj && typeof u.obj[`${u.k}.${o}`] < "u" && (u.obj = void 0);
  u.obj[`${u.k}.${o}`] = t;
}, oae = (r, e, t, n) => {
  const {
    obj: i,
    k: o
  } = cw(r, e, Object);
  i[o] = i[o] || [], i[o].push(t);
}, CW = (r, e) => {
  const {
    obj: t,
    k: n
  } = cw(r, e);
  if (t)
    return t[n];
}, sae = (r, e, t) => {
  const n = CW(r, t);
  return n !== void 0 ? n : CW(e, t);
}, kk = (r, e, t) => {
  for (const n in e)
    n !== "__proto__" && n !== "constructor" && (n in r ? ar(r[n]) || r[n] instanceof String || ar(e[n]) || e[n] instanceof String ? t && (r[n] = e[n]) : kk(r[n], e[n], t) : r[n] = e[n]);
  return r;
}, UG = (r) => r.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var lae = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const uae = (r) => ar(r) ? r.replace(/[&<>"'\/]/g, (e) => lae[e]) : r;
class cae {
  constructor(e) {
    this.capacity = e, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(e) {
    const t = this.regExpMap.get(e);
    if (t !== void 0)
      return t;
    const n = new RegExp(e);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, n), this.regExpQueue.push(e), n;
  }
}
const gae = [" ", ",", "?", "!", ";"], dae = new cae(20), Iae = (r, e, t) => {
  e = e || "", t = t || "";
  const n = gae.filter((l) => e.indexOf(l) < 0 && t.indexOf(l) < 0);
  if (n.length === 0) return !0;
  const i = dae.getRegExp(`(${n.map((l) => l === "?" ? "\\?" : l).join("|")})`);
  let o = !i.test(r);
  if (!o) {
    const l = r.indexOf(t);
    l > 0 && !i.test(r.substring(0, l)) && (o = !0);
  }
  return o;
}, wX = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!r) return;
  if (r[e]) return r[e];
  const n = e.split(t);
  let i = r;
  for (let o = 0; o < n.length; ) {
    if (!i || typeof i != "object")
      return;
    let l, u = "";
    for (let I = o; I < n.length; ++I)
      if (I !== o && (u += t), u += n[I], l = i[u], l !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof l) > -1 && I < n.length - 1)
          continue;
        o += I - o + 1;
        break;
      }
    i = l;
  }
  return i;
}, hW = (r) => r && r.replace("_", "-"), Cae = {
  type: "logger",
  log(r) {
    this.output("log", r);
  },
  warn(r) {
    this.output("warn", r);
  },
  error(r) {
    this.output("error", r);
  },
  output(r, e) {
    console && console[r] && console[r].apply(console, e);
  }
};
class fW {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(e, t);
  }
  init(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = t.prefix || "i18next:", this.logger = e || Cae, this.options = t, this.debug = t.debug;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "log", "", !0);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "", !0);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(e, t, n, i) {
    return i && !this.debug ? null : (ar(e[0]) && (e[0] = `${n}${this.prefix} ${e[0]}`), this.logger[t](e));
  }
  create(e) {
    return new fW(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options
    });
  }
  clone(e) {
    return e = e || this.options, e.prefix = e.prefix || this.prefix, new fW(this.logger, e);
  }
}
var lp = new fW();
class fV {
  constructor() {
    this.observers = {};
  }
  on(e, t) {
    return e.split(" ").forEach((n) => {
      this.observers[n] || (this.observers[n] = /* @__PURE__ */ new Map());
      const i = this.observers[n].get(t) || 0;
      this.observers[n].set(t, i + 1);
    }), this;
  }
  off(e, t) {
    if (this.observers[e]) {
      if (!t) {
        delete this.observers[e];
        return;
      }
      this.observers[e].delete(t);
    }
  }
  emit(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    this.observers[e] && Array.from(this.observers[e].entries()).forEach((l) => {
      let [u, I] = l;
      for (let C = 0; C < I; C++)
        u(...n);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((l) => {
      let [u, I] = l;
      for (let C = 0; C < I; C++)
        u.apply(u, [e, ...n]);
    });
  }
}
class Y_ extends fV {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const t = this.options.ns.indexOf(e);
    t > -1 && this.options.ns.splice(t, 1);
  }
  getResource(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, l = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let u;
    e.indexOf(".") > -1 ? u = e.split(".") : (u = [e, t], n && (Array.isArray(n) ? u.push(...n) : ar(n) && o ? u.push(...n.split(o)) : u.push(n)));
    const I = CW(this.data, u);
    return !I && !t && !n && e.indexOf(".") > -1 && (e = u[0], t = u[1], n = u.slice(2).join(".")), I || !l || !ar(n) ? I : wX(this.data && this.data[e] && this.data[e][t], n, o);
  }
  addResource(e, t, n, i) {
    let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const l = o.keySeparator !== void 0 ? o.keySeparator : this.options.keySeparator;
    let u = [e, t];
    n && (u = u.concat(l ? n.split(l) : n)), e.indexOf(".") > -1 && (u = e.split("."), i = t, t = u[1]), this.addNamespaces(t), X_(this.data, u, i), o.silent || this.emit("added", e, t, n, i);
  }
  addResources(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const o in n)
      (ar(n[o]) || Array.isArray(n[o])) && this.addResource(e, t, o, n[o], {
        silent: !0
      });
    i.silent || this.emit("added", e, t, n);
  }
  addResourceBundle(e, t, n, i, o) {
    let l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, u = [e, t];
    e.indexOf(".") > -1 && (u = e.split("."), i = n, n = t, t = u[1]), this.addNamespaces(t);
    let I = CW(this.data, u) || {};
    l.skipCopy || (n = JSON.parse(JSON.stringify(n))), i ? kk(I, n, o) : I = {
      ...I,
      ...n
    }, X_(this.data, u, I), l.silent || this.emit("added", e, t, n);
  }
  removeResourceBundle(e, t) {
    this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t);
  }
  hasResourceBundle(e, t) {
    return this.getResource(e, t) !== void 0;
  }
  getResourceBundle(e, t) {
    return t || (t = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(e, t)
    } : this.getResource(e, t);
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const t = this.getDataByLanguage(e);
    return !!(t && Object.keys(t) || []).find((i) => t[i] && Object.keys(t[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var Dk = {
  processors: {},
  addPostProcessor(r) {
    this.processors[r.name] = r;
  },
  handle(r, e, t, n, i) {
    return r.forEach((o) => {
      this.processors[o] && (e = this.processors[o].process(e, t, n, i));
    }), e;
  }
};
const F_ = {};
class pW extends fV {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), rae(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = lp.create("translator");
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (e == null)
      return !1;
    const n = this.resolve(e, t);
    return n && n.res !== void 0;
  }
  extractFromKey(e, t) {
    let n = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
    n === void 0 && (n = ":");
    const i = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator;
    let o = t.ns || this.options.defaultNS || [];
    const l = n && e.indexOf(n) > -1, u = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !Iae(e, n, i);
    if (l && !u) {
      const I = e.match(this.interpolator.nestingRegexp);
      if (I && I.length > 0)
        return {
          key: e,
          namespaces: ar(o) ? [o] : o
        };
      const C = e.split(n);
      (n !== i || n === i && this.options.ns.indexOf(C[0]) > -1) && (o = C.shift()), e = C.join(i);
    }
    return {
      key: e,
      namespaces: ar(o) ? [o] : o
    };
  }
  translate(e, t, n) {
    if (typeof t != "object" && this.options.overloadTranslationOptionHandler && (t = this.options.overloadTranslationOptionHandler(arguments)), typeof t == "object" && (t = {
      ...t
    }), t || (t = {}), e == null) return "";
    Array.isArray(e) || (e = [String(e)]);
    const i = t.returnDetails !== void 0 ? t.returnDetails : this.options.returnDetails, o = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator, {
      key: l,
      namespaces: u
    } = this.extractFromKey(e[e.length - 1], t), I = u[u.length - 1], C = t.lng || this.language, f = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (C && C.toLowerCase() === "cimode") {
      if (f) {
        const T = t.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${I}${T}${l}`,
          usedKey: l,
          exactUsedKey: l,
          usedLng: C,
          usedNS: I,
          usedParams: this.getUsedParamsDetails(t)
        } : `${I}${T}${l}`;
      }
      return i ? {
        res: l,
        usedKey: l,
        exactUsedKey: l,
        usedLng: C,
        usedNS: I,
        usedParams: this.getUsedParamsDetails(t)
      } : l;
    }
    const v = this.resolve(e, t);
    let b = v && v.res;
    const S = v && v.usedKey || l, R = v && v.exactUsedKey || l, W = Object.prototype.toString.apply(b), x = ["[object Number]", "[object Function]", "[object RegExp]"], N = t.joinArrays !== void 0 ? t.joinArrays : this.options.joinArrays, Y = !this.i18nFormat || this.i18nFormat.handleAsObject, F = !ar(b) && typeof b != "boolean" && typeof b != "number";
    if (Y && b && F && x.indexOf(W) < 0 && !(ar(N) && Array.isArray(b))) {
      if (!t.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const T = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(S, b, {
          ...t,
          ns: u
        }) : `key '${l} (${this.language})' returned an object instead of string.`;
        return i ? (v.res = T, v.usedParams = this.getUsedParamsDetails(t), v) : T;
      }
      if (o) {
        const T = Array.isArray(b), P = T ? [] : {}, D = T ? R : S;
        for (const L in b)
          if (Object.prototype.hasOwnProperty.call(b, L)) {
            const j = `${D}${o}${L}`;
            P[L] = this.translate(j, {
              ...t,
              joinArrays: !1,
              ns: u
            }), P[L] === j && (P[L] = b[L]);
          }
        b = P;
      }
    } else if (Y && ar(N) && Array.isArray(b))
      b = b.join(N), b && (b = this.extendTranslation(b, e, t, n));
    else {
      let T = !1, P = !1;
      const D = t.count !== void 0 && !ar(t.count), L = pW.hasDefaultValue(t), j = D ? this.pluralResolver.getSuffix(C, t.count, t) : "", J = t.ordinal && D ? this.pluralResolver.getSuffix(C, t.count, {
        ordinal: !1
      }) : "", O = D && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), ne = O && t[`defaultValue${this.options.pluralSeparator}zero`] || t[`defaultValue${j}`] || t[`defaultValue${J}`] || t.defaultValue;
      !this.isValidLookup(b) && L && (T = !0, b = ne), this.isValidLookup(b) || (P = !0, b = l);
      const pe = (t.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && P ? void 0 : b, Ae = L && ne !== b && this.options.updateMissing;
      if (P || T || Ae) {
        if (this.logger.log(Ae ? "updateKey" : "missingKey", C, I, l, Ae ? ne : b), o) {
          const re = this.resolve(l, {
            ...t,
            keySeparator: !1
          });
          re && re.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let ke = [];
        const Re = this.languageUtils.getFallbackCodes(this.options.fallbackLng, t.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && Re && Re[0])
          for (let re = 0; re < Re.length; re++)
            ke.push(Re[re]);
        else this.options.saveMissingTo === "all" ? ke = this.languageUtils.toResolveHierarchy(t.lng || this.language) : ke.push(t.lng || this.language);
        const Xe = (re, Se, Be) => {
          const le = L && Be !== b ? Be : pe;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(re, I, Se, le, Ae, t) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(re, I, Se, le, Ae, t), this.emit("missingKey", re, I, Se, b);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && D ? ke.forEach((re) => {
          const Se = this.pluralResolver.getSuffixes(re, t);
          O && t[`defaultValue${this.options.pluralSeparator}zero`] && Se.indexOf(`${this.options.pluralSeparator}zero`) < 0 && Se.push(`${this.options.pluralSeparator}zero`), Se.forEach((Be) => {
            Xe([re], l + Be, t[`defaultValue${Be}`] || ne);
          });
        }) : Xe(ke, l, ne));
      }
      b = this.extendTranslation(b, e, t, v, n), P && b === l && this.options.appendNamespaceToMissingKey && (b = `${I}:${l}`), (P || T) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? b = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${I}:${l}` : l, T ? b : void 0) : b = this.options.parseMissingKeyHandler(b));
    }
    return i ? (v.res = b, v.usedParams = this.getUsedParamsDetails(t), v) : b;
  }
  extendTranslation(e, t, n, i, o) {
    var l = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e = this.i18nFormat.parse(e, {
        ...this.options.interpolation.defaultVariables,
        ...n
      }, n.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!n.skipInterpolation) {
      n.interpolation && this.interpolator.init({
        ...n,
        interpolation: {
          ...this.options.interpolation,
          ...n.interpolation
        }
      });
      const C = ar(e) && (n && n.interpolation && n.interpolation.skipOnVariables !== void 0 ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let f;
      if (C) {
        const b = e.match(this.interpolator.nestingRegexp);
        f = b && b.length;
      }
      let v = n.replace && !ar(n.replace) ? n.replace : n;
      if (this.options.interpolation.defaultVariables && (v = {
        ...this.options.interpolation.defaultVariables,
        ...v
      }), e = this.interpolator.interpolate(e, v, n.lng || this.language || i.usedLng, n), C) {
        const b = e.match(this.interpolator.nestingRegexp), S = b && b.length;
        f < S && (n.nest = !1);
      }
      !n.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (n.lng = this.language || i.usedLng), n.nest !== !1 && (e = this.interpolator.nest(e, function() {
        for (var b = arguments.length, S = new Array(b), R = 0; R < b; R++)
          S[R] = arguments[R];
        return o && o[0] === S[0] && !n.context ? (l.logger.warn(`It seems you are nesting recursively key: ${S[0]} in key: ${t[0]}`), null) : l.translate(...S, t);
      }, n)), n.interpolation && this.interpolator.reset();
    }
    const u = n.postProcess || this.options.postProcess, I = ar(u) ? [u] : u;
    return e != null && I && I.length && n.applyPostProcessor !== !1 && (e = Dk.handle(I, e, t, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(n)
      },
      ...n
    } : n, this)), e;
  }
  resolve(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n, i, o, l, u;
    return ar(e) && (e = [e]), e.forEach((I) => {
      if (this.isValidLookup(n)) return;
      const C = this.extractFromKey(I, t), f = C.key;
      i = f;
      let v = C.namespaces;
      this.options.fallbackNS && (v = v.concat(this.options.fallbackNS));
      const b = t.count !== void 0 && !ar(t.count), S = b && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), R = t.context !== void 0 && (ar(t.context) || typeof t.context == "number") && t.context !== "", W = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng);
      v.forEach((x) => {
        this.isValidLookup(n) || (u = x, !F_[`${W[0]}-${x}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(u) && (F_[`${W[0]}-${x}`] = !0, this.logger.warn(`key "${i}" for languages "${W.join(", ")}" won't get resolved as namespace "${u}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), W.forEach((N) => {
          if (this.isValidLookup(n)) return;
          l = N;
          const Y = [f];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(Y, f, N, x, t);
          else {
            let T;
            b && (T = this.pluralResolver.getSuffix(N, t.count, t));
            const P = `${this.options.pluralSeparator}zero`, D = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (b && (Y.push(f + T), t.ordinal && T.indexOf(D) === 0 && Y.push(f + T.replace(D, this.options.pluralSeparator)), S && Y.push(f + P)), R) {
              const L = `${f}${this.options.contextSeparator}${t.context}`;
              Y.push(L), b && (Y.push(L + T), t.ordinal && T.indexOf(D) === 0 && Y.push(L + T.replace(D, this.options.pluralSeparator)), S && Y.push(L + P));
            }
          }
          let F;
          for (; F = Y.pop(); )
            this.isValidLookup(n) || (o = F, n = this.getResource(N, x, F, t));
        }));
      });
    }), {
      res: n,
      usedKey: i,
      exactUsedKey: o,
      usedLng: l,
      usedNS: u
    };
  }
  isValidLookup(e) {
    return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "");
  }
  getResource(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, i) : this.resourceStore.getResource(e, t, n, i);
  }
  getUsedParamsDetails() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], n = e.replace && !ar(e.replace);
    let i = n ? e.replace : e;
    if (n && typeof e.count < "u" && (i.count = e.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !n) {
      i = {
        ...i
      };
      for (const o of t)
        delete i[o];
    }
    return i;
  }
  static hasDefaultValue(e) {
    const t = "defaultValue";
    for (const n in e)
      if (Object.prototype.hasOwnProperty.call(e, n) && t === n.substring(0, t.length) && e[n] !== void 0)
        return !0;
    return !1;
  }
}
const VH = (r) => r.charAt(0).toUpperCase() + r.slice(1);
class E_ {
  constructor(e) {
    this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = lp.create("languageUtils");
  }
  getScriptPartFromCode(e) {
    if (e = hW(e), !e || e.indexOf("-") < 0) return null;
    const t = e.split("-");
    return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(t.join("-"));
  }
  getLanguagePartFromCode(e) {
    if (e = hW(e), !e || e.indexOf("-") < 0) return e;
    const t = e.split("-");
    return this.formatLanguageCode(t[0]);
  }
  formatLanguageCode(e) {
    if (ar(e) && e.indexOf("-") > -1) {
      if (typeof Intl < "u" && typeof Intl.getCanonicalLocales < "u")
        try {
          let i = Intl.getCanonicalLocales(e)[0];
          if (i && this.options.lowerCaseLng && (i = i.toLowerCase()), i) return i;
        } catch {
        }
      const t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let n = e.split("-");
      return this.options.lowerCaseLng ? n = n.map((i) => i.toLowerCase()) : n.length === 2 ? (n[0] = n[0].toLowerCase(), n[1] = n[1].toUpperCase(), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = VH(n[1].toLowerCase()))) : n.length === 3 && (n[0] = n[0].toLowerCase(), n[1].length === 2 && (n[1] = n[1].toUpperCase()), n[0] !== "sgn" && n[2].length === 2 && (n[2] = n[2].toUpperCase()), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = VH(n[1].toLowerCase())), t.indexOf(n[2].toLowerCase()) > -1 && (n[2] = VH(n[2].toLowerCase()))), n.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e;
  }
  isSupportedCode(e) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1;
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let t;
    return e.forEach((n) => {
      if (t) return;
      const i = this.formatLanguageCode(n);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (t = i);
    }), !t && this.options.supportedLngs && e.forEach((n) => {
      if (t) return;
      const i = this.getLanguagePartFromCode(n);
      if (this.isSupportedCode(i)) return t = i;
      t = this.options.supportedLngs.find((o) => {
        if (o === i) return o;
        if (!(o.indexOf("-") < 0 && i.indexOf("-") < 0) && (o.indexOf("-") > 0 && i.indexOf("-") < 0 && o.substring(0, o.indexOf("-")) === i || o.indexOf(i) === 0 && i.length > 1))
          return o;
      });
    }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t;
  }
  getFallbackCodes(e, t) {
    if (!e) return [];
    if (typeof e == "function" && (e = e(t)), ar(e) && (e = [e]), Array.isArray(e)) return e;
    if (!t) return e.default || [];
    let n = e[t];
    return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [];
  }
  toResolveHierarchy(e, t) {
    const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e), i = [], o = (l) => {
      l && (this.isSupportedCode(l) ? i.push(l) : this.logger.warn(`rejecting language code not found in supportedLngs: ${l}`));
    };
    return ar(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(e))) : ar(e) && o(this.formatLanguageCode(e)), n.forEach((l) => {
      i.indexOf(l) < 0 && o(this.formatLanguageCode(l));
    }), i;
  }
}
let hae = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], fae = {
  1: (r) => +(r > 1),
  2: (r) => +(r != 1),
  3: (r) => 0,
  4: (r) => r % 10 == 1 && r % 100 != 11 ? 0 : r % 10 >= 2 && r % 10 <= 4 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2,
  5: (r) => r == 0 ? 0 : r == 1 ? 1 : r == 2 ? 2 : r % 100 >= 3 && r % 100 <= 10 ? 3 : r % 100 >= 11 ? 4 : 5,
  6: (r) => r == 1 ? 0 : r >= 2 && r <= 4 ? 1 : 2,
  7: (r) => r == 1 ? 0 : r % 10 >= 2 && r % 10 <= 4 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2,
  8: (r) => r == 1 ? 0 : r == 2 ? 1 : r != 8 && r != 11 ? 2 : 3,
  9: (r) => +(r >= 2),
  10: (r) => r == 1 ? 0 : r == 2 ? 1 : r < 7 ? 2 : r < 11 ? 3 : 4,
  11: (r) => r == 1 || r == 11 ? 0 : r == 2 || r == 12 ? 1 : r > 2 && r < 20 ? 2 : 3,
  12: (r) => +(r % 10 != 1 || r % 100 == 11),
  13: (r) => +(r !== 0),
  14: (r) => r == 1 ? 0 : r == 2 ? 1 : r == 3 ? 2 : 3,
  15: (r) => r % 10 == 1 && r % 100 != 11 ? 0 : r % 10 >= 2 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2,
  16: (r) => r % 10 == 1 && r % 100 != 11 ? 0 : r !== 0 ? 1 : 2,
  17: (r) => r == 1 || r % 10 == 1 && r % 100 != 11 ? 0 : 1,
  18: (r) => r == 0 ? 0 : r == 1 ? 1 : 2,
  19: (r) => r == 1 ? 0 : r == 0 || r % 100 > 1 && r % 100 < 11 ? 1 : r % 100 > 10 && r % 100 < 20 ? 2 : 3,
  20: (r) => r == 1 ? 0 : r == 0 || r % 100 > 0 && r % 100 < 20 ? 1 : 2,
  21: (r) => r % 100 == 1 ? 1 : r % 100 == 2 ? 2 : r % 100 == 3 || r % 100 == 4 ? 3 : 0,
  22: (r) => r == 1 ? 0 : r == 2 ? 1 : (r < 0 || r > 10) && r % 10 == 0 ? 2 : 3
};
const pae = ["v1", "v2", "v3"], mae = ["v4"], T_ = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, Aae = () => {
  const r = {};
  return hae.forEach((e) => {
    e.lngs.forEach((t) => {
      r[t] = {
        numbers: e.nr,
        plurals: fae[e.fc]
      };
    });
  }), r;
};
class vae {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = e, this.options = t, this.logger = lp.create("pluralResolver"), (!this.options.compatibilityJSON || mae.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = Aae(), this.pluralRulesCache = {};
  }
  addRule(e, t) {
    this.rules[e] = t;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      const n = hW(e === "dev" ? "en" : e), i = t.ordinal ? "ordinal" : "cardinal", o = JSON.stringify({
        cleanedCode: n,
        type: i
      });
      if (o in this.pluralRulesCache)
        return this.pluralRulesCache[o];
      let l;
      try {
        l = new Intl.PluralRules(n, {
          type: i
        });
      } catch {
        if (!e.match(/-|_/)) return;
        const I = this.languageUtils.getLanguagePartFromCode(e);
        l = this.getRule(I, t);
      }
      return this.pluralRulesCache[o] = l, l;
    }
    return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)];
  }
  needsPlural(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return this.shouldUseIntlApi() ? n && n.resolvedOptions().pluralCategories.length > 1 : n && n.numbers.length > 1;
  }
  getPluralFormsOfKey(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(e, n).map((i) => `${t}${i}`);
  }
  getSuffixes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return n ? this.shouldUseIntlApi() ? n.resolvedOptions().pluralCategories.sort((i, o) => T_[i] - T_[o]).map((i) => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : n.numbers.map((i) => this.getSuffix(e, i, t)) : [];
  }
  getSuffix(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(e, n);
    return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(t)}` : this.getSuffixRetroCompatible(i, t) : (this.logger.warn(`no plural rule found for: ${e}`), "");
  }
  getSuffixRetroCompatible(e, t) {
    const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
    let i = e.numbers[n];
    this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
    const o = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : o() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? o() : this.options.prepend && n.toString() ? this.options.prepend + n.toString() : n.toString();
  }
  shouldUseIntlApi() {
    return !pae.includes(this.options.compatibilityJSON);
  }
}
const __ = function(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, o = sae(r, e, t);
  return !o && i && ar(t) && (o = wX(r, t, n), o === void 0 && (o = wX(e, t, n))), o;
}, NH = (r) => r.replace(/\$/g, "$$$$");
class yae {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = lp.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || ((t) => t), this.init(e);
  }
  init() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e.interpolation || (e.interpolation = {
      escapeValue: !0
    });
    const {
      escape: t,
      escapeValue: n,
      useRawValueToEscape: i,
      prefix: o,
      prefixEscaped: l,
      suffix: u,
      suffixEscaped: I,
      formatSeparator: C,
      unescapeSuffix: f,
      unescapePrefix: v,
      nestingPrefix: b,
      nestingPrefixEscaped: S,
      nestingSuffix: R,
      nestingSuffixEscaped: W,
      nestingOptionsSeparator: x,
      maxReplaces: N,
      alwaysFormat: Y
    } = e.interpolation;
    this.escape = t !== void 0 ? t : uae, this.escapeValue = n !== void 0 ? n : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = o ? UG(o) : l || "{{", this.suffix = u ? UG(u) : I || "}}", this.formatSeparator = C || ",", this.unescapePrefix = f ? "" : v || "-", this.unescapeSuffix = this.unescapePrefix ? "" : f || "", this.nestingPrefix = b ? UG(b) : S || UG("$t("), this.nestingSuffix = R ? UG(R) : W || UG(")"), this.nestingOptionsSeparator = x || ",", this.maxReplaces = N || 1e3, this.alwaysFormat = Y !== void 0 ? Y : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (t, n) => t && t.source === n ? (t.lastIndex = 0, t) : new RegExp(n, "g");
    this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(e, t, n, i) {
    let o, l, u;
    const I = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, C = (S) => {
      if (S.indexOf(this.formatSeparator) < 0) {
        const N = __(t, I, S, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(N, void 0, n, {
          ...i,
          ...t,
          interpolationkey: S
        }) : N;
      }
      const R = S.split(this.formatSeparator), W = R.shift().trim(), x = R.join(this.formatSeparator).trim();
      return this.format(__(t, I, W, this.options.keySeparator, this.options.ignoreJSONStructure), x, n, {
        ...i,
        ...t,
        interpolationkey: W
      });
    };
    this.resetRegExp();
    const f = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler, v = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (S) => NH(S)
    }, {
      regex: this.regexp,
      safeValue: (S) => this.escapeValue ? NH(this.escape(S)) : NH(S)
    }].forEach((S) => {
      for (u = 0; o = S.regex.exec(e); ) {
        const R = o[1].trim();
        if (l = C(R), l === void 0)
          if (typeof f == "function") {
            const x = f(e, o, i);
            l = ar(x) ? x : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, R))
            l = "";
          else if (v) {
            l = o[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${R} for interpolating ${e}`), l = "";
        else !ar(l) && !this.useRawValueToEscape && (l = N_(l));
        const W = S.safeValue(l);
        if (e = e.replace(o[0], W), v ? (S.regex.lastIndex += l.length, S.regex.lastIndex -= o[0].length) : S.regex.lastIndex = 0, u++, u >= this.maxReplaces)
          break;
      }
    }), e;
  }
  nest(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, o, l;
    const u = (I, C) => {
      const f = this.nestingOptionsSeparator;
      if (I.indexOf(f) < 0) return I;
      const v = I.split(new RegExp(`${f}[ ]*{`));
      let b = `{${v[1]}`;
      I = v[0], b = this.interpolate(b, l);
      const S = b.match(/'/g), R = b.match(/"/g);
      (S && S.length % 2 === 0 && !R || R.length % 2 !== 0) && (b = b.replace(/'/g, '"'));
      try {
        l = JSON.parse(b), C && (l = {
          ...C,
          ...l
        });
      } catch (W) {
        return this.logger.warn(`failed parsing options string in nesting for key ${I}`, W), `${I}${f}${b}`;
      }
      return l.defaultValue && l.defaultValue.indexOf(this.prefix) > -1 && delete l.defaultValue, I;
    };
    for (; i = this.nestingRegexp.exec(e); ) {
      let I = [];
      l = {
        ...n
      }, l = l.replace && !ar(l.replace) ? l.replace : l, l.applyPostProcessor = !1, delete l.defaultValue;
      let C = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const f = i[1].split(this.formatSeparator).map((v) => v.trim());
        i[1] = f.shift(), I = f, C = !0;
      }
      if (o = t(u.call(this, i[1].trim(), l), l), o && i[0] === e && !ar(o)) return o;
      ar(o) || (o = N_(o)), o || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${e}`), o = ""), C && (o = I.reduce((f, v) => this.format(f, v, n.lng, {
        ...n,
        interpolationkey: i[1].trim()
      }), o.trim())), e = e.replace(i[0], o), this.regexp.lastIndex = 0;
    }
    return e;
  }
}
const bae = (r) => {
  let e = r.toLowerCase().trim();
  const t = {};
  if (r.indexOf("(") > -1) {
    const n = r.split("(");
    e = n[0].toLowerCase().trim();
    const i = n[1].substring(0, n[1].length - 1);
    e === "currency" && i.indexOf(":") < 0 ? t.currency || (t.currency = i.trim()) : e === "relativetime" && i.indexOf(":") < 0 ? t.range || (t.range = i.trim()) : i.split(";").forEach((l) => {
      if (l) {
        const [u, ...I] = l.split(":"), C = I.join(":").trim().replace(/^'+|'+$/g, ""), f = u.trim();
        t[f] || (t[f] = C), C === "false" && (t[f] = !1), C === "true" && (t[f] = !0), isNaN(C) || (t[f] = parseInt(C, 10));
      }
    });
  }
  return {
    formatName: e,
    formatOptions: t
  };
}, OG = (r) => {
  const e = {};
  return (t, n, i) => {
    let o = i;
    i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (o = {
      ...o,
      [i.interpolationkey]: void 0
    });
    const l = n + JSON.stringify(o);
    let u = e[l];
    return u || (u = r(hW(n), i), e[l] = u), u(t);
  };
};
class Gae {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = lp.create("formatter"), this.options = e, this.formats = {
      number: OG((t, n) => {
        const i = new Intl.NumberFormat(t, {
          ...n
        });
        return (o) => i.format(o);
      }),
      currency: OG((t, n) => {
        const i = new Intl.NumberFormat(t, {
          ...n,
          style: "currency"
        });
        return (o) => i.format(o);
      }),
      datetime: OG((t, n) => {
        const i = new Intl.DateTimeFormat(t, {
          ...n
        });
        return (o) => i.format(o);
      }),
      relativetime: OG((t, n) => {
        const i = new Intl.RelativeTimeFormat(t, {
          ...n
        });
        return (o) => i.format(o, n.range || "day");
      }),
      list: OG((t, n) => {
        const i = new Intl.ListFormat(t, {
          ...n
        });
        return (o) => i.format(o);
      })
    }, this.init(e);
  }
  init(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = t.interpolation.formatSeparator || ",";
  }
  add(e, t) {
    this.formats[e.toLowerCase().trim()] = t;
  }
  addCached(e, t) {
    this.formats[e.toLowerCase().trim()] = OG(t);
  }
  format(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const o = t.split(this.formatSeparator);
    if (o.length > 1 && o[0].indexOf("(") > 1 && o[0].indexOf(")") < 0 && o.find((u) => u.indexOf(")") > -1)) {
      const u = o.findIndex((I) => I.indexOf(")") > -1);
      o[0] = [o[0], ...o.splice(1, u)].join(this.formatSeparator);
    }
    return o.reduce((u, I) => {
      const {
        formatName: C,
        formatOptions: f
      } = bae(I);
      if (this.formats[C]) {
        let v = u;
        try {
          const b = i && i.formatParams && i.formatParams[i.interpolationkey] || {}, S = b.locale || b.lng || i.locale || i.lng || n;
          v = this.formats[C](u, S, {
            ...f,
            ...i,
            ...b
          });
        } catch (b) {
          this.logger.warn(b);
        }
        return v;
      } else
        this.logger.warn(`there was no format function for ${C}`);
      return u;
    }, e);
  }
}
const Bae = (r, e) => {
  r.pending[e] !== void 0 && (delete r.pending[e], r.pendingCount--);
};
class Sae extends fV {
  constructor(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = e, this.store = t, this.services = n, this.languageUtils = n.languageUtils, this.options = i, this.logger = lp.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(n, i.backend, i);
  }
  queueLoad(e, t, n, i) {
    const o = {}, l = {}, u = {}, I = {};
    return e.forEach((C) => {
      let f = !0;
      t.forEach((v) => {
        const b = `${C}|${v}`;
        !n.reload && this.store.hasResourceBundle(C, v) ? this.state[b] = 2 : this.state[b] < 0 || (this.state[b] === 1 ? l[b] === void 0 && (l[b] = !0) : (this.state[b] = 1, f = !1, l[b] === void 0 && (l[b] = !0), o[b] === void 0 && (o[b] = !0), I[v] === void 0 && (I[v] = !0)));
      }), f || (u[C] = !0);
    }), (Object.keys(o).length || Object.keys(l).length) && this.queue.push({
      pending: l,
      pendingCount: Object.keys(l).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(o),
      pending: Object.keys(l),
      toLoadLanguages: Object.keys(u),
      toLoadNamespaces: Object.keys(I)
    };
  }
  loaded(e, t, n) {
    const i = e.split("|"), o = i[0], l = i[1];
    t && this.emit("failedLoading", o, l, t), !t && n && this.store.addResourceBundle(o, l, n, void 0, void 0, {
      skipCopy: !0
    }), this.state[e] = t ? -1 : 2, t && n && (this.state[e] = 0);
    const u = {};
    this.queue.forEach((I) => {
      oae(I.loaded, [o], l), Bae(I, e), t && I.errors.push(t), I.pendingCount === 0 && !I.done && (Object.keys(I.loaded).forEach((C) => {
        u[C] || (u[C] = {});
        const f = I.loaded[C];
        f.length && f.forEach((v) => {
          u[C][v] === void 0 && (u[C][v] = !0);
        });
      }), I.done = !0, I.errors.length ? I.callback(I.errors) : I.callback());
    }), this.emit("loaded", u), this.queue = this.queue.filter((I) => !I.done);
  }
  read(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, l = arguments.length > 5 ? arguments[5] : void 0;
    if (!e.length) return l(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: e,
        ns: t,
        fcName: n,
        tried: i,
        wait: o,
        callback: l
      });
      return;
    }
    this.readingCalls++;
    const u = (C, f) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const v = this.waitingReads.shift();
        this.read(v.lng, v.ns, v.fcName, v.tried, v.wait, v.callback);
      }
      if (C && f && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, e, t, n, i + 1, o * 2, l);
        }, o);
        return;
      }
      l(C, f);
    }, I = this.backend[n].bind(this.backend);
    if (I.length === 2) {
      try {
        const C = I(e, t);
        C && typeof C.then == "function" ? C.then((f) => u(null, f)).catch(u) : u(null, C);
      } catch (C) {
        u(C);
      }
      return;
    }
    return I(e, t, u);
  }
  prepareLoading(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    ar(e) && (e = this.languageUtils.toResolveHierarchy(e)), ar(t) && (t = [t]);
    const o = this.queueLoad(e, t, n, i);
    if (!o.toLoad.length)
      return o.pending.length || i(), null;
    o.toLoad.forEach((l) => {
      this.loadOne(l);
    });
  }
  load(e, t, n) {
    this.prepareLoading(e, t, {}, n);
  }
  reload(e, t, n) {
    this.prepareLoading(e, t, {
      reload: !0
    }, n);
  }
  loadOne(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const n = e.split("|"), i = n[0], o = n[1];
    this.read(i, o, "read", void 0, void 0, (l, u) => {
      l && this.logger.warn(`${t}loading namespace ${o} for language ${i} failed`, l), !l && u && this.logger.log(`${t}loaded namespace ${o} for language ${i}`, u), this.loaded(e, l, u);
    });
  }
  saveMissing(e, t, n, i, o) {
    let l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, u = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t)) {
      this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(n == null || n === "")) {
      if (this.backend && this.backend.create) {
        const I = {
          ...l,
          isUpdate: o
        }, C = this.backend.create.bind(this.backend);
        if (C.length < 6)
          try {
            let f;
            C.length === 5 ? f = C(e, t, n, i, I) : f = C(e, t, n, i), f && typeof f.then == "function" ? f.then((v) => u(null, v)).catch(u) : u(null, f);
          } catch (f) {
            u(f);
          }
        else
          C(e, t, n, i, u, I);
      }
      !e || !e[0] || this.store.addResource(e[0], t, n, i);
    }
  }
}
const z_ = () => ({
  debug: !1,
  initImmediate: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (r) => {
    let e = {};
    if (typeof r[1] == "object" && (e = r[1]), ar(r[1]) && (e.defaultValue = r[1]), ar(r[2]) && (e.tDescription = r[2]), typeof r[2] == "object" || typeof r[3] == "object") {
      const t = r[3] || r[2];
      Object.keys(t).forEach((n) => {
        e[n] = t[n];
      });
    }
    return e;
  },
  interpolation: {
    escapeValue: !0,
    format: (r) => r,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), K_ = (r) => (ar(r.ns) && (r.ns = [r.ns]), ar(r.fallbackLng) && (r.fallbackLng = [r.fallbackLng]), ar(r.fallbackNS) && (r.fallbackNS = [r.fallbackNS]), r.supportedLngs && r.supportedLngs.indexOf("cimode") < 0 && (r.supportedLngs = r.supportedLngs.concat(["cimode"])), r), o2 = () => {
}, Zae = (r) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(r)).forEach((t) => {
    typeof r[t] == "function" && (r[t] = r[t].bind(r));
  });
};
class Ow extends fV {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = K_(e), this.services = {}, this.logger = lp, this.modules = {
      external: []
    }, Zae(this), t && !this.isInitialized && !e.isClone) {
      if (!this.options.initImmediate)
        return this.init(e, t), this;
      setTimeout(() => {
        this.init(e, t);
      }, 0);
    }
  }
  init() {
    var e = this;
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof t == "function" && (n = t, t = {}), !t.defaultNS && t.defaultNS !== !1 && t.ns && (ar(t.ns) ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const i = z_();
    this.options = {
      ...i,
      ...this.options,
      ...K_(t)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }), t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    const o = (f) => f ? typeof f == "function" ? new f() : f : null;
    if (!this.options.isClone) {
      this.modules.logger ? lp.init(o(this.modules.logger), this.options) : lp.init(null, this.options);
      let f;
      this.modules.formatter ? f = this.modules.formatter : typeof Intl < "u" && (f = Gae);
      const v = new E_(this.options);
      this.store = new Y_(this.options.resources, this.options);
      const b = this.services;
      b.logger = lp, b.resourceStore = this.store, b.languageUtils = v, b.pluralResolver = new vae(v, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), f && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (b.formatter = o(f), b.formatter.init(b, this.options), this.options.interpolation.format = b.formatter.format.bind(b.formatter)), b.interpolator = new yae(this.options), b.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, b.backendConnector = new Sae(o(this.modules.backend), b.resourceStore, b, this.options), b.backendConnector.on("*", function(S) {
        for (var R = arguments.length, W = new Array(R > 1 ? R - 1 : 0), x = 1; x < R; x++)
          W[x - 1] = arguments[x];
        e.emit(S, ...W);
      }), this.modules.languageDetector && (b.languageDetector = o(this.modules.languageDetector), b.languageDetector.init && b.languageDetector.init(b, this.options.detection, this.options)), this.modules.i18nFormat && (b.i18nFormat = o(this.modules.i18nFormat), b.i18nFormat.init && b.i18nFormat.init(this)), this.translator = new pW(this.services, this.options), this.translator.on("*", function(S) {
        for (var R = arguments.length, W = new Array(R > 1 ? R - 1 : 0), x = 1; x < R; x++)
          W[x - 1] = arguments[x];
        e.emit(S, ...W);
      }), this.modules.external.forEach((S) => {
        S.init && S.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, n || (n = o2), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const f = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      f.length > 0 && f[0] !== "dev" && (this.options.lng = f[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((f) => {
      this[f] = function() {
        return e.store[f](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((f) => {
      this[f] = function() {
        return e.store[f](...arguments), e;
      };
    });
    const I = KZ(), C = () => {
      const f = (v, b) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), I.resolve(b), n(v, b);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return f(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, f);
    };
    return this.options.resources || !this.options.initImmediate ? C() : setTimeout(C, 0), I;
  }
  loadResources(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : o2;
    const i = ar(e) ? e : this.language;
    if (typeof e == "function" && (n = e), !this.options.resources || this.options.partialBundledLanguages) {
      if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return n();
      const o = [], l = (u) => {
        if (!u || u === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(u).forEach((C) => {
          C !== "cimode" && o.indexOf(C) < 0 && o.push(C);
        });
      };
      i ? l(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((I) => l(I)), this.options.preload && this.options.preload.forEach((u) => l(u)), this.services.backendConnector.load(o, this.options.ns, (u) => {
        !u && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), n(u);
      });
    } else
      n(null);
  }
  reloadResources(e, t, n) {
    const i = KZ();
    return typeof e == "function" && (n = e, e = void 0), typeof t == "function" && (n = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), n || (n = o2), this.services.backendConnector.reload(e, t, (o) => {
      i.resolve(), n(o);
    }), i;
  }
  use(e) {
    if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && Dk.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this;
  }
  setResolvedLanguage(e) {
    if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
      for (let t = 0; t < this.languages.length; t++) {
        const n = this.languages[t];
        if (!(["cimode", "dev"].indexOf(n) > -1) && this.store.hasLanguageSomeTranslations(n)) {
          this.resolvedLanguage = n;
          break;
        }
      }
  }
  changeLanguage(e, t) {
    var n = this;
    this.isLanguageChangingTo = e;
    const i = KZ();
    this.emit("languageChanging", e);
    const o = (I) => {
      this.language = I, this.languages = this.services.languageUtils.toResolveHierarchy(I), this.resolvedLanguage = void 0, this.setResolvedLanguage(I);
    }, l = (I, C) => {
      C ? (o(C), this.translator.changeLanguage(C), this.isLanguageChangingTo = void 0, this.emit("languageChanged", C), this.logger.log("languageChanged", C)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
        return n.t(...arguments);
      }), t && t(I, function() {
        return n.t(...arguments);
      });
    }, u = (I) => {
      !e && !I && this.services.languageDetector && (I = []);
      const C = ar(I) ? I : this.services.languageUtils.getBestMatchFromCodes(I);
      C && (this.language || o(C), this.translator.language || this.translator.changeLanguage(C), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(C)), this.loadResources(C, (f) => {
        l(f, C);
      });
    };
    return !e && this.services.languageDetector && !this.services.languageDetector.async ? u(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(u) : this.services.languageDetector.detect(u) : u(e), i;
  }
  getFixedT(e, t, n) {
    var i = this;
    const o = function(l, u) {
      let I;
      if (typeof u != "object") {
        for (var C = arguments.length, f = new Array(C > 2 ? C - 2 : 0), v = 2; v < C; v++)
          f[v - 2] = arguments[v];
        I = i.options.overloadTranslationOptionHandler([l, u].concat(f));
      } else
        I = {
          ...u
        };
      I.lng = I.lng || o.lng, I.lngs = I.lngs || o.lngs, I.ns = I.ns || o.ns, I.keyPrefix !== "" && (I.keyPrefix = I.keyPrefix || n || o.keyPrefix);
      const b = i.options.keySeparator || ".";
      let S;
      return I.keyPrefix && Array.isArray(l) ? S = l.map((R) => `${I.keyPrefix}${b}${R}`) : S = I.keyPrefix ? `${I.keyPrefix}${b}${l}` : l, i.t(S, I);
    };
    return ar(e) ? o.lng = e : o.lngs = e, o.ns = t, o.keyPrefix = n, o;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const n = t.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, o = this.languages[this.languages.length - 1];
    if (n.toLowerCase() === "cimode") return !0;
    const l = (u, I) => {
      const C = this.services.backendConnector.state[`${u}|${I}`];
      return C === -1 || C === 0 || C === 2;
    };
    if (t.precheck) {
      const u = t.precheck(this, l);
      if (u !== void 0) return u;
    }
    return !!(this.hasResourceBundle(n, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || l(n, e) && (!i || l(o, e)));
  }
  loadNamespaces(e, t) {
    const n = KZ();
    return this.options.ns ? (ar(e) && (e = [e]), e.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      n.resolve(), t && t(i);
    }), n) : (t && t(), Promise.resolve());
  }
  loadLanguages(e, t) {
    const n = KZ();
    ar(e) && (e = [e]);
    const i = this.options.preload || [], o = e.filter((l) => i.indexOf(l) < 0 && this.services.languageUtils.isSupportedCode(l));
    return o.length ? (this.options.preload = i.concat(o), this.loadResources((l) => {
      n.resolve(), t && t(l);
    }), n) : (t && t(), Promise.resolve());
  }
  dir(e) {
    if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
    const t = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], n = this.services && this.services.languageUtils || new E_(z_());
    return t.indexOf(n.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    return new Ow(e, t);
  }
  cloneInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : o2;
    const n = e.forkResourceStore;
    n && delete e.forkResourceStore;
    const i = {
      ...this.options,
      ...e,
      isClone: !0
    }, o = new Ow(i);
    return (e.debug !== void 0 || e.prefix !== void 0) && (o.logger = o.logger.clone(e)), ["store", "services", "language"].forEach((u) => {
      o[u] = this[u];
    }), o.services = {
      ...this.services
    }, o.services.utils = {
      hasLoadedNamespace: o.hasLoadedNamespace.bind(o)
    }, n && (o.store = new Y_(this.store.data, i), o.services.resourceStore = o.store), o.translator = new pW(o.services, i), o.translator.on("*", function(u) {
      for (var I = arguments.length, C = new Array(I > 1 ? I - 1 : 0), f = 1; f < I; f++)
        C[f - 1] = arguments[f];
      o.emit(u, ...C);
    }), o.init(i, t), o.translator.options = i, o.translator.backendConnector.services.utils = {
      hasLoadedNamespace: o.hasLoadedNamespace.bind(o)
    }, o;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const Dl = Ow.createInstance();
Dl.createInstance = Ow.createInstance;
Dl.createInstance;
Dl.dir;
Dl.init;
Dl.loadResources;
Dl.reloadResources;
Dl.use;
Dl.changeLanguage;
Dl.getFixedT;
Dl.t;
Dl.exists;
Dl.setDefaultNamespace;
Dl.hasLoadedNamespace;
Dl.loadNamespaces;
Dl.loadLanguages;
const wae = {
  zh: {
    translation: {
      myName: " ",
      myPosition: "",
      lang_zh: "",
      lang_en: "english",
      theme_default: "",
      theme_dark: "",
      theme_light: "",
      nav_home: "",
      nav_about: "",
      nav_experience: "",
      nav_projects: "",
      nav_links: "",
      subtitle_aboutme: "",
      subtitle_aboutweb: "",
      subtitle_experience: "",
      subtitle_projects: "",
      subtitle_links: "",
      subtitle_materials: "",
      proj_download: "download",
      proj_link: "link",
      proj_github: "github",
      link_email: "",
      link_git: "GitHub",
      link_youtube: "YouTube",
      toast_copy: ""
    }
  },
  en: {
    translation: {
      myName: "Wu, Pei-Cheng",
      myPosition: "Frontend Engineer",
      lang_zh: "",
      lang_en: "english",
      theme_default: "default",
      theme_dark: "dark",
      theme_light: "light",
      nav_home: "Home",
      nav_about: "About",
      nav_experience: "Experience",
      nav_projects: "Projects",
      nav_links: "Links",
      subtitle_aboutme: "About",
      subtitle_aboutweb: "Website Overview",
      subtitle_experience: "Work Experience",
      subtitle_projects: "Projects",
      subtitle_links: "Profile Links",
      subtitle_materials: "Study Materials",
      proj_download: "download",
      proj_link: "link",
      proj_github: "github",
      link_email: "Email",
      link_git: "GitHub",
      link_youtube: "YouTube",
      toast_copy: "copied link"
    }
  }
}, Rae = () => {
  const r = location.href, e = r.indexOf("?lang=") !== -1 ? r.indexOf("?lang=") : r.indexOf("&lang=");
  if (e !== -1) {
    const n = r.substring(e), o = /[?&]lang=([^&]+)/.exec(n);
    if (o && o.length > 1 && o[1]) {
      const l = o[1];
      if (ow.includes(l))
        return l;
    }
  }
  const t = localStorage.getItem(Tw.lang);
  return ow.includes(t) ? t : ow[0];
};
Dl.use(zre).init({
  debug: !1,
  fallbackLng: Rae(),
  interpolation: { escapeValue: !1 },
  supportedLngs: ow,
  resources: wae
});
const xae = ({ className: r }) => {
  const { t: e } = Uu(), t = rd(), n = Wb();
  return /* @__PURE__ */ We.jsxs("nav", { className: `mobile-nav-${Dl.language} ${r}`, children: [
    /* @__PURE__ */ We.jsxs("label", { className: "cursor-pointer flex flex-row gap-1 text-nowrap", onClick: () => n(lg.HOME), children: [
      /* @__PURE__ */ We.jsx($re, { size: "12px", className: Dl.language === "zh" ? "rotate-0" : "rotate-180" }),
      e("nav_home")
    ] }),
    KY.map(({ url: i, title: o }) => /* @__PURE__ */ We.jsxs("label", { className: "cursor-pointer text-nowrap", children: [
      /* @__PURE__ */ We.jsx("input", { type: "radio", checked: t.pathname === i, onChange: () => n(i) }),
      e(o)
    ] }, o))
  ] });
}, L_ = ({ defaultChecked: r, name: e, options: t, onChange: n }) => {
  const { t: i } = Uu();
  return /* @__PURE__ */ We.jsx("div", { className: "radiogroup uppercase", children: t.map((o) => /* @__PURE__ */ We.jsxs("label", { className: "custom-radio", children: [
    /* @__PURE__ */ We.jsx(
      "input",
      {
        type: "radio",
        defaultChecked: o.value === r,
        name: e,
        value: o.value,
        onChange: (l) => n(l.target.value)
      }
    ),
    i(o.name)
  ] }, o.value)) });
}, Wae = ({ type: r, during: e, text: t }) => {
  const [n, i] = ye.useState("open");
  return ye.useEffect(() => {
    setTimeout(() => {
      i("close");
    }, e);
  }, []), /* @__PURE__ */ We.jsx("div", { className: `toast_content-${n}`, children: t });
}, Vae = ({ children: r }) => {
  let e = document.getElementById("toast-wrapper");
  if (!e) {
    const t = document.getElementById("root"), n = document.createElement("div");
    n.id = "toast-wrapper", document.body.insertBefore(n, t), e = n;
  }
  return _X.createPortal(r, e);
}, Nae = ({ during: r = 3e3, maxCount: e = 1 }) => {
  const [t, n] = ye.useState([]), i = 290, o = (l) => {
    n((u) => u.filter(({ key: I }) => I !== l.key));
  };
  return m2 = (l) => {
    n((u) => [...u, l]), setTimeout(() => {
      o(l);
    }, r + i);
  }, ye.useEffect(() => {
    if (t.length > e) {
      const [l] = t;
      o(l);
    }
  }, [t]), /* @__PURE__ */ We.jsx(Vae, { children: /* @__PURE__ */ We.jsx("div", { className: "toast_container", children: t.map(({ key: l, type: u, text: I }) => /* @__PURE__ */ We.jsx(Wae, { during: r, type: u, text: I }, l)) }) });
};
let m2, k_ = 0;
const Mae = Date.now(), MH = () => {
  const r = k_;
  return k_ += 1, `${Mae}_${r}`;
}, D_ = {
  success: (r) => {
    m2({
      text: r,
      key: MH(),
      type: "success"
    });
  },
  warning: (r) => {
    m2({
      text: r,
      key: MH(),
      type: "warning"
    });
  },
  error: (r) => {
    m2({
      text: r,
      key: MH(),
      type: "error"
    });
  }
}, pV = ({ title: r, children: e }) => /* @__PURE__ */ We.jsxs("section", { className: "section", children: [
  /* @__PURE__ */ We.jsxs("div", { className: "titleFrame", children: [
    /* @__PURE__ */ We.jsx("div", { className: "titleFrame-linel" }),
    /* @__PURE__ */ We.jsx("h2", { className: "title", children: r }),
    /* @__PURE__ */ We.jsx("div", { className: "titleFrame-liner" })
  ] }),
  e
] }), mp = (r) => {
  const e = {
    [dv.EN]: dv.EN,
    [dv.ZH]: dv.ZH
  };
  return ((n) => n in e)(r) ? e[r] : dv.EN;
}, s2 = {
  phaseI: {
    en: "I'm Randy, a frontend developer. I created this website to document the projects I've worked on over the past few years, including side projects and those I've participated in at work. As long as the projects are publicly accessible, they will be showcased here as part of my portfolio.",
    zh: ""
  },
  phaseII: {
    en: "Currently, I'm a frontend engineer at Kang Da Information Inc., responsible for the frontend project development of the Taiwan Intellectual Property Office (TIPO) and provided technical support, such as project architecture planning, writing tests, training, etc..",
    zh: " (TIPO) "
  },
  phaseIII: {
    en: "Prior to this role, I worked at a gaming company as a developer, contributing to game development projects. This experience allowed me to appreciate the unique challenges and joys of working on different types of projects",
    zh: ""
  },
  phaseIV: {
    en: "In my spare time, I'm usually reading, playing the guitar, and recently, I reunited with some university friends to form a new band.",
    zh: ""
  }
}, Hae = () => {
  const { t: r, i18n: e } = Uu(), t = mp(e.language);
  return /* @__PURE__ */ We.jsx(pV, { title: r("subtitle_aboutme"), children: /* @__PURE__ */ We.jsxs("article", { className: "text-base sm:text-sm flex flex-col gap-6 transition-theme text-defaccent dark:text-darkaccent light:text-lightaccent md:px-4 xs:p-0", children: [
    /* @__PURE__ */ We.jsx("p", { children: s2.phaseI[t] }),
    /* @__PURE__ */ We.jsx("p", { children: s2.phaseII[t] }),
    /* @__PURE__ */ We.jsx("p", { children: s2.phaseIII[t] }),
    /* @__PURE__ */ We.jsx("p", { children: s2.phaseIV[t] })
  ] }) });
}, ig = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
function Xae() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (ig[r & 255] + ig[r >> 8 & 255] + ig[r >> 16 & 255] + ig[r >> 24 & 255] + "-" + ig[e & 255] + ig[e >> 8 & 255] + "-" + ig[e >> 16 & 15 | 64] + ig[e >> 24 & 255] + "-" + ig[t & 63 | 128] + ig[t >> 8 & 255] + "-" + ig[t >> 16 & 255] + ig[t >> 24 & 255] + ig[n & 255] + ig[n >> 8 & 255] + ig[n >> 16 & 255] + ig[n >> 24 & 255]).toLowerCase();
}
const Yae = ({
  experience: { id: r, coname: e, district: t, position: n, period: i, description: o, link: l, tags: u, contributions: I },
  hoverState: C
}) => {
  const { i18n: f } = Uu(), v = mp(f.language);
  return /* @__PURE__ */ We.jsxs(
    Fk,
    {
      id: r,
      hoverState: C,
      title: /* @__PURE__ */ We.jsxs("p", { className: "text-xs uppercase", children: [
        /* @__PURE__ */ We.jsx("span", { className: "text-nowrap", children: i[0] }),
        "  ",
        /* @__PURE__ */ We.jsx("span", { className: "text-nowrap", children: i[1] })
      ] }),
      children: [
        /* @__PURE__ */ We.jsx("div", { className: "flex flex-col gap-2", children: /* @__PURE__ */ We.jsxs("div", { className: "flex flex-row flex-wrap justify-between items-center gap-x-2", children: [
          l ? /* @__PURE__ */ We.jsx("a", { target: "_blank", rel: "noopener noreferrer", href: l, children: /* @__PURE__ */ We.jsxs("h3", { className: "text-nowrap xs:text-wrap text-lg font-medium md:underline", children: [
            e[v],
            /* @__PURE__ */ We.jsx("span", { className: "text-sm underline md:hidden ml-2", children: "link" })
          ] }) }) : /* @__PURE__ */ We.jsx("h3", { className: "text-nowrap xs:text-wrap text-lg font-medium md:underline", children: e[v] }),
          /* @__PURE__ */ We.jsx("div", { className: "text-xs font-normal", children: t[v] }),
          /* @__PURE__ */ We.jsx("div", { className: "mt-1 w-full flex flex-row justify-between items-center", children: n[v] })
        ] }) }),
        /* @__PURE__ */ We.jsx("div", { className: "text-sm", children: o[v] }),
        I.length > 0 && /* @__PURE__ */ We.jsx("div", { className: "text-sm", children: /* @__PURE__ */ We.jsx("ul", { className: "list-disc ml-5", children: I.map((b) => /* @__PURE__ */ We.jsx("li", { children: b[v] }, Xae())) }) }),
        u.length > 0 && /* @__PURE__ */ We.jsx("div", { className: "mt-1 flex flex-row justify-between items-end text-sm font-medium", children: /* @__PURE__ */ We.jsx(Ek, { tags: u }) })
      ]
    }
  );
}, Fae = [
  {
    id: "2",
    coname: {
      en: "Kang Da Information Inc.",
      zh: ""
    },
    district: {
      en: "Zhongshan Dist., Taipei City",
      zh: ""
    },
    position: {
      en: "Frontend Engineer",
      zh: ""
    },
    period: [`${sg.SEP} 2022`, "present"],
    description: {
      en: "Led front-end project development at the Taiwan Intellectual Property Office (TIPO) and provided technical support.",
      zh: " TIPO"
    },
    link: "https://www.kangdainfo.com/web/index.html?pageId=1",
    contributions: [
      {
        en: "Designed and implemented a batch file conversion module for an online patent application system, allowing users to upload and process large files before submission.",
        zh: " "
      },
      {
        en: "Created and standardized a UI library for TIPO, now adopted across all TIPO projects, improving maintainability and design consistency.",
        zh: " TIPO  UI Library TIPO "
      },
      {
        en: "Refactored TIPOs online payment system, reducing redundant code by 30%, improving maintainability, and boosting development efficiency.",
        zh: " TIPO  30% "
      },
      {
        en: "Wrote unit tests in Jest for TIPOs online payment system, achieving 100% code coverage for business logic.",
        zh: "  (Jest) TIPO  100% "
      },
      {
        en: "Conducted training for TIPO engineers on React, functional programming, and best practices, while leading code reviews and technical mentorship.",
        zh: " TIPO  ReactFunctional Programming Code Review "
      },
      {
        en: "Built a Chrome extension that boosted developer productivity by 300%, streamlining repetitive workflows.",
        zh: " Chrome extension 300%"
      }
    ],
    tags: [Ji.react, Ji.express, Ji.nativeJS, Ji.typescript, Ji.tailwind, Ji.vite, Ji.jest, Ji.i18n]
  },
  {
    id: "1",
    coname: {
      en: "Chenhe Digital Technology CO., LTD.",
      zh: ""
    },
    district: {
      en: "Neihu Dist., Taipei City",
      zh: ""
    },
    position: {
      en: "Game Frontend Engineer",
      zh: ""
    },
    period: [`${sg.AUG} 2020`, `${sg.AUG} 2022`],
    description: {
      en: 'Responsible for the development and maintenance of the "" game project together with the team.',
      zh: ' "" '
    },
    link: "https://www.linkedin.com/company/%E5%AE%B8%E5%92%8C%E6%95%B8%E4%BD%8D%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/",
    contributions: [
      {
        en: "Developed 7 game projects, led architecture planning and task allocation for 3 of them, ensuring a 100% project completion rate and delivery.",
        zh: " 100%"
      },
      {
        en: "Handled real-time user messages using WebSocket.",
        zh: " WebSocket "
      },
      {
        en: "Optimized the web version of games, reducing image requests by 50% and cutting project loading time in half.",
        zh: " Web  50%"
      },
      {
        en: "Developed internal automation tools using Python and Shell, reducing repetitive workflows and saving 3 hours per engineer per week.",
        zh: " Python  Shell  3 "
      }
    ],
    tags: [Ji.htmlscss, Ji.websocket, Ji.typescript, Ji.java, Ji.python, Ji.canvas, Ji.glsl, Ji.i18n]
  },
  {
    id: "0",
    coname: {
      en: "Ming Yang Co., Ltd.",
      zh: ""
    },
    district: {
      en: "Xizhi Dist., New Taipei City",
      zh: ""
    },
    position: {
      en: "Live Sound Technician",
      zh: ""
    },
    period: [`${sg.SEP} 2018`, `${sg.JAN} 2020`],
    description: {
      en: "Coordinated with event teams to set up and operate PA systems and mixers, ensuring optimal live sound quality.",
      zh: "PA "
    },
    contributions: [],
    tags: []
  }
], Eae = () => {
  const { t: r } = Uu(), [e, t] = ye.useState("");
  return /* @__PURE__ */ We.jsx(pV, { title: r("subtitle_experience"), children: /* @__PURE__ */ We.jsx("div", { className: "w-full flex flex-col gap-0 xs:gap-8 md:pr-4 xs:p-0", onMouseLeave: () => t(""), children: Fae.map((n) => /* @__PURE__ */ We.jsx(Yae, { experience: n, hoverState: [e, t] }, n.id)) }) });
}, Pw = (r) => r === lg.HOME, Tae = ({ className: r }) => {
  const { pathname: t } = rd(), [n, i] = ye.useState(Pw(t));
  return ye.useEffect(() => {
    const o = setTimeout(() => {
      i(!1);
    }, 2e3);
    return () => clearTimeout(o);
  }, [2e3]), n && Pw(t) && /* @__PURE__ */ We.jsx("div", { className: `${r} animation`, children: /* @__PURE__ */ We.jsx("div", { className: "animation-spec", children: /* @__PURE__ */ We.jsxs("div", { className: "animation-text", children: [
    "Randy's",
    /* @__PURE__ */ We.jsx("br", {}),
    "Website"
  ] }) }) });
}, U_ = (r) => {
  const e = {
    [lg.HOME]: /* @__PURE__ */ We.jsx(We.Fragment, {}),
    [lg.ABOUT]: /* @__PURE__ */ We.jsx(Hae, {}),
    [lg.EXPERIENCE]: /* @__PURE__ */ We.jsx(Eae, {}),
    [lg.PROJECTS]: /* @__PURE__ */ We.jsx(xse, {}),
    [lg.LINKS]: /* @__PURE__ */ We.jsx(Oae, {})
  };
  if (((n) => n in e)(r))
    return e[r];
}, _ae = ({ className: r }) => {
  const e = ye.useRef(null), t = ye.useRef(null), { t: n } = Uu(), { pathname: i, search: o } = rd(), l = ye.useRef(i), [u, I] = ye.useState(U_(i)), C = i.replace("/", "");
  return ye.useEffect(() => {
    e.current && e.current.scrollTo({ top: 0 });
  }, [o]), ye.useEffect(() => {
    const f = e.current;
    if (!f)
      return;
    f.classList.remove("outlet-fadein"), f.classList.add("outlet-fadeout"), f.style.overflow = "hidden";
    const v = Pw(l.current) ? 0 : 200;
    return t.current = setTimeout(() => {
      f.scrollTo({ top: 0 }), I(U_(i)), f.classList.remove("outlet-fadeout"), f.style.overflow = "auto", Pw(i) || f.classList.add("outlet-fadein");
    }, v), l.current = i, () => {
      t.current && clearTimeout(t.current);
    };
  }, [i]), /* @__PURE__ */ We.jsxs("main", { id: "outlet", ref: e, className: r, children: [
    C && /* @__PURE__ */ We.jsx("h1", { className: "hidden uppercase", children: n(`nav_${C}`) }),
    u
  ] });
}, zae = (r) => {
  const e = mp(r);
  Dl.changeLanguage(e), localStorage.setItem(Tw.lang, e);
}, Kae = (r) => {
  const e = window.document.documentElement;
  e.classList.remove(...rW);
  const t = rW.includes(r) ? r : id.DEFAULT;
  window.dispatchEvent(new CustomEvent("change-theme", { detail: { theme: t } })), localStorage.setItem(Tw.theme, t), e.classList.add(t);
}, Lae = "" + new URL("assets/myphoto.webp", import.meta.url).href, kae = () => {
  const { t: r } = Uu(), e = Wb(), t = Pw(rd().pathname);
  return /* @__PURE__ */ We.jsxs(Hte, { className: "main-grid", children: [
    /* @__PURE__ */ We.jsx(wre, { className: t ? "background-home" : "background" }),
    /* @__PURE__ */ We.jsx("div", { className: t ? "mask-close" : "mask-open" }),
    /* @__PURE__ */ We.jsx(_ae, { className: t ? "outlet-home" : "outlet" }),
    /* @__PURE__ */ We.jsxs(
      "header",
      {
        className: t ? "my-info" : "my-info-hidden cursor-pointer",
        onClick: () => e(lg.HOME),
        children: [
          /* @__PURE__ */ We.jsx("img", { draggable: !1, className: "w-28 h-28 object-cover animate-rotateCube", src: Lae, alt: "photo" }),
          /* @__PURE__ */ We.jsxs("div", { className: "my-title", children: [
            /* @__PURE__ */ We.jsx("div", { className: "text-2xl xs:text-xl", children: r("myName") }),
            /* @__PURE__ */ We.jsx("div", { className: "text-sm", children: r("myPosition") })
          ] })
        ]
      }
    ),
    /* @__PURE__ */ We.jsxs("aside", { className: "setting", children: [
      /* @__PURE__ */ We.jsx(
        L_,
        {
          defaultChecked: Dl.language,
          name: "lang",
          options: ow.map((n) => ({ name: `lang_${n}`, value: n })),
          onChange: zae
        }
      ),
      /* @__PURE__ */ We.jsx(
        L_,
        {
          defaultChecked: LY(),
          name: "theme",
          options: rW.map((n) => ({ name: `theme_${n}`, value: n })),
          onChange: Kae
        }
      )
    ] }),
    /* @__PURE__ */ We.jsx(xae, { className: `mobile-nav-${t ? "fadeout" : "fadein"}` }),
    /* @__PURE__ */ We.jsx("nav", { className: t ? "btngroup" : "btngroup-hidden", children: KY.map(({ title: n, url: i }) => /* @__PURE__ */ We.jsx(iae, { url: i, children: n }, n)) }),
    /* @__PURE__ */ We.jsx("footer", { className: "footer", children: /* @__PURE__ */ We.jsx(xre, {}) }),
    /* @__PURE__ */ We.jsx(Tae, { className: "intro-ani" })
  ] });
};
function Dae(r) {
  return Eb({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M7.024 3.75c0-.966.784-1.75 1.75-1.75H20.25c.966 0 1.75.784 1.75 1.75v11.498a1.75 1.75 0 0 1-1.75 1.75H8.774a1.75 1.75 0 0 1-1.75-1.75Zm1.75-.25a.25.25 0 0 0-.25.25v11.498c0 .139.112.25.25.25H20.25a.25.25 0 0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25Z" }, child: [] }, { tag: "path", attr: { d: "M1.995 10.749a1.75 1.75 0 0 1 1.75-1.751H5.25a.75.75 0 1 1 0 1.5H3.745a.25.25 0 0 0-.25.25L3.5 20.25c0 .138.111.25.25.25h9.5a.25.25 0 0 0 .25-.25v-1.51a.75.75 0 1 1 1.5 0v1.51A1.75 1.75 0 0 1 13.25 22h-9.5A1.75 1.75 0 0 1 2 20.25l-.005-9.501Z" }, child: [] }] })(r);
}
function O_(r) {
  return Eb({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M15.5 2.25a.75.75 0 0 1 .75-.75h5.5a.75.75 0 0 1 .75.75v5.5a.75.75 0 0 1-1.5 0V4.06l-6.22 6.22a.75.75 0 1 1-1.06-1.06L19.94 3h-3.69a.75.75 0 0 1-.75-.75Z" }, child: [] }, { tag: "path", attr: { d: "M2.5 4.25c0-.966.784-1.75 1.75-1.75h8.5a.75.75 0 0 1 0 1.5h-8.5a.25.25 0 0 0-.25.25v15.5c0 .138.112.25.25.25h15.5a.25.25 0 0 0 .25-.25v-8.5a.75.75 0 0 1 1.5 0v8.5a1.75 1.75 0 0 1-1.75 1.75H4.25a1.75 1.75 0 0 1-1.75-1.75V4.25Z" }, child: [] }] })(r);
}
const HH = ({ title: r, href: e }) => {
  const { t } = Uu(), n = e.replace("mailto:", ""), i = async () => {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText)
        await navigator.clipboard.writeText(n);
      else {
        const o = document.createElement("textarea");
        o.value = n, document.body.appendChild(o), o.select(), document.execCommand("copy"), document.body.removeChild(o);
      }
      D_.success(t("toast_copy"));
    } catch (o) {
      console.error("Failed to copy: ", o), D_.error(t("toast_copy_failed"));
    }
  };
  return /* @__PURE__ */ We.jsx("li", { children: /* @__PURE__ */ We.jsxs("div", { className: "flex items-center gap-x-2 flex-wrap", children: [
    /* @__PURE__ */ We.jsx("span", { className: "capitalize text-nowrap xs:w-14", children: r }),
    /* @__PURE__ */ We.jsxs("span", { className: "flex items-center gap-2", children: [
      e.includes("mailto:") ? /* @__PURE__ */ We.jsx("a", { className: "underline xs:hidden", href: e, children: n }) : /* @__PURE__ */ We.jsx("a", { target: "_blank", rel: "noopener noreferrer", className: "underline xs:hidden", href: e, children: n }),
      e.includes("mailto:") ? /* @__PURE__ */ We.jsx("a", { className: "underline hidden xs:block", href: e, children: /* @__PURE__ */ We.jsx(O_, { size: "14px" }) }) : /* @__PURE__ */ We.jsx("a", { target: "_blank", rel: "noopener noreferrer", className: "underline hidden xs:block", href: e, children: /* @__PURE__ */ We.jsx(O_, { size: "14px" }) }),
      /* @__PURE__ */ We.jsx("button", { onClick: i, children: /* @__PURE__ */ We.jsx(Dae, { className: "cursor-pointer", size: "16px" }) })
    ] })
  ] }) });
}, Uae = ({ children: r }) => /* @__PURE__ */ We.jsx("ul", { className: "linkList", children: r }), Oae = () => {
  const { t: r } = Uu();
  return /* @__PURE__ */ We.jsx(pV, { title: r("subtitle_links"), children: /* @__PURE__ */ We.jsxs(Uae, { children: [
    /* @__PURE__ */ We.jsx(HH, { title: r("link_email"), href: "mailto:randywu417@gmail.com" }),
    /* @__PURE__ */ We.jsx(HH, { title: r("link_git"), href: "https://github.com/randywu417" }),
    /* @__PURE__ */ We.jsx(HH, { title: r("link_youtube"), href: "https://www.youtube.com/@randywu417" })
  ] }) });
};
function Pae(r) {
  return Eb({ attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M10 12.796V3.204L4.519 8zm-.659.753-5.48-4.796a1 1 0 0 1 0-1.506l5.48-4.796A1 1 0 0 1 11 3.204v9.592a1 1 0 0 1-1.659.753" }, child: [] }] })(r);
}
function Jae(r) {
  return Eb({ attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M6 12.796V3.204L11.481 8zm.659.753 5.48-4.796a1 1 0 0 0 0-1.506L6.66 2.451C6.011 1.885 5 2.345 5 3.204v9.592a1 1 0 0 0 1.659.753" }, child: [] }] })(r);
}
var Qae = { 694: (r, e, t) => {
  var n = t(925);
  function i() {
  }
  function o() {
  }
  o.resetWarningCache = i, r.exports = function() {
    function l(C, f, v, b, S, R) {
      if (R !== n) {
        var W = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
        throw W.name = "Invariant Violation", W;
      }
    }
    function u() {
      return l;
    }
    l.isRequired = l;
    var I = { array: l, bigint: l, bool: l, func: l, number: l, object: l, string: l, symbol: l, any: l, arrayOf: u, element: l, elementType: l, instanceOf: u, node: l, objectOf: u, oneOf: u, oneOfType: u, shape: u, exact: u, checkPropTypes: o, resetWarningCache: i };
    return I.PropTypes = I, I;
  };
}, 556: (r, e, t) => {
  r.exports = t(694)();
}, 925: (r) => {
  r.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
}, 115: (r) => {
  var e = typeof Element < "u", t = typeof Map == "function", n = typeof Set == "function", i = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
  function o(l, u) {
    if (l === u) return !0;
    if (l && u && typeof l == "object" && typeof u == "object") {
      if (l.constructor !== u.constructor) return !1;
      var I, C, f, v;
      if (Array.isArray(l)) {
        if ((I = l.length) != u.length) return !1;
        for (C = I; C-- != 0; ) if (!o(l[C], u[C])) return !1;
        return !0;
      }
      if (t && l instanceof Map && u instanceof Map) {
        if (l.size !== u.size) return !1;
        for (v = l.entries(); !(C = v.next()).done; ) if (!u.has(C.value[0])) return !1;
        for (v = l.entries(); !(C = v.next()).done; ) if (!o(C.value[1], u.get(C.value[0]))) return !1;
        return !0;
      }
      if (n && l instanceof Set && u instanceof Set) {
        if (l.size !== u.size) return !1;
        for (v = l.entries(); !(C = v.next()).done; ) if (!u.has(C.value[0])) return !1;
        return !0;
      }
      if (i && ArrayBuffer.isView(l) && ArrayBuffer.isView(u)) {
        if ((I = l.length) != u.length) return !1;
        for (C = I; C-- != 0; ) if (l[C] !== u[C]) return !1;
        return !0;
      }
      if (l.constructor === RegExp) return l.source === u.source && l.flags === u.flags;
      if (l.valueOf !== Object.prototype.valueOf && typeof l.valueOf == "function" && typeof u.valueOf == "function") return l.valueOf() === u.valueOf();
      if (l.toString !== Object.prototype.toString && typeof l.toString == "function" && typeof u.toString == "function") return l.toString() === u.toString();
      if ((I = (f = Object.keys(l)).length) !== Object.keys(u).length) return !1;
      for (C = I; C-- != 0; ) if (!Object.prototype.hasOwnProperty.call(u, f[C])) return !1;
      if (e && l instanceof Element) return !1;
      for (C = I; C-- != 0; ) if ((f[C] !== "_owner" && f[C] !== "__v" && f[C] !== "__o" || !l.$$typeof) && !o(l[f[C]], u[f[C]])) return !1;
      return !0;
    }
    return l != l && u != u;
  }
  r.exports = function(l, u) {
    try {
      return o(l, u);
    } catch (I) {
      if ((I.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1;
      throw I;
    }
  };
} }, P_ = {};
function og(r) {
  var e = P_[r];
  if (e !== void 0) return e.exports;
  var t = P_[r] = { exports: {} };
  return Qae[r](t, t.exports, og), t.exports;
}
og.n = (r) => {
  var e = r && r.__esModule ? () => r.default : () => r;
  return og.d(e, { a: e }), e;
}, og.d = (r, e) => {
  for (var t in e) og.o(e, t) && !og.o(r, t) && Object.defineProperty(r, t, { enumerable: !0, get: e[t] });
}, og.g = function() {
  if (typeof globalThis == "object") return globalThis;
  try {
    return this || new Function("return this")();
  } catch {
    if (typeof window == "object") return window;
  }
}(), og.o = (r, e) => Object.prototype.hasOwnProperty.call(r, e);
var Uk = {};
function Ok(r) {
  var e, t, n = "";
  if (typeof r == "string" || typeof r == "number") n += r;
  else if (typeof r == "object") if (Array.isArray(r)) {
    var i = r.length;
    for (e = 0; e < i; e++) r[e] && (t = Ok(r[e])) && (n && (n += " "), n += t);
  } else for (t in r) r[t] && (n && (n += " "), n += t);
  return n;
}
og.d(Uk, { A: () => _oe });
const jy = function() {
  for (var r, e, t = 0, n = "", i = arguments.length; t < i; t++) (r = arguments[t]) && (e = Ok(r)) && (n && (n += " "), n += e);
  return n;
}, En = (J_ = { default: () => wc, useMemo: () => ye.useMemo, useRef: () => ye.useRef }, XH = {}, og.d(XH, J_), XH);
var J_, XH;
const mW = function(r) {
  var e = typeof r;
  return r != null && (e == "object" || e == "function");
}, jae = typeof global == "object" && global && global.Object === Object && global;
var qae = typeof self == "object" && self && self.Object === Object && self;
const Pk = jae || qae || Function("return this")(), YH = function() {
  return Pk.Date.now();
};
var $ae = /\s/, eoe = /^\s+/;
const toe = function(r) {
  return r && r.slice(0, function(e) {
    for (var t = e.length; t-- && $ae.test(e.charAt(t)); ) ;
    return t;
  }(r) + 1).replace(eoe, "");
}, AW = Pk.Symbol;
var Jk = Object.prototype, noe = Jk.hasOwnProperty, ioe = Jk.toString, LZ = AW ? AW.toStringTag : void 0, roe = Object.prototype.toString, Q_ = AW ? AW.toStringTag : void 0;
const aoe = function(r) {
  return r == null ? r === void 0 ? "[object Undefined]" : "[object Null]" : Q_ && Q_ in Object(r) ? function(e) {
    var t = noe.call(e, LZ), n = e[LZ];
    try {
      e[LZ] = void 0;
      var i = !0;
    } catch {
    }
    var o = ioe.call(e);
    return i && (t ? e[LZ] = n : delete e[LZ]), o;
  }(r) : function(e) {
    return roe.call(e);
  }(r);
};
var ooe = /^[-+]0x[0-9a-f]+$/i, soe = /^0b[01]+$/i, loe = /^0o[0-7]+$/i, uoe = parseInt;
const j_ = function(r) {
  if (typeof r == "number") return r;
  if (function(n) {
    return typeof n == "symbol" || function(i) {
      return i != null && typeof i == "object";
    }(n) && aoe(n) == "[object Symbol]";
  }(r)) return NaN;
  if (mW(r)) {
    var e = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = mW(e) ? e + "" : e;
  }
  if (typeof r != "string") return r === 0 ? r : +r;
  r = toe(r);
  var t = soe.test(r);
  return t || loe.test(r) ? uoe(r.slice(2), t ? 2 : 8) : ooe.test(r) ? NaN : +r;
};
var coe = Math.max, goe = Math.min;
const RX = function(r, e, t) {
  var n, i, o, l, u, I, C = 0, f = !1, v = !1, b = !0;
  if (typeof r != "function") throw new TypeError("Expected a function");
  function S(Y) {
    var F = n, T = i;
    return n = i = void 0, C = Y, l = r.apply(T, F);
  }
  function R(Y) {
    var F = Y - I;
    return I === void 0 || F >= e || F < 0 || v && Y - C >= o;
  }
  function W() {
    var Y = YH();
    if (R(Y)) return x(Y);
    u = setTimeout(W, function(F) {
      var T = e - (F - I);
      return v ? goe(T, o - (F - C)) : T;
    }(Y));
  }
  function x(Y) {
    return u = void 0, b && n ? S(Y) : (n = i = void 0, l);
  }
  function N() {
    var Y = YH(), F = R(Y);
    if (n = arguments, i = this, I = Y, F) {
      if (u === void 0) return function(T) {
        return C = T, u = setTimeout(W, e), f ? S(T) : l;
      }(I);
      if (v) return clearTimeout(u), u = setTimeout(W, e), S(I);
    }
    return u === void 0 && (u = setTimeout(W, e)), l;
  }
  return e = j_(e) || 0, mW(t) && (f = !!t.leading, o = (v = "maxWait" in t) ? coe(j_(t.maxWait) || 0, e) : o, b = "trailing" in t ? !!t.trailing : b), N.cancel = function() {
    u !== void 0 && clearTimeout(u), C = 0, n = I = i = u = void 0;
  }, N.flush = function() {
    return u === void 0 ? l : x(YH());
  }, N;
}, q_ = function(r, e, t) {
  var n = !0, i = !0;
  if (typeof r != "function") throw new TypeError("Expected a function");
  return mW(t) && (n = "leading" in t ? !!t.leading : n, i = "trailing" in t ? !!t.trailing : i), RX(r, e, { leading: n, maxWait: e, trailing: i });
};
var doe = og(115), Ioe = og.n(doe), Qk = function() {
  if (typeof Map < "u") return Map;
  function r(e, t) {
    var n = -1;
    return e.some(function(i, o) {
      return i[0] === t && (n = o, !0);
    }), n;
  }
  return function() {
    function e() {
      this.__entries__ = [];
    }
    return Object.defineProperty(e.prototype, "size", { get: function() {
      return this.__entries__.length;
    }, enumerable: !0, configurable: !0 }), e.prototype.get = function(t) {
      var n = r(this.__entries__, t), i = this.__entries__[n];
      return i && i[1];
    }, e.prototype.set = function(t, n) {
      var i = r(this.__entries__, t);
      ~i ? this.__entries__[i][1] = n : this.__entries__.push([t, n]);
    }, e.prototype.delete = function(t) {
      var n = this.__entries__, i = r(n, t);
      ~i && n.splice(i, 1);
    }, e.prototype.has = function(t) {
      return !!~r(this.__entries__, t);
    }, e.prototype.clear = function() {
      this.__entries__.splice(0);
    }, e.prototype.forEach = function(t, n) {
      n === void 0 && (n = null);
      for (var i = 0, o = this.__entries__; i < o.length; i++) {
        var l = o[i];
        t.call(n, l[1], l[0]);
      }
    }, e;
  }();
}(), xX = typeof window < "u" && typeof document < "u" && window.document === document, vW = og.g !== void 0 && og.g.Math === Math ? og.g : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")(), Coe = typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(vW) : function(r) {
  return setTimeout(function() {
    return r(Date.now());
  }, 1e3 / 60);
}, hoe = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], foe = typeof MutationObserver < "u", poe = function() {
  function r() {
    this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = /* @__PURE__ */ function(e) {
      var t = !1, n = !1, i = 0;
      function o() {
        t && (t = !1, e()), n && u();
      }
      function l() {
        Coe(o);
      }
      function u() {
        var I = Date.now();
        if (t) {
          if (I - i < 2) return;
          n = !0;
        } else t = !0, n = !1, setTimeout(l, 20);
        i = I;
      }
      return u;
    }(this.refresh.bind(this));
  }
  return r.prototype.addObserver = function(e) {
    ~this.observers_.indexOf(e) || this.observers_.push(e), this.connected_ || this.connect_();
  }, r.prototype.removeObserver = function(e) {
    var t = this.observers_, n = t.indexOf(e);
    ~n && t.splice(n, 1), !t.length && this.connected_ && this.disconnect_();
  }, r.prototype.refresh = function() {
    this.updateObservers_() && this.refresh();
  }, r.prototype.updateObservers_ = function() {
    var e = this.observers_.filter(function(t) {
      return t.gatherActive(), t.hasActive();
    });
    return e.forEach(function(t) {
      return t.broadcastActive();
    }), e.length > 0;
  }, r.prototype.connect_ = function() {
    xX && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), foe ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, { attributes: !0, childList: !0, characterData: !0, subtree: !0 })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
  }, r.prototype.disconnect_ = function() {
    xX && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
  }, r.prototype.onTransitionEnd_ = function(e) {
    var t = e.propertyName, n = t === void 0 ? "" : t;
    hoe.some(function(i) {
      return !!~n.indexOf(i);
    }) && this.refresh();
  }, r.getInstance = function() {
    return this.instance_ || (this.instance_ = new r()), this.instance_;
  }, r.instance_ = null, r;
}(), $_ = function(r, e) {
  for (var t = 0, n = Object.keys(e); t < n.length; t++) {
    var i = n[t];
    Object.defineProperty(r, i, { value: e[i], enumerable: !1, writable: !1, configurable: !0 });
  }
  return r;
}, ZB = function(r) {
  return r && r.ownerDocument && r.ownerDocument.defaultView || vW;
}, ez = yW(0, 0, 0, 0);
function A2(r) {
  return parseFloat(r) || 0;
}
function tz(r) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  return e.reduce(function(n, i) {
    return n + A2(r["border-" + i + "-width"]);
  }, 0);
}
var moe = typeof SVGGraphicsElement < "u" ? function(r) {
  return r instanceof ZB(r).SVGGraphicsElement;
} : function(r) {
  return r instanceof ZB(r).SVGElement && typeof r.getBBox == "function";
};
function Aoe(r) {
  return xX ? moe(r) ? function(e) {
    var t = e.getBBox();
    return yW(0, 0, t.width, t.height);
  }(r) : function(e) {
    var t = e.clientWidth, n = e.clientHeight;
    if (!t && !n) return ez;
    var i = ZB(e).getComputedStyle(e), o = function(b) {
      for (var S = {}, R = 0, W = ["top", "right", "bottom", "left"]; R < W.length; R++) {
        var x = W[R], N = b["padding-" + x];
        S[x] = A2(N);
      }
      return S;
    }(i), l = o.left + o.right, u = o.top + o.bottom, I = A2(i.width), C = A2(i.height);
    if (i.boxSizing === "border-box" && (Math.round(I + l) !== t && (I -= tz(i, "left", "right") + l), Math.round(C + u) !== n && (C -= tz(i, "top", "bottom") + u)), !function(b) {
      return b === ZB(b).document.documentElement;
    }(e)) {
      var f = Math.round(I + l) - t, v = Math.round(C + u) - n;
      Math.abs(f) !== 1 && (I -= f), Math.abs(v) !== 1 && (C -= v);
    }
    return yW(o.left, o.top, I, C);
  }(r) : ez;
}
function yW(r, e, t, n) {
  return { x: r, y: e, width: t, height: n };
}
var voe = function() {
  function r(e) {
    this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = yW(0, 0, 0, 0), this.target = e;
  }
  return r.prototype.isActive = function() {
    var e = Aoe(this.target);
    return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight;
  }, r.prototype.broadcastRect = function() {
    var e = this.contentRect_;
    return this.broadcastWidth = e.width, this.broadcastHeight = e.height, e;
  }, r;
}(), yoe = function(r, e) {
  var t = function(n) {
    var i = n.x, o = n.y, l = n.width, u = n.height, I = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, C = Object.create(I.prototype);
    return $_(C, { x: i, y: o, width: l, height: u, top: o, right: i + l, bottom: u + o, left: i }), C;
  }(e);
  $_(this, { target: r, contentRect: t });
}, boe = function() {
  function r(e, t, n) {
    if (this.activeObservations_ = [], this.observations_ = new Qk(), typeof e != "function") throw new TypeError("The callback provided as parameter 1 is not a function.");
    this.callback_ = e, this.controller_ = t, this.callbackCtx_ = n;
  }
  return r.prototype.observe = function(e) {
    if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
    if (typeof Element < "u" && Element instanceof Object) {
      if (!(e instanceof ZB(e).Element)) throw new TypeError('parameter 1 is not of type "Element".');
      var t = this.observations_;
      t.has(e) || (t.set(e, new voe(e)), this.controller_.addObserver(this), this.controller_.refresh());
    }
  }, r.prototype.unobserve = function(e) {
    if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
    if (typeof Element < "u" && Element instanceof Object) {
      if (!(e instanceof ZB(e).Element)) throw new TypeError('parameter 1 is not of type "Element".');
      var t = this.observations_;
      t.has(e) && (t.delete(e), t.size || this.controller_.removeObserver(this));
    }
  }, r.prototype.disconnect = function() {
    this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
  }, r.prototype.gatherActive = function() {
    var e = this;
    this.clearActive(), this.observations_.forEach(function(t) {
      t.isActive() && e.activeObservations_.push(t);
    });
  }, r.prototype.broadcastActive = function() {
    if (this.hasActive()) {
      var e = this.callbackCtx_, t = this.activeObservations_.map(function(n) {
        return new yoe(n.target, n.broadcastRect());
      });
      this.callback_.call(e, t, e), this.clearActive();
    }
  }, r.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  }, r.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  }, r;
}(), jk = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new Qk(), qk = function r(e) {
  if (!(this instanceof r)) throw new TypeError("Cannot call a class as a function.");
  if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
  var t = poe.getInstance(), n = new boe(e, t, this);
  jk.set(this, n);
};
["observe", "unobserve", "disconnect"].forEach(function(r) {
  qk.prototype[r] = function() {
    var e;
    return (e = jk.get(this))[r].apply(e, arguments);
  };
});
const nz = vW.ResizeObserver !== void 0 ? vW.ResizeObserver : qk, Mm = "Left", Hm = "Right", Xm = "Up", Ym = "Down", PG = { delta: 10, preventScrollOnSwipe: !1, rotationAngle: 0, trackMouse: !1, trackTouch: !0, swipeDuration: 1 / 0, touchEventOptions: { passive: !0 } }, FH = { first: !0, initial: [0, 0], start: 0, swiping: !1, xy: [0, 0] }, iz = "mousemove", rz = "mouseup";
function az(r, e) {
  if (e === 0) return r;
  const t = Math.PI / 180 * e;
  return [r[0] * Math.cos(t) + r[1] * Math.sin(t), r[1] * Math.cos(t) - r[0] * Math.sin(t)];
}
function Goe(r) {
  const { trackMouse: e } = r, t = En.useRef(Object.assign({}, FH)), n = En.useRef(Object.assign({}, PG)), i = En.useRef(Object.assign({}, n.current));
  let o;
  for (o in i.current = Object.assign({}, n.current), n.current = Object.assign(Object.assign({}, PG), r), PG) n.current[o] === void 0 && (n.current[o] = PG[o]);
  const [l, u] = En.useMemo(() => function(I, C) {
    const f = (x) => {
      const N = "touches" in x;
      N && x.touches.length > 1 || I((Y, F) => {
        F.trackMouse && !N && (document.addEventListener(iz, v), document.addEventListener(rz, S));
        const { clientX: T, clientY: P } = N ? x.touches[0] : x, D = az([T, P], F.rotationAngle);
        return F.onTouchStartOrOnMouseDown && F.onTouchStartOrOnMouseDown({ event: x }), Object.assign(Object.assign(Object.assign({}, Y), FH), { initial: D.slice(), xy: D, start: x.timeStamp || 0 });
      });
    }, v = (x) => {
      I((N, Y) => {
        const F = "touches" in x;
        if (F && x.touches.length > 1) return N;
        if (x.timeStamp - N.start > Y.swipeDuration) return N.swiping ? Object.assign(Object.assign({}, N), { swiping: !1 }) : N;
        const { clientX: T, clientY: P } = F ? x.touches[0] : x, [D, L] = az([T, P], Y.rotationAngle), j = D - N.xy[0], J = L - N.xy[1], O = Math.abs(j), ne = Math.abs(J), he = (x.timeStamp || 0) - N.start, pe = Math.sqrt(O * O + ne * ne) / (he || 1), Ae = [j / (he || 1), J / (he || 1)], ke = function(Se, Be, le, Ye) {
          return Se > Be ? le > 0 ? Hm : Mm : Ye > 0 ? Ym : Xm;
        }(O, ne, j, J), Re = typeof Y.delta == "number" ? Y.delta : Y.delta[ke.toLowerCase()] || PG.delta;
        if (O < Re && ne < Re && !N.swiping) return N;
        const Xe = { absX: O, absY: ne, deltaX: j, deltaY: J, dir: ke, event: x, first: N.first, initial: N.initial, velocity: pe, vxvy: Ae };
        Xe.first && Y.onSwipeStart && Y.onSwipeStart(Xe), Y.onSwiping && Y.onSwiping(Xe);
        let re = !1;
        return (Y.onSwiping || Y.onSwiped || Y[`onSwiped${ke}`]) && (re = !0), re && Y.preventScrollOnSwipe && Y.trackTouch && x.cancelable && x.preventDefault(), Object.assign(Object.assign({}, N), { first: !1, eventData: Xe, swiping: !0 });
      });
    }, b = (x) => {
      I((N, Y) => {
        let F;
        if (N.swiping && N.eventData) {
          if (x.timeStamp - N.start < Y.swipeDuration) {
            F = Object.assign(Object.assign({}, N.eventData), { event: x }), Y.onSwiped && Y.onSwiped(F);
            const T = Y[`onSwiped${F.dir}`];
            T && T(F);
          }
        } else Y.onTap && Y.onTap({ event: x });
        return Y.onTouchEndOrOnMouseUp && Y.onTouchEndOrOnMouseUp({ event: x }), Object.assign(Object.assign(Object.assign({}, N), FH), { eventData: F });
      });
    }, S = (x) => {
      document.removeEventListener(iz, v), document.removeEventListener(rz, S), b(x);
    }, R = (x, N) => {
      let Y = () => {
      };
      if (x && x.addEventListener) {
        const F = Object.assign(Object.assign({}, PG.touchEventOptions), N.touchEventOptions), T = [["touchstart", f, F], ["touchmove", v, Object.assign(Object.assign({}, F), N.preventScrollOnSwipe ? { passive: !1 } : {})], ["touchend", b, F]];
        T.forEach(([P, D, L]) => x.addEventListener(P, D, L)), Y = () => T.forEach(([P, D]) => x.removeEventListener(P, D));
      }
      return Y;
    }, W = { ref: (x) => {
      x !== null && I((N, Y) => {
        if (N.el === x) return N;
        const F = {};
        return N.el && N.el !== x && N.cleanUpTouch && (N.cleanUpTouch(), F.cleanUpTouch = void 0), Y.trackTouch && x && (F.cleanUpTouch = R(x, Y)), Object.assign(Object.assign(Object.assign({}, N), { el: x }), F);
      });
    } };
    return C.trackMouse && (W.onMouseDown = f), [W, R];
  }((I) => t.current = I(t.current, n.current), { trackMouse: e }), [e]);
  return t.current = function(I, C, f, v) {
    return C.trackTouch && I.el ? I.cleanUpTouch ? C.preventScrollOnSwipe !== f.preventScrollOnSwipe || C.touchEventOptions.passive !== f.touchEventOptions.passive ? (I.cleanUpTouch(), Object.assign(Object.assign({}, I), { cleanUpTouch: v(I.el, C) })) : I : Object.assign(Object.assign({}, I), { cleanUpTouch: v(I.el, C) }) : (I.cleanUpTouch && I.cleanUpTouch(), Object.assign(Object.assign({}, I), { cleanUpTouch: void 0 }));
  }(t.current, n.current, i.current, u), l;
}
var kt = og(556);
function gw(r) {
  return gw = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, gw(r);
}
function oz(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function sz(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? oz(Object(t), !0).forEach(function(n) {
      Boe(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : oz(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Boe(r, e, t) {
  return (e = function(n) {
    var i = function(o) {
      if (gw(o) != "object" || !o) return o;
      var l = o[Symbol.toPrimitive];
      if (l !== void 0) {
        var u = l.call(o, "string");
        if (gw(u) != "object") return u;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(o);
    }(n);
    return gw(i) == "symbol" ? i : i + "";
  }(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
var Soe = { description: "", fullscreen: "", isFullscreen: !1, originalAlt: "", originalHeight: "", originalWidth: "", originalTitle: "", sizes: "", srcSet: "", loading: "eager" }, WX = En.default.memo(function(r) {
  var e = sz(sz({}, Soe), r), t = e.description, n = e.fullscreen, i = e.handleImageLoaded, o = e.isFullscreen, l = e.onImageError, u = e.original, I = e.originalAlt, C = e.originalHeight, f = e.originalWidth, v = e.originalTitle, b = e.sizes, S = e.srcSet, R = e.loading, W = o && n || u;
  return En.default.createElement(En.default.Fragment, null, En.default.createElement("img", { className: "image-gallery-image", src: W, alt: I, srcSet: S, height: C, width: f, sizes: b, title: v, onLoad: function(x) {
    return i(x, u);
  }, onError: l, loading: R }), t && En.default.createElement("span", { className: "image-gallery-description" }, t));
});
WX.displayName = "Item", WX.propTypes = { description: kt.string, fullscreen: kt.string, handleImageLoaded: kt.func.isRequired, isFullscreen: kt.bool, onImageError: kt.func.isRequired, original: kt.string.isRequired, originalAlt: kt.string, originalHeight: kt.string, originalWidth: kt.string, originalTitle: kt.string, sizes: kt.string, srcSet: kt.string, loading: kt.string };
const Zoe = WX;
function dw(r) {
  return dw = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, dw(r);
}
function lz(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function uz(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? lz(Object(t), !0).forEach(function(n) {
      woe(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : lz(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function woe(r, e, t) {
  return (e = function(n) {
    var i = function(o) {
      if (dw(o) != "object" || !o) return o;
      var l = o[Symbol.toPrimitive];
      if (l !== void 0) {
        var u = l.call(o, "string");
        if (dw(u) != "object") return u;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(o);
    }(n);
    return dw(i) == "symbol" ? i : i + "";
  }(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
var Roe = { left: En.default.createElement("polyline", { points: "15 18 9 12 15 6" }), right: En.default.createElement("polyline", { points: "9 18 15 12 9 6" }), top: En.default.createElement("polyline", { points: "6 15 12 9 18 15" }), bottom: En.default.createElement("polyline", { points: "6 9 12 15 18 9" }), maximize: En.default.createElement("path", { d: "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" }), minimize: En.default.createElement("path", { d: "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" }), play: En.default.createElement("polygon", { points: "5 3 19 12 5 21 5 3" }), pause: En.default.createElement(En.default.Fragment, null, En.default.createElement("rect", { x: "6", y: "4", width: "4", height: "16" }), En.default.createElement("rect", { x: "14", y: "4", width: "4", height: "16" })) }, xoe = { strokeWidth: 1, viewBox: "0 0 24 24" }, $k = function(r) {
  var e = uz(uz({}, xoe), r), t = e.strokeWidth, n = e.viewBox, i = e.icon;
  return En.default.createElement("svg", { className: "image-gallery-svg", xmlns: "http://www.w3.org/2000/svg", viewBox: n, fill: "none", stroke: "currentColor", strokeWidth: t, strokeLinecap: "round", strokeLinejoin: "round" }, Roe[i]);
};
$k.propTypes = { strokeWidth: kt.number, viewBox: kt.string, icon: (0, kt.oneOf)(["left", "right", "top", "bottom", "maximize", "minimize", "play", "pause"]).isRequired };
const MB = $k;
var VX = En.default.memo(function(r) {
  var e = r.isFullscreen, t = r.onClick;
  return En.default.createElement("button", { type: "button", className: "image-gallery-icon image-gallery-fullscreen-button", onClick: t, "aria-label": "Open Fullscreen" }, En.default.createElement(MB, { strokeWidth: 2, icon: e ? "minimize" : "maximize" }));
});
VX.displayName = "Fullscreen", VX.propTypes = { isFullscreen: kt.bool.isRequired, onClick: kt.func.isRequired };
const Woe = VX;
var NX = En.default.memo(function(r) {
  var e = r.disabled, t = r.onClick;
  return En.default.createElement("button", { type: "button", className: "image-gallery-icon image-gallery-left-nav", disabled: e, onClick: t, "aria-label": "Previous Slide" }, En.default.createElement(MB, { icon: "left", viewBox: "6 0 12 24" }));
});
NX.displayName = "LeftNav", NX.propTypes = { disabled: kt.bool.isRequired, onClick: kt.func.isRequired };
const Voe = NX;
var MX = En.default.memo(function(r) {
  var e = r.disabled, t = r.onClick;
  return En.default.createElement("button", { type: "button", className: "image-gallery-icon image-gallery-right-nav", disabled: e, onClick: t, "aria-label": "Next Slide" }, En.default.createElement(MB, { icon: "right", viewBox: "6 0 12 24" }));
});
MX.displayName = "RightNav", MX.propTypes = { disabled: kt.bool.isRequired, onClick: kt.func.isRequired };
const Noe = MX;
var HX = En.default.memo(function(r) {
  var e = r.isPlaying, t = r.onClick;
  return En.default.createElement("button", { type: "button", className: "image-gallery-icon image-gallery-play-button", onClick: t, "aria-label": "Play or Pause Slideshow" }, En.default.createElement(MB, { strokeWidth: 2, icon: e ? "pause" : "play" }));
});
HX.displayName = "PlayPause", HX.propTypes = { isPlaying: kt.bool.isRequired, onClick: kt.func.isRequired };
const Moe = HX;
function Iw(r) {
  return Iw = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Iw(r);
}
function XX() {
  return XX = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, XX.apply(null, arguments);
}
function cz(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function gz(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? cz(Object(t), !0).forEach(function(n) {
      Hoe(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : cz(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Hoe(r, e, t) {
  return (e = function(n) {
    var i = function(o) {
      if (Iw(o) != "object" || !o) return o;
      var l = o[Symbol.toPrimitive];
      if (l !== void 0) {
        var u = l.call(o, "string");
        if (Iw(u) != "object") return u;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(o);
    }(n);
    return Iw(i) == "symbol" ? i : i + "";
  }(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
var Xoe = { className: "", delta: 0, onSwiping: function() {
}, onSwiped: function() {
} }, eD = function(r) {
  var e = gz(gz({}, Xoe), r), t = e.children, n = e.className, i = Goe({ delta: e.delta, onSwiping: e.onSwiping, onSwiped: e.onSwiped });
  return En.default.createElement("div", XX({}, i, { className: n }), t);
};
eD.propTypes = { children: kt.node.isRequired, className: kt.string, delta: kt.number, onSwiped: kt.func, onSwiping: kt.func };
const dz = eD;
var YX = En.default.memo(function(r) {
  var e = r.disabled, t = r.onClick;
  return En.default.createElement("button", { type: "button", className: "image-gallery-icon image-gallery-top-nav", disabled: e, onClick: t, "aria-label": "Previous Slide" }, En.default.createElement(MB, { icon: "top", viewBox: "6 0 12 24" }));
});
YX.displayName = "TopNav", YX.propTypes = { disabled: kt.bool.isRequired, onClick: kt.func.isRequired };
const Yoe = YX;
var FX = En.default.memo(function(r) {
  var e = r.disabled, t = r.onClick;
  return En.default.createElement("button", { type: "button", className: "image-gallery-icon image-gallery-bottom-nav", disabled: e, onClick: t, "aria-label": "Next Slide" }, En.default.createElement(MB, { icon: "bottom", viewBox: "6 0 12 24" }));
});
FX.displayName = "BottomNav", FX.propTypes = { disabled: kt.bool.isRequired, onClick: kt.func.isRequired };
const Foe = FX;
function IB(r) {
  return IB = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, IB(r);
}
function Iz(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Cz(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Iz(Object(t), !0).forEach(function(n) {
      jG(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Iz(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function Eoe(r, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, nD(n.key), n);
  }
}
function tD() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (tD = function() {
    return !!r;
  })();
}
function bW(r) {
  return bW = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, bW(r);
}
function EX(r, e) {
  return EX = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
    return t.__proto__ = n, t;
  }, EX(r, e);
}
function jG(r, e, t) {
  return (e = nD(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function nD(r) {
  var e = function(t) {
    if (IB(t) != "object" || !t) return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
      var i = n.call(t, "string");
      if (IB(i) != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(t);
  }(r);
  return IB(e) == "symbol" ? e : e + "";
}
var hz = ["fullscreenchange", "MSFullscreenChange", "mozfullscreenchange", "webkitfullscreenchange"], Toe = (0, kt.arrayOf)((0, kt.shape)({ srcSet: kt.string, media: kt.string }));
function fz(r) {
  var e = parseInt(r.keyCode || r.which || 0, 10);
  return e === 66 || e === 62;
}
var TX = function() {
  function r(e) {
    var t, n, i, o;
    return function(l, u) {
      if (!(l instanceof u)) throw new TypeError("Cannot call a class as a function");
    }(this, r), jG((n = this, o = [e], i = bW(i = r), t = function(l, u) {
      if (u && (IB(u) == "object" || typeof u == "function")) return u;
      if (u !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
      return function(I) {
        if (I === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return I;
      }(l);
    }(n, tD() ? Reflect.construct(i, o || [], bW(n).constructor) : i.apply(n, o))), "onBulletClick", function(l, u) {
      var I = t.props, C = I.onBulletClick, f = I.items, v = t.state.currentIndex;
      l.target.blur(), v !== u && (f.length === 2 ? t.slideToIndexWithStyleReset(u, l) : t.slideToIndex(u, l)), C && C(l, u);
    }), t.state = { currentIndex: e.startIndex, thumbsTranslate: 0, thumbsSwipedTranslate: 0, currentSlideOffset: 0, galleryWidth: 0, galleryHeight: 0, thumbnailsWrapperWidth: 0, thumbnailsWrapperHeight: 0, thumbsStyle: { transition: "all ".concat(e.slideDuration, "ms ease-out") }, isFullscreen: !1, isSwipingThumbnail: !1, isPlaying: !1 }, t.loadedImages = {}, t.imageGallery = En.default.createRef(), t.thumbnailsWrapper = En.default.createRef(), t.thumbnails = En.default.createRef(), t.imageGallerySlideWrapper = En.default.createRef(), t.handleImageLoaded = t.handleImageLoaded.bind(t), t.handleKeyDown = t.handleKeyDown.bind(t), t.handleMouseDown = t.handleMouseDown.bind(t), t.handleResize = t.handleResize.bind(t), t.handleOnSwiped = t.handleOnSwiped.bind(t), t.handleScreenChange = t.handleScreenChange.bind(t), t.handleSwiping = t.handleSwiping.bind(t), t.handleThumbnailSwiping = t.handleThumbnailSwiping.bind(t), t.handleOnThumbnailSwiped = t.handleOnThumbnailSwiped.bind(t), t.onThumbnailMouseLeave = t.onThumbnailMouseLeave.bind(t), t.handleImageError = t.handleImageError.bind(t), t.pauseOrPlay = t.pauseOrPlay.bind(t), t.renderThumbInner = t.renderThumbInner.bind(t), t.renderItem = t.renderItem.bind(t), t.slideLeft = t.slideLeft.bind(t), t.slideRight = t.slideRight.bind(t), t.toggleFullScreen = t.toggleFullScreen.bind(t), t.togglePlay = t.togglePlay.bind(t), t.unthrottledSlideToIndex = t.slideToIndex, t.slideToIndex = q_(t.unthrottledSlideToIndex, e.slideDuration, { trailing: !1 }), e.lazyLoad && (t.lazyLoaded = []), t;
  }
  return function(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && EX(e, t);
  }(r, En.default.Component), function(e, t) {
    return t && Eoe(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
  }(r, [{ key: "componentDidMount", value: function() {
    var e = this.props, t = e.autoPlay, n = e.useWindowKeyDown;
    t && this.play(), n ? window.addEventListener("keydown", this.handleKeyDown) : this.imageGallery.current.addEventListener("keydown", this.handleKeyDown), window.addEventListener("mousedown", this.handleMouseDown), this.initSlideWrapperResizeObserver(this.imageGallerySlideWrapper), this.initThumbnailWrapperResizeObserver(this.thumbnailsWrapper), this.addScreenChangeEvent();
  } }, { key: "componentDidUpdate", value: function(e, t) {
    var n = this.props, i = n.items, o = n.lazyLoad, l = n.slideDuration, u = n.slideInterval, I = n.startIndex, C = n.thumbnailPosition, f = n.showThumbnails, v = n.useWindowKeyDown, b = this.state, S = b.currentIndex, R = b.isPlaying, W = e.items.length !== i.length, x = !Ioe()(e.items, i), N = e.startIndex !== I, Y = e.thumbnailPosition !== C, F = e.showThumbnails !== f;
    u === e.slideInterval && l === e.slideDuration || R && (this.pause(), this.play()), Y && (this.removeResizeObserver(), this.initSlideWrapperResizeObserver(this.imageGallerySlideWrapper), this.initThumbnailWrapperResizeObserver(this.thumbnailsWrapper)), F && f && this.initThumbnailWrapperResizeObserver(this.thumbnailsWrapper), F && !f && this.removeThumbnailsResizeObserver(), (W || F) && this.handleResize(), t.currentIndex !== S && this.slideThumbnailBar(), e.slideDuration !== l && (this.slideToIndex = q_(this.unthrottledSlideToIndex, l, { trailing: !1 })), !o || e.lazyLoad && !x || (this.lazyLoaded = []), v !== e.useWindowKeyDown && (v ? (this.imageGallery.current.removeEventListener("keydown", this.handleKeyDown), window.addEventListener("keydown", this.handleKeyDown)) : (window.removeEventListener("keydown", this.handleKeyDown), this.imageGallery.current.addEventListener("keydown", this.handleKeyDown))), (N || x) && this.setState({ currentIndex: I, slideStyle: { transition: "none" } });
  } }, { key: "componentWillUnmount", value: function() {
    var e = this.props.useWindowKeyDown;
    window.removeEventListener("mousedown", this.handleMouseDown), this.removeScreenChangeEvent(), this.removeResizeObserver(), this.playPauseIntervalId && (window.clearInterval(this.playPauseIntervalId), this.playPauseIntervalId = null), this.transitionTimer && window.clearTimeout(this.transitionTimer), e ? window.removeEventListener("keydown", this.handleKeyDown) : this.imageGallery.current.removeEventListener("keydown", this.handleKeyDown);
  } }, { key: "onSliding", value: function() {
    var e = this, t = this.state, n = t.currentIndex, i = t.isTransitioning, o = this.props, l = o.onSlide, u = o.slideDuration;
    this.transitionTimer = window.setTimeout(function() {
      i && (e.setState({ isTransitioning: !i, isSwipingThumbnail: !1 }), l && l(n));
    }, u + 50);
  } }, { key: "onThumbnailClick", value: function(e, t) {
    var n = this.props, i = n.onThumbnailClick, o = n.items, l = this.state.currentIndex;
    e.target.parentNode.parentNode.blur(), l !== t && (o.length === 2 ? this.slideToIndexWithStyleReset(t, e) : this.slideToIndex(t, e)), i && i(e, t);
  } }, { key: "onThumbnailMouseOver", value: function(e, t) {
    var n = this;
    this.thumbnailMouseOverTimer && (window.clearTimeout(this.thumbnailMouseOverTimer), this.thumbnailMouseOverTimer = null), this.thumbnailMouseOverTimer = window.setTimeout(function() {
      n.slideToIndex(t), n.pause();
    }, 300);
  } }, { key: "onThumbnailMouseLeave", value: function() {
    if (this.thumbnailMouseOverTimer) {
      var e = this.props.autoPlay;
      window.clearTimeout(this.thumbnailMouseOverTimer), this.thumbnailMouseOverTimer = null, e && this.play();
    }
  } }, { key: "setThumbsTranslate", value: function(e) {
    this.setState({ thumbsTranslate: e });
  } }, { key: "setModalFullscreen", value: function(e) {
    var t = this.props.onScreenChange;
    this.setState({ modalFullscreen: e }), t && t(e);
  } }, { key: "getThumbsTranslate", value: function(e) {
    var t, n = this.props, i = n.disableThumbnailScroll, o = n.items, l = this.state, u = l.thumbnailsWrapperWidth, I = l.thumbnailsWrapperHeight, C = this.thumbnails && this.thumbnails.current;
    if (i) return 0;
    if (C) {
      if (this.isThumbnailVertical()) {
        if (C.scrollHeight <= I) return 0;
        t = C.scrollHeight - I;
      } else {
        if (C.scrollWidth <= u || u <= 0) return 0;
        t = C.scrollWidth - u;
      }
      return e * (t / (o.length - 1));
    }
    return 0;
  } }, { key: "getThumbnailPositionClassName", value: function(e) {
    switch (e) {
      case "left":
        e = " ".concat("image-gallery-thumbnails-left");
        break;
      case "right":
        e = " ".concat("image-gallery-thumbnails-right");
        break;
      case "bottom":
        e = " ".concat("image-gallery-thumbnails-bottom");
        break;
      case "top":
        e = " ".concat("image-gallery-thumbnails-top");
    }
    return e;
  } }, { key: "getAlignmentClassName", value: function(e) {
    var t = this.state.currentIndex, n = this.props, i = n.infinite, o = n.items, l = "", u = "image-gallery-left", I = "image-gallery-right";
    switch (e) {
      case t - 1:
        l = " ".concat(u);
        break;
      case t:
        l = " ".concat("image-gallery-center");
        break;
      case t + 1:
        l = " ".concat(I);
    }
    return o.length >= 3 && i && (e === 0 && t === o.length - 1 ? l = " ".concat(I) : e === o.length - 1 && t === 0 && (l = " ".concat(u))), l;
  } }, { key: "getTranslateXForTwoSlide", value: function(e) {
    var t = this.state, n = t.currentIndex, i = t.currentSlideOffset, o = t.previousIndex, l = n !== o, u = e === 0 && o === 0, I = e === 1 && o === 1, C = e === 0 && n === 1, f = e === 1 && n === 0, v = i === 0, b = -100 * n + 100 * e + i;
    return i > 0 ? this.direction = "left" : i < 0 && (this.direction = "right"), f && i > 0 && (b = -100 + i), C && i < 0 && (b = 100 + i), l ? u && v && this.direction === "left" ? b = 100 : I && v && this.direction === "right" && (b = -100) : (f && v && this.direction === "left" && (b = -100), C && v && this.direction === "right" && (b = 100)), b;
  } }, { key: "getThumbnailBarHeight", value: function() {
    return this.isThumbnailVertical() ? { height: this.state.gallerySlideWrapperHeight } : {};
  } }, { key: "getSlideStyle", value: function(e) {
    var t = this.state, n = t.currentIndex, i = t.currentSlideOffset, o = t.slideStyle, l = this.props, u = l.infinite, I = l.items, C = l.useTranslate3D, f = l.isRTL, v = l.slideVertically, b = -100 * n, S = I.length - 1, R = (b + 100 * e) * (f ? -1 : 1) + i;
    u && I.length > 2 && (n === 0 && e === S ? R = -100 * (f ? -1 : 1) + i : n === S && e === 0 && (R = 100 * (f ? -1 : 1) + i)), u && I.length === 2 && (R = this.getTranslateXForTwoSlide(e));
    var W = v ? "translate(0, ".concat(R, "%)") : "translate(".concat(R, "%, 0)");
    return C && (W = v ? "translate3d(0, ".concat(R, "%, 0)") : "translate3d(".concat(R, "%, 0, 0)")), Cz({ display: this.isSlideVisible(e) ? "inherit" : "none", WebkitTransform: W, MozTransform: W, msTransform: W, OTransform: W, transform: W }, o);
  } }, { key: "getCurrentIndex", value: function() {
    return this.state.currentIndex;
  } }, { key: "getThumbnailStyle", value: function() {
    var e, t = this.props, n = t.useTranslate3D, i = t.isRTL, o = this.state, l = o.thumbsTranslate, u = o.thumbsStyle, I = i ? -1 * l : l;
    return this.isThumbnailVertical() ? (e = "translate(0, ".concat(l, "px)"), n && (e = "translate3d(0, ".concat(l, "px, 0)"))) : (e = "translate(".concat(I, "px, 0)"), n && (e = "translate3d(".concat(I, "px, 0, 0)"))), Cz({ WebkitTransform: e, MozTransform: e, msTransform: e, OTransform: e, transform: e }, u);
  } }, { key: "getSlideItems", value: function() {
    var e = this, t = this.state.currentIndex, n = this.props, i = n.items, o = n.slideOnThumbnailOver, l = n.onClick, u = n.lazyLoad, I = n.onTouchMove, C = n.onTouchEnd, f = n.onTouchStart, v = n.onMouseOver, b = n.onMouseLeave, S = n.renderItem, R = n.renderThumbInner, W = n.showThumbnails, x = n.showBullets, N = [], Y = [], F = [];
    return i.forEach(function(T, P) {
      var D = e.getAlignmentClassName(P), L = T.originalClass ? " ".concat(T.originalClass) : "", j = T.thumbnailClass ? " ".concat(T.thumbnailClass) : "", J = T.renderItem || S || e.renderItem, O = T.renderThumbInner || R || e.renderThumbInner, ne = !u || D || e.lazyLoaded[P];
      ne && u && !e.lazyLoaded[P] && (e.lazyLoaded[P] = !0);
      var he = e.getSlideStyle(P), pe = En.default.createElement("div", { "aria-label": "Go to Slide ".concat(P + 1), key: "slide-".concat(P), tabIndex: "-1", className: "image-gallery-slide ".concat(D, " ").concat(L), style: he, onClick: l, onKeyUp: e.handleSlideKeyUp, onTouchMove: I, onTouchEnd: C, onTouchStart: f, onMouseOver: v, onFocus: v, onMouseLeave: b, role: "button" }, ne ? J(T) : En.default.createElement("div", { style: { height: "100%" } }));
      if (N.push(pe), W && T.thumbnail) {
        var Ae = jy("image-gallery-thumbnail", j, { active: t === P });
        Y.push(En.default.createElement("button", { key: "thumbnail-".concat(P), type: "button", tabIndex: "0", "aria-pressed": t === P ? "true" : "false", "aria-label": "Go to Slide ".concat(P + 1), className: Ae, onMouseLeave: o ? e.onThumbnailMouseLeave : null, onMouseOver: function(Re) {
          return e.handleThumbnailMouseOver(Re, P);
        }, onFocus: function(Re) {
          return e.handleThumbnailMouseOver(Re, P);
        }, onKeyUp: function(Re) {
          return e.handleThumbnailKeyUp(Re, P);
        }, onClick: function(Re) {
          return e.onThumbnailClick(Re, P);
        } }, O(T)));
      }
      if (x) {
        var ke = jy("image-gallery-bullet", T.bulletClass, { active: t === P });
        F.push(En.default.createElement("button", { type: "button", key: "bullet-".concat(P), className: ke, onClick: function(Re) {
          return e.onBulletClick(Re, P);
        }, "aria-pressed": t === P ? "true" : "false", "aria-label": "Go to Slide ".concat(P + 1) }));
      }
    }), { slides: N, thumbnails: Y, bullets: F };
  } }, { key: "ignoreIsTransitioning", value: function() {
    var e = this.props.items, t = this.state, n = t.previousIndex, i = t.currentIndex, o = e.length - 1;
    return Math.abs(n - i) > 1 && !(n === 0 && i === o) && !(n === o && i === 0);
  } }, { key: "isFirstOrLastSlide", value: function(e) {
    return e === this.props.items.length - 1 || e === 0;
  } }, { key: "slideIsTransitioning", value: function(e) {
    var t = this.state, n = t.isTransitioning, i = t.previousIndex, o = t.currentIndex;
    return n && !(e === i || e === o);
  } }, { key: "isSlideVisible", value: function(e) {
    return !this.slideIsTransitioning(e) || this.ignoreIsTransitioning() && !this.isFirstOrLastSlide(e);
  } }, { key: "slideThumbnailBar", value: function() {
    var e = this.state, t = e.currentIndex, n = e.isSwipingThumbnail, i = -this.getThumbsTranslate(t);
    n || (t === 0 ? this.setState({ thumbsTranslate: 0, thumbsSwipedTranslate: 0 }) : this.setState({ thumbsTranslate: i, thumbsSwipedTranslate: i }));
  } }, { key: "canSlide", value: function() {
    return this.props.items.length >= 2;
  } }, { key: "canSlideLeft", value: function() {
    var e = this.props, t = e.infinite, n = e.isRTL;
    return t || (n ? this.canSlideNext() : this.canSlidePrevious());
  } }, { key: "canSlideRight", value: function() {
    var e = this.props, t = e.infinite, n = e.isRTL;
    return t || (n ? this.canSlidePrevious() : this.canSlideNext());
  } }, { key: "canSlidePrevious", value: function() {
    return this.state.currentIndex > 0;
  } }, { key: "canSlideNext", value: function() {
    return this.state.currentIndex < this.props.items.length - 1;
  } }, { key: "handleSwiping", value: function(e) {
    var t = e.event, n = e.absX, i = e.absY, o = e.dir, l = this.props, u = l.disableSwipe, I = l.stopPropagation, C = l.swipingTransitionDuration, f = this.state, v = f.galleryWidth, b = f.galleryHeight, S = f.isTransitioning, R = f.swipingUpDown, W = f.swipingLeftRight, x = this.props.slideVertically;
    if ((o !== Xm && o !== Ym && !R || W || (R || this.setState({ swipingUpDown: !0 }), x)) && (o !== Mm && o !== Hm || W || this.setState({ swipingLeftRight: !0 }), !u)) if (I && t.preventDefault(), S) this.setState({ currentSlideOffset: 0 });
    else {
      if ((o === Mm || o === Hm) && x || (o === Xm || o === Ym) && !x) return;
      var N = jG(jG(jG(jG({}, Mm, -1), Hm, 1), Xm, -1), Ym, 1)[o], Y = n / v * 100;
      x && (Y = i / b * 100), Math.abs(Y) >= 100 && (Y = 100);
      var F = { transition: "transform ".concat(C, "ms ease-out") };
      this.setState({ currentSlideOffset: N * Y, slideStyle: F });
    }
  } }, { key: "handleThumbnailSwiping", value: function(e) {
    var t = e.event, n = e.absX, i = e.absY, o = e.dir, l = this.props, u = l.stopPropagation, I = l.swipingThumbnailTransitionDuration, C = this.state, f = C.thumbsSwipedTranslate, v = C.thumbnailsWrapperHeight, b = C.thumbnailsWrapperWidth, S = C.swipingUpDown, R = C.swipingLeftRight;
    if (this.isThumbnailVertical()) {
      if ((o === Mm || o === Hm || R) && !S) return void (R || this.setState({ swipingLeftRight: !0 }));
      o !== Xm && o !== Ym || S || this.setState({ swipingUpDown: !0 });
    } else {
      if ((o === Xm || o === Ym || S) && !R) return void (S || this.setState({ swipingUpDown: !0 }));
      o !== Mm && o !== Hm || R || this.setState({ swipingLeftRight: !0 });
    }
    var W, x, N, Y, F, T = this.thumbnails && this.thumbnails.current;
    if (this.isThumbnailVertical() ? (W = f + (o === Ym ? i : -i), x = T.scrollHeight - v + 20, N = Math.abs(W) > x, Y = W > 20, F = T.scrollHeight <= v) : (W = f + (o === Hm ? n : -n), x = T.scrollWidth - b + 20, N = Math.abs(W) > x, Y = W > 20, F = T.scrollWidth <= b), !F && (o !== Mm && o !== Xm || !N) && (o !== Hm && o !== Ym || !Y)) {
      u && t.stopPropagation();
      var P = { transition: "transform ".concat(I, "ms ease-out") };
      this.setState({ thumbsTranslate: W, thumbsStyle: P });
    }
  } }, { key: "handleOnThumbnailSwiped", value: function() {
    var e = this.state.thumbsTranslate, t = this.props.slideDuration;
    this.resetSwipingDirection(), this.setState({ isSwipingThumbnail: !0, thumbsSwipedTranslate: e, thumbsStyle: { transition: "all ".concat(t, "ms ease-out") } });
  } }, { key: "sufficientSwipe", value: function() {
    var e = this.state.currentSlideOffset, t = this.props.swipeThreshold;
    return Math.abs(e) > t;
  } }, { key: "resetSwipingDirection", value: function() {
    var e = this.state, t = e.swipingUpDown, n = e.swipingLeftRight;
    t && this.setState({ swipingUpDown: !1 }), n && this.setState({ swipingLeftRight: !1 });
  } }, { key: "handleOnSwiped", value: function(e) {
    var t = e.event, n = e.dir, i = e.velocity, o = this.props, l = o.disableSwipe, u = o.stopPropagation, I = o.flickThreshold, C = this.props.slideVertically;
    if (!l) {
      var f = this.props.isRTL;
      u && t.stopPropagation(), this.resetSwipingDirection();
      var v = (n === Mm ? 1 : -1) * (f ? -1 : 1);
      C && (v = n === Xm ? 1 : -1);
      var b = C ? i > I && !(n === Mm || n === Hm) : i > I && !(n === Xm || n === Ym);
      this.handleOnSwipedTo(v, b);
    }
  } }, { key: "handleOnSwipedTo", value: function(e, t) {
    var n = this.state, i = n.currentIndex, o = n.isTransitioning, l = i;
    !this.sufficientSwipe() && !t || o || (l += e), (e === -1 && !this.canSlideLeft() || e === 1 && !this.canSlideRight()) && (l = i), this.unthrottledSlideToIndex(l);
  } }, { key: "handleMouseDown", value: function() {
    this.imageGallery.current.classList.add("image-gallery-using-mouse");
  } }, { key: "handleKeyDown", value: function(e) {
    var t = this.props, n = t.disableKeyDown, i = t.useBrowserFullscreen, o = this.state.isFullscreen;
    if (this.imageGallery.current.classList.remove("image-gallery-using-mouse"), !n) switch (parseInt(e.keyCode || e.which || 0, 10)) {
      case 37:
        this.canSlideLeft() && !this.playPauseIntervalId && this.slideLeft(e);
        break;
      case 39:
        this.canSlideRight() && !this.playPauseIntervalId && this.slideRight(e);
        break;
      case 27:
        o && !i && this.exitFullScreen();
    }
  } }, { key: "handleImageError", value: function(e) {
    var t = this.props.onErrorImageURL;
    t && e.target.src.indexOf(t) === -1 && (e.target.src = t);
  } }, { key: "removeThumbnailsResizeObserver", value: function() {
    this.resizeThumbnailWrapperObserver && this.thumbnailsWrapper && this.thumbnailsWrapper.current && (this.resizeThumbnailWrapperObserver.unobserve(this.thumbnailsWrapper.current), this.resizeThumbnailWrapperObserver = null);
  } }, { key: "removeResizeObserver", value: function() {
    this.resizeSlideWrapperObserver && this.imageGallerySlideWrapper && this.imageGallerySlideWrapper.current && (this.resizeSlideWrapperObserver.unobserve(this.imageGallerySlideWrapper.current), this.resizeSlideWrapperObserver = null), this.removeThumbnailsResizeObserver();
  } }, { key: "handleResize", value: function() {
    var e = this.state.currentIndex;
    this.imageGallery && (this.imageGallery && this.imageGallery.current && this.setState({ galleryWidth: this.imageGallery.current.offsetWidth, galleryHeight: this.imageGallery.current.offsetHeight }), this.imageGallerySlideWrapper && this.imageGallerySlideWrapper.current && this.setState({ gallerySlideWrapperHeight: this.imageGallerySlideWrapper.current.offsetHeight }), this.setThumbsTranslate(-this.getThumbsTranslate(e)));
  } }, { key: "initSlideWrapperResizeObserver", value: function(e) {
    var t = this;
    e && !e.current || (this.resizeSlideWrapperObserver = new nz(RX(function(n) {
      n && n.forEach(function(i) {
        t.setState({ thumbnailsWrapperWidth: i.contentRect.width }, t.handleResize);
      });
    }, 50)), this.resizeSlideWrapperObserver.observe(e.current));
  } }, { key: "initThumbnailWrapperResizeObserver", value: function(e) {
    var t = this;
    e && !e.current || (this.resizeThumbnailWrapperObserver = new nz(RX(function(n) {
      n && n.forEach(function(i) {
        t.setState({ thumbnailsWrapperHeight: i.contentRect.height }, t.handleResize);
      });
    }, 50)), this.resizeThumbnailWrapperObserver.observe(e.current));
  } }, { key: "toggleFullScreen", value: function() {
    this.state.isFullscreen ? this.exitFullScreen() : this.fullScreen();
  } }, { key: "togglePlay", value: function() {
    this.playPauseIntervalId ? this.pause() : this.play();
  } }, { key: "handleScreenChange", value: function() {
    var e = this.props, t = e.onScreenChange, n = e.useBrowserFullscreen, i = document.fullscreenElement || document.msFullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement, o = this.imageGallery.current === i;
    t && t(o), n && this.setState({ isFullscreen: o });
  } }, { key: "slideToIndex", value: function(e, t) {
    var n = this.state, i = n.currentIndex, o = n.isTransitioning, l = this.props, u = l.items, I = l.slideDuration, C = l.onBeforeSlide;
    if (!o) {
      t && this.playPauseIntervalId && (this.pause(!1), this.play(!1));
      var f = u.length - 1, v = e;
      e < 0 ? v = f : e > f && (v = 0), C && v !== i && C(v), this.setState({ previousIndex: i, currentIndex: v, isTransitioning: v !== i, currentSlideOffset: 0, slideStyle: { transition: "all ".concat(I, "ms ease-out") } }, this.onSliding);
    }
  } }, { key: "slideLeft", value: function(e) {
    var t = this.props.isRTL;
    this.slideTo(e, t ? "right" : "left");
  } }, { key: "slideRight", value: function(e) {
    var t = this.props.isRTL;
    this.slideTo(e, t ? "left" : "right");
  } }, { key: "slideTo", value: function(e, t) {
    var n = this.state, i = n.currentIndex, o = n.isTransitioning, l = this.props.items, u = i + (t === "left" ? -1 : 1);
    o || (l.length === 2 ? this.slideToIndexWithStyleReset(u, e) : this.slideToIndex(u, e));
  } }, { key: "slideToIndexWithStyleReset", value: function(e, t) {
    var n = this, i = this.state, o = i.currentIndex, l = i.currentSlideOffset;
    this.setState({ currentSlideOffset: l + (o > e ? 1e-3 : -1e-3), slideStyle: { transition: "none" } }, function() {
      window.setTimeout(function() {
        return n.slideToIndex(e, t);
      }, 25);
    });
  } }, { key: "handleThumbnailMouseOver", value: function(e, t) {
    this.props.slideOnThumbnailOver && this.onThumbnailMouseOver(e, t);
  } }, { key: "handleThumbnailKeyUp", value: function(e, t) {
    fz(e) && this.onThumbnailClick(e, t);
  } }, { key: "handleSlideKeyUp", value: function(e) {
    fz(e) && (0, this.props.onClick)(e);
  } }, { key: "isThumbnailVertical", value: function() {
    var e = this.props.thumbnailPosition;
    return e === "left" || e === "right";
  } }, { key: "addScreenChangeEvent", value: function() {
    var e = this;
    hz.forEach(function(t) {
      document.addEventListener(t, e.handleScreenChange);
    });
  } }, { key: "removeScreenChangeEvent", value: function() {
    var e = this;
    hz.forEach(function(t) {
      document.removeEventListener(t, e.handleScreenChange);
    });
  } }, { key: "fullScreen", value: function() {
    var e = this.props.useBrowserFullscreen, t = this.imageGallery.current;
    e ? t.requestFullscreen ? t.requestFullscreen() : t.msRequestFullscreen ? t.msRequestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : this.setModalFullscreen(!0) : this.setModalFullscreen(!0), this.setState({ isFullscreen: !0 });
  } }, { key: "exitFullScreen", value: function() {
    var e = this.state.isFullscreen, t = this.props.useBrowserFullscreen;
    e && (t ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen ? document.msExitFullscreen() : this.setModalFullscreen(!1) : this.setModalFullscreen(!1), this.setState({ isFullscreen: !1 }));
  } }, { key: "pauseOrPlay", value: function() {
    var e = this.props.infinite, t = this.state.currentIndex;
    e || this.canSlideRight() ? this.slideToIndex(t + 1) : this.pause();
  } }, { key: "play", value: function() {
    var e = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t = this.props, n = t.onPlay, i = t.slideInterval, o = t.slideDuration, l = this.state.currentIndex;
    this.playPauseIntervalId || (this.setState({ isPlaying: !0 }), this.playPauseIntervalId = window.setInterval(this.pauseOrPlay, Math.max(i, o)), n && e && n(l));
  } }, { key: "pause", value: function() {
    var e = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t = this.props.onPause, n = this.state.currentIndex;
    this.playPauseIntervalId && (window.clearInterval(this.playPauseIntervalId), this.playPauseIntervalId = null, this.setState({ isPlaying: !1 }), t && e && t(n));
  } }, { key: "isImageLoaded", value: function(e) {
    return !!this.loadedImages[e.original] || (this.loadedImages[e.original] = !0, !1);
  } }, { key: "handleImageLoaded", value: function(e, t) {
    var n = this.props.onImageLoad;
    !this.loadedImages[t] && n && (this.loadedImages[t] = !0, n(e));
  } }, { key: "renderItem", value: function(e) {
    var t = this.state.isFullscreen, n = this.props.onImageError || this.handleImageError;
    return En.default.createElement(Zoe, { description: e.description, fullscreen: e.fullscreen, handleImageLoaded: this.handleImageLoaded, isFullscreen: t, onImageError: n, original: e.original, originalAlt: e.originalAlt, originalHeight: e.originalHeight, originalWidth: e.originalWidth, originalTitle: e.originalTitle, sizes: e.sizes, loading: e.loading, srcSet: e.srcSet });
  } }, { key: "renderThumbInner", value: function(e) {
    var t = this.props.onThumbnailError || this.handleImageError;
    return En.default.createElement("span", { className: "image-gallery-thumbnail-inner" }, En.default.createElement("img", { className: "image-gallery-thumbnail-image", src: e.thumbnail, height: e.thumbnailHeight, width: e.thumbnailWidth, alt: e.thumbnailAlt, title: e.thumbnailTitle, loading: e.thumbnailLoading, onError: t }), e.thumbnailLabel && En.default.createElement("div", { className: "image-gallery-thumbnail-label" }, e.thumbnailLabel));
  } }, { key: "render", value: function() {
    var e = this.state, t = e.currentIndex, n = e.isFullscreen, i = e.modalFullscreen, o = e.isPlaying, l = this.props, u = l.additionalClass, I = l.disableThumbnailSwipe, C = l.indexSeparator, f = l.isRTL, v = l.items, b = l.thumbnailPosition, S = l.renderFullscreenButton, R = l.renderCustomControls, W = l.renderLeftNav, x = l.renderRightNav, N = l.renderTopNav, Y = l.renderBottomNav, F = l.showBullets, T = l.showFullscreenButton, P = l.showIndex, D = l.showThumbnails, L = l.showNav, j = l.showPlayButton, J = l.slideVertically, O = l.renderPlayPauseButton, ne = this.getThumbnailStyle(), he = this.getSlideItems(), pe = he.slides, Ae = he.thumbnails, ke = he.bullets, Re = jy("image-gallery-slide-wrapper", this.getThumbnailPositionClassName(b), { "image-gallery-rtl": f }), Xe = jy("image-gallery-bullets", { "image-gallery-bullets-vertical": J }), re = En.default.createElement("div", { ref: this.imageGallerySlideWrapper, className: Re }, R && R(), this.canSlide() ? En.default.createElement(En.default.Fragment, null, L && En.default.createElement(En.default.Fragment, null, J ? N(this.slideLeft, !this.canSlideLeft()) : W(this.slideLeft, !this.canSlideLeft()), J ? Y(this.slideRight, !this.canSlideRight()) : x(this.slideRight, !this.canSlideRight())), En.default.createElement(dz, { className: "image-gallery-swipe", delta: 0, onSwiping: this.handleSwiping, onSwiped: this.handleOnSwiped }, En.default.createElement("div", { className: "image-gallery-slides" }, pe))) : En.default.createElement("div", { className: "image-gallery-slides" }, pe), j && O(this.togglePlay, o), F && En.default.createElement("div", { className: Xe }, En.default.createElement("div", { className: "image-gallery-bullets-container", role: "navigation", "aria-label": "Bullet Navigation" }, ke)), T && S(this.toggleFullScreen, n), P && En.default.createElement("div", { className: "image-gallery-index" }, En.default.createElement("span", { className: "image-gallery-index-current" }, t + 1), En.default.createElement("span", { className: "image-gallery-index-separator" }, C), En.default.createElement("span", { className: "image-gallery-index-total" }, v.length))), Se = jy("image-gallery", u, { "fullscreen-modal": i }), Be = jy("image-gallery-content", this.getThumbnailPositionClassName(b), { fullscreen: n }), le = jy("image-gallery-thumbnails-wrapper", this.getThumbnailPositionClassName(b), { "thumbnails-wrapper-rtl": !this.isThumbnailVertical() && f }, { "thumbnails-swipe-horizontal": !this.isThumbnailVertical() && !I }, { "thumbnails-swipe-vertical": this.isThumbnailVertical() && !I });
    return En.default.createElement("div", { ref: this.imageGallery, className: Se, "aria-live": "polite" }, En.default.createElement("div", { className: Be }, (b === "bottom" || b === "right") && re, D && Ae.length > 0 ? En.default.createElement(dz, { className: le, delta: 0, onSwiping: !I && this.handleThumbnailSwiping, onSwiped: !I && this.handleOnThumbnailSwiped }, En.default.createElement("div", { className: "image-gallery-thumbnails", ref: this.thumbnailsWrapper, style: this.getThumbnailBarHeight() }, En.default.createElement("nav", { ref: this.thumbnails, className: "image-gallery-thumbnails-container", style: ne, "aria-label": "Thumbnail Navigation" }, Ae))) : null, (b === "top" || b === "left") && re));
  } }]);
}();
TX.propTypes = { flickThreshold: kt.number, items: (0, kt.arrayOf)((0, kt.shape)({ bulletClass: kt.string, bulletOnClick: kt.func, description: kt.string, original: kt.string, originalHeight: kt.number, originalWidth: kt.number, loading: kt.string, thumbnailHeight: kt.number, thumbnailWidth: kt.number, thumbnailLoading: kt.string, fullscreen: kt.string, originalAlt: kt.string, originalTitle: kt.string, thumbnail: kt.string, thumbnailAlt: kt.string, thumbnailLabel: kt.string, thumbnailTitle: kt.string, originalClass: kt.string, thumbnailClass: kt.string, renderItem: kt.func, renderThumbInner: kt.func, imageSet: Toe, srcSet: kt.string, sizes: kt.string })).isRequired, showNav: kt.bool, autoPlay: kt.bool, lazyLoad: kt.bool, infinite: kt.bool, showIndex: kt.bool, showBullets: kt.bool, showThumbnails: kt.bool, showPlayButton: kt.bool, showFullscreenButton: kt.bool, disableThumbnailScroll: kt.bool, disableKeyDown: kt.bool, disableSwipe: kt.bool, disableThumbnailSwipe: kt.bool, useBrowserFullscreen: kt.bool, onErrorImageURL: kt.string, indexSeparator: kt.string, thumbnailPosition: (0, kt.oneOf)(["top", "bottom", "left", "right"]), startIndex: kt.number, slideDuration: kt.number, slideInterval: kt.number, slideOnThumbnailOver: kt.bool, swipeThreshold: kt.number, swipingTransitionDuration: kt.number, swipingThumbnailTransitionDuration: kt.number, onSlide: kt.func, onBeforeSlide: kt.func, onScreenChange: kt.func, onPause: kt.func, onPlay: kt.func, onClick: kt.func, onImageLoad: kt.func, onImageError: kt.func, onTouchMove: kt.func, onTouchEnd: kt.func, onTouchStart: kt.func, onMouseOver: kt.func, onMouseLeave: kt.func, onBulletClick: kt.func, onThumbnailError: kt.func, onThumbnailClick: kt.func, renderCustomControls: kt.func, renderLeftNav: kt.func, renderRightNav: kt.func, renderTopNav: kt.func, renderBottomNav: kt.func, renderPlayPauseButton: kt.func, renderFullscreenButton: kt.func, renderItem: kt.func, renderThumbInner: kt.func, stopPropagation: kt.bool, additionalClass: kt.string, useTranslate3D: kt.bool, isRTL: kt.bool, useWindowKeyDown: kt.bool, slideVertically: kt.bool }, TX.defaultProps = { onErrorImageURL: "", additionalClass: "", showNav: !0, autoPlay: !1, lazyLoad: !1, infinite: !0, showIndex: !1, showBullets: !1, showThumbnails: !0, showPlayButton: !0, showFullscreenButton: !0, disableThumbnailScroll: !1, disableKeyDown: !1, disableSwipe: !1, disableThumbnailSwipe: !1, useTranslate3D: !0, isRTL: !1, useBrowserFullscreen: !0, flickThreshold: 0.4, stopPropagation: !1, indexSeparator: " / ", thumbnailPosition: "bottom", startIndex: 0, slideDuration: 450, swipingTransitionDuration: 0, swipingThumbnailTransitionDuration: 0, onSlide: null, onBeforeSlide: null, onScreenChange: null, onPause: null, onPlay: null, onClick: null, onImageLoad: null, onImageError: null, onTouchMove: null, onTouchEnd: null, onTouchStart: null, onMouseOver: null, onMouseLeave: null, onBulletClick: null, onThumbnailError: null, onThumbnailClick: null, renderCustomControls: null, renderThumbInner: null, renderItem: null, slideInterval: 3e3, slideOnThumbnailOver: !1, swipeThreshold: 30, slideVertically: !1, renderLeftNav: function(r, e) {
  return En.default.createElement(Voe, { onClick: r, disabled: e });
}, renderRightNav: function(r, e) {
  return En.default.createElement(Noe, { onClick: r, disabled: e });
}, renderTopNav: function(r, e) {
  return En.default.createElement(Yoe, { onClick: r, disabled: e });
}, renderBottomNav: function(r, e) {
  return En.default.createElement(Foe, { onClick: r, disabled: e });
}, renderPlayPauseButton: function(r, e) {
  return En.default.createElement(Moe, { onClick: r, isPlaying: e });
}, renderFullscreenButton: function(r, e) {
  return En.default.createElement(Woe, { onClick: r, isFullscreen: e });
}, useWindowKeyDown: !0 };
const _oe = TX;
var zoe = Uk.A;
const Koe = (r, e = "div", t = "") => {
  const n = document.getElementById("root"), i = document.createElement(e);
  return i.id = r, i.className = t, document.body.insertBefore(i, n), i;
}, Loe = (r, e = "div", t = "") => {
  const n = document.getElementById(r);
  return n || Koe(r, e, t);
}, koe = ({ visible: r, items: e, setItems: t, onClose: n }) => {
  const [i, o] = ye.useState(r), l = Loe("modal");
  if (ye.useEffect(() => {
    r ? o(!0) : setTimeout(() => {
      o(!1), t(null);
    }, 200);
  }, [r]), !!i)
    return _X.createPortal(
      /* @__PURE__ */ We.jsxs("div", { className: `imageGalleryModal ${r ? "animate-fadein" : "animate-fadeout"}`, children: [
        /* @__PURE__ */ We.jsx("div", { className: "imageGalleryModal-bg", onClick: n }),
        /* @__PURE__ */ We.jsxs("div", { className: "gallery", children: [
          /* @__PURE__ */ We.jsx("button", { className: "close-btn", onClick: n, children: "close" }),
          /* @__PURE__ */ We.jsx(
            zoe,
            {
              items: e ?? [],
              showFullscreenButton: !1,
              showPlayButton: !1,
              slideDuration: 200,
              renderLeftNav: (u) => /* @__PURE__ */ We.jsx("button", { className: "gallery-arrow left-2", onClick: u, children: /* @__PURE__ */ We.jsx(Pae, { size: "2.5rem" }) }),
              renderRightNav: (u) => /* @__PURE__ */ We.jsx("button", { className: "gallery-arrow right-2", onClick: u, children: /* @__PURE__ */ We.jsx(Jae, { size: "2.5rem" }) })
            }
          )
        ] })
      ] }),
      l
    );
}, Doe = (r) => r != null && typeof r == "object" && "en" in r && typeof r.en == "string" && "zh" in r && typeof r.zh == "string", iD = (r) => {
  const e = document.getElementById("outlet"), t = document.getElementById(r);
  if (e && t) {
    const n = window.innerWidth <= 575 ? 57 : window.innerWidth <= 767 ? 66 : 72, o = t.getBoundingClientRect().top + e.scrollTop - n;
    e.scrollTo({ behavior: "smooth", top: o });
  }
}, Uoe = ({
  project: { id: r, title: e, description: t, picPath: n, tags: i, link: o, date: l, images: u },
  hoverState: I,
  setGalleryItems: C
}) => {
  const f = rd(), v = Wb(), { i18n: b, t: S } = Uu(), R = mp(b.language), W = u && u.length, x = () => {
    v({ ...f, hash: `#${r}` }), iD(r.toString());
  }, N = (Y) => /* @__PURE__ */ We.jsx(
    "a",
    {
      target: "_blank",
      rel: "noopener noreferrer",
      href: Y.site,
      className: "sm:self-end text-sm underline",
      onClick: (F) => F.stopPropagation(),
      children: S(`proj_${Y.type}`)
    }
  );
  return /* @__PURE__ */ We.jsxs(
    Fk,
    {
      id: r,
      turnGray: !0,
      hoverState: I,
      title: /* @__PURE__ */ We.jsxs(
        "div",
        {
          className: `relative pt-[56.25%] transition-theme overflow-hidden ${W ? "cursor-pointer" : "cursor-default"}`,
          onClick: () => {
            W && C(u);
          },
          children: [
            W && /* @__PURE__ */ We.jsx(
              tae,
              {
                className: "transition-theme mt-2 ml-auto text-defaccent dark:text-darkaccent light:text-lightaccent sm:absolute sm:bottom-2 sm:right-2 z-[2]",
                size: "18px"
              }
            ),
            /* @__PURE__ */ We.jsx(
              "img",
              {
                draggable: !1,
                className: "absolute w-full top-0 left-0 object-contain max-w-full max-h-full",
                src: n,
                alt: e[R]
              }
            )
          ]
        }
      ),
      children: [
        /* @__PURE__ */ We.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ We.jsx(
            "div",
            {
              className: "text-lg md:text-base font-medium flex flex-row items-center sm:mt-3 gap-x-2 cursor-pointer",
              onClick: x,
              children: /* @__PURE__ */ We.jsxs("p", { children: [
                e[R],
                "",
                N(o)
              ] })
            }
          ),
          /* @__PURE__ */ We.jsx("div", { className: "text-sm", children: Doe(t) ? t[R] : t })
        ] }),
        /* @__PURE__ */ We.jsxs("div", { className: "mt-1 flex flex-row justify-between items-end text-sm font-medium", children: [
          /* @__PURE__ */ We.jsx(Ek, { selectable: !0, tags: i }),
          /* @__PURE__ */ We.jsxs("div", { className: "text-nowrap text-xs", children: [
            l.month,
            " ",
            l.year
          ] })
        ] })
      ]
    }
  );
};
var lI = /* @__PURE__ */ ((r) => (r.PROJECT = "project", r.SIDE_PROJECT = "side_project", r.OTHERS = "others", r))(lI || {});
const Ooe = "keyboard", Poe = {
  id: Ooe,
  title: {
    en: "Keyboard",
    zh: "keyboard"
  },
  type: lI.OTHERS,
  tags: [Ji.webAudio],
  picPath: "/assets/keyboard.webp",
  description: {
    en: "A keyboard implemented using WebAudio for the first time. After downloading, click index.html to start the project.",
    zh: " WebAudio  Keyboard index.html "
  },
  link: {
    type: "download",
    site: "https://drive.google.com/file/d/1NgQFqJ2N6pBeSbCv-HcWH-vlAfUioUWm/view?usp=sharing"
  },
  date: {
    year: 2023,
    month: sg.JAN
  }
}, Joe = "kitchen-timer", Qoe = {
  id: Joe,
  title: {
    en: "Kitchen Timer",
    zh: "Kitchen Timer"
  },
  type: lI.SIDE_PROJECT,
  tags: [Ji.nativeJS],
  picPath: "/assets/kitchen-timer/preview2.webp",
  images: [
    {
      original: "/assets/kitchen-timer/preview1.webp",
      thumbnail: "/assets/kitchen-timer/preview1.webp"
    },
    {
      original: "/assets/kitchen-timer/preview2.webp",
      thumbnail: "/assets/kitchen-timer/preview2.webp"
    },
    {
      original: "/assets/kitchen-timer/preview3.webp",
      thumbnail: "/assets/kitchen-timer/preview3.webp"
    },
    {
      original: "/assets/kitchen-timer/preview4.webp",
      thumbnail: "/assets/kitchen-timer/preview4.webp"
    }
  ],
  description: {
    en: 'This game is inspired by a minigame from "Everybody 1-2-Switch!" by Nintendo. After downloading, click "index.html" to start the game.',
    zh: ' Nintendo  "Everybody 1-2-Switch!"  "Kitchen Timer" index.html '
  },
  link: {
    type: "download",
    site: "https://drive.google.com/file/d/19sycv9WDLah-2teR5dLgkUL4itxPn4L4/view?usp=sharing"
  },
  date: {
    year: 2024,
    month: sg.JUN
  }
}, uR = ({ target: r, state: e }) => {
  const t = rd(), [n, i] = e, o = (l) => {
    l.stopPropagation(), i((u) => !u), iD(r);
  };
  return /* @__PURE__ */ We.jsx(
    JX,
    {
      replace: !0,
      to: { ...t, hash: `#${r}` },
      onClick: o,
      className: "text-xs underline outline-none",
      children: n ? "Show less..." : "Show more..."
    }
  );
}, rD = "mog-simulation", joe = {
  en: "This project is a simulation exercise of a multiplayer online game, where players can create rooms and interact with each other through their characters, as well as perform various actions. The project technologies are as follows: ",
  zh: ""
}, qoe = [
  {
    title: { en: "Mesh Network: ", zh: "Mesh " },
    content: {
      en: "Uses a Mesh Network to establish peer-to-peer (P2P) connections between players.",
      zh: " Mesh Network (P2P) "
    }
  },
  {
    title: { en: "WebSocket: ", zh: "WebSocket" },
    content: {
      en: "Implements text chat between players and WebRTC P2P connection functionality.",
      zh: " WebRTC  P2P "
    }
  },
  {
    title: { en: "WebRTC Data Channels: ", zh: "WebRTC Data Channels" },
    content: {
      en: "Responsible for transmitting character movement data to ensure the game screen can immediately render the latest coordinates of other players.",
      zh: ""
    }
  }
], $oe = {
  en: "This project demonstrates how WebSocket and WebRTC technologies work together to achieve real-time interaction and data transmission in a multiplayer game environment.",
  zh: " WebSocket  WebRTC "
}, ese = () => {
  const { i18n: r } = Uu(), e = mp(r.language), [t, n] = ye.useState(!1);
  return /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
    /* @__PURE__ */ We.jsx("p", { className: `${t ? "mb-3" : ""}`, children: joe[e] }),
    t && /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
      /* @__PURE__ */ We.jsx("ul", { className: "list-disc ml-4", children: qoe.map((i, o) => /* @__PURE__ */ We.jsxs("li", { className: "mb-3", children: [
        /* @__PURE__ */ We.jsx("b", { children: i.title[e] }),
        i.content[e]
      ] }, o)) }),
      /* @__PURE__ */ We.jsx("p", { children: $oe[e] })
    ] }),
    /* @__PURE__ */ We.jsx(uR, { target: rD, state: [t, n] })
  ] });
}, tse = {
  id: rD,
  title: {
    en: "Multiplayer Online Game Simulation",
    zh: ""
  },
  type: lI.SIDE_PROJECT,
  tags: [Ji.next, Ji.express, Ji.tailwind, Ji.websocket, Ji.webRTC, Ji.three],
  picPath: "assets/mog-simulation/preview2.webp",
  description: wc.createElement(ese),
  images: [
    {
      original: "/assets/mog-simulation/lobby.webp",
      thumbnail: "/assets/mog-simulation/lobby.webp"
    },
    {
      original: "/assets/mog-simulation/join-room.webp",
      thumbnail: "/assets/mog-simulation/join-room.webp"
    },
    {
      original: "/assets/mog-simulation/preview1.webp",
      thumbnail: "/assets/mog-simulation/preview1.webp"
    },
    {
      original: "/assets/mog-simulation/preview2.webp",
      thumbnail: "/assets/mog-simulation/preview2.webp"
    },
    {
      original: "/assets/mog-simulation/preview3.webp",
      thumbnail: "/assets/mog-simulation/preview3.webp"
    }
  ],
  link: { type: "github", site: "https://github.com/randywu417/mogs" },
  date: {
    year: 2025,
    month: sg.JAN
  }
}, aD = "patent-application", nse = {
  en: "This system is an online platform provided by the Taiwan Intellectual Property Office (TIPO) under the Ministry of Economic Affairs, designed to facilitate patent applications for individuals and legal entities in Taiwan.",
  zh: " (TIPO) "
}, ise = {
  en: "In addition to patent applications, the system supports 50 types of patent-related requests, such as filing supplementary documents, amendments, and responses. The system also features large-file splitting and conversion tools, ensuring stable transmission of large files. Users can upload completed application documents in advance, simplifying subsequent application processes and significantly enhancing efficiency and convenience.",
  zh: " 50 "
}, rse = () => {
  const { i18n: r } = Uu(), e = mp(r.language), [t, n] = ye.useState(!1);
  return /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
    /* @__PURE__ */ We.jsx("p", { className: `${t ? "mb-3" : ""}`, children: nse[e] }),
    t && /* @__PURE__ */ We.jsx("p", { children: ise[e] }),
    /* @__PURE__ */ We.jsx(uR, { target: aD, state: [t, n] })
  ] });
}, ase = {
  id: aD,
  title: {
    en: "Patent Application System",
    zh: ""
  },
  type: lI.PROJECT,
  tags: [Ji.react, Ji.vite, Ji.jest, Ji.e2e],
  picPath: "/assets/patent-application/preview1.webp",
  description: wc.createElement(rse),
  images: [
    {
      original: "/assets/patent-application/preview1.webp",
      thumbnail: "/assets/patent-application/preview1.webp"
    },
    {
      original: "/assets/patent-application/preview2.webp",
      thumbnail: "/assets/patent-application/preview2.webp"
    },
    {
      original: "/assets/patent-application/preview3.webp",
      thumbnail: "/assets/patent-application/preview3.webp"
    },
    {
      original: "/assets/patent-application/preview4.webp",
      thumbnail: "/assets/patent-application/preview4.webp"
    },
    {
      original: "/assets/patent-application/preview5.webp",
      thumbnail: "/assets/patent-application/preview5.webp"
    }
  ],
  link: {
    type: "link",
    site: "https://tiponet.tipo.gov.tw/patent"
  },
  date: {
    year: 2024,
    month: sg.NOV
  }
}, oD = "personal-website", ose = {
  en: "My personal website is a platform for showcasing professional skills, project work, and technical insights. The website covers the following aspects:",
  zh: ""
}, sse = [
  {
    title: {
      en: "Personal Introduction: ",
      zh: ""
    },
    content: {
      en: "A brief introduction to my interests and professional background.",
      zh: ""
    }
  },
  {
    title: {
      en: "Project Portfolio: ",
      zh: ""
    },
    content: {
      en: "A detailed showcase of past projects, including technology stack, key features, and implementation details.",
      zh: ""
    }
  },
  {
    title: {
      en: "Interactive Design: ",
      zh: ""
    },
    content: {
      en: "The website features an intuitive interface and a clean, minimalist design. It also includes an interactive homepage scene created using Three.js.",
      zh: " Three.js "
    }
  }
], lse = {
  en: "This website is not only a platform to showcase my work but also a gateway to connect with the world.",
  zh: ""
}, use = () => {
  const { i18n: r } = Uu(), e = mp(r.language), [t, n] = ye.useState(!1);
  return /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
    /* @__PURE__ */ We.jsx("p", { className: `${t ? "mb-3" : ""}`, children: ose[e] }),
    t && /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
      /* @__PURE__ */ We.jsx("ul", { className: "list-disc ml-4", children: sse.map((i, o) => /* @__PURE__ */ We.jsxs("li", { className: "mb-3", children: [
        /* @__PURE__ */ We.jsx("b", { children: i.title[e] }),
        i.content[e]
      ] }, o)) }),
      /* @__PURE__ */ We.jsx("p", { children: lse[e] })
    ] }),
    /* @__PURE__ */ We.jsx(uR, { target: oD, state: [t, n] })
  ] });
}, cse = {
  id: oD,
  title: {
    en: "Personal Website",
    zh: ""
  },
  type: lI.SIDE_PROJECT,
  tags: [Ji.react, Ji.three, Ji.canvas],
  picPath: "/assets/personal-website/preview1.webp",
  description: wc.createElement(use),
  images: [
    {
      original: "/assets/personal-website/preview1.webp",
      thumbnail: "/assets/personal-website/preview1.webp"
    },
    {
      original: "/assets/personal-website/preview2.webp",
      thumbnail: "/assets/personal-website/preview2.webp"
    },
    {
      original: "/assets/personal-website/preview3.webp",
      thumbnail: "/assets/personal-website/preview3.webp"
    },
    {
      original: "/assets/personal-website/preview4.webp",
      thumbnail: "/assets/personal-website/preview4.webp"
    }
  ],
  link: { type: "link", site: "https://randywu417.github.io" },
  date: {
    year: 2024,
    month: sg.OCT
  }
}, gse = "python-tool", dse = {
  id: gse,
  title: {
    en: "Bulk Folder Rename Tool",
    zh: ""
  },
  type: lI.OTHERS,
  tags: [Ji.python],
  picPath: "/assets/python.webp",
  description: {
    en: "",
    zh: ""
  },
  link: {
    type: "github",
    site: "https://github.com/randywu417/bulk-folder-rename-tool"
  },
  date: {
    year: 2022,
    month: sg.AUG
  }
}, sD = "saboteur", Ise = {
  en: 'This project is a real-time, faction-based board game built using WebSocket connections, inspired by the board game "Saboteur" published by Swan Panasia.',
  zh: ' WebSocket    ""'
}, Cse = {
  en: "The project includes features such as card animations, a chatroom, heartbeat packets, reconnection upon disconnection, player timers, and maze-related algorithms.",
  zh: ""
}, hse = {
  en: "Due to the use of copyrighted artwork, this project is intended solely for personal practice and cannot be shared publicly. If you're interested in viewing the code, please email me at randywu417@gmail.com to request the password for final.zip and include a brief explanation of your purpose. Thank you for your understanding.",
  zh: " randywu417@gmail.com  final.zip "
}, fse = () => {
  const { i18n: r } = Uu(), e = mp(r.language), [t, n] = ye.useState(!1);
  return /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
    /* @__PURE__ */ We.jsx("p", { children: Ise[e] }),
    /* @__PURE__ */ We.jsx("p", { children: Cse[e] }),
    t && /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
      /* @__PURE__ */ We.jsx("br", {}),
      /* @__PURE__ */ We.jsx("p", { children: hse[e] })
    ] }),
    /* @__PURE__ */ We.jsx(uR, { target: sD, state: [t, n] })
  ] });
}, pse = {
  id: sD,
  title: {
    en: "Saboteur",
    zh: ""
  },
  type: lI.SIDE_PROJECT,
  tags: [Ji.react, Ji.nodeJS, Ji.express, Ji.websocket, Ji.jest],
  picPath: "/assets/saboteur/game-preview2.webp",
  description: wc.createElement(fse),
  images: [
    {
      original: "/assets/saboteur/home.webp",
      thumbnail: "/assets/saboteur/home.webp"
    },
    {
      original: "/assets/saboteur/hall-preview.webp",
      thumbnail: "/assets/saboteur/hall-preview.webp"
    },
    {
      original: "/assets/saboteur/game-loading.webp",
      thumbnail: "/assets/saboteur/game-loading.webp"
    },
    {
      original: "/assets/saboteur/game-preview1.webp",
      thumbnail: "/assets/saboteur/game-preview1.webp"
    },
    {
      original: "/assets/saboteur/game-preview2.webp",
      thumbnail: "/assets/saboteur/game-preview2.webp"
    },
    {
      original: "/assets/saboteur/game-preview3.webp",
      thumbnail: "/assets/saboteur/game-preview3.webp"
    }
  ],
  link: {
    type: "download",
    site: "https://drive.google.com/file/d/1rHa5sLhgSN-XQmHdRzQ-JYbO-NN6keLZ/view?usp=sharing"
  },
  date: {
    year: 2023,
    month: sg.DEC
  }
}, mse = "shader-materials", Ase = {
  id: mse,
  title: {
    en: "2D Shader Material",
    zh: "2D Shader Material"
  },
  type: lI.OTHERS,
  tags: [Ji.canvas, Ji.glsl],
  picPath: "/assets/shader-materials.webp",
  description: {
    en: "Shaders that have been implemented.",
    zh: " shader"
  },
  link: {
    type: "github",
    site: "https://github.com/randywu417/basic-2d-shader-material"
  },
  date: {
    year: 2022,
    month: sg.JUN
  }
}, vse = "trademark-fee-payment", yse = {
  id: vse,
  title: {
    en: "Online Fee Payment System",
    zh: ""
  },
  type: lI.PROJECT,
  tags: [Ji.react, Ji.vite, Ji.jest, Ji.i18n],
  picPath: "/assets/trademark-fee-payment.webp",
  description: {
    en: "Provides an online platform for trademark fee payments, along with features for payment records, querying payable fees, and annual fee calculations.",
    zh: ""
  },
  link: { type: "link", site: "https://tiponet.tipo.gov.tw/S080WV1/#/" },
  date: {
    year: 2023,
    month: sg.JUL
  }
}, lD = "trademark-search", bse = {
  en: "This system offers a powerful trademark search platform, supporting diverse search methods to help users quickly locate the required trademark information.",
  zh: ""
}, Gse = {
  en: "Key Features: ",
  zh: ""
}, Bse = [
  {
    title: { en: "Basic and Advanced Search: ", zh: "" },
    content: {
      en: "Provides six basic, easy-to-use search methods, along with tens of thousands of advanced search combinations to meet diverse needs.",
      zh: " 6 "
    }
  },
  {
    title: { en: "Image Editing and Search: ", zh: "" },
    content: {
      en: "Equipped with a built-in image editor that allows users to crop specific parts of an image for more precise searches.",
      zh: ""
    }
  },
  {
    title: { en: "Detailed Trademark Information: ", zh: "" },
    content: {
      en: "Displays comprehensive trademark details, enabling users to gain a deeper understanding of the related information.",
      zh: ""
    }
  }
], Sse = {
  en: "This system is designed to provide an intuitive and efficient trademark search, assisting users in quickly accessing the information they need.",
  zh: ""
}, Zse = () => {
  const { i18n: r } = Uu(), e = mp(r.language), [t, n] = ye.useState(!1);
  return /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
    /* @__PURE__ */ We.jsx("p", { className: "mb-3", children: bse[e] }),
    /* @__PURE__ */ We.jsx("p", { className: `${t ? "mb-3" : ""}`, children: Gse[e] }),
    t && /* @__PURE__ */ We.jsxs(We.Fragment, { children: [
      /* @__PURE__ */ We.jsx("ul", { className: "list-disc ml-4", children: Bse.map((i, o) => /* @__PURE__ */ We.jsxs("li", { className: "mb-3", children: [
        /* @__PURE__ */ We.jsx("b", { children: i.title[e] }),
        i.content[e]
      ] }, o)) }),
      /* @__PURE__ */ We.jsx("p", { children: Sse[e] })
    ] }),
    /* @__PURE__ */ We.jsx(uR, { target: lD, state: [t, n] })
  ] });
}, wse = {
  id: lD,
  title: {
    en: "Trademark Search System",
    zh: ""
  },
  type: lI.PROJECT,
  tags: [Ji.react, Ji.canvas, Ji.nodeJS, Ji.vite, Ji.jest, Ji.e2e],
  picPath: "/assets/trademark-search/preview1.webp",
  description: wc.createElement(Zse),
  images: [
    {
      original: "/assets/trademark-search/preview1.webp",
      thumbnail: "/assets/trademark-search/preview1.webp"
    },
    {
      original: "/assets/trademark-search/preview2.webp",
      thumbnail: "/assets/trademark-search/preview2.webp"
    },
    {
      original: "/assets/trademark-search/preview3.webp",
      thumbnail: "/assets/trademark-search/preview3.webp"
    },
    {
      original: "/assets/trademark-search/preview4.webp",
      thumbnail: "/assets/trademark-search/preview4.webp"
    },
    {
      original: "/assets/trademark-search/preview5.webp",
      thumbnail: "/assets/trademark-search/preview5.webp"
    },
    {
      original: "/assets/trademark-search/preview6.webp",
      thumbnail: "/assets/trademark-search/preview6.webp"
    },
    {
      original: "/assets/trademark-search/preview7.webp",
      thumbnail: "/assets/trademark-search/preview7.webp"
    }
  ],
  link: {
    type: "link",
    site: "https://cloud.tipo.gov.tw/S282/S282WV1/"
  },
  date: {
    year: 2024,
    month: sg.MAR
  }
}, GW = [
  { title: { en: "Other", zh: "" }, value: lI.OTHERS },
  { title: { en: "Side Project", zh: "" }, value: lI.SIDE_PROJECT },
  { title: { en: "Project", zh: "" }, value: lI.PROJECT },
  { title: { en: "All", zh: "" }, value: "" }
], pz = [
  tse,
  ase,
  cse,
  Qoe,
  wse,
  pse,
  yse,
  Poe,
  Ase,
  dse
], Rse = ({ activeTab: r, setActiveTab: e }) => {
  const { width: t } = Yb(), { i18n: n } = Uu(), i = [
    ye.useRef(null),
    ye.useRef(null),
    ye.useRef(null),
    ye.useRef(null)
  ], o = mp(n.language), l = (f) => f === r, u = GW.findIndex((f) => r === f.value), [I, C] = ye.useState({});
  return ye.useEffect(() => {
    const f = () => i[u] && i[u].current ? i[u].current.getBoundingClientRect().width + "px" : "", v = () => {
      let b = 0;
      for (let S = 0; S < u; S++) {
        const R = i[S];
        R && R.current && (b += R.current.getBoundingClientRect().width);
      }
      return b + "px";
    };
    C({
      width: f(),
      right: v()
    });
  }, [u, i[0].current, i[1].current, i[2].current, i[3].current, t, o]), /* @__PURE__ */ We.jsxs("div", { className: "project-tabs", children: [
    GW.map((f, v) => /* @__PURE__ */ We.jsx(
      "a",
      {
        ref: i[v],
        className: `tab ${l(f.value) ? "opacity-100" : "opacity-30 hover:opacity-100"}`,
        onClick: () => e(f.value),
        children: f.title[o]
      },
      v
    )),
    /* @__PURE__ */ We.jsx("span", { className: "line xs:hidden", style: I })
  ] });
}, xse = () => {
  const { t: r } = Uu(), [e, t] = Fz(), [n, i] = ye.useState(!1), [o, l] = ye.useState(null), [u, I] = ye.useState(""), [C, f] = ye.useState(
    (() => {
      const W = e.get("tab");
      return !W || !GW.find(({ value: x }) => x === W) ? "" : W;
    })()
  ), v = e.get("tab"), b = e.get("tags"), S = ye.useMemo(
    () => C === "" ? pz : pz.filter(({ type: W }) => W === C),
    [C]
  ), R = (W) => {
    W ? e.set("tab", W) : e.delete("tab"), e.delete("tags"), t(e);
  };
  return ye.useEffect(() => {
    !v || !GW.find(({ value: W }) => W === v) ? f("") : f(v);
  }, [v]), /* @__PURE__ */ We.jsxs(pV, { title: r("subtitle_projects"), children: [
    /* @__PURE__ */ We.jsx(Rse, { activeTab: C, setActiveTab: R }),
    /* @__PURE__ */ We.jsx("div", { className: "w-full flex flex-col gap-0 xs:gap-8 md:pr-4 xs:p-0", onMouseLeave: () => I(""), children: S.filter((W) => b ? W.tags.some((x) => b.includes(x.value)) : W).map((W) => /* @__PURE__ */ We.jsx(
      Uoe,
      {
        project: W,
        hoverState: [u, I],
        setGalleryItems: (x) => {
          i(!0), l(x);
        }
      },
      W.id
    )) }),
    /* @__PURE__ */ We.jsx(
      koe,
      {
        items: o,
        visible: n,
        setItems: l,
        onClose: () => i(!1)
      }
    )
  ] });
}, Wse = (r) => {
  r && r instanceof Function && import("./web-vitals-CCnqwnC8.mjs").then(({ onCLS: e, onFCP: t, onINP: n, onLCP: i, onTTFB: o }) => {
    e(r), t(r), n(r), i(r), o(r);
  });
}, Vse = yP.createRoot(document.getElementById("root")), Nse = qJ(
  [
    {
      path: lg.HOME,
      element: /* @__PURE__ */ We.jsx(kae, {}),
      errorElement: /* @__PURE__ */ We.jsx(YJ, { to: lg.HOME }),
      children: KY.map((r) => ({ path: r.url, element: /* @__PURE__ */ We.jsx(We.Fragment, {}) }))
    }
  ],
  { basename: void 0 }
);
Vse.render(
  /* @__PURE__ */ We.jsxs(wc.StrictMode, { children: [
    /* @__PURE__ */ We.jsx(aQ, { router: Nse }),
    /* @__PURE__ */ We.jsx(Nae, { maxCount: 1 })
  ] })
);
Wse(console.log);
