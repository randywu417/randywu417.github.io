function d5(a, e) {
  for (var t = 0; t < e.length; t++) {
    const n = e[t];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in a)) {
          const o = Object.getOwnPropertyDescriptor(n, i);
          o && Object.defineProperty(a, i, o.get ? o : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }));
}
(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload"))
    return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
    n(i);
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === "childList")
        for (const l of o.addedNodes)
          l.tagName === "LINK" && l.rel === "modulepreload" && n(l);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const o = {};
    return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o;
  }
  function n(i) {
    if (i.ep)
      return;
    i.ep = !0;
    const o = t(i);
    fetch(i.href, o);
  }
})();
var lZ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tw(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var hH = { exports: {} }, uZ = {}, fH = { exports: {} }, ta = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var SE;
function PU() {
  if (SE) return ta;
  SE = 1;
  var a = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), I = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), v = Symbol.iterator;
  function b(le) {
    return le === null || typeof le != "object" ? null : (le = v && le[v] || le["@@iterator"], typeof le == "function" ? le : null);
  }
  var S = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, R = Object.assign, W = {};
  function x(le, Ye, $e) {
    this.props = le, this.context = Ye, this.refs = W, this.updater = $e || S;
  }
  x.prototype.isReactComponent = {}, x.prototype.setState = function(le, Ye) {
    if (typeof le != "object" && typeof le != "function" && le != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, le, Ye, "setState");
  }, x.prototype.forceUpdate = function(le) {
    this.updater.enqueueForceUpdate(this, le, "forceUpdate");
  };
  function M() {
  }
  M.prototype = x.prototype;
  function T(le, Ye, $e) {
    this.props = le, this.context = Ye, this.refs = W, this.updater = $e || S;
  }
  var E = T.prototype = new M();
  E.constructor = T, R(E, x.prototype), E.isPureReactComponent = !0;
  var _ = Array.isArray, P = Object.prototype.hasOwnProperty, U = { current: null }, q = { key: !0, ref: !0, __self: !0, __source: !0 };
  function k(le, Ye, $e) {
    var ke, ot = {}, wt = null, St = null;
    if (Ye != null) for (ke in Ye.ref !== void 0 && (St = Ye.ref), Ye.key !== void 0 && (wt = "" + Ye.key), Ye) P.call(Ye, ke) && !q.hasOwnProperty(ke) && (ot[ke] = Ye[ke]);
    var ln = arguments.length - 2;
    if (ln === 1) ot.children = $e;
    else if (1 < ln) {
      for (var hn = Array(ln), mn = 0; mn < ln; mn++) hn[mn] = arguments[mn + 2];
      ot.children = hn;
    }
    if (le && le.defaultProps) for (ke in ln = le.defaultProps, ln) ot[ke] === void 0 && (ot[ke] = ln[ke]);
    return { $$typeof: a, type: le, key: wt, ref: St, props: ot, _owner: U.current };
  }
  function O(le, Ye) {
    return { $$typeof: a, type: le.type, key: Ye, ref: le.ref, props: le.props, _owner: le._owner };
  }
  function J(le) {
    return typeof le == "object" && le !== null && le.$$typeof === a;
  }
  function te(le) {
    var Ye = { "=": "=0", ":": "=2" };
    return "$" + le.replace(/[=:]/g, function($e) {
      return Ye[$e];
    });
  }
  var fe = /\/+/g;
  function pe(le, Ye) {
    return typeof le == "object" && le !== null && le.key != null ? te("" + le.key) : Ye.toString(36);
  }
  function Ae(le, Ye, $e, ke, ot) {
    var wt = typeof le;
    (wt === "undefined" || wt === "boolean") && (le = null);
    var St = !1;
    if (le === null) St = !0;
    else switch (wt) {
      case "string":
      case "number":
        St = !0;
        break;
      case "object":
        switch (le.$$typeof) {
          case a:
          case e:
            St = !0;
        }
    }
    if (St) return St = le, ot = ot(St), le = ke === "" ? "." + pe(St, 0) : ke, _(ot) ? ($e = "", le != null && ($e = le.replace(fe, "$&/") + "/"), Ae(ot, Ye, $e, "", function(mn) {
      return mn;
    })) : ot != null && (J(ot) && (ot = O(ot, $e + (!ot.key || St && St.key === ot.key ? "" : ("" + ot.key).replace(fe, "$&/") + "/") + le)), Ye.push(ot)), 1;
    if (St = 0, ke = ke === "" ? "." : ke + ":", _(le)) for (var ln = 0; ln < le.length; ln++) {
      wt = le[ln];
      var hn = ke + pe(wt, ln);
      St += Ae(wt, Ye, $e, hn, ot);
    }
    else if (hn = b(le), typeof hn == "function") for (le = hn.call(le), ln = 0; !(wt = le.next()).done; ) wt = wt.value, hn = ke + pe(wt, ln++), St += Ae(wt, Ye, $e, hn, ot);
    else if (wt === "object") throw Ye = String(le), Error("Objects are not valid as a React child (found: " + (Ye === "[object Object]" ? "object with keys {" + Object.keys(le).join(", ") + "}" : Ye) + "). If you meant to render a collection of children, use an array instead.");
    return St;
  }
  function Te(le, Ye, $e) {
    if (le == null) return le;
    var ke = [], ot = 0;
    return Ae(le, ke, "", "", function(wt) {
      return Ye.call($e, wt, ot++);
    }), ke;
  }
  function Ke(le) {
    if (le._status === -1) {
      var Ye = le._result;
      Ye = Ye(), Ye.then(function($e) {
        (le._status === 0 || le._status === -1) && (le._status = 1, le._result = $e);
      }, function($e) {
        (le._status === 0 || le._status === -1) && (le._status = 2, le._result = $e);
      }), le._status === -1 && (le._status = 0, le._result = Ye);
    }
    if (le._status === 1) return le._result.default;
    throw le._result;
  }
  var je = { current: null }, ee = { transition: null }, Ce = { ReactCurrentDispatcher: je, ReactCurrentBatchConfig: ee, ReactCurrentOwner: U };
  function be() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return ta.Children = { map: Te, forEach: function(le, Ye, $e) {
    Te(le, function() {
      Ye.apply(this, arguments);
    }, $e);
  }, count: function(le) {
    var Ye = 0;
    return Te(le, function() {
      Ye++;
    }), Ye;
  }, toArray: function(le) {
    return Te(le, function(Ye) {
      return Ye;
    }) || [];
  }, only: function(le) {
    if (!J(le)) throw Error("React.Children.only expected to receive a single React element child.");
    return le;
  } }, ta.Component = x, ta.Fragment = t, ta.Profiler = i, ta.PureComponent = T, ta.StrictMode = n, ta.Suspense = I, ta.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ce, ta.act = be, ta.cloneElement = function(le, Ye, $e) {
    if (le == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + le + ".");
    var ke = R({}, le.props), ot = le.key, wt = le.ref, St = le._owner;
    if (Ye != null) {
      if (Ye.ref !== void 0 && (wt = Ye.ref, St = U.current), Ye.key !== void 0 && (ot = "" + Ye.key), le.type && le.type.defaultProps) var ln = le.type.defaultProps;
      for (hn in Ye) P.call(Ye, hn) && !q.hasOwnProperty(hn) && (ke[hn] = Ye[hn] === void 0 && ln !== void 0 ? ln[hn] : Ye[hn]);
    }
    var hn = arguments.length - 2;
    if (hn === 1) ke.children = $e;
    else if (1 < hn) {
      ln = Array(hn);
      for (var mn = 0; mn < hn; mn++) ln[mn] = arguments[mn + 2];
      ke.children = ln;
    }
    return { $$typeof: a, type: le.type, key: ot, ref: wt, props: ke, _owner: St };
  }, ta.createContext = function(le) {
    return le = { $$typeof: l, _currentValue: le, _currentValue2: le, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, le.Provider = { $$typeof: o, _context: le }, le.Consumer = le;
  }, ta.createElement = k, ta.createFactory = function(le) {
    var Ye = k.bind(null, le);
    return Ye.type = le, Ye;
  }, ta.createRef = function() {
    return { current: null };
  }, ta.forwardRef = function(le) {
    return { $$typeof: u, render: le };
  }, ta.isValidElement = J, ta.lazy = function(le) {
    return { $$typeof: h, _payload: { _status: -1, _result: le }, _init: Ke };
  }, ta.memo = function(le, Ye) {
    return { $$typeof: f, type: le, compare: Ye === void 0 ? null : Ye };
  }, ta.startTransition = function(le) {
    var Ye = ee.transition;
    ee.transition = {};
    try {
      le();
    } finally {
      ee.transition = Ye;
    }
  }, ta.unstable_act = be, ta.useCallback = function(le, Ye) {
    return je.current.useCallback(le, Ye);
  }, ta.useContext = function(le) {
    return je.current.useContext(le);
  }, ta.useDebugValue = function() {
  }, ta.useDeferredValue = function(le) {
    return je.current.useDeferredValue(le);
  }, ta.useEffect = function(le, Ye) {
    return je.current.useEffect(le, Ye);
  }, ta.useId = function() {
    return je.current.useId();
  }, ta.useImperativeHandle = function(le, Ye, $e) {
    return je.current.useImperativeHandle(le, Ye, $e);
  }, ta.useInsertionEffect = function(le, Ye) {
    return je.current.useInsertionEffect(le, Ye);
  }, ta.useLayoutEffect = function(le, Ye) {
    return je.current.useLayoutEffect(le, Ye);
  }, ta.useMemo = function(le, Ye) {
    return je.current.useMemo(le, Ye);
  }, ta.useReducer = function(le, Ye, $e) {
    return je.current.useReducer(le, Ye, $e);
  }, ta.useRef = function(le) {
    return je.current.useRef(le);
  }, ta.useState = function(le) {
    return je.current.useState(le);
  }, ta.useSyncExternalStore = function(le, Ye, $e) {
    return je.current.useSyncExternalStore(le, Ye, $e);
  }, ta.useTransition = function() {
    return je.current.useTransition();
  }, ta.version = "18.3.1", ta;
}
var YZ = { exports: {} };
YZ.exports;
var ZE;
function JU() {
  return ZE || (ZE = 1, function(a, e) {
    var t = {};
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    t.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = "18.3.1", i = Symbol.for("react.element"), o = Symbol.for("react.portal"), l = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), I = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), h = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), S = Symbol.for("react.suspense_list"), R = Symbol.for("react.memo"), W = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), M = Symbol.iterator, T = "@@iterator";
      function E(ie) {
        if (ie === null || typeof ie != "object")
          return null;
        var De = M && ie[M] || ie[T];
        return typeof De == "function" ? De : null;
      }
      var _ = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, P = {
        transition: null
      }, U = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, q = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, k = {}, O = null;
      function J(ie) {
        O = ie;
      }
      k.setExtraStackFrame = function(ie) {
        O = ie;
      }, k.getCurrentStack = null, k.getStackAddendum = function() {
        var ie = "";
        O && (ie += O);
        var De = k.getCurrentStack;
        return De && (ie += De() || ""), ie;
      };
      var te = !1, fe = !1, pe = !1, Ae = !1, Te = !1, Ke = {
        ReactCurrentDispatcher: _,
        ReactCurrentBatchConfig: P,
        ReactCurrentOwner: q
      };
      Ke.ReactDebugCurrentFrame = k, Ke.ReactCurrentActQueue = U;
      function je(ie) {
        {
          for (var De = arguments.length, bt = new Array(De > 1 ? De - 1 : 0), Et = 1; Et < De; Et++)
            bt[Et - 1] = arguments[Et];
          Ce("warn", ie, bt);
        }
      }
      function ee(ie) {
        {
          for (var De = arguments.length, bt = new Array(De > 1 ? De - 1 : 0), Et = 1; Et < De; Et++)
            bt[Et - 1] = arguments[Et];
          Ce("error", ie, bt);
        }
      }
      function Ce(ie, De, bt) {
        {
          var Et = Ke.ReactDebugCurrentFrame, wn = Et.getStackAddendum();
          wn !== "" && (De += "%s", bt = bt.concat([wn]));
          var ui = bt.map(function(ni) {
            return String(ni);
          });
          ui.unshift("Warning: " + De), Function.prototype.apply.call(console[ie], console, ui);
        }
      }
      var be = {};
      function le(ie, De) {
        {
          var bt = ie.constructor, Et = bt && (bt.displayName || bt.name) || "ReactClass", wn = Et + "." + De;
          if (be[wn])
            return;
          ee("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", De, Et), be[wn] = !0;
        }
      }
      var Ye = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(ie) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(ie, De, bt) {
          le(ie, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(ie, De, bt, Et) {
          le(ie, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(ie, De, bt, Et) {
          le(ie, "setState");
        }
      }, $e = Object.assign, ke = {};
      Object.freeze(ke);
      function ot(ie, De, bt) {
        this.props = ie, this.context = De, this.refs = ke, this.updater = bt || Ye;
      }
      ot.prototype.isReactComponent = {}, ot.prototype.setState = function(ie, De) {
        if (typeof ie != "object" && typeof ie != "function" && ie != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, ie, De, "setState");
      }, ot.prototype.forceUpdate = function(ie) {
        this.updater.enqueueForceUpdate(this, ie, "forceUpdate");
      };
      {
        var wt = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, St = function(ie, De) {
          Object.defineProperty(ot.prototype, ie, {
            get: function() {
              je("%s(...) is deprecated in plain JavaScript React classes. %s", De[0], De[1]);
            }
          });
        };
        for (var ln in wt)
          wt.hasOwnProperty(ln) && St(ln, wt[ln]);
      }
      function hn() {
      }
      hn.prototype = ot.prototype;
      function mn(ie, De, bt) {
        this.props = ie, this.context = De, this.refs = ke, this.updater = bt || Ye;
      }
      var Pn = mn.prototype = new hn();
      Pn.constructor = mn, $e(Pn, ot.prototype), Pn.isPureReactComponent = !0;
      function he() {
        var ie = {
          current: null
        };
        return Object.seal(ie), ie;
      }
      var Lt = Array.isArray;
      function Wt(ie) {
        return Lt(ie);
      }
      function tn(ie) {
        {
          var De = typeof Symbol == "function" && Symbol.toStringTag, bt = De && ie[Symbol.toStringTag] || ie.constructor.name || "Object";
          return bt;
        }
      }
      function Gt(ie) {
        try {
          return Rn(ie), !1;
        } catch {
          return !0;
        }
      }
      function Rn(ie) {
        return "" + ie;
      }
      function nn(ie) {
        if (Gt(ie))
          return ee("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", tn(ie)), Rn(ie);
      }
      function Bn(ie, De, bt) {
        var Et = ie.displayName;
        if (Et)
          return Et;
        var wn = De.displayName || De.name || "";
        return wn !== "" ? bt + "(" + wn + ")" : bt;
      }
      function Se(ie) {
        return ie.displayName || "Context";
      }
      function oe(ie) {
        if (ie == null)
          return null;
        if (typeof ie.tag == "number" && ee("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ie == "function")
          return ie.displayName || ie.name || null;
        if (typeof ie == "string")
          return ie;
        switch (ie) {
          case l:
            return "Fragment";
          case o:
            return "Portal";
          case I:
            return "Profiler";
          case u:
            return "StrictMode";
          case b:
            return "Suspense";
          case S:
            return "SuspenseList";
        }
        if (typeof ie == "object")
          switch (ie.$$typeof) {
            case h:
              var De = ie;
              return Se(De) + ".Consumer";
            case f:
              var bt = ie;
              return Se(bt._context) + ".Provider";
            case v:
              return Bn(ie, ie.render, "ForwardRef");
            case R:
              var Et = ie.displayName || null;
              return Et !== null ? Et : oe(ie.type) || "Memo";
            case W: {
              var wn = ie, ui = wn._payload, ni = wn._init;
              try {
                return oe(ni(ui));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var ct = Object.prototype.hasOwnProperty, Ft = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, pt, zt, Sn;
      Sn = {};
      function rn(ie) {
        if (ct.call(ie, "ref")) {
          var De = Object.getOwnPropertyDescriptor(ie, "ref").get;
          if (De && De.isReactWarning)
            return !1;
        }
        return ie.ref !== void 0;
      }
      function gn(ie) {
        if (ct.call(ie, "key")) {
          var De = Object.getOwnPropertyDescriptor(ie, "key").get;
          if (De && De.isReactWarning)
            return !1;
        }
        return ie.key !== void 0;
      }
      function qn(ie, De) {
        var bt = function() {
          pt || (pt = !0, ee("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", De));
        };
        bt.isReactWarning = !0, Object.defineProperty(ie, "key", {
          get: bt,
          configurable: !0
        });
      }
      function qt(ie, De) {
        var bt = function() {
          zt || (zt = !0, ee("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", De));
        };
        bt.isReactWarning = !0, Object.defineProperty(ie, "ref", {
          get: bt,
          configurable: !0
        });
      }
      function An(ie) {
        if (typeof ie.ref == "string" && q.current && ie.__self && q.current.stateNode !== ie.__self) {
          var De = oe(q.current.type);
          Sn[De] || (ee('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', De, ie.ref), Sn[De] = !0);
        }
      }
      var Fe = function(ie, De, bt, Et, wn, ui, ni) {
        var Yi = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: i,
          // Built-in properties that belong on the element
          type: ie,
          key: De,
          ref: bt,
          props: ni,
          // Record the component responsible for creating this element.
          _owner: ui
        };
        return Yi._store = {}, Object.defineProperty(Yi._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Yi, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Et
        }), Object.defineProperty(Yi, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: wn
        }), Object.freeze && (Object.freeze(Yi.props), Object.freeze(Yi)), Yi;
      };
      function Ie(ie, De, bt) {
        var Et, wn = {}, ui = null, ni = null, Yi = null, rr = null;
        if (De != null) {
          rn(De) && (ni = De.ref, An(De)), gn(De) && (nn(De.key), ui = "" + De.key), Yi = De.__self === void 0 ? null : De.__self, rr = De.__source === void 0 ? null : De.__source;
          for (Et in De)
            ct.call(De, Et) && !Ft.hasOwnProperty(Et) && (wn[Et] = De[Et]);
        }
        var Yr = arguments.length - 2;
        if (Yr === 1)
          wn.children = bt;
        else if (Yr > 1) {
          for (var hr = Array(Yr), vr = 0; vr < Yr; vr++)
            hr[vr] = arguments[vr + 2];
          Object.freeze && Object.freeze(hr), wn.children = hr;
        }
        if (ie && ie.defaultProps) {
          var br = ie.defaultProps;
          for (Et in br)
            wn[Et] === void 0 && (wn[Et] = br[Et]);
        }
        if (ui || ni) {
          var Ia = typeof ie == "function" ? ie.displayName || ie.name || "Unknown" : ie;
          ui && qn(wn, Ia), ni && qt(wn, Ia);
        }
        return Fe(ie, ui, ni, Yi, rr, q.current, wn);
      }
      function at(ie, De) {
        var bt = Fe(ie.type, De, ie.ref, ie._self, ie._source, ie._owner, ie.props);
        return bt;
      }
      function ye(ie, De, bt) {
        if (ie == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + ie + ".");
        var Et, wn = $e({}, ie.props), ui = ie.key, ni = ie.ref, Yi = ie._self, rr = ie._source, Yr = ie._owner;
        if (De != null) {
          rn(De) && (ni = De.ref, Yr = q.current), gn(De) && (nn(De.key), ui = "" + De.key);
          var hr;
          ie.type && ie.type.defaultProps && (hr = ie.type.defaultProps);
          for (Et in De)
            ct.call(De, Et) && !Ft.hasOwnProperty(Et) && (De[Et] === void 0 && hr !== void 0 ? wn[Et] = hr[Et] : wn[Et] = De[Et]);
        }
        var vr = arguments.length - 2;
        if (vr === 1)
          wn.children = bt;
        else if (vr > 1) {
          for (var br = Array(vr), Ia = 0; Ia < vr; Ia++)
            br[Ia] = arguments[Ia + 2];
          wn.children = br;
        }
        return Fe(ie.type, ui, ni, Yi, rr, Yr, wn);
      }
      function Pe(ie) {
        return typeof ie == "object" && ie !== null && ie.$$typeof === i;
      }
      var Ot = ".", Re = ":";
      function lt(ie) {
        var De = /[=:]/g, bt = {
          "=": "=0",
          ":": "=2"
        }, Et = ie.replace(De, function(wn) {
          return bt[wn];
        });
        return "$" + Et;
      }
      var _e = !1, ht = /\/+/g;
      function Ht(ie) {
        return ie.replace(ht, "$&/");
      }
      function an(ie, De) {
        return typeof ie == "object" && ie !== null && ie.key != null ? (nn(ie.key), lt("" + ie.key)) : De.toString(36);
      }
      function fi(ie, De, bt, Et, wn) {
        var ui = typeof ie;
        (ui === "undefined" || ui === "boolean") && (ie = null);
        var ni = !1;
        if (ie === null)
          ni = !0;
        else
          switch (ui) {
            case "string":
            case "number":
              ni = !0;
              break;
            case "object":
              switch (ie.$$typeof) {
                case i:
                case o:
                  ni = !0;
              }
          }
        if (ni) {
          var Yi = ie, rr = wn(Yi), Yr = Et === "" ? Ot + an(Yi, 0) : Et;
          if (Wt(rr)) {
            var hr = "";
            Yr != null && (hr = Ht(Yr) + "/"), fi(rr, De, hr, "", function(DC) {
              return DC;
            });
          } else rr != null && (Pe(rr) && (rr.key && (!Yi || Yi.key !== rr.key) && nn(rr.key), rr = at(
            rr,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            bt + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (rr.key && (!Yi || Yi.key !== rr.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              Ht("" + rr.key) + "/"
            ) : "") + Yr
          )), De.push(rr));
          return 1;
        }
        var vr, br, Ia = 0, Fr = Et === "" ? Ot : Et + Re;
        if (Wt(ie))
          for (var Qo = 0; Qo < ie.length; Qo++)
            vr = ie[Qo], br = Fr + an(vr, Qo), Ia += fi(vr, De, bt, br, wn);
        else {
          var Tl = E(ie);
          if (typeof Tl == "function") {
            var qg = ie;
            Tl === qg.entries && (_e || je("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), _e = !0);
            for (var DI = Tl.call(qg), Iu, UI = 0; !(Iu = DI.next()).done; )
              vr = Iu.value, br = Fr + an(vr, UI++), Ia += fi(vr, De, bt, br, wn);
          } else if (ui === "object") {
            var OI = String(ie);
            throw new Error("Objects are not valid as a React child (found: " + (OI === "[object Object]" ? "object with keys {" + Object.keys(ie).join(", ") + "}" : OI) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Ia;
      }
      function xi(ie, De, bt) {
        if (ie == null)
          return ie;
        var Et = [], wn = 0;
        return fi(ie, Et, "", "", function(ui) {
          return De.call(bt, ui, wn++);
        }), Et;
      }
      function Ir(ie) {
        var De = 0;
        return xi(ie, function() {
          De++;
        }), De;
      }
      function Xi(ie, De, bt) {
        xi(ie, function() {
          De.apply(this, arguments);
        }, bt);
      }
      function pi(ie) {
        return xi(ie, function(De) {
          return De;
        }) || [];
      }
      function Cr(ie) {
        if (!Pe(ie))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return ie;
      }
      function Sa(ie) {
        var De = {
          $$typeof: h,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: ie,
          _currentValue2: ie,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        De.Provider = {
          $$typeof: f,
          _context: De
        };
        var bt = !1, Et = !1, wn = !1;
        {
          var ui = {
            $$typeof: h,
            _context: De
          };
          Object.defineProperties(ui, {
            Provider: {
              get: function() {
                return Et || (Et = !0, ee("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), De.Provider;
              },
              set: function(ni) {
                De.Provider = ni;
              }
            },
            _currentValue: {
              get: function() {
                return De._currentValue;
              },
              set: function(ni) {
                De._currentValue = ni;
              }
            },
            _currentValue2: {
              get: function() {
                return De._currentValue2;
              },
              set: function(ni) {
                De._currentValue2 = ni;
              }
            },
            _threadCount: {
              get: function() {
                return De._threadCount;
              },
              set: function(ni) {
                De._threadCount = ni;
              }
            },
            Consumer: {
              get: function() {
                return bt || (bt = !0, ee("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), De.Consumer;
              }
            },
            displayName: {
              get: function() {
                return De.displayName;
              },
              set: function(ni) {
                wn || (je("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", ni), wn = !0);
              }
            }
          }), De.Consumer = ui;
        }
        return De._currentRenderer = null, De._currentRenderer2 = null, De;
      }
      var zr = -1, na = 0, la = 1, Oa = 2;
      function Le(ie) {
        if (ie._status === zr) {
          var De = ie._result, bt = De();
          if (bt.then(function(ui) {
            if (ie._status === na || ie._status === zr) {
              var ni = ie;
              ni._status = la, ni._result = ui;
            }
          }, function(ui) {
            if (ie._status === na || ie._status === zr) {
              var ni = ie;
              ni._status = Oa, ni._result = ui;
            }
          }), ie._status === zr) {
            var Et = ie;
            Et._status = na, Et._result = bt;
          }
        }
        if (ie._status === la) {
          var wn = ie._result;
          return wn === void 0 && ee(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, wn), "default" in wn || ee(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, wn), wn.default;
        } else
          throw ie._result;
      }
      function qe(ie) {
        var De = {
          // We use these fields to store the result.
          _status: zr,
          _result: ie
        }, bt = {
          $$typeof: W,
          _payload: De,
          _init: Le
        };
        {
          var Et, wn;
          Object.defineProperties(bt, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Et;
              },
              set: function(ui) {
                ee("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Et = ui, Object.defineProperty(bt, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return wn;
              },
              set: function(ui) {
                ee("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), wn = ui, Object.defineProperty(bt, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return bt;
      }
      function gt(ie) {
        ie != null && ie.$$typeof === R ? ee("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof ie != "function" ? ee("forwardRef requires a render function but was given %s.", ie === null ? "null" : typeof ie) : ie.length !== 0 && ie.length !== 2 && ee("forwardRef render functions accept exactly two parameters: props and ref. %s", ie.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), ie != null && (ie.defaultProps != null || ie.propTypes != null) && ee("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var De = {
          $$typeof: v,
          render: ie
        };
        {
          var bt;
          Object.defineProperty(De, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return bt;
            },
            set: function(Et) {
              bt = Et, !ie.name && !ie.displayName && (ie.displayName = Et);
            }
          });
        }
        return De;
      }
      var Pt;
      Pt = Symbol.for("react.module.reference");
      function me(ie) {
        return !!(typeof ie == "string" || typeof ie == "function" || ie === l || ie === I || Te || ie === u || ie === b || ie === S || Ae || ie === x || te || fe || pe || typeof ie == "object" && ie !== null && (ie.$$typeof === W || ie.$$typeof === R || ie.$$typeof === f || ie.$$typeof === h || ie.$$typeof === v || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        ie.$$typeof === Pt || ie.getModuleId !== void 0));
      }
      function ut(ie, De) {
        me(ie) || ee("memo: The first argument must be a component. Instead received: %s", ie === null ? "null" : typeof ie);
        var bt = {
          $$typeof: R,
          type: ie,
          compare: De === void 0 ? null : De
        };
        {
          var Et;
          Object.defineProperty(bt, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Et;
            },
            set: function(wn) {
              Et = wn, !ie.name && !ie.displayName && (ie.displayName = wn);
            }
          });
        }
        return bt;
      }
      function Bt() {
        var ie = _.current;
        return ie === null && ee(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), ie;
      }
      function Tt(ie) {
        var De = Bt();
        if (ie._context !== void 0) {
          var bt = ie._context;
          bt.Consumer === ie ? ee("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : bt.Provider === ie && ee("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return De.useContext(ie);
      }
      function ae(ie) {
        var De = Bt();
        return De.useState(ie);
      }
      function we(ie, De, bt) {
        var Et = Bt();
        return Et.useReducer(ie, De, bt);
      }
      function Ee(ie) {
        var De = Bt();
        return De.useRef(ie);
      }
      function Ue(ie, De) {
        var bt = Bt();
        return bt.useEffect(ie, De);
      }
      function Oe(ie, De) {
        var bt = Bt();
        return bt.useInsertionEffect(ie, De);
      }
      function Nt(ie, De) {
        var bt = Bt();
        return bt.useLayoutEffect(ie, De);
      }
      function Kt(ie, De) {
        var bt = Bt();
        return bt.useCallback(ie, De);
      }
      function vn(ie, De) {
        var bt = Bt();
        return bt.useMemo(ie, De);
      }
      function Yt(ie, De, bt) {
        var Et = Bt();
        return Et.useImperativeHandle(ie, De, bt);
      }
      function Yn(ie, De) {
        {
          var bt = Bt();
          return bt.useDebugValue(ie, De);
        }
      }
      function Fn() {
        var ie = Bt();
        return ie.useTransition();
      }
      function _n(ie) {
        var De = Bt();
        return De.useDeferredValue(ie);
      }
      function Xn() {
        var ie = Bt();
        return ie.useId();
      }
      function or(ie, De, bt) {
        var Et = Bt();
        return Et.useSyncExternalStore(ie, De, bt);
      }
      var Ei = 0, pr, Ln, ge, ue, We, et, Mt;
      function bn() {
      }
      bn.__reactDisabledLog = !0;
      function Ai() {
        {
          if (Ei === 0) {
            pr = console.log, Ln = console.info, ge = console.warn, ue = console.error, We = console.group, et = console.groupCollapsed, Mt = console.groupEnd;
            var ie = {
              configurable: !0,
              enumerable: !0,
              value: bn,
              writable: !0
            };
            Object.defineProperties(console, {
              info: ie,
              log: ie,
              warn: ie,
              error: ie,
              group: ie,
              groupCollapsed: ie,
              groupEnd: ie
            });
          }
          Ei++;
        }
      }
      function ve() {
        {
          if (Ei--, Ei === 0) {
            var ie = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: $e({}, ie, {
                value: pr
              }),
              info: $e({}, ie, {
                value: Ln
              }),
              warn: $e({}, ie, {
                value: ge
              }),
              error: $e({}, ie, {
                value: ue
              }),
              group: $e({}, ie, {
                value: We
              }),
              groupCollapsed: $e({}, ie, {
                value: et
              }),
              groupEnd: $e({}, ie, {
                value: Mt
              })
            });
          }
          Ei < 0 && ee("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Be = Ke.ReactCurrentDispatcher, mt;
      function $t(ie, De, bt) {
        {
          if (mt === void 0)
            try {
              throw Error();
            } catch (wn) {
              var Et = wn.stack.trim().match(/\n( *(at )?)/);
              mt = Et && Et[1] || "";
            }
          return `
` + mt + ie;
        }
      }
      var In = !1, un;
      {
        var Bi = typeof WeakMap == "function" ? WeakMap : Map;
        un = new Bi();
      }
      function Si(ie, De) {
        if (!ie || In)
          return "";
        {
          var bt = un.get(ie);
          if (bt !== void 0)
            return bt;
        }
        var Et;
        In = !0;
        var wn = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var ui;
        ui = Be.current, Be.current = null, Ai();
        try {
          if (De) {
            var ni = function() {
              throw Error();
            };
            if (Object.defineProperty(ni.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(ni, []);
              } catch (Fr) {
                Et = Fr;
              }
              Reflect.construct(ie, [], ni);
            } else {
              try {
                ni.call();
              } catch (Fr) {
                Et = Fr;
              }
              ie.call(ni.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Fr) {
              Et = Fr;
            }
            ie();
          }
        } catch (Fr) {
          if (Fr && Et && typeof Fr.stack == "string") {
            for (var Yi = Fr.stack.split(`
`), rr = Et.stack.split(`
`), Yr = Yi.length - 1, hr = rr.length - 1; Yr >= 1 && hr >= 0 && Yi[Yr] !== rr[hr]; )
              hr--;
            for (; Yr >= 1 && hr >= 0; Yr--, hr--)
              if (Yi[Yr] !== rr[hr]) {
                if (Yr !== 1 || hr !== 1)
                  do
                    if (Yr--, hr--, hr < 0 || Yi[Yr] !== rr[hr]) {
                      var vr = `
` + Yi[Yr].replace(" at new ", " at ");
                      return ie.displayName && vr.includes("<anonymous>") && (vr = vr.replace("<anonymous>", ie.displayName)), typeof ie == "function" && un.set(ie, vr), vr;
                    }
                  while (Yr >= 1 && hr >= 0);
                break;
              }
          }
        } finally {
          In = !1, Be.current = ui, ve(), Error.prepareStackTrace = wn;
        }
        var br = ie ? ie.displayName || ie.name : "", Ia = br ? $t(br) : "";
        return typeof ie == "function" && un.set(ie, Ia), Ia;
      }
      function Ji(ie, De, bt) {
        return Si(ie, !1);
      }
      function En(ie) {
        var De = ie.prototype;
        return !!(De && De.isReactComponent);
      }
      function cn(ie, De, bt) {
        if (ie == null)
          return "";
        if (typeof ie == "function")
          return Si(ie, En(ie));
        if (typeof ie == "string")
          return $t(ie);
        switch (ie) {
          case b:
            return $t("Suspense");
          case S:
            return $t("SuspenseList");
        }
        if (typeof ie == "object")
          switch (ie.$$typeof) {
            case v:
              return Ji(ie.render);
            case R:
              return cn(ie.type, De, bt);
            case W: {
              var Et = ie, wn = Et._payload, ui = Et._init;
              try {
                return cn(ui(wn), De, bt);
              } catch {
              }
            }
          }
        return "";
      }
      var kn = {}, ti = Ke.ReactDebugCurrentFrame;
      function Di(ie) {
        if (ie) {
          var De = ie._owner, bt = cn(ie.type, ie._source, De ? De.type : null);
          ti.setExtraStackFrame(bt);
        } else
          ti.setExtraStackFrame(null);
      }
      function qi(ie, De, bt, Et, wn) {
        {
          var ui = Function.call.bind(ct);
          for (var ni in ie)
            if (ui(ie, ni)) {
              var Yi = void 0;
              try {
                if (typeof ie[ni] != "function") {
                  var rr = Error((Et || "React class") + ": " + bt + " type `" + ni + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ie[ni] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw rr.name = "Invariant Violation", rr;
                }
                Yi = ie[ni](De, ni, Et, bt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Yr) {
                Yi = Yr;
              }
              Yi && !(Yi instanceof Error) && (Di(wn), ee("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Et || "React class", bt, ni, typeof Yi), Di(null)), Yi instanceof Error && !(Yi.message in kn) && (kn[Yi.message] = !0, Di(wn), ee("Failed %s type: %s", bt, Yi.message), Di(null));
            }
        }
      }
      function ci(ie) {
        if (ie) {
          var De = ie._owner, bt = cn(ie.type, ie._source, De ? De.type : null);
          J(bt);
        } else
          J(null);
      }
      var Hr;
      Hr = !1;
      function Za() {
        if (q.current) {
          var ie = oe(q.current.type);
          if (ie)
            return `

Check the render method of \`` + ie + "`.";
        }
        return "";
      }
      function gi(ie) {
        if (ie !== void 0) {
          var De = ie.fileName.replace(/^.*[\\\/]/, ""), bt = ie.lineNumber;
          return `

Check your code at ` + De + ":" + bt + ".";
        }
        return "";
      }
      function yr(ie) {
        return ie != null ? gi(ie.__source) : "";
      }
      var Hn = {};
      function Pa(ie) {
        var De = Za();
        if (!De) {
          var bt = typeof ie == "string" ? ie : ie.displayName || ie.name;
          bt && (De = `

Check the top-level render call using <` + bt + ">.");
        }
        return De;
      }
      function zo(ie, De) {
        if (!(!ie._store || ie._store.validated || ie.key != null)) {
          ie._store.validated = !0;
          var bt = Pa(De);
          if (!Hn[bt]) {
            Hn[bt] = !0;
            var Et = "";
            ie && ie._owner && ie._owner !== q.current && (Et = " It was passed a child from " + oe(ie._owner.type) + "."), ci(ie), ee('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', bt, Et), ci(null);
          }
        }
      }
      function Ko(ie, De) {
        if (typeof ie == "object") {
          if (Wt(ie))
            for (var bt = 0; bt < ie.length; bt++) {
              var Et = ie[bt];
              Pe(Et) && zo(Et, De);
            }
          else if (Pe(ie))
            ie._store && (ie._store.validated = !0);
          else if (ie) {
            var wn = E(ie);
            if (typeof wn == "function" && wn !== ie.entries)
              for (var ui = wn.call(ie), ni; !(ni = ui.next()).done; )
                Pe(ni.value) && zo(ni.value, De);
          }
        }
      }
      function Xr(ie) {
        {
          var De = ie.type;
          if (De == null || typeof De == "string")
            return;
          var bt;
          if (typeof De == "function")
            bt = De.propTypes;
          else if (typeof De == "object" && (De.$$typeof === v || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          De.$$typeof === R))
            bt = De.propTypes;
          else
            return;
          if (bt) {
            var Et = oe(De);
            qi(bt, ie.props, "prop", Et, ie);
          } else if (De.PropTypes !== void 0 && !Hr) {
            Hr = !0;
            var wn = oe(De);
            ee("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", wn || "Unknown");
          }
          typeof De.getDefaultProps == "function" && !De.getDefaultProps.isReactClassApproved && ee("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function ia(ie) {
        {
          for (var De = Object.keys(ie.props), bt = 0; bt < De.length; bt++) {
            var Et = De[bt];
            if (Et !== "children" && Et !== "key") {
              ci(ie), ee("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Et), ci(null);
              break;
            }
          }
          ie.ref !== null && (ci(ie), ee("Invalid attribute `ref` supplied to `React.Fragment`."), ci(null));
        }
      }
      function kr(ie, De, bt) {
        var Et = me(ie);
        if (!Et) {
          var wn = "";
          (ie === void 0 || typeof ie == "object" && ie !== null && Object.keys(ie).length === 0) && (wn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ui = yr(De);
          ui ? wn += ui : wn += Za();
          var ni;
          ie === null ? ni = "null" : Wt(ie) ? ni = "array" : ie !== void 0 && ie.$$typeof === i ? (ni = "<" + (oe(ie.type) || "Unknown") + " />", wn = " Did you accidentally export a JSX literal instead of a component?") : ni = typeof ie, ee("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ni, wn);
        }
        var Yi = Ie.apply(this, arguments);
        if (Yi == null)
          return Yi;
        if (Et)
          for (var rr = 2; rr < arguments.length; rr++)
            Ko(arguments[rr], ie);
        return ie === l ? ia(Yi) : Xr(Yi), Yi;
      }
      var ua = !1;
      function Lo(ie) {
        var De = kr.bind(null, ie);
        return De.type = ie, ua || (ua = !0, je("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(De, "type", {
          enumerable: !1,
          get: function() {
            return je("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: ie
            }), ie;
          }
        }), De;
      }
      function ko(ie, De, bt) {
        for (var Et = ye.apply(this, arguments), wn = 2; wn < arguments.length; wn++)
          Ko(arguments[wn], Et.type);
        return Xr(Et), Et;
      }
      function cu(ie, De) {
        var bt = P.transition;
        P.transition = {};
        var Et = P.transition;
        P.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          ie();
        } finally {
          if (P.transition = bt, bt === null && Et._updatedFibers) {
            var wn = Et._updatedFibers.size;
            wn > 10 && je("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Et._updatedFibers.clear();
          }
        }
      }
      var Ja = !1, is = null;
      function Qg(ie) {
        if (is === null)
          try {
            var De = ("require" + Math.random()).slice(0, 7), bt = a && a[De];
            is = bt.call(a, "timers").setImmediate;
          } catch {
            is = function(wn) {
              Ja === !1 && (Ja = !0, typeof MessageChannel > "u" && ee("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var ui = new MessageChannel();
              ui.port1.onmessage = wn, ui.port2.postMessage(void 0);
            };
          }
        return is(ie);
      }
      var gu = 0, rs = !1;
      function rl(ie) {
        {
          var De = gu;
          gu++, U.current === null && (U.current = []);
          var bt = U.isBatchingLegacy, Et;
          try {
            if (U.isBatchingLegacy = !0, Et = ie(), !bt && U.didScheduleLegacyUpdate) {
              var wn = U.current;
              wn !== null && (U.didScheduleLegacyUpdate = !1, Bc(wn));
            }
          } catch (br) {
            throw du(De), br;
          } finally {
            U.isBatchingLegacy = bt;
          }
          if (Et !== null && typeof Et == "object" && typeof Et.then == "function") {
            var ui = Et, ni = !1, Yi = {
              then: function(br, Ia) {
                ni = !0, ui.then(function(Fr) {
                  du(De), gu === 0 ? jg(Fr, br, Ia) : br(Fr);
                }, function(Fr) {
                  du(De), Ia(Fr);
                });
              }
            };
            return !rs && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              ni || (rs = !0, ee("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), Yi;
          } else {
            var rr = Et;
            if (du(De), gu === 0) {
              var Yr = U.current;
              Yr !== null && (Bc(Yr), U.current = null);
              var hr = {
                then: function(br, Ia) {
                  U.current === null ? (U.current = [], jg(rr, br, Ia)) : br(rr);
                }
              };
              return hr;
            } else {
              var vr = {
                then: function(br, Ia) {
                  br(rr);
                }
              };
              return vr;
            }
          }
        }
      }
      function du(ie) {
        ie !== gu - 1 && ee("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), gu = ie;
      }
      function jg(ie, De, bt) {
        {
          var Et = U.current;
          if (Et !== null)
            try {
              Bc(Et), Qg(function() {
                Et.length === 0 ? (U.current = null, De(ie)) : jg(ie, De, bt);
              });
            } catch (wn) {
              bt(wn);
            }
          else
            De(ie);
        }
      }
      var ku = !1;
      function Bc(ie) {
        if (!ku) {
          ku = !0;
          var De = 0;
          try {
            for (; De < ie.length; De++) {
              var bt = ie[De];
              do
                bt = bt(!0);
              while (bt !== null);
            }
            ie.length = 0;
          } catch (Et) {
            throw ie = ie.slice(De + 1), Et;
          } finally {
            ku = !1;
          }
        }
      }
      var al = kr, kC = ko, Bl = Lo, kI = {
        map: xi,
        forEach: Xi,
        count: Ir,
        toArray: pi,
        only: Cr
      };
      e.Children = kI, e.Component = ot, e.Fragment = l, e.Profiler = I, e.PureComponent = mn, e.StrictMode = u, e.Suspense = b, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ke, e.act = rl, e.cloneElement = kC, e.createContext = Sa, e.createElement = al, e.createFactory = Bl, e.createRef = he, e.forwardRef = gt, e.isValidElement = Pe, e.lazy = qe, e.memo = ut, e.startTransition = cu, e.unstable_act = rl, e.useCallback = Kt, e.useContext = Tt, e.useDebugValue = Yn, e.useDeferredValue = _n, e.useEffect = Ue, e.useId = Xn, e.useImperativeHandle = Yt, e.useInsertionEffect = Oe, e.useLayoutEffect = Nt, e.useMemo = vn, e.useReducer = we, e.useRef = Ee, e.useState = ae, e.useSyncExternalStore = or, e.useTransition = Fn, e.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(YZ, YZ.exports)), YZ.exports;
}
var QU = {};
QU.NODE_ENV === "production" ? fH.exports = PU() : fH.exports = JU();
var xe = fH.exports;
const ag = /* @__PURE__ */ Tw(xe), jU = /* @__PURE__ */ d5({
  __proto__: null,
  default: ag
}, [xe]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wE;
function qU() {
  if (wE) return uZ;
  wE = 1;
  var a = xe, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(u, I, f) {
    var h, v = {}, b = null, S = null;
    f !== void 0 && (b = "" + f), I.key !== void 0 && (b = "" + I.key), I.ref !== void 0 && (S = I.ref);
    for (h in I) n.call(I, h) && !o.hasOwnProperty(h) && (v[h] = I[h]);
    if (u && u.defaultProps) for (h in I = u.defaultProps, I) v[h] === void 0 && (v[h] = I[h]);
    return { $$typeof: e, type: u, key: b, ref: S, props: v, _owner: i.current };
  }
  return uZ.Fragment = t, uZ.jsx = l, uZ.jsxs = l, uZ;
}
var cZ = {}, RE;
function $U() {
  if (RE) return cZ;
  RE = 1;
  var a = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return a.NODE_ENV !== "production" && function() {
    var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), I = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), v = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), R = Symbol.for("react.offscreen"), W = Symbol.iterator, x = "@@iterator";
    function M(me) {
      if (me === null || typeof me != "object")
        return null;
      var ut = W && me[W] || me[x];
      return typeof ut == "function" ? ut : null;
    }
    var T = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function E(me) {
      {
        for (var ut = arguments.length, Bt = new Array(ut > 1 ? ut - 1 : 0), Tt = 1; Tt < ut; Tt++)
          Bt[Tt - 1] = arguments[Tt];
        _("error", me, Bt);
      }
    }
    function _(me, ut, Bt) {
      {
        var Tt = T.ReactDebugCurrentFrame, ae = Tt.getStackAddendum();
        ae !== "" && (ut += "%s", Bt = Bt.concat([ae]));
        var we = Bt.map(function(Ee) {
          return String(Ee);
        });
        we.unshift("Warning: " + ut), Function.prototype.apply.call(console[me], console, we);
      }
    }
    var P = !1, U = !1, q = !1, k = !1, O = !1, J;
    J = Symbol.for("react.module.reference");
    function te(me) {
      return !!(typeof me == "string" || typeof me == "function" || me === i || me === l || O || me === o || me === h || me === v || k || me === R || P || U || q || typeof me == "object" && me !== null && (me.$$typeof === S || me.$$typeof === b || me.$$typeof === u || me.$$typeof === I || me.$$typeof === f || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      me.$$typeof === J || me.getModuleId !== void 0));
    }
    function fe(me, ut, Bt) {
      var Tt = me.displayName;
      if (Tt)
        return Tt;
      var ae = ut.displayName || ut.name || "";
      return ae !== "" ? Bt + "(" + ae + ")" : Bt;
    }
    function pe(me) {
      return me.displayName || "Context";
    }
    function Ae(me) {
      if (me == null)
        return null;
      if (typeof me.tag == "number" && E("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof me == "function")
        return me.displayName || me.name || null;
      if (typeof me == "string")
        return me;
      switch (me) {
        case i:
          return "Fragment";
        case n:
          return "Portal";
        case l:
          return "Profiler";
        case o:
          return "StrictMode";
        case h:
          return "Suspense";
        case v:
          return "SuspenseList";
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case I:
            var ut = me;
            return pe(ut) + ".Consumer";
          case u:
            var Bt = me;
            return pe(Bt._context) + ".Provider";
          case f:
            return fe(me, me.render, "ForwardRef");
          case b:
            var Tt = me.displayName || null;
            return Tt !== null ? Tt : Ae(me.type) || "Memo";
          case S: {
            var ae = me, we = ae._payload, Ee = ae._init;
            try {
              return Ae(Ee(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Te = Object.assign, Ke = 0, je, ee, Ce, be, le, Ye, $e;
    function ke() {
    }
    ke.__reactDisabledLog = !0;
    function ot() {
      {
        if (Ke === 0) {
          je = console.log, ee = console.info, Ce = console.warn, be = console.error, le = console.group, Ye = console.groupCollapsed, $e = console.groupEnd;
          var me = {
            configurable: !0,
            enumerable: !0,
            value: ke,
            writable: !0
          };
          Object.defineProperties(console, {
            info: me,
            log: me,
            warn: me,
            error: me,
            group: me,
            groupCollapsed: me,
            groupEnd: me
          });
        }
        Ke++;
      }
    }
    function wt() {
      {
        if (Ke--, Ke === 0) {
          var me = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Te({}, me, {
              value: je
            }),
            info: Te({}, me, {
              value: ee
            }),
            warn: Te({}, me, {
              value: Ce
            }),
            error: Te({}, me, {
              value: be
            }),
            group: Te({}, me, {
              value: le
            }),
            groupCollapsed: Te({}, me, {
              value: Ye
            }),
            groupEnd: Te({}, me, {
              value: $e
            })
          });
        }
        Ke < 0 && E("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var St = T.ReactCurrentDispatcher, ln;
    function hn(me, ut, Bt) {
      {
        if (ln === void 0)
          try {
            throw Error();
          } catch (ae) {
            var Tt = ae.stack.trim().match(/\n( *(at )?)/);
            ln = Tt && Tt[1] || "";
          }
        return `
` + ln + me;
      }
    }
    var mn = !1, Pn;
    {
      var he = typeof WeakMap == "function" ? WeakMap : Map;
      Pn = new he();
    }
    function Lt(me, ut) {
      if (!me || mn)
        return "";
      {
        var Bt = Pn.get(me);
        if (Bt !== void 0)
          return Bt;
      }
      var Tt;
      mn = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = St.current, St.current = null, ot();
      try {
        if (ut) {
          var Ee = function() {
            throw Error();
          };
          if (Object.defineProperty(Ee.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ee, []);
            } catch (Fn) {
              Tt = Fn;
            }
            Reflect.construct(me, [], Ee);
          } else {
            try {
              Ee.call();
            } catch (Fn) {
              Tt = Fn;
            }
            me.call(Ee.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Fn) {
            Tt = Fn;
          }
          me();
        }
      } catch (Fn) {
        if (Fn && Tt && typeof Fn.stack == "string") {
          for (var Ue = Fn.stack.split(`
`), Oe = Tt.stack.split(`
`), Nt = Ue.length - 1, Kt = Oe.length - 1; Nt >= 1 && Kt >= 0 && Ue[Nt] !== Oe[Kt]; )
            Kt--;
          for (; Nt >= 1 && Kt >= 0; Nt--, Kt--)
            if (Ue[Nt] !== Oe[Kt]) {
              if (Nt !== 1 || Kt !== 1)
                do
                  if (Nt--, Kt--, Kt < 0 || Ue[Nt] !== Oe[Kt]) {
                    var vn = `
` + Ue[Nt].replace(" at new ", " at ");
                    return me.displayName && vn.includes("<anonymous>") && (vn = vn.replace("<anonymous>", me.displayName)), typeof me == "function" && Pn.set(me, vn), vn;
                  }
                while (Nt >= 1 && Kt >= 0);
              break;
            }
        }
      } finally {
        mn = !1, St.current = we, wt(), Error.prepareStackTrace = ae;
      }
      var Yt = me ? me.displayName || me.name : "", Yn = Yt ? hn(Yt) : "";
      return typeof me == "function" && Pn.set(me, Yn), Yn;
    }
    function Wt(me, ut, Bt) {
      return Lt(me, !1);
    }
    function tn(me) {
      var ut = me.prototype;
      return !!(ut && ut.isReactComponent);
    }
    function Gt(me, ut, Bt) {
      if (me == null)
        return "";
      if (typeof me == "function")
        return Lt(me, tn(me));
      if (typeof me == "string")
        return hn(me);
      switch (me) {
        case h:
          return hn("Suspense");
        case v:
          return hn("SuspenseList");
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case f:
            return Wt(me.render);
          case b:
            return Gt(me.type, ut, Bt);
          case S: {
            var Tt = me, ae = Tt._payload, we = Tt._init;
            try {
              return Gt(we(ae), ut, Bt);
            } catch {
            }
          }
        }
      return "";
    }
    var Rn = Object.prototype.hasOwnProperty, nn = {}, Bn = T.ReactDebugCurrentFrame;
    function Se(me) {
      if (me) {
        var ut = me._owner, Bt = Gt(me.type, me._source, ut ? ut.type : null);
        Bn.setExtraStackFrame(Bt);
      } else
        Bn.setExtraStackFrame(null);
    }
    function oe(me, ut, Bt, Tt, ae) {
      {
        var we = Function.call.bind(Rn);
        for (var Ee in me)
          if (we(me, Ee)) {
            var Ue = void 0;
            try {
              if (typeof me[Ee] != "function") {
                var Oe = Error((Tt || "React class") + ": " + Bt + " type `" + Ee + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof me[Ee] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              Ue = me[Ee](ut, Ee, Tt, Bt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Nt) {
              Ue = Nt;
            }
            Ue && !(Ue instanceof Error) && (Se(ae), E("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Tt || "React class", Bt, Ee, typeof Ue), Se(null)), Ue instanceof Error && !(Ue.message in nn) && (nn[Ue.message] = !0, Se(ae), E("Failed %s type: %s", Bt, Ue.message), Se(null));
          }
      }
    }
    var ct = Array.isArray;
    function Ft(me) {
      return ct(me);
    }
    function pt(me) {
      {
        var ut = typeof Symbol == "function" && Symbol.toStringTag, Bt = ut && me[Symbol.toStringTag] || me.constructor.name || "Object";
        return Bt;
      }
    }
    function zt(me) {
      try {
        return Sn(me), !1;
      } catch {
        return !0;
      }
    }
    function Sn(me) {
      return "" + me;
    }
    function rn(me) {
      if (zt(me))
        return E("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", pt(me)), Sn(me);
    }
    var gn = T.ReactCurrentOwner, qn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, qt, An, Fe;
    Fe = {};
    function Ie(me) {
      if (Rn.call(me, "ref")) {
        var ut = Object.getOwnPropertyDescriptor(me, "ref").get;
        if (ut && ut.isReactWarning)
          return !1;
      }
      return me.ref !== void 0;
    }
    function at(me) {
      if (Rn.call(me, "key")) {
        var ut = Object.getOwnPropertyDescriptor(me, "key").get;
        if (ut && ut.isReactWarning)
          return !1;
      }
      return me.key !== void 0;
    }
    function ye(me, ut) {
      if (typeof me.ref == "string" && gn.current && ut && gn.current.stateNode !== ut) {
        var Bt = Ae(gn.current.type);
        Fe[Bt] || (E('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Ae(gn.current.type), me.ref), Fe[Bt] = !0);
      }
    }
    function Pe(me, ut) {
      {
        var Bt = function() {
          qt || (qt = !0, E("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ut));
        };
        Bt.isReactWarning = !0, Object.defineProperty(me, "key", {
          get: Bt,
          configurable: !0
        });
      }
    }
    function Ot(me, ut) {
      {
        var Bt = function() {
          An || (An = !0, E("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ut));
        };
        Bt.isReactWarning = !0, Object.defineProperty(me, "ref", {
          get: Bt,
          configurable: !0
        });
      }
    }
    var Re = function(me, ut, Bt, Tt, ae, we, Ee) {
      var Ue = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: me,
        key: ut,
        ref: Bt,
        props: Ee,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return Ue._store = {}, Object.defineProperty(Ue._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ue, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Tt
      }), Object.defineProperty(Ue, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(Ue.props), Object.freeze(Ue)), Ue;
    };
    function lt(me, ut, Bt, Tt, ae) {
      {
        var we, Ee = {}, Ue = null, Oe = null;
        Bt !== void 0 && (rn(Bt), Ue = "" + Bt), at(ut) && (rn(ut.key), Ue = "" + ut.key), Ie(ut) && (Oe = ut.ref, ye(ut, ae));
        for (we in ut)
          Rn.call(ut, we) && !qn.hasOwnProperty(we) && (Ee[we] = ut[we]);
        if (me && me.defaultProps) {
          var Nt = me.defaultProps;
          for (we in Nt)
            Ee[we] === void 0 && (Ee[we] = Nt[we]);
        }
        if (Ue || Oe) {
          var Kt = typeof me == "function" ? me.displayName || me.name || "Unknown" : me;
          Ue && Pe(Ee, Kt), Oe && Ot(Ee, Kt);
        }
        return Re(me, Ue, Oe, ae, Tt, gn.current, Ee);
      }
    }
    var _e = T.ReactCurrentOwner, ht = T.ReactDebugCurrentFrame;
    function Ht(me) {
      if (me) {
        var ut = me._owner, Bt = Gt(me.type, me._source, ut ? ut.type : null);
        ht.setExtraStackFrame(Bt);
      } else
        ht.setExtraStackFrame(null);
    }
    var an;
    an = !1;
    function fi(me) {
      return typeof me == "object" && me !== null && me.$$typeof === t;
    }
    function xi() {
      {
        if (_e.current) {
          var me = Ae(_e.current.type);
          if (me)
            return `

Check the render method of \`` + me + "`.";
        }
        return "";
      }
    }
    function Ir(me) {
      return "";
    }
    var Xi = {};
    function pi(me) {
      {
        var ut = xi();
        if (!ut) {
          var Bt = typeof me == "string" ? me : me.displayName || me.name;
          Bt && (ut = `

Check the top-level render call using <` + Bt + ">.");
        }
        return ut;
      }
    }
    function Cr(me, ut) {
      {
        if (!me._store || me._store.validated || me.key != null)
          return;
        me._store.validated = !0;
        var Bt = pi(ut);
        if (Xi[Bt])
          return;
        Xi[Bt] = !0;
        var Tt = "";
        me && me._owner && me._owner !== _e.current && (Tt = " It was passed a child from " + Ae(me._owner.type) + "."), Ht(me), E('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Bt, Tt), Ht(null);
      }
    }
    function Sa(me, ut) {
      {
        if (typeof me != "object")
          return;
        if (Ft(me))
          for (var Bt = 0; Bt < me.length; Bt++) {
            var Tt = me[Bt];
            fi(Tt) && Cr(Tt, ut);
          }
        else if (fi(me))
          me._store && (me._store.validated = !0);
        else if (me) {
          var ae = M(me);
          if (typeof ae == "function" && ae !== me.entries)
            for (var we = ae.call(me), Ee; !(Ee = we.next()).done; )
              fi(Ee.value) && Cr(Ee.value, ut);
        }
      }
    }
    function zr(me) {
      {
        var ut = me.type;
        if (ut == null || typeof ut == "string")
          return;
        var Bt;
        if (typeof ut == "function")
          Bt = ut.propTypes;
        else if (typeof ut == "object" && (ut.$$typeof === f || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ut.$$typeof === b))
          Bt = ut.propTypes;
        else
          return;
        if (Bt) {
          var Tt = Ae(ut);
          oe(Bt, me.props, "prop", Tt, me);
        } else if (ut.PropTypes !== void 0 && !an) {
          an = !0;
          var ae = Ae(ut);
          E("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof ut.getDefaultProps == "function" && !ut.getDefaultProps.isReactClassApproved && E("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function na(me) {
      {
        for (var ut = Object.keys(me.props), Bt = 0; Bt < ut.length; Bt++) {
          var Tt = ut[Bt];
          if (Tt !== "children" && Tt !== "key") {
            Ht(me), E("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Tt), Ht(null);
            break;
          }
        }
        me.ref !== null && (Ht(me), E("Invalid attribute `ref` supplied to `React.Fragment`."), Ht(null));
      }
    }
    var la = {};
    function Oa(me, ut, Bt, Tt, ae, we) {
      {
        var Ee = te(me);
        if (!Ee) {
          var Ue = "";
          (me === void 0 || typeof me == "object" && me !== null && Object.keys(me).length === 0) && (Ue += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ir();
          Oe ? Ue += Oe : Ue += xi();
          var Nt;
          me === null ? Nt = "null" : Ft(me) ? Nt = "array" : me !== void 0 && me.$$typeof === t ? (Nt = "<" + (Ae(me.type) || "Unknown") + " />", Ue = " Did you accidentally export a JSX literal instead of a component?") : Nt = typeof me, E("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Nt, Ue);
        }
        var Kt = lt(me, ut, Bt, ae, we);
        if (Kt == null)
          return Kt;
        if (Ee) {
          var vn = ut.children;
          if (vn !== void 0)
            if (Tt)
              if (Ft(vn)) {
                for (var Yt = 0; Yt < vn.length; Yt++)
                  Sa(vn[Yt], me);
                Object.freeze && Object.freeze(vn);
              } else
                E("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Sa(vn, me);
        }
        if (Rn.call(ut, "key")) {
          var Yn = Ae(me), Fn = Object.keys(ut).filter(function(or) {
            return or !== "key";
          }), _n = Fn.length > 0 ? "{key: someKey, " + Fn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!la[Yn + _n]) {
            var Xn = Fn.length > 0 ? "{" + Fn.join(": ..., ") + ": ...}" : "{}";
            E(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, _n, Yn, Xn, Yn), la[Yn + _n] = !0;
          }
        }
        return me === i ? na(Kt) : zr(Kt), Kt;
      }
    }
    function Le(me, ut, Bt) {
      return Oa(me, ut, Bt, !0);
    }
    function qe(me, ut, Bt) {
      return Oa(me, ut, Bt, !1);
    }
    var gt = qe, Pt = Le;
    cZ.Fragment = i, cZ.jsx = gt, cZ.jsxs = Pt;
  }(), cZ;
}
var eO = {};
eO.NODE_ENV === "production" ? hH.exports = qU() : hH.exports = $U();
var ze = hH.exports, FZ = {}, pH = { exports: {} }, xd = {}, Tx = { exports: {} }, DN = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xE;
function tO() {
  return xE || (xE = 1, function(a) {
    function e(ee, Ce) {
      var be = ee.length;
      ee.push(Ce);
      e: for (; 0 < be; ) {
        var le = be - 1 >>> 1, Ye = ee[le];
        if (0 < i(Ye, Ce)) ee[le] = Ce, ee[be] = Ye, be = le;
        else break e;
      }
    }
    function t(ee) {
      return ee.length === 0 ? null : ee[0];
    }
    function n(ee) {
      if (ee.length === 0) return null;
      var Ce = ee[0], be = ee.pop();
      if (be !== Ce) {
        ee[0] = be;
        e: for (var le = 0, Ye = ee.length, $e = Ye >>> 1; le < $e; ) {
          var ke = 2 * (le + 1) - 1, ot = ee[ke], wt = ke + 1, St = ee[wt];
          if (0 > i(ot, be)) wt < Ye && 0 > i(St, ot) ? (ee[le] = St, ee[wt] = be, le = wt) : (ee[le] = ot, ee[ke] = be, le = ke);
          else if (wt < Ye && 0 > i(St, be)) ee[le] = St, ee[wt] = be, le = wt;
          else break e;
        }
      }
      return Ce;
    }
    function i(ee, Ce) {
      var be = ee.sortIndex - Ce.sortIndex;
      return be !== 0 ? be : ee.id - Ce.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      a.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, u = l.now();
      a.unstable_now = function() {
        return l.now() - u;
      };
    }
    var I = [], f = [], h = 1, v = null, b = 3, S = !1, R = !1, W = !1, x = typeof setTimeout == "function" ? setTimeout : null, M = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function E(ee) {
      for (var Ce = t(f); Ce !== null; ) {
        if (Ce.callback === null) n(f);
        else if (Ce.startTime <= ee) n(f), Ce.sortIndex = Ce.expirationTime, e(I, Ce);
        else break;
        Ce = t(f);
      }
    }
    function _(ee) {
      if (W = !1, E(ee), !R) if (t(I) !== null) R = !0, Ke(P);
      else {
        var Ce = t(f);
        Ce !== null && je(_, Ce.startTime - ee);
      }
    }
    function P(ee, Ce) {
      R = !1, W && (W = !1, M(k), k = -1), S = !0;
      var be = b;
      try {
        for (E(Ce), v = t(I); v !== null && (!(v.expirationTime > Ce) || ee && !te()); ) {
          var le = v.callback;
          if (typeof le == "function") {
            v.callback = null, b = v.priorityLevel;
            var Ye = le(v.expirationTime <= Ce);
            Ce = a.unstable_now(), typeof Ye == "function" ? v.callback = Ye : v === t(I) && n(I), E(Ce);
          } else n(I);
          v = t(I);
        }
        if (v !== null) var $e = !0;
        else {
          var ke = t(f);
          ke !== null && je(_, ke.startTime - Ce), $e = !1;
        }
        return $e;
      } finally {
        v = null, b = be, S = !1;
      }
    }
    var U = !1, q = null, k = -1, O = 5, J = -1;
    function te() {
      return !(a.unstable_now() - J < O);
    }
    function fe() {
      if (q !== null) {
        var ee = a.unstable_now();
        J = ee;
        var Ce = !0;
        try {
          Ce = q(!0, ee);
        } finally {
          Ce ? pe() : (U = !1, q = null);
        }
      } else U = !1;
    }
    var pe;
    if (typeof T == "function") pe = function() {
      T(fe);
    };
    else if (typeof MessageChannel < "u") {
      var Ae = new MessageChannel(), Te = Ae.port2;
      Ae.port1.onmessage = fe, pe = function() {
        Te.postMessage(null);
      };
    } else pe = function() {
      x(fe, 0);
    };
    function Ke(ee) {
      q = ee, U || (U = !0, pe());
    }
    function je(ee, Ce) {
      k = x(function() {
        ee(a.unstable_now());
      }, Ce);
    }
    a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(ee) {
      ee.callback = null;
    }, a.unstable_continueExecution = function() {
      R || S || (R = !0, Ke(P));
    }, a.unstable_forceFrameRate = function(ee) {
      0 > ee || 125 < ee ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < ee ? Math.floor(1e3 / ee) : 5;
    }, a.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, a.unstable_getFirstCallbackNode = function() {
      return t(I);
    }, a.unstable_next = function(ee) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var Ce = 3;
          break;
        default:
          Ce = b;
      }
      var be = b;
      b = Ce;
      try {
        return ee();
      } finally {
        b = be;
      }
    }, a.unstable_pauseExecution = function() {
    }, a.unstable_requestPaint = function() {
    }, a.unstable_runWithPriority = function(ee, Ce) {
      switch (ee) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ee = 3;
      }
      var be = b;
      b = ee;
      try {
        return Ce();
      } finally {
        b = be;
      }
    }, a.unstable_scheduleCallback = function(ee, Ce, be) {
      var le = a.unstable_now();
      switch (typeof be == "object" && be !== null ? (be = be.delay, be = typeof be == "number" && 0 < be ? le + be : le) : be = le, ee) {
        case 1:
          var Ye = -1;
          break;
        case 2:
          Ye = 250;
          break;
        case 5:
          Ye = 1073741823;
          break;
        case 4:
          Ye = 1e4;
          break;
        default:
          Ye = 5e3;
      }
      return Ye = be + Ye, ee = { id: h++, callback: Ce, priorityLevel: ee, startTime: be, expirationTime: Ye, sortIndex: -1 }, be > le ? (ee.sortIndex = be, e(f, ee), t(I) === null && ee === t(f) && (W ? (M(k), k = -1) : W = !0, je(_, be - le))) : (ee.sortIndex = Ye, e(I, ee), R || S || (R = !0, Ke(P))), ee;
    }, a.unstable_shouldYield = te, a.unstable_wrapCallback = function(ee) {
      var Ce = b;
      return function() {
        var be = b;
        b = Ce;
        try {
          return ee.apply(this, arguments);
        } finally {
          b = be;
        }
      };
    };
  }(DN)), DN;
}
var UN = {}, WE;
function nO() {
  return WE || (WE = 1, function(a) {
    var e = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    e.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = !1, i = 5;
      function o(Fe, Ie) {
        var at = Fe.length;
        Fe.push(Ie), I(Fe, Ie, at);
      }
      function l(Fe) {
        return Fe.length === 0 ? null : Fe[0];
      }
      function u(Fe) {
        if (Fe.length === 0)
          return null;
        var Ie = Fe[0], at = Fe.pop();
        return at !== Ie && (Fe[0] = at, f(Fe, at, 0)), Ie;
      }
      function I(Fe, Ie, at) {
        for (var ye = at; ye > 0; ) {
          var Pe = ye - 1 >>> 1, Ot = Fe[Pe];
          if (h(Ot, Ie) > 0)
            Fe[Pe] = Ie, Fe[ye] = Ot, ye = Pe;
          else
            return;
        }
      }
      function f(Fe, Ie, at) {
        for (var ye = at, Pe = Fe.length, Ot = Pe >>> 1; ye < Ot; ) {
          var Re = (ye + 1) * 2 - 1, lt = Fe[Re], _e = Re + 1, ht = Fe[_e];
          if (h(lt, Ie) < 0)
            _e < Pe && h(ht, lt) < 0 ? (Fe[ye] = ht, Fe[_e] = Ie, ye = _e) : (Fe[ye] = lt, Fe[Re] = Ie, ye = Re);
          else if (_e < Pe && h(ht, Ie) < 0)
            Fe[ye] = ht, Fe[_e] = Ie, ye = _e;
          else
            return;
        }
      }
      function h(Fe, Ie) {
        var at = Fe.sortIndex - Ie.sortIndex;
        return at !== 0 ? at : Fe.id - Ie.id;
      }
      var v = 1, b = 2, S = 3, R = 4, W = 5;
      function x(Fe, Ie) {
      }
      var M = typeof performance == "object" && typeof performance.now == "function";
      if (M) {
        var T = performance;
        a.unstable_now = function() {
          return T.now();
        };
      } else {
        var E = Date, _ = E.now();
        a.unstable_now = function() {
          return E.now() - _;
        };
      }
      var P = 1073741823, U = -1, q = 250, k = 5e3, O = 1e4, J = P, te = [], fe = [], pe = 1, Ae = null, Te = S, Ke = !1, je = !1, ee = !1, Ce = typeof setTimeout == "function" ? setTimeout : null, be = typeof clearTimeout == "function" ? clearTimeout : null, le = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Ye(Fe) {
        for (var Ie = l(fe); Ie !== null; ) {
          if (Ie.callback === null)
            u(fe);
          else if (Ie.startTime <= Fe)
            u(fe), Ie.sortIndex = Ie.expirationTime, o(te, Ie);
          else
            return;
          Ie = l(fe);
        }
      }
      function $e(Fe) {
        if (ee = !1, Ye(Fe), !je)
          if (l(te) !== null)
            je = !0, rn(ke);
          else {
            var Ie = l(fe);
            Ie !== null && gn($e, Ie.startTime - Fe);
          }
      }
      function ke(Fe, Ie) {
        je = !1, ee && (ee = !1, qn()), Ke = !0;
        var at = Te;
        try {
          var ye;
          if (!n) return ot(Fe, Ie);
        } finally {
          Ae = null, Te = at, Ke = !1;
        }
      }
      function ot(Fe, Ie) {
        var at = Ie;
        for (Ye(at), Ae = l(te); Ae !== null && !t && !(Ae.expirationTime > at && (!Fe || Se())); ) {
          var ye = Ae.callback;
          if (typeof ye == "function") {
            Ae.callback = null, Te = Ae.priorityLevel;
            var Pe = Ae.expirationTime <= at, Ot = ye(Pe);
            at = a.unstable_now(), typeof Ot == "function" ? Ae.callback = Ot : Ae === l(te) && u(te), Ye(at);
          } else
            u(te);
          Ae = l(te);
        }
        if (Ae !== null)
          return !0;
        var Re = l(fe);
        return Re !== null && gn($e, Re.startTime - at), !1;
      }
      function wt(Fe, Ie) {
        switch (Fe) {
          case v:
          case b:
          case S:
          case R:
          case W:
            break;
          default:
            Fe = S;
        }
        var at = Te;
        Te = Fe;
        try {
          return Ie();
        } finally {
          Te = at;
        }
      }
      function St(Fe) {
        var Ie;
        switch (Te) {
          case v:
          case b:
          case S:
            Ie = S;
            break;
          default:
            Ie = Te;
            break;
        }
        var at = Te;
        Te = Ie;
        try {
          return Fe();
        } finally {
          Te = at;
        }
      }
      function ln(Fe) {
        var Ie = Te;
        return function() {
          var at = Te;
          Te = Ie;
          try {
            return Fe.apply(this, arguments);
          } finally {
            Te = at;
          }
        };
      }
      function hn(Fe, Ie, at) {
        var ye = a.unstable_now(), Pe;
        if (typeof at == "object" && at !== null) {
          var Ot = at.delay;
          typeof Ot == "number" && Ot > 0 ? Pe = ye + Ot : Pe = ye;
        } else
          Pe = ye;
        var Re;
        switch (Fe) {
          case v:
            Re = U;
            break;
          case b:
            Re = q;
            break;
          case W:
            Re = J;
            break;
          case R:
            Re = O;
            break;
          case S:
          default:
            Re = k;
            break;
        }
        var lt = Pe + Re, _e = {
          id: pe++,
          callback: Ie,
          priorityLevel: Fe,
          startTime: Pe,
          expirationTime: lt,
          sortIndex: -1
        };
        return Pe > ye ? (_e.sortIndex = Pe, o(fe, _e), l(te) === null && _e === l(fe) && (ee ? qn() : ee = !0, gn($e, Pe - ye))) : (_e.sortIndex = lt, o(te, _e), !je && !Ke && (je = !0, rn(ke))), _e;
      }
      function mn() {
      }
      function Pn() {
        !je && !Ke && (je = !0, rn(ke));
      }
      function he() {
        return l(te);
      }
      function Lt(Fe) {
        Fe.callback = null;
      }
      function Wt() {
        return Te;
      }
      var tn = !1, Gt = null, Rn = -1, nn = i, Bn = -1;
      function Se() {
        var Fe = a.unstable_now() - Bn;
        return !(Fe < nn);
      }
      function oe() {
      }
      function ct(Fe) {
        if (Fe < 0 || Fe > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Fe > 0 ? nn = Math.floor(1e3 / Fe) : nn = i;
      }
      var Ft = function() {
        if (Gt !== null) {
          var Fe = a.unstable_now();
          Bn = Fe;
          var Ie = !0, at = !0;
          try {
            at = Gt(Ie, Fe);
          } finally {
            at ? pt() : (tn = !1, Gt = null);
          }
        } else
          tn = !1;
      }, pt;
      if (typeof le == "function")
        pt = function() {
          le(Ft);
        };
      else if (typeof MessageChannel < "u") {
        var zt = new MessageChannel(), Sn = zt.port2;
        zt.port1.onmessage = Ft, pt = function() {
          Sn.postMessage(null);
        };
      } else
        pt = function() {
          Ce(Ft, 0);
        };
      function rn(Fe) {
        Gt = Fe, tn || (tn = !0, pt());
      }
      function gn(Fe, Ie) {
        Rn = Ce(function() {
          Fe(a.unstable_now());
        }, Ie);
      }
      function qn() {
        be(Rn), Rn = -1;
      }
      var qt = oe, An = null;
      a.unstable_IdlePriority = W, a.unstable_ImmediatePriority = v, a.unstable_LowPriority = R, a.unstable_NormalPriority = S, a.unstable_Profiling = An, a.unstable_UserBlockingPriority = b, a.unstable_cancelCallback = Lt, a.unstable_continueExecution = Pn, a.unstable_forceFrameRate = ct, a.unstable_getCurrentPriorityLevel = Wt, a.unstable_getFirstCallbackNode = he, a.unstable_next = St, a.unstable_pauseExecution = mn, a.unstable_requestPaint = qt, a.unstable_runWithPriority = wt, a.unstable_scheduleCallback = hn, a.unstable_shouldYield = Se, a.unstable_wrapCallback = ln, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(UN)), UN;
}
var VE;
function I5() {
  if (VE) return Tx.exports;
  VE = 1;
  var a = {};
  return a.NODE_ENV === "production" ? Tx.exports = tO() : Tx.exports = nO(), Tx.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NE;
function iO() {
  if (NE) return xd;
  NE = 1;
  var a = xe, e = I5();
  function t(g) {
    for (var C = "https://reactjs.org/docs/error-decoder.html?invariant=" + g, B = 1; B < arguments.length; B++) C += "&args[]=" + encodeURIComponent(arguments[B]);
    return "Minified React error #" + g + "; visit " + C + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = /* @__PURE__ */ new Set(), i = {};
  function o(g, C) {
    l(g, C), l(g + "Capture", C);
  }
  function l(g, C) {
    for (i[g] = C, g = 0; g < C.length; g++) n.add(C[g]);
  }
  var u = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), I = Object.prototype.hasOwnProperty, f = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, h = {}, v = {};
  function b(g) {
    return I.call(v, g) ? !0 : I.call(h, g) ? !1 : f.test(g) ? v[g] = !0 : (h[g] = !0, !1);
  }
  function S(g, C, B, N) {
    if (B !== null && B.type === 0) return !1;
    switch (typeof C) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return N ? !1 : B !== null ? !B.acceptsBooleans : (g = g.toLowerCase().slice(0, 5), g !== "data-" && g !== "aria-");
      default:
        return !1;
    }
  }
  function R(g, C, B, N) {
    if (C === null || typeof C > "u" || S(g, C, B, N)) return !0;
    if (N) return !1;
    if (B !== null) switch (B.type) {
      case 3:
        return !C;
      case 4:
        return C === !1;
      case 5:
        return isNaN(C);
      case 6:
        return isNaN(C) || 1 > C;
    }
    return !1;
  }
  function W(g, C, B, N, F, D, se) {
    this.acceptsBooleans = C === 2 || C === 3 || C === 4, this.attributeName = N, this.attributeNamespace = F, this.mustUseProperty = B, this.propertyName = g, this.type = C, this.sanitizeURL = D, this.removeEmptyString = se;
  }
  var x = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(g) {
    x[g] = new W(g, 0, !1, g, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(g) {
    var C = g[0];
    x[C] = new W(C, 1, !1, g[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(g) {
    x[g] = new W(g, 2, !1, g.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(g) {
    x[g] = new W(g, 2, !1, g, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(g) {
    x[g] = new W(g, 3, !1, g.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(g) {
    x[g] = new W(g, 3, !0, g, null, !1, !1);
  }), ["capture", "download"].forEach(function(g) {
    x[g] = new W(g, 4, !1, g, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(g) {
    x[g] = new W(g, 6, !1, g, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(g) {
    x[g] = new W(g, 5, !1, g.toLowerCase(), null, !1, !1);
  });
  var M = /[\-:]([a-z])/g;
  function T(g) {
    return g[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(g) {
    var C = g.replace(
      M,
      T
    );
    x[C] = new W(C, 1, !1, g, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(g) {
    var C = g.replace(M, T);
    x[C] = new W(C, 1, !1, g, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(g) {
    var C = g.replace(M, T);
    x[C] = new W(C, 1, !1, g, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(g) {
    x[g] = new W(g, 1, !1, g.toLowerCase(), null, !1, !1);
  }), x.xlinkHref = new W("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(g) {
    x[g] = new W(g, 1, !1, g.toLowerCase(), null, !0, !0);
  });
  function E(g, C, B, N) {
    var F = x.hasOwnProperty(C) ? x[C] : null;
    (F !== null ? F.type !== 0 : N || !(2 < C.length) || C[0] !== "o" && C[0] !== "O" || C[1] !== "n" && C[1] !== "N") && (R(C, B, F, N) && (B = null), N || F === null ? b(C) && (B === null ? g.removeAttribute(C) : g.setAttribute(C, "" + B)) : F.mustUseProperty ? g[F.propertyName] = B === null ? F.type === 3 ? !1 : "" : B : (C = F.attributeName, N = F.attributeNamespace, B === null ? g.removeAttribute(C) : (F = F.type, B = F === 3 || F === 4 && B === !0 ? "" : "" + B, N ? g.setAttributeNS(N, C, B) : g.setAttribute(C, B))));
  }
  var _ = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, P = Symbol.for("react.element"), U = Symbol.for("react.portal"), q = Symbol.for("react.fragment"), k = Symbol.for("react.strict_mode"), O = Symbol.for("react.profiler"), J = Symbol.for("react.provider"), te = Symbol.for("react.context"), fe = Symbol.for("react.forward_ref"), pe = Symbol.for("react.suspense"), Ae = Symbol.for("react.suspense_list"), Te = Symbol.for("react.memo"), Ke = Symbol.for("react.lazy"), je = Symbol.for("react.offscreen"), ee = Symbol.iterator;
  function Ce(g) {
    return g === null || typeof g != "object" ? null : (g = ee && g[ee] || g["@@iterator"], typeof g == "function" ? g : null);
  }
  var be = Object.assign, le;
  function Ye(g) {
    if (le === void 0) try {
      throw Error();
    } catch (B) {
      var C = B.stack.trim().match(/\n( *(at )?)/);
      le = C && C[1] || "";
    }
    return `
` + le + g;
  }
  var $e = !1;
  function ke(g, C) {
    if (!g || $e) return "";
    $e = !0;
    var B = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (C) if (C = function() {
        throw Error();
      }, Object.defineProperty(C.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(C, []);
        } catch (xt) {
          var N = xt;
        }
        Reflect.construct(g, [], C);
      } else {
        try {
          C.call();
        } catch (xt) {
          N = xt;
        }
        g.call(C.prototype);
      }
      else {
        try {
          throw Error();
        } catch (xt) {
          N = xt;
        }
        g();
      }
    } catch (xt) {
      if (xt && N && typeof xt.stack == "string") {
        for (var F = xt.stack.split(`
`), D = N.stack.split(`
`), se = F.length - 1, He = D.length - 1; 1 <= se && 0 <= He && F[se] !== D[He]; ) He--;
        for (; 1 <= se && 0 <= He; se--, He--) if (F[se] !== D[He]) {
          if (se !== 1 || He !== 1)
            do
              if (se--, He--, 0 > He || F[se] !== D[He]) {
                var Qe = `
` + F[se].replace(" at new ", " at ");
                return g.displayName && Qe.includes("<anonymous>") && (Qe = Qe.replace("<anonymous>", g.displayName)), Qe;
              }
            while (1 <= se && 0 <= He);
          break;
        }
      }
    } finally {
      $e = !1, Error.prepareStackTrace = B;
    }
    return (g = g ? g.displayName || g.name : "") ? Ye(g) : "";
  }
  function ot(g) {
    switch (g.tag) {
      case 5:
        return Ye(g.type);
      case 16:
        return Ye("Lazy");
      case 13:
        return Ye("Suspense");
      case 19:
        return Ye("SuspenseList");
      case 0:
      case 2:
      case 15:
        return g = ke(g.type, !1), g;
      case 11:
        return g = ke(g.type.render, !1), g;
      case 1:
        return g = ke(g.type, !0), g;
      default:
        return "";
    }
  }
  function wt(g) {
    if (g == null) return null;
    if (typeof g == "function") return g.displayName || g.name || null;
    if (typeof g == "string") return g;
    switch (g) {
      case q:
        return "Fragment";
      case U:
        return "Portal";
      case O:
        return "Profiler";
      case k:
        return "StrictMode";
      case pe:
        return "Suspense";
      case Ae:
        return "SuspenseList";
    }
    if (typeof g == "object") switch (g.$$typeof) {
      case te:
        return (g.displayName || "Context") + ".Consumer";
      case J:
        return (g._context.displayName || "Context") + ".Provider";
      case fe:
        var C = g.render;
        return g = g.displayName, g || (g = C.displayName || C.name || "", g = g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef"), g;
      case Te:
        return C = g.displayName || null, C !== null ? C : wt(g.type) || "Memo";
      case Ke:
        C = g._payload, g = g._init;
        try {
          return wt(g(C));
        } catch {
        }
    }
    return null;
  }
  function St(g) {
    var C = g.type;
    switch (g.tag) {
      case 24:
        return "Cache";
      case 9:
        return (C.displayName || "Context") + ".Consumer";
      case 10:
        return (C._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return g = C.render, g = g.displayName || g.name || "", C.displayName || (g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return C;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return wt(C);
      case 8:
        return C === k ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof C == "function") return C.displayName || C.name || null;
        if (typeof C == "string") return C;
    }
    return null;
  }
  function ln(g) {
    switch (typeof g) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return g;
      case "object":
        return g;
      default:
        return "";
    }
  }
  function hn(g) {
    var C = g.type;
    return (g = g.nodeName) && g.toLowerCase() === "input" && (C === "checkbox" || C === "radio");
  }
  function mn(g) {
    var C = hn(g) ? "checked" : "value", B = Object.getOwnPropertyDescriptor(g.constructor.prototype, C), N = "" + g[C];
    if (!g.hasOwnProperty(C) && typeof B < "u" && typeof B.get == "function" && typeof B.set == "function") {
      var F = B.get, D = B.set;
      return Object.defineProperty(g, C, { configurable: !0, get: function() {
        return F.call(this);
      }, set: function(se) {
        N = "" + se, D.call(this, se);
      } }), Object.defineProperty(g, C, { enumerable: B.enumerable }), { getValue: function() {
        return N;
      }, setValue: function(se) {
        N = "" + se;
      }, stopTracking: function() {
        g._valueTracker = null, delete g[C];
      } };
    }
  }
  function Pn(g) {
    g._valueTracker || (g._valueTracker = mn(g));
  }
  function he(g) {
    if (!g) return !1;
    var C = g._valueTracker;
    if (!C) return !0;
    var B = C.getValue(), N = "";
    return g && (N = hn(g) ? g.checked ? "true" : "false" : g.value), g = N, g !== B ? (C.setValue(g), !0) : !1;
  }
  function Lt(g) {
    if (g = g || (typeof document < "u" ? document : void 0), typeof g > "u") return null;
    try {
      return g.activeElement || g.body;
    } catch {
      return g.body;
    }
  }
  function Wt(g, C) {
    var B = C.checked;
    return be({}, C, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: B ?? g._wrapperState.initialChecked });
  }
  function tn(g, C) {
    var B = C.defaultValue == null ? "" : C.defaultValue, N = C.checked != null ? C.checked : C.defaultChecked;
    B = ln(C.value != null ? C.value : B), g._wrapperState = { initialChecked: N, initialValue: B, controlled: C.type === "checkbox" || C.type === "radio" ? C.checked != null : C.value != null };
  }
  function Gt(g, C) {
    C = C.checked, C != null && E(g, "checked", C, !1);
  }
  function Rn(g, C) {
    Gt(g, C);
    var B = ln(C.value), N = C.type;
    if (B != null) N === "number" ? (B === 0 && g.value === "" || g.value != B) && (g.value = "" + B) : g.value !== "" + B && (g.value = "" + B);
    else if (N === "submit" || N === "reset") {
      g.removeAttribute("value");
      return;
    }
    C.hasOwnProperty("value") ? Bn(g, C.type, B) : C.hasOwnProperty("defaultValue") && Bn(g, C.type, ln(C.defaultValue)), C.checked == null && C.defaultChecked != null && (g.defaultChecked = !!C.defaultChecked);
  }
  function nn(g, C, B) {
    if (C.hasOwnProperty("value") || C.hasOwnProperty("defaultValue")) {
      var N = C.type;
      if (!(N !== "submit" && N !== "reset" || C.value !== void 0 && C.value !== null)) return;
      C = "" + g._wrapperState.initialValue, B || C === g.value || (g.value = C), g.defaultValue = C;
    }
    B = g.name, B !== "" && (g.name = ""), g.defaultChecked = !!g._wrapperState.initialChecked, B !== "" && (g.name = B);
  }
  function Bn(g, C, B) {
    (C !== "number" || Lt(g.ownerDocument) !== g) && (B == null ? g.defaultValue = "" + g._wrapperState.initialValue : g.defaultValue !== "" + B && (g.defaultValue = "" + B));
  }
  var Se = Array.isArray;
  function oe(g, C, B, N) {
    if (g = g.options, C) {
      C = {};
      for (var F = 0; F < B.length; F++) C["$" + B[F]] = !0;
      for (B = 0; B < g.length; B++) F = C.hasOwnProperty("$" + g[B].value), g[B].selected !== F && (g[B].selected = F), F && N && (g[B].defaultSelected = !0);
    } else {
      for (B = "" + ln(B), C = null, F = 0; F < g.length; F++) {
        if (g[F].value === B) {
          g[F].selected = !0, N && (g[F].defaultSelected = !0);
          return;
        }
        C !== null || g[F].disabled || (C = g[F]);
      }
      C !== null && (C.selected = !0);
    }
  }
  function ct(g, C) {
    if (C.dangerouslySetInnerHTML != null) throw Error(t(91));
    return be({}, C, { value: void 0, defaultValue: void 0, children: "" + g._wrapperState.initialValue });
  }
  function Ft(g, C) {
    var B = C.value;
    if (B == null) {
      if (B = C.children, C = C.defaultValue, B != null) {
        if (C != null) throw Error(t(92));
        if (Se(B)) {
          if (1 < B.length) throw Error(t(93));
          B = B[0];
        }
        C = B;
      }
      C == null && (C = ""), B = C;
    }
    g._wrapperState = { initialValue: ln(B) };
  }
  function pt(g, C) {
    var B = ln(C.value), N = ln(C.defaultValue);
    B != null && (B = "" + B, B !== g.value && (g.value = B), C.defaultValue == null && g.defaultValue !== B && (g.defaultValue = B)), N != null && (g.defaultValue = "" + N);
  }
  function zt(g) {
    var C = g.textContent;
    C === g._wrapperState.initialValue && C !== "" && C !== null && (g.value = C);
  }
  function Sn(g) {
    switch (g) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function rn(g, C) {
    return g == null || g === "http://www.w3.org/1999/xhtml" ? Sn(C) : g === "http://www.w3.org/2000/svg" && C === "foreignObject" ? "http://www.w3.org/1999/xhtml" : g;
  }
  var gn, qn = function(g) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(C, B, N, F) {
      MSApp.execUnsafeLocalFunction(function() {
        return g(C, B, N, F);
      });
    } : g;
  }(function(g, C) {
    if (g.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in g) g.innerHTML = C;
    else {
      for (gn = gn || document.createElement("div"), gn.innerHTML = "<svg>" + C.valueOf().toString() + "</svg>", C = gn.firstChild; g.firstChild; ) g.removeChild(g.firstChild);
      for (; C.firstChild; ) g.appendChild(C.firstChild);
    }
  });
  function qt(g, C) {
    if (C) {
      var B = g.firstChild;
      if (B && B === g.lastChild && B.nodeType === 3) {
        B.nodeValue = C;
        return;
      }
    }
    g.textContent = C;
  }
  var An = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Fe = ["Webkit", "ms", "Moz", "O"];
  Object.keys(An).forEach(function(g) {
    Fe.forEach(function(C) {
      C = C + g.charAt(0).toUpperCase() + g.substring(1), An[C] = An[g];
    });
  });
  function Ie(g, C, B) {
    return C == null || typeof C == "boolean" || C === "" ? "" : B || typeof C != "number" || C === 0 || An.hasOwnProperty(g) && An[g] ? ("" + C).trim() : C + "px";
  }
  function at(g, C) {
    g = g.style;
    for (var B in C) if (C.hasOwnProperty(B)) {
      var N = B.indexOf("--") === 0, F = Ie(B, C[B], N);
      B === "float" && (B = "cssFloat"), N ? g.setProperty(B, F) : g[B] = F;
    }
  }
  var ye = be({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Pe(g, C) {
    if (C) {
      if (ye[g] && (C.children != null || C.dangerouslySetInnerHTML != null)) throw Error(t(137, g));
      if (C.dangerouslySetInnerHTML != null) {
        if (C.children != null) throw Error(t(60));
        if (typeof C.dangerouslySetInnerHTML != "object" || !("__html" in C.dangerouslySetInnerHTML)) throw Error(t(61));
      }
      if (C.style != null && typeof C.style != "object") throw Error(t(62));
    }
  }
  function Ot(g, C) {
    if (g.indexOf("-") === -1) return typeof C.is == "string";
    switch (g) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Re = null;
  function lt(g) {
    return g = g.target || g.srcElement || window, g.correspondingUseElement && (g = g.correspondingUseElement), g.nodeType === 3 ? g.parentNode : g;
  }
  var _e = null, ht = null, Ht = null;
  function an(g) {
    if (g = os(g)) {
      if (typeof _e != "function") throw Error(t(280));
      var C = g.stateNode;
      C && (C = ks(C), _e(g.stateNode, g.type, C));
    }
  }
  function fi(g) {
    ht ? Ht ? Ht.push(g) : Ht = [g] : ht = g;
  }
  function xi() {
    if (ht) {
      var g = ht, C = Ht;
      if (Ht = ht = null, an(g), C) for (g = 0; g < C.length; g++) an(C[g]);
    }
  }
  function Ir(g, C) {
    return g(C);
  }
  function Xi() {
  }
  var pi = !1;
  function Cr(g, C, B) {
    if (pi) return g(C, B);
    pi = !0;
    try {
      return Ir(g, C, B);
    } finally {
      pi = !1, (ht !== null || Ht !== null) && (Xi(), xi());
    }
  }
  function Sa(g, C) {
    var B = g.stateNode;
    if (B === null) return null;
    var N = ks(B);
    if (N === null) return null;
    B = N[C];
    e: switch (C) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (N = !N.disabled) || (g = g.type, N = !(g === "button" || g === "input" || g === "select" || g === "textarea")), g = !N;
        break e;
      default:
        g = !1;
    }
    if (g) return null;
    if (B && typeof B != "function") throw Error(t(231, C, typeof B));
    return B;
  }
  var zr = !1;
  if (u) try {
    var na = {};
    Object.defineProperty(na, "passive", { get: function() {
      zr = !0;
    } }), window.addEventListener("test", na, na), window.removeEventListener("test", na, na);
  } catch {
    zr = !1;
  }
  function la(g, C, B, N, F, D, se, He, Qe) {
    var xt = Array.prototype.slice.call(arguments, 3);
    try {
      C.apply(B, xt);
    } catch (Cn) {
      this.onError(Cn);
    }
  }
  var Oa = !1, Le = null, qe = !1, gt = null, Pt = { onError: function(g) {
    Oa = !0, Le = g;
  } };
  function me(g, C, B, N, F, D, se, He, Qe) {
    Oa = !1, Le = null, la.apply(Pt, arguments);
  }
  function ut(g, C, B, N, F, D, se, He, Qe) {
    if (me.apply(this, arguments), Oa) {
      if (Oa) {
        var xt = Le;
        Oa = !1, Le = null;
      } else throw Error(t(198));
      qe || (qe = !0, gt = xt);
    }
  }
  function Bt(g) {
    var C = g, B = g;
    if (g.alternate) for (; C.return; ) C = C.return;
    else {
      g = C;
      do
        C = g, C.flags & 4098 && (B = C.return), g = C.return;
      while (g);
    }
    return C.tag === 3 ? B : null;
  }
  function Tt(g) {
    if (g.tag === 13) {
      var C = g.memoizedState;
      if (C === null && (g = g.alternate, g !== null && (C = g.memoizedState)), C !== null) return C.dehydrated;
    }
    return null;
  }
  function ae(g) {
    if (Bt(g) !== g) throw Error(t(188));
  }
  function we(g) {
    var C = g.alternate;
    if (!C) {
      if (C = Bt(g), C === null) throw Error(t(188));
      return C !== g ? null : g;
    }
    for (var B = g, N = C; ; ) {
      var F = B.return;
      if (F === null) break;
      var D = F.alternate;
      if (D === null) {
        if (N = F.return, N !== null) {
          B = N;
          continue;
        }
        break;
      }
      if (F.child === D.child) {
        for (D = F.child; D; ) {
          if (D === B) return ae(F), g;
          if (D === N) return ae(F), C;
          D = D.sibling;
        }
        throw Error(t(188));
      }
      if (B.return !== N.return) B = F, N = D;
      else {
        for (var se = !1, He = F.child; He; ) {
          if (He === B) {
            se = !0, B = F, N = D;
            break;
          }
          if (He === N) {
            se = !0, N = F, B = D;
            break;
          }
          He = He.sibling;
        }
        if (!se) {
          for (He = D.child; He; ) {
            if (He === B) {
              se = !0, B = D, N = F;
              break;
            }
            if (He === N) {
              se = !0, N = D, B = F;
              break;
            }
            He = He.sibling;
          }
          if (!se) throw Error(t(189));
        }
      }
      if (B.alternate !== N) throw Error(t(190));
    }
    if (B.tag !== 3) throw Error(t(188));
    return B.stateNode.current === B ? g : C;
  }
  function Ee(g) {
    return g = we(g), g !== null ? Ue(g) : null;
  }
  function Ue(g) {
    if (g.tag === 5 || g.tag === 6) return g;
    for (g = g.child; g !== null; ) {
      var C = Ue(g);
      if (C !== null) return C;
      g = g.sibling;
    }
    return null;
  }
  var Oe = e.unstable_scheduleCallback, Nt = e.unstable_cancelCallback, Kt = e.unstable_shouldYield, vn = e.unstable_requestPaint, Yt = e.unstable_now, Yn = e.unstable_getCurrentPriorityLevel, Fn = e.unstable_ImmediatePriority, _n = e.unstable_UserBlockingPriority, Xn = e.unstable_NormalPriority, or = e.unstable_LowPriority, Ei = e.unstable_IdlePriority, pr = null, Ln = null;
  function ge(g) {
    if (Ln && typeof Ln.onCommitFiberRoot == "function") try {
      Ln.onCommitFiberRoot(pr, g, void 0, (g.current.flags & 128) === 128);
    } catch {
    }
  }
  var ue = Math.clz32 ? Math.clz32 : Mt, We = Math.log, et = Math.LN2;
  function Mt(g) {
    return g >>>= 0, g === 0 ? 32 : 31 - (We(g) / et | 0) | 0;
  }
  var bn = 64, Ai = 4194304;
  function ve(g) {
    switch (g & -g) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return g & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return g & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return g;
    }
  }
  function Be(g, C) {
    var B = g.pendingLanes;
    if (B === 0) return 0;
    var N = 0, F = g.suspendedLanes, D = g.pingedLanes, se = B & 268435455;
    if (se !== 0) {
      var He = se & ~F;
      He !== 0 ? N = ve(He) : (D &= se, D !== 0 && (N = ve(D)));
    } else se = B & ~F, se !== 0 ? N = ve(se) : D !== 0 && (N = ve(D));
    if (N === 0) return 0;
    if (C !== 0 && C !== N && !(C & F) && (F = N & -N, D = C & -C, F >= D || F === 16 && (D & 4194240) !== 0)) return C;
    if (N & 4 && (N |= B & 16), C = g.entangledLanes, C !== 0) for (g = g.entanglements, C &= N; 0 < C; ) B = 31 - ue(C), F = 1 << B, N |= g[B], C &= ~F;
    return N;
  }
  function mt(g, C) {
    switch (g) {
      case 1:
      case 2:
      case 4:
        return C + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return C + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function $t(g, C) {
    for (var B = g.suspendedLanes, N = g.pingedLanes, F = g.expirationTimes, D = g.pendingLanes; 0 < D; ) {
      var se = 31 - ue(D), He = 1 << se, Qe = F[se];
      Qe === -1 ? (!(He & B) || He & N) && (F[se] = mt(He, C)) : Qe <= C && (g.expiredLanes |= He), D &= ~He;
    }
  }
  function In(g) {
    return g = g.pendingLanes & -1073741825, g !== 0 ? g : g & 1073741824 ? 1073741824 : 0;
  }
  function un() {
    var g = bn;
    return bn <<= 1, !(bn & 4194240) && (bn = 64), g;
  }
  function Bi(g) {
    for (var C = [], B = 0; 31 > B; B++) C.push(g);
    return C;
  }
  function Si(g, C, B) {
    g.pendingLanes |= C, C !== 536870912 && (g.suspendedLanes = 0, g.pingedLanes = 0), g = g.eventTimes, C = 31 - ue(C), g[C] = B;
  }
  function Ji(g, C) {
    var B = g.pendingLanes & ~C;
    g.pendingLanes = C, g.suspendedLanes = 0, g.pingedLanes = 0, g.expiredLanes &= C, g.mutableReadLanes &= C, g.entangledLanes &= C, C = g.entanglements;
    var N = g.eventTimes;
    for (g = g.expirationTimes; 0 < B; ) {
      var F = 31 - ue(B), D = 1 << F;
      C[F] = 0, N[F] = -1, g[F] = -1, B &= ~D;
    }
  }
  function En(g, C) {
    var B = g.entangledLanes |= C;
    for (g = g.entanglements; B; ) {
      var N = 31 - ue(B), F = 1 << N;
      F & C | g[N] & C && (g[N] |= C), B &= ~F;
    }
  }
  var cn = 0;
  function kn(g) {
    return g &= -g, 1 < g ? 4 < g ? g & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var ti, Di, qi, ci, Hr, Za = !1, gi = [], yr = null, Hn = null, Pa = null, zo = /* @__PURE__ */ new Map(), Ko = /* @__PURE__ */ new Map(), Xr = [], ia = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function kr(g, C) {
    switch (g) {
      case "focusin":
      case "focusout":
        yr = null;
        break;
      case "dragenter":
      case "dragleave":
        Hn = null;
        break;
      case "mouseover":
      case "mouseout":
        Pa = null;
        break;
      case "pointerover":
      case "pointerout":
        zo.delete(C.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ko.delete(C.pointerId);
    }
  }
  function ua(g, C, B, N, F, D) {
    return g === null || g.nativeEvent !== D ? (g = { blockedOn: C, domEventName: B, eventSystemFlags: N, nativeEvent: D, targetContainers: [F] }, C !== null && (C = os(C), C !== null && Di(C)), g) : (g.eventSystemFlags |= N, C = g.targetContainers, F !== null && C.indexOf(F) === -1 && C.push(F), g);
  }
  function Lo(g, C, B, N, F) {
    switch (C) {
      case "focusin":
        return yr = ua(yr, g, C, B, N, F), !0;
      case "dragenter":
        return Hn = ua(Hn, g, C, B, N, F), !0;
      case "mouseover":
        return Pa = ua(Pa, g, C, B, N, F), !0;
      case "pointerover":
        var D = F.pointerId;
        return zo.set(D, ua(zo.get(D) || null, g, C, B, N, F)), !0;
      case "gotpointercapture":
        return D = F.pointerId, Ko.set(D, ua(Ko.get(D) || null, g, C, B, N, F)), !0;
    }
    return !1;
  }
  function ko(g) {
    var C = Ju(g.target);
    if (C !== null) {
      var B = Bt(C);
      if (B !== null) {
        if (C = B.tag, C === 13) {
          if (C = Tt(B), C !== null) {
            g.blockedOn = C, Hr(g.priority, function() {
              qi(B);
            });
            return;
          }
        } else if (C === 3 && B.stateNode.current.memoizedState.isDehydrated) {
          g.blockedOn = B.tag === 3 ? B.stateNode.containerInfo : null;
          return;
        }
      }
    }
    g.blockedOn = null;
  }
  function cu(g) {
    if (g.blockedOn !== null) return !1;
    for (var C = g.targetContainers; 0 < C.length; ) {
      var B = al(g.domEventName, g.eventSystemFlags, C[0], g.nativeEvent);
      if (B === null) {
        B = g.nativeEvent;
        var N = new B.constructor(B.type, B);
        Re = N, B.target.dispatchEvent(N), Re = null;
      } else return C = os(B), C !== null && Di(C), g.blockedOn = B, !1;
      C.shift();
    }
    return !0;
  }
  function Ja(g, C, B) {
    cu(g) && B.delete(C);
  }
  function is() {
    Za = !1, yr !== null && cu(yr) && (yr = null), Hn !== null && cu(Hn) && (Hn = null), Pa !== null && cu(Pa) && (Pa = null), zo.forEach(Ja), Ko.forEach(Ja);
  }
  function Qg(g, C) {
    g.blockedOn === C && (g.blockedOn = null, Za || (Za = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, is)));
  }
  function gu(g) {
    function C(F) {
      return Qg(F, g);
    }
    if (0 < gi.length) {
      Qg(gi[0], g);
      for (var B = 1; B < gi.length; B++) {
        var N = gi[B];
        N.blockedOn === g && (N.blockedOn = null);
      }
    }
    for (yr !== null && Qg(yr, g), Hn !== null && Qg(Hn, g), Pa !== null && Qg(Pa, g), zo.forEach(C), Ko.forEach(C), B = 0; B < Xr.length; B++) N = Xr[B], N.blockedOn === g && (N.blockedOn = null);
    for (; 0 < Xr.length && (B = Xr[0], B.blockedOn === null); ) ko(B), B.blockedOn === null && Xr.shift();
  }
  var rs = _.ReactCurrentBatchConfig, rl = !0;
  function du(g, C, B, N) {
    var F = cn, D = rs.transition;
    rs.transition = null;
    try {
      cn = 1, ku(g, C, B, N);
    } finally {
      cn = F, rs.transition = D;
    }
  }
  function jg(g, C, B, N) {
    var F = cn, D = rs.transition;
    rs.transition = null;
    try {
      cn = 4, ku(g, C, B, N);
    } finally {
      cn = F, rs.transition = D;
    }
  }
  function ku(g, C, B, N) {
    if (rl) {
      var F = al(g, C, B, N);
      if (F === null) Rc(g, C, N, Bc, B), kr(g, N);
      else if (Lo(F, g, C, B, N)) N.stopPropagation();
      else if (kr(g, N), C & 4 && -1 < ia.indexOf(g)) {
        for (; F !== null; ) {
          var D = os(F);
          if (D !== null && ti(D), D = al(g, C, B, N), D === null && Rc(g, C, N, Bc, B), D === F) break;
          F = D;
        }
        F !== null && N.stopPropagation();
      } else Rc(g, C, N, null, B);
    }
  }
  var Bc = null;
  function al(g, C, B, N) {
    if (Bc = null, g = lt(N), g = Ju(g), g !== null) if (C = Bt(g), C === null) g = null;
    else if (B = C.tag, B === 13) {
      if (g = Tt(C), g !== null) return g;
      g = null;
    } else if (B === 3) {
      if (C.stateNode.current.memoizedState.isDehydrated) return C.tag === 3 ? C.stateNode.containerInfo : null;
      g = null;
    } else C !== g && (g = null);
    return Bc = g, null;
  }
  function kC(g) {
    switch (g) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Yn()) {
          case Fn:
            return 1;
          case _n:
            return 4;
          case Xn:
          case or:
            return 16;
          case Ei:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Bl = null, kI = null, ie = null;
  function De() {
    if (ie) return ie;
    var g, C = kI, B = C.length, N, F = "value" in Bl ? Bl.value : Bl.textContent, D = F.length;
    for (g = 0; g < B && C[g] === F[g]; g++) ;
    var se = B - g;
    for (N = 1; N <= se && C[B - N] === F[D - N]; N++) ;
    return ie = F.slice(g, 1 < N ? 1 - N : void 0);
  }
  function bt(g) {
    var C = g.keyCode;
    return "charCode" in g ? (g = g.charCode, g === 0 && C === 13 && (g = 13)) : g = C, g === 10 && (g = 13), 32 <= g || g === 13 ? g : 0;
  }
  function Et() {
    return !0;
  }
  function wn() {
    return !1;
  }
  function ui(g) {
    function C(B, N, F, D, se) {
      this._reactName = B, this._targetInst = F, this.type = N, this.nativeEvent = D, this.target = se, this.currentTarget = null;
      for (var He in g) g.hasOwnProperty(He) && (B = g[He], this[He] = B ? B(D) : D[He]);
      return this.isDefaultPrevented = (D.defaultPrevented != null ? D.defaultPrevented : D.returnValue === !1) ? Et : wn, this.isPropagationStopped = wn, this;
    }
    return be(C.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var B = this.nativeEvent;
      B && (B.preventDefault ? B.preventDefault() : typeof B.returnValue != "unknown" && (B.returnValue = !1), this.isDefaultPrevented = Et);
    }, stopPropagation: function() {
      var B = this.nativeEvent;
      B && (B.stopPropagation ? B.stopPropagation() : typeof B.cancelBubble != "unknown" && (B.cancelBubble = !0), this.isPropagationStopped = Et);
    }, persist: function() {
    }, isPersistent: Et }), C;
  }
  var ni = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(g) {
    return g.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Yi = ui(ni), rr = be({}, ni, { view: 0, detail: 0 }), Yr = ui(rr), hr, vr, br, Ia = be({}, rr, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ug, button: 0, buttons: 0, relatedTarget: function(g) {
    return g.relatedTarget === void 0 ? g.fromElement === g.srcElement ? g.toElement : g.fromElement : g.relatedTarget;
  }, movementX: function(g) {
    return "movementX" in g ? g.movementX : (g !== br && (br && g.type === "mousemove" ? (hr = g.screenX - br.screenX, vr = g.screenY - br.screenY) : vr = hr = 0, br = g), hr);
  }, movementY: function(g) {
    return "movementY" in g ? g.movementY : vr;
  } }), Fr = ui(Ia), Qo = be({}, Ia, { dataTransfer: 0 }), Tl = ui(Qo), qg = be({}, rr, { relatedTarget: 0 }), DI = ui(qg), Iu = be({}, ni, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), UI = ui(Iu), OI = be({}, ni, { clipboardData: function(g) {
    return "clipboardData" in g ? g.clipboardData : window.clipboardData;
  } }), DC = ui(OI), UC = be({}, ni, { data: 0 }), fp = ui(UC), pp = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, kh = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Dh = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Dd(g) {
    var C = this.nativeEvent;
    return C.getModifierState ? C.getModifierState(g) : (g = Dh[g]) ? !!C[g] : !1;
  }
  function ug() {
    return Dd;
  }
  var Uh = be({}, rr, { key: function(g) {
    if (g.key) {
      var C = pp[g.key] || g.key;
      if (C !== "Unidentified") return C;
    }
    return g.type === "keypress" ? (g = bt(g), g === 13 ? "Enter" : String.fromCharCode(g)) : g.type === "keydown" || g.type === "keyup" ? kh[g.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ug, charCode: function(g) {
    return g.type === "keypress" ? bt(g) : 0;
  }, keyCode: function(g) {
    return g.type === "keydown" || g.type === "keyup" ? g.keyCode : 0;
  }, which: function(g) {
    return g.type === "keypress" ? bt(g) : g.type === "keydown" || g.type === "keyup" ? g.keyCode : 0;
  } }), Cu = ui(Uh), hu = be({}, Ia, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), ol = ui(hu), cg = be({}, rr, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ug }), Du = ui(cg), gg = be({}, ni, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Sc = ui(gg), mp = be({}, Ia, {
    deltaX: function(g) {
      return "deltaX" in g ? g.deltaX : "wheelDeltaX" in g ? -g.wheelDeltaX : 0;
    },
    deltaY: function(g) {
      return "deltaY" in g ? g.deltaY : "wheelDeltaY" in g ? -g.wheelDeltaY : "wheelDelta" in g ? -g.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Es = ui(mp), Uu = [9, 13, 27, 32], Kr = u && "CompositionEvent" in window, _a = null;
  u && "documentMode" in document && (_a = document.documentMode);
  var ca = u && "TextEvent" in window && !_a, Zc = u && (!Kr || _a && 8 < _a && 11 >= _a), _l = " ", $g = !1;
  function Oh(g, C) {
    switch (g) {
      case "keyup":
        return Uu.indexOf(C.keyCode) !== -1;
      case "keydown":
        return C.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function OC(g) {
    return g = g.detail, typeof g == "object" && "data" in g ? g.data : null;
  }
  var Ou = !1;
  function Ap(g, C) {
    switch (g) {
      case "compositionend":
        return OC(C);
      case "keypress":
        return C.which !== 32 ? null : ($g = !0, _l);
      case "textInput":
        return g = C.data, g === _l && $g ? null : g;
      default:
        return null;
    }
  }
  function PI(g, C) {
    if (Ou) return g === "compositionend" || !Kr && Oh(g, C) ? (g = De(), ie = kI = Bl = null, Ou = !1, g) : null;
    switch (g) {
      case "paste":
        return null;
      case "keypress":
        if (!(C.ctrlKey || C.altKey || C.metaKey) || C.ctrlKey && C.altKey) {
          if (C.char && 1 < C.char.length) return C.char;
          if (C.which) return String.fromCharCode(C.which);
        }
        return null;
      case "compositionend":
        return Zc && C.locale !== "ko" ? null : C.data;
      default:
        return null;
    }
  }
  var JI = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function PC(g) {
    var C = g && g.nodeName && g.nodeName.toLowerCase();
    return C === "input" ? !!JI[g.type] : C === "textarea";
  }
  function ed(g, C, B, N) {
    fi(N), C = id(C, "onChange"), 0 < C.length && (B = new Yi("onChange", "change", null, B, N), g.push({ event: B, listeners: C }));
  }
  var wc = null, zl = null;
  function JC(g) {
    nd(g, 0);
  }
  function fs(g) {
    var C = wa(g);
    if (he(C)) return g;
  }
  function Ph(g, C) {
    if (g === "change") return C;
  }
  var dg = !1;
  if (u) {
    var sl;
    if (u) {
      var Ig = "oninput" in document;
      if (!Ig) {
        var Ud = document.createElement("div");
        Ud.setAttribute("oninput", "return;"), Ig = typeof Ud.oninput == "function";
      }
      sl = Ig;
    } else sl = !1;
    dg = sl && (!document.documentMode || 9 < document.documentMode);
  }
  function Kl() {
    wc && (wc.detachEvent("onpropertychange", QC), zl = wc = null);
  }
  function QC(g) {
    if (g.propertyName === "value" && fs(zl)) {
      var C = [];
      ed(C, zl, g, lt(g)), Cr(JC, C);
    }
  }
  function Od(g, C, B) {
    g === "focusin" ? (Kl(), wc = C, zl = B, wc.attachEvent("onpropertychange", QC)) : g === "focusout" && Kl();
  }
  function vp(g) {
    if (g === "selectionchange" || g === "keyup" || g === "keydown") return fs(zl);
  }
  function QI(g, C) {
    if (g === "click") return fs(C);
  }
  function Dr(g, C) {
    if (g === "input" || g === "change") return fs(C);
  }
  function Pd(g, C) {
    return g === C && (g !== 0 || 1 / g === 1 / C) || g !== g && C !== C;
  }
  var Ts = typeof Object.is == "function" ? Object.is : Pd;
  function _s(g, C) {
    if (Ts(g, C)) return !0;
    if (typeof g != "object" || g === null || typeof C != "object" || C === null) return !1;
    var B = Object.keys(g), N = Object.keys(C);
    if (B.length !== N.length) return !1;
    for (N = 0; N < B.length; N++) {
      var F = B[N];
      if (!I.call(C, F) || !Ts(g[F], C[F])) return !1;
    }
    return !0;
  }
  function fu(g) {
    for (; g && g.firstChild; ) g = g.firstChild;
    return g;
  }
  function va(g, C) {
    var B = fu(g);
    g = 0;
    for (var N; B; ) {
      if (B.nodeType === 3) {
        if (N = g + B.textContent.length, g <= C && N >= C) return { node: B, offset: C - g };
        g = N;
      }
      e: {
        for (; B; ) {
          if (B.nextSibling) {
            B = B.nextSibling;
            break e;
          }
          B = B.parentNode;
        }
        B = void 0;
      }
      B = fu(B);
    }
  }
  function ao(g, C) {
    return g && C ? g === C ? !0 : g && g.nodeType === 3 ? !1 : C && C.nodeType === 3 ? ao(g, C.parentNode) : "contains" in g ? g.contains(C) : g.compareDocumentPosition ? !!(g.compareDocumentPosition(C) & 16) : !1 : !1;
  }
  function za() {
    for (var g = window, C = Lt(); C instanceof g.HTMLIFrameElement; ) {
      try {
        var B = typeof C.contentWindow.location.href == "string";
      } catch {
        B = !1;
      }
      if (B) g = C.contentWindow;
      else break;
      C = Lt(g.document);
    }
    return C;
  }
  function Qr(g) {
    var C = g && g.nodeName && g.nodeName.toLowerCase();
    return C && (C === "input" && (g.type === "text" || g.type === "search" || g.type === "tel" || g.type === "url" || g.type === "password") || C === "textarea" || g.contentEditable === "true");
  }
  function jr(g) {
    var C = za(), B = g.focusedElem, N = g.selectionRange;
    if (C !== B && B && B.ownerDocument && ao(B.ownerDocument.documentElement, B)) {
      if (N !== null && Qr(B)) {
        if (C = N.start, g = N.end, g === void 0 && (g = C), "selectionStart" in B) B.selectionStart = C, B.selectionEnd = Math.min(g, B.value.length);
        else if (g = (C = B.ownerDocument || document) && C.defaultView || window, g.getSelection) {
          g = g.getSelection();
          var F = B.textContent.length, D = Math.min(N.start, F);
          N = N.end === void 0 ? D : Math.min(N.end, F), !g.extend && D > N && (F = N, N = D, D = F), F = va(B, D);
          var se = va(
            B,
            N
          );
          F && se && (g.rangeCount !== 1 || g.anchorNode !== F.node || g.anchorOffset !== F.offset || g.focusNode !== se.node || g.focusOffset !== se.offset) && (C = C.createRange(), C.setStart(F.node, F.offset), g.removeAllRanges(), D > N ? (g.addRange(C), g.extend(se.node, se.offset)) : (C.setEnd(se.node, se.offset), g.addRange(C)));
        }
      }
      for (C = [], g = B; g = g.parentNode; ) g.nodeType === 1 && C.push({ element: g, left: g.scrollLeft, top: g.scrollTop });
      for (typeof B.focus == "function" && B.focus(), B = 0; B < C.length; B++) g = C[B], g.element.scrollLeft = g.left, g.element.scrollTop = g.top;
    }
  }
  var zs = u && "documentMode" in document && 11 >= document.documentMode, Ll = null, ps = null, jI = null, oo = !1;
  function Jd(g, C, B) {
    var N = B.window === B ? B.document : B.nodeType === 9 ? B : B.ownerDocument;
    oo || Ll == null || Ll !== Lt(N) || (N = Ll, "selectionStart" in N && Qr(N) ? N = { start: N.selectionStart, end: N.selectionEnd } : (N = (N.ownerDocument && N.ownerDocument.defaultView || window).getSelection(), N = { anchorNode: N.anchorNode, anchorOffset: N.anchorOffset, focusNode: N.focusNode, focusOffset: N.focusOffset }), jI && _s(jI, N) || (jI = N, N = id(ps, "onSelect"), 0 < N.length && (C = new Yi("onSelect", "select", null, C, B), g.push({ event: C, listeners: N }), C.target = Ll)));
  }
  function ll(g, C) {
    var B = {};
    return B[g.toLowerCase()] = C.toLowerCase(), B["Webkit" + g] = "webkit" + C, B["Moz" + g] = "moz" + C, B;
  }
  var Pu = { animationend: ll("Animation", "AnimationEnd"), animationiteration: ll("Animation", "AnimationIteration"), animationstart: ll("Animation", "AnimationStart"), transitionend: ll("Transition", "TransitionEnd") }, Sl = {}, pu = {};
  u && (pu = document.createElement("div").style, "AnimationEvent" in window || (delete Pu.animationend.animation, delete Pu.animationiteration.animation, delete Pu.animationstart.animation), "TransitionEvent" in window || delete Pu.transitionend.transition);
  function mu(g) {
    if (Sl[g]) return Sl[g];
    if (!Pu[g]) return g;
    var C = Pu[g], B;
    for (B in C) if (C.hasOwnProperty(B) && B in pu) return Sl[g] = C[B];
    return g;
  }
  var fo = mu("animationend"), Qd = mu("animationiteration"), yp = mu("animationstart"), td = mu("transitionend"), Jh = /* @__PURE__ */ new Map(), Oi = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Rr(g, C) {
    Jh.set(g, C), o(C, [g]);
  }
  for (var xr = 0; xr < Oi.length; xr++) {
    var Ma = Oi[xr], as = Ma.toLowerCase(), bp = Ma[0].toUpperCase() + Ma.slice(1);
    Rr(as, "on" + bp);
  }
  Rr(fo, "onAnimationEnd"), Rr(Qd, "onAnimationIteration"), Rr(yp, "onAnimationStart"), Rr("dblclick", "onDoubleClick"), Rr("focusin", "onFocus"), Rr("focusout", "onBlur"), Rr(td, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), o("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), o("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), o("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Au = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Qh = new Set("cancel close invalid load scroll toggle".split(" ").concat(Au));
  function jh(g, C, B) {
    var N = g.type || "unknown-event";
    g.currentTarget = B, ut(N, C, void 0, g), g.currentTarget = null;
  }
  function nd(g, C) {
    C = (C & 4) !== 0;
    for (var B = 0; B < g.length; B++) {
      var N = g[B], F = N.event;
      N = N.listeners;
      e: {
        var D = void 0;
        if (C) for (var se = N.length - 1; 0 <= se; se--) {
          var He = N[se], Qe = He.instance, xt = He.currentTarget;
          if (He = He.listener, Qe !== D && F.isPropagationStopped()) break e;
          jh(F, He, xt), D = Qe;
        }
        else for (se = 0; se < N.length; se++) {
          if (He = N[se], Qe = He.instance, xt = He.currentTarget, He = He.listener, Qe !== D && F.isPropagationStopped()) break e;
          jh(F, He, xt), D = Qe;
        }
      }
    }
    if (qe) throw g = gt, qe = !1, gt = null, g;
  }
  function Dt(g, C) {
    var B = C[pg];
    B === void 0 && (B = C[pg] = /* @__PURE__ */ new Set());
    var N = g + "__bubble";
    B.has(N) || (vu(C, g, 2, !1), B.add(N));
  }
  function so(g, C, B) {
    var N = 0;
    C && (N |= 4), vu(B, g, N, C);
  }
  var nr = "_reactListening" + Math.random().toString(36).slice(2);
  function Ks(g) {
    if (!g[nr]) {
      g[nr] = !0, n.forEach(function(B) {
        B !== "selectionchange" && (Qh.has(B) || so(B, !1, g), so(B, !0, g));
      });
      var C = g.nodeType === 9 ? g : g.ownerDocument;
      C === null || C[nr] || (C[nr] = !0, so("selectionchange", !1, C));
    }
  }
  function vu(g, C, B, N) {
    switch (kC(C)) {
      case 1:
        var F = du;
        break;
      case 4:
        F = jg;
        break;
      default:
        F = ku;
    }
    B = F.bind(null, C, B, g), F = void 0, !zr || C !== "touchstart" && C !== "touchmove" && C !== "wheel" || (F = !0), N ? F !== void 0 ? g.addEventListener(C, B, { capture: !0, passive: F }) : g.addEventListener(C, B, !0) : F !== void 0 ? g.addEventListener(C, B, { passive: F }) : g.addEventListener(C, B, !1);
  }
  function Rc(g, C, B, N, F) {
    var D = N;
    if (!(C & 1) && !(C & 2) && N !== null) e: for (; ; ) {
      if (N === null) return;
      var se = N.tag;
      if (se === 3 || se === 4) {
        var He = N.stateNode.containerInfo;
        if (He === F || He.nodeType === 8 && He.parentNode === F) break;
        if (se === 4) for (se = N.return; se !== null; ) {
          var Qe = se.tag;
          if ((Qe === 3 || Qe === 4) && (Qe = se.stateNode.containerInfo, Qe === F || Qe.nodeType === 8 && Qe.parentNode === F)) return;
          se = se.return;
        }
        for (; He !== null; ) {
          if (se = Ju(He), se === null) return;
          if (Qe = se.tag, Qe === 5 || Qe === 6) {
            N = D = se;
            continue e;
          }
          He = He.parentNode;
        }
      }
      N = N.return;
    }
    Cr(function() {
      var xt = D, Cn = lt(B), Gn = [];
      e: {
        var pn = Jh.get(g);
        if (pn !== void 0) {
          var Dn = Yi, ei = g;
          switch (g) {
            case "keypress":
              if (bt(B) === 0) break e;
            case "keydown":
            case "keyup":
              Dn = Cu;
              break;
            case "focusin":
              ei = "focus", Dn = DI;
              break;
            case "focusout":
              ei = "blur", Dn = DI;
              break;
            case "beforeblur":
            case "afterblur":
              Dn = DI;
              break;
            case "click":
              if (B.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Dn = Fr;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Dn = Tl;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Dn = Du;
              break;
            case fo:
            case Qd:
            case yp:
              Dn = UI;
              break;
            case td:
              Dn = Sc;
              break;
            case "scroll":
              Dn = Yr;
              break;
            case "wheel":
              Dn = Es;
              break;
            case "copy":
            case "cut":
            case "paste":
              Dn = DC;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Dn = ol;
          }
          var bi = (C & 4) !== 0, Xo = !bi && g === "scroll", dt = bi ? pn !== null ? pn + "Capture" : null : pn;
          bi = [];
          for (var tt = xt, yt; tt !== null; ) {
            yt = tt;
            var Mn = yt.stateNode;
            if (yt.tag === 5 && Mn !== null && (yt = Mn, dt !== null && (Mn = Sa(tt, dt), Mn != null && bi.push(ul(tt, Mn, yt)))), Xo) break;
            tt = tt.return;
          }
          0 < bi.length && (pn = new Dn(pn, ei, null, B, Cn), Gn.push({ event: pn, listeners: bi }));
        }
      }
      if (!(C & 7)) {
        e: {
          if (pn = g === "mouseover" || g === "pointerover", Dn = g === "mouseout" || g === "pointerout", pn && B !== Re && (ei = B.relatedTarget || B.fromElement) && (Ju(ei) || ei[ms])) break e;
          if ((Dn || pn) && (pn = Cn.window === Cn ? Cn : (pn = Cn.ownerDocument) ? pn.defaultView || pn.parentWindow : window, Dn ? (ei = B.relatedTarget || B.toElement, Dn = xt, ei = ei ? Ju(ei) : null, ei !== null && (Xo = Bt(ei), ei !== Xo || ei.tag !== 5 && ei.tag !== 6) && (ei = null)) : (Dn = null, ei = xt), Dn !== ei)) {
            if (bi = Fr, Mn = "onMouseLeave", dt = "onMouseEnter", tt = "mouse", (g === "pointerout" || g === "pointerover") && (bi = ol, Mn = "onPointerLeave", dt = "onPointerEnter", tt = "pointer"), Xo = Dn == null ? pn : wa(Dn), yt = ei == null ? pn : wa(ei), pn = new bi(Mn, tt + "leave", Dn, B, Cn), pn.target = Xo, pn.relatedTarget = yt, Mn = null, Ju(Cn) === xt && (bi = new bi(dt, tt + "enter", ei, B, Cn), bi.target = yt, bi.relatedTarget = Xo, Mn = bi), Xo = Mn, Dn && ei) t: {
              for (bi = Dn, dt = ei, tt = 0, yt = bi; yt; yt = kl(yt)) tt++;
              for (yt = 0, Mn = dt; Mn; Mn = kl(Mn)) yt++;
              for (; 0 < tt - yt; ) bi = kl(bi), tt--;
              for (; 0 < yt - tt; ) dt = kl(dt), yt--;
              for (; tt--; ) {
                if (bi === dt || dt !== null && bi === dt.alternate) break t;
                bi = kl(bi), dt = kl(dt);
              }
              bi = null;
            }
            else bi = null;
            Dn !== null && jd(Gn, pn, Dn, bi, !1), ei !== null && Xo !== null && jd(Gn, Xo, ei, bi, !0);
          }
        }
        e: {
          if (pn = xt ? wa(xt) : window, Dn = pn.nodeName && pn.nodeName.toLowerCase(), Dn === "select" || Dn === "input" && pn.type === "file") var Vi = Ph;
          else if (PC(pn)) if (dg) Vi = Dr;
          else {
            Vi = vp;
            var Ti = Od;
          }
          else (Dn = pn.nodeName) && Dn.toLowerCase() === "input" && (pn.type === "checkbox" || pn.type === "radio") && (Vi = QI);
          if (Vi && (Vi = Vi(g, xt))) {
            ed(Gn, Vi, B, Cn);
            break e;
          }
          Ti && Ti(g, pn, xt), g === "focusout" && (Ti = pn._wrapperState) && Ti.controlled && pn.type === "number" && Bn(pn, "number", pn.value);
        }
        switch (Ti = xt ? wa(xt) : window, g) {
          case "focusin":
            (PC(Ti) || Ti.contentEditable === "true") && (Ll = Ti, ps = xt, jI = null);
            break;
          case "focusout":
            jI = ps = Ll = null;
            break;
          case "mousedown":
            oo = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            oo = !1, Jd(Gn, B, Cn);
            break;
          case "selectionchange":
            if (zs) break;
          case "keydown":
          case "keyup":
            Jd(Gn, B, Cn);
        }
        var Fi;
        if (Kr) e: {
          switch (g) {
            case "compositionstart":
              var Ri = "onCompositionStart";
              break e;
            case "compositionend":
              Ri = "onCompositionEnd";
              break e;
            case "compositionupdate":
              Ri = "onCompositionUpdate";
              break e;
          }
          Ri = void 0;
        }
        else Ou ? Oh(g, B) && (Ri = "onCompositionEnd") : g === "keydown" && B.keyCode === 229 && (Ri = "onCompositionStart");
        Ri && (Zc && B.locale !== "ko" && (Ou || Ri !== "onCompositionStart" ? Ri === "onCompositionEnd" && Ou && (Fi = De()) : (Bl = Cn, kI = "value" in Bl ? Bl.value : Bl.textContent, Ou = !0)), Ti = id(xt, Ri), 0 < Ti.length && (Ri = new fp(Ri, g, null, B, Cn), Gn.push({ event: Ri, listeners: Ti }), Fi ? Ri.data = Fi : (Fi = OC(B), Fi !== null && (Ri.data = Fi)))), (Fi = ca ? Ap(g, B) : PI(g, B)) && (xt = id(xt, "onBeforeInput"), 0 < xt.length && (Cn = new fp("onBeforeInput", "beforeinput", null, B, Cn), Gn.push({ event: Cn, listeners: xt }), Cn.data = Fi));
      }
      nd(Gn, C);
    });
  }
  function ul(g, C, B) {
    return { instance: g, listener: C, currentTarget: B };
  }
  function id(g, C) {
    for (var B = C + "Capture", N = []; g !== null; ) {
      var F = g, D = F.stateNode;
      F.tag === 5 && D !== null && (F = D, D = Sa(g, B), D != null && N.unshift(ul(g, D, F)), D = Sa(g, C), D != null && N.push(ul(g, D, F))), g = g.return;
    }
    return N;
  }
  function kl(g) {
    if (g === null) return null;
    do
      g = g.return;
    while (g && g.tag !== 5);
    return g || null;
  }
  function jd(g, C, B, N, F) {
    for (var D = C._reactName, se = []; B !== null && B !== N; ) {
      var He = B, Qe = He.alternate, xt = He.stateNode;
      if (Qe !== null && Qe === N) break;
      He.tag === 5 && xt !== null && (He = xt, F ? (Qe = Sa(B, D), Qe != null && se.unshift(ul(B, Qe, He))) : F || (Qe = Sa(B, D), Qe != null && se.push(ul(B, Qe, He)))), B = B.return;
    }
    se.length !== 0 && g.push({ event: C, listeners: se });
  }
  var qh = /\r\n?/g, qI = /\u0000|\uFFFD/g;
  function jC(g) {
    return (typeof g == "string" ? g : "" + g).replace(qh, `
`).replace(qI, "");
  }
  function rd(g, C, B) {
    if (C = jC(C), jC(g) !== C && B) throw Error(t(425));
  }
  function qd() {
  }
  var ad = null, qC = null;
  function Cg(g, C) {
    return g === "textarea" || g === "noscript" || typeof C.children == "string" || typeof C.children == "number" || typeof C.dangerouslySetInnerHTML == "object" && C.dangerouslySetInnerHTML !== null && C.dangerouslySetInnerHTML.__html != null;
  }
  var $d = typeof setTimeout == "function" ? setTimeout : void 0, hg = typeof clearTimeout == "function" ? clearTimeout : void 0, eI = typeof Promise == "function" ? Promise : void 0, $h = typeof queueMicrotask == "function" ? queueMicrotask : typeof eI < "u" ? function(g) {
    return eI.resolve(null).then(g).catch($I);
  } : $d;
  function $I(g) {
    setTimeout(function() {
      throw g;
    });
  }
  function eC(g, C) {
    var B = C, N = 0;
    do {
      var F = B.nextSibling;
      if (g.removeChild(B), F && F.nodeType === 8) if (B = F.data, B === "/$") {
        if (N === 0) {
          g.removeChild(F), gu(C);
          return;
        }
        N--;
      } else B !== "$" && B !== "$?" && B !== "$!" || N++;
      B = F;
    } while (B);
    gu(C);
  }
  function Ls(g) {
    for (; g != null; g = g.nextSibling) {
      var C = g.nodeType;
      if (C === 1 || C === 3) break;
      if (C === 8) {
        if (C = g.data, C === "$" || C === "$!" || C === "$?") break;
        if (C === "/$") return null;
      }
    }
    return g;
  }
  function fg(g) {
    g = g.previousSibling;
    for (var C = 0; g; ) {
      if (g.nodeType === 8) {
        var B = g.data;
        if (B === "$" || B === "$!" || B === "$?") {
          if (C === 0) return g;
          C--;
        } else B === "/$" && C++;
      }
      g = g.previousSibling;
    }
    return null;
  }
  var cl = Math.random().toString(36).slice(2), lo = "__reactFiber$" + cl, od = "__reactProps$" + cl, ms = "__reactContainer$" + cl, pg = "__reactEvents$" + cl, $C = "__reactListeners$" + cl, sd = "__reactHandles$" + cl;
  function Ju(g) {
    var C = g[lo];
    if (C) return C;
    for (var B = g.parentNode; B; ) {
      if (C = B[ms] || B[lo]) {
        if (B = C.alternate, C.child !== null || B !== null && B.child !== null) for (g = fg(g); g !== null; ) {
          if (B = g[lo]) return B;
          g = fg(g);
        }
        return C;
      }
      g = B, B = g.parentNode;
    }
    return null;
  }
  function os(g) {
    return g = g[lo] || g[ms], !g || g.tag !== 5 && g.tag !== 6 && g.tag !== 13 && g.tag !== 3 ? null : g;
  }
  function wa(g) {
    if (g.tag === 5 || g.tag === 6) return g.stateNode;
    throw Error(t(33));
  }
  function ks(g) {
    return g[od] || null;
  }
  var Hi = [], Pi = -1;
  function ar(g) {
    return { current: g };
  }
  function Ci(g) {
    0 > Pi || (g.current = Hi[Pi], Hi[Pi] = null, Pi--);
  }
  function Gr(g, C) {
    Pi++, Hi[Pi] = g.current, g.current = C;
  }
  var Ds = {}, jo = ar(Ds), Qi = ar(!1), As = Ds;
  function Zl(g, C) {
    var B = g.type.contextTypes;
    if (!B) return Ds;
    var N = g.stateNode;
    if (N && N.__reactInternalMemoizedUnmaskedChildContext === C) return N.__reactInternalMemoizedMaskedChildContext;
    var F = {}, D;
    for (D in B) F[D] = C[D];
    return N && (g = g.stateNode, g.__reactInternalMemoizedUnmaskedChildContext = C, g.__reactInternalMemoizedMaskedChildContext = F), F;
  }
  function Qa(g) {
    return g = g.childContextTypes, g != null;
  }
  function gl() {
    Ci(Qi), Ci(jo);
  }
  function Dl(g, C, B) {
    if (jo.current !== Ds) throw Error(t(168));
    Gr(jo, C), Gr(Qi, B);
  }
  function yu(g, C, B) {
    var N = g.stateNode;
    if (C = C.childContextTypes, typeof N.getChildContext != "function") return B;
    N = N.getChildContext();
    for (var F in N) if (!(F in C)) throw Error(t(108, St(g) || "Unknown", F));
    return be({}, B, N);
  }
  function xc(g) {
    return g = (g = g.stateNode) && g.__reactInternalMemoizedMergedChildContext || Ds, As = jo.current, Gr(jo, g), Gr(Qi, Qi.current), !0;
  }
  function tC(g, C, B) {
    var N = g.stateNode;
    if (!N) throw Error(t(169));
    B ? (g = yu(g, C, As), N.__reactInternalMemoizedMergedChildContext = g, Ci(Qi), Ci(jo), Gr(jo, g)) : Ci(Qi), Gr(Qi, B);
  }
  var Qu = null, Wc = !1, ss = !1;
  function tI(g) {
    Qu === null ? Qu = [g] : Qu.push(g);
  }
  function mg(g) {
    Wc = !0, tI(g);
  }
  function Us() {
    if (!ss && Qu !== null) {
      ss = !0;
      var g = 0, C = cn;
      try {
        var B = Qu;
        for (cn = 1; g < B.length; g++) {
          var N = B[g];
          do
            N = N(!0);
          while (N !== null);
        }
        Qu = null, Wc = !1;
      } catch (F) {
        throw Qu !== null && (Qu = Qu.slice(g + 1)), Oe(Fn, Us), F;
      } finally {
        cn = C, ss = !1;
      }
    }
    return null;
  }
  var qo = [], ls = 0, ja = null, bu = 0, Wi = [], uo = 0, Gu = null, Nn = 1, Do = "";
  function ju(g, C) {
    qo[ls++] = bu, qo[ls++] = ja, ja = g, bu = C;
  }
  function Ul(g, C, B) {
    Wi[uo++] = Nn, Wi[uo++] = Do, Wi[uo++] = Gu, Gu = g;
    var N = Nn;
    g = Do;
    var F = 32 - ue(N) - 1;
    N &= ~(1 << F), B += 1;
    var D = 32 - ue(C) + F;
    if (30 < D) {
      var se = F - F % 5;
      D = (N & (1 << se) - 1).toString(32), N >>= se, F -= se, Nn = 1 << 32 - ue(C) + F | B << F | N, Do = D + g;
    } else Nn = 1 << D | B << F | N, Do = g;
  }
  function ef(g) {
    g.return !== null && (ju(g, 1), Ul(g, 1, 0));
  }
  function qu(g) {
    for (; g === ja; ) ja = qo[--ls], qo[ls] = null, bu = qo[--ls], qo[ls] = null;
    for (; g === Gu; ) Gu = Wi[--uo], Wi[uo] = null, Do = Wi[--uo], Wi[uo] = null, Nn = Wi[--uo], Wi[uo] = null;
  }
  var vs = null, ys = null, Ha = !1, wl = null;
  function eh(g, C) {
    var B = Mo(5, null, null, 0);
    B.elementType = "DELETED", B.stateNode = C, B.return = g, C = g.deletions, C === null ? (g.deletions = [B], g.flags |= 16) : C.push(B);
  }
  function Ol(g, C) {
    switch (g.tag) {
      case 5:
        var B = g.type;
        return C = C.nodeType !== 1 || B.toLowerCase() !== C.nodeName.toLowerCase() ? null : C, C !== null ? (g.stateNode = C, vs = g, ys = Ls(C.firstChild), !0) : !1;
      case 6:
        return C = g.pendingProps === "" || C.nodeType !== 3 ? null : C, C !== null ? (g.stateNode = C, vs = g, ys = null, !0) : !1;
      case 13:
        return C = C.nodeType !== 8 ? null : C, C !== null ? (B = Gu !== null ? { id: Nn, overflow: Do } : null, g.memoizedState = { dehydrated: C, treeContext: B, retryLane: 1073741824 }, B = Mo(18, null, null, 0), B.stateNode = C, B.return = g, g.child = B, vs = g, ys = null, !0) : !1;
      default:
        return !1;
    }
  }
  function ld(g) {
    return (g.mode & 1) !== 0 && (g.flags & 128) === 0;
  }
  function Ag(g) {
    if (Ha) {
      var C = ys;
      if (C) {
        var B = C;
        if (!Ol(g, C)) {
          if (ld(g)) throw Error(t(418));
          C = Ls(B.nextSibling);
          var N = vs;
          C && Ol(g, C) ? eh(N, B) : (g.flags = g.flags & -4097 | 2, Ha = !1, vs = g);
        }
      } else {
        if (ld(g)) throw Error(t(418));
        g.flags = g.flags & -4097 | 2, Ha = !1, vs = g;
      }
    }
  }
  function nI(g) {
    for (g = g.return; g !== null && g.tag !== 5 && g.tag !== 3 && g.tag !== 13; ) g = g.return;
    vs = g;
  }
  function Vc(g) {
    if (g !== vs) return !1;
    if (!Ha) return nI(g), Ha = !0, !1;
    var C;
    if ((C = g.tag !== 3) && !(C = g.tag !== 5) && (C = g.type, C = C !== "head" && C !== "body" && !Cg(g.type, g.memoizedProps)), C && (C = ys)) {
      if (ld(g)) throw Pl(), Error(t(418));
      for (; C; ) eh(g, C), C = Ls(C.nextSibling);
    }
    if (nI(g), g.tag === 13) {
      if (g = g.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(t(317));
      e: {
        for (g = g.nextSibling, C = 0; g; ) {
          if (g.nodeType === 8) {
            var B = g.data;
            if (B === "/$") {
              if (C === 0) {
                ys = Ls(g.nextSibling);
                break e;
              }
              C--;
            } else B !== "$" && B !== "$!" && B !== "$?" || C++;
          }
          g = g.nextSibling;
        }
        ys = null;
      }
    } else ys = vs ? Ls(g.stateNode.nextSibling) : null;
    return !0;
  }
  function Pl() {
    for (var g = ys; g; ) g = Ls(g.nextSibling);
  }
  function Ka() {
    ys = vs = null, Ha = !1;
  }
  function co(g) {
    wl === null ? wl = [g] : wl.push(g);
  }
  var lv = _.ReactCurrentBatchConfig;
  function ud(g, C, B) {
    if (g = B.ref, g !== null && typeof g != "function" && typeof g != "object") {
      if (B._owner) {
        if (B = B._owner, B) {
          if (B.tag !== 1) throw Error(t(309));
          var N = B.stateNode;
        }
        if (!N) throw Error(t(147, g));
        var F = N, D = "" + g;
        return C !== null && C.ref !== null && typeof C.ref == "function" && C.ref._stringRef === D ? C.ref : (C = function(se) {
          var He = F.refs;
          se === null ? delete He[D] : He[D] = se;
        }, C._stringRef = D, C);
      }
      if (typeof g != "string") throw Error(t(284));
      if (!B._owner) throw Error(t(290, g));
    }
    return g;
  }
  function cd(g, C) {
    throw g = Object.prototype.toString.call(C), Error(t(31, g === "[object Object]" ? "object with keys {" + Object.keys(C).join(", ") + "}" : g));
  }
  function Nc(g) {
    var C = g._init;
    return C(g._payload);
  }
  function tf(g) {
    function C(dt, tt) {
      if (g) {
        var yt = dt.deletions;
        yt === null ? (dt.deletions = [tt], dt.flags |= 16) : yt.push(tt);
      }
    }
    function B(dt, tt) {
      if (!g) return null;
      for (; tt !== null; ) C(dt, tt), tt = tt.sibling;
      return null;
    }
    function N(dt, tt) {
      for (dt = /* @__PURE__ */ new Map(); tt !== null; ) tt.key !== null ? dt.set(tt.key, tt) : dt.set(tt.index, tt), tt = tt.sibling;
      return dt;
    }
    function F(dt, tt) {
      return dt = md(dt, tt), dt.index = 0, dt.sibling = null, dt;
    }
    function D(dt, tt, yt) {
      return dt.index = yt, g ? (yt = dt.alternate, yt !== null ? (yt = yt.index, yt < tt ? (dt.flags |= 2, tt) : yt) : (dt.flags |= 2, tt)) : (dt.flags |= 1048576, tt);
    }
    function se(dt) {
      return g && dt.alternate === null && (dt.flags |= 2), dt;
    }
    function He(dt, tt, yt, Mn) {
      return tt === null || tt.tag !== 6 ? (tt = yv(yt, dt.mode, Mn), tt.return = dt, tt) : (tt = F(tt, yt), tt.return = dt, tt);
    }
    function Qe(dt, tt, yt, Mn) {
      var Vi = yt.type;
      return Vi === q ? Cn(dt, tt, yt.props.children, Mn, yt.key) : tt !== null && (tt.elementType === Vi || typeof Vi == "object" && Vi !== null && Vi.$$typeof === Ke && Nc(Vi) === tt.type) ? (Mn = F(tt, yt.props), Mn.ref = ud(dt, tt, yt), Mn.return = dt, Mn) : (Mn = Pm(yt.type, yt.key, yt.props, null, dt.mode, Mn), Mn.ref = ud(dt, tt, yt), Mn.return = dt, Mn);
    }
    function xt(dt, tt, yt, Mn) {
      return tt === null || tt.tag !== 4 || tt.stateNode.containerInfo !== yt.containerInfo || tt.stateNode.implementation !== yt.implementation ? (tt = ch(yt, dt.mode, Mn), tt.return = dt, tt) : (tt = F(tt, yt.children || []), tt.return = dt, tt);
    }
    function Cn(dt, tt, yt, Mn, Vi) {
      return tt === null || tt.tag !== 7 ? (tt = Wu(yt, dt.mode, Mn, Vi), tt.return = dt, tt) : (tt = F(tt, yt), tt.return = dt, tt);
    }
    function Gn(dt, tt, yt) {
      if (typeof tt == "string" && tt !== "" || typeof tt == "number") return tt = yv("" + tt, dt.mode, yt), tt.return = dt, tt;
      if (typeof tt == "object" && tt !== null) {
        switch (tt.$$typeof) {
          case P:
            return yt = Pm(tt.type, tt.key, tt.props, null, dt.mode, yt), yt.ref = ud(dt, null, tt), yt.return = dt, yt;
          case U:
            return tt = ch(tt, dt.mode, yt), tt.return = dt, tt;
          case Ke:
            var Mn = tt._init;
            return Gn(dt, Mn(tt._payload), yt);
        }
        if (Se(tt) || Ce(tt)) return tt = Wu(tt, dt.mode, yt, null), tt.return = dt, tt;
        cd(dt, tt);
      }
      return null;
    }
    function pn(dt, tt, yt, Mn) {
      var Vi = tt !== null ? tt.key : null;
      if (typeof yt == "string" && yt !== "" || typeof yt == "number") return Vi !== null ? null : He(dt, tt, "" + yt, Mn);
      if (typeof yt == "object" && yt !== null) {
        switch (yt.$$typeof) {
          case P:
            return yt.key === Vi ? Qe(dt, tt, yt, Mn) : null;
          case U:
            return yt.key === Vi ? xt(dt, tt, yt, Mn) : null;
          case Ke:
            return Vi = yt._init, pn(
              dt,
              tt,
              Vi(yt._payload),
              Mn
            );
        }
        if (Se(yt) || Ce(yt)) return Vi !== null ? null : Cn(dt, tt, yt, Mn, null);
        cd(dt, yt);
      }
      return null;
    }
    function Dn(dt, tt, yt, Mn, Vi) {
      if (typeof Mn == "string" && Mn !== "" || typeof Mn == "number") return dt = dt.get(yt) || null, He(tt, dt, "" + Mn, Vi);
      if (typeof Mn == "object" && Mn !== null) {
        switch (Mn.$$typeof) {
          case P:
            return dt = dt.get(Mn.key === null ? yt : Mn.key) || null, Qe(tt, dt, Mn, Vi);
          case U:
            return dt = dt.get(Mn.key === null ? yt : Mn.key) || null, xt(tt, dt, Mn, Vi);
          case Ke:
            var Ti = Mn._init;
            return Dn(dt, tt, yt, Ti(Mn._payload), Vi);
        }
        if (Se(Mn) || Ce(Mn)) return dt = dt.get(yt) || null, Cn(tt, dt, Mn, Vi, null);
        cd(tt, Mn);
      }
      return null;
    }
    function ei(dt, tt, yt, Mn) {
      for (var Vi = null, Ti = null, Fi = tt, Ri = tt = 0, Yo = null; Fi !== null && Ri < yt.length; Ri++) {
        Fi.index > Ri ? (Yo = Fi, Fi = null) : Yo = Fi.sibling;
        var ea = pn(dt, Fi, yt[Ri], Mn);
        if (ea === null) {
          Fi === null && (Fi = Yo);
          break;
        }
        g && Fi && ea.alternate === null && C(dt, Fi), tt = D(ea, tt, Ri), Ti === null ? Vi = ea : Ti.sibling = ea, Ti = ea, Fi = Yo;
      }
      if (Ri === yt.length) return B(dt, Fi), Ha && ju(dt, Ri), Vi;
      if (Fi === null) {
        for (; Ri < yt.length; Ri++) Fi = Gn(dt, yt[Ri], Mn), Fi !== null && (tt = D(Fi, tt, Ri), Ti === null ? Vi = Fi : Ti.sibling = Fi, Ti = Fi);
        return Ha && ju(dt, Ri), Vi;
      }
      for (Fi = N(dt, Fi); Ri < yt.length; Ri++) Yo = Dn(Fi, dt, Ri, yt[Ri], Mn), Yo !== null && (g && Yo.alternate !== null && Fi.delete(Yo.key === null ? Ri : Yo.key), tt = D(Yo, tt, Ri), Ti === null ? Vi = Yo : Ti.sibling = Yo, Ti = Yo);
      return g && Fi.forEach(function(vI) {
        return C(dt, vI);
      }), Ha && ju(dt, Ri), Vi;
    }
    function bi(dt, tt, yt, Mn) {
      var Vi = Ce(yt);
      if (typeof Vi != "function") throw Error(t(150));
      if (yt = Vi.call(yt), yt == null) throw Error(t(151));
      for (var Ti = Vi = null, Fi = tt, Ri = tt = 0, Yo = null, ea = yt.next(); Fi !== null && !ea.done; Ri++, ea = yt.next()) {
        Fi.index > Ri ? (Yo = Fi, Fi = null) : Yo = Fi.sibling;
        var vI = pn(dt, Fi, ea.value, Mn);
        if (vI === null) {
          Fi === null && (Fi = Yo);
          break;
        }
        g && Fi && vI.alternate === null && C(dt, Fi), tt = D(vI, tt, Ri), Ti === null ? Vi = vI : Ti.sibling = vI, Ti = vI, Fi = Yo;
      }
      if (ea.done) return B(
        dt,
        Fi
      ), Ha && ju(dt, Ri), Vi;
      if (Fi === null) {
        for (; !ea.done; Ri++, ea = yt.next()) ea = Gn(dt, ea.value, Mn), ea !== null && (tt = D(ea, tt, Ri), Ti === null ? Vi = ea : Ti.sibling = ea, Ti = ea);
        return Ha && ju(dt, Ri), Vi;
      }
      for (Fi = N(dt, Fi); !ea.done; Ri++, ea = yt.next()) ea = Dn(Fi, dt, Ri, ea.value, Mn), ea !== null && (g && ea.alternate !== null && Fi.delete(ea.key === null ? Ri : ea.key), tt = D(ea, tt, Ri), Ti === null ? Vi = ea : Ti.sibling = ea, Ti = ea);
      return g && Fi.forEach(function(Gv) {
        return C(dt, Gv);
      }), Ha && ju(dt, Ri), Vi;
    }
    function Xo(dt, tt, yt, Mn) {
      if (typeof yt == "object" && yt !== null && yt.type === q && yt.key === null && (yt = yt.props.children), typeof yt == "object" && yt !== null) {
        switch (yt.$$typeof) {
          case P:
            e: {
              for (var Vi = yt.key, Ti = tt; Ti !== null; ) {
                if (Ti.key === Vi) {
                  if (Vi = yt.type, Vi === q) {
                    if (Ti.tag === 7) {
                      B(dt, Ti.sibling), tt = F(Ti, yt.props.children), tt.return = dt, dt = tt;
                      break e;
                    }
                  } else if (Ti.elementType === Vi || typeof Vi == "object" && Vi !== null && Vi.$$typeof === Ke && Nc(Vi) === Ti.type) {
                    B(dt, Ti.sibling), tt = F(Ti, yt.props), tt.ref = ud(dt, Ti, yt), tt.return = dt, dt = tt;
                    break e;
                  }
                  B(dt, Ti);
                  break;
                } else C(dt, Ti);
                Ti = Ti.sibling;
              }
              yt.type === q ? (tt = Wu(yt.props.children, dt.mode, Mn, yt.key), tt.return = dt, dt = tt) : (Mn = Pm(yt.type, yt.key, yt.props, null, dt.mode, Mn), Mn.ref = ud(dt, tt, yt), Mn.return = dt, dt = Mn);
            }
            return se(dt);
          case U:
            e: {
              for (Ti = yt.key; tt !== null; ) {
                if (tt.key === Ti) if (tt.tag === 4 && tt.stateNode.containerInfo === yt.containerInfo && tt.stateNode.implementation === yt.implementation) {
                  B(dt, tt.sibling), tt = F(tt, yt.children || []), tt.return = dt, dt = tt;
                  break e;
                } else {
                  B(dt, tt);
                  break;
                }
                else C(dt, tt);
                tt = tt.sibling;
              }
              tt = ch(yt, dt.mode, Mn), tt.return = dt, dt = tt;
            }
            return se(dt);
          case Ke:
            return Ti = yt._init, Xo(dt, tt, Ti(yt._payload), Mn);
        }
        if (Se(yt)) return ei(dt, tt, yt, Mn);
        if (Ce(yt)) return bi(dt, tt, yt, Mn);
        cd(dt, yt);
      }
      return typeof yt == "string" && yt !== "" || typeof yt == "number" ? (yt = "" + yt, tt !== null && tt.tag === 6 ? (B(dt, tt.sibling), tt = F(tt, yt), tt.return = dt, dt = tt) : (B(dt, tt), tt = yv(yt, dt.mode, Mn), tt.return = dt, dt = tt), se(dt)) : B(dt, tt);
    }
    return Xo;
  }
  var vg = tf(!0), th = tf(!1), iI = ar(null), Ca = null, Ra = null, zn = null;
  function Ro() {
    zn = Ra = Ca = null;
  }
  function Os(g) {
    var C = iI.current;
    Ci(iI), g._currentValue = C;
  }
  function nh(g, C, B) {
    for (; g !== null; ) {
      var N = g.alternate;
      if ((g.childLanes & C) !== C ? (g.childLanes |= C, N !== null && (N.childLanes |= C)) : N !== null && (N.childLanes & C) !== C && (N.childLanes |= C), g === B) break;
      g = g.return;
    }
  }
  function gd(g, C) {
    Ca = g, zn = Ra = null, g = g.dependencies, g !== null && g.firstContext !== null && (g.lanes & C && (lr = !0), g.firstContext = null);
  }
  function us(g) {
    var C = g._currentValue;
    if (zn !== g) if (g = { context: g, memoizedValue: C, next: null }, Ra === null) {
      if (Ca === null) throw Error(t(308));
      Ra = g, Ca.dependencies = { lanes: 0, firstContext: g };
    } else Ra = Ra.next = g;
    return C;
  }
  var qa = null;
  function On(g) {
    qa === null ? qa = [g] : qa.push(g);
  }
  function ra(g, C, B, N) {
    var F = C.interleaved;
    return F === null ? (B.next = B, On(C)) : (B.next = F.next, F.next = B), C.interleaved = B, xo(g, N);
  }
  function xo(g, C) {
    g.lanes |= C;
    var B = g.alternate;
    for (B !== null && (B.lanes |= C), B = g, g = g.return; g !== null; ) g.childLanes |= C, B = g.alternate, B !== null && (B.childLanes |= C), B = g, g = g.return;
    return B.tag === 3 ? B.stateNode : null;
  }
  var ya = !1;
  function ur(g) {
    g.updateQueue = { baseState: g.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function po(g, C) {
    g = g.updateQueue, C.updateQueue === g && (C.updateQueue = { baseState: g.baseState, firstBaseUpdate: g.firstBaseUpdate, lastBaseUpdate: g.lastBaseUpdate, shared: g.shared, effects: g.effects });
  }
  function qr(g, C) {
    return { eventTime: g, lane: C, tag: 0, payload: null, callback: null, next: null };
  }
  function ha(g, C, B) {
    var N = g.updateQueue;
    if (N === null) return null;
    if (N = N.shared, Sr & 2) {
      var F = N.pending;
      return F === null ? C.next = C : (C.next = F.next, F.next = C), N.pending = C, xo(g, B);
    }
    return F = N.interleaved, F === null ? (C.next = C, On(N)) : (C.next = F.next, F.next = C), N.interleaved = C, xo(g, B);
  }
  function Ur(g, C, B) {
    if (C = C.updateQueue, C !== null && (C = C.shared, (B & 4194240) !== 0)) {
      var N = C.lanes;
      N &= g.pendingLanes, B |= N, C.lanes = B, En(g, B);
    }
  }
  function rI(g, C) {
    var B = g.updateQueue, N = g.alternate;
    if (N !== null && (N = N.updateQueue, B === N)) {
      var F = null, D = null;
      if (B = B.firstBaseUpdate, B !== null) {
        do {
          var se = { eventTime: B.eventTime, lane: B.lane, tag: B.tag, payload: B.payload, callback: B.callback, next: null };
          D === null ? F = D = se : D = D.next = se, B = B.next;
        } while (B !== null);
        D === null ? F = D = C : D = D.next = C;
      } else F = D = C;
      B = { baseState: N.baseState, firstBaseUpdate: F, lastBaseUpdate: D, shared: N.shared, effects: N.effects }, g.updateQueue = B;
      return;
    }
    g = B.lastBaseUpdate, g === null ? B.firstBaseUpdate = C : g.next = C, B.lastBaseUpdate = C;
  }
  function mo(g, C, B, N) {
    var F = g.updateQueue;
    ya = !1;
    var D = F.firstBaseUpdate, se = F.lastBaseUpdate, He = F.shared.pending;
    if (He !== null) {
      F.shared.pending = null;
      var Qe = He, xt = Qe.next;
      Qe.next = null, se === null ? D = xt : se.next = xt, se = Qe;
      var Cn = g.alternate;
      Cn !== null && (Cn = Cn.updateQueue, He = Cn.lastBaseUpdate, He !== se && (He === null ? Cn.firstBaseUpdate = xt : He.next = xt, Cn.lastBaseUpdate = Qe));
    }
    if (D !== null) {
      var Gn = F.baseState;
      se = 0, Cn = xt = Qe = null, He = D;
      do {
        var pn = He.lane, Dn = He.eventTime;
        if ((N & pn) === pn) {
          Cn !== null && (Cn = Cn.next = {
            eventTime: Dn,
            lane: 0,
            tag: He.tag,
            payload: He.payload,
            callback: He.callback,
            next: null
          });
          e: {
            var ei = g, bi = He;
            switch (pn = C, Dn = B, bi.tag) {
              case 1:
                if (ei = bi.payload, typeof ei == "function") {
                  Gn = ei.call(Dn, Gn, pn);
                  break e;
                }
                Gn = ei;
                break e;
              case 3:
                ei.flags = ei.flags & -65537 | 128;
              case 0:
                if (ei = bi.payload, pn = typeof ei == "function" ? ei.call(Dn, Gn, pn) : ei, pn == null) break e;
                Gn = be({}, Gn, pn);
                break e;
              case 2:
                ya = !0;
            }
          }
          He.callback !== null && He.lane !== 0 && (g.flags |= 64, pn = F.effects, pn === null ? F.effects = [He] : pn.push(He));
        } else Dn = { eventTime: Dn, lane: pn, tag: He.tag, payload: He.payload, callback: He.callback, next: null }, Cn === null ? (xt = Cn = Dn, Qe = Gn) : Cn = Cn.next = Dn, se |= pn;
        if (He = He.next, He === null) {
          if (He = F.shared.pending, He === null) break;
          pn = He, He = pn.next, pn.next = null, F.lastBaseUpdate = pn, F.shared.pending = null;
        }
      } while (!0);
      if (Cn === null && (Qe = Gn), F.baseState = Qe, F.firstBaseUpdate = xt, F.lastBaseUpdate = Cn, C = F.shared.interleaved, C !== null) {
        F = C;
        do
          se |= F.lane, F = F.next;
        while (F !== C);
      } else D === null && (F.shared.lanes = 0);
      oh |= se, g.lanes = se, g.memoizedState = Gn;
    }
  }
  function nC(g, C, B) {
    if (g = C.effects, C.effects = null, g !== null) for (C = 0; C < g.length; C++) {
      var N = g[C], F = N.callback;
      if (F !== null) {
        if (N.callback = null, N = B, typeof F != "function") throw Error(t(191, F));
        F.call(N);
      }
    }
  }
  var $u = {}, bs = ar($u), Jl = ar($u), Mc = ar($u);
  function Uo(g) {
    if (g === $u) throw Error(t(174));
    return g;
  }
  function ih(g, C) {
    switch (Gr(Mc, C), Gr(Jl, g), Gr(bs, $u), g = C.nodeType, g) {
      case 9:
      case 11:
        C = (C = C.documentElement) ? C.namespaceURI : rn(null, "");
        break;
      default:
        g = g === 8 ? C.parentNode : C, C = g.namespaceURI || null, g = g.tagName, C = rn(C, g);
    }
    Ci(bs), Gr(bs, C);
  }
  function dd() {
    Ci(bs), Ci(Jl), Ci(Mc);
  }
  function aI(g) {
    Uo(Mc.current);
    var C = Uo(bs.current), B = rn(C, g.type);
    C !== B && (Gr(Jl, g), Gr(bs, B));
  }
  function iC(g) {
    Jl.current === g && (Ci(bs), Ci(Jl));
  }
  var Xa = ar(0);
  function Ql(g) {
    for (var C = g; C !== null; ) {
      if (C.tag === 13) {
        var B = C.memoizedState;
        if (B !== null && (B = B.dehydrated, B === null || B.data === "$?" || B.data === "$!")) return C;
      } else if (C.tag === 19 && C.memoizedProps.revealOrder !== void 0) {
        if (C.flags & 128) return C;
      } else if (C.child !== null) {
        C.child.return = C, C = C.child;
        continue;
      }
      if (C === g) break;
      for (; C.sibling === null; ) {
        if (C.return === null || C.return === g) return null;
        C = C.return;
      }
      C.sibling.return = C.return, C = C.sibling;
    }
    return null;
  }
  var rC = [];
  function ec() {
    for (var g = 0; g < rC.length; g++) rC[g]._workInProgressVersionPrimary = null;
    rC.length = 0;
  }
  var oI = _.ReactCurrentDispatcher, sI = _.ReactCurrentBatchConfig, tc = 0, Kn = null, Zi = null, vi = null, Or = !1, La = !1, yg = 0, Ps = 0;
  function Gs() {
    throw Error(t(321));
  }
  function Js(g, C) {
    if (C === null) return !1;
    for (var B = 0; B < C.length && B < g.length; B++) if (!Ts(g[B], C[B])) return !1;
    return !0;
  }
  function dl(g, C, B, N, F, D) {
    if (tc = D, Kn = C, C.memoizedState = null, C.updateQueue = null, C.lanes = 0, oI.current = g === null || g.memoizedState === null ? Vl : _m, g = B(N, F), La) {
      D = 0;
      do {
        if (La = !1, yg = 0, 25 <= D) throw Error(t(301));
        D += 1, vi = Zi = null, C.updateQueue = null, oI.current = Br, g = B(N, F);
      } while (La);
    }
    if (oI.current = Zu, C = Zi !== null && Zi.next !== null, tc = 0, vi = Zi = Kn = null, Or = !1, C) throw Error(t(300));
    return g;
  }
  function dn() {
    var g = yg !== 0;
    return yg = 0, g;
  }
  function Wr() {
    var g = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return vi === null ? Kn.memoizedState = vi = g : vi = vi.next = g, vi;
  }
  function yi() {
    if (Zi === null) {
      var g = Kn.alternate;
      g = g !== null ? g.memoizedState : null;
    } else g = Zi.next;
    var C = vi === null ? Kn.memoizedState : vi.next;
    if (C !== null) vi = C, Zi = g;
    else {
      if (g === null) throw Error(t(310));
      Zi = g, g = { memoizedState: Zi.memoizedState, baseState: Zi.baseState, baseQueue: Zi.baseQueue, queue: Zi.queue, next: null }, vi === null ? Kn.memoizedState = vi = g : vi = vi.next = g;
    }
    return vi;
  }
  function nc(g, C) {
    return typeof C == "function" ? C(g) : C;
  }
  function Rl(g) {
    var C = yi(), B = C.queue;
    if (B === null) throw Error(t(311));
    B.lastRenderedReducer = g;
    var N = Zi, F = N.baseQueue, D = B.pending;
    if (D !== null) {
      if (F !== null) {
        var se = F.next;
        F.next = D.next, D.next = se;
      }
      N.baseQueue = F = D, B.pending = null;
    }
    if (F !== null) {
      D = F.next, N = N.baseState;
      var He = se = null, Qe = null, xt = D;
      do {
        var Cn = xt.lane;
        if ((tc & Cn) === Cn) Qe !== null && (Qe = Qe.next = { lane: 0, action: xt.action, hasEagerState: xt.hasEagerState, eagerState: xt.eagerState, next: null }), N = xt.hasEagerState ? xt.eagerState : g(N, xt.action);
        else {
          var Gn = {
            lane: Cn,
            action: xt.action,
            hasEagerState: xt.hasEagerState,
            eagerState: xt.eagerState,
            next: null
          };
          Qe === null ? (He = Qe = Gn, se = N) : Qe = Qe.next = Gn, Kn.lanes |= Cn, oh |= Cn;
        }
        xt = xt.next;
      } while (xt !== null && xt !== D);
      Qe === null ? se = N : Qe.next = He, Ts(N, C.memoizedState) || (lr = !0), C.memoizedState = N, C.baseState = se, C.baseQueue = Qe, B.lastRenderedState = N;
    }
    if (g = B.interleaved, g !== null) {
      F = g;
      do
        D = F.lane, Kn.lanes |= D, oh |= D, F = F.next;
      while (F !== g);
    } else F === null && (B.lanes = 0);
    return [C.memoizedState, B.dispatch];
  }
  function $a(g) {
    var C = yi(), B = C.queue;
    if (B === null) throw Error(t(311));
    B.lastRenderedReducer = g;
    var N = B.dispatch, F = B.pending, D = C.memoizedState;
    if (F !== null) {
      B.pending = null;
      var se = F = F.next;
      do
        D = g(D, se.action), se = se.next;
      while (se !== F);
      Ts(D, C.memoizedState) || (lr = !0), C.memoizedState = D, C.baseQueue === null && (C.baseState = D), B.lastRenderedState = D;
    }
    return [D, N];
  }
  function jl() {
  }
  function lI(g, C) {
    var B = Kn, N = yi(), F = C(), D = !Ts(N.memoizedState, F);
    if (D && (N.memoizedState = F, lr = !0), N = N.queue, Ao(uI.bind(null, B, N, g), [g]), N.getSnapshot !== C || D || vi !== null && vi.memoizedState.tag & 1) {
      if (B.flags |= 2048, eo(9, Gg.bind(null, B, N, F, C), void 0, null), Vr === null) throw Error(t(349));
      tc & 30 || bg(B, C, F);
    }
    return F;
  }
  function bg(g, C, B) {
    g.flags |= 16384, g = { getSnapshot: C, value: B }, C = Kn.updateQueue, C === null ? (C = { lastEffect: null, stores: null }, Kn.updateQueue = C, C.stores = [g]) : (B = C.stores, B === null ? C.stores = [g] : B.push(g));
  }
  function Gg(g, C, B, N) {
    C.value = B, C.getSnapshot = N, nf(C) && aC(g);
  }
  function uI(g, C, B) {
    return B(function() {
      nf(C) && aC(g);
    });
  }
  function nf(g) {
    var C = g.getSnapshot;
    g = g.value;
    try {
      var B = C();
      return !Ts(g, B);
    } catch {
      return !0;
    }
  }
  function aC(g) {
    var C = xo(g, 1);
    C !== null && ka(C, g, 1, -1);
  }
  function oC(g) {
    var C = Wr();
    return typeof g == "function" && (g = g()), C.memoizedState = C.baseState = g, g = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: nc, lastRenderedState: g }, C.queue = g, g = g.dispatch = rc.bind(null, Kn, g), [C.memoizedState, g];
  }
  function eo(g, C, B, N) {
    return g = { tag: g, create: C, destroy: B, deps: N, next: null }, C = Kn.updateQueue, C === null ? (C = { lastEffect: null, stores: null }, Kn.updateQueue = C, C.lastEffect = g.next = g) : (B = C.lastEffect, B === null ? C.lastEffect = g.next = g : (N = B.next, B.next = g, g.next = N, C.lastEffect = g)), g;
  }
  function Id() {
    return yi().memoizedState;
  }
  function Bu(g, C, B, N) {
    var F = Wr();
    Kn.flags |= g, F.memoizedState = eo(1 | C, B, void 0, N === void 0 ? null : N);
  }
  function cI(g, C, B, N) {
    var F = yi();
    N = N === void 0 ? null : N;
    var D = void 0;
    if (Zi !== null) {
      var se = Zi.memoizedState;
      if (D = se.destroy, N !== null && Js(N, se.deps)) {
        F.memoizedState = eo(C, B, D, N);
        return;
      }
    }
    Kn.flags |= g, F.memoizedState = eo(1 | C, B, D, N);
  }
  function $r(g, C) {
    return Bu(8390656, 8, g, C);
  }
  function Ao(g, C) {
    return cI(2048, 8, g, C);
  }
  function xl(g, C) {
    return cI(4, 2, g, C);
  }
  function Wl(g, C) {
    return cI(4, 4, g, C);
  }
  function rf(g, C) {
    if (typeof C == "function") return g = g(), C(g), function() {
      C(null);
    };
    if (C != null) return g = g(), C.current = g, function() {
      C.current = null;
    };
  }
  function ic(g, C, B) {
    return B = B != null ? B.concat([g]) : null, cI(4, 4, rf.bind(null, C, g), B);
  }
  function Hc() {
  }
  function Bg(g, C) {
    var B = yi();
    C = C === void 0 ? null : C;
    var N = B.memoizedState;
    return N !== null && C !== null && Js(C, N[1]) ? N[0] : (B.memoizedState = [g, C], g);
  }
  function vo(g, C) {
    var B = yi();
    C = C === void 0 ? null : C;
    var N = B.memoizedState;
    return N !== null && C !== null && Js(C, N[1]) ? N[0] : (g = g(), B.memoizedState = [g, C], g);
  }
  function Xc(g, C, B) {
    return tc & 21 ? (Ts(B, C) || (B = un(), Kn.lanes |= B, oh |= B, g.baseState = !0), C) : (g.baseState && (g.baseState = !1, lr = !0), g.memoizedState = B);
  }
  function gI(g, C) {
    var B = cn;
    cn = B !== 0 && 4 > B ? B : 4, g(!0);
    var N = sI.transition;
    sI.transition = {};
    try {
      g(!1), C();
    } finally {
      cn = B, sI.transition = N;
    }
  }
  function Il() {
    return yi().memoizedState;
  }
  function Su(g, C, B) {
    var N = Tc(g);
    if (B = { lane: N, action: B, hasEagerState: !1, eagerState: null, next: null }, Yc(g)) sC(C, B);
    else if (B = ra(g, C, B, N), B !== null) {
      var F = No();
      ka(B, g, N, F), Sg(B, C, N);
    }
  }
  function rc(g, C, B) {
    var N = Tc(g), F = { lane: N, action: B, hasEagerState: !1, eagerState: null, next: null };
    if (Yc(g)) sC(C, F);
    else {
      var D = g.alternate;
      if (g.lanes === 0 && (D === null || D.lanes === 0) && (D = C.lastRenderedReducer, D !== null)) try {
        var se = C.lastRenderedState, He = D(se, B);
        if (F.hasEagerState = !0, F.eagerState = He, Ts(He, se)) {
          var Qe = C.interleaved;
          Qe === null ? (F.next = F, On(C)) : (F.next = Qe.next, Qe.next = F), C.interleaved = F;
          return;
        }
      } catch {
      } finally {
      }
      B = ra(g, C, F, N), B !== null && (F = No(), ka(B, g, N, F), Sg(B, C, N));
    }
  }
  function Yc(g) {
    var C = g.alternate;
    return g === Kn || C !== null && C === Kn;
  }
  function sC(g, C) {
    La = Or = !0;
    var B = g.pending;
    B === null ? C.next = C : (C.next = B.next, B.next = C), g.pending = C;
  }
  function Sg(g, C, B) {
    if (B & 4194240) {
      var N = C.lanes;
      N &= g.pendingLanes, B |= N, C.lanes = B, En(g, B);
    }
  }
  var Zu = { readContext: us, useCallback: Gs, useContext: Gs, useEffect: Gs, useImperativeHandle: Gs, useInsertionEffect: Gs, useLayoutEffect: Gs, useMemo: Gs, useReducer: Gs, useRef: Gs, useState: Gs, useDebugValue: Gs, useDeferredValue: Gs, useTransition: Gs, useMutableSource: Gs, useSyncExternalStore: Gs, useId: Gs, unstable_isNewReconciler: !1 }, Vl = { readContext: us, useCallback: function(g, C) {
    return Wr().memoizedState = [g, C === void 0 ? null : C], g;
  }, useContext: us, useEffect: $r, useImperativeHandle: function(g, C, B) {
    return B = B != null ? B.concat([g]) : null, Bu(
      4194308,
      4,
      rf.bind(null, C, g),
      B
    );
  }, useLayoutEffect: function(g, C) {
    return Bu(4194308, 4, g, C);
  }, useInsertionEffect: function(g, C) {
    return Bu(4, 2, g, C);
  }, useMemo: function(g, C) {
    var B = Wr();
    return C = C === void 0 ? null : C, g = g(), B.memoizedState = [g, C], g;
  }, useReducer: function(g, C, B) {
    var N = Wr();
    return C = B !== void 0 ? B(C) : C, N.memoizedState = N.baseState = C, g = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: g, lastRenderedState: C }, N.queue = g, g = g.dispatch = Su.bind(null, Kn, g), [N.memoizedState, g];
  }, useRef: function(g) {
    var C = Wr();
    return g = { current: g }, C.memoizedState = g;
  }, useState: oC, useDebugValue: Hc, useDeferredValue: function(g) {
    return Wr().memoizedState = g;
  }, useTransition: function() {
    var g = oC(!1), C = g[0];
    return g = gI.bind(null, g[1]), Wr().memoizedState = g, [C, g];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(g, C, B) {
    var N = Kn, F = Wr();
    if (Ha) {
      if (B === void 0) throw Error(t(407));
      B = B();
    } else {
      if (B = C(), Vr === null) throw Error(t(349));
      tc & 30 || bg(N, C, B);
    }
    F.memoizedState = B;
    var D = { value: B, getSnapshot: C };
    return F.queue = D, $r(uI.bind(
      null,
      N,
      D,
      g
    ), [g]), N.flags |= 2048, eo(9, Gg.bind(null, N, D, B, C), void 0, null), B;
  }, useId: function() {
    var g = Wr(), C = Vr.identifierPrefix;
    if (Ha) {
      var B = Do, N = Nn;
      B = (N & ~(1 << 32 - ue(N) - 1)).toString(32) + B, C = ":" + C + "R" + B, B = yg++, 0 < B && (C += "H" + B.toString(32)), C += ":";
    } else B = Ps++, C = ":" + C + "r" + B.toString(32) + ":";
    return g.memoizedState = C;
  }, unstable_isNewReconciler: !1 }, _m = {
    readContext: us,
    useCallback: Bg,
    useContext: us,
    useEffect: Ao,
    useImperativeHandle: ic,
    useInsertionEffect: xl,
    useLayoutEffect: Wl,
    useMemo: vo,
    useReducer: Rl,
    useRef: Id,
    useState: function() {
      return Rl(nc);
    },
    useDebugValue: Hc,
    useDeferredValue: function(g) {
      var C = yi();
      return Xc(C, Zi.memoizedState, g);
    },
    useTransition: function() {
      var g = Rl(nc)[0], C = yi().memoizedState;
      return [g, C];
    },
    useMutableSource: jl,
    useSyncExternalStore: lI,
    useId: Il,
    unstable_isNewReconciler: !1
  }, Br = { readContext: us, useCallback: Bg, useContext: us, useEffect: Ao, useImperativeHandle: ic, useInsertionEffect: xl, useLayoutEffect: Wl, useMemo: vo, useReducer: $a, useRef: Id, useState: function() {
    return $a(nc);
  }, useDebugValue: Hc, useDeferredValue: function(g) {
    var C = yi();
    return Zi === null ? C.memoizedState = g : Xc(C, Zi.memoizedState, g);
  }, useTransition: function() {
    var g = $a(nc)[0], C = yi().memoizedState;
    return [g, C];
  }, useMutableSource: jl, useSyncExternalStore: lI, useId: Il, unstable_isNewReconciler: !1 };
  function cs(g, C) {
    if (g && g.defaultProps) {
      C = be({}, C), g = g.defaultProps;
      for (var B in g) C[B] === void 0 && (C[B] = g[B]);
      return C;
    }
    return C;
  }
  function wu(g, C, B, N) {
    C = g.memoizedState, B = B(N, C), B = B == null ? C : be({}, C, B), g.memoizedState = B, g.lanes === 0 && (g.updateQueue.baseState = B);
  }
  var ac = { isMounted: function(g) {
    return (g = g._reactInternals) ? Bt(g) === g : !1;
  }, enqueueSetState: function(g, C, B) {
    g = g._reactInternals;
    var N = No(), F = Tc(g), D = qr(N, F);
    D.payload = C, B != null && (D.callback = B), C = ha(g, D, F), C !== null && (ka(C, g, F, N), Ur(C, g, F));
  }, enqueueReplaceState: function(g, C, B) {
    g = g._reactInternals;
    var N = No(), F = Tc(g), D = qr(N, F);
    D.tag = 1, D.payload = C, B != null && (D.callback = B), C = ha(g, D, F), C !== null && (ka(C, g, F, N), Ur(C, g, F));
  }, enqueueForceUpdate: function(g, C) {
    g = g._reactInternals;
    var B = No(), N = Tc(g), F = qr(B, N);
    F.tag = 2, C != null && (F.callback = C), C = ha(g, F, N), C !== null && (ka(C, g, N, B), Ur(C, g, N));
  } };
  function Fc(g, C, B, N, F, D, se) {
    return g = g.stateNode, typeof g.shouldComponentUpdate == "function" ? g.shouldComponentUpdate(N, D, se) : C.prototype && C.prototype.isPureReactComponent ? !_s(B, N) || !_s(F, D) : !0;
  }
  function m(g, C, B) {
    var N = !1, F = Ds, D = C.contextType;
    return typeof D == "object" && D !== null ? D = us(D) : (F = Qa(C) ? As : jo.current, N = C.contextTypes, D = (N = N != null) ? Zl(g, F) : Ds), C = new C(B, D), g.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, C.updater = ac, g.stateNode = C, C._reactInternals = g, N && (g = g.stateNode, g.__reactInternalMemoizedUnmaskedChildContext = F, g.__reactInternalMemoizedMaskedChildContext = D), C;
  }
  function A(g, C, B, N) {
    g = C.state, typeof C.componentWillReceiveProps == "function" && C.componentWillReceiveProps(B, N), typeof C.UNSAFE_componentWillReceiveProps == "function" && C.UNSAFE_componentWillReceiveProps(B, N), C.state !== g && ac.enqueueReplaceState(C, C.state, null);
  }
  function V(g, C, B, N) {
    var F = g.stateNode;
    F.props = B, F.state = g.memoizedState, F.refs = {}, ur(g);
    var D = C.contextType;
    typeof D == "object" && D !== null ? F.context = us(D) : (D = Qa(C) ? As : jo.current, F.context = Zl(g, D)), F.state = g.memoizedState, D = C.getDerivedStateFromProps, typeof D == "function" && (wu(g, C, D, B), F.state = g.memoizedState), typeof C.getDerivedStateFromProps == "function" || typeof F.getSnapshotBeforeUpdate == "function" || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (C = F.state, typeof F.componentWillMount == "function" && F.componentWillMount(), typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount(), C !== F.state && ac.enqueueReplaceState(F, F.state, null), mo(g, B, F, N), F.state = g.memoizedState), typeof F.componentDidMount == "function" && (g.flags |= 4194308);
  }
  function Y(g, C) {
    try {
      var B = "", N = C;
      do
        B += ot(N), N = N.return;
      while (N);
      var F = B;
    } catch (D) {
      F = `
Error generating stack: ` + D.message + `
` + D.stack;
    }
    return { value: g, source: C, stack: F, digest: null };
  }
  function L(g, C, B) {
    return { value: g, source: null, stack: B ?? null, digest: C ?? null };
  }
  function $(g, C) {
    try {
      console.error(C.value);
    } catch (B) {
      setTimeout(function() {
        throw B;
      });
    }
  }
  var Ve = typeof WeakMap == "function" ? WeakMap : Map;
  function nt(g, C, B) {
    B = qr(-1, B), B.tag = 3, B.payload = { element: null };
    var N = C.value;
    return B.callback = function() {
      If || (If = !0, xp = N), $(g, C);
    }, B;
  }
  function kt(g, C, B) {
    B = qr(-1, B), B.tag = 3;
    var N = g.type.getDerivedStateFromError;
    if (typeof N == "function") {
      var F = C.value;
      B.payload = function() {
        return N(F);
      }, B.callback = function() {
        $(g, C);
      };
    }
    var D = g.stateNode;
    return D !== null && typeof D.componentDidCatch == "function" && (B.callback = function() {
      $(g, C), typeof N != "function" && (pC === null ? pC = /* @__PURE__ */ new Set([this]) : pC.add(this));
      var se = C.stack;
      this.componentDidCatch(C.value, { componentStack: se !== null ? se : "" });
    }), B;
  }
  function Wn(g, C, B) {
    var N = g.pingCache;
    if (N === null) {
      N = g.pingCache = new Ve();
      var F = /* @__PURE__ */ new Set();
      N.set(C, F);
    } else F = N.get(C), F === void 0 && (F = /* @__PURE__ */ new Set(), N.set(C, F));
    F.has(B) || (F.add(B), g = Hp.bind(null, g, C, B), C.then(g, g));
  }
  function Jn(g) {
    do {
      var C;
      if ((C = g.tag === 13) && (C = g.memoizedState, C = C !== null ? C.dehydrated !== null : !0), C) return g;
      g = g.return;
    } while (g !== null);
    return null;
  }
  function mi(g, C, B, N, F) {
    return g.mode & 1 ? (g.flags |= 65536, g.lanes = F, g) : (g === C ? g.flags |= 65536 : (g.flags |= 128, B.flags |= 131072, B.flags &= -52805, B.tag === 1 && (B.alternate === null ? B.tag = 17 : (C = qr(-1, 1), C.tag = 2, ha(B, C, 1))), B.lanes |= 1), g);
  }
  var wi = _.ReactCurrentOwner, lr = !1;
  function $n(g, C, B, N) {
    C.child = g === null ? th(C, null, B, N) : vg(C, g.child, B, N);
  }
  function to(g, C, B, N, F) {
    B = B.render;
    var D = C.ref;
    return gd(C, F), N = dl(g, C, B, N, D, F), B = dn(), g !== null && !lr ? (C.updateQueue = g.updateQueue, C.flags &= -2053, g.lanes &= ~F, Zg(g, C, F)) : (Ha && B && ef(C), C.flags |= 1, $n(g, C, N, F), C.child);
  }
  function gs(g, C, B, N, F) {
    if (g === null) {
      var D = B.type;
      return typeof D == "function" && !Yp(D) && D.defaultProps === void 0 && B.compare === null && B.defaultProps === void 0 ? (C.tag = 15, C.type = D, It(g, C, D, N, F)) : (g = Pm(B.type, null, N, C, C.mode, F), g.ref = C.ref, g.return = C, C.child = g);
    }
    if (D = g.child, !(g.lanes & F)) {
      var se = D.memoizedProps;
      if (B = B.compare, B = B !== null ? B : _s, B(se, N) && g.ref === C.ref) return Zg(g, C, F);
    }
    return C.flags |= 1, g = md(D, N), g.ref = C.ref, g.return = C, C.child = g;
  }
  function It(g, C, B, N, F) {
    if (g !== null) {
      var D = g.memoizedProps;
      if (_s(D, N) && g.ref === C.ref) if (lr = !1, C.pendingProps = N = D, (g.lanes & F) !== 0) g.flags & 131072 && (lr = !0);
      else return C.lanes = g.lanes, Zg(g, C, F);
    }
    return Tn(g, C, B, N, F);
  }
  function st(g, C, B) {
    var N = C.pendingProps, F = N.children, D = g !== null ? g.memoizedState : null;
    if (N.mode === "hidden") if (!(C.mode & 1)) C.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Gr(xu, $o), $o |= B;
    else {
      if (!(B & 1073741824)) return g = D !== null ? D.baseLanes | B : B, C.lanes = C.childLanes = 1073741824, C.memoizedState = { baseLanes: g, cachePool: null, transitions: null }, C.updateQueue = null, Gr(xu, $o), $o |= g, null;
      C.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, N = D !== null ? D.baseLanes : B, Gr(xu, $o), $o |= N;
    }
    else D !== null ? (N = D.baseLanes | B, C.memoizedState = null) : N = B, Gr(xu, $o), $o |= N;
    return $n(g, C, F, B), C.child;
  }
  function Zt(g, C) {
    var B = C.ref;
    (g === null && B !== null || g !== null && g.ref !== B) && (C.flags |= 512, C.flags |= 2097152);
  }
  function Tn(g, C, B, N, F) {
    var D = Qa(B) ? As : jo.current;
    return D = Zl(C, D), gd(C, F), B = dl(g, C, B, N, D, F), N = dn(), g !== null && !lr ? (C.updateQueue = g.updateQueue, C.flags &= -2053, g.lanes &= ~F, Zg(g, C, F)) : (Ha && N && ef(C), C.flags |= 1, $n(g, C, B, F), C.child);
  }
  function fn(g, C, B, N, F) {
    if (Qa(B)) {
      var D = !0;
      xc(C);
    } else D = !1;
    if (gd(C, F), C.stateNode === null) rh(g, C), m(C, B, N), V(C, B, N, F), N = !0;
    else if (g === null) {
      var se = C.stateNode, He = C.memoizedProps;
      se.props = He;
      var Qe = se.context, xt = B.contextType;
      typeof xt == "object" && xt !== null ? xt = us(xt) : (xt = Qa(B) ? As : jo.current, xt = Zl(C, xt));
      var Cn = B.getDerivedStateFromProps, Gn = typeof Cn == "function" || typeof se.getSnapshotBeforeUpdate == "function";
      Gn || typeof se.UNSAFE_componentWillReceiveProps != "function" && typeof se.componentWillReceiveProps != "function" || (He !== N || Qe !== xt) && A(C, se, N, xt), ya = !1;
      var pn = C.memoizedState;
      se.state = pn, mo(C, N, se, F), Qe = C.memoizedState, He !== N || pn !== Qe || Qi.current || ya ? (typeof Cn == "function" && (wu(C, B, Cn, N), Qe = C.memoizedState), (He = ya || Fc(C, B, He, N, pn, Qe, xt)) ? (Gn || typeof se.UNSAFE_componentWillMount != "function" && typeof se.componentWillMount != "function" || (typeof se.componentWillMount == "function" && se.componentWillMount(), typeof se.UNSAFE_componentWillMount == "function" && se.UNSAFE_componentWillMount()), typeof se.componentDidMount == "function" && (C.flags |= 4194308)) : (typeof se.componentDidMount == "function" && (C.flags |= 4194308), C.memoizedProps = N, C.memoizedState = Qe), se.props = N, se.state = Qe, se.context = xt, N = He) : (typeof se.componentDidMount == "function" && (C.flags |= 4194308), N = !1);
    } else {
      se = C.stateNode, po(g, C), He = C.memoizedProps, xt = C.type === C.elementType ? He : cs(C.type, He), se.props = xt, Gn = C.pendingProps, pn = se.context, Qe = B.contextType, typeof Qe == "object" && Qe !== null ? Qe = us(Qe) : (Qe = Qa(B) ? As : jo.current, Qe = Zl(C, Qe));
      var Dn = B.getDerivedStateFromProps;
      (Cn = typeof Dn == "function" || typeof se.getSnapshotBeforeUpdate == "function") || typeof se.UNSAFE_componentWillReceiveProps != "function" && typeof se.componentWillReceiveProps != "function" || (He !== Gn || pn !== Qe) && A(C, se, N, Qe), ya = !1, pn = C.memoizedState, se.state = pn, mo(C, N, se, F);
      var ei = C.memoizedState;
      He !== Gn || pn !== ei || Qi.current || ya ? (typeof Dn == "function" && (wu(C, B, Dn, N), ei = C.memoizedState), (xt = ya || Fc(C, B, xt, N, pn, ei, Qe) || !1) ? (Cn || typeof se.UNSAFE_componentWillUpdate != "function" && typeof se.componentWillUpdate != "function" || (typeof se.componentWillUpdate == "function" && se.componentWillUpdate(N, ei, Qe), typeof se.UNSAFE_componentWillUpdate == "function" && se.UNSAFE_componentWillUpdate(N, ei, Qe)), typeof se.componentDidUpdate == "function" && (C.flags |= 4), typeof se.getSnapshotBeforeUpdate == "function" && (C.flags |= 1024)) : (typeof se.componentDidUpdate != "function" || He === g.memoizedProps && pn === g.memoizedState || (C.flags |= 4), typeof se.getSnapshotBeforeUpdate != "function" || He === g.memoizedProps && pn === g.memoizedState || (C.flags |= 1024), C.memoizedProps = N, C.memoizedState = ei), se.props = N, se.state = ei, se.context = Qe, N = xt) : (typeof se.componentDidUpdate != "function" || He === g.memoizedProps && pn === g.memoizedState || (C.flags |= 4), typeof se.getSnapshotBeforeUpdate != "function" || He === g.memoizedProps && pn === g.memoizedState || (C.flags |= 1024), N = !1);
    }
    return ji(g, C, B, N, D, F);
  }
  function ji(g, C, B, N, F, D) {
    Zt(g, C);
    var se = (C.flags & 128) !== 0;
    if (!N && !se) return F && tC(C, B, !1), Zg(g, C, D);
    N = C.stateNode, wi.current = C;
    var He = se && typeof B.getDerivedStateFromError != "function" ? null : N.render();
    return C.flags |= 1, g !== null && se ? (C.child = vg(C, g.child, null, D), C.child = vg(C, null, He, D)) : $n(g, C, He, D), C.memoizedState = N.state, F && tC(C, B, !0), C.child;
  }
  function $i(g) {
    var C = g.stateNode;
    C.pendingContext ? Dl(g, C.pendingContext, C.pendingContext !== C.context) : C.context && Dl(g, C.context, !1), ih(g, C.containerInfo);
  }
  function fr(g, C, B, N, F) {
    return Ka(), co(F), C.flags |= 256, $n(g, C, B, N), C.child;
  }
  var xa = { dehydrated: null, treeContext: null, retryLane: 0 };
  function mr(g) {
    return { baseLanes: g, cachePool: null, transitions: null };
  }
  function Cl(g, C, B) {
    var N = C.pendingProps, F = Xa.current, D = !1, se = (C.flags & 128) !== 0, He;
    if ((He = se) || (He = g !== null && g.memoizedState === null ? !1 : (F & 2) !== 0), He ? (D = !0, C.flags &= -129) : (g === null || g.memoizedState !== null) && (F |= 1), Gr(Xa, F & 1), g === null)
      return Ag(C), g = C.memoizedState, g !== null && (g = g.dehydrated, g !== null) ? (C.mode & 1 ? g.data === "$!" ? C.lanes = 8 : C.lanes = 1073741824 : C.lanes = 1, null) : (se = N.children, g = N.fallback, D ? (N = C.mode, D = C.child, se = { mode: "hidden", children: se }, !(N & 1) && D !== null ? (D.childLanes = 0, D.pendingProps = se) : D = mI(se, N, 0, null), g = Wu(g, N, B, null), D.return = C, g.return = C, D.sibling = g, C.child = D, C.child.memoizedState = mr(B), C.memoizedState = xa, g) : Gp(C, se));
    if (F = g.memoizedState, F !== null && (He = F.dehydrated, He !== null)) return hB(g, C, se, N, He, F, B);
    if (D) {
      D = N.fallback, se = C.mode, F = g.child, He = F.sibling;
      var Qe = { mode: "hidden", children: N.children };
      return !(se & 1) && C.child !== F ? (N = C.child, N.childLanes = 0, N.pendingProps = Qe, C.deletions = null) : (N = md(F, Qe), N.subtreeFlags = F.subtreeFlags & 14680064), He !== null ? D = md(He, D) : (D = Wu(D, se, B, null), D.flags |= 2), D.return = C, N.return = C, N.sibling = D, C.child = N, N = D, D = C.child, se = g.child.memoizedState, se = se === null ? mr(B) : { baseLanes: se.baseLanes | B, cachePool: null, transitions: se.transitions }, D.memoizedState = se, D.childLanes = g.childLanes & ~B, C.memoizedState = xa, N;
    }
    return D = g.child, g = D.sibling, N = md(D, { mode: "visible", children: N.children }), !(C.mode & 1) && (N.lanes = B), N.return = C, N.sibling = null, g !== null && (B = C.deletions, B === null ? (C.deletions = [g], C.flags |= 16) : B.push(g)), C.child = N, C.memoizedState = null, N;
  }
  function Gp(g, C) {
    return C = mI({ mode: "visible", children: C }, g.mode, 0, null), C.return = g, g.child = C;
  }
  function lC(g, C, B, N) {
    return N !== null && co(N), vg(C, g.child, null, B), g = Gp(C, C.pendingProps.children), g.flags |= 2, C.memoizedState = null, g;
  }
  function hB(g, C, B, N, F, D, se) {
    if (B)
      return C.flags & 256 ? (C.flags &= -257, N = L(Error(t(422))), lC(g, C, se, N)) : C.memoizedState !== null ? (C.child = g.child, C.flags |= 128, null) : (D = N.fallback, F = C.mode, N = mI({ mode: "visible", children: N.children }, F, 0, null), D = Wu(D, F, se, null), D.flags |= 2, N.return = C, D.return = C, N.sibling = D, C.child = N, C.mode & 1 && vg(C, g.child, null, se), C.child.memoizedState = mr(se), C.memoizedState = xa, D);
    if (!(C.mode & 1)) return lC(g, C, se, null);
    if (F.data === "$!") {
      if (N = F.nextSibling && F.nextSibling.dataset, N) var He = N.dgst;
      return N = He, D = Error(t(419)), N = L(D, N, void 0), lC(g, C, se, N);
    }
    if (He = (se & g.childLanes) !== 0, lr || He) {
      if (N = Vr, N !== null) {
        switch (se & -se) {
          case 4:
            F = 2;
            break;
          case 16:
            F = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            F = 32;
            break;
          case 536870912:
            F = 268435456;
            break;
          default:
            F = 0;
        }
        F = F & (N.suspendedLanes | se) ? 0 : F, F !== 0 && F !== D.retryLane && (D.retryLane = F, xo(g, F), ka(N, g, F, -1));
      }
      return Um(), N = L(Error(t(421))), lC(g, C, se, N);
    }
    return F.data === "$?" ? (C.flags |= 128, C.child = g.child, C = pv.bind(null, g), F._reactRetry = C, null) : (g = D.treeContext, ys = Ls(F.nextSibling), vs = C, Ha = !0, wl = null, g !== null && (Wi[uo++] = Nn, Wi[uo++] = Do, Wi[uo++] = Gu, Nn = g.id, Do = g.overflow, Gu = C), C = Gp(C, N.children), C.flags |= 4096, C);
  }
  function Bp(g, C, B) {
    g.lanes |= C;
    var N = g.alternate;
    N !== null && (N.lanes |= C), nh(g.return, C, B);
  }
  function af(g, C, B, N, F) {
    var D = g.memoizedState;
    D === null ? g.memoizedState = { isBackwards: C, rendering: null, renderingStartTime: 0, last: N, tail: B, tailMode: F } : (D.isBackwards = C, D.rendering = null, D.renderingStartTime = 0, D.last = N, D.tail = B, D.tailMode = F);
  }
  function zm(g, C, B) {
    var N = C.pendingProps, F = N.revealOrder, D = N.tail;
    if ($n(g, C, N.children, B), N = Xa.current, N & 2) N = N & 1 | 2, C.flags |= 128;
    else {
      if (g !== null && g.flags & 128) e: for (g = C.child; g !== null; ) {
        if (g.tag === 13) g.memoizedState !== null && Bp(g, B, C);
        else if (g.tag === 19) Bp(g, B, C);
        else if (g.child !== null) {
          g.child.return = g, g = g.child;
          continue;
        }
        if (g === C) break e;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === C) break e;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
      N &= 1;
    }
    if (Gr(Xa, N), !(C.mode & 1)) C.memoizedState = null;
    else switch (F) {
      case "forwards":
        for (B = C.child, F = null; B !== null; ) g = B.alternate, g !== null && Ql(g) === null && (F = B), B = B.sibling;
        B = F, B === null ? (F = C.child, C.child = null) : (F = B.sibling, B.sibling = null), af(C, !1, F, B, D);
        break;
      case "backwards":
        for (B = null, F = C.child, C.child = null; F !== null; ) {
          if (g = F.alternate, g !== null && Ql(g) === null) {
            C.child = F;
            break;
          }
          g = F.sibling, F.sibling = B, B = F, F = g;
        }
        af(C, !0, B, null, D);
        break;
      case "together":
        af(C, !1, null, null, void 0);
        break;
      default:
        C.memoizedState = null;
    }
    return C.child;
  }
  function rh(g, C) {
    !(C.mode & 1) && g !== null && (g.alternate = null, C.alternate = null, C.flags |= 2);
  }
  function Zg(g, C, B) {
    if (g !== null && (C.dependencies = g.dependencies), oh |= C.lanes, !(B & C.childLanes)) return null;
    if (g !== null && C.child !== g.child) throw Error(t(153));
    if (C.child !== null) {
      for (g = C.child, B = md(g, g.pendingProps), C.child = B, B.return = C; g.sibling !== null; ) g = g.sibling, B = B.sibling = md(g, g.pendingProps), B.return = C;
      B.sibling = null;
    }
    return C.child;
  }
  function ql(g, C, B) {
    switch (C.tag) {
      case 3:
        $i(C), Ka();
        break;
      case 5:
        aI(C);
        break;
      case 1:
        Qa(C.type) && xc(C);
        break;
      case 4:
        ih(C, C.stateNode.containerInfo);
        break;
      case 10:
        var N = C.type._context, F = C.memoizedProps.value;
        Gr(iI, N._currentValue), N._currentValue = F;
        break;
      case 13:
        if (N = C.memoizedState, N !== null)
          return N.dehydrated !== null ? (Gr(Xa, Xa.current & 1), C.flags |= 128, null) : B & C.child.childLanes ? Cl(g, C, B) : (Gr(Xa, Xa.current & 1), g = Zg(g, C, B), g !== null ? g.sibling : null);
        Gr(Xa, Xa.current & 1);
        break;
      case 19:
        if (N = (B & C.childLanes) !== 0, g.flags & 128) {
          if (N) return zm(g, C, B);
          C.flags |= 128;
        }
        if (F = C.memoizedState, F !== null && (F.rendering = null, F.tail = null, F.lastEffect = null), Gr(Xa, Xa.current), N) break;
        return null;
      case 22:
      case 23:
        return C.lanes = 0, st(g, C, B);
    }
    return Zg(g, C, B);
  }
  var Ec, oc, ah, uC;
  Ec = function(g, C) {
    for (var B = C.child; B !== null; ) {
      if (B.tag === 5 || B.tag === 6) g.appendChild(B.stateNode);
      else if (B.tag !== 4 && B.child !== null) {
        B.child.return = B, B = B.child;
        continue;
      }
      if (B === C) break;
      for (; B.sibling === null; ) {
        if (B.return === null || B.return === C) return;
        B = B.return;
      }
      B.sibling.return = B.return, B = B.sibling;
    }
  }, oc = function() {
  }, ah = function(g, C, B, N) {
    var F = g.memoizedProps;
    if (F !== N) {
      g = C.stateNode, Uo(bs.current);
      var D = null;
      switch (B) {
        case "input":
          F = Wt(g, F), N = Wt(g, N), D = [];
          break;
        case "select":
          F = be({}, F, { value: void 0 }), N = be({}, N, { value: void 0 }), D = [];
          break;
        case "textarea":
          F = ct(g, F), N = ct(g, N), D = [];
          break;
        default:
          typeof F.onClick != "function" && typeof N.onClick == "function" && (g.onclick = qd);
      }
      Pe(B, N);
      var se;
      B = null;
      for (xt in F) if (!N.hasOwnProperty(xt) && F.hasOwnProperty(xt) && F[xt] != null) if (xt === "style") {
        var He = F[xt];
        for (se in He) He.hasOwnProperty(se) && (B || (B = {}), B[se] = "");
      } else xt !== "dangerouslySetInnerHTML" && xt !== "children" && xt !== "suppressContentEditableWarning" && xt !== "suppressHydrationWarning" && xt !== "autoFocus" && (i.hasOwnProperty(xt) ? D || (D = []) : (D = D || []).push(xt, null));
      for (xt in N) {
        var Qe = N[xt];
        if (He = F?.[xt], N.hasOwnProperty(xt) && Qe !== He && (Qe != null || He != null)) if (xt === "style") if (He) {
          for (se in He) !He.hasOwnProperty(se) || Qe && Qe.hasOwnProperty(se) || (B || (B = {}), B[se] = "");
          for (se in Qe) Qe.hasOwnProperty(se) && He[se] !== Qe[se] && (B || (B = {}), B[se] = Qe[se]);
        } else B || (D || (D = []), D.push(
          xt,
          B
        )), B = Qe;
        else xt === "dangerouslySetInnerHTML" ? (Qe = Qe ? Qe.__html : void 0, He = He ? He.__html : void 0, Qe != null && He !== Qe && (D = D || []).push(xt, Qe)) : xt === "children" ? typeof Qe != "string" && typeof Qe != "number" || (D = D || []).push(xt, "" + Qe) : xt !== "suppressContentEditableWarning" && xt !== "suppressHydrationWarning" && (i.hasOwnProperty(xt) ? (Qe != null && xt === "onScroll" && Dt("scroll", g), D || He === Qe || (D = [])) : (D = D || []).push(xt, Qe));
      }
      B && (D = D || []).push("style", B);
      var xt = D;
      (C.updateQueue = xt) && (C.flags |= 4);
    }
  }, uC = function(g, C, B, N) {
    B !== N && (C.flags |= 4);
  };
  function Nl(g, C) {
    if (!Ha) switch (g.tailMode) {
      case "hidden":
        C = g.tail;
        for (var B = null; C !== null; ) C.alternate !== null && (B = C), C = C.sibling;
        B === null ? g.tail = null : B.sibling = null;
        break;
      case "collapsed":
        B = g.tail;
        for (var N = null; B !== null; ) B.alternate !== null && (N = B), B = B.sibling;
        N === null ? C || g.tail === null ? g.tail = null : g.tail.sibling = null : N.sibling = null;
    }
  }
  function Lr(g) {
    var C = g.alternate !== null && g.alternate.child === g.child, B = 0, N = 0;
    if (C) for (var F = g.child; F !== null; ) B |= F.lanes | F.childLanes, N |= F.subtreeFlags & 14680064, N |= F.flags & 14680064, F.return = g, F = F.sibling;
    else for (F = g.child; F !== null; ) B |= F.lanes | F.childLanes, N |= F.subtreeFlags, N |= F.flags, F.return = g, F = F.sibling;
    return g.subtreeFlags |= N, g.childLanes = B, C;
  }
  function uv(g, C, B) {
    var N = C.pendingProps;
    switch (qu(C), C.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Lr(C), null;
      case 1:
        return Qa(C.type) && gl(), Lr(C), null;
      case 3:
        return N = C.stateNode, dd(), Ci(Qi), Ci(jo), ec(), N.pendingContext && (N.context = N.pendingContext, N.pendingContext = null), (g === null || g.child === null) && (Vc(C) ? C.flags |= 4 : g === null || g.memoizedState.isDehydrated && !(C.flags & 256) || (C.flags |= 1024, wl !== null && (CI(wl), wl = null))), oc(g, C), Lr(C), null;
      case 5:
        iC(C);
        var F = Uo(Mc.current);
        if (B = C.type, g !== null && C.stateNode != null) ah(g, C, B, N, F), g.ref !== C.ref && (C.flags |= 512, C.flags |= 2097152);
        else {
          if (!N) {
            if (C.stateNode === null) throw Error(t(166));
            return Lr(C), null;
          }
          if (g = Uo(bs.current), Vc(C)) {
            N = C.stateNode, B = C.type;
            var D = C.memoizedProps;
            switch (N[lo] = C, N[od] = D, g = (C.mode & 1) !== 0, B) {
              case "dialog":
                Dt("cancel", N), Dt("close", N);
                break;
              case "iframe":
              case "object":
              case "embed":
                Dt("load", N);
                break;
              case "video":
              case "audio":
                for (F = 0; F < Au.length; F++) Dt(Au[F], N);
                break;
              case "source":
                Dt("error", N);
                break;
              case "img":
              case "image":
              case "link":
                Dt(
                  "error",
                  N
                ), Dt("load", N);
                break;
              case "details":
                Dt("toggle", N);
                break;
              case "input":
                tn(N, D), Dt("invalid", N);
                break;
              case "select":
                N._wrapperState = { wasMultiple: !!D.multiple }, Dt("invalid", N);
                break;
              case "textarea":
                Ft(N, D), Dt("invalid", N);
            }
            Pe(B, D), F = null;
            for (var se in D) if (D.hasOwnProperty(se)) {
              var He = D[se];
              se === "children" ? typeof He == "string" ? N.textContent !== He && (D.suppressHydrationWarning !== !0 && rd(N.textContent, He, g), F = ["children", He]) : typeof He == "number" && N.textContent !== "" + He && (D.suppressHydrationWarning !== !0 && rd(
                N.textContent,
                He,
                g
              ), F = ["children", "" + He]) : i.hasOwnProperty(se) && He != null && se === "onScroll" && Dt("scroll", N);
            }
            switch (B) {
              case "input":
                Pn(N), nn(N, D, !0);
                break;
              case "textarea":
                Pn(N), zt(N);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof D.onClick == "function" && (N.onclick = qd);
            }
            N = F, C.updateQueue = N, N !== null && (C.flags |= 4);
          } else {
            se = F.nodeType === 9 ? F : F.ownerDocument, g === "http://www.w3.org/1999/xhtml" && (g = Sn(B)), g === "http://www.w3.org/1999/xhtml" ? B === "script" ? (g = se.createElement("div"), g.innerHTML = "<script><\/script>", g = g.removeChild(g.firstChild)) : typeof N.is == "string" ? g = se.createElement(B, { is: N.is }) : (g = se.createElement(B), B === "select" && (se = g, N.multiple ? se.multiple = !0 : N.size && (se.size = N.size))) : g = se.createElementNS(g, B), g[lo] = C, g[od] = N, Ec(g, C, !1, !1), C.stateNode = g;
            e: {
              switch (se = Ot(B, N), B) {
                case "dialog":
                  Dt("cancel", g), Dt("close", g), F = N;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Dt("load", g), F = N;
                  break;
                case "video":
                case "audio":
                  for (F = 0; F < Au.length; F++) Dt(Au[F], g);
                  F = N;
                  break;
                case "source":
                  Dt("error", g), F = N;
                  break;
                case "img":
                case "image":
                case "link":
                  Dt(
                    "error",
                    g
                  ), Dt("load", g), F = N;
                  break;
                case "details":
                  Dt("toggle", g), F = N;
                  break;
                case "input":
                  tn(g, N), F = Wt(g, N), Dt("invalid", g);
                  break;
                case "option":
                  F = N;
                  break;
                case "select":
                  g._wrapperState = { wasMultiple: !!N.multiple }, F = be({}, N, { value: void 0 }), Dt("invalid", g);
                  break;
                case "textarea":
                  Ft(g, N), F = ct(g, N), Dt("invalid", g);
                  break;
                default:
                  F = N;
              }
              Pe(B, F), He = F;
              for (D in He) if (He.hasOwnProperty(D)) {
                var Qe = He[D];
                D === "style" ? at(g, Qe) : D === "dangerouslySetInnerHTML" ? (Qe = Qe ? Qe.__html : void 0, Qe != null && qn(g, Qe)) : D === "children" ? typeof Qe == "string" ? (B !== "textarea" || Qe !== "") && qt(g, Qe) : typeof Qe == "number" && qt(g, "" + Qe) : D !== "suppressContentEditableWarning" && D !== "suppressHydrationWarning" && D !== "autoFocus" && (i.hasOwnProperty(D) ? Qe != null && D === "onScroll" && Dt("scroll", g) : Qe != null && E(g, D, Qe, se));
              }
              switch (B) {
                case "input":
                  Pn(g), nn(g, N, !1);
                  break;
                case "textarea":
                  Pn(g), zt(g);
                  break;
                case "option":
                  N.value != null && g.setAttribute("value", "" + ln(N.value));
                  break;
                case "select":
                  g.multiple = !!N.multiple, D = N.value, D != null ? oe(g, !!N.multiple, D, !1) : N.defaultValue != null && oe(
                    g,
                    !!N.multiple,
                    N.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof F.onClick == "function" && (g.onclick = qd);
              }
              switch (B) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  N = !!N.autoFocus;
                  break e;
                case "img":
                  N = !0;
                  break e;
                default:
                  N = !1;
              }
            }
            N && (C.flags |= 4);
          }
          C.ref !== null && (C.flags |= 512, C.flags |= 2097152);
        }
        return Lr(C), null;
      case 6:
        if (g && C.stateNode != null) uC(g, C, g.memoizedProps, N);
        else {
          if (typeof N != "string" && C.stateNode === null) throw Error(t(166));
          if (B = Uo(Mc.current), Uo(bs.current), Vc(C)) {
            if (N = C.stateNode, B = C.memoizedProps, N[lo] = C, (D = N.nodeValue !== B) && (g = vs, g !== null)) switch (g.tag) {
              case 3:
                rd(N.nodeValue, B, (g.mode & 1) !== 0);
                break;
              case 5:
                g.memoizedProps.suppressHydrationWarning !== !0 && rd(N.nodeValue, B, (g.mode & 1) !== 0);
            }
            D && (C.flags |= 4);
          } else N = (B.nodeType === 9 ? B : B.ownerDocument).createTextNode(N), N[lo] = C, C.stateNode = N;
        }
        return Lr(C), null;
      case 13:
        if (Ci(Xa), N = C.memoizedState, g === null || g.memoizedState !== null && g.memoizedState.dehydrated !== null) {
          if (Ha && ys !== null && C.mode & 1 && !(C.flags & 128)) Pl(), Ka(), C.flags |= 98560, D = !1;
          else if (D = Vc(C), N !== null && N.dehydrated !== null) {
            if (g === null) {
              if (!D) throw Error(t(318));
              if (D = C.memoizedState, D = D !== null ? D.dehydrated : null, !D) throw Error(t(317));
              D[lo] = C;
            } else Ka(), !(C.flags & 128) && (C.memoizedState = null), C.flags |= 4;
            Lr(C), D = !1;
          } else wl !== null && (CI(wl), wl = null), D = !0;
          if (!D) return C.flags & 65536 ? C : null;
        }
        return C.flags & 128 ? (C.lanes = B, C) : (N = N !== null, N !== (g !== null && g.memoizedState !== null) && N && (C.child.flags |= 8192, C.mode & 1 && (g === null || Xa.current & 1 ? Ss === 0 && (Ss = 3) : Um())), C.updateQueue !== null && (C.flags |= 4), Lr(C), null);
      case 4:
        return dd(), oc(g, C), g === null && Ks(C.stateNode.containerInfo), Lr(C), null;
      case 10:
        return Os(C.type._context), Lr(C), null;
      case 17:
        return Qa(C.type) && gl(), Lr(C), null;
      case 19:
        if (Ci(Xa), D = C.memoizedState, D === null) return Lr(C), null;
        if (N = (C.flags & 128) !== 0, se = D.rendering, se === null) if (N) Nl(D, !1);
        else {
          if (Ss !== 0 || g !== null && g.flags & 128) for (g = C.child; g !== null; ) {
            if (se = Ql(g), se !== null) {
              for (C.flags |= 128, Nl(D, !1), N = se.updateQueue, N !== null && (C.updateQueue = N, C.flags |= 4), C.subtreeFlags = 0, N = B, B = C.child; B !== null; ) D = B, g = N, D.flags &= 14680066, se = D.alternate, se === null ? (D.childLanes = 0, D.lanes = g, D.child = null, D.subtreeFlags = 0, D.memoizedProps = null, D.memoizedState = null, D.updateQueue = null, D.dependencies = null, D.stateNode = null) : (D.childLanes = se.childLanes, D.lanes = se.lanes, D.child = se.child, D.subtreeFlags = 0, D.deletions = null, D.memoizedProps = se.memoizedProps, D.memoizedState = se.memoizedState, D.updateQueue = se.updateQueue, D.type = se.type, g = se.dependencies, D.dependencies = g === null ? null : { lanes: g.lanes, firstContext: g.firstContext }), B = B.sibling;
              return Gr(Xa, Xa.current & 1 | 2), C.child;
            }
            g = g.sibling;
          }
          D.tail !== null && Yt() > fC && (C.flags |= 128, N = !0, Nl(D, !1), C.lanes = 4194304);
        }
        else {
          if (!N) if (g = Ql(se), g !== null) {
            if (C.flags |= 128, N = !0, B = g.updateQueue, B !== null && (C.updateQueue = B, C.flags |= 4), Nl(D, !0), D.tail === null && D.tailMode === "hidden" && !se.alternate && !Ha) return Lr(C), null;
          } else 2 * Yt() - D.renderingStartTime > fC && B !== 1073741824 && (C.flags |= 128, N = !0, Nl(D, !1), C.lanes = 4194304);
          D.isBackwards ? (se.sibling = C.child, C.child = se) : (B = D.last, B !== null ? B.sibling = se : C.child = se, D.last = se);
        }
        return D.tail !== null ? (C = D.tail, D.rendering = C, D.tail = C.sibling, D.renderingStartTime = Yt(), C.sibling = null, B = Xa.current, Gr(Xa, N ? B & 1 | 2 : B & 1), C) : (Lr(C), null);
      case 22:
      case 23:
        return hI(), N = C.memoizedState !== null, g !== null && g.memoizedState !== null !== N && (C.flags |= 8192), N && C.mode & 1 ? $o & 1073741824 && (Lr(C), C.subtreeFlags & 6 && (C.flags |= 8192)) : Lr(C), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, C.tag));
  }
  function cv(g, C) {
    switch (qu(C), C.tag) {
      case 1:
        return Qa(C.type) && gl(), g = C.flags, g & 65536 ? (C.flags = g & -65537 | 128, C) : null;
      case 3:
        return dd(), Ci(Qi), Ci(jo), ec(), g = C.flags, g & 65536 && !(g & 128) ? (C.flags = g & -65537 | 128, C) : null;
      case 5:
        return iC(C), null;
      case 13:
        if (Ci(Xa), g = C.memoizedState, g !== null && g.dehydrated !== null) {
          if (C.alternate === null) throw Error(t(340));
          Ka();
        }
        return g = C.flags, g & 65536 ? (C.flags = g & -65537 | 128, C) : null;
      case 19:
        return Ci(Xa), null;
      case 4:
        return dd(), null;
      case 10:
        return Os(C.type._context), null;
      case 22:
      case 23:
        return hI(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var of = !1, Bs = !1, Km = typeof WeakSet == "function" ? WeakSet : Set, oi = null;
  function cC(g, C) {
    var B = g.ref;
    if (B !== null) if (typeof B == "function") try {
      B(null);
    } catch (N) {
      Da(g, C, N);
    }
    else B.current = null;
  }
  function gv(g, C, B) {
    try {
      B();
    } catch (N) {
      Da(g, C, N);
    }
  }
  var dv = !1;
  function Lm(g, C) {
    if (ad = rl, g = za(), Qr(g)) {
      if ("selectionStart" in g) var B = { start: g.selectionStart, end: g.selectionEnd };
      else e: {
        B = (B = g.ownerDocument) && B.defaultView || window;
        var N = B.getSelection && B.getSelection();
        if (N && N.rangeCount !== 0) {
          B = N.anchorNode;
          var F = N.anchorOffset, D = N.focusNode;
          N = N.focusOffset;
          try {
            B.nodeType, D.nodeType;
          } catch {
            B = null;
            break e;
          }
          var se = 0, He = -1, Qe = -1, xt = 0, Cn = 0, Gn = g, pn = null;
          t: for (; ; ) {
            for (var Dn; Gn !== B || F !== 0 && Gn.nodeType !== 3 || (He = se + F), Gn !== D || N !== 0 && Gn.nodeType !== 3 || (Qe = se + N), Gn.nodeType === 3 && (se += Gn.nodeValue.length), (Dn = Gn.firstChild) !== null; )
              pn = Gn, Gn = Dn;
            for (; ; ) {
              if (Gn === g) break t;
              if (pn === B && ++xt === F && (He = se), pn === D && ++Cn === N && (Qe = se), (Dn = Gn.nextSibling) !== null) break;
              Gn = pn, pn = Gn.parentNode;
            }
            Gn = Dn;
          }
          B = He === -1 || Qe === -1 ? null : { start: He, end: Qe };
        } else B = null;
      }
      B = B || { start: 0, end: 0 };
    } else B = null;
    for (qC = { focusedElem: g, selectionRange: B }, rl = !1, oi = C; oi !== null; ) if (C = oi, g = C.child, (C.subtreeFlags & 1028) !== 0 && g !== null) g.return = C, oi = g;
    else for (; oi !== null; ) {
      C = oi;
      try {
        var ei = C.alternate;
        if (C.flags & 1024) switch (C.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (ei !== null) {
              var bi = ei.memoizedProps, Xo = ei.memoizedState, dt = C.stateNode, tt = dt.getSnapshotBeforeUpdate(C.elementType === C.type ? bi : cs(C.type, bi), Xo);
              dt.__reactInternalSnapshotBeforeUpdate = tt;
            }
            break;
          case 3:
            var yt = C.stateNode.containerInfo;
            yt.nodeType === 1 ? yt.textContent = "" : yt.nodeType === 9 && yt.documentElement && yt.removeChild(yt.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(t(163));
        }
      } catch (Mn) {
        Da(C, C.return, Mn);
      }
      if (g = C.sibling, g !== null) {
        g.return = C.return, oi = g;
        break;
      }
      oi = C.return;
    }
    return ei = dv, dv = !1, ei;
  }
  function Sp(g, C, B) {
    var N = C.updateQueue;
    if (N = N !== null ? N.lastEffect : null, N !== null) {
      var F = N = N.next;
      do {
        if ((F.tag & g) === g) {
          var D = F.destroy;
          F.destroy = void 0, D !== void 0 && gv(C, B, D);
        }
        F = F.next;
      } while (F !== N);
    }
  }
  function sf(g, C) {
    if (C = C.updateQueue, C = C !== null ? C.lastEffect : null, C !== null) {
      var B = C = C.next;
      do {
        if ((B.tag & g) === g) {
          var N = B.create;
          B.destroy = N();
        }
        B = B.next;
      } while (B !== C);
    }
  }
  function Zp(g) {
    var C = g.ref;
    if (C !== null) {
      var B = g.stateNode;
      switch (g.tag) {
        case 5:
          g = B;
          break;
        default:
          g = B;
      }
      typeof C == "function" ? C(g) : C.current = g;
    }
  }
  function Iv(g) {
    var C = g.alternate;
    C !== null && (g.alternate = null, Iv(C)), g.child = null, g.deletions = null, g.sibling = null, g.tag === 5 && (C = g.stateNode, C !== null && (delete C[lo], delete C[od], delete C[pg], delete C[$C], delete C[sd])), g.stateNode = null, g.return = null, g.dependencies = null, g.memoizedProps = null, g.memoizedState = null, g.pendingProps = null, g.stateNode = null, g.updateQueue = null;
  }
  function Hb(g) {
    return g.tag === 5 || g.tag === 3 || g.tag === 4;
  }
  function gC(g) {
    e: for (; ; ) {
      for (; g.sibling === null; ) {
        if (g.return === null || Hb(g.return)) return null;
        g = g.return;
      }
      for (g.sibling.return = g.return, g = g.sibling; g.tag !== 5 && g.tag !== 6 && g.tag !== 18; ) {
        if (g.flags & 2 || g.child === null || g.tag === 4) continue e;
        g.child.return = g, g = g.child;
      }
      if (!(g.flags & 2)) return g.stateNode;
    }
  }
  function dC(g, C, B) {
    var N = g.tag;
    if (N === 5 || N === 6) g = g.stateNode, C ? B.nodeType === 8 ? B.parentNode.insertBefore(g, C) : B.insertBefore(g, C) : (B.nodeType === 8 ? (C = B.parentNode, C.insertBefore(g, B)) : (C = B, C.appendChild(g)), B = B._reactRootContainer, B != null || C.onclick !== null || (C.onclick = qd));
    else if (N !== 4 && (g = g.child, g !== null)) for (dC(g, C, B), g = g.sibling; g !== null; ) dC(g, C, B), g = g.sibling;
  }
  function IC(g, C, B) {
    var N = g.tag;
    if (N === 5 || N === 6) g = g.stateNode, C ? B.insertBefore(g, C) : B.appendChild(g);
    else if (N !== 4 && (g = g.child, g !== null)) for (IC(g, C, B), g = g.sibling; g !== null; ) IC(g, C, B), g = g.sibling;
  }
  var Wo = null, Wa = !1;
  function no(g, C, B) {
    for (B = B.child; B !== null; ) $l(g, C, B), B = B.sibling;
  }
  function $l(g, C, B) {
    if (Ln && typeof Ln.onCommitFiberUnmount == "function") try {
      Ln.onCommitFiberUnmount(pr, B);
    } catch {
    }
    switch (B.tag) {
      case 5:
        Bs || cC(B, C);
      case 6:
        var N = Wo, F = Wa;
        Wo = null, no(g, C, B), Wo = N, Wa = F, Wo !== null && (Wa ? (g = Wo, B = B.stateNode, g.nodeType === 8 ? g.parentNode.removeChild(B) : g.removeChild(B)) : Wo.removeChild(B.stateNode));
        break;
      case 18:
        Wo !== null && (Wa ? (g = Wo, B = B.stateNode, g.nodeType === 8 ? eC(g.parentNode, B) : g.nodeType === 1 && eC(g, B), gu(g)) : eC(Wo, B.stateNode));
        break;
      case 4:
        N = Wo, F = Wa, Wo = B.stateNode.containerInfo, Wa = !0, no(g, C, B), Wo = N, Wa = F;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Bs && (N = B.updateQueue, N !== null && (N = N.lastEffect, N !== null))) {
          F = N = N.next;
          do {
            var D = F, se = D.destroy;
            D = D.tag, se !== void 0 && (D & 2 || D & 4) && gv(B, C, se), F = F.next;
          } while (F !== N);
        }
        no(g, C, B);
        break;
      case 1:
        if (!Bs && (cC(B, C), N = B.stateNode, typeof N.componentWillUnmount == "function")) try {
          N.props = B.memoizedProps, N.state = B.memoizedState, N.componentWillUnmount();
        } catch (He) {
          Da(B, C, He);
        }
        no(g, C, B);
        break;
      case 21:
        no(g, C, B);
        break;
      case 22:
        B.mode & 1 ? (Bs = (N = Bs) || B.memoizedState !== null, no(g, C, B), Bs = N) : no(g, C, B);
        break;
      default:
        no(g, C, B);
    }
  }
  function Ru(g) {
    var C = g.updateQueue;
    if (C !== null) {
      g.updateQueue = null;
      var B = g.stateNode;
      B === null && (B = g.stateNode = new Km()), C.forEach(function(N) {
        var F = mv.bind(null, g, N);
        B.has(N) || (B.add(N), N.then(F, F));
      });
    }
  }
  function Vo(g, C) {
    var B = C.deletions;
    if (B !== null) for (var N = 0; N < B.length; N++) {
      var F = B[N];
      try {
        var D = g, se = C, He = se;
        e: for (; He !== null; ) {
          switch (He.tag) {
            case 5:
              Wo = He.stateNode, Wa = !1;
              break e;
            case 3:
              Wo = He.stateNode.containerInfo, Wa = !0;
              break e;
            case 4:
              Wo = He.stateNode.containerInfo, Wa = !0;
              break e;
          }
          He = He.return;
        }
        if (Wo === null) throw Error(t(160));
        $l(D, se, F), Wo = null, Wa = !1;
        var Qe = F.alternate;
        Qe !== null && (Qe.return = null), F.return = null;
      } catch (xt) {
        Da(F, C, xt);
      }
    }
    if (C.subtreeFlags & 12854) for (C = C.child; C !== null; ) dI(C, g), C = C.sibling;
  }
  function dI(g, C) {
    var B = g.alternate, N = g.flags;
    switch (g.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Vo(C, g), Cd(g), N & 4) {
          try {
            Sp(3, g, g.return), sf(3, g);
          } catch (bi) {
            Da(g, g.return, bi);
          }
          try {
            Sp(5, g, g.return);
          } catch (bi) {
            Da(g, g.return, bi);
          }
        }
        break;
      case 1:
        Vo(C, g), Cd(g), N & 512 && B !== null && cC(B, B.return);
        break;
      case 5:
        if (Vo(C, g), Cd(g), N & 512 && B !== null && cC(B, B.return), g.flags & 32) {
          var F = g.stateNode;
          try {
            qt(F, "");
          } catch (bi) {
            Da(g, g.return, bi);
          }
        }
        if (N & 4 && (F = g.stateNode, F != null)) {
          var D = g.memoizedProps, se = B !== null ? B.memoizedProps : D, He = g.type, Qe = g.updateQueue;
          if (g.updateQueue = null, Qe !== null) try {
            He === "input" && D.type === "radio" && D.name != null && Gt(F, D), Ot(He, se);
            var xt = Ot(He, D);
            for (se = 0; se < Qe.length; se += 2) {
              var Cn = Qe[se], Gn = Qe[se + 1];
              Cn === "style" ? at(F, Gn) : Cn === "dangerouslySetInnerHTML" ? qn(F, Gn) : Cn === "children" ? qt(F, Gn) : E(F, Cn, Gn, xt);
            }
            switch (He) {
              case "input":
                Rn(F, D);
                break;
              case "textarea":
                pt(F, D);
                break;
              case "select":
                var pn = F._wrapperState.wasMultiple;
                F._wrapperState.wasMultiple = !!D.multiple;
                var Dn = D.value;
                Dn != null ? oe(F, !!D.multiple, Dn, !1) : pn !== !!D.multiple && (D.defaultValue != null ? oe(
                  F,
                  !!D.multiple,
                  D.defaultValue,
                  !0
                ) : oe(F, !!D.multiple, D.multiple ? [] : "", !1));
            }
            F[od] = D;
          } catch (bi) {
            Da(g, g.return, bi);
          }
        }
        break;
      case 6:
        if (Vo(C, g), Cd(g), N & 4) {
          if (g.stateNode === null) throw Error(t(162));
          F = g.stateNode, D = g.memoizedProps;
          try {
            F.nodeValue = D;
          } catch (bi) {
            Da(g, g.return, bi);
          }
        }
        break;
      case 3:
        if (Vo(C, g), Cd(g), N & 4 && B !== null && B.memoizedState.isDehydrated) try {
          gu(C.containerInfo);
        } catch (bi) {
          Da(g, g.return, bi);
        }
        break;
      case 4:
        Vo(C, g), Cd(g);
        break;
      case 13:
        Vo(C, g), Cd(g), F = g.child, F.flags & 8192 && (D = F.memoizedState !== null, F.stateNode.isHidden = D, !D || F.alternate !== null && F.alternate.memoizedState !== null || (df = Yt())), N & 4 && Ru(g);
        break;
      case 22:
        if (Cn = B !== null && B.memoizedState !== null, g.mode & 1 ? (Bs = (xt = Bs) || Cn, Vo(C, g), Bs = xt) : Vo(C, g), Cd(g), N & 8192) {
          if (xt = g.memoizedState !== null, (g.stateNode.isHidden = xt) && !Cn && g.mode & 1) for (oi = g, Cn = g.child; Cn !== null; ) {
            for (Gn = oi = Cn; oi !== null; ) {
              switch (pn = oi, Dn = pn.child, pn.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Sp(4, pn, pn.return);
                  break;
                case 1:
                  cC(pn, pn.return);
                  var ei = pn.stateNode;
                  if (typeof ei.componentWillUnmount == "function") {
                    N = pn, B = pn.return;
                    try {
                      C = N, ei.props = C.memoizedProps, ei.state = C.memoizedState, ei.componentWillUnmount();
                    } catch (bi) {
                      Da(N, B, bi);
                    }
                  }
                  break;
                case 5:
                  cC(pn, pn.return);
                  break;
                case 22:
                  if (pn.memoizedState !== null) {
                    hC(Gn);
                    continue;
                  }
              }
              Dn !== null ? (Dn.return = pn, oi = Dn) : hC(Gn);
            }
            Cn = Cn.sibling;
          }
          e: for (Cn = null, Gn = g; ; ) {
            if (Gn.tag === 5) {
              if (Cn === null) {
                Cn = Gn;
                try {
                  F = Gn.stateNode, xt ? (D = F.style, typeof D.setProperty == "function" ? D.setProperty("display", "none", "important") : D.display = "none") : (He = Gn.stateNode, Qe = Gn.memoizedProps.style, se = Qe != null && Qe.hasOwnProperty("display") ? Qe.display : null, He.style.display = Ie("display", se));
                } catch (bi) {
                  Da(g, g.return, bi);
                }
              }
            } else if (Gn.tag === 6) {
              if (Cn === null) try {
                Gn.stateNode.nodeValue = xt ? "" : Gn.memoizedProps;
              } catch (bi) {
                Da(g, g.return, bi);
              }
            } else if ((Gn.tag !== 22 && Gn.tag !== 23 || Gn.memoizedState === null || Gn === g) && Gn.child !== null) {
              Gn.child.return = Gn, Gn = Gn.child;
              continue;
            }
            if (Gn === g) break e;
            for (; Gn.sibling === null; ) {
              if (Gn.return === null || Gn.return === g) break e;
              Cn === Gn && (Cn = null), Gn = Gn.return;
            }
            Cn === Gn && (Cn = null), Gn.sibling.return = Gn.return, Gn = Gn.sibling;
          }
        }
        break;
      case 19:
        Vo(C, g), Cd(g), N & 4 && Ru(g);
        break;
      case 21:
        break;
      default:
        Vo(
          C,
          g
        ), Cd(g);
    }
  }
  function Cd(g) {
    var C = g.flags;
    if (C & 2) {
      try {
        e: {
          for (var B = g.return; B !== null; ) {
            if (Hb(B)) {
              var N = B;
              break e;
            }
            B = B.return;
          }
          throw Error(t(160));
        }
        switch (N.tag) {
          case 5:
            var F = N.stateNode;
            N.flags & 32 && (qt(F, ""), N.flags &= -33);
            var D = gC(g);
            IC(g, D, F);
            break;
          case 3:
          case 4:
            var se = N.stateNode.containerInfo, He = gC(g);
            dC(g, He, se);
            break;
          default:
            throw Error(t(161));
        }
      } catch (Qe) {
        Da(g, g.return, Qe);
      }
      g.flags &= -3;
    }
    C & 4096 && (g.flags &= -4097);
  }
  function fB(g, C, B) {
    oi = g, CC(g);
  }
  function CC(g, C, B) {
    for (var N = (g.mode & 1) !== 0; oi !== null; ) {
      var F = oi, D = F.child;
      if (F.tag === 22 && N) {
        var se = F.memoizedState !== null || of;
        if (!se) {
          var He = F.alternate, Qe = He !== null && He.memoizedState !== null || Bs;
          He = of;
          var xt = Bs;
          if (of = se, (Bs = Qe) && !xt) for (oi = F; oi !== null; ) se = oi, Qe = se.child, se.tag === 22 && se.memoizedState !== null ? wp(F) : Qe !== null ? (Qe.return = se, oi = Qe) : wp(F);
          for (; D !== null; ) oi = D, CC(D), D = D.sibling;
          oi = F, of = He, Bs = xt;
        }
        km(g);
      } else F.subtreeFlags & 8772 && D !== null ? (D.return = F, oi = D) : km(g);
    }
  }
  function km(g) {
    for (; oi !== null; ) {
      var C = oi;
      if (C.flags & 8772) {
        var B = C.alternate;
        try {
          if (C.flags & 8772) switch (C.tag) {
            case 0:
            case 11:
            case 15:
              Bs || sf(5, C);
              break;
            case 1:
              var N = C.stateNode;
              if (C.flags & 4 && !Bs) if (B === null) N.componentDidMount();
              else {
                var F = C.elementType === C.type ? B.memoizedProps : cs(C.type, B.memoizedProps);
                N.componentDidUpdate(F, B.memoizedState, N.__reactInternalSnapshotBeforeUpdate);
              }
              var D = C.updateQueue;
              D !== null && nC(C, D, N);
              break;
            case 3:
              var se = C.updateQueue;
              if (se !== null) {
                if (B = null, C.child !== null) switch (C.child.tag) {
                  case 5:
                    B = C.child.stateNode;
                    break;
                  case 1:
                    B = C.child.stateNode;
                }
                nC(C, se, B);
              }
              break;
            case 5:
              var He = C.stateNode;
              if (B === null && C.flags & 4) {
                B = He;
                var Qe = C.memoizedProps;
                switch (C.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    Qe.autoFocus && B.focus();
                    break;
                  case "img":
                    Qe.src && (B.src = Qe.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (C.memoizedState === null) {
                var xt = C.alternate;
                if (xt !== null) {
                  var Cn = xt.memoizedState;
                  if (Cn !== null) {
                    var Gn = Cn.dehydrated;
                    Gn !== null && gu(Gn);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(t(163));
          }
          Bs || C.flags & 512 && Zp(C);
        } catch (pn) {
          Da(C, C.return, pn);
        }
      }
      if (C === g) {
        oi = null;
        break;
      }
      if (B = C.sibling, B !== null) {
        B.return = C.return, oi = B;
        break;
      }
      oi = C.return;
    }
  }
  function hC(g) {
    for (; oi !== null; ) {
      var C = oi;
      if (C === g) {
        oi = null;
        break;
      }
      var B = C.sibling;
      if (B !== null) {
        B.return = C.return, oi = B;
        break;
      }
      oi = C.return;
    }
  }
  function wp(g) {
    for (; oi !== null; ) {
      var C = oi;
      try {
        switch (C.tag) {
          case 0:
          case 11:
          case 15:
            var B = C.return;
            try {
              sf(4, C);
            } catch (Qe) {
              Da(C, B, Qe);
            }
            break;
          case 1:
            var N = C.stateNode;
            if (typeof N.componentDidMount == "function") {
              var F = C.return;
              try {
                N.componentDidMount();
              } catch (Qe) {
                Da(C, F, Qe);
              }
            }
            var D = C.return;
            try {
              Zp(C);
            } catch (Qe) {
              Da(C, D, Qe);
            }
            break;
          case 5:
            var se = C.return;
            try {
              Zp(C);
            } catch (Qe) {
              Da(C, se, Qe);
            }
        }
      } catch (Qe) {
        Da(C, C.return, Qe);
      }
      if (C === g) {
        oi = null;
        break;
      }
      var He = C.sibling;
      if (He !== null) {
        He.return = C.return, oi = He;
        break;
      }
      oi = C.return;
    }
  }
  var Xb = Math.ceil, lf = _.ReactCurrentDispatcher, uf = _.ReactCurrentOwner, sc = _.ReactCurrentBatchConfig, Sr = 0, Vr = null, Pr = null, ga = 0, $o = 0, xu = ar(0), Ss = 0, Rp = null, oh = 0, Dm = 0, cf = 0, gf = null, Zs = null, df = 0, fC = 1 / 0, wg = null, If = !1, xp = null, pC = null, mC = !1, hd = null, AC = 0, Cf = 0, sh = null, Wp = -1, hf = 0;
  function No() {
    return Sr & 6 ? Yt() : Wp !== -1 ? Wp : Wp = Yt();
  }
  function Tc(g) {
    return g.mode & 1 ? Sr & 2 && ga !== 0 ? ga & -ga : lv.transition !== null ? (hf === 0 && (hf = un()), hf) : (g = cn, g !== 0 || (g = window.event, g = g === void 0 ? 16 : kC(g.type)), g) : 1;
  }
  function ka(g, C, B, N) {
    if (50 < Cf) throw Cf = 0, sh = null, Error(t(185));
    Si(g, B, N), (!(Sr & 2) || g !== Vr) && (g === Vr && (!(Sr & 2) && (Dm |= B), Ss === 4 && _c(g, ga)), Ya(g, N), B === 1 && Sr === 0 && !(C.mode & 1) && (fC = Yt() + 500, Wc && Us()));
  }
  function Ya(g, C) {
    var B = g.callbackNode;
    $t(g, C);
    var N = Be(g, g === Vr ? ga : 0);
    if (N === 0) B !== null && Nt(B), g.callbackNode = null, g.callbackPriority = 0;
    else if (C = N & -N, g.callbackPriority !== C) {
      if (B != null && Nt(B), C === 1) g.tag === 0 ? mg(Vp.bind(null, g)) : tI(Vp.bind(null, g)), $h(function() {
        !(Sr & 6) && Us();
      }), B = null;
      else {
        switch (kn(N)) {
          case 1:
            B = Fn;
            break;
          case 4:
            B = _n;
            break;
          case 16:
            B = Xn;
            break;
          case 536870912:
            B = Ei;
            break;
          default:
            B = Xn;
        }
        B = vv(B, II.bind(null, g));
      }
      g.callbackPriority = C, g.callbackNode = B;
    }
  }
  function II(g, C) {
    if (Wp = -1, hf = 0, Sr & 6) throw Error(t(327));
    var B = g.callbackNode;
    if (vC() && g.callbackNode !== B) return null;
    var N = Be(g, g === Vr ? ga : 0);
    if (N === 0) return null;
    if (N & 30 || N & g.expiredLanes || C) C = ff(g, N);
    else {
      C = N;
      var F = Sr;
      Sr |= 2;
      var D = uh();
      (Vr !== g || ga !== C) && (wg = null, fC = Yt() + 500, fI(g, C));
      do
        try {
          Np();
          break;
        } catch (He) {
          hv(g, He);
        }
      while (!0);
      Ro(), lf.current = D, Sr = F, Pr !== null ? C = 0 : (Vr = null, ga = 0, C = Ss);
    }
    if (C !== 0) {
      if (C === 2 && (F = In(g), F !== 0 && (N = F, C = lh(g, F))), C === 1) throw B = Rp, fI(g, 0), _c(g, N), Ya(g, Yt()), B;
      if (C === 6) _c(g, N);
      else {
        if (F = g.current.alternate, !(N & 30) && !Cv(F) && (C = ff(g, N), C === 2 && (D = In(g), D !== 0 && (N = D, C = lh(g, D))), C === 1)) throw B = Rp, fI(g, 0), _c(g, N), Ya(g, Yt()), B;
        switch (g.finishedWork = F, g.finishedLanes = N, C) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            pd(g, Zs, wg);
            break;
          case 3:
            if (_c(g, N), (N & 130023424) === N && (C = df + 500 - Yt(), 10 < C)) {
              if (Be(g, 0) !== 0) break;
              if (F = g.suspendedLanes, (F & N) !== N) {
                No(), g.pingedLanes |= g.suspendedLanes & F;
                break;
              }
              g.timeoutHandle = $d(pd.bind(null, g, Zs, wg), C);
              break;
            }
            pd(g, Zs, wg);
            break;
          case 4:
            if (_c(g, N), (N & 4194240) === N) break;
            for (C = g.eventTimes, F = -1; 0 < N; ) {
              var se = 31 - ue(N);
              D = 1 << se, se = C[se], se > F && (F = se), N &= ~D;
            }
            if (N = F, N = Yt() - N, N = (120 > N ? 120 : 480 > N ? 480 : 1080 > N ? 1080 : 1920 > N ? 1920 : 3e3 > N ? 3e3 : 4320 > N ? 4320 : 1960 * Xb(N / 1960)) - N, 10 < N) {
              g.timeoutHandle = $d(pd.bind(null, g, Zs, wg), N);
              break;
            }
            pd(g, Zs, wg);
            break;
          case 5:
            pd(g, Zs, wg);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return Ya(g, Yt()), g.callbackNode === B ? II.bind(null, g) : null;
  }
  function lh(g, C) {
    var B = gf;
    return g.current.memoizedState.isDehydrated && (fI(g, C).flags |= 256), g = ff(g, C), g !== 2 && (C = Zs, Zs = B, C !== null && CI(C)), g;
  }
  function CI(g) {
    Zs === null ? Zs = g : Zs.push.apply(Zs, g);
  }
  function Cv(g) {
    for (var C = g; ; ) {
      if (C.flags & 16384) {
        var B = C.updateQueue;
        if (B !== null && (B = B.stores, B !== null)) for (var N = 0; N < B.length; N++) {
          var F = B[N], D = F.getSnapshot;
          F = F.value;
          try {
            if (!Ts(D(), F)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (B = C.child, C.subtreeFlags & 16384 && B !== null) B.return = C, C = B;
      else {
        if (C === g) break;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === g) return !0;
          C = C.return;
        }
        C.sibling.return = C.return, C = C.sibling;
      }
    }
    return !0;
  }
  function _c(g, C) {
    for (C &= ~cf, C &= ~Dm, g.suspendedLanes |= C, g.pingedLanes &= ~C, g = g.expirationTimes; 0 < C; ) {
      var B = 31 - ue(C), N = 1 << B;
      g[B] = -1, C &= ~N;
    }
  }
  function Vp(g) {
    if (Sr & 6) throw Error(t(327));
    vC();
    var C = Be(g, 0);
    if (!(C & 1)) return Ya(g, Yt()), null;
    var B = ff(g, C);
    if (g.tag !== 0 && B === 2) {
      var N = In(g);
      N !== 0 && (C = N, B = lh(g, N));
    }
    if (B === 1) throw B = Rp, fI(g, 0), _c(g, C), Ya(g, Yt()), B;
    if (B === 6) throw Error(t(345));
    return g.finishedWork = g.current.alternate, g.finishedLanes = C, pd(g, Zs, wg), Ya(g, Yt()), null;
  }
  function Rg(g, C) {
    var B = Sr;
    Sr |= 1;
    try {
      return g(C);
    } finally {
      Sr = B, Sr === 0 && (fC = Yt() + 500, Wc && Us());
    }
  }
  function fd(g) {
    hd !== null && hd.tag === 0 && !(Sr & 6) && vC();
    var C = Sr;
    Sr |= 1;
    var B = sc.transition, N = cn;
    try {
      if (sc.transition = null, cn = 1, g) return g();
    } finally {
      cn = N, sc.transition = B, Sr = C, !(Sr & 6) && Us();
    }
  }
  function hI() {
    $o = xu.current, Ci(xu);
  }
  function fI(g, C) {
    g.finishedWork = null, g.finishedLanes = 0;
    var B = g.timeoutHandle;
    if (B !== -1 && (g.timeoutHandle = -1, hg(B)), Pr !== null) for (B = Pr.return; B !== null; ) {
      var N = B;
      switch (qu(N), N.tag) {
        case 1:
          N = N.type.childContextTypes, N != null && gl();
          break;
        case 3:
          dd(), Ci(Qi), Ci(jo), ec();
          break;
        case 5:
          iC(N);
          break;
        case 4:
          dd();
          break;
        case 13:
          Ci(Xa);
          break;
        case 19:
          Ci(Xa);
          break;
        case 10:
          Os(N.type._context);
          break;
        case 22:
        case 23:
          hI();
      }
      B = B.return;
    }
    if (Vr = g, Pr = g = md(g.current, null), ga = $o = C, Ss = 0, Rp = null, cf = Dm = oh = 0, Zs = gf = null, qa !== null) {
      for (C = 0; C < qa.length; C++) if (B = qa[C], N = B.interleaved, N !== null) {
        B.interleaved = null;
        var F = N.next, D = B.pending;
        if (D !== null) {
          var se = D.next;
          D.next = F, N.next = se;
        }
        B.pending = N;
      }
      qa = null;
    }
    return g;
  }
  function hv(g, C) {
    do {
      var B = Pr;
      try {
        if (Ro(), oI.current = Zu, Or) {
          for (var N = Kn.memoizedState; N !== null; ) {
            var F = N.queue;
            F !== null && (F.pending = null), N = N.next;
          }
          Or = !1;
        }
        if (tc = 0, vi = Zi = Kn = null, La = !1, yg = 0, uf.current = null, B === null || B.return === null) {
          Ss = 1, Rp = C, Pr = null;
          break;
        }
        e: {
          var D = g, se = B.return, He = B, Qe = C;
          if (C = ga, He.flags |= 32768, Qe !== null && typeof Qe == "object" && typeof Qe.then == "function") {
            var xt = Qe, Cn = He, Gn = Cn.tag;
            if (!(Cn.mode & 1) && (Gn === 0 || Gn === 11 || Gn === 15)) {
              var pn = Cn.alternate;
              pn ? (Cn.updateQueue = pn.updateQueue, Cn.memoizedState = pn.memoizedState, Cn.lanes = pn.lanes) : (Cn.updateQueue = null, Cn.memoizedState = null);
            }
            var Dn = Jn(se);
            if (Dn !== null) {
              Dn.flags &= -257, mi(Dn, se, He, D, C), Dn.mode & 1 && Wn(D, xt, C), C = Dn, Qe = xt;
              var ei = C.updateQueue;
              if (ei === null) {
                var bi = /* @__PURE__ */ new Set();
                bi.add(Qe), C.updateQueue = bi;
              } else ei.add(Qe);
              break e;
            } else {
              if (!(C & 1)) {
                Wn(D, xt, C), Um();
                break e;
              }
              Qe = Error(t(426));
            }
          } else if (Ha && He.mode & 1) {
            var Xo = Jn(se);
            if (Xo !== null) {
              !(Xo.flags & 65536) && (Xo.flags |= 256), mi(Xo, se, He, D, C), co(Y(Qe, He));
              break e;
            }
          }
          D = Qe = Y(Qe, He), Ss !== 4 && (Ss = 2), gf === null ? gf = [D] : gf.push(D), D = se;
          do {
            switch (D.tag) {
              case 3:
                D.flags |= 65536, C &= -C, D.lanes |= C;
                var dt = nt(D, Qe, C);
                rI(D, dt);
                break e;
              case 1:
                He = Qe;
                var tt = D.type, yt = D.stateNode;
                if (!(D.flags & 128) && (typeof tt.getDerivedStateFromError == "function" || yt !== null && typeof yt.componentDidCatch == "function" && (pC === null || !pC.has(yt)))) {
                  D.flags |= 65536, C &= -C, D.lanes |= C;
                  var Mn = kt(D, He, C);
                  rI(D, Mn);
                  break e;
                }
            }
            D = D.return;
          } while (D !== null);
        }
        pf(B);
      } catch (Vi) {
        C = Vi, Pr === B && B !== null && (Pr = B = B.return);
        continue;
      }
      break;
    } while (!0);
  }
  function uh() {
    var g = lf.current;
    return lf.current = Zu, g === null ? Zu : g;
  }
  function Um() {
    (Ss === 0 || Ss === 3 || Ss === 2) && (Ss = 4), Vr === null || !(oh & 268435455) && !(Dm & 268435455) || _c(Vr, ga);
  }
  function ff(g, C) {
    var B = Sr;
    Sr |= 2;
    var N = uh();
    (Vr !== g || ga !== C) && (wg = null, fI(g, C));
    do
      try {
        pB();
        break;
      } catch (F) {
        hv(g, F);
      }
    while (!0);
    if (Ro(), Sr = B, lf.current = N, Pr !== null) throw Error(t(261));
    return Vr = null, ga = 0, Ss;
  }
  function pB() {
    for (; Pr !== null; ) pI(Pr);
  }
  function Np() {
    for (; Pr !== null && !Kt(); ) pI(Pr);
  }
  function pI(g) {
    var C = Av(g.alternate, g, $o);
    g.memoizedProps = g.pendingProps, C === null ? pf(g) : Pr = C, uf.current = null;
  }
  function pf(g) {
    var C = g;
    do {
      var B = C.alternate;
      if (g = C.return, C.flags & 32768) {
        if (B = cv(B, C), B !== null) {
          B.flags &= 32767, Pr = B;
          return;
        }
        if (g !== null) g.flags |= 32768, g.subtreeFlags = 0, g.deletions = null;
        else {
          Ss = 6, Pr = null;
          return;
        }
      } else if (B = uv(B, C, $o), B !== null) {
        Pr = B;
        return;
      }
      if (C = C.sibling, C !== null) {
        Pr = C;
        return;
      }
      Pr = C = g;
    } while (C !== null);
    Ss === 0 && (Ss = 5);
  }
  function pd(g, C, B) {
    var N = cn, F = sc.transition;
    try {
      sc.transition = null, cn = 1, Mp(g, C, B, N);
    } finally {
      sc.transition = F, cn = N;
    }
    return null;
  }
  function Mp(g, C, B, N) {
    do
      vC();
    while (hd !== null);
    if (Sr & 6) throw Error(t(327));
    B = g.finishedWork;
    var F = g.finishedLanes;
    if (B === null) return null;
    if (g.finishedWork = null, g.finishedLanes = 0, B === g.current) throw Error(t(177));
    g.callbackNode = null, g.callbackPriority = 0;
    var D = B.lanes | B.childLanes;
    if (Ji(g, D), g === Vr && (Pr = Vr = null, ga = 0), !(B.subtreeFlags & 2064) && !(B.flags & 2064) || mC || (mC = !0, vv(Xn, function() {
      return vC(), null;
    })), D = (B.flags & 15990) !== 0, B.subtreeFlags & 15990 || D) {
      D = sc.transition, sc.transition = null;
      var se = cn;
      cn = 1;
      var He = Sr;
      Sr |= 4, uf.current = null, Lm(g, B), dI(B, g), jr(qC), rl = !!ad, qC = ad = null, g.current = B, fB(B), vn(), Sr = He, cn = se, sc.transition = D;
    } else g.current = B;
    if (mC && (mC = !1, hd = g, AC = F), D = g.pendingLanes, D === 0 && (pC = null), ge(B.stateNode), Ya(g, Yt()), C !== null) for (N = g.onRecoverableError, B = 0; B < C.length; B++) F = C[B], N(F.value, { componentStack: F.stack, digest: F.digest });
    if (If) throw If = !1, g = xp, xp = null, g;
    return AC & 1 && g.tag !== 0 && vC(), D = g.pendingLanes, D & 1 ? g === sh ? Cf++ : (Cf = 0, sh = g) : Cf = 0, Us(), null;
  }
  function vC() {
    if (hd !== null) {
      var g = kn(AC), C = sc.transition, B = cn;
      try {
        if (sc.transition = null, cn = 16 > g ? 16 : g, hd === null) var N = !1;
        else {
          if (g = hd, hd = null, AC = 0, Sr & 6) throw Error(t(331));
          var F = Sr;
          for (Sr |= 4, oi = g.current; oi !== null; ) {
            var D = oi, se = D.child;
            if (oi.flags & 16) {
              var He = D.deletions;
              if (He !== null) {
                for (var Qe = 0; Qe < He.length; Qe++) {
                  var xt = He[Qe];
                  for (oi = xt; oi !== null; ) {
                    var Cn = oi;
                    switch (Cn.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Sp(8, Cn, D);
                    }
                    var Gn = Cn.child;
                    if (Gn !== null) Gn.return = Cn, oi = Gn;
                    else for (; oi !== null; ) {
                      Cn = oi;
                      var pn = Cn.sibling, Dn = Cn.return;
                      if (Iv(Cn), Cn === xt) {
                        oi = null;
                        break;
                      }
                      if (pn !== null) {
                        pn.return = Dn, oi = pn;
                        break;
                      }
                      oi = Dn;
                    }
                  }
                }
                var ei = D.alternate;
                if (ei !== null) {
                  var bi = ei.child;
                  if (bi !== null) {
                    ei.child = null;
                    do {
                      var Xo = bi.sibling;
                      bi.sibling = null, bi = Xo;
                    } while (bi !== null);
                  }
                }
                oi = D;
              }
            }
            if (D.subtreeFlags & 2064 && se !== null) se.return = D, oi = se;
            else e: for (; oi !== null; ) {
              if (D = oi, D.flags & 2048) switch (D.tag) {
                case 0:
                case 11:
                case 15:
                  Sp(9, D, D.return);
              }
              var dt = D.sibling;
              if (dt !== null) {
                dt.return = D.return, oi = dt;
                break e;
              }
              oi = D.return;
            }
          }
          var tt = g.current;
          for (oi = tt; oi !== null; ) {
            se = oi;
            var yt = se.child;
            if (se.subtreeFlags & 2064 && yt !== null) yt.return = se, oi = yt;
            else e: for (se = tt; oi !== null; ) {
              if (He = oi, He.flags & 2048) try {
                switch (He.tag) {
                  case 0:
                  case 11:
                  case 15:
                    sf(9, He);
                }
              } catch (Vi) {
                Da(He, He.return, Vi);
              }
              if (He === se) {
                oi = null;
                break e;
              }
              var Mn = He.sibling;
              if (Mn !== null) {
                Mn.return = He.return, oi = Mn;
                break e;
              }
              oi = He.return;
            }
          }
          if (Sr = F, Us(), Ln && typeof Ln.onPostCommitFiberRoot == "function") try {
            Ln.onPostCommitFiberRoot(pr, g);
          } catch {
          }
          N = !0;
        }
        return N;
      } finally {
        cn = B, sc.transition = C;
      }
    }
    return !1;
  }
  function Om(g, C, B) {
    C = Y(B, C), C = nt(g, C, 1), g = ha(g, C, 1), C = No(), g !== null && (Si(g, 1, C), Ya(g, C));
  }
  function Da(g, C, B) {
    if (g.tag === 3) Om(g, g, B);
    else for (; C !== null; ) {
      if (C.tag === 3) {
        Om(C, g, B);
        break;
      } else if (C.tag === 1) {
        var N = C.stateNode;
        if (typeof C.type.getDerivedStateFromError == "function" || typeof N.componentDidCatch == "function" && (pC === null || !pC.has(N))) {
          g = Y(B, g), g = kt(C, g, 1), C = ha(C, g, 1), g = No(), C !== null && (Si(C, 1, g), Ya(C, g));
          break;
        }
      }
      C = C.return;
    }
  }
  function Hp(g, C, B) {
    var N = g.pingCache;
    N !== null && N.delete(C), C = No(), g.pingedLanes |= g.suspendedLanes & B, Vr === g && (ga & B) === B && (Ss === 4 || Ss === 3 && (ga & 130023424) === ga && 500 > Yt() - df ? fI(g, 0) : cf |= B), Ya(g, C);
  }
  function fv(g, C) {
    C === 0 && (g.mode & 1 ? (C = Ai, Ai <<= 1, !(Ai & 130023424) && (Ai = 4194304)) : C = 1);
    var B = No();
    g = xo(g, C), g !== null && (Si(g, C, B), Ya(g, B));
  }
  function pv(g) {
    var C = g.memoizedState, B = 0;
    C !== null && (B = C.retryLane), fv(g, B);
  }
  function mv(g, C) {
    var B = 0;
    switch (g.tag) {
      case 13:
        var N = g.stateNode, F = g.memoizedState;
        F !== null && (B = F.retryLane);
        break;
      case 19:
        N = g.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    N !== null && N.delete(C), fv(g, B);
  }
  var Av;
  Av = function(g, C, B) {
    if (g !== null) if (g.memoizedProps !== C.pendingProps || Qi.current) lr = !0;
    else {
      if (!(g.lanes & B) && !(C.flags & 128)) return lr = !1, ql(g, C, B);
      lr = !!(g.flags & 131072);
    }
    else lr = !1, Ha && C.flags & 1048576 && Ul(C, bu, C.index);
    switch (C.lanes = 0, C.tag) {
      case 2:
        var N = C.type;
        rh(g, C), g = C.pendingProps;
        var F = Zl(C, jo.current);
        gd(C, B), F = dl(null, C, N, g, F, B);
        var D = dn();
        return C.flags |= 1, typeof F == "object" && F !== null && typeof F.render == "function" && F.$$typeof === void 0 ? (C.tag = 1, C.memoizedState = null, C.updateQueue = null, Qa(N) ? (D = !0, xc(C)) : D = !1, C.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null, ur(C), F.updater = ac, C.stateNode = F, F._reactInternals = C, V(C, N, g, B), C = ji(null, C, N, !0, D, B)) : (C.tag = 0, Ha && D && ef(C), $n(null, C, F, B), C = C.child), C;
      case 16:
        N = C.elementType;
        e: {
          switch (rh(g, C), g = C.pendingProps, F = N._init, N = F(N._payload), C.type = N, F = C.tag = mf(N), g = cs(N, g), F) {
            case 0:
              C = Tn(null, C, N, g, B);
              break e;
            case 1:
              C = fn(null, C, N, g, B);
              break e;
            case 11:
              C = to(null, C, N, g, B);
              break e;
            case 14:
              C = gs(null, C, N, cs(N.type, g), B);
              break e;
          }
          throw Error(t(
            306,
            N,
            ""
          ));
        }
        return C;
      case 0:
        return N = C.type, F = C.pendingProps, F = C.elementType === N ? F : cs(N, F), Tn(g, C, N, F, B);
      case 1:
        return N = C.type, F = C.pendingProps, F = C.elementType === N ? F : cs(N, F), fn(g, C, N, F, B);
      case 3:
        e: {
          if ($i(C), g === null) throw Error(t(387));
          N = C.pendingProps, D = C.memoizedState, F = D.element, po(g, C), mo(C, N, null, B);
          var se = C.memoizedState;
          if (N = se.element, D.isDehydrated) if (D = { element: N, isDehydrated: !1, cache: se.cache, pendingSuspenseBoundaries: se.pendingSuspenseBoundaries, transitions: se.transitions }, C.updateQueue.baseState = D, C.memoizedState = D, C.flags & 256) {
            F = Y(Error(t(423)), C), C = fr(g, C, N, B, F);
            break e;
          } else if (N !== F) {
            F = Y(Error(t(424)), C), C = fr(g, C, N, B, F);
            break e;
          } else for (ys = Ls(C.stateNode.containerInfo.firstChild), vs = C, Ha = !0, wl = null, B = th(C, null, N, B), C.child = B; B; ) B.flags = B.flags & -3 | 4096, B = B.sibling;
          else {
            if (Ka(), N === F) {
              C = Zg(g, C, B);
              break e;
            }
            $n(g, C, N, B);
          }
          C = C.child;
        }
        return C;
      case 5:
        return aI(C), g === null && Ag(C), N = C.type, F = C.pendingProps, D = g !== null ? g.memoizedProps : null, se = F.children, Cg(N, F) ? se = null : D !== null && Cg(N, D) && (C.flags |= 32), Zt(g, C), $n(g, C, se, B), C.child;
      case 6:
        return g === null && Ag(C), null;
      case 13:
        return Cl(g, C, B);
      case 4:
        return ih(C, C.stateNode.containerInfo), N = C.pendingProps, g === null ? C.child = vg(C, null, N, B) : $n(g, C, N, B), C.child;
      case 11:
        return N = C.type, F = C.pendingProps, F = C.elementType === N ? F : cs(N, F), to(g, C, N, F, B);
      case 7:
        return $n(g, C, C.pendingProps, B), C.child;
      case 8:
        return $n(g, C, C.pendingProps.children, B), C.child;
      case 12:
        return $n(g, C, C.pendingProps.children, B), C.child;
      case 10:
        e: {
          if (N = C.type._context, F = C.pendingProps, D = C.memoizedProps, se = F.value, Gr(iI, N._currentValue), N._currentValue = se, D !== null) if (Ts(D.value, se)) {
            if (D.children === F.children && !Qi.current) {
              C = Zg(g, C, B);
              break e;
            }
          } else for (D = C.child, D !== null && (D.return = C); D !== null; ) {
            var He = D.dependencies;
            if (He !== null) {
              se = D.child;
              for (var Qe = He.firstContext; Qe !== null; ) {
                if (Qe.context === N) {
                  if (D.tag === 1) {
                    Qe = qr(-1, B & -B), Qe.tag = 2;
                    var xt = D.updateQueue;
                    if (xt !== null) {
                      xt = xt.shared;
                      var Cn = xt.pending;
                      Cn === null ? Qe.next = Qe : (Qe.next = Cn.next, Cn.next = Qe), xt.pending = Qe;
                    }
                  }
                  D.lanes |= B, Qe = D.alternate, Qe !== null && (Qe.lanes |= B), nh(
                    D.return,
                    B,
                    C
                  ), He.lanes |= B;
                  break;
                }
                Qe = Qe.next;
              }
            } else if (D.tag === 10) se = D.type === C.type ? null : D.child;
            else if (D.tag === 18) {
              if (se = D.return, se === null) throw Error(t(341));
              se.lanes |= B, He = se.alternate, He !== null && (He.lanes |= B), nh(se, B, C), se = D.sibling;
            } else se = D.child;
            if (se !== null) se.return = D;
            else for (se = D; se !== null; ) {
              if (se === C) {
                se = null;
                break;
              }
              if (D = se.sibling, D !== null) {
                D.return = se.return, se = D;
                break;
              }
              se = se.return;
            }
            D = se;
          }
          $n(g, C, F.children, B), C = C.child;
        }
        return C;
      case 9:
        return F = C.type, N = C.pendingProps.children, gd(C, B), F = us(F), N = N(F), C.flags |= 1, $n(g, C, N, B), C.child;
      case 14:
        return N = C.type, F = cs(N, C.pendingProps), F = cs(N.type, F), gs(g, C, N, F, B);
      case 15:
        return It(g, C, C.type, C.pendingProps, B);
      case 17:
        return N = C.type, F = C.pendingProps, F = C.elementType === N ? F : cs(N, F), rh(g, C), C.tag = 1, Qa(N) ? (g = !0, xc(C)) : g = !1, gd(C, B), m(C, N, F), V(C, N, F, B), ji(null, C, N, !0, g, B);
      case 19:
        return zm(g, C, B);
      case 22:
        return st(g, C, B);
    }
    throw Error(t(156, C.tag));
  };
  function vv(g, C) {
    return Oe(g, C);
  }
  function Xp(g, C, B, N) {
    this.tag = g, this.key = B, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = C, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = N, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Mo(g, C, B, N) {
    return new Xp(g, C, B, N);
  }
  function Yp(g) {
    return g = g.prototype, !(!g || !g.isReactComponent);
  }
  function mf(g) {
    if (typeof g == "function") return Yp(g) ? 1 : 0;
    if (g != null) {
      if (g = g.$$typeof, g === fe) return 11;
      if (g === Te) return 14;
    }
    return 2;
  }
  function md(g, C) {
    var B = g.alternate;
    return B === null ? (B = Mo(g.tag, C, g.key, g.mode), B.elementType = g.elementType, B.type = g.type, B.stateNode = g.stateNode, B.alternate = g, g.alternate = B) : (B.pendingProps = C, B.type = g.type, B.flags = 0, B.subtreeFlags = 0, B.deletions = null), B.flags = g.flags & 14680064, B.childLanes = g.childLanes, B.lanes = g.lanes, B.child = g.child, B.memoizedProps = g.memoizedProps, B.memoizedState = g.memoizedState, B.updateQueue = g.updateQueue, C = g.dependencies, B.dependencies = C === null ? null : { lanes: C.lanes, firstContext: C.firstContext }, B.sibling = g.sibling, B.index = g.index, B.ref = g.ref, B;
  }
  function Pm(g, C, B, N, F, D) {
    var se = 2;
    if (N = g, typeof g == "function") Yp(g) && (se = 1);
    else if (typeof g == "string") se = 5;
    else e: switch (g) {
      case q:
        return Wu(B.children, F, D, C);
      case k:
        se = 8, F |= 8;
        break;
      case O:
        return g = Mo(12, B, C, F | 2), g.elementType = O, g.lanes = D, g;
      case pe:
        return g = Mo(13, B, C, F), g.elementType = pe, g.lanes = D, g;
      case Ae:
        return g = Mo(19, B, C, F), g.elementType = Ae, g.lanes = D, g;
      case je:
        return mI(B, F, D, C);
      default:
        if (typeof g == "object" && g !== null) switch (g.$$typeof) {
          case J:
            se = 10;
            break e;
          case te:
            se = 9;
            break e;
          case fe:
            se = 11;
            break e;
          case Te:
            se = 14;
            break e;
          case Ke:
            se = 16, N = null;
            break e;
        }
        throw Error(t(130, g == null ? g : typeof g, ""));
    }
    return C = Mo(se, B, C, F), C.elementType = g, C.type = N, C.lanes = D, C;
  }
  function Wu(g, C, B, N) {
    return g = Mo(7, g, N, C), g.lanes = B, g;
  }
  function mI(g, C, B, N) {
    return g = Mo(22, g, N, C), g.elementType = je, g.lanes = B, g.stateNode = { isHidden: !1 }, g;
  }
  function yv(g, C, B) {
    return g = Mo(6, g, null, C), g.lanes = B, g;
  }
  function ch(g, C, B) {
    return C = Mo(4, g.children !== null ? g.children : [], g.key, C), C.lanes = B, C.stateNode = { containerInfo: g.containerInfo, pendingChildren: null, implementation: g.implementation }, C;
  }
  function zc(g, C, B, N, F) {
    this.tag = C, this.containerInfo = g, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Bi(0), this.expirationTimes = Bi(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Bi(0), this.identifierPrefix = N, this.onRecoverableError = F, this.mutableSourceEagerHydrationData = null;
  }
  function Va(g, C, B, N, F, D, se, He, Qe) {
    return g = new zc(g, C, B, He, Qe), C === 1 ? (C = 1, D === !0 && (C |= 8)) : C = 0, D = Mo(3, null, null, C), g.current = D, D.stateNode = g, D.memoizedState = { element: N, isDehydrated: B, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ur(D), g;
  }
  function yC(g, C, B) {
    var N = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: U, key: N == null ? null : "" + N, children: g, containerInfo: C, implementation: B };
  }
  function Ho(g) {
    if (!g) return Ds;
    g = g._reactInternals;
    e: {
      if (Bt(g) !== g || g.tag !== 1) throw Error(t(170));
      var C = g;
      do {
        switch (C.tag) {
          case 3:
            C = C.stateNode.context;
            break e;
          case 1:
            if (Qa(C.type)) {
              C = C.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        C = C.return;
      } while (C !== null);
      throw Error(t(171));
    }
    if (g.tag === 1) {
      var B = g.type;
      if (Qa(B)) return yu(g, B, C);
    }
    return C;
  }
  function ws(g, C, B, N, F, D, se, He, Qe) {
    return g = Va(B, N, !0, g, F, D, se, He, Qe), g.context = Ho(null), B = g.current, N = No(), F = Tc(B), D = qr(N, F), D.callback = C ?? null, ha(B, D, F), g.current.lanes = F, Si(g, F, N), Ya(g, N), g;
  }
  function gh(g, C, B, N) {
    var F = C.current, D = No(), se = Tc(F);
    return B = Ho(B), C.context === null ? C.context = B : C.pendingContext = B, C = qr(D, se), C.payload = { element: g }, N = N === void 0 ? null : N, N !== null && (C.callback = N), g = ha(F, C, se), g !== null && (ka(g, F, se, D), Ur(g, F, se)), se;
  }
  function Af(g) {
    if (g = g.current, !g.child) return null;
    switch (g.child.tag) {
      case 5:
        return g.child.stateNode;
      default:
        return g.child.stateNode;
    }
  }
  function bv(g, C) {
    if (g = g.memoizedState, g !== null && g.dehydrated !== null) {
      var B = g.retryLane;
      g.retryLane = B !== 0 && B < C ? B : C;
    }
  }
  function Qn(g, C) {
    bv(g, C), (g = g.alternate) && bv(g, C);
  }
  function Vu() {
    return null;
  }
  var Jm = typeof reportError == "function" ? reportError : function(g) {
    console.error(g);
  };
  function AI(g) {
    this._internalRoot = g;
  }
  Ad.prototype.render = AI.prototype.render = function(g) {
    var C = this._internalRoot;
    if (C === null) throw Error(t(409));
    gh(g, C, null, null);
  }, Ad.prototype.unmount = AI.prototype.unmount = function() {
    var g = this._internalRoot;
    if (g !== null) {
      this._internalRoot = null;
      var C = g.containerInfo;
      fd(function() {
        gh(null, g, null, null);
      }), C[ms] = null;
    }
  };
  function Ad(g) {
    this._internalRoot = g;
  }
  Ad.prototype.unstable_scheduleHydration = function(g) {
    if (g) {
      var C = ci();
      g = { blockedOn: null, target: g, priority: C };
      for (var B = 0; B < Xr.length && C !== 0 && C < Xr[B].priority; B++) ;
      Xr.splice(B, 0, g), B === 0 && ko(g);
    }
  };
  function fa(g) {
    return !(!g || g.nodeType !== 1 && g.nodeType !== 9 && g.nodeType !== 11);
  }
  function yo(g) {
    return !(!g || g.nodeType !== 1 && g.nodeType !== 9 && g.nodeType !== 11 && (g.nodeType !== 8 || g.nodeValue !== " react-mount-point-unstable "));
  }
  function ds() {
  }
  function Qm(g, C, B, N, F) {
    if (F) {
      if (typeof N == "function") {
        var D = N;
        N = function() {
          var xt = Af(se);
          D.call(xt);
        };
      }
      var se = ws(C, N, g, 0, null, !1, !1, "", ds);
      return g._reactRootContainer = se, g[ms] = se.current, Ks(g.nodeType === 8 ? g.parentNode : g), fd(), se;
    }
    for (; F = g.lastChild; ) g.removeChild(F);
    if (typeof N == "function") {
      var He = N;
      N = function() {
        var xt = Af(Qe);
        He.call(xt);
      };
    }
    var Qe = Va(g, 0, !1, null, null, !1, !1, "", ds);
    return g._reactRootContainer = Qe, g[ms] = Qe.current, Ks(g.nodeType === 8 ? g.parentNode : g), fd(function() {
      gh(C, Qe, B, N);
    }), Qe;
  }
  function bC(g, C, B, N, F) {
    var D = B._reactRootContainer;
    if (D) {
      var se = D;
      if (typeof F == "function") {
        var He = F;
        F = function() {
          var Qe = Af(se);
          He.call(Qe);
        };
      }
      gh(C, se, g, F);
    } else se = Qm(B, C, g, F, N);
    return Af(se);
  }
  ti = function(g) {
    switch (g.tag) {
      case 3:
        var C = g.stateNode;
        if (C.current.memoizedState.isDehydrated) {
          var B = ve(C.pendingLanes);
          B !== 0 && (En(C, B | 1), Ya(C, Yt()), !(Sr & 6) && (fC = Yt() + 500, Us()));
        }
        break;
      case 13:
        fd(function() {
          var N = xo(g, 1);
          if (N !== null) {
            var F = No();
            ka(N, g, 1, F);
          }
        }), Qn(g, 1);
    }
  }, Di = function(g) {
    if (g.tag === 13) {
      var C = xo(g, 134217728);
      if (C !== null) {
        var B = No();
        ka(C, g, 134217728, B);
      }
      Qn(g, 134217728);
    }
  }, qi = function(g) {
    if (g.tag === 13) {
      var C = Tc(g), B = xo(g, C);
      if (B !== null) {
        var N = No();
        ka(B, g, C, N);
      }
      Qn(g, C);
    }
  }, ci = function() {
    return cn;
  }, Hr = function(g, C) {
    var B = cn;
    try {
      return cn = g, C();
    } finally {
      cn = B;
    }
  }, _e = function(g, C, B) {
    switch (C) {
      case "input":
        if (Rn(g, B), C = B.name, B.type === "radio" && C != null) {
          for (B = g; B.parentNode; ) B = B.parentNode;
          for (B = B.querySelectorAll("input[name=" + JSON.stringify("" + C) + '][type="radio"]'), C = 0; C < B.length; C++) {
            var N = B[C];
            if (N !== g && N.form === g.form) {
              var F = ks(N);
              if (!F) throw Error(t(90));
              he(N), Rn(N, F);
            }
          }
        }
        break;
      case "textarea":
        pt(g, B);
        break;
      case "select":
        C = B.value, C != null && oe(g, !!B.multiple, C, !1);
    }
  }, Ir = Rg, Xi = fd;
  var Fp = { usingClientEntryPoint: !1, Events: [os, wa, ks, fi, xi, Rg] }, Ep = { findFiberByHostInstance: Ju, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, mB = { bundleType: Ep.bundleType, version: Ep.version, rendererPackageName: Ep.rendererPackageName, rendererConfig: Ep.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: _.ReactCurrentDispatcher, findHostInstanceByFiber: function(g) {
    return g = Ee(g), g === null ? null : g.stateNode;
  }, findFiberByHostInstance: Ep.findFiberByHostInstance || Vu, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var jt = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!jt.isDisabled && jt.supportsFiber) try {
      pr = jt.inject(mB), Ln = jt;
    } catch {
    }
  }
  return xd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Fp, xd.createPortal = function(g, C) {
    var B = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!fa(C)) throw Error(t(200));
    return yC(g, C, null, B);
  }, xd.createRoot = function(g, C) {
    if (!fa(g)) throw Error(t(299));
    var B = !1, N = "", F = Jm;
    return C != null && (C.unstable_strictMode === !0 && (B = !0), C.identifierPrefix !== void 0 && (N = C.identifierPrefix), C.onRecoverableError !== void 0 && (F = C.onRecoverableError)), C = Va(g, 1, !1, null, null, B, !1, N, F), g[ms] = C.current, Ks(g.nodeType === 8 ? g.parentNode : g), new AI(C);
  }, xd.findDOMNode = function(g) {
    if (g == null) return null;
    if (g.nodeType === 1) return g;
    var C = g._reactInternals;
    if (C === void 0)
      throw typeof g.render == "function" ? Error(t(188)) : (g = Object.keys(g).join(","), Error(t(268, g)));
    return g = Ee(C), g = g === null ? null : g.stateNode, g;
  }, xd.flushSync = function(g) {
    return fd(g);
  }, xd.hydrate = function(g, C, B) {
    if (!yo(C)) throw Error(t(200));
    return bC(null, g, C, !0, B);
  }, xd.hydrateRoot = function(g, C, B) {
    if (!fa(g)) throw Error(t(405));
    var N = B != null && B.hydratedSources || null, F = !1, D = "", se = Jm;
    if (B != null && (B.unstable_strictMode === !0 && (F = !0), B.identifierPrefix !== void 0 && (D = B.identifierPrefix), B.onRecoverableError !== void 0 && (se = B.onRecoverableError)), C = ws(C, null, g, 1, B ?? null, F, !1, D, se), g[ms] = C.current, Ks(g), N) for (g = 0; g < N.length; g++) B = N[g], F = B._getVersion, F = F(B._source), C.mutableSourceEagerHydrationData == null ? C.mutableSourceEagerHydrationData = [B, F] : C.mutableSourceEagerHydrationData.push(
      B,
      F
    );
    return new Ad(C);
  }, xd.render = function(g, C, B) {
    if (!yo(C)) throw Error(t(200));
    return bC(null, g, C, !1, B);
  }, xd.unmountComponentAtNode = function(g) {
    if (!yo(g)) throw Error(t(40));
    return g._reactRootContainer ? (fd(function() {
      bC(null, null, g, !1, function() {
        g._reactRootContainer = null, g[ms] = null;
      });
    }), !0) : !1;
  }, xd.unstable_batchedUpdates = Rg, xd.unstable_renderSubtreeIntoContainer = function(g, C, B, N) {
    if (!yo(B)) throw Error(t(200));
    if (g == null || g._reactInternals === void 0) throw Error(t(38));
    return bC(g, C, B, !1, N);
  }, xd.version = "18.3.1-next-f1338f8080-20240426", xd;
}
var Wd = {}, ME;
function rO() {
  if (ME) return Wd;
  ME = 1;
  var a = {};
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return a.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = xe, t = I5(), n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, i = !1;
    function o(r) {
      i = r;
    }
    function l(r) {
      if (!i) {
        for (var s = arguments.length, p = new Array(s > 1 ? s - 1 : 0), y = 1; y < s; y++)
          p[y - 1] = arguments[y];
        I("warn", r, p);
      }
    }
    function u(r) {
      if (!i) {
        for (var s = arguments.length, p = new Array(s > 1 ? s - 1 : 0), y = 1; y < s; y++)
          p[y - 1] = arguments[y];
        I("error", r, p);
      }
    }
    function I(r, s, p) {
      {
        var y = n.ReactDebugCurrentFrame, Z = y.getStackAddendum();
        Z !== "" && (s += "%s", p = p.concat([Z]));
        var X = p.map(function(K) {
          return String(K);
        });
        X.unshift("Warning: " + s), Function.prototype.apply.call(console[r], console, X);
      }
    }
    var f = 0, h = 1, v = 2, b = 3, S = 4, R = 5, W = 6, x = 7, M = 8, T = 9, E = 10, _ = 11, P = 12, U = 13, q = 14, k = 15, O = 16, J = 17, te = 18, fe = 19, pe = 21, Ae = 22, Te = 23, Ke = 24, je = 25, ee = !0, Ce = !1, be = !1, le = !1, Ye = !1, $e = !0, ke = !1, ot = !0, wt = !0, St = !0, ln = !0, hn = /* @__PURE__ */ new Set(), mn = {}, Pn = {};
    function he(r, s) {
      Lt(r, s), Lt(r + "Capture", s);
    }
    function Lt(r, s) {
      mn[r] && u("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", r), mn[r] = s;
      {
        var p = r.toLowerCase();
        Pn[p] = r, r === "onDoubleClick" && (Pn.ondblclick = r);
      }
      for (var y = 0; y < s.length; y++)
        hn.add(s[y]);
    }
    var Wt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", tn = Object.prototype.hasOwnProperty;
    function Gt(r) {
      {
        var s = typeof Symbol == "function" && Symbol.toStringTag, p = s && r[Symbol.toStringTag] || r.constructor.name || "Object";
        return p;
      }
    }
    function Rn(r) {
      try {
        return nn(r), !1;
      } catch {
        return !0;
      }
    }
    function nn(r) {
      return "" + r;
    }
    function Bn(r, s) {
      if (Rn(r))
        return u("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Gt(r)), nn(r);
    }
    function Se(r) {
      if (Rn(r))
        return u("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Gt(r)), nn(r);
    }
    function oe(r, s) {
      if (Rn(r))
        return u("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Gt(r)), nn(r);
    }
    function ct(r, s) {
      if (Rn(r))
        return u("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Gt(r)), nn(r);
    }
    function Ft(r) {
      if (Rn(r))
        return u("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Gt(r)), nn(r);
    }
    function pt(r) {
      if (Rn(r))
        return u("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Gt(r)), nn(r);
    }
    var zt = 0, Sn = 1, rn = 2, gn = 3, qn = 4, qt = 5, An = 6, Fe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ie = Fe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", at = new RegExp("^[" + Fe + "][" + Ie + "]*$"), ye = {}, Pe = {};
    function Ot(r) {
      return tn.call(Pe, r) ? !0 : tn.call(ye, r) ? !1 : at.test(r) ? (Pe[r] = !0, !0) : (ye[r] = !0, u("Invalid attribute name: `%s`", r), !1);
    }
    function Re(r, s, p) {
      return s !== null ? s.type === zt : p ? !1 : r.length > 2 && (r[0] === "o" || r[0] === "O") && (r[1] === "n" || r[1] === "N");
    }
    function lt(r, s, p, y) {
      if (p !== null && p.type === zt)
        return !1;
      switch (typeof s) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (y)
            return !1;
          if (p !== null)
            return !p.acceptsBooleans;
          var Z = r.toLowerCase().slice(0, 5);
          return Z !== "data-" && Z !== "aria-";
        }
        default:
          return !1;
      }
    }
    function _e(r, s, p, y) {
      if (s === null || typeof s > "u" || lt(r, s, p, y))
        return !0;
      if (y)
        return !1;
      if (p !== null)
        switch (p.type) {
          case gn:
            return !s;
          case qn:
            return s === !1;
          case qt:
            return isNaN(s);
          case An:
            return isNaN(s) || s < 1;
        }
      return !1;
    }
    function ht(r) {
      return an.hasOwnProperty(r) ? an[r] : null;
    }
    function Ht(r, s, p, y, Z, X, K) {
      this.acceptsBooleans = s === rn || s === gn || s === qn, this.attributeName = y, this.attributeNamespace = Z, this.mustUseProperty = p, this.propertyName = r, this.type = s, this.sanitizeURL = X, this.removeEmptyString = K;
    }
    var an = {}, fi = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    fi.forEach(function(r) {
      an[r] = new Ht(
        r,
        zt,
        !1,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(r) {
      var s = r[0], p = r[1];
      an[s] = new Ht(
        s,
        Sn,
        !1,
        // mustUseProperty
        p,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(r) {
      an[r] = new Ht(
        r,
        rn,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(r) {
      an[r] = new Ht(
        r,
        rn,
        !1,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(r) {
      an[r] = new Ht(
        r,
        gn,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      an[r] = new Ht(
        r,
        gn,
        !0,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      an[r] = new Ht(
        r,
        qn,
        !1,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      an[r] = new Ht(
        r,
        An,
        !1,
        // mustUseProperty
        r,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(r) {
      an[r] = new Ht(
        r,
        qt,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var xi = /[\-\:]([a-z])/g, Ir = function(r) {
      return r[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      var s = r.replace(xi, Ir);
      an[s] = new Ht(
        s,
        Sn,
        !1,
        // mustUseProperty
        r,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      var s = r.replace(xi, Ir);
      an[s] = new Ht(
        s,
        Sn,
        !1,
        // mustUseProperty
        r,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(r) {
      var s = r.replace(xi, Ir);
      an[s] = new Ht(
        s,
        Sn,
        !1,
        // mustUseProperty
        r,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(r) {
      an[r] = new Ht(
        r,
        Sn,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Xi = "xlinkHref";
    an[Xi] = new Ht(
      "xlinkHref",
      Sn,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(r) {
      an[r] = new Ht(
        r,
        Sn,
        !1,
        // mustUseProperty
        r.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var pi = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Cr = !1;
    function Sa(r) {
      !Cr && pi.test(r) && (Cr = !0, u("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(r)));
    }
    function zr(r, s, p, y) {
      if (y.mustUseProperty) {
        var Z = y.propertyName;
        return r[Z];
      } else {
        Bn(p, s), y.sanitizeURL && Sa("" + p);
        var X = y.attributeName, K = null;
        if (y.type === qn) {
          if (r.hasAttribute(X)) {
            var j = r.getAttribute(X);
            return j === "" ? !0 : _e(s, p, y, !1) ? j : j === "" + p ? p : j;
          }
        } else if (r.hasAttribute(X)) {
          if (_e(s, p, y, !1))
            return r.getAttribute(X);
          if (y.type === gn)
            return p;
          K = r.getAttribute(X);
        }
        return _e(s, p, y, !1) ? K === null ? p : K : K === "" + p ? p : K;
      }
    }
    function na(r, s, p, y) {
      {
        if (!Ot(s))
          return;
        if (!r.hasAttribute(s))
          return p === void 0 ? void 0 : null;
        var Z = r.getAttribute(s);
        return Bn(p, s), Z === "" + p ? p : Z;
      }
    }
    function la(r, s, p, y) {
      var Z = ht(s);
      if (!Re(s, Z, y)) {
        if (_e(s, p, Z, y) && (p = null), y || Z === null) {
          if (Ot(s)) {
            var X = s;
            p === null ? r.removeAttribute(X) : (Bn(p, s), r.setAttribute(X, "" + p));
          }
          return;
        }
        var K = Z.mustUseProperty;
        if (K) {
          var j = Z.propertyName;
          if (p === null) {
            var ne = Z.type;
            r[j] = ne === gn ? !1 : "";
          } else
            r[j] = p;
          return;
        }
        var de = Z.attributeName, Ge = Z.attributeNamespace;
        if (p === null)
          r.removeAttribute(de);
        else {
          var rt = Z.type, it;
          rt === gn || rt === qn && p === !0 ? it = "" : (Bn(p, de), it = "" + p, Z.sanitizeURL && Sa(it.toString())), Ge ? r.setAttributeNS(Ge, de, it) : r.setAttribute(de, it);
        }
      }
    }
    var Oa = Symbol.for("react.element"), Le = Symbol.for("react.portal"), qe = Symbol.for("react.fragment"), gt = Symbol.for("react.strict_mode"), Pt = Symbol.for("react.profiler"), me = Symbol.for("react.provider"), ut = Symbol.for("react.context"), Bt = Symbol.for("react.forward_ref"), Tt = Symbol.for("react.suspense"), ae = Symbol.for("react.suspense_list"), we = Symbol.for("react.memo"), Ee = Symbol.for("react.lazy"), Ue = Symbol.for("react.scope"), Oe = Symbol.for("react.debug_trace_mode"), Nt = Symbol.for("react.offscreen"), Kt = Symbol.for("react.legacy_hidden"), vn = Symbol.for("react.cache"), Yt = Symbol.for("react.tracing_marker"), Yn = Symbol.iterator, Fn = "@@iterator";
    function _n(r) {
      if (r === null || typeof r != "object")
        return null;
      var s = Yn && r[Yn] || r[Fn];
      return typeof s == "function" ? s : null;
    }
    var Xn = Object.assign, or = 0, Ei, pr, Ln, ge, ue, We, et;
    function Mt() {
    }
    Mt.__reactDisabledLog = !0;
    function bn() {
      {
        if (or === 0) {
          Ei = console.log, pr = console.info, Ln = console.warn, ge = console.error, ue = console.group, We = console.groupCollapsed, et = console.groupEnd;
          var r = {
            configurable: !0,
            enumerable: !0,
            value: Mt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: r,
            log: r,
            warn: r,
            error: r,
            group: r,
            groupCollapsed: r,
            groupEnd: r
          });
        }
        or++;
      }
    }
    function Ai() {
      {
        if (or--, or === 0) {
          var r = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Xn({}, r, {
              value: Ei
            }),
            info: Xn({}, r, {
              value: pr
            }),
            warn: Xn({}, r, {
              value: Ln
            }),
            error: Xn({}, r, {
              value: ge
            }),
            group: Xn({}, r, {
              value: ue
            }),
            groupCollapsed: Xn({}, r, {
              value: We
            }),
            groupEnd: Xn({}, r, {
              value: et
            })
          });
        }
        or < 0 && u("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ve = n.ReactCurrentDispatcher, Be;
    function mt(r, s, p) {
      {
        if (Be === void 0)
          try {
            throw Error();
          } catch (Z) {
            var y = Z.stack.trim().match(/\n( *(at )?)/);
            Be = y && y[1] || "";
          }
        return `
` + Be + r;
      }
    }
    var $t = !1, In;
    {
      var un = typeof WeakMap == "function" ? WeakMap : Map;
      In = new un();
    }
    function Bi(r, s) {
      if (!r || $t)
        return "";
      {
        var p = In.get(r);
        if (p !== void 0)
          return p;
      }
      var y;
      $t = !0;
      var Z = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var X;
      X = ve.current, ve.current = null, bn();
      try {
        if (s) {
          var K = function() {
            throw Error();
          };
          if (Object.defineProperty(K.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(K, []);
            } catch (Xt) {
              y = Xt;
            }
            Reflect.construct(r, [], K);
          } else {
            try {
              K.call();
            } catch (Xt) {
              y = Xt;
            }
            r.call(K.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Xt) {
            y = Xt;
          }
          r();
        }
      } catch (Xt) {
        if (Xt && y && typeof Xt.stack == "string") {
          for (var j = Xt.stack.split(`
`), ne = y.stack.split(`
`), de = j.length - 1, Ge = ne.length - 1; de >= 1 && Ge >= 0 && j[de] !== ne[Ge]; )
            Ge--;
          for (; de >= 1 && Ge >= 0; de--, Ge--)
            if (j[de] !== ne[Ge]) {
              if (de !== 1 || Ge !== 1)
                do
                  if (de--, Ge--, Ge < 0 || j[de] !== ne[Ge]) {
                    var rt = `
` + j[de].replace(" at new ", " at ");
                    return r.displayName && rt.includes("<anonymous>") && (rt = rt.replace("<anonymous>", r.displayName)), typeof r == "function" && In.set(r, rt), rt;
                  }
                while (de >= 1 && Ge >= 0);
              break;
            }
        }
      } finally {
        $t = !1, ve.current = X, Ai(), Error.prepareStackTrace = Z;
      }
      var it = r ? r.displayName || r.name : "", Vt = it ? mt(it) : "";
      return typeof r == "function" && In.set(r, Vt), Vt;
    }
    function Si(r, s, p) {
      return Bi(r, !0);
    }
    function Ji(r, s, p) {
      return Bi(r, !1);
    }
    function En(r) {
      var s = r.prototype;
      return !!(s && s.isReactComponent);
    }
    function cn(r, s, p) {
      if (r == null)
        return "";
      if (typeof r == "function")
        return Bi(r, En(r));
      if (typeof r == "string")
        return mt(r);
      switch (r) {
        case Tt:
          return mt("Suspense");
        case ae:
          return mt("SuspenseList");
      }
      if (typeof r == "object")
        switch (r.$$typeof) {
          case Bt:
            return Ji(r.render);
          case we:
            return cn(r.type, s, p);
          case Ee: {
            var y = r, Z = y._payload, X = y._init;
            try {
              return cn(X(Z), s, p);
            } catch {
            }
          }
        }
      return "";
    }
    function kn(r) {
      switch (r._debugOwner && r._debugOwner.type, r._debugSource, r.tag) {
        case R:
          return mt(r.type);
        case O:
          return mt("Lazy");
        case U:
          return mt("Suspense");
        case fe:
          return mt("SuspenseList");
        case f:
        case v:
        case k:
          return Ji(r.type);
        case _:
          return Ji(r.type.render);
        case h:
          return Si(r.type);
        default:
          return "";
      }
    }
    function ti(r) {
      try {
        var s = "", p = r;
        do
          s += kn(p), p = p.return;
        while (p);
        return s;
      } catch (y) {
        return `
Error generating stack: ` + y.message + `
` + y.stack;
      }
    }
    function Di(r, s, p) {
      var y = r.displayName;
      if (y)
        return y;
      var Z = s.displayName || s.name || "";
      return Z !== "" ? p + "(" + Z + ")" : p;
    }
    function qi(r) {
      return r.displayName || "Context";
    }
    function ci(r) {
      if (r == null)
        return null;
      if (typeof r.tag == "number" && u("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof r == "function")
        return r.displayName || r.name || null;
      if (typeof r == "string")
        return r;
      switch (r) {
        case qe:
          return "Fragment";
        case Le:
          return "Portal";
        case Pt:
          return "Profiler";
        case gt:
          return "StrictMode";
        case Tt:
          return "Suspense";
        case ae:
          return "SuspenseList";
      }
      if (typeof r == "object")
        switch (r.$$typeof) {
          case ut:
            var s = r;
            return qi(s) + ".Consumer";
          case me:
            var p = r;
            return qi(p._context) + ".Provider";
          case Bt:
            return Di(r, r.render, "ForwardRef");
          case we:
            var y = r.displayName || null;
            return y !== null ? y : ci(r.type) || "Memo";
          case Ee: {
            var Z = r, X = Z._payload, K = Z._init;
            try {
              return ci(K(X));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Hr(r, s, p) {
      var y = s.displayName || s.name || "";
      return r.displayName || (y !== "" ? p + "(" + y + ")" : p);
    }
    function Za(r) {
      return r.displayName || "Context";
    }
    function gi(r) {
      var s = r.tag, p = r.type;
      switch (s) {
        case Ke:
          return "Cache";
        case T:
          var y = p;
          return Za(y) + ".Consumer";
        case E:
          var Z = p;
          return Za(Z._context) + ".Provider";
        case te:
          return "DehydratedFragment";
        case _:
          return Hr(p, p.render, "ForwardRef");
        case x:
          return "Fragment";
        case R:
          return p;
        case S:
          return "Portal";
        case b:
          return "Root";
        case W:
          return "Text";
        case O:
          return ci(p);
        case M:
          return p === gt ? "StrictMode" : "Mode";
        case Ae:
          return "Offscreen";
        case P:
          return "Profiler";
        case pe:
          return "Scope";
        case U:
          return "Suspense";
        case fe:
          return "SuspenseList";
        case je:
          return "TracingMarker";
        case h:
        case f:
        case J:
        case v:
        case q:
        case k:
          if (typeof p == "function")
            return p.displayName || p.name || null;
          if (typeof p == "string")
            return p;
          break;
      }
      return null;
    }
    var yr = n.ReactDebugCurrentFrame, Hn = null, Pa = !1;
    function zo() {
      {
        if (Hn === null)
          return null;
        var r = Hn._debugOwner;
        if (r !== null && typeof r < "u")
          return gi(r);
      }
      return null;
    }
    function Ko() {
      return Hn === null ? "" : ti(Hn);
    }
    function Xr() {
      yr.getCurrentStack = null, Hn = null, Pa = !1;
    }
    function ia(r) {
      yr.getCurrentStack = r === null ? null : Ko, Hn = r, Pa = !1;
    }
    function kr() {
      return Hn;
    }
    function ua(r) {
      Pa = r;
    }
    function Lo(r) {
      return "" + r;
    }
    function ko(r) {
      switch (typeof r) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return r;
        case "object":
          return pt(r), r;
        default:
          return "";
      }
    }
    var cu = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ja(r, s) {
      cu[s.type] || s.onChange || s.onInput || s.readOnly || s.disabled || s.value == null || u("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), s.onChange || s.readOnly || s.disabled || s.checked == null || u("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function is(r) {
      var s = r.type, p = r.nodeName;
      return p && p.toLowerCase() === "input" && (s === "checkbox" || s === "radio");
    }
    function Qg(r) {
      return r._valueTracker;
    }
    function gu(r) {
      r._valueTracker = null;
    }
    function rs(r) {
      var s = "";
      return r && (is(r) ? s = r.checked ? "true" : "false" : s = r.value), s;
    }
    function rl(r) {
      var s = is(r) ? "checked" : "value", p = Object.getOwnPropertyDescriptor(r.constructor.prototype, s);
      pt(r[s]);
      var y = "" + r[s];
      if (!(r.hasOwnProperty(s) || typeof p > "u" || typeof p.get != "function" || typeof p.set != "function")) {
        var Z = p.get, X = p.set;
        Object.defineProperty(r, s, {
          configurable: !0,
          get: function() {
            return Z.call(this);
          },
          set: function(j) {
            pt(j), y = "" + j, X.call(this, j);
          }
        }), Object.defineProperty(r, s, {
          enumerable: p.enumerable
        });
        var K = {
          getValue: function() {
            return y;
          },
          setValue: function(j) {
            pt(j), y = "" + j;
          },
          stopTracking: function() {
            gu(r), delete r[s];
          }
        };
        return K;
      }
    }
    function du(r) {
      Qg(r) || (r._valueTracker = rl(r));
    }
    function jg(r) {
      if (!r)
        return !1;
      var s = Qg(r);
      if (!s)
        return !0;
      var p = s.getValue(), y = rs(r);
      return y !== p ? (s.setValue(y), !0) : !1;
    }
    function ku(r) {
      if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u")
        return null;
      try {
        return r.activeElement || r.body;
      } catch {
        return r.body;
      }
    }
    var Bc = !1, al = !1, kC = !1, Bl = !1;
    function kI(r) {
      var s = r.type === "checkbox" || r.type === "radio";
      return s ? r.checked != null : r.value != null;
    }
    function ie(r, s) {
      var p = r, y = s.checked, Z = Xn({}, s, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: y ?? p._wrapperState.initialChecked
      });
      return Z;
    }
    function De(r, s) {
      Ja("input", s), s.checked !== void 0 && s.defaultChecked !== void 0 && !al && (u("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", zo() || "A component", s.type), al = !0), s.value !== void 0 && s.defaultValue !== void 0 && !Bc && (u("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", zo() || "A component", s.type), Bc = !0);
      var p = r, y = s.defaultValue == null ? "" : s.defaultValue;
      p._wrapperState = {
        initialChecked: s.checked != null ? s.checked : s.defaultChecked,
        initialValue: ko(s.value != null ? s.value : y),
        controlled: kI(s)
      };
    }
    function bt(r, s) {
      var p = r, y = s.checked;
      y != null && la(p, "checked", y, !1);
    }
    function Et(r, s) {
      var p = r;
      {
        var y = kI(s);
        !p._wrapperState.controlled && y && !Bl && (u("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Bl = !0), p._wrapperState.controlled && !y && !kC && (u("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), kC = !0);
      }
      bt(r, s);
      var Z = ko(s.value), X = s.type;
      if (Z != null)
        X === "number" ? (Z === 0 && p.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        p.value != Z) && (p.value = Lo(Z)) : p.value !== Lo(Z) && (p.value = Lo(Z));
      else if (X === "submit" || X === "reset") {
        p.removeAttribute("value");
        return;
      }
      s.hasOwnProperty("value") ? Yi(p, s.type, Z) : s.hasOwnProperty("defaultValue") && Yi(p, s.type, ko(s.defaultValue)), s.checked == null && s.defaultChecked != null && (p.defaultChecked = !!s.defaultChecked);
    }
    function wn(r, s, p) {
      var y = r;
      if (s.hasOwnProperty("value") || s.hasOwnProperty("defaultValue")) {
        var Z = s.type, X = Z === "submit" || Z === "reset";
        if (X && (s.value === void 0 || s.value === null))
          return;
        var K = Lo(y._wrapperState.initialValue);
        p || K !== y.value && (y.value = K), y.defaultValue = K;
      }
      var j = y.name;
      j !== "" && (y.name = ""), y.defaultChecked = !y.defaultChecked, y.defaultChecked = !!y._wrapperState.initialChecked, j !== "" && (y.name = j);
    }
    function ui(r, s) {
      var p = r;
      Et(p, s), ni(p, s);
    }
    function ni(r, s) {
      var p = s.name;
      if (s.type === "radio" && p != null) {
        for (var y = r; y.parentNode; )
          y = y.parentNode;
        Bn(p, "name");
        for (var Z = y.querySelectorAll("input[name=" + JSON.stringify("" + p) + '][type="radio"]'), X = 0; X < Z.length; X++) {
          var K = Z[X];
          if (!(K === r || K.form !== r.form)) {
            var j = yd(K);
            if (!j)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            jg(K), Et(K, j);
          }
        }
      }
    }
    function Yi(r, s, p) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (s !== "number" || ku(r.ownerDocument) !== r) && (p == null ? r.defaultValue = Lo(r._wrapperState.initialValue) : r.defaultValue !== Lo(p) && (r.defaultValue = Lo(p)));
    }
    var rr = !1, Yr = !1, hr = !1;
    function vr(r, s) {
      s.value == null && (typeof s.children == "object" && s.children !== null ? e.Children.forEach(s.children, function(p) {
        p != null && (typeof p == "string" || typeof p == "number" || Yr || (Yr = !0, u("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : s.dangerouslySetInnerHTML != null && (hr || (hr = !0, u("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), s.selected != null && !rr && (u("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), rr = !0);
    }
    function br(r, s) {
      s.value != null && r.setAttribute("value", Lo(ko(s.value)));
    }
    var Ia = Array.isArray;
    function Fr(r) {
      return Ia(r);
    }
    var Qo;
    Qo = !1;
    function Tl() {
      var r = zo();
      return r ? `

Check the render method of \`` + r + "`." : "";
    }
    var qg = ["value", "defaultValue"];
    function DI(r) {
      {
        Ja("select", r);
        for (var s = 0; s < qg.length; s++) {
          var p = qg[s];
          if (r[p] != null) {
            var y = Fr(r[p]);
            r.multiple && !y ? u("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", p, Tl()) : !r.multiple && y && u("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", p, Tl());
          }
        }
      }
    }
    function Iu(r, s, p, y) {
      var Z = r.options;
      if (s) {
        for (var X = p, K = {}, j = 0; j < X.length; j++)
          K["$" + X[j]] = !0;
        for (var ne = 0; ne < Z.length; ne++) {
          var de = K.hasOwnProperty("$" + Z[ne].value);
          Z[ne].selected !== de && (Z[ne].selected = de), de && y && (Z[ne].defaultSelected = !0);
        }
      } else {
        for (var Ge = Lo(ko(p)), rt = null, it = 0; it < Z.length; it++) {
          if (Z[it].value === Ge) {
            Z[it].selected = !0, y && (Z[it].defaultSelected = !0);
            return;
          }
          rt === null && !Z[it].disabled && (rt = Z[it]);
        }
        rt !== null && (rt.selected = !0);
      }
    }
    function UI(r, s) {
      return Xn({}, s, {
        value: void 0
      });
    }
    function OI(r, s) {
      var p = r;
      DI(s), p._wrapperState = {
        wasMultiple: !!s.multiple
      }, s.value !== void 0 && s.defaultValue !== void 0 && !Qo && (u("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Qo = !0);
    }
    function DC(r, s) {
      var p = r;
      p.multiple = !!s.multiple;
      var y = s.value;
      y != null ? Iu(p, !!s.multiple, y, !1) : s.defaultValue != null && Iu(p, !!s.multiple, s.defaultValue, !0);
    }
    function UC(r, s) {
      var p = r, y = p._wrapperState.wasMultiple;
      p._wrapperState.wasMultiple = !!s.multiple;
      var Z = s.value;
      Z != null ? Iu(p, !!s.multiple, Z, !1) : y !== !!s.multiple && (s.defaultValue != null ? Iu(p, !!s.multiple, s.defaultValue, !0) : Iu(p, !!s.multiple, s.multiple ? [] : "", !1));
    }
    function fp(r, s) {
      var p = r, y = s.value;
      y != null && Iu(p, !!s.multiple, y, !1);
    }
    var pp = !1;
    function kh(r, s) {
      var p = r;
      if (s.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var y = Xn({}, s, {
        value: void 0,
        defaultValue: void 0,
        children: Lo(p._wrapperState.initialValue)
      });
      return y;
    }
    function Dh(r, s) {
      var p = r;
      Ja("textarea", s), s.value !== void 0 && s.defaultValue !== void 0 && !pp && (u("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", zo() || "A component"), pp = !0);
      var y = s.value;
      if (y == null) {
        var Z = s.children, X = s.defaultValue;
        if (Z != null) {
          u("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (X != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Fr(Z)) {
              if (Z.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              Z = Z[0];
            }
            X = Z;
          }
        }
        X == null && (X = ""), y = X;
      }
      p._wrapperState = {
        initialValue: ko(y)
      };
    }
    function Dd(r, s) {
      var p = r, y = ko(s.value), Z = ko(s.defaultValue);
      if (y != null) {
        var X = Lo(y);
        X !== p.value && (p.value = X), s.defaultValue == null && p.defaultValue !== X && (p.defaultValue = X);
      }
      Z != null && (p.defaultValue = Lo(Z));
    }
    function ug(r, s) {
      var p = r, y = p.textContent;
      y === p._wrapperState.initialValue && y !== "" && y !== null && (p.value = y);
    }
    function Uh(r, s) {
      Dd(r, s);
    }
    var Cu = "http://www.w3.org/1999/xhtml", hu = "http://www.w3.org/1998/Math/MathML", ol = "http://www.w3.org/2000/svg";
    function cg(r) {
      switch (r) {
        case "svg":
          return ol;
        case "math":
          return hu;
        default:
          return Cu;
      }
    }
    function Du(r, s) {
      return r == null || r === Cu ? cg(s) : r === ol && s === "foreignObject" ? Cu : r;
    }
    var gg = function(r) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(s, p, y, Z) {
        MSApp.execUnsafeLocalFunction(function() {
          return r(s, p, y, Z);
        });
      } : r;
    }, Sc, mp = gg(function(r, s) {
      if (r.namespaceURI === ol && !("innerHTML" in r)) {
        Sc = Sc || document.createElement("div"), Sc.innerHTML = "<svg>" + s.valueOf().toString() + "</svg>";
        for (var p = Sc.firstChild; r.firstChild; )
          r.removeChild(r.firstChild);
        for (; p.firstChild; )
          r.appendChild(p.firstChild);
        return;
      }
      r.innerHTML = s;
    }), Es = 1, Uu = 3, Kr = 8, _a = 9, ca = 11, Zc = function(r, s) {
      if (s) {
        var p = r.firstChild;
        if (p && p === r.lastChild && p.nodeType === Uu) {
          p.nodeValue = s;
          return;
        }
      }
      r.textContent = s;
    }, _l = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, $g = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Oh(r, s) {
      return r + s.charAt(0).toUpperCase() + s.substring(1);
    }
    var OC = ["Webkit", "ms", "Moz", "O"];
    Object.keys($g).forEach(function(r) {
      OC.forEach(function(s) {
        $g[Oh(s, r)] = $g[r];
      });
    });
    function Ou(r, s, p) {
      var y = s == null || typeof s == "boolean" || s === "";
      return y ? "" : !p && typeof s == "number" && s !== 0 && !($g.hasOwnProperty(r) && $g[r]) ? s + "px" : (ct(s, r), ("" + s).trim());
    }
    var Ap = /([A-Z])/g, PI = /^ms-/;
    function JI(r) {
      return r.replace(Ap, "-$1").toLowerCase().replace(PI, "-ms-");
    }
    var PC = function() {
    };
    {
      var ed = /^(?:webkit|moz|o)[A-Z]/, wc = /^-ms-/, zl = /-(.)/g, JC = /;\s*$/, fs = {}, Ph = {}, dg = !1, sl = !1, Ig = function(r) {
        return r.replace(zl, function(s, p) {
          return p.toUpperCase();
        });
      }, Ud = function(r) {
        fs.hasOwnProperty(r) && fs[r] || (fs[r] = !0, u(
          "Unsupported style property %s. Did you mean %s?",
          r,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Ig(r.replace(wc, "ms-"))
        ));
      }, Kl = function(r) {
        fs.hasOwnProperty(r) && fs[r] || (fs[r] = !0, u("Unsupported vendor-prefixed style property %s. Did you mean %s?", r, r.charAt(0).toUpperCase() + r.slice(1)));
      }, QC = function(r, s) {
        Ph.hasOwnProperty(s) && Ph[s] || (Ph[s] = !0, u(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, r, s.replace(JC, "")));
      }, Od = function(r, s) {
        dg || (dg = !0, u("`NaN` is an invalid value for the `%s` css style property.", r));
      }, vp = function(r, s) {
        sl || (sl = !0, u("`Infinity` is an invalid value for the `%s` css style property.", r));
      };
      PC = function(r, s) {
        r.indexOf("-") > -1 ? Ud(r) : ed.test(r) ? Kl(r) : JC.test(s) && QC(r, s), typeof s == "number" && (isNaN(s) ? Od(r, s) : isFinite(s) || vp(r, s));
      };
    }
    var QI = PC;
    function Dr(r) {
      {
        var s = "", p = "";
        for (var y in r)
          if (r.hasOwnProperty(y)) {
            var Z = r[y];
            if (Z != null) {
              var X = y.indexOf("--") === 0;
              s += p + (X ? y : JI(y)) + ":", s += Ou(y, Z, X), p = ";";
            }
          }
        return s || null;
      }
    }
    function Pd(r, s) {
      var p = r.style;
      for (var y in s)
        if (s.hasOwnProperty(y)) {
          var Z = y.indexOf("--") === 0;
          Z || QI(y, s[y]);
          var X = Ou(y, s[y], Z);
          y === "float" && (y = "cssFloat"), Z ? p.setProperty(y, X) : p[y] = X;
        }
    }
    function Ts(r) {
      return r == null || typeof r == "boolean" || r === "";
    }
    function _s(r) {
      var s = {};
      for (var p in r)
        for (var y = _l[p] || [p], Z = 0; Z < y.length; Z++)
          s[y[Z]] = p;
      return s;
    }
    function fu(r, s) {
      {
        if (!s)
          return;
        var p = _s(r), y = _s(s), Z = {};
        for (var X in p) {
          var K = p[X], j = y[X];
          if (j && K !== j) {
            var ne = K + "," + j;
            if (Z[ne])
              continue;
            Z[ne] = !0, u("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Ts(r[K]) ? "Removing" : "Updating", K, j);
          }
        }
      }
    }
    var va = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, ao = Xn({
      menuitem: !0
    }, va), za = "__html";
    function Qr(r, s) {
      if (s) {
        if (ao[r] && (s.children != null || s.dangerouslySetInnerHTML != null))
          throw new Error(r + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (s.dangerouslySetInnerHTML != null) {
          if (s.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof s.dangerouslySetInnerHTML != "object" || !(za in s.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!s.suppressContentEditableWarning && s.contentEditable && s.children != null && u("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), s.style != null && typeof s.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function jr(r, s) {
      if (r.indexOf("-") === -1)
        return typeof s.is == "string";
      switch (r) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var zs = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Ll = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, ps = {}, jI = new RegExp("^(aria)-[" + Ie + "]*$"), oo = new RegExp("^(aria)[A-Z][" + Ie + "]*$");
    function Jd(r, s) {
      {
        if (tn.call(ps, s) && ps[s])
          return !0;
        if (oo.test(s)) {
          var p = "aria-" + s.slice(4).toLowerCase(), y = Ll.hasOwnProperty(p) ? p : null;
          if (y == null)
            return u("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", s), ps[s] = !0, !0;
          if (s !== y)
            return u("Invalid ARIA attribute `%s`. Did you mean `%s`?", s, y), ps[s] = !0, !0;
        }
        if (jI.test(s)) {
          var Z = s.toLowerCase(), X = Ll.hasOwnProperty(Z) ? Z : null;
          if (X == null)
            return ps[s] = !0, !1;
          if (s !== X)
            return u("Unknown ARIA attribute `%s`. Did you mean `%s`?", s, X), ps[s] = !0, !0;
        }
      }
      return !0;
    }
    function ll(r, s) {
      {
        var p = [];
        for (var y in s) {
          var Z = Jd(r, y);
          Z || p.push(y);
        }
        var X = p.map(function(K) {
          return "`" + K + "`";
        }).join(", ");
        p.length === 1 ? u("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", X, r) : p.length > 1 && u("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", X, r);
      }
    }
    function Pu(r, s) {
      jr(r, s) || ll(r, s);
    }
    var Sl = !1;
    function pu(r, s) {
      {
        if (r !== "input" && r !== "textarea" && r !== "select")
          return;
        s != null && s.value === null && !Sl && (Sl = !0, r === "select" && s.multiple ? u("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", r) : u("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", r));
      }
    }
    var mu = function() {
    };
    {
      var fo = {}, Qd = /^on./, yp = /^on[^A-Z]/, td = new RegExp("^(aria)-[" + Ie + "]*$"), Jh = new RegExp("^(aria)[A-Z][" + Ie + "]*$");
      mu = function(r, s, p, y) {
        if (tn.call(fo, s) && fo[s])
          return !0;
        var Z = s.toLowerCase();
        if (Z === "onfocusin" || Z === "onfocusout")
          return u("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), fo[s] = !0, !0;
        if (y != null) {
          var X = y.registrationNameDependencies, K = y.possibleRegistrationNames;
          if (X.hasOwnProperty(s))
            return !0;
          var j = K.hasOwnProperty(Z) ? K[Z] : null;
          if (j != null)
            return u("Invalid event handler property `%s`. Did you mean `%s`?", s, j), fo[s] = !0, !0;
          if (Qd.test(s))
            return u("Unknown event handler property `%s`. It will be ignored.", s), fo[s] = !0, !0;
        } else if (Qd.test(s))
          return yp.test(s) && u("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", s), fo[s] = !0, !0;
        if (td.test(s) || Jh.test(s))
          return !0;
        if (Z === "innerhtml")
          return u("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), fo[s] = !0, !0;
        if (Z === "aria")
          return u("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), fo[s] = !0, !0;
        if (Z === "is" && p !== null && p !== void 0 && typeof p != "string")
          return u("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof p), fo[s] = !0, !0;
        if (typeof p == "number" && isNaN(p))
          return u("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", s), fo[s] = !0, !0;
        var ne = ht(s), de = ne !== null && ne.type === zt;
        if (zs.hasOwnProperty(Z)) {
          var Ge = zs[Z];
          if (Ge !== s)
            return u("Invalid DOM property `%s`. Did you mean `%s`?", s, Ge), fo[s] = !0, !0;
        } else if (!de && s !== Z)
          return u("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", s, Z), fo[s] = !0, !0;
        return typeof p == "boolean" && lt(s, p, ne, !1) ? (p ? u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', p, s, s, p, s) : u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', p, s, s, p, s, s, s), fo[s] = !0, !0) : de ? !0 : lt(s, p, ne, !1) ? (fo[s] = !0, !1) : ((p === "false" || p === "true") && ne !== null && ne.type === gn && (u("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", p, s, p === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', s, p), fo[s] = !0), !0);
      };
    }
    var Oi = function(r, s, p) {
      {
        var y = [];
        for (var Z in s) {
          var X = mu(r, Z, s[Z], p);
          X || y.push(Z);
        }
        var K = y.map(function(j) {
          return "`" + j + "`";
        }).join(", ");
        y.length === 1 ? u("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", K, r) : y.length > 1 && u("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", K, r);
      }
    };
    function Rr(r, s, p) {
      jr(r, s) || Oi(r, s, p);
    }
    var xr = 1, Ma = 2, as = 4, bp = xr | Ma | as, Au = null;
    function Qh(r) {
      Au !== null && u("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Au = r;
    }
    function jh() {
      Au === null && u("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Au = null;
    }
    function nd(r) {
      return r === Au;
    }
    function Dt(r) {
      var s = r.target || r.srcElement || window;
      return s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === Uu ? s.parentNode : s;
    }
    var so = null, nr = null, Ks = null;
    function vu(r) {
      var s = Sf(r);
      if (s) {
        if (typeof so != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var p = s.stateNode;
        if (p) {
          var y = yd(p);
          so(s.stateNode, s.type, y);
        }
      }
    }
    function Rc(r) {
      so = r;
    }
    function ul(r) {
      nr ? Ks ? Ks.push(r) : Ks = [r] : nr = r;
    }
    function id() {
      return nr !== null || Ks !== null;
    }
    function kl() {
      if (nr) {
        var r = nr, s = Ks;
        if (nr = null, Ks = null, vu(r), s)
          for (var p = 0; p < s.length; p++)
            vu(s[p]);
      }
    }
    var jd = function(r, s) {
      return r(s);
    }, qh = function() {
    }, qI = !1;
    function jC() {
      var r = id();
      r && (qh(), kl());
    }
    function rd(r, s, p) {
      if (qI)
        return r(s, p);
      qI = !0;
      try {
        return jd(r, s, p);
      } finally {
        qI = !1, jC();
      }
    }
    function qd(r, s, p) {
      jd = r, qh = p;
    }
    function ad(r) {
      return r === "button" || r === "input" || r === "select" || r === "textarea";
    }
    function qC(r, s, p) {
      switch (r) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(p.disabled && ad(s));
        default:
          return !1;
      }
    }
    function Cg(r, s) {
      var p = r.stateNode;
      if (p === null)
        return null;
      var y = yd(p);
      if (y === null)
        return null;
      var Z = y[s];
      if (qC(s, r.type, y))
        return null;
      if (Z && typeof Z != "function")
        throw new Error("Expected `" + s + "` listener to be a function, instead got a value of `" + typeof Z + "` type.");
      return Z;
    }
    var $d = !1;
    if (Wt)
      try {
        var hg = {};
        Object.defineProperty(hg, "passive", {
          get: function() {
            $d = !0;
          }
        }), window.addEventListener("test", hg, hg), window.removeEventListener("test", hg, hg);
      } catch {
        $d = !1;
      }
    function eI(r, s, p, y, Z, X, K, j, ne) {
      var de = Array.prototype.slice.call(arguments, 3);
      try {
        s.apply(p, de);
      } catch (Ge) {
        this.onError(Ge);
      }
    }
    var $h = eI;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var $I = document.createElement("react");
      $h = function(s, p, y, Z, X, K, j, ne, de) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Ge = document.createEvent("Event"), rt = !1, it = !0, Vt = window.event, Xt = Object.getOwnPropertyDescriptor(window, "event");
        function Jt() {
          $I.removeEventListener(Qt, Li, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Vt);
        }
        var ri = Array.prototype.slice.call(arguments, 3);
        function Li() {
          rt = !0, Jt(), p.apply(y, ri), it = !1;
        }
        var Ni, sa = !1, Jr = !1;
        function At(vt) {
          if (Ni = vt.error, sa = !0, Ni === null && vt.colno === 0 && vt.lineno === 0 && (Jr = !0), vt.defaultPrevented && Ni != null && typeof Ni == "object")
            try {
              Ni._suppressLogging = !0;
            } catch {
            }
        }
        var Qt = "react-" + (s || "invokeguardedcallback");
        if (window.addEventListener("error", At), $I.addEventListener(Qt, Li, !1), Ge.initEvent(Qt, !1, !1), $I.dispatchEvent(Ge), Xt && Object.defineProperty(window, "event", Xt), rt && it && (sa ? Jr && (Ni = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Ni = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Ni)), window.removeEventListener("error", At), !rt)
          return Jt(), eI.apply(this, arguments);
      };
    }
    var eC = $h, Ls = !1, fg = null, cl = !1, lo = null, od = {
      onError: function(r) {
        Ls = !0, fg = r;
      }
    };
    function ms(r, s, p, y, Z, X, K, j, ne) {
      Ls = !1, fg = null, eC.apply(od, arguments);
    }
    function pg(r, s, p, y, Z, X, K, j, ne) {
      if (ms.apply(this, arguments), Ls) {
        var de = Ju();
        cl || (cl = !0, lo = de);
      }
    }
    function $C() {
      if (cl) {
        var r = lo;
        throw cl = !1, lo = null, r;
      }
    }
    function sd() {
      return Ls;
    }
    function Ju() {
      if (Ls) {
        var r = fg;
        return Ls = !1, fg = null, r;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function os(r) {
      return r._reactInternals;
    }
    function wa(r) {
      return r._reactInternals !== void 0;
    }
    function ks(r, s) {
      r._reactInternals = s;
    }
    var Hi = (
      /*                      */
      0
    ), Pi = (
      /*                */
      1
    ), ar = (
      /*                    */
      2
    ), Ci = (
      /*                       */
      4
    ), Gr = (
      /*                */
      16
    ), Ds = (
      /*                 */
      32
    ), jo = (
      /*                     */
      64
    ), Qi = (
      /*                   */
      128
    ), As = (
      /*            */
      256
    ), Zl = (
      /*                          */
      512
    ), Qa = (
      /*                     */
      1024
    ), gl = (
      /*                      */
      2048
    ), Dl = (
      /*                    */
      4096
    ), yu = (
      /*                   */
      8192
    ), xc = (
      /*             */
      16384
    ), tC = gl | Ci | jo | Zl | Qa | xc, Qu = (
      /*               */
      32767
    ), Wc = (
      /*                   */
      32768
    ), ss = (
      /*                */
      65536
    ), tI = (
      /* */
      131072
    ), mg = (
      /*                       */
      1048576
    ), Us = (
      /*                    */
      2097152
    ), qo = (
      /*                 */
      4194304
    ), ls = (
      /*                */
      8388608
    ), ja = (
      /*               */
      16777216
    ), bu = (
      /*              */
      33554432
    ), Wi = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Ci | Qa | 0
    ), uo = ar | Ci | Gr | Ds | Zl | Dl | yu, Gu = Ci | jo | Zl | yu, Nn = gl | Gr, Do = qo | ls | Us, ju = n.ReactCurrentOwner;
    function Ul(r) {
      var s = r, p = r;
      if (r.alternate)
        for (; s.return; )
          s = s.return;
      else {
        var y = s;
        do
          s = y, (s.flags & (ar | Dl)) !== Hi && (p = s.return), y = s.return;
        while (y);
      }
      return s.tag === b ? p : null;
    }
    function ef(r) {
      if (r.tag === U) {
        var s = r.memoizedState;
        if (s === null) {
          var p = r.alternate;
          p !== null && (s = p.memoizedState);
        }
        if (s !== null)
          return s.dehydrated;
      }
      return null;
    }
    function qu(r) {
      return r.tag === b ? r.stateNode.containerInfo : null;
    }
    function vs(r) {
      return Ul(r) === r;
    }
    function ys(r) {
      {
        var s = ju.current;
        if (s !== null && s.tag === h) {
          var p = s, y = p.stateNode;
          y._warnedAboutRefsInRender || u("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", gi(p) || "A component"), y._warnedAboutRefsInRender = !0;
        }
      }
      var Z = os(r);
      return Z ? Ul(Z) === Z : !1;
    }
    function Ha(r) {
      if (Ul(r) !== r)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function wl(r) {
      var s = r.alternate;
      if (!s) {
        var p = Ul(r);
        if (p === null)
          throw new Error("Unable to find node on an unmounted component.");
        return p !== r ? null : r;
      }
      for (var y = r, Z = s; ; ) {
        var X = y.return;
        if (X === null)
          break;
        var K = X.alternate;
        if (K === null) {
          var j = X.return;
          if (j !== null) {
            y = Z = j;
            continue;
          }
          break;
        }
        if (X.child === K.child) {
          for (var ne = X.child; ne; ) {
            if (ne === y)
              return Ha(X), r;
            if (ne === Z)
              return Ha(X), s;
            ne = ne.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (y.return !== Z.return)
          y = X, Z = K;
        else {
          for (var de = !1, Ge = X.child; Ge; ) {
            if (Ge === y) {
              de = !0, y = X, Z = K;
              break;
            }
            if (Ge === Z) {
              de = !0, Z = X, y = K;
              break;
            }
            Ge = Ge.sibling;
          }
          if (!de) {
            for (Ge = K.child; Ge; ) {
              if (Ge === y) {
                de = !0, y = K, Z = X;
                break;
              }
              if (Ge === Z) {
                de = !0, Z = K, y = X;
                break;
              }
              Ge = Ge.sibling;
            }
            if (!de)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (y.alternate !== Z)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (y.tag !== b)
        throw new Error("Unable to find node on an unmounted component.");
      return y.stateNode.current === y ? r : s;
    }
    function eh(r) {
      var s = wl(r);
      return s !== null ? Ol(s) : null;
    }
    function Ol(r) {
      if (r.tag === R || r.tag === W)
        return r;
      for (var s = r.child; s !== null; ) {
        var p = Ol(s);
        if (p !== null)
          return p;
        s = s.sibling;
      }
      return null;
    }
    function ld(r) {
      var s = wl(r);
      return s !== null ? Ag(s) : null;
    }
    function Ag(r) {
      if (r.tag === R || r.tag === W)
        return r;
      for (var s = r.child; s !== null; ) {
        if (s.tag !== S) {
          var p = Ag(s);
          if (p !== null)
            return p;
        }
        s = s.sibling;
      }
      return null;
    }
    var nI = t.unstable_scheduleCallback, Vc = t.unstable_cancelCallback, Pl = t.unstable_shouldYield, Ka = t.unstable_requestPaint, co = t.unstable_now, lv = t.unstable_getCurrentPriorityLevel, ud = t.unstable_ImmediatePriority, cd = t.unstable_UserBlockingPriority, Nc = t.unstable_NormalPriority, tf = t.unstable_LowPriority, vg = t.unstable_IdlePriority, th = t.unstable_yieldValue, iI = t.unstable_setDisableYieldValue, Ca = null, Ra = null, zn = null, Ro = !1, Os = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function nh(r) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var s = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (s.isDisabled)
        return !0;
      if (!s.supportsFiber)
        return u("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        wt && (r = Xn({}, r, {
          getLaneLabelMap: ya,
          injectProfilingHooks: xo
        })), Ca = s.inject(r), Ra = s;
      } catch (p) {
        u("React instrumentation encountered an error: %s.", p);
      }
      return !!s.checkDCE;
    }
    function gd(r, s) {
      if (Ra && typeof Ra.onScheduleFiberRoot == "function")
        try {
          Ra.onScheduleFiberRoot(Ca, r, s);
        } catch (p) {
          Ro || (Ro = !0, u("React instrumentation encountered an error: %s", p));
        }
    }
    function us(r, s) {
      if (Ra && typeof Ra.onCommitFiberRoot == "function")
        try {
          var p = (r.current.flags & Qi) === Qi;
          if (St) {
            var y;
            switch (s) {
              case ql:
                y = ud;
                break;
              case Ec:
                y = cd;
                break;
              case oc:
                y = Nc;
                break;
              case ah:
                y = vg;
                break;
              default:
                y = Nc;
                break;
            }
            Ra.onCommitFiberRoot(Ca, r, y, p);
          }
        } catch (Z) {
          Ro || (Ro = !0, u("React instrumentation encountered an error: %s", Z));
        }
    }
    function qa(r) {
      if (Ra && typeof Ra.onPostCommitFiberRoot == "function")
        try {
          Ra.onPostCommitFiberRoot(Ca, r);
        } catch (s) {
          Ro || (Ro = !0, u("React instrumentation encountered an error: %s", s));
        }
    }
    function On(r) {
      if (Ra && typeof Ra.onCommitFiberUnmount == "function")
        try {
          Ra.onCommitFiberUnmount(Ca, r);
        } catch (s) {
          Ro || (Ro = !0, u("React instrumentation encountered an error: %s", s));
        }
    }
    function ra(r) {
      if (typeof th == "function" && (iI(r), o(r)), Ra && typeof Ra.setStrictMode == "function")
        try {
          Ra.setStrictMode(Ca, r);
        } catch (s) {
          Ro || (Ro = !0, u("React instrumentation encountered an error: %s", s));
        }
    }
    function xo(r) {
      zn = r;
    }
    function ya() {
      {
        for (var r = /* @__PURE__ */ new Map(), s = 1, p = 0; p < dl; p++) {
          var y = _m(s);
          r.set(s, y), s *= 2;
        }
        return r;
      }
    }
    function ur(r) {
      zn !== null && typeof zn.markCommitStarted == "function" && zn.markCommitStarted(r);
    }
    function po() {
      zn !== null && typeof zn.markCommitStopped == "function" && zn.markCommitStopped();
    }
    function qr(r) {
      zn !== null && typeof zn.markComponentRenderStarted == "function" && zn.markComponentRenderStarted(r);
    }
    function ha() {
      zn !== null && typeof zn.markComponentRenderStopped == "function" && zn.markComponentRenderStopped();
    }
    function Ur(r) {
      zn !== null && typeof zn.markComponentPassiveEffectMountStarted == "function" && zn.markComponentPassiveEffectMountStarted(r);
    }
    function rI() {
      zn !== null && typeof zn.markComponentPassiveEffectMountStopped == "function" && zn.markComponentPassiveEffectMountStopped();
    }
    function mo(r) {
      zn !== null && typeof zn.markComponentPassiveEffectUnmountStarted == "function" && zn.markComponentPassiveEffectUnmountStarted(r);
    }
    function nC() {
      zn !== null && typeof zn.markComponentPassiveEffectUnmountStopped == "function" && zn.markComponentPassiveEffectUnmountStopped();
    }
    function $u(r) {
      zn !== null && typeof zn.markComponentLayoutEffectMountStarted == "function" && zn.markComponentLayoutEffectMountStarted(r);
    }
    function bs() {
      zn !== null && typeof zn.markComponentLayoutEffectMountStopped == "function" && zn.markComponentLayoutEffectMountStopped();
    }
    function Jl(r) {
      zn !== null && typeof zn.markComponentLayoutEffectUnmountStarted == "function" && zn.markComponentLayoutEffectUnmountStarted(r);
    }
    function Mc() {
      zn !== null && typeof zn.markComponentLayoutEffectUnmountStopped == "function" && zn.markComponentLayoutEffectUnmountStopped();
    }
    function Uo(r, s, p) {
      zn !== null && typeof zn.markComponentErrored == "function" && zn.markComponentErrored(r, s, p);
    }
    function ih(r, s, p) {
      zn !== null && typeof zn.markComponentSuspended == "function" && zn.markComponentSuspended(r, s, p);
    }
    function dd(r) {
      zn !== null && typeof zn.markLayoutEffectsStarted == "function" && zn.markLayoutEffectsStarted(r);
    }
    function aI() {
      zn !== null && typeof zn.markLayoutEffectsStopped == "function" && zn.markLayoutEffectsStopped();
    }
    function iC(r) {
      zn !== null && typeof zn.markPassiveEffectsStarted == "function" && zn.markPassiveEffectsStarted(r);
    }
    function Xa() {
      zn !== null && typeof zn.markPassiveEffectsStopped == "function" && zn.markPassiveEffectsStopped();
    }
    function Ql(r) {
      zn !== null && typeof zn.markRenderStarted == "function" && zn.markRenderStarted(r);
    }
    function rC() {
      zn !== null && typeof zn.markRenderYielded == "function" && zn.markRenderYielded();
    }
    function ec() {
      zn !== null && typeof zn.markRenderStopped == "function" && zn.markRenderStopped();
    }
    function oI(r) {
      zn !== null && typeof zn.markRenderScheduled == "function" && zn.markRenderScheduled(r);
    }
    function sI(r, s) {
      zn !== null && typeof zn.markForceUpdateScheduled == "function" && zn.markForceUpdateScheduled(r, s);
    }
    function tc(r, s) {
      zn !== null && typeof zn.markStateUpdateScheduled == "function" && zn.markStateUpdateScheduled(r, s);
    }
    var Kn = (
      /*                         */
      0
    ), Zi = (
      /*                 */
      1
    ), vi = (
      /*                    */
      2
    ), Or = (
      /*               */
      8
    ), La = (
      /*              */
      16
    ), yg = Math.clz32 ? Math.clz32 : Js, Ps = Math.log, Gs = Math.LN2;
    function Js(r) {
      var s = r >>> 0;
      return s === 0 ? 32 : 31 - (Ps(s) / Gs | 0) | 0;
    }
    var dl = 31, dn = (
      /*                        */
      0
    ), Wr = (
      /*                          */
      0
    ), yi = (
      /*                        */
      1
    ), nc = (
      /*    */
      2
    ), Rl = (
      /*             */
      4
    ), $a = (
      /*            */
      8
    ), jl = (
      /*                     */
      16
    ), lI = (
      /*                */
      32
    ), bg = (
      /*                       */
      4194240
    ), Gg = (
      /*                        */
      64
    ), uI = (
      /*                        */
      128
    ), nf = (
      /*                        */
      256
    ), aC = (
      /*                        */
      512
    ), oC = (
      /*                        */
      1024
    ), eo = (
      /*                        */
      2048
    ), Id = (
      /*                        */
      4096
    ), Bu = (
      /*                        */
      8192
    ), cI = (
      /*                        */
      16384
    ), $r = (
      /*                       */
      32768
    ), Ao = (
      /*                       */
      65536
    ), xl = (
      /*                       */
      131072
    ), Wl = (
      /*                       */
      262144
    ), rf = (
      /*                       */
      524288
    ), ic = (
      /*                       */
      1048576
    ), Hc = (
      /*                       */
      2097152
    ), Bg = (
      /*                            */
      130023424
    ), vo = (
      /*                             */
      4194304
    ), Xc = (
      /*                             */
      8388608
    ), gI = (
      /*                             */
      16777216
    ), Il = (
      /*                             */
      33554432
    ), Su = (
      /*                             */
      67108864
    ), rc = vo, Yc = (
      /*          */
      134217728
    ), sC = (
      /*                          */
      268435455
    ), Sg = (
      /*               */
      268435456
    ), Zu = (
      /*                        */
      536870912
    ), Vl = (
      /*                   */
      1073741824
    );
    function _m(r) {
      {
        if (r & yi)
          return "Sync";
        if (r & nc)
          return "InputContinuousHydration";
        if (r & Rl)
          return "InputContinuous";
        if (r & $a)
          return "DefaultHydration";
        if (r & jl)
          return "Default";
        if (r & lI)
          return "TransitionHydration";
        if (r & bg)
          return "Transition";
        if (r & Bg)
          return "Retry";
        if (r & Yc)
          return "SelectiveHydration";
        if (r & Sg)
          return "IdleHydration";
        if (r & Zu)
          return "Idle";
        if (r & Vl)
          return "Offscreen";
      }
    }
    var Br = -1, cs = Gg, wu = vo;
    function ac(r) {
      switch (to(r)) {
        case yi:
          return yi;
        case nc:
          return nc;
        case Rl:
          return Rl;
        case $a:
          return $a;
        case jl:
          return jl;
        case lI:
          return lI;
        case Gg:
        case uI:
        case nf:
        case aC:
        case oC:
        case eo:
        case Id:
        case Bu:
        case cI:
        case $r:
        case Ao:
        case xl:
        case Wl:
        case rf:
        case ic:
        case Hc:
          return r & bg;
        case vo:
        case Xc:
        case gI:
        case Il:
        case Su:
          return r & Bg;
        case Yc:
          return Yc;
        case Sg:
          return Sg;
        case Zu:
          return Zu;
        case Vl:
          return Vl;
        default:
          return u("Should have found matching lanes. This is a bug in React."), r;
      }
    }
    function Fc(r, s) {
      var p = r.pendingLanes;
      if (p === dn)
        return dn;
      var y = dn, Z = r.suspendedLanes, X = r.pingedLanes, K = p & sC;
      if (K !== dn) {
        var j = K & ~Z;
        if (j !== dn)
          y = ac(j);
        else {
          var ne = K & X;
          ne !== dn && (y = ac(ne));
        }
      } else {
        var de = p & ~Z;
        de !== dn ? y = ac(de) : X !== dn && (y = ac(X));
      }
      if (y === dn)
        return dn;
      if (s !== dn && s !== y && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (s & Z) === dn) {
        var Ge = to(y), rt = to(s);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          Ge >= rt || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          Ge === jl && (rt & bg) !== dn
        )
          return s;
      }
      (y & Rl) !== dn && (y |= p & jl);
      var it = r.entangledLanes;
      if (it !== dn)
        for (var Vt = r.entanglements, Xt = y & it; Xt > 0; ) {
          var Jt = It(Xt), ri = 1 << Jt;
          y |= Vt[Jt], Xt &= ~ri;
        }
      return y;
    }
    function m(r, s) {
      for (var p = r.eventTimes, y = Br; s > 0; ) {
        var Z = It(s), X = 1 << Z, K = p[Z];
        K > y && (y = K), s &= ~X;
      }
      return y;
    }
    function A(r, s) {
      switch (r) {
        case yi:
        case nc:
        case Rl:
          return s + 250;
        case $a:
        case jl:
        case lI:
        case Gg:
        case uI:
        case nf:
        case aC:
        case oC:
        case eo:
        case Id:
        case Bu:
        case cI:
        case $r:
        case Ao:
        case xl:
        case Wl:
        case rf:
        case ic:
        case Hc:
          return s + 5e3;
        case vo:
        case Xc:
        case gI:
        case Il:
        case Su:
          return Br;
        case Yc:
        case Sg:
        case Zu:
        case Vl:
          return Br;
        default:
          return u("Should have found matching lanes. This is a bug in React."), Br;
      }
    }
    function V(r, s) {
      for (var p = r.pendingLanes, y = r.suspendedLanes, Z = r.pingedLanes, X = r.expirationTimes, K = p; K > 0; ) {
        var j = It(K), ne = 1 << j, de = X[j];
        de === Br ? ((ne & y) === dn || (ne & Z) !== dn) && (X[j] = A(ne, s)) : de <= s && (r.expiredLanes |= ne), K &= ~ne;
      }
    }
    function Y(r) {
      return ac(r.pendingLanes);
    }
    function L(r) {
      var s = r.pendingLanes & ~Vl;
      return s !== dn ? s : s & Vl ? Vl : dn;
    }
    function $(r) {
      return (r & yi) !== dn;
    }
    function Ve(r) {
      return (r & sC) !== dn;
    }
    function nt(r) {
      return (r & Bg) === r;
    }
    function kt(r) {
      var s = yi | Rl | jl;
      return (r & s) === dn;
    }
    function Wn(r) {
      return (r & bg) === r;
    }
    function Jn(r, s) {
      var p = nc | Rl | $a | jl;
      return (s & p) !== dn;
    }
    function mi(r, s) {
      return (s & r.expiredLanes) !== dn;
    }
    function wi(r) {
      return (r & bg) !== dn;
    }
    function lr() {
      var r = cs;
      return cs <<= 1, (cs & bg) === dn && (cs = Gg), r;
    }
    function $n() {
      var r = wu;
      return wu <<= 1, (wu & Bg) === dn && (wu = vo), r;
    }
    function to(r) {
      return r & -r;
    }
    function gs(r) {
      return to(r);
    }
    function It(r) {
      return 31 - yg(r);
    }
    function st(r) {
      return It(r);
    }
    function Zt(r, s) {
      return (r & s) !== dn;
    }
    function Tn(r, s) {
      return (r & s) === s;
    }
    function fn(r, s) {
      return r | s;
    }
    function ji(r, s) {
      return r & ~s;
    }
    function $i(r, s) {
      return r & s;
    }
    function fr(r) {
      return r;
    }
    function xa(r, s) {
      return r !== Wr && r < s ? r : s;
    }
    function mr(r) {
      for (var s = [], p = 0; p < dl; p++)
        s.push(r);
      return s;
    }
    function Cl(r, s, p) {
      r.pendingLanes |= s, s !== Zu && (r.suspendedLanes = dn, r.pingedLanes = dn);
      var y = r.eventTimes, Z = st(s);
      y[Z] = p;
    }
    function Gp(r, s) {
      r.suspendedLanes |= s, r.pingedLanes &= ~s;
      for (var p = r.expirationTimes, y = s; y > 0; ) {
        var Z = It(y), X = 1 << Z;
        p[Z] = Br, y &= ~X;
      }
    }
    function lC(r, s, p) {
      r.pingedLanes |= r.suspendedLanes & s;
    }
    function hB(r, s) {
      var p = r.pendingLanes & ~s;
      r.pendingLanes = s, r.suspendedLanes = dn, r.pingedLanes = dn, r.expiredLanes &= s, r.mutableReadLanes &= s, r.entangledLanes &= s;
      for (var y = r.entanglements, Z = r.eventTimes, X = r.expirationTimes, K = p; K > 0; ) {
        var j = It(K), ne = 1 << j;
        y[j] = dn, Z[j] = Br, X[j] = Br, K &= ~ne;
      }
    }
    function Bp(r, s) {
      for (var p = r.entangledLanes |= s, y = r.entanglements, Z = p; Z; ) {
        var X = It(Z), K = 1 << X;
        // Is this one of the newly entangled lanes?
        K & s | // Is this lane transitively entangled with the newly entangled lanes?
        y[X] & s && (y[X] |= s), Z &= ~K;
      }
    }
    function af(r, s) {
      var p = to(s), y;
      switch (p) {
        case Rl:
          y = nc;
          break;
        case jl:
          y = $a;
          break;
        case Gg:
        case uI:
        case nf:
        case aC:
        case oC:
        case eo:
        case Id:
        case Bu:
        case cI:
        case $r:
        case Ao:
        case xl:
        case Wl:
        case rf:
        case ic:
        case Hc:
        case vo:
        case Xc:
        case gI:
        case Il:
        case Su:
          y = lI;
          break;
        case Zu:
          y = Sg;
          break;
        default:
          y = Wr;
          break;
      }
      return (y & (r.suspendedLanes | s)) !== Wr ? Wr : y;
    }
    function zm(r, s, p) {
      if (Os)
        for (var y = r.pendingUpdatersLaneMap; p > 0; ) {
          var Z = st(p), X = 1 << Z, K = y[Z];
          K.add(s), p &= ~X;
        }
    }
    function rh(r, s) {
      if (Os)
        for (var p = r.pendingUpdatersLaneMap, y = r.memoizedUpdaters; s > 0; ) {
          var Z = st(s), X = 1 << Z, K = p[Z];
          K.size > 0 && (K.forEach(function(j) {
            var ne = j.alternate;
            (ne === null || !y.has(ne)) && y.add(j);
          }), K.clear()), s &= ~X;
        }
    }
    function Zg(r, s) {
      return null;
    }
    var ql = yi, Ec = Rl, oc = jl, ah = Zu, uC = Wr;
    function Nl() {
      return uC;
    }
    function Lr(r) {
      uC = r;
    }
    function uv(r, s) {
      var p = uC;
      try {
        return uC = r, s();
      } finally {
        uC = p;
      }
    }
    function cv(r, s) {
      return r !== 0 && r < s ? r : s;
    }
    function of(r, s) {
      return r > s ? r : s;
    }
    function Bs(r, s) {
      return r !== 0 && r < s;
    }
    function Km(r) {
      var s = to(r);
      return Bs(ql, s) ? Bs(Ec, s) ? Ve(s) ? oc : ah : Ec : ql;
    }
    function oi(r) {
      var s = r.current.memoizedState;
      return s.isDehydrated;
    }
    var cC;
    function gv(r) {
      cC = r;
    }
    function dv(r) {
      cC(r);
    }
    var Lm;
    function Sp(r) {
      Lm = r;
    }
    var sf;
    function Zp(r) {
      sf = r;
    }
    var Iv;
    function Hb(r) {
      Iv = r;
    }
    var gC;
    function dC(r) {
      gC = r;
    }
    var IC = !1, Wo = [], Wa = null, no = null, $l = null, Ru = /* @__PURE__ */ new Map(), Vo = /* @__PURE__ */ new Map(), dI = [], Cd = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function fB(r) {
      return Cd.indexOf(r) > -1;
    }
    function CC(r, s, p, y, Z) {
      return {
        blockedOn: r,
        domEventName: s,
        eventSystemFlags: p,
        nativeEvent: Z,
        targetContainers: [y]
      };
    }
    function km(r, s) {
      switch (r) {
        case "focusin":
        case "focusout":
          Wa = null;
          break;
        case "dragenter":
        case "dragleave":
          no = null;
          break;
        case "mouseover":
        case "mouseout":
          $l = null;
          break;
        case "pointerover":
        case "pointerout": {
          var p = s.pointerId;
          Ru.delete(p);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var y = s.pointerId;
          Vo.delete(y);
          break;
        }
      }
    }
    function hC(r, s, p, y, Z, X) {
      if (r === null || r.nativeEvent !== X) {
        var K = CC(s, p, y, Z, X);
        if (s !== null) {
          var j = Sf(s);
          j !== null && Lm(j);
        }
        return K;
      }
      r.eventSystemFlags |= y;
      var ne = r.targetContainers;
      return Z !== null && ne.indexOf(Z) === -1 && ne.push(Z), r;
    }
    function wp(r, s, p, y, Z) {
      switch (s) {
        case "focusin": {
          var X = Z;
          return Wa = hC(Wa, r, s, p, y, X), !0;
        }
        case "dragenter": {
          var K = Z;
          return no = hC(no, r, s, p, y, K), !0;
        }
        case "mouseover": {
          var j = Z;
          return $l = hC($l, r, s, p, y, j), !0;
        }
        case "pointerover": {
          var ne = Z, de = ne.pointerId;
          return Ru.set(de, hC(Ru.get(de) || null, r, s, p, y, ne)), !0;
        }
        case "gotpointercapture": {
          var Ge = Z, rt = Ge.pointerId;
          return Vo.set(rt, hC(Vo.get(rt) || null, r, s, p, y, Ge)), !0;
        }
      }
      return !1;
    }
    function Xb(r) {
      var s = Up(r.target);
      if (s !== null) {
        var p = Ul(s);
        if (p !== null) {
          var y = p.tag;
          if (y === U) {
            var Z = ef(p);
            if (Z !== null) {
              r.blockedOn = Z, gC(r.priority, function() {
                sf(p);
              });
              return;
            }
          } else if (y === b) {
            var X = p.stateNode;
            if (oi(X)) {
              r.blockedOn = qu(p);
              return;
            }
          }
        }
      }
      r.blockedOn = null;
    }
    function lf(r) {
      for (var s = Iv(), p = {
        blockedOn: null,
        target: r,
        priority: s
      }, y = 0; y < dI.length && Bs(s, dI[y].priority); y++)
        ;
      dI.splice(y, 0, p), y === 0 && Xb(p);
    }
    function uf(r) {
      if (r.blockedOn !== null)
        return !1;
      for (var s = r.targetContainers; s.length > 0; ) {
        var p = s[0], y = df(r.domEventName, r.eventSystemFlags, p, r.nativeEvent);
        if (y === null) {
          var Z = r.nativeEvent, X = new Z.constructor(Z.type, Z);
          Qh(X), Z.target.dispatchEvent(X), jh();
        } else {
          var K = Sf(y);
          return K !== null && Lm(K), r.blockedOn = y, !1;
        }
        s.shift();
      }
      return !0;
    }
    function sc(r, s, p) {
      uf(r) && p.delete(s);
    }
    function Sr() {
      IC = !1, Wa !== null && uf(Wa) && (Wa = null), no !== null && uf(no) && (no = null), $l !== null && uf($l) && ($l = null), Ru.forEach(sc), Vo.forEach(sc);
    }
    function Vr(r, s) {
      r.blockedOn === s && (r.blockedOn = null, IC || (IC = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Sr)));
    }
    function Pr(r) {
      if (Wo.length > 0) {
        Vr(Wo[0], r);
        for (var s = 1; s < Wo.length; s++) {
          var p = Wo[s];
          p.blockedOn === r && (p.blockedOn = null);
        }
      }
      Wa !== null && Vr(Wa, r), no !== null && Vr(no, r), $l !== null && Vr($l, r);
      var y = function(j) {
        return Vr(j, r);
      };
      Ru.forEach(y), Vo.forEach(y);
      for (var Z = 0; Z < dI.length; Z++) {
        var X = dI[Z];
        X.blockedOn === r && (X.blockedOn = null);
      }
      for (; dI.length > 0; ) {
        var K = dI[0];
        if (K.blockedOn !== null)
          break;
        Xb(K), K.blockedOn === null && dI.shift();
      }
    }
    var ga = n.ReactCurrentBatchConfig, $o = !0;
    function xu(r) {
      $o = !!r;
    }
    function Ss() {
      return $o;
    }
    function Rp(r, s, p) {
      var y = fC(s), Z;
      switch (y) {
        case ql:
          Z = oh;
          break;
        case Ec:
          Z = Dm;
          break;
        case oc:
        default:
          Z = cf;
          break;
      }
      return Z.bind(null, s, p, r);
    }
    function oh(r, s, p, y) {
      var Z = Nl(), X = ga.transition;
      ga.transition = null;
      try {
        Lr(ql), cf(r, s, p, y);
      } finally {
        Lr(Z), ga.transition = X;
      }
    }
    function Dm(r, s, p, y) {
      var Z = Nl(), X = ga.transition;
      ga.transition = null;
      try {
        Lr(Ec), cf(r, s, p, y);
      } finally {
        Lr(Z), ga.transition = X;
      }
    }
    function cf(r, s, p, y) {
      $o && gf(r, s, p, y);
    }
    function gf(r, s, p, y) {
      var Z = df(r, s, p, y);
      if (Z === null) {
        er(r, s, y, Zs, p), km(r, y);
        return;
      }
      if (wp(Z, r, s, p, y)) {
        y.stopPropagation();
        return;
      }
      if (km(r, y), s & as && fB(r)) {
        for (; Z !== null; ) {
          var X = Sf(Z);
          X !== null && dv(X);
          var K = df(r, s, p, y);
          if (K === null && er(r, s, y, Zs, p), K === Z)
            break;
          Z = K;
        }
        Z !== null && y.stopPropagation();
        return;
      }
      er(r, s, y, null, p);
    }
    var Zs = null;
    function df(r, s, p, y) {
      Zs = null;
      var Z = Dt(y), X = Up(Z);
      if (X !== null) {
        var K = Ul(X);
        if (K === null)
          X = null;
        else {
          var j = K.tag;
          if (j === U) {
            var ne = ef(K);
            if (ne !== null)
              return ne;
            X = null;
          } else if (j === b) {
            var de = K.stateNode;
            if (oi(de))
              return qu(K);
            X = null;
          } else K !== X && (X = null);
        }
      }
      return Zs = X, null;
    }
    function fC(r) {
      switch (r) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ql;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Ec;
        case "message": {
          var s = lv();
          switch (s) {
            case ud:
              return ql;
            case cd:
              return Ec;
            case Nc:
            case tf:
              return oc;
            case vg:
              return ah;
            default:
              return oc;
          }
        }
        default:
          return oc;
      }
    }
    function wg(r, s, p) {
      return r.addEventListener(s, p, !1), p;
    }
    function If(r, s, p) {
      return r.addEventListener(s, p, !0), p;
    }
    function xp(r, s, p, y) {
      return r.addEventListener(s, p, {
        capture: !0,
        passive: y
      }), p;
    }
    function pC(r, s, p, y) {
      return r.addEventListener(s, p, {
        passive: y
      }), p;
    }
    var mC = null, hd = null, AC = null;
    function Cf(r) {
      return mC = r, hd = hf(), !0;
    }
    function sh() {
      mC = null, hd = null, AC = null;
    }
    function Wp() {
      if (AC)
        return AC;
      var r, s = hd, p = s.length, y, Z = hf(), X = Z.length;
      for (r = 0; r < p && s[r] === Z[r]; r++)
        ;
      var K = p - r;
      for (y = 1; y <= K && s[p - y] === Z[X - y]; y++)
        ;
      var j = y > 1 ? 1 - y : void 0;
      return AC = Z.slice(r, j), AC;
    }
    function hf() {
      return "value" in mC ? mC.value : mC.textContent;
    }
    function No(r) {
      var s, p = r.keyCode;
      return "charCode" in r ? (s = r.charCode, s === 0 && p === 13 && (s = 13)) : s = p, s === 10 && (s = 13), s >= 32 || s === 13 ? s : 0;
    }
    function Tc() {
      return !0;
    }
    function ka() {
      return !1;
    }
    function Ya(r) {
      function s(p, y, Z, X, K) {
        this._reactName = p, this._targetInst = Z, this.type = y, this.nativeEvent = X, this.target = K, this.currentTarget = null;
        for (var j in r)
          if (r.hasOwnProperty(j)) {
            var ne = r[j];
            ne ? this[j] = ne(X) : this[j] = X[j];
          }
        var de = X.defaultPrevented != null ? X.defaultPrevented : X.returnValue === !1;
        return de ? this.isDefaultPrevented = Tc : this.isDefaultPrevented = ka, this.isPropagationStopped = ka, this;
      }
      return Xn(s.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var p = this.nativeEvent;
          p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = Tc);
        },
        stopPropagation: function() {
          var p = this.nativeEvent;
          p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = Tc);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Tc
      }), s;
    }
    var II = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(r) {
        return r.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, lh = Ya(II), CI = Xn({}, II, {
      view: 0,
      detail: 0
    }), Cv = Ya(CI), _c, Vp, Rg;
    function fd(r) {
      r !== Rg && (Rg && r.type === "mousemove" ? (_c = r.screenX - Rg.screenX, Vp = r.screenY - Rg.screenY) : (_c = 0, Vp = 0), Rg = r);
    }
    var hI = Xn({}, CI, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: mv,
      button: 0,
      buttons: 0,
      relatedTarget: function(r) {
        return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
      },
      movementX: function(r) {
        return "movementX" in r ? r.movementX : (fd(r), _c);
      },
      movementY: function(r) {
        return "movementY" in r ? r.movementY : Vp;
      }
    }), fI = Ya(hI), hv = Xn({}, hI, {
      dataTransfer: 0
    }), uh = Ya(hv), Um = Xn({}, CI, {
      relatedTarget: 0
    }), ff = Ya(Um), pB = Xn({}, II, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Np = Ya(pB), pI = Xn({}, II, {
      clipboardData: function(r) {
        return "clipboardData" in r ? r.clipboardData : window.clipboardData;
      }
    }), pf = Ya(pI), pd = Xn({}, II, {
      data: 0
    }), Mp = Ya(pd), vC = Mp, Om = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Da = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Hp(r) {
      if (r.key) {
        var s = Om[r.key] || r.key;
        if (s !== "Unidentified")
          return s;
      }
      if (r.type === "keypress") {
        var p = No(r);
        return p === 13 ? "Enter" : String.fromCharCode(p);
      }
      return r.type === "keydown" || r.type === "keyup" ? Da[r.keyCode] || "Unidentified" : "";
    }
    var fv = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function pv(r) {
      var s = this, p = s.nativeEvent;
      if (p.getModifierState)
        return p.getModifierState(r);
      var y = fv[r];
      return y ? !!p[y] : !1;
    }
    function mv(r) {
      return pv;
    }
    var Av = Xn({}, CI, {
      key: Hp,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: mv,
      // Legacy Interface
      charCode: function(r) {
        return r.type === "keypress" ? No(r) : 0;
      },
      keyCode: function(r) {
        return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
      },
      which: function(r) {
        return r.type === "keypress" ? No(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
      }
    }), vv = Ya(Av), Xp = Xn({}, hI, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Mo = Ya(Xp), Yp = Xn({}, CI, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: mv
    }), mf = Ya(Yp), md = Xn({}, II, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Pm = Ya(md), Wu = Xn({}, hI, {
      deltaX: function(r) {
        return "deltaX" in r ? r.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in r ? -r.wheelDeltaX : 0
        );
      },
      deltaY: function(r) {
        return "deltaY" in r ? r.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in r ? -r.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in r ? -r.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), mI = Ya(Wu), yv = [9, 13, 27, 32], ch = 229, zc = Wt && "CompositionEvent" in window, Va = null;
    Wt && "documentMode" in document && (Va = document.documentMode);
    var yC = Wt && "TextEvent" in window && !Va, Ho = Wt && (!zc || Va && Va > 8 && Va <= 11), ws = 32, gh = String.fromCharCode(ws);
    function Af() {
      he("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), he("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), he("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), he("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var bv = !1;
    function Qn(r) {
      return (r.ctrlKey || r.altKey || r.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(r.ctrlKey && r.altKey);
    }
    function Vu(r) {
      switch (r) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Jm(r, s) {
      return r === "keydown" && s.keyCode === ch;
    }
    function AI(r, s) {
      switch (r) {
        case "keyup":
          return yv.indexOf(s.keyCode) !== -1;
        case "keydown":
          return s.keyCode !== ch;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Ad(r) {
      var s = r.detail;
      return typeof s == "object" && "data" in s ? s.data : null;
    }
    function fa(r) {
      return r.locale === "ko";
    }
    var yo = !1;
    function ds(r, s, p, y, Z) {
      var X, K;
      if (zc ? X = Vu(s) : yo ? AI(s, y) && (X = "onCompositionEnd") : Jm(s, y) && (X = "onCompositionStart"), !X)
        return null;
      Ho && !fa(y) && (!yo && X === "onCompositionStart" ? yo = Cf(Z) : X === "onCompositionEnd" && yo && (K = Wp()));
      var j = Kp(p, X);
      if (j.length > 0) {
        var ne = new Mp(X, s, null, y, Z);
        if (r.push({
          event: ne,
          listeners: j
        }), K)
          ne.data = K;
        else {
          var de = Ad(y);
          de !== null && (ne.data = de);
        }
      }
    }
    function Qm(r, s) {
      switch (r) {
        case "compositionend":
          return Ad(s);
        case "keypress":
          var p = s.which;
          return p !== ws ? null : (bv = !0, gh);
        case "textInput":
          var y = s.data;
          return y === gh && bv ? null : y;
        default:
          return null;
      }
    }
    function bC(r, s) {
      if (yo) {
        if (r === "compositionend" || !zc && AI(r, s)) {
          var p = Wp();
          return sh(), yo = !1, p;
        }
        return null;
      }
      switch (r) {
        case "paste":
          return null;
        case "keypress":
          if (!Qn(s)) {
            if (s.char && s.char.length > 1)
              return s.char;
            if (s.which)
              return String.fromCharCode(s.which);
          }
          return null;
        case "compositionend":
          return Ho && !fa(s) ? null : s.data;
        default:
          return null;
      }
    }
    function Fp(r, s, p, y, Z) {
      var X;
      if (yC ? X = Qm(s, y) : X = bC(s, y), !X)
        return null;
      var K = Kp(p, "onBeforeInput");
      if (K.length > 0) {
        var j = new vC("onBeforeInput", "beforeinput", null, y, Z);
        r.push({
          event: j,
          listeners: K
        }), j.data = X;
      }
    }
    function Ep(r, s, p, y, Z, X, K) {
      ds(r, s, p, y, Z), Fp(r, s, p, y, Z);
    }
    var mB = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function jt(r) {
      var s = r && r.nodeName && r.nodeName.toLowerCase();
      return s === "input" ? !!mB[r.type] : s === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function g(r) {
      if (!Wt)
        return !1;
      var s = "on" + r, p = s in document;
      if (!p) {
        var y = document.createElement("div");
        y.setAttribute(s, "return;"), p = typeof y[s] == "function";
      }
      return p;
    }
    function C() {
      he("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function B(r, s, p, y) {
      ul(y);
      var Z = Kp(s, "onChange");
      if (Z.length > 0) {
        var X = new lh("onChange", "change", null, p, y);
        r.push({
          event: X,
          listeners: Z
        });
      }
    }
    var N = null, F = null;
    function D(r) {
      var s = r.nodeName && r.nodeName.toLowerCase();
      return s === "select" || s === "input" && r.type === "file";
    }
    function se(r) {
      var s = [];
      B(s, F, r, Dt(r)), rd(He, s);
    }
    function He(r) {
      ZB(r, 0);
    }
    function Qe(r) {
      var s = fl(r);
      if (jg(s))
        return r;
    }
    function xt(r, s) {
      if (r === "change")
        return s;
    }
    var Cn = !1;
    Wt && (Cn = g("input") && (!document.documentMode || document.documentMode > 9));
    function Gn(r, s) {
      N = r, F = s, N.attachEvent("onpropertychange", Dn);
    }
    function pn() {
      N && (N.detachEvent("onpropertychange", Dn), N = null, F = null);
    }
    function Dn(r) {
      r.propertyName === "value" && Qe(F) && se(r);
    }
    function ei(r, s, p) {
      r === "focusin" ? (pn(), Gn(s, p)) : r === "focusout" && pn();
    }
    function bi(r, s) {
      if (r === "selectionchange" || r === "keyup" || r === "keydown")
        return Qe(F);
    }
    function Xo(r) {
      var s = r.nodeName;
      return s && s.toLowerCase() === "input" && (r.type === "checkbox" || r.type === "radio");
    }
    function dt(r, s) {
      if (r === "click")
        return Qe(s);
    }
    function tt(r, s) {
      if (r === "input" || r === "change")
        return Qe(s);
    }
    function yt(r) {
      var s = r._wrapperState;
      !s || !s.controlled || r.type !== "number" || Yi(r, "number", r.value);
    }
    function Mn(r, s, p, y, Z, X, K) {
      var j = p ? fl(p) : window, ne, de;
      if (D(j) ? ne = xt : jt(j) ? Cn ? ne = tt : (ne = bi, de = ei) : Xo(j) && (ne = dt), ne) {
        var Ge = ne(s, p);
        if (Ge) {
          B(r, Ge, y, Z);
          return;
        }
      }
      de && de(s, j, p), s === "focusout" && yt(j);
    }
    function Vi() {
      Lt("onMouseEnter", ["mouseout", "mouseover"]), Lt("onMouseLeave", ["mouseout", "mouseover"]), Lt("onPointerEnter", ["pointerout", "pointerover"]), Lt("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Ti(r, s, p, y, Z, X, K) {
      var j = s === "mouseover" || s === "pointerover", ne = s === "mouseout" || s === "pointerout";
      if (j && !nd(y)) {
        var de = y.relatedTarget || y.fromElement;
        if (de && (Up(de) || Lv(de)))
          return;
      }
      if (!(!ne && !j)) {
        var Ge;
        if (Z.window === Z)
          Ge = Z;
        else {
          var rt = Z.ownerDocument;
          rt ? Ge = rt.defaultView || rt.parentWindow : Ge = window;
        }
        var it, Vt;
        if (ne) {
          var Xt = y.relatedTarget || y.toElement;
          if (it = p, Vt = Xt ? Up(Xt) : null, Vt !== null) {
            var Jt = Ul(Vt);
            (Vt !== Jt || Vt.tag !== R && Vt.tag !== W) && (Vt = null);
          }
        } else
          it = null, Vt = p;
        if (it !== Vt) {
          var ri = fI, Li = "onMouseLeave", Ni = "onMouseEnter", sa = "mouse";
          (s === "pointerout" || s === "pointerover") && (ri = Mo, Li = "onPointerLeave", Ni = "onPointerEnter", sa = "pointer");
          var Jr = it == null ? Ge : fl(it), At = Vt == null ? Ge : fl(Vt), Qt = new ri(Li, sa + "leave", it, y, Z);
          Qt.target = Jr, Qt.relatedTarget = At;
          var vt = null, Zn = Up(Z);
          if (Zn === p) {
            var Ii = new ri(Ni, sa + "enter", Vt, y, Z);
            Ii.target = At, Ii.relatedTarget = Jr, vt = Ii;
          }
          $b(r, Qt, vt, it, Vt);
        }
      }
    }
    function Fi(r, s) {
      return r === s && (r !== 0 || 1 / r === 1 / s) || r !== r && s !== s;
    }
    var Ri = typeof Object.is == "function" ? Object.is : Fi;
    function Yo(r, s) {
      if (Ri(r, s))
        return !0;
      if (typeof r != "object" || r === null || typeof s != "object" || s === null)
        return !1;
      var p = Object.keys(r), y = Object.keys(s);
      if (p.length !== y.length)
        return !1;
      for (var Z = 0; Z < p.length; Z++) {
        var X = p[Z];
        if (!tn.call(s, X) || !Ri(r[X], s[X]))
          return !1;
      }
      return !0;
    }
    function ea(r) {
      for (; r && r.firstChild; )
        r = r.firstChild;
      return r;
    }
    function vI(r) {
      for (; r; ) {
        if (r.nextSibling)
          return r.nextSibling;
        r = r.parentNode;
      }
    }
    function Gv(r, s) {
      for (var p = ea(r), y = 0, Z = 0; p; ) {
        if (p.nodeType === Uu) {
          if (Z = y + p.textContent.length, y <= s && Z >= s)
            return {
              node: p,
              offset: s - y
            };
          y = Z;
        }
        p = ea(vI(p));
      }
    }
    function Bv(r) {
      var s = r.ownerDocument, p = s && s.defaultView || window, y = p.getSelection && p.getSelection();
      if (!y || y.rangeCount === 0)
        return null;
      var Z = y.anchorNode, X = y.anchorOffset, K = y.focusNode, j = y.focusOffset;
      try {
        Z.nodeType, K.nodeType;
      } catch {
        return null;
      }
      return Yb(r, Z, X, K, j);
    }
    function Yb(r, s, p, y, Z) {
      var X = 0, K = -1, j = -1, ne = 0, de = 0, Ge = r, rt = null;
      e: for (; ; ) {
        for (var it = null; Ge === s && (p === 0 || Ge.nodeType === Uu) && (K = X + p), Ge === y && (Z === 0 || Ge.nodeType === Uu) && (j = X + Z), Ge.nodeType === Uu && (X += Ge.nodeValue.length), (it = Ge.firstChild) !== null; )
          rt = Ge, Ge = it;
        for (; ; ) {
          if (Ge === r)
            break e;
          if (rt === s && ++ne === p && (K = X), rt === y && ++de === Z && (j = X), (it = Ge.nextSibling) !== null)
            break;
          Ge = rt, rt = Ge.parentNode;
        }
        Ge = it;
      }
      return K === -1 || j === -1 ? null : {
        start: K,
        end: j
      };
    }
    function Fb(r, s) {
      var p = r.ownerDocument || document, y = p && p.defaultView || window;
      if (y.getSelection) {
        var Z = y.getSelection(), X = r.textContent.length, K = Math.min(s.start, X), j = s.end === void 0 ? K : Math.min(s.end, X);
        if (!Z.extend && K > j) {
          var ne = j;
          j = K, K = ne;
        }
        var de = Gv(r, K), Ge = Gv(r, j);
        if (de && Ge) {
          if (Z.rangeCount === 1 && Z.anchorNode === de.node && Z.anchorOffset === de.offset && Z.focusNode === Ge.node && Z.focusOffset === Ge.offset)
            return;
          var rt = p.createRange();
          rt.setStart(de.node, de.offset), Z.removeAllRanges(), K > j ? (Z.addRange(rt), Z.extend(Ge.node, Ge.offset)) : (rt.setEnd(Ge.node, Ge.offset), Z.addRange(rt));
        }
      }
    }
    function jm(r) {
      return r && r.nodeType === Uu;
    }
    function Eb(r, s) {
      return !r || !s ? !1 : r === s ? !0 : jm(r) ? !1 : jm(s) ? Eb(r, s.parentNode) : "contains" in r ? r.contains(s) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(s) & 16) : !1;
    }
    function Tb(r) {
      return r && r.ownerDocument && Eb(r.ownerDocument.documentElement, r);
    }
    function Sv(r) {
      try {
        return typeof r.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function Zv() {
      for (var r = window, s = ku(); s instanceof r.HTMLIFrameElement; ) {
        if (Sv(s))
          r = s.contentWindow;
        else
          return s;
        s = ku(r.document);
      }
      return s;
    }
    function Tp(r) {
      var s = r && r.nodeName && r.nodeName.toLowerCase();
      return s && (s === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || s === "textarea" || r.contentEditable === "true");
    }
    function _p() {
      var r = Zv();
      return {
        focusedElem: r,
        selectionRange: Tp(r) ? _b(r) : null
      };
    }
    function AB(r) {
      var s = Zv(), p = r.focusedElem, y = r.selectionRange;
      if (s !== p && Tb(p)) {
        y !== null && Tp(p) && vB(p, y);
        for (var Z = [], X = p; X = X.parentNode; )
          X.nodeType === Es && Z.push({
            element: X,
            left: X.scrollLeft,
            top: X.scrollTop
          });
        typeof p.focus == "function" && p.focus();
        for (var K = 0; K < Z.length; K++) {
          var j = Z[K];
          j.element.scrollLeft = j.left, j.element.scrollTop = j.top;
        }
      }
    }
    function _b(r) {
      var s;
      return "selectionStart" in r ? s = {
        start: r.selectionStart,
        end: r.selectionEnd
      } : s = Bv(r), s || {
        start: 0,
        end: 0
      };
    }
    function vB(r, s) {
      var p = s.start, y = s.end;
      y === void 0 && (y = p), "selectionStart" in r ? (r.selectionStart = p, r.selectionEnd = Math.min(y, r.value.length)) : Fb(r, s);
    }
    var zb = Wt && "documentMode" in document && document.documentMode <= 11;
    function tR() {
      he("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var vf = null, qm = null, wv = null, $m = !1;
    function yB(r) {
      if ("selectionStart" in r && Tp(r))
        return {
          start: r.selectionStart,
          end: r.selectionEnd
        };
      var s = r.ownerDocument && r.ownerDocument.defaultView || window, p = s.getSelection();
      return {
        anchorNode: p.anchorNode,
        anchorOffset: p.anchorOffset,
        focusNode: p.focusNode,
        focusOffset: p.focusOffset
      };
    }
    function Kb(r) {
      return r.window === r ? r.document : r.nodeType === _a ? r : r.ownerDocument;
    }
    function Lb(r, s, p) {
      var y = Kb(p);
      if (!($m || vf == null || vf !== ku(y))) {
        var Z = yB(vf);
        if (!wv || !Yo(wv, Z)) {
          wv = Z;
          var X = Kp(qm, "onSelect");
          if (X.length > 0) {
            var K = new lh("onSelect", "select", null, s, p);
            r.push({
              event: K,
              listeners: X
            }), K.target = vf;
          }
        }
      }
    }
    function kb(r, s, p, y, Z, X, K) {
      var j = p ? fl(p) : window;
      switch (s) {
        case "focusin":
          (jt(j) || j.contentEditable === "true") && (vf = j, qm = p, wv = null);
          break;
        case "focusout":
          vf = null, qm = null, wv = null;
          break;
        case "mousedown":
          $m = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          $m = !1, Lb(r, y, Z);
          break;
        case "selectionchange":
          if (zb)
            break;
        case "keydown":
        case "keyup":
          Lb(r, y, Z);
      }
    }
    function eA(r, s) {
      var p = {};
      return p[r.toLowerCase()] = s.toLowerCase(), p["Webkit" + r] = "webkit" + s, p["Moz" + r] = "moz" + s, p;
    }
    var zp = {
      animationend: eA("Animation", "AnimationEnd"),
      animationiteration: eA("Animation", "AnimationIteration"),
      animationstart: eA("Animation", "AnimationStart"),
      transitionend: eA("Transition", "TransitionEnd")
    }, Db = {}, nR = {};
    Wt && (nR = document.createElement("div").style, "AnimationEvent" in window || (delete zp.animationend.animation, delete zp.animationiteration.animation, delete zp.animationstart.animation), "TransitionEvent" in window || delete zp.transitionend.transition);
    function tA(r) {
      if (Db[r])
        return Db[r];
      if (!zp[r])
        return r;
      var s = zp[r];
      for (var p in s)
        if (s.hasOwnProperty(p) && p in nR)
          return Db[r] = s[p];
      return r;
    }
    var bB = tA("animationend"), GB = tA("animationiteration"), BB = tA("animationstart"), iR = tA("transitionend"), Ub = /* @__PURE__ */ new Map(), Rv = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function yf(r, s) {
      Ub.set(r, s), he(s, [r]);
    }
    function QW() {
      for (var r = 0; r < Rv.length; r++) {
        var s = Rv[r], p = s.toLowerCase(), y = s[0].toUpperCase() + s.slice(1);
        yf(p, "on" + y);
      }
      yf(bB, "onAnimationEnd"), yf(GB, "onAnimationIteration"), yf(BB, "onAnimationStart"), yf("dblclick", "onDoubleClick"), yf("focusin", "onFocus"), yf("focusout", "onBlur"), yf(iR, "onTransitionEnd");
    }
    function rR(r, s, p, y, Z, X, K) {
      var j = Ub.get(s);
      if (j !== void 0) {
        var ne = lh, de = s;
        switch (s) {
          case "keypress":
            if (No(y) === 0)
              return;
          case "keydown":
          case "keyup":
            ne = vv;
            break;
          case "focusin":
            de = "focus", ne = ff;
            break;
          case "focusout":
            de = "blur", ne = ff;
            break;
          case "beforeblur":
          case "afterblur":
            ne = ff;
            break;
          case "click":
            if (y.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            ne = fI;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            ne = uh;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            ne = mf;
            break;
          case bB:
          case GB:
          case BB:
            ne = Np;
            break;
          case iR:
            ne = Pm;
            break;
          case "scroll":
            ne = Cv;
            break;
          case "wheel":
            ne = mI;
            break;
          case "copy":
          case "cut":
          case "paste":
            ne = pf;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            ne = Mo;
            break;
        }
        var Ge = (X & as) !== 0;
        {
          var rt = !Ge && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          s === "scroll", it = sR(p, j, y.type, Ge, rt);
          if (it.length > 0) {
            var Vt = new ne(j, de, null, y, Z);
            r.push({
              event: Vt,
              listeners: it
            });
          }
        }
      }
    }
    QW(), Vi(), C(), tR(), Af();
    function aR(r, s, p, y, Z, X, K) {
      rR(r, s, p, y, Z, X);
      var j = (X & bp) === 0;
      j && (Ti(r, s, p, y, Z), Mn(r, s, p, y, Z), kb(r, s, p, y, Z), Ep(r, s, p, y, Z));
    }
    var nA = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Ob = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(nA));
    function SB(r, s, p) {
      var y = r.type || "unknown-event";
      r.currentTarget = p, pg(y, s, void 0, r), r.currentTarget = null;
    }
    function Pb(r, s, p) {
      var y;
      if (p)
        for (var Z = s.length - 1; Z >= 0; Z--) {
          var X = s[Z], K = X.instance, j = X.currentTarget, ne = X.listener;
          if (K !== y && r.isPropagationStopped())
            return;
          SB(r, ne, j), y = K;
        }
      else
        for (var de = 0; de < s.length; de++) {
          var Ge = s[de], rt = Ge.instance, it = Ge.currentTarget, Vt = Ge.listener;
          if (rt !== y && r.isPropagationStopped())
            return;
          SB(r, Vt, it), y = rt;
        }
    }
    function ZB(r, s) {
      for (var p = (s & as) !== 0, y = 0; y < r.length; y++) {
        var Z = r[y], X = Z.event, K = Z.listeners;
        Pb(X, K, p);
      }
      $C();
    }
    function oR(r, s, p, y, Z) {
      var X = Dt(p), K = [];
      aR(K, r, y, p, X, s), ZB(K, s);
    }
    function bo(r, s) {
      Ob.has(r) || u('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', r);
      var p = !1, y = BV(s), Z = lR(r);
      y.has(Z) || (xv(s, r, Ma, p), y.add(Z));
    }
    function Jb(r, s, p) {
      Ob.has(r) && !s && u('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', r);
      var y = 0;
      s && (y |= as), xv(p, r, y, s);
    }
    var xg = "_reactListening" + Math.random().toString(36).slice(2);
    function lc(r) {
      if (!r[xg]) {
        r[xg] = !0, hn.forEach(function(p) {
          p !== "selectionchange" && (Ob.has(p) || Jb(p, !1, r), Jb(p, !0, r));
        });
        var s = r.nodeType === _a ? r : r.ownerDocument;
        s !== null && (s[xg] || (s[xg] = !0, Jb("selectionchange", !1, s)));
      }
    }
    function xv(r, s, p, y, Z) {
      var X = Rp(r, s, p), K = void 0;
      $d && (s === "touchstart" || s === "touchmove" || s === "wheel") && (K = !0), r = r, y ? K !== void 0 ? xp(r, s, X, K) : If(r, s, X) : K !== void 0 ? pC(r, s, X, K) : wg(r, s, X);
    }
    function Qb(r, s) {
      return r === s || r.nodeType === Kr && r.parentNode === s;
    }
    function er(r, s, p, y, Z) {
      var X = y;
      if (!(s & xr) && !(s & Ma)) {
        var K = Z;
        if (y !== null) {
          var j = y;
          e: for (; ; ) {
            if (j === null)
              return;
            var ne = j.tag;
            if (ne === b || ne === S) {
              var de = j.stateNode.containerInfo;
              if (Qb(de, K))
                break;
              if (ne === S)
                for (var Ge = j.return; Ge !== null; ) {
                  var rt = Ge.tag;
                  if (rt === b || rt === S) {
                    var it = Ge.stateNode.containerInfo;
                    if (Qb(it, K))
                      return;
                  }
                  Ge = Ge.return;
                }
              for (; de !== null; ) {
                var Vt = Up(de);
                if (Vt === null)
                  return;
                var Xt = Vt.tag;
                if (Xt === R || Xt === W) {
                  j = X = Vt;
                  continue e;
                }
                de = de.parentNode;
              }
            }
            j = j.return;
          }
        }
      }
      rd(function() {
        return oR(r, s, p, X);
      });
    }
    function vd(r, s, p) {
      return {
        instance: r,
        listener: s,
        currentTarget: p
      };
    }
    function sR(r, s, p, y, Z, X) {
      for (var K = s !== null ? s + "Capture" : null, j = y ? K : s, ne = [], de = r, Ge = null; de !== null; ) {
        var rt = de, it = rt.stateNode, Vt = rt.tag;
        if (Vt === R && it !== null && (Ge = it, j !== null)) {
          var Xt = Cg(de, j);
          Xt != null && ne.push(vd(de, Xt, Ge));
        }
        if (Z)
          break;
        de = de.return;
      }
      return ne;
    }
    function Kp(r, s) {
      for (var p = s + "Capture", y = [], Z = r; Z !== null; ) {
        var X = Z, K = X.stateNode, j = X.tag;
        if (j === R && K !== null) {
          var ne = K, de = Cg(Z, p);
          de != null && y.unshift(vd(Z, de, ne));
          var Ge = Cg(Z, s);
          Ge != null && y.push(vd(Z, Ge, ne));
        }
        Z = Z.return;
      }
      return y;
    }
    function GC(r) {
      if (r === null)
        return null;
      do
        r = r.return;
      while (r && r.tag !== R);
      return r || null;
    }
    function jb(r, s) {
      for (var p = r, y = s, Z = 0, X = p; X; X = GC(X))
        Z++;
      for (var K = 0, j = y; j; j = GC(j))
        K++;
      for (; Z - K > 0; )
        p = GC(p), Z--;
      for (; K - Z > 0; )
        y = GC(y), K--;
      for (var ne = Z; ne--; ) {
        if (p === y || y !== null && p === y.alternate)
          return p;
        p = GC(p), y = GC(y);
      }
      return null;
    }
    function qb(r, s, p, y, Z) {
      for (var X = s._reactName, K = [], j = p; j !== null && j !== y; ) {
        var ne = j, de = ne.alternate, Ge = ne.stateNode, rt = ne.tag;
        if (de !== null && de === y)
          break;
        if (rt === R && Ge !== null) {
          var it = Ge;
          if (Z) {
            var Vt = Cg(j, X);
            Vt != null && K.unshift(vd(j, Vt, it));
          } else if (!Z) {
            var Xt = Cg(j, X);
            Xt != null && K.push(vd(j, Xt, it));
          }
        }
        j = j.return;
      }
      K.length !== 0 && r.push({
        event: s,
        listeners: K
      });
    }
    function $b(r, s, p, y, Z) {
      var X = y && Z ? jb(y, Z) : null;
      y !== null && qb(r, s, y, X, !1), Z !== null && p !== null && qb(r, p, Z, X, !0);
    }
    function lR(r, s) {
      return r + "__bubble";
    }
    var Kc = !1, Wv = "dangerouslySetInnerHTML", e0 = "suppressContentEditableWarning", dh = "suppressHydrationWarning", wB = "autoFocus", Ih = "children", bf = "style", Lp = "__html", Lc, iA, Nu, t0, rA, Vv, uR;
    Lc = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, iA = function(r, s) {
      Pu(r, s), pu(r, s), Rr(r, s, {
        registrationNameDependencies: mn,
        possibleRegistrationNames: Pn
      });
    }, Vv = Wt && !document.documentMode, Nu = function(r, s, p) {
      if (!Kc) {
        var y = Nv(p), Z = Nv(s);
        Z !== y && (Kc = !0, u("Prop `%s` did not match. Server: %s Client: %s", r, JSON.stringify(Z), JSON.stringify(y)));
      }
    }, t0 = function(r) {
      if (!Kc) {
        Kc = !0;
        var s = [];
        r.forEach(function(p) {
          s.push(p);
        }), u("Extra attributes from the server: %s", s);
      }
    }, rA = function(r, s) {
      s === !1 ? u("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", r, r, r) : u("Expected `%s` listener to be a function, instead got a value of `%s` type.", r, typeof s);
    }, uR = function(r, s) {
      var p = r.namespaceURI === Cu ? r.ownerDocument.createElement(r.tagName) : r.ownerDocument.createElementNS(r.namespaceURI, r.tagName);
      return p.innerHTML = s, p.innerHTML;
    };
    var RB = /\r\n?/g, jW = /\u0000|\uFFFD/g;
    function Nv(r) {
      Ft(r);
      var s = typeof r == "string" ? r : "" + r;
      return s.replace(RB, `
`).replace(jW, "");
    }
    function aA(r, s, p, y) {
      var Z = Nv(s), X = Nv(r);
      if (X !== Z && (y && (Kc || (Kc = !0, u('Text content did not match. Server: "%s" Client: "%s"', X, Z))), p && ee))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function xB(r) {
      return r.nodeType === _a ? r : r.ownerDocument;
    }
    function qW() {
    }
    function n0(r) {
      r.onclick = qW;
    }
    function cR(r, s, p, y, Z) {
      for (var X in y)
        if (y.hasOwnProperty(X)) {
          var K = y[X];
          if (X === bf)
            K && Object.freeze(K), Pd(s, K);
          else if (X === Wv) {
            var j = K ? K[Lp] : void 0;
            j != null && mp(s, j);
          } else if (X === Ih)
            if (typeof K == "string") {
              var ne = r !== "textarea" || K !== "";
              ne && Zc(s, K);
            } else typeof K == "number" && Zc(s, "" + K);
          else X === e0 || X === dh || X === wB || (mn.hasOwnProperty(X) ? K != null && (typeof K != "function" && rA(X, K), X === "onScroll" && bo("scroll", s)) : K != null && la(s, X, K, Z));
        }
    }
    function gR(r, s, p, y) {
      for (var Z = 0; Z < s.length; Z += 2) {
        var X = s[Z], K = s[Z + 1];
        X === bf ? Pd(r, K) : X === Wv ? mp(r, K) : X === Ih ? Zc(r, K) : la(r, X, K, y);
      }
    }
    function $W(r, s, p, y) {
      var Z, X = xB(p), K, j = y;
      if (j === Cu && (j = cg(r)), j === Cu) {
        if (Z = jr(r, s), !Z && r !== r.toLowerCase() && u("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", r), r === "script") {
          var ne = X.createElement("div");
          ne.innerHTML = "<script><\/script>";
          var de = ne.firstChild;
          K = ne.removeChild(de);
        } else if (typeof s.is == "string")
          K = X.createElement(r, {
            is: s.is
          });
        else if (K = X.createElement(r), r === "select") {
          var Ge = K;
          s.multiple ? Ge.multiple = !0 : s.size && (Ge.size = s.size);
        }
      } else
        K = X.createElementNS(j, r);
      return j === Cu && !Z && Object.prototype.toString.call(K) === "[object HTMLUnknownElement]" && !tn.call(Lc, r) && (Lc[r] = !0, u("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", r)), K;
    }
    function eV(r, s) {
      return xB(s).createTextNode(r);
    }
    function BC(r, s, p, y) {
      var Z = jr(s, p);
      iA(s, p);
      var X;
      switch (s) {
        case "dialog":
          bo("cancel", r), bo("close", r), X = p;
          break;
        case "iframe":
        case "object":
        case "embed":
          bo("load", r), X = p;
          break;
        case "video":
        case "audio":
          for (var K = 0; K < nA.length; K++)
            bo(nA[K], r);
          X = p;
          break;
        case "source":
          bo("error", r), X = p;
          break;
        case "img":
        case "image":
        case "link":
          bo("error", r), bo("load", r), X = p;
          break;
        case "details":
          bo("toggle", r), X = p;
          break;
        case "input":
          De(r, p), X = ie(r, p), bo("invalid", r);
          break;
        case "option":
          vr(r, p), X = p;
          break;
        case "select":
          OI(r, p), X = UI(r, p), bo("invalid", r);
          break;
        case "textarea":
          Dh(r, p), X = kh(r, p), bo("invalid", r);
          break;
        default:
          X = p;
      }
      switch (Qr(s, X), cR(s, r, y, X, Z), s) {
        case "input":
          du(r), wn(r, p, !1);
          break;
        case "textarea":
          du(r), ug(r);
          break;
        case "option":
          br(r, p);
          break;
        case "select":
          DC(r, p);
          break;
        default:
          typeof X.onClick == "function" && n0(r);
          break;
      }
    }
    function dR(r, s, p, y, Z) {
      iA(s, y);
      var X = null, K, j;
      switch (s) {
        case "input":
          K = ie(r, p), j = ie(r, y), X = [];
          break;
        case "select":
          K = UI(r, p), j = UI(r, y), X = [];
          break;
        case "textarea":
          K = kh(r, p), j = kh(r, y), X = [];
          break;
        default:
          K = p, j = y, typeof K.onClick != "function" && typeof j.onClick == "function" && n0(r);
          break;
      }
      Qr(s, j);
      var ne, de, Ge = null;
      for (ne in K)
        if (!(j.hasOwnProperty(ne) || !K.hasOwnProperty(ne) || K[ne] == null))
          if (ne === bf) {
            var rt = K[ne];
            for (de in rt)
              rt.hasOwnProperty(de) && (Ge || (Ge = {}), Ge[de] = "");
          } else ne === Wv || ne === Ih || ne === e0 || ne === dh || ne === wB || (mn.hasOwnProperty(ne) ? X || (X = []) : (X = X || []).push(ne, null));
      for (ne in j) {
        var it = j[ne], Vt = K?.[ne];
        if (!(!j.hasOwnProperty(ne) || it === Vt || it == null && Vt == null))
          if (ne === bf)
            if (it && Object.freeze(it), Vt) {
              for (de in Vt)
                Vt.hasOwnProperty(de) && (!it || !it.hasOwnProperty(de)) && (Ge || (Ge = {}), Ge[de] = "");
              for (de in it)
                it.hasOwnProperty(de) && Vt[de] !== it[de] && (Ge || (Ge = {}), Ge[de] = it[de]);
            } else
              Ge || (X || (X = []), X.push(ne, Ge)), Ge = it;
          else if (ne === Wv) {
            var Xt = it ? it[Lp] : void 0, Jt = Vt ? Vt[Lp] : void 0;
            Xt != null && Jt !== Xt && (X = X || []).push(ne, Xt);
          } else ne === Ih ? (typeof it == "string" || typeof it == "number") && (X = X || []).push(ne, "" + it) : ne === e0 || ne === dh || (mn.hasOwnProperty(ne) ? (it != null && (typeof it != "function" && rA(ne, it), ne === "onScroll" && bo("scroll", r)), !X && Vt !== it && (X = [])) : (X = X || []).push(ne, it));
      }
      return Ge && (fu(Ge, j[bf]), (X = X || []).push(bf, Ge)), X;
    }
    function IR(r, s, p, y, Z) {
      p === "input" && Z.type === "radio" && Z.name != null && bt(r, Z);
      var X = jr(p, y), K = jr(p, Z);
      switch (gR(r, s, X, K), p) {
        case "input":
          Et(r, Z);
          break;
        case "textarea":
          Dd(r, Z);
          break;
        case "select":
          UC(r, Z);
          break;
      }
    }
    function Mv(r) {
      {
        var s = r.toLowerCase();
        return zs.hasOwnProperty(s) && zs[s] || null;
      }
    }
    function Hv(r, s, p, y, Z, X, K) {
      var j, ne;
      switch (j = jr(s, p), iA(s, p), s) {
        case "dialog":
          bo("cancel", r), bo("close", r);
          break;
        case "iframe":
        case "object":
        case "embed":
          bo("load", r);
          break;
        case "video":
        case "audio":
          for (var de = 0; de < nA.length; de++)
            bo(nA[de], r);
          break;
        case "source":
          bo("error", r);
          break;
        case "img":
        case "image":
        case "link":
          bo("error", r), bo("load", r);
          break;
        case "details":
          bo("toggle", r);
          break;
        case "input":
          De(r, p), bo("invalid", r);
          break;
        case "option":
          vr(r, p);
          break;
        case "select":
          OI(r, p), bo("invalid", r);
          break;
        case "textarea":
          Dh(r, p), bo("invalid", r);
          break;
      }
      Qr(s, p);
      {
        ne = /* @__PURE__ */ new Set();
        for (var Ge = r.attributes, rt = 0; rt < Ge.length; rt++) {
          var it = Ge[rt].name.toLowerCase();
          switch (it) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              ne.add(Ge[rt].name);
          }
        }
      }
      var Vt = null;
      for (var Xt in p)
        if (p.hasOwnProperty(Xt)) {
          var Jt = p[Xt];
          if (Xt === Ih)
            typeof Jt == "string" ? r.textContent !== Jt && (p[dh] !== !0 && aA(r.textContent, Jt, X, K), Vt = [Ih, Jt]) : typeof Jt == "number" && r.textContent !== "" + Jt && (p[dh] !== !0 && aA(r.textContent, Jt, X, K), Vt = [Ih, "" + Jt]);
          else if (mn.hasOwnProperty(Xt))
            Jt != null && (typeof Jt != "function" && rA(Xt, Jt), Xt === "onScroll" && bo("scroll", r));
          else if (K && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof j == "boolean") {
            var ri = void 0, Li = j && ke ? null : ht(Xt);
            if (p[dh] !== !0) {
              if (!(Xt === e0 || Xt === dh || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Xt === "value" || Xt === "checked" || Xt === "selected")) {
                if (Xt === Wv) {
                  var Ni = r.innerHTML, sa = Jt ? Jt[Lp] : void 0;
                  if (sa != null) {
                    var Jr = uR(r, sa);
                    Jr !== Ni && Nu(Xt, Ni, Jr);
                  }
                } else if (Xt === bf) {
                  if (ne.delete(Xt), Vv) {
                    var At = Dr(Jt);
                    ri = r.getAttribute("style"), At !== ri && Nu(Xt, ri, At);
                  }
                } else if (j && !ke)
                  ne.delete(Xt.toLowerCase()), ri = na(r, Xt, Jt), Jt !== ri && Nu(Xt, ri, Jt);
                else if (!Re(Xt, Li, j) && !_e(Xt, Jt, Li, j)) {
                  var Qt = !1;
                  if (Li !== null)
                    ne.delete(Li.attributeName), ri = zr(r, Xt, Jt, Li);
                  else {
                    var vt = y;
                    if (vt === Cu && (vt = cg(s)), vt === Cu)
                      ne.delete(Xt.toLowerCase());
                    else {
                      var Zn = Mv(Xt);
                      Zn !== null && Zn !== Xt && (Qt = !0, ne.delete(Zn)), ne.delete(Xt);
                    }
                    ri = na(r, Xt, Jt);
                  }
                  var Ii = ke;
                  !Ii && Jt !== ri && !Qt && Nu(Xt, ri, Jt);
                }
              }
            }
          }
        }
      switch (K && // $FlowFixMe - Should be inferred as not undefined.
      ne.size > 0 && p[dh] !== !0 && t0(ne), s) {
        case "input":
          du(r), wn(r, p, !0);
          break;
        case "textarea":
          du(r), ug(r);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof p.onClick == "function" && n0(r);
          break;
      }
      return Vt;
    }
    function i0(r, s, p) {
      var y = r.nodeValue !== s;
      return y;
    }
    function oA(r, s) {
      {
        if (Kc)
          return;
        Kc = !0, u("Did not expect server HTML to contain a <%s> in <%s>.", s.nodeName.toLowerCase(), r.nodeName.toLowerCase());
      }
    }
    function r0(r, s) {
      {
        if (Kc)
          return;
        Kc = !0, u('Did not expect server HTML to contain the text node "%s" in <%s>.', s.nodeValue, r.nodeName.toLowerCase());
      }
    }
    function kp(r, s, p) {
      {
        if (Kc)
          return;
        Kc = !0, u("Expected server HTML to contain a matching <%s> in <%s>.", s, r.nodeName.toLowerCase());
      }
    }
    function hl(r, s) {
      {
        if (s === "" || Kc)
          return;
        Kc = !0, u('Expected server HTML to contain a matching text node for "%s" in <%s>.', s, r.nodeName.toLowerCase());
      }
    }
    function CR(r, s, p) {
      switch (s) {
        case "input":
          ui(r, p);
          return;
        case "textarea":
          Uh(r, p);
          return;
        case "select":
          fp(r, p);
          return;
      }
    }
    var Ch = function() {
    }, uc = function() {
    };
    {
      var WB = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], sA = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], VB = sA.concat(["button"]), NB = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], a0 = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      uc = function(r, s) {
        var p = Xn({}, r || a0), y = {
          tag: s
        };
        return sA.indexOf(s) !== -1 && (p.aTagInScope = null, p.buttonTagInScope = null, p.nobrTagInScope = null), VB.indexOf(s) !== -1 && (p.pTagInButtonScope = null), WB.indexOf(s) !== -1 && s !== "address" && s !== "div" && s !== "p" && (p.listItemTagAutoclosing = null, p.dlItemTagAutoclosing = null), p.current = y, s === "form" && (p.formTag = y), s === "a" && (p.aTagInScope = y), s === "button" && (p.buttonTagInScope = y), s === "nobr" && (p.nobrTagInScope = y), s === "p" && (p.pTagInButtonScope = y), s === "li" && (p.listItemTagAutoclosing = y), (s === "dd" || s === "dt") && (p.dlItemTagAutoclosing = y), p;
      };
      var Dp = function(r, s) {
        switch (s) {
          case "select":
            return r === "option" || r === "optgroup" || r === "#text";
          case "optgroup":
            return r === "option" || r === "#text";
          case "option":
            return r === "#text";
          case "tr":
            return r === "th" || r === "td" || r === "style" || r === "script" || r === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return r === "tr" || r === "style" || r === "script" || r === "template";
          case "colgroup":
            return r === "col" || r === "template";
          case "table":
            return r === "caption" || r === "colgroup" || r === "tbody" || r === "tfoot" || r === "thead" || r === "style" || r === "script" || r === "template";
          case "head":
            return r === "base" || r === "basefont" || r === "bgsound" || r === "link" || r === "meta" || r === "title" || r === "noscript" || r === "noframes" || r === "style" || r === "script" || r === "template";
          case "html":
            return r === "head" || r === "body" || r === "frameset";
          case "frameset":
            return r === "frame";
          case "#document":
            return r === "html";
        }
        switch (r) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return s !== "h1" && s !== "h2" && s !== "h3" && s !== "h4" && s !== "h5" && s !== "h6";
          case "rp":
          case "rt":
            return NB.indexOf(s) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return s == null;
        }
        return !0;
      }, MB = function(r, s) {
        switch (r) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return s.pTagInButtonScope;
          case "form":
            return s.formTag || s.pTagInButtonScope;
          case "li":
            return s.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return s.dlItemTagAutoclosing;
          case "button":
            return s.buttonTagInScope;
          case "a":
            return s.aTagInScope;
          case "nobr":
            return s.nobrTagInScope;
        }
        return null;
      }, Xv = {};
      Ch = function(r, s, p) {
        p = p || a0;
        var y = p.current, Z = y && y.tag;
        s != null && (r != null && u("validateDOMNesting: when childText is passed, childTag should be null"), r = "#text");
        var X = Dp(r, Z) ? null : y, K = X ? null : MB(r, p), j = X || K;
        if (j) {
          var ne = j.tag, de = !!X + "|" + r + "|" + ne;
          if (!Xv[de]) {
            Xv[de] = !0;
            var Ge = r, rt = "";
            if (r === "#text" ? /\S/.test(s) ? Ge = "Text nodes" : (Ge = "Whitespace text nodes", rt = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Ge = "<" + r + ">", X) {
              var it = "";
              ne === "table" && r === "tr" && (it += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), u("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Ge, ne, rt, it);
            } else
              u("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Ge, ne);
          }
        }
      };
    }
    var Ml = "suppressHydrationWarning", o0 = "$", Yv = "/$", lA = "$?", uA = "$!", hR = "style", HB = null, XB = null;
    function tV(r) {
      var s, p, y = r.nodeType;
      switch (y) {
        case _a:
        case ca: {
          s = y === _a ? "#document" : "#fragment";
          var Z = r.documentElement;
          p = Z ? Z.namespaceURI : Du(null, "");
          break;
        }
        default: {
          var X = y === Kr ? r.parentNode : r, K = X.namespaceURI || null;
          s = X.tagName, p = Du(K, s);
          break;
        }
      }
      {
        var j = s.toLowerCase(), ne = uc(null, j);
        return {
          namespace: p,
          ancestorInfo: ne
        };
      }
    }
    function fR(r, s, p) {
      {
        var y = r, Z = Du(y.namespace, s), X = uc(y.ancestorInfo, s);
        return {
          namespace: Z,
          ancestorInfo: X
        };
      }
    }
    function pR(r) {
      return r;
    }
    function mR(r) {
      HB = Ss(), XB = _p();
      var s = null;
      return xu(!1), s;
    }
    function YB(r) {
      AB(XB), xu(HB), HB = null, XB = null;
    }
    function AR(r, s, p, y, Z) {
      var X;
      {
        var K = y;
        if (Ch(r, null, K.ancestorInfo), typeof s.children == "string" || typeof s.children == "number") {
          var j = "" + s.children, ne = uc(K.ancestorInfo, r);
          Ch(null, j, ne);
        }
        X = K.namespace;
      }
      var de = $W(r, s, p, X);
      return Bf(Z, de), JB(de, s), de;
    }
    function nV(r, s) {
      r.appendChild(s);
    }
    function vR(r, s, p, y, Z) {
      switch (BC(r, s, p, y), s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!p.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function iV(r, s, p, y, Z, X) {
      {
        var K = X;
        if (typeof y.children != typeof p.children && (typeof y.children == "string" || typeof y.children == "number")) {
          var j = "" + y.children, ne = uc(K.ancestorInfo, s);
          Ch(null, j, ne);
        }
      }
      return dR(r, s, p, y);
    }
    function FB(r, s) {
      return r === "textarea" || r === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null;
    }
    function rV(r, s, p, y) {
      {
        var Z = p;
        Ch(null, r, Z.ancestorInfo);
      }
      var X = eV(r, s);
      return Bf(y, X), X;
    }
    function aV() {
      var r = window.event;
      return r === void 0 ? oc : fC(r.type);
    }
    var EB = typeof setTimeout == "function" ? setTimeout : void 0, TB = typeof clearTimeout == "function" ? clearTimeout : void 0, cA = -1, Fv = typeof Promise == "function" ? Promise : void 0, yR = typeof queueMicrotask == "function" ? queueMicrotask : typeof Fv < "u" ? function(r) {
      return Fv.resolve(null).then(r).catch(oV);
    } : EB;
    function oV(r) {
      setTimeout(function() {
        throw r;
      });
    }
    function bR(r, s, p, y) {
      switch (s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && r.focus();
          return;
        case "img": {
          p.src && (r.src = p.src);
          return;
        }
      }
    }
    function GR(r, s, p, y, Z, X) {
      IR(r, s, p, y, Z), JB(r, Z);
    }
    function s0(r) {
      Zc(r, "");
    }
    function sV(r, s, p) {
      r.nodeValue = p;
    }
    function _B(r, s) {
      r.appendChild(s);
    }
    function BR(r, s) {
      var p;
      r.nodeType === Kr ? (p = r.parentNode, p.insertBefore(s, r)) : (p = r, p.appendChild(s));
      var y = r._reactRootContainer;
      y == null && p.onclick === null && n0(p);
    }
    function SR(r, s, p) {
      r.insertBefore(s, p);
    }
    function ZR(r, s, p) {
      r.nodeType === Kr ? r.parentNode.insertBefore(s, p) : r.insertBefore(s, p);
    }
    function l0(r, s) {
      r.removeChild(s);
    }
    function lV(r, s) {
      r.nodeType === Kr ? r.parentNode.removeChild(s) : r.removeChild(s);
    }
    function zB(r, s) {
      var p = s, y = 0;
      do {
        var Z = p.nextSibling;
        if (r.removeChild(p), Z && Z.nodeType === Kr) {
          var X = Z.data;
          if (X === Yv)
            if (y === 0) {
              r.removeChild(Z), Pr(s);
              return;
            } else
              y--;
          else (X === o0 || X === lA || X === uA) && y++;
        }
        p = Z;
      } while (p);
      Pr(s);
    }
    function uV(r, s) {
      r.nodeType === Kr ? zB(r.parentNode, s) : r.nodeType === Es && zB(r, s), Pr(r);
    }
    function wR(r) {
      r = r;
      var s = r.style;
      typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none";
    }
    function cV(r) {
      r.nodeValue = "";
    }
    function gV(r, s) {
      r = r;
      var p = s[hR], y = p != null && p.hasOwnProperty("display") ? p.display : null;
      r.style.display = Ou("display", y);
    }
    function dV(r, s) {
      r.nodeValue = s;
    }
    function IV(r) {
      r.nodeType === Es ? r.textContent = "" : r.nodeType === _a && r.documentElement && r.removeChild(r.documentElement);
    }
    function RR(r, s, p) {
      return r.nodeType !== Es || s.toLowerCase() !== r.nodeName.toLowerCase() ? null : r;
    }
    function CV(r, s) {
      return s === "" || r.nodeType !== Uu ? null : r;
    }
    function KB(r) {
      return r.nodeType !== Kr ? null : r;
    }
    function LB(r) {
      return r.data === lA;
    }
    function kB(r) {
      return r.data === uA;
    }
    function xR(r) {
      var s = r.nextSibling && r.nextSibling.dataset, p, y, Z;
      return s && (p = s.dgst, y = s.msg, Z = s.stck), {
        message: y,
        digest: p,
        stack: Z
      };
    }
    function hV(r, s) {
      r._reactRetry = s;
    }
    function Ev(r) {
      for (; r != null; r = r.nextSibling) {
        var s = r.nodeType;
        if (s === Es || s === Uu)
          break;
        if (s === Kr) {
          var p = r.data;
          if (p === o0 || p === uA || p === lA)
            break;
          if (p === Yv)
            return null;
        }
      }
      return r;
    }
    function Tv(r) {
      return Ev(r.nextSibling);
    }
    function u0(r) {
      return Ev(r.firstChild);
    }
    function hh(r) {
      return Ev(r.firstChild);
    }
    function fV(r) {
      return Ev(r.nextSibling);
    }
    function DB(r, s, p, y, Z, X, K) {
      Bf(X, r), JB(r, p);
      var j;
      {
        var ne = Z;
        j = ne.namespace;
      }
      var de = (X.mode & Zi) !== Kn;
      return Hv(r, s, p, j, y, de, K);
    }
    function pV(r, s, p, y) {
      return Bf(p, r), p.mode & Zi, i0(r, s);
    }
    function WR(r, s) {
      Bf(s, r);
    }
    function mV(r) {
      for (var s = r.nextSibling, p = 0; s; ) {
        if (s.nodeType === Kr) {
          var y = s.data;
          if (y === Yv) {
            if (p === 0)
              return Tv(s);
            p--;
          } else (y === o0 || y === uA || y === lA) && p++;
        }
        s = s.nextSibling;
      }
      return null;
    }
    function UB(r) {
      for (var s = r.previousSibling, p = 0; s; ) {
        if (s.nodeType === Kr) {
          var y = s.data;
          if (y === o0 || y === uA || y === lA) {
            if (p === 0)
              return s;
            p--;
          } else y === Yv && p++;
        }
        s = s.previousSibling;
      }
      return null;
    }
    function VR(r) {
      Pr(r);
    }
    function NR(r) {
      Pr(r);
    }
    function OB(r) {
      return r !== "head" && r !== "body";
    }
    function AV(r, s, p, y) {
      var Z = !0;
      aA(s.nodeValue, p, y, Z);
    }
    function _v(r, s, p, y, Z, X) {
      if (s[Ml] !== !0) {
        var K = !0;
        aA(y.nodeValue, Z, X, K);
      }
    }
    function c0(r, s) {
      s.nodeType === Es ? oA(r, s) : s.nodeType === Kr || r0(r, s);
    }
    function vV(r, s) {
      {
        var p = r.parentNode;
        p !== null && (s.nodeType === Es ? oA(p, s) : s.nodeType === Kr || r0(p, s));
      }
    }
    function MR(r, s, p, y, Z) {
      (Z || s[Ml] !== !0) && (y.nodeType === Es ? oA(p, y) : y.nodeType === Kr || r0(p, y));
    }
    function yV(r, s, p) {
      kp(r, s);
    }
    function HR(r, s) {
      hl(r, s);
    }
    function XR(r, s, p) {
      {
        var y = r.parentNode;
        y !== null && kp(y, s);
      }
    }
    function g0(r, s) {
      {
        var p = r.parentNode;
        p !== null && hl(p, s);
      }
    }
    function Gf(r, s, p, y, Z, X) {
      (X || s[Ml] !== !0) && kp(p, y);
    }
    function bV(r, s, p, y, Z) {
      (Z || s[Ml] !== !0) && hl(p, y);
    }
    function ii(r) {
      u("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", r.nodeName.toLowerCase());
    }
    function gA(r) {
      lc(r);
    }
    var yI = Math.random().toString(36).slice(2), Is = "__reactFiber$" + yI, PB = "__reactProps$" + yI, dA = "__reactContainer$" + yI, zv = "__reactEvents$" + yI, GV = "__reactListeners$" + yI, YR = "__reactHandles$" + yI;
    function d0(r) {
      delete r[Is], delete r[PB], delete r[zv], delete r[GV], delete r[YR];
    }
    function Bf(r, s) {
      s[Is] = r;
    }
    function Kv(r, s) {
      s[dA] = r;
    }
    function FR(r) {
      r[dA] = null;
    }
    function Lv(r) {
      return !!r[dA];
    }
    function Up(r) {
      var s = r[Is];
      if (s)
        return s;
      for (var p = r.parentNode; p; ) {
        if (s = p[dA] || p[Is], s) {
          var y = s.alternate;
          if (s.child !== null || y !== null && y.child !== null)
            for (var Z = UB(r); Z !== null; ) {
              var X = Z[Is];
              if (X)
                return X;
              Z = UB(Z);
            }
          return s;
        }
        r = p, p = r.parentNode;
      }
      return null;
    }
    function Sf(r) {
      var s = r[Is] || r[dA];
      return s && (s.tag === R || s.tag === W || s.tag === U || s.tag === b) ? s : null;
    }
    function fl(r) {
      if (r.tag === R || r.tag === W)
        return r.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function yd(r) {
      return r[PB] || null;
    }
    function JB(r, s) {
      r[PB] = s;
    }
    function BV(r) {
      var s = r[zv];
      return s === void 0 && (s = r[zv] = /* @__PURE__ */ new Set()), s;
    }
    var ER = {}, TR = n.ReactDebugCurrentFrame;
    function kv(r) {
      if (r) {
        var s = r._owner, p = cn(r.type, r._source, s ? s.type : null);
        TR.setExtraStackFrame(p);
      } else
        TR.setExtraStackFrame(null);
    }
    function bI(r, s, p, y, Z) {
      {
        var X = Function.call.bind(tn);
        for (var K in r)
          if (X(r, K)) {
            var j = void 0;
            try {
              if (typeof r[K] != "function") {
                var ne = Error((y || "React class") + ": " + p + " type `" + K + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof r[K] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ne.name = "Invariant Violation", ne;
              }
              j = r[K](s, K, y, p, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              j = de;
            }
            j && !(j instanceof Error) && (kv(Z), u("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", y || "React class", p, K, typeof j), kv(null)), j instanceof Error && !(j.message in ER) && (ER[j.message] = !0, kv(Z), u("Failed %s type: %s", p, j.message), kv(null));
          }
      }
    }
    var I0 = [], Dv;
    Dv = [];
    var fh = -1;
    function ph(r) {
      return {
        current: r
      };
    }
    function Mu(r, s) {
      if (fh < 0) {
        u("Unexpected pop.");
        return;
      }
      s !== Dv[fh] && u("Unexpected Fiber popped."), r.current = I0[fh], I0[fh] = null, Dv[fh] = null, fh--;
    }
    function Hu(r, s, p) {
      fh++, I0[fh] = r.current, Dv[fh] = p, r.current = s;
    }
    var QB;
    QB = {};
    var kc = {};
    Object.freeze(kc);
    var SC = ph(kc), GI = ph(!1), Uv = kc;
    function Zf(r, s, p) {
      return p && BI(s) ? Uv : SC.current;
    }
    function jB(r, s, p) {
      {
        var y = r.stateNode;
        y.__reactInternalMemoizedUnmaskedChildContext = s, y.__reactInternalMemoizedMaskedChildContext = p;
      }
    }
    function IA(r, s) {
      {
        var p = r.type, y = p.contextTypes;
        if (!y)
          return kc;
        var Z = r.stateNode;
        if (Z && Z.__reactInternalMemoizedUnmaskedChildContext === s)
          return Z.__reactInternalMemoizedMaskedChildContext;
        var X = {};
        for (var K in y)
          X[K] = s[K];
        {
          var j = gi(r) || "Unknown";
          bI(y, X, "context", j);
        }
        return Z && jB(r, s, X), X;
      }
    }
    function CA() {
      return GI.current;
    }
    function BI(r) {
      {
        var s = r.childContextTypes;
        return s != null;
      }
    }
    function C0(r) {
      Mu(GI, r), Mu(SC, r);
    }
    function hA(r) {
      Mu(GI, r), Mu(SC, r);
    }
    function _R(r, s, p) {
      {
        if (SC.current !== kc)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Hu(SC, s, r), Hu(GI, p, r);
      }
    }
    function zR(r, s, p) {
      {
        var y = r.stateNode, Z = s.childContextTypes;
        if (typeof y.getChildContext != "function") {
          {
            var X = gi(r) || "Unknown";
            QB[X] || (QB[X] = !0, u("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", X, X));
          }
          return p;
        }
        var K = y.getChildContext();
        for (var j in K)
          if (!(j in Z))
            throw new Error((gi(r) || "Unknown") + '.getChildContext(): key "' + j + '" is not defined in childContextTypes.');
        {
          var ne = gi(r) || "Unknown";
          bI(Z, K, "child context", ne);
        }
        return Xn({}, p, K);
      }
    }
    function h0(r) {
      {
        var s = r.stateNode, p = s && s.__reactInternalMemoizedMergedChildContext || kc;
        return Uv = SC.current, Hu(SC, p, r), Hu(GI, GI.current, r), !0;
      }
    }
    function KR(r, s, p) {
      {
        var y = r.stateNode;
        if (!y)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (p) {
          var Z = zR(r, s, Uv);
          y.__reactInternalMemoizedMergedChildContext = Z, Mu(GI, r), Mu(SC, r), Hu(SC, Z, r), Hu(GI, p, r);
        } else
          Mu(GI, r), Hu(GI, p, r);
      }
    }
    function SV(r) {
      {
        if (!vs(r) || r.tag !== h)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var s = r;
        do {
          switch (s.tag) {
            case b:
              return s.stateNode.context;
            case h: {
              var p = s.type;
              if (BI(p))
                return s.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          s = s.return;
        } while (s !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var wf = 0, Ov = 1, SI = null, qB = !1, f0 = !1;
    function LR(r) {
      SI === null ? SI = [r] : SI.push(r);
    }
    function kR(r) {
      qB = !0, LR(r);
    }
    function DR() {
      qB && Rf();
    }
    function Rf() {
      if (!f0 && SI !== null) {
        f0 = !0;
        var r = 0, s = Nl();
        try {
          var p = !0, y = SI;
          for (Lr(ql); r < y.length; r++) {
            var Z = y[r];
            do
              Z = Z(p);
            while (Z !== null);
          }
          SI = null, qB = !1;
        } catch (X) {
          throw SI !== null && (SI = SI.slice(r + 1)), nI(ud, Rf), X;
        } finally {
          Lr(s), f0 = !1;
        }
      }
      return null;
    }
    var fA = [], pA = 0, p0 = null, m0 = 0, bd = [], Gd = 0, Op = null, mh = 1, Ah = "";
    function UR(r) {
      return ZI(), (r.flags & mg) !== Hi;
    }
    function Bd(r) {
      return ZI(), m0;
    }
    function ZV() {
      var r = Ah, s = mh, p = s & ~A0(s);
      return p.toString(32) + r;
    }
    function Pp(r, s) {
      ZI(), fA[pA++] = m0, fA[pA++] = p0, p0 = r, m0 = s;
    }
    function OR(r, s, p) {
      ZI(), bd[Gd++] = mh, bd[Gd++] = Ah, bd[Gd++] = Op, Op = r;
      var y = mh, Z = Ah, X = Jp(y) - 1, K = y & ~(1 << X), j = p + 1, ne = Jp(s) + X;
      if (ne > 30) {
        var de = X - X % 5, Ge = (1 << de) - 1, rt = (K & Ge).toString(32), it = K >> de, Vt = X - de, Xt = Jp(s) + Vt, Jt = j << Vt, ri = Jt | it, Li = rt + Z;
        mh = 1 << Xt | ri, Ah = Li;
      } else {
        var Ni = j << X, sa = Ni | K, Jr = Z;
        mh = 1 << ne | sa, Ah = Jr;
      }
    }
    function $B(r) {
      ZI();
      var s = r.return;
      if (s !== null) {
        var p = 1, y = 0;
        Pp(r, p), OR(r, p, y);
      }
    }
    function Jp(r) {
      return 32 - yg(r);
    }
    function A0(r) {
      return 1 << Jp(r) - 1;
    }
    function mA(r) {
      for (; r === p0; )
        p0 = fA[--pA], fA[pA] = null, m0 = fA[--pA], fA[pA] = null;
      for (; r === Op; )
        Op = bd[--Gd], bd[Gd] = null, Ah = bd[--Gd], bd[Gd] = null, mh = bd[--Gd], bd[Gd] = null;
    }
    function v0() {
      return ZI(), Op !== null ? {
        id: mh,
        overflow: Ah
      } : null;
    }
    function y0(r, s) {
      ZI(), bd[Gd++] = mh, bd[Gd++] = Ah, bd[Gd++] = Op, mh = s.id, Ah = s.overflow, Op = r;
    }
    function ZI() {
      go() || u("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var eu = null, Sd = null, wI = !1, Qp = !1, xf = null;
    function eS() {
      wI && u("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function b0() {
      Qp = !0;
    }
    function tS() {
      return Qp;
    }
    function PR(r) {
      var s = r.stateNode.containerInfo;
      return Sd = hh(s), eu = r, wI = !0, xf = null, Qp = !1, !0;
    }
    function wV(r, s, p) {
      return Sd = fV(s), eu = r, wI = !0, xf = null, Qp = !1, p !== null && y0(r, p), !0;
    }
    function Pv(r, s) {
      switch (r.tag) {
        case b: {
          c0(r.stateNode.containerInfo, s);
          break;
        }
        case R: {
          var p = (r.mode & Zi) !== Kn;
          MR(
            r.type,
            r.memoizedProps,
            r.stateNode,
            s,
            // TODO: Delete this argument when we remove the legacy root API.
            p
          );
          break;
        }
        case U: {
          var y = r.memoizedState;
          y.dehydrated !== null && vV(y.dehydrated, s);
          break;
        }
      }
    }
    function JR(r, s) {
      Pv(r, s);
      var p = hU();
      p.stateNode = s, p.return = r;
      var y = r.deletions;
      y === null ? (r.deletions = [p], r.flags |= Gr) : y.push(p);
    }
    function nS(r, s) {
      {
        if (Qp)
          return;
        switch (r.tag) {
          case b: {
            var p = r.stateNode.containerInfo;
            switch (s.tag) {
              case R:
                var y = s.type;
                s.pendingProps, yV(p, y);
                break;
              case W:
                var Z = s.pendingProps;
                HR(p, Z);
                break;
            }
            break;
          }
          case R: {
            var X = r.type, K = r.memoizedProps, j = r.stateNode;
            switch (s.tag) {
              case R: {
                var ne = s.type, de = s.pendingProps, Ge = (r.mode & Zi) !== Kn;
                Gf(
                  X,
                  K,
                  j,
                  ne,
                  de,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Ge
                );
                break;
              }
              case W: {
                var rt = s.pendingProps, it = (r.mode & Zi) !== Kn;
                bV(
                  X,
                  K,
                  j,
                  rt,
                  // TODO: Delete this argument when we remove the legacy root API.
                  it
                );
                break;
              }
            }
            break;
          }
          case U: {
            var Vt = r.memoizedState, Xt = Vt.dehydrated;
            if (Xt !== null) switch (s.tag) {
              case R:
                var Jt = s.type;
                s.pendingProps, XR(Xt, Jt);
                break;
              case W:
                var ri = s.pendingProps;
                g0(Xt, ri);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function QR(r, s) {
      s.flags = s.flags & ~Dl | ar, nS(r, s);
    }
    function Jv(r, s) {
      switch (r.tag) {
        case R: {
          var p = r.type;
          r.pendingProps;
          var y = RR(s, p);
          return y !== null ? (r.stateNode = y, eu = r, Sd = u0(y), !0) : !1;
        }
        case W: {
          var Z = r.pendingProps, X = CV(s, Z);
          return X !== null ? (r.stateNode = X, eu = r, Sd = null, !0) : !1;
        }
        case U: {
          var K = KB(s);
          if (K !== null) {
            var j = {
              dehydrated: K,
              treeContext: v0(),
              retryLane: Vl
            };
            r.memoizedState = j;
            var ne = fU(K);
            return ne.return = r, r.child = ne, eu = r, Sd = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function iS(r) {
      return (r.mode & Zi) !== Kn && (r.flags & Qi) === Hi;
    }
    function rS(r) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function aS(r) {
      if (wI) {
        var s = Sd;
        if (!s) {
          iS(r) && (nS(eu, r), rS()), QR(eu, r), wI = !1, eu = r;
          return;
        }
        var p = s;
        if (!Jv(r, s)) {
          iS(r) && (nS(eu, r), rS()), s = Tv(p);
          var y = eu;
          if (!s || !Jv(r, s)) {
            QR(eu, r), wI = !1, eu = r;
            return;
          }
          JR(y, p);
        }
      }
    }
    function RV(r, s, p) {
      var y = r.stateNode, Z = !Qp, X = DB(y, r.type, r.memoizedProps, s, p, r, Z);
      return r.updateQueue = X, X !== null;
    }
    function jR(r) {
      var s = r.stateNode, p = r.memoizedProps, y = pV(s, p, r);
      if (y) {
        var Z = eu;
        if (Z !== null)
          switch (Z.tag) {
            case b: {
              var X = Z.stateNode.containerInfo, K = (Z.mode & Zi) !== Kn;
              AV(
                X,
                s,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                K
              );
              break;
            }
            case R: {
              var j = Z.type, ne = Z.memoizedProps, de = Z.stateNode, Ge = (Z.mode & Zi) !== Kn;
              _v(
                j,
                ne,
                de,
                s,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                Ge
              );
              break;
            }
          }
      }
      return y;
    }
    function xV(r) {
      var s = r.memoizedState, p = s !== null ? s.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      WR(p, r);
    }
    function oS(r) {
      var s = r.memoizedState, p = s !== null ? s.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return mV(p);
    }
    function G0(r) {
      for (var s = r.return; s !== null && s.tag !== R && s.tag !== b && s.tag !== U; )
        s = s.return;
      eu = s;
    }
    function Go(r) {
      if (r !== eu)
        return !1;
      if (!wI)
        return G0(r), wI = !0, !1;
      if (r.tag !== b && (r.tag !== R || OB(r.type) && !FB(r.type, r.memoizedProps))) {
        var s = Sd;
        if (s)
          if (iS(r))
            Rs(r), rS();
          else
            for (; s; )
              JR(r, s), s = Tv(s);
      }
      return G0(r), r.tag === U ? Sd = oS(r) : Sd = eu ? Tv(r.stateNode) : null, !0;
    }
    function RI() {
      return wI && Sd !== null;
    }
    function Rs(r) {
      for (var s = Sd; s; )
        Pv(r, s), s = Tv(s);
    }
    function Wf() {
      eu = null, Sd = null, wI = !1, Qp = !1;
    }
    function tu() {
      xf !== null && (RF(xf), xf = null);
    }
    function go() {
      return wI;
    }
    function xI(r) {
      xf === null ? xf = [r] : xf.push(r);
    }
    var Qv = n.ReactCurrentBatchConfig, jp = null;
    function B0() {
      return Qv.transition;
    }
    var cc = {
      recordUnsafeLifecycleWarnings: function(r, s) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(r, s) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var qR = function(r) {
        for (var s = null, p = r; p !== null; )
          p.mode & Or && (s = p), p = p.return;
        return s;
      }, vh = function(r) {
        var s = [];
        return r.forEach(function(p) {
          s.push(p);
        }), s.sort().join(", ");
      }, cr = [], Qs = [], Io = [], es = [], Dc = [], qp = [], Fo = /* @__PURE__ */ new Set();
      cc.recordUnsafeLifecycleWarnings = function(r, s) {
        Fo.has(r.type) || (typeof s.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        s.componentWillMount.__suppressDeprecationWarning !== !0 && cr.push(r), r.mode & Or && typeof s.UNSAFE_componentWillMount == "function" && Qs.push(r), typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Io.push(r), r.mode & Or && typeof s.UNSAFE_componentWillReceiveProps == "function" && es.push(r), typeof s.componentWillUpdate == "function" && s.componentWillUpdate.__suppressDeprecationWarning !== !0 && Dc.push(r), r.mode & Or && typeof s.UNSAFE_componentWillUpdate == "function" && qp.push(r));
      }, cc.flushPendingUnsafeLifecycleWarnings = function() {
        var r = /* @__PURE__ */ new Set();
        cr.length > 0 && (cr.forEach(function(it) {
          r.add(gi(it) || "Component"), Fo.add(it.type);
        }), cr = []);
        var s = /* @__PURE__ */ new Set();
        Qs.length > 0 && (Qs.forEach(function(it) {
          s.add(gi(it) || "Component"), Fo.add(it.type);
        }), Qs = []);
        var p = /* @__PURE__ */ new Set();
        Io.length > 0 && (Io.forEach(function(it) {
          p.add(gi(it) || "Component"), Fo.add(it.type);
        }), Io = []);
        var y = /* @__PURE__ */ new Set();
        es.length > 0 && (es.forEach(function(it) {
          y.add(gi(it) || "Component"), Fo.add(it.type);
        }), es = []);
        var Z = /* @__PURE__ */ new Set();
        Dc.length > 0 && (Dc.forEach(function(it) {
          Z.add(gi(it) || "Component"), Fo.add(it.type);
        }), Dc = []);
        var X = /* @__PURE__ */ new Set();
        if (qp.length > 0 && (qp.forEach(function(it) {
          X.add(gi(it) || "Component"), Fo.add(it.type);
        }), qp = []), s.size > 0) {
          var K = vh(s);
          u(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, K);
        }
        if (y.size > 0) {
          var j = vh(y);
          u(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, j);
        }
        if (X.size > 0) {
          var ne = vh(X);
          u(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, ne);
        }
        if (r.size > 0) {
          var de = vh(r);
          l(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, de);
        }
        if (p.size > 0) {
          var Ge = vh(p);
          l(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ge);
        }
        if (Z.size > 0) {
          var rt = vh(Z);
          l(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, rt);
        }
      };
      var Vf = /* @__PURE__ */ new Map(), jv = /* @__PURE__ */ new Set();
      cc.recordLegacyContextWarning = function(r, s) {
        var p = qR(r);
        if (p === null) {
          u("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!jv.has(r.type)) {
          var y = Vf.get(p);
          (r.type.contextTypes != null || r.type.childContextTypes != null || s !== null && typeof s.getChildContext == "function") && (y === void 0 && (y = [], Vf.set(p, y)), y.push(r));
        }
      }, cc.flushLegacyContextWarning = function() {
        Vf.forEach(function(r, s) {
          if (r.length !== 0) {
            var p = r[0], y = /* @__PURE__ */ new Set();
            r.forEach(function(X) {
              y.add(gi(X) || "Component"), jv.add(X.type);
            });
            var Z = vh(y);
            try {
              ia(p), u(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, Z);
            } finally {
              Xr();
            }
          }
        });
      }, cc.discardPendingWarnings = function() {
        cr = [], Qs = [], Io = [], es = [], Dc = [], qp = [], Vf = /* @__PURE__ */ new Map();
      };
    }
    var $p, AA, em, Xu, qv, sS = function(r, s) {
    };
    $p = !1, AA = !1, em = {}, Xu = {}, qv = {}, sS = function(r, s) {
      if (!(r === null || typeof r != "object") && !(!r._store || r._store.validated || r.key != null)) {
        if (typeof r._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        r._store.validated = !0;
        var p = gi(s) || "Component";
        Xu[p] || (Xu[p] = !0, u('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function $R(r) {
      return r.prototype && r.prototype.isReactComponent;
    }
    function $v(r, s, p) {
      var y = p.ref;
      if (y !== null && typeof y != "function" && typeof y != "object") {
        if ((r.mode & Or || ot) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(p._owner && p._self && p._owner.stateNode !== p._self) && // Will already throw with "Function components cannot have string refs"
        !(p._owner && p._owner.tag !== h) && // Will already warn with "Function components cannot be given refs"
        !(typeof p.type == "function" && !$R(p.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        p._owner) {
          var Z = gi(r) || "Component";
          em[Z] || (u('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Z, y), em[Z] = !0);
        }
        if (p._owner) {
          var X = p._owner, K;
          if (X) {
            var j = X;
            if (j.tag !== h)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            K = j.stateNode;
          }
          if (!K)
            throw new Error("Missing owner for string ref " + y + ". This error is likely caused by a bug in React. Please file an issue.");
          var ne = K;
          oe(y, "ref");
          var de = "" + y;
          if (s !== null && s.ref !== null && typeof s.ref == "function" && s.ref._stringRef === de)
            return s.ref;
          var Ge = function(rt) {
            var it = ne.refs;
            rt === null ? delete it[de] : it[de] = rt;
          };
          return Ge._stringRef = de, Ge;
        } else {
          if (typeof y != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!p._owner)
            throw new Error("Element ref was specified as a string (" + y + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return y;
    }
    function yh(r, s) {
      var p = Object.prototype.toString.call(s);
      throw new Error("Objects are not valid as a React child (found: " + (p === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : p) + "). If you meant to render a collection of children, use an array instead.");
    }
    function ey(r) {
      {
        var s = gi(r) || "Component";
        if (qv[s])
          return;
        qv[s] = !0, u("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function ty(r) {
      var s = r._payload, p = r._init;
      return p(s);
    }
    function S0(r) {
      function s(At, Qt) {
        if (r) {
          var vt = At.deletions;
          vt === null ? (At.deletions = [Qt], At.flags |= Gr) : vt.push(Qt);
        }
      }
      function p(At, Qt) {
        if (!r)
          return null;
        for (var vt = Qt; vt !== null; )
          s(At, vt), vt = vt.sibling;
        return null;
      }
      function y(At, Qt) {
        for (var vt = /* @__PURE__ */ new Map(), Zn = Qt; Zn !== null; )
          Zn.key !== null ? vt.set(Zn.key, Zn) : vt.set(Zn.index, Zn), Zn = Zn.sibling;
        return vt;
      }
      function Z(At, Qt) {
        var vt = Ny(At, Qt);
        return vt.index = 0, vt.sibling = null, vt;
      }
      function X(At, Qt, vt) {
        if (At.index = vt, !r)
          return At.flags |= mg, Qt;
        var Zn = At.alternate;
        if (Zn !== null) {
          var Ii = Zn.index;
          return Ii < Qt ? (At.flags |= ar, Qt) : Ii;
        } else
          return At.flags |= ar, Qt;
      }
      function K(At) {
        return r && At.alternate === null && (At.flags |= ar), At;
      }
      function j(At, Qt, vt, Zn) {
        if (Qt === null || Qt.tag !== W) {
          var Ii = XN(vt, At.mode, Zn);
          return Ii.return = At, Ii;
        } else {
          var li = Z(Qt, vt);
          return li.return = At, li;
        }
      }
      function ne(At, Qt, vt, Zn) {
        var Ii = vt.type;
        if (Ii === qe)
          return Ge(At, Qt, vt.props.children, Zn, vt.key);
        if (Qt !== null && (Qt.elementType === Ii || // Keep this check inline so it only runs on the false path:
        kF(Qt, vt) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Ii == "object" && Ii !== null && Ii.$$typeof === Ee && ty(Ii) === Qt.type)) {
          var li = Z(Qt, vt.props);
          return li.ref = $v(At, Qt, vt), li.return = At, li._debugSource = vt._source, li._debugOwner = vt._owner, li;
        }
        var ir = HN(vt, At.mode, Zn);
        return ir.ref = $v(At, Qt, vt), ir.return = At, ir;
      }
      function de(At, Qt, vt, Zn) {
        if (Qt === null || Qt.tag !== S || Qt.stateNode.containerInfo !== vt.containerInfo || Qt.stateNode.implementation !== vt.implementation) {
          var Ii = YN(vt, At.mode, Zn);
          return Ii.return = At, Ii;
        } else {
          var li = Z(Qt, vt.children || []);
          return li.return = At, li;
        }
      }
      function Ge(At, Qt, vt, Zn, Ii) {
        if (Qt === null || Qt.tag !== x) {
          var li = NA(vt, At.mode, Zn, Ii);
          return li.return = At, li;
        } else {
          var ir = Z(Qt, vt);
          return ir.return = At, ir;
        }
      }
      function rt(At, Qt, vt) {
        if (typeof Qt == "string" && Qt !== "" || typeof Qt == "number") {
          var Zn = XN("" + Qt, At.mode, vt);
          return Zn.return = At, Zn;
        }
        if (typeof Qt == "object" && Qt !== null) {
          switch (Qt.$$typeof) {
            case Oa: {
              var Ii = HN(Qt, At.mode, vt);
              return Ii.ref = $v(At, null, Qt), Ii.return = At, Ii;
            }
            case Le: {
              var li = YN(Qt, At.mode, vt);
              return li.return = At, li;
            }
            case Ee: {
              var ir = Qt._payload, gr = Qt._init;
              return rt(At, gr(ir), vt);
            }
          }
          if (Fr(Qt) || _n(Qt)) {
            var io = NA(Qt, At.mode, vt, null);
            return io.return = At, io;
          }
          yh(At, Qt);
        }
        return typeof Qt == "function" && ey(At), null;
      }
      function it(At, Qt, vt, Zn) {
        var Ii = Qt !== null ? Qt.key : null;
        if (typeof vt == "string" && vt !== "" || typeof vt == "number")
          return Ii !== null ? null : j(At, Qt, "" + vt, Zn);
        if (typeof vt == "object" && vt !== null) {
          switch (vt.$$typeof) {
            case Oa:
              return vt.key === Ii ? ne(At, Qt, vt, Zn) : null;
            case Le:
              return vt.key === Ii ? de(At, Qt, vt, Zn) : null;
            case Ee: {
              var li = vt._payload, ir = vt._init;
              return it(At, Qt, ir(li), Zn);
            }
          }
          if (Fr(vt) || _n(vt))
            return Ii !== null ? null : Ge(At, Qt, vt, Zn, null);
          yh(At, vt);
        }
        return typeof vt == "function" && ey(At), null;
      }
      function Vt(At, Qt, vt, Zn, Ii) {
        if (typeof Zn == "string" && Zn !== "" || typeof Zn == "number") {
          var li = At.get(vt) || null;
          return j(Qt, li, "" + Zn, Ii);
        }
        if (typeof Zn == "object" && Zn !== null) {
          switch (Zn.$$typeof) {
            case Oa: {
              var ir = At.get(Zn.key === null ? vt : Zn.key) || null;
              return ne(Qt, ir, Zn, Ii);
            }
            case Le: {
              var gr = At.get(Zn.key === null ? vt : Zn.key) || null;
              return de(Qt, gr, Zn, Ii);
            }
            case Ee:
              var io = Zn._payload, ba = Zn._init;
              return Vt(At, Qt, vt, ba(io), Ii);
          }
          if (Fr(Zn) || _n(Zn)) {
            var vl = At.get(vt) || null;
            return Ge(Qt, vl, Zn, Ii, null);
          }
          yh(Qt, Zn);
        }
        return typeof Zn == "function" && ey(Qt), null;
      }
      function Xt(At, Qt, vt) {
        {
          if (typeof At != "object" || At === null)
            return Qt;
          switch (At.$$typeof) {
            case Oa:
            case Le:
              sS(At, vt);
              var Zn = At.key;
              if (typeof Zn != "string")
                break;
              if (Qt === null) {
                Qt = /* @__PURE__ */ new Set(), Qt.add(Zn);
                break;
              }
              if (!Qt.has(Zn)) {
                Qt.add(Zn);
                break;
              }
              u("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Zn);
              break;
            case Ee:
              var Ii = At._payload, li = At._init;
              Xt(li(Ii), Qt, vt);
              break;
          }
        }
        return Qt;
      }
      function Jt(At, Qt, vt, Zn) {
        for (var Ii = null, li = 0; li < vt.length; li++) {
          var ir = vt[li];
          Ii = Xt(ir, Ii, At);
        }
        for (var gr = null, io = null, ba = Qt, vl = 0, Ga = 0, qs = null; ba !== null && Ga < vt.length; Ga++) {
          ba.index > Ga ? (qs = ba, ba = null) : qs = ba.sibling;
          var Pc = it(At, ba, vt[Ga], Zn);
          if (Pc === null) {
            ba === null && (ba = qs);
            break;
          }
          r && ba && Pc.alternate === null && s(At, ba), vl = X(Pc, vl, Ga), io === null ? gr = Pc : io.sibling = Pc, io = Pc, ba = qs;
        }
        if (Ga === vt.length) {
          if (p(At, ba), go()) {
            var yc = Ga;
            Pp(At, yc);
          }
          return gr;
        }
        if (ba === null) {
          for (; Ga < vt.length; Ga++) {
            var MI = rt(At, vt[Ga], Zn);
            MI !== null && (vl = X(MI, vl, Ga), io === null ? gr = MI : io.sibling = MI, io = MI);
          }
          if (go()) {
            var Hg = Ga;
            Pp(At, Hg);
          }
          return gr;
        }
        for (var Xg = y(At, ba); Ga < vt.length; Ga++) {
          var Jc = Vt(Xg, At, Ga, vt[Ga], Zn);
          Jc !== null && (r && Jc.alternate !== null && Xg.delete(Jc.key === null ? Ga : Jc.key), vl = X(Jc, vl, Ga), io === null ? gr = Jc : io.sibling = Jc, io = Jc);
        }
        if (r && Xg.forEach(function(oG) {
          return s(At, oG);
        }), go()) {
          var hm = Ga;
          Pp(At, hm);
        }
        return gr;
      }
      function ri(At, Qt, vt, Zn) {
        var Ii = _n(vt);
        if (typeof Ii != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          vt[Symbol.toStringTag] === "Generator" && (AA || u("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), AA = !0), vt.entries === Ii && ($p || u("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), $p = !0);
          var li = Ii.call(vt);
          if (li)
            for (var ir = null, gr = li.next(); !gr.done; gr = li.next()) {
              var io = gr.value;
              ir = Xt(io, ir, At);
            }
        }
        var ba = Ii.call(vt);
        if (ba == null)
          throw new Error("An iterable object provided no iterator.");
        for (var vl = null, Ga = null, qs = Qt, Pc = 0, yc = 0, MI = null, Hg = ba.next(); qs !== null && !Hg.done; yc++, Hg = ba.next()) {
          qs.index > yc ? (MI = qs, qs = null) : MI = qs.sibling;
          var Xg = it(At, qs, Hg.value, Zn);
          if (Xg === null) {
            qs === null && (qs = MI);
            break;
          }
          r && qs && Xg.alternate === null && s(At, qs), Pc = X(Xg, Pc, yc), Ga === null ? vl = Xg : Ga.sibling = Xg, Ga = Xg, qs = MI;
        }
        if (Hg.done) {
          if (p(At, qs), go()) {
            var Jc = yc;
            Pp(At, Jc);
          }
          return vl;
        }
        if (qs === null) {
          for (; !Hg.done; yc++, Hg = ba.next()) {
            var hm = rt(At, Hg.value, Zn);
            hm !== null && (Pc = X(hm, Pc, yc), Ga === null ? vl = hm : Ga.sibling = hm, Ga = hm);
          }
          if (go()) {
            var oG = yc;
            Pp(At, oG);
          }
          return vl;
        }
        for (var sZ = y(At, qs); !Hg.done; yc++, Hg = ba.next()) {
          var Pf = Vt(sZ, At, yc, Hg.value, Zn);
          Pf !== null && (r && Pf.alternate !== null && sZ.delete(Pf.key === null ? yc : Pf.key), Pc = X(Pf, Pc, yc), Ga === null ? vl = Pf : Ga.sibling = Pf, Ga = Pf);
        }
        if (r && sZ.forEach(function(OU) {
          return s(At, OU);
        }), go()) {
          var UU = yc;
          Pp(At, UU);
        }
        return vl;
      }
      function Li(At, Qt, vt, Zn) {
        if (Qt !== null && Qt.tag === W) {
          p(At, Qt.sibling);
          var Ii = Z(Qt, vt);
          return Ii.return = At, Ii;
        }
        p(At, Qt);
        var li = XN(vt, At.mode, Zn);
        return li.return = At, li;
      }
      function Ni(At, Qt, vt, Zn) {
        for (var Ii = vt.key, li = Qt; li !== null; ) {
          if (li.key === Ii) {
            var ir = vt.type;
            if (ir === qe) {
              if (li.tag === x) {
                p(At, li.sibling);
                var gr = Z(li, vt.props.children);
                return gr.return = At, gr._debugSource = vt._source, gr._debugOwner = vt._owner, gr;
              }
            } else if (li.elementType === ir || // Keep this check inline so it only runs on the false path:
            kF(li, vt) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof ir == "object" && ir !== null && ir.$$typeof === Ee && ty(ir) === li.type) {
              p(At, li.sibling);
              var io = Z(li, vt.props);
              return io.ref = $v(At, li, vt), io.return = At, io._debugSource = vt._source, io._debugOwner = vt._owner, io;
            }
            p(At, li);
            break;
          } else
            s(At, li);
          li = li.sibling;
        }
        if (vt.type === qe) {
          var ba = NA(vt.props.children, At.mode, Zn, vt.key);
          return ba.return = At, ba;
        } else {
          var vl = HN(vt, At.mode, Zn);
          return vl.ref = $v(At, Qt, vt), vl.return = At, vl;
        }
      }
      function sa(At, Qt, vt, Zn) {
        for (var Ii = vt.key, li = Qt; li !== null; ) {
          if (li.key === Ii)
            if (li.tag === S && li.stateNode.containerInfo === vt.containerInfo && li.stateNode.implementation === vt.implementation) {
              p(At, li.sibling);
              var ir = Z(li, vt.children || []);
              return ir.return = At, ir;
            } else {
              p(At, li);
              break;
            }
          else
            s(At, li);
          li = li.sibling;
        }
        var gr = YN(vt, At.mode, Zn);
        return gr.return = At, gr;
      }
      function Jr(At, Qt, vt, Zn) {
        var Ii = typeof vt == "object" && vt !== null && vt.type === qe && vt.key === null;
        if (Ii && (vt = vt.props.children), typeof vt == "object" && vt !== null) {
          switch (vt.$$typeof) {
            case Oa:
              return K(Ni(At, Qt, vt, Zn));
            case Le:
              return K(sa(At, Qt, vt, Zn));
            case Ee:
              var li = vt._payload, ir = vt._init;
              return Jr(At, Qt, ir(li), Zn);
          }
          if (Fr(vt))
            return Jt(At, Qt, vt, Zn);
          if (_n(vt))
            return ri(At, Qt, vt, Zn);
          yh(At, vt);
        }
        return typeof vt == "string" && vt !== "" || typeof vt == "number" ? K(Li(At, Qt, "" + vt, Zn)) : (typeof vt == "function" && ey(At), p(At, Qt));
      }
      return Jr;
    }
    var WI = S0(!0), Nf = S0(!1);
    function bh(r, s) {
      if (r !== null && s.child !== r.child)
        throw new Error("Resuming work not yet implemented.");
      if (s.child !== null) {
        var p = s.child, y = Ny(p, p.pendingProps);
        for (s.child = y, y.return = s; p.sibling !== null; )
          p = p.sibling, y = y.sibling = Ny(p, p.pendingProps), y.return = s;
        y.sibling = null;
      }
    }
    function ny(r, s) {
      for (var p = r.child; p !== null; )
        cU(p, s), p = p.sibling;
    }
    var iy = ph(null), lS;
    lS = {};
    var Mf = null, Hf = null, uS = null, tm = !1;
    function Xf() {
      Mf = null, Hf = null, uS = null, tm = !1;
    }
    function ry() {
      tm = !0;
    }
    function ay() {
      tm = !1;
    }
    function Yu(r, s, p) {
      Hu(iy, s._currentValue, r), s._currentValue = p, s._currentRenderer !== void 0 && s._currentRenderer !== null && s._currentRenderer !== lS && u("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer = lS;
    }
    function ZC(r, s) {
      var p = iy.current;
      Mu(iy, s), r._currentValue = p;
    }
    function cS(r, s, p) {
      for (var y = r; y !== null; ) {
        var Z = y.alternate;
        if (Tn(y.childLanes, s) ? Z !== null && !Tn(Z.childLanes, s) && (Z.childLanes = fn(Z.childLanes, s)) : (y.childLanes = fn(y.childLanes, s), Z !== null && (Z.childLanes = fn(Z.childLanes, s))), y === p)
          break;
        y = y.return;
      }
      y !== p && u("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function pl(r, s, p) {
      WV(r, s, p);
    }
    function WV(r, s, p) {
      var y = r.child;
      for (y !== null && (y.return = r); y !== null; ) {
        var Z = void 0, X = y.dependencies;
        if (X !== null) {
          Z = y.child;
          for (var K = X.firstContext; K !== null; ) {
            if (K.context === s) {
              if (y.tag === h) {
                var j = gs(p), ne = wC(Br, j);
                ne.tag = R0;
                var de = y.updateQueue;
                if (de !== null) {
                  var Ge = de.shared, rt = Ge.pending;
                  rt === null ? ne.next = ne : (ne.next = rt.next, rt.next = ne), Ge.pending = ne;
                }
              }
              y.lanes = fn(y.lanes, p);
              var it = y.alternate;
              it !== null && (it.lanes = fn(it.lanes, p)), cS(y.return, p, r), X.lanes = fn(X.lanes, p);
              break;
            }
            K = K.next;
          }
        } else if (y.tag === E)
          Z = y.type === r.type ? null : y.child;
        else if (y.tag === te) {
          var Vt = y.return;
          if (Vt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Vt.lanes = fn(Vt.lanes, p);
          var Xt = Vt.alternate;
          Xt !== null && (Xt.lanes = fn(Xt.lanes, p)), cS(Vt, p, r), Z = y.sibling;
        } else
          Z = y.child;
        if (Z !== null)
          Z.return = y;
        else
          for (Z = y; Z !== null; ) {
            if (Z === r) {
              Z = null;
              break;
            }
            var Jt = Z.sibling;
            if (Jt !== null) {
              Jt.return = Z.return, Z = Jt;
              break;
            }
            Z = Z.return;
          }
        y = Z;
      }
    }
    function Gh(r, s) {
      Mf = r, Hf = null, uS = null;
      var p = r.dependencies;
      if (p !== null) {
        var y = p.firstContext;
        y !== null && (Zt(p.lanes, s) && kS(), p.firstContext = null);
      }
    }
    function xs(r) {
      tm && u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var s = r._currentValue;
      if (uS !== r) {
        var p = {
          context: r,
          memoizedValue: s,
          next: null
        };
        if (Hf === null) {
          if (Mf === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Hf = p, Mf.dependencies = {
            lanes: dn,
            firstContext: p
          };
        } else
          Hf = Hf.next = p;
      }
      return s;
    }
    var js = null;
    function Z0(r) {
      js === null ? js = [r] : js.push(r);
    }
    function gS() {
      if (js !== null) {
        for (var r = 0; r < js.length; r++) {
          var s = js[r], p = s.interleaved;
          if (p !== null) {
            s.interleaved = null;
            var y = p.next, Z = s.pending;
            if (Z !== null) {
              var X = Z.next;
              Z.next = y, p.next = X;
            }
            s.pending = p;
          }
        }
        js = null;
      }
    }
    function dS(r, s, p, y) {
      var Z = s.interleaved;
      return Z === null ? (p.next = p, Z0(s)) : (p.next = Z.next, Z.next = p), s.interleaved = p, w0(r, y);
    }
    function VV(r, s, p, y) {
      var Z = s.interleaved;
      Z === null ? (p.next = p, Z0(s)) : (p.next = Z.next, Z.next = p), s.interleaved = p;
    }
    function NV(r, s, p, y) {
      var Z = s.interleaved;
      return Z === null ? (p.next = p, Z0(s)) : (p.next = Z.next, Z.next = p), s.interleaved = p, w0(r, y);
    }
    function Ws(r, s) {
      return w0(r, s);
    }
    var ex = w0;
    function w0(r, s) {
      r.lanes = fn(r.lanes, s);
      var p = r.alternate;
      p !== null && (p.lanes = fn(p.lanes, s)), p === null && (r.flags & (ar | Dl)) !== Hi && _F(r);
      for (var y = r, Z = r.return; Z !== null; )
        Z.childLanes = fn(Z.childLanes, s), p = Z.alternate, p !== null ? p.childLanes = fn(p.childLanes, s) : (Z.flags & (ar | Dl)) !== Hi && _F(r), y = Z, Z = Z.return;
      if (y.tag === b) {
        var X = y.stateNode;
        return X;
      } else
        return null;
    }
    var tx = 0, nx = 1, R0 = 2, vA = 3, x0 = !1, IS, nm;
    IS = !1, nm = null;
    function oy(r) {
      var s = {
        baseState: r.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: dn
        },
        effects: null
      };
      r.updateQueue = s;
    }
    function Yf(r, s) {
      var p = s.updateQueue, y = r.updateQueue;
      if (p === y) {
        var Z = {
          baseState: y.baseState,
          firstBaseUpdate: y.firstBaseUpdate,
          lastBaseUpdate: y.lastBaseUpdate,
          shared: y.shared,
          effects: y.effects
        };
        s.updateQueue = Z;
      }
    }
    function wC(r, s) {
      var p = {
        eventTime: r,
        lane: s,
        tag: tx,
        payload: null,
        callback: null,
        next: null
      };
      return p;
    }
    function Bh(r, s, p) {
      var y = r.updateQueue;
      if (y === null)
        return null;
      var Z = y.shared;
      if (nm === Z && !IS && (u("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), IS = !0), wD()) {
        var X = Z.pending;
        return X === null ? s.next = s : (s.next = X.next, X.next = s), Z.pending = s, ex(r, p);
      } else
        return NV(r, Z, s, p);
    }
    function sy(r, s, p) {
      var y = s.updateQueue;
      if (y !== null) {
        var Z = y.shared;
        if (wi(p)) {
          var X = Z.lanes;
          X = $i(X, r.pendingLanes);
          var K = fn(X, p);
          Z.lanes = K, Bp(r, K);
        }
      }
    }
    function CS(r, s) {
      var p = r.updateQueue, y = r.alternate;
      if (y !== null) {
        var Z = y.updateQueue;
        if (p === Z) {
          var X = null, K = null, j = p.firstBaseUpdate;
          if (j !== null) {
            var ne = j;
            do {
              var de = {
                eventTime: ne.eventTime,
                lane: ne.lane,
                tag: ne.tag,
                payload: ne.payload,
                callback: ne.callback,
                next: null
              };
              K === null ? X = K = de : (K.next = de, K = de), ne = ne.next;
            } while (ne !== null);
            K === null ? X = K = s : (K.next = s, K = s);
          } else
            X = K = s;
          p = {
            baseState: Z.baseState,
            firstBaseUpdate: X,
            lastBaseUpdate: K,
            shared: Z.shared,
            effects: Z.effects
          }, r.updateQueue = p;
          return;
        }
      }
      var Ge = p.lastBaseUpdate;
      Ge === null ? p.firstBaseUpdate = s : Ge.next = s, p.lastBaseUpdate = s;
    }
    function W0(r, s, p, y, Z, X) {
      switch (p.tag) {
        case nx: {
          var K = p.payload;
          if (typeof K == "function") {
            ry();
            var j = K.call(X, y, Z);
            {
              if (r.mode & Or) {
                ra(!0);
                try {
                  K.call(X, y, Z);
                } finally {
                  ra(!1);
                }
              }
              ay();
            }
            return j;
          }
          return K;
        }
        case vA:
          r.flags = r.flags & ~ss | Qi;
        case tx: {
          var ne = p.payload, de;
          if (typeof ne == "function") {
            ry(), de = ne.call(X, y, Z);
            {
              if (r.mode & Or) {
                ra(!0);
                try {
                  ne.call(X, y, Z);
                } finally {
                  ra(!1);
                }
              }
              ay();
            }
          } else
            de = ne;
          return de == null ? y : Xn({}, y, de);
        }
        case R0:
          return x0 = !0, y;
      }
      return y;
    }
    function V0(r, s, p, y) {
      var Z = r.updateQueue;
      x0 = !1, nm = Z.shared;
      var X = Z.firstBaseUpdate, K = Z.lastBaseUpdate, j = Z.shared.pending;
      if (j !== null) {
        Z.shared.pending = null;
        var ne = j, de = ne.next;
        ne.next = null, K === null ? X = de : K.next = de, K = ne;
        var Ge = r.alternate;
        if (Ge !== null) {
          var rt = Ge.updateQueue, it = rt.lastBaseUpdate;
          it !== K && (it === null ? rt.firstBaseUpdate = de : it.next = de, rt.lastBaseUpdate = ne);
        }
      }
      if (X !== null) {
        var Vt = Z.baseState, Xt = dn, Jt = null, ri = null, Li = null, Ni = X;
        do {
          var sa = Ni.lane, Jr = Ni.eventTime;
          if (Tn(y, sa)) {
            if (Li !== null) {
              var Qt = {
                eventTime: Jr,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Wr,
                tag: Ni.tag,
                payload: Ni.payload,
                callback: Ni.callback,
                next: null
              };
              Li = Li.next = Qt;
            }
            Vt = W0(r, Z, Ni, Vt, s, p);
            var vt = Ni.callback;
            if (vt !== null && // If the update was already committed, we should not queue its
            // callback again.
            Ni.lane !== Wr) {
              r.flags |= jo;
              var Zn = Z.effects;
              Zn === null ? Z.effects = [Ni] : Zn.push(Ni);
            }
          } else {
            var At = {
              eventTime: Jr,
              lane: sa,
              tag: Ni.tag,
              payload: Ni.payload,
              callback: Ni.callback,
              next: null
            };
            Li === null ? (ri = Li = At, Jt = Vt) : Li = Li.next = At, Xt = fn(Xt, sa);
          }
          if (Ni = Ni.next, Ni === null) {
            if (j = Z.shared.pending, j === null)
              break;
            var Ii = j, li = Ii.next;
            Ii.next = null, Ni = li, Z.lastBaseUpdate = Ii, Z.shared.pending = null;
          }
        } while (!0);
        Li === null && (Jt = Vt), Z.baseState = Jt, Z.firstBaseUpdate = ri, Z.lastBaseUpdate = Li;
        var ir = Z.shared.interleaved;
        if (ir !== null) {
          var gr = ir;
          do
            Xt = fn(Xt, gr.lane), gr = gr.next;
          while (gr !== ir);
        } else X === null && (Z.shared.lanes = dn);
        nZ(Xt), r.lanes = Xt, r.memoizedState = Vt;
      }
      nm = null;
    }
    function hS(r, s) {
      if (typeof r != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + r));
      r.call(s);
    }
    function ix() {
      x0 = !1;
    }
    function N0() {
      return x0;
    }
    function ly(r, s, p) {
      var y = s.effects;
      if (s.effects = null, y !== null)
        for (var Z = 0; Z < y.length; Z++) {
          var X = y[Z], K = X.callback;
          K !== null && (X.callback = null, hS(K, p));
        }
    }
    var uy = {}, Ff = ph(uy), cy = ph(uy), gy = ph(uy);
    function dy(r) {
      if (r === uy)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return r;
    }
    function Ef() {
      var r = dy(gy.current);
      return r;
    }
    function fS(r, s) {
      Hu(gy, s, r), Hu(cy, r, r), Hu(Ff, uy, r);
      var p = tV(s);
      Mu(Ff, r), Hu(Ff, p, r);
    }
    function gc(r) {
      Mu(Ff, r), Mu(cy, r), Mu(gy, r);
    }
    function pS() {
      var r = dy(Ff.current);
      return r;
    }
    function rx(r) {
      dy(gy.current);
      var s = dy(Ff.current), p = fR(s, r.type);
      s !== p && (Hu(cy, r, r), Hu(Ff, p, r));
    }
    function M0(r) {
      cy.current === r && (Mu(Ff, r), Mu(cy, r));
    }
    var MV = 0, ax = 1, ox = 1, yA = 2, Co = ph(MV);
    function mS(r, s) {
      return (r & s) !== 0;
    }
    function im(r) {
      return r & ax;
    }
    function AS(r, s) {
      return r & ax | s;
    }
    function HV(r, s) {
      return r | s;
    }
    function Tf(r, s) {
      Hu(Co, s, r);
    }
    function bA(r) {
      Mu(Co, r);
    }
    function XV(r, s) {
      var p = r.memoizedState;
      return p !== null ? p.dehydrated !== null : (r.memoizedProps, !0);
    }
    function Iy(r) {
      for (var s = r; s !== null; ) {
        if (s.tag === U) {
          var p = s.memoizedState;
          if (p !== null) {
            var y = p.dehydrated;
            if (y === null || LB(y) || kB(y))
              return s;
          }
        } else if (s.tag === fe && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        s.memoizedProps.revealOrder !== void 0) {
          var Z = (s.flags & Qi) !== Hi;
          if (Z)
            return s;
        } else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === r)
          return null;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === r)
            return null;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return null;
    }
    var nu = (
      /*   */
      0
    ), Cs = (
      /* */
      1
    ), VI = (
      /*  */
      2
    ), Vs = (
      /*    */
      4
    ), iu = (
      /*   */
      8
    ), H0 = [];
    function Cy() {
      for (var r = 0; r < H0.length; r++) {
        var s = H0[r];
        s._workInProgressVersionPrimary = null;
      }
      H0.length = 0;
    }
    function YV(r, s) {
      var p = s._getVersion, y = p(s._source);
      r.mutableSourceEagerHydrationData == null ? r.mutableSourceEagerHydrationData = [s, y] : r.mutableSourceEagerHydrationData.push(s, y);
    }
    var jn = n.ReactCurrentDispatcher, rm = n.ReactCurrentBatchConfig, GA, am;
    GA = /* @__PURE__ */ new Set();
    var _f = dn, Fa = null, ml = null, Ea = null, Sh = !1, hy = !1, RC = 0, vS = 0, yS = 25, on = null, Wg = null, zf = -1, bS = !1;
    function da() {
      {
        var r = on;
        Wg === null ? Wg = [r] : Wg.push(r);
      }
    }
    function Un() {
      {
        var r = on;
        Wg !== null && (zf++, Wg[zf] !== r && FV(r));
      }
    }
    function Kf(r) {
      r != null && !Fr(r) && u("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", on, typeof r);
    }
    function FV(r) {
      {
        var s = gi(Fa);
        if (!GA.has(s) && (GA.add(s), Wg !== null)) {
          for (var p = "", y = 30, Z = 0; Z <= zf; Z++) {
            for (var X = Wg[Z], K = Z === zf ? r : X, j = Z + 1 + ". " + X; j.length < y; )
              j += " ";
            j += K + `
`, p += j;
          }
          u(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, s, p);
        }
      }
    }
    function Fu() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function fy(r, s) {
      if (bS)
        return !1;
      if (s === null)
        return u("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", on), !1;
      r.length !== s.length && u(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, on, "[" + s.join(", ") + "]", "[" + r.join(", ") + "]");
      for (var p = 0; p < s.length && p < r.length; p++)
        if (!Ri(r[p], s[p]))
          return !1;
      return !0;
    }
    function om(r, s, p, y, Z, X) {
      _f = X, Fa = s, Wg = r !== null ? r._debugHookTypes : null, zf = -1, bS = r !== null && r.type !== s.type, s.memoizedState = null, s.updateQueue = null, s.lanes = dn, r !== null && r.memoizedState !== null ? jn.current = c : Wg !== null ? jn.current = fx : jn.current = hx;
      var K = p(y, Z);
      if (hy) {
        var j = 0;
        do {
          if (hy = !1, RC = 0, j >= yS)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          j += 1, bS = !1, ml = null, Ea = null, s.updateQueue = null, zf = -1, jn.current = d, K = p(y, Z);
        } while (hy);
      }
      jn.current = j0, s._debugHookTypes = Wg;
      var ne = ml !== null && ml.next !== null;
      if (_f = dn, Fa = null, ml = null, Ea = null, on = null, Wg = null, zf = -1, r !== null && (r.flags & Do) !== (s.flags & Do) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (r.mode & Zi) !== Kn && u("Internal React error: Expected static flag was missing. Please notify the React team."), Sh = !1, ne)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return K;
    }
    function BA() {
      var r = RC !== 0;
      return RC = 0, r;
    }
    function Uc(r, s, p) {
      s.updateQueue = r.updateQueue, (s.mode & La) !== Kn ? s.flags &= ~(bu | ja | gl | Ci) : s.flags &= ~(gl | Ci), r.lanes = ji(r.lanes, p);
    }
    function X0() {
      if (jn.current = j0, Sh) {
        for (var r = Fa.memoizedState; r !== null; ) {
          var s = r.queue;
          s !== null && (s.pending = null), r = r.next;
        }
        Sh = !1;
      }
      _f = dn, Fa = null, ml = null, Ea = null, Wg = null, zf = -1, on = null, YS = !1, hy = !1, RC = 0;
    }
    function xC() {
      var r = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ea === null ? Fa.memoizedState = Ea = r : Ea = Ea.next = r, Ea;
    }
    function Zd() {
      var r;
      if (ml === null) {
        var s = Fa.alternate;
        s !== null ? r = s.memoizedState : r = null;
      } else
        r = ml.next;
      var p;
      if (Ea === null ? p = Fa.memoizedState : p = Ea.next, p !== null)
        Ea = p, p = Ea.next, ml = r;
      else {
        if (r === null)
          throw new Error("Rendered more hooks than during the previous render.");
        ml = r;
        var y = {
          memoizedState: ml.memoizedState,
          baseState: ml.baseState,
          baseQueue: ml.baseQueue,
          queue: ml.queue,
          next: null
        };
        Ea === null ? Fa.memoizedState = Ea = y : Ea = Ea.next = y;
      }
      return Ea;
    }
    function Lf() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function GS(r, s) {
      return typeof s == "function" ? s(r) : s;
    }
    function BS(r, s, p) {
      var y = xC(), Z;
      p !== void 0 ? Z = p(s) : Z = s, y.memoizedState = y.baseState = Z;
      var X = {
        pending: null,
        interleaved: null,
        lanes: dn,
        dispatch: null,
        lastRenderedReducer: r,
        lastRenderedState: Z
      };
      y.queue = X;
      var K = X.dispatch = dx.bind(null, Fa, X);
      return [y.memoizedState, K];
    }
    function py(r, s, p) {
      var y = Zd(), Z = y.queue;
      if (Z === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Z.lastRenderedReducer = r;
      var X = ml, K = X.baseQueue, j = Z.pending;
      if (j !== null) {
        if (K !== null) {
          var ne = K.next, de = j.next;
          K.next = de, j.next = ne;
        }
        X.baseQueue !== K && u("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), X.baseQueue = K = j, Z.pending = null;
      }
      if (K !== null) {
        var Ge = K.next, rt = X.baseState, it = null, Vt = null, Xt = null, Jt = Ge;
        do {
          var ri = Jt.lane;
          if (Tn(_f, ri)) {
            if (Xt !== null) {
              var Ni = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Wr,
                action: Jt.action,
                hasEagerState: Jt.hasEagerState,
                eagerState: Jt.eagerState,
                next: null
              };
              Xt = Xt.next = Ni;
            }
            if (Jt.hasEagerState)
              rt = Jt.eagerState;
            else {
              var sa = Jt.action;
              rt = r(rt, sa);
            }
          } else {
            var Li = {
              lane: ri,
              action: Jt.action,
              hasEagerState: Jt.hasEagerState,
              eagerState: Jt.eagerState,
              next: null
            };
            Xt === null ? (Vt = Xt = Li, it = rt) : Xt = Xt.next = Li, Fa.lanes = fn(Fa.lanes, ri), nZ(ri);
          }
          Jt = Jt.next;
        } while (Jt !== null && Jt !== Ge);
        Xt === null ? it = rt : Xt.next = Vt, Ri(rt, y.memoizedState) || kS(), y.memoizedState = rt, y.baseState = it, y.baseQueue = Xt, Z.lastRenderedState = rt;
      }
      var Jr = Z.interleaved;
      if (Jr !== null) {
        var At = Jr;
        do {
          var Qt = At.lane;
          Fa.lanes = fn(Fa.lanes, Qt), nZ(Qt), At = At.next;
        } while (At !== Jr);
      } else K === null && (Z.lanes = dn);
      var vt = Z.dispatch;
      return [y.memoizedState, vt];
    }
    function my(r, s, p) {
      var y = Zd(), Z = y.queue;
      if (Z === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Z.lastRenderedReducer = r;
      var X = Z.dispatch, K = Z.pending, j = y.memoizedState;
      if (K !== null) {
        Z.pending = null;
        var ne = K.next, de = ne;
        do {
          var Ge = de.action;
          j = r(j, Ge), de = de.next;
        } while (de !== ne);
        Ri(j, y.memoizedState) || kS(), y.memoizedState = j, y.baseQueue === null && (y.baseState = j), Z.lastRenderedState = j;
      }
      return [j, X];
    }
    function sm(r, s, p) {
    }
    function NY(r, s, p) {
    }
    function SS(r, s, p) {
      var y = Fa, Z = xC(), X, K = go();
      if (K) {
        if (p === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        X = p(), am || X !== p() && (u("The result of getServerSnapshot should be cached to avoid an infinite loop"), am = !0);
      } else {
        if (X = s(), !am) {
          var j = s();
          Ri(X, j) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), am = !0);
        }
        var ne = Wx();
        if (ne === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Jn(ne, _f) || ZS(y, s, X);
      }
      Z.memoizedState = X;
      var de = {
        value: X,
        getSnapshot: s
      };
      return Z.queue = de, _0(sx.bind(null, y, de, r), [r]), y.flags |= gl, vy(Cs | iu, F0.bind(null, y, de, X, s), void 0, null), X;
    }
    function Y0(r, s, p) {
      var y = Fa, Z = Zd(), X = s();
      if (!am) {
        var K = s();
        Ri(X, K) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), am = !0);
      }
      var j = Z.memoizedState, ne = !Ri(j, X);
      ne && (Z.memoizedState = X, kS());
      var de = Z.queue;
      if (by(sx.bind(null, y, de, r), [r]), de.getSnapshot !== s || ne || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Ea !== null && Ea.memoizedState.tag & Cs) {
        y.flags |= gl, vy(Cs | iu, F0.bind(null, y, de, X, s), void 0, null);
        var Ge = Wx();
        if (Ge === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Jn(Ge, _f) || ZS(y, s, X);
      }
      return X;
    }
    function ZS(r, s, p) {
      r.flags |= xc;
      var y = {
        getSnapshot: s,
        value: p
      }, Z = Fa.updateQueue;
      if (Z === null)
        Z = Lf(), Fa.updateQueue = Z, Z.stores = [y];
      else {
        var X = Z.stores;
        X === null ? Z.stores = [y] : X.push(y);
      }
    }
    function F0(r, s, p, y) {
      s.value = p, s.getSnapshot = y, lx(s) && E0(r);
    }
    function sx(r, s, p) {
      var y = function() {
        lx(s) && E0(r);
      };
      return p(y);
    }
    function lx(r) {
      var s = r.getSnapshot, p = r.value;
      try {
        var y = s();
        return !Ri(p, y);
      } catch {
        return !0;
      }
    }
    function E0(r) {
      var s = Ws(r, yi);
      s !== null && su(s, r, yi, Br);
    }
    function Ay(r) {
      var s = xC();
      typeof r == "function" && (r = r()), s.memoizedState = s.baseState = r;
      var p = {
        pending: null,
        interleaved: null,
        lanes: dn,
        dispatch: null,
        lastRenderedReducer: GS,
        lastRenderedState: r
      };
      s.queue = p;
      var y = p.dispatch = Ix.bind(null, Fa, p);
      return [s.memoizedState, y];
    }
    function wS(r) {
      return py(GS);
    }
    function T0(r) {
      return my(GS);
    }
    function vy(r, s, p, y) {
      var Z = {
        tag: r,
        create: s,
        destroy: p,
        deps: y,
        // Circular
        next: null
      }, X = Fa.updateQueue;
      if (X === null)
        X = Lf(), Fa.updateQueue = X, X.lastEffect = Z.next = Z;
      else {
        var K = X.lastEffect;
        if (K === null)
          X.lastEffect = Z.next = Z;
        else {
          var j = K.next;
          K.next = Z, Z.next = j, X.lastEffect = Z;
        }
      }
      return Z;
    }
    function RS(r) {
      var s = xC();
      {
        var p = {
          current: r
        };
        return s.memoizedState = p, p;
      }
    }
    function SA(r) {
      var s = Zd();
      return s.memoizedState;
    }
    function lm(r, s, p, y) {
      var Z = xC(), X = y === void 0 ? null : y;
      Fa.flags |= r, Z.memoizedState = vy(Cs | s, p, void 0, X);
    }
    function yy(r, s, p, y) {
      var Z = Zd(), X = y === void 0 ? null : y, K = void 0;
      if (ml !== null) {
        var j = ml.memoizedState;
        if (K = j.destroy, X !== null) {
          var ne = j.deps;
          if (fy(X, ne)) {
            Z.memoizedState = vy(s, p, K, X);
            return;
          }
        }
      }
      Fa.flags |= r, Z.memoizedState = vy(Cs | s, p, K, X);
    }
    function _0(r, s) {
      return (Fa.mode & La) !== Kn ? lm(bu | gl | ls, iu, r, s) : lm(gl | ls, iu, r, s);
    }
    function by(r, s) {
      return yy(gl, iu, r, s);
    }
    function xS(r, s) {
      return lm(Ci, VI, r, s);
    }
    function z0(r, s) {
      return yy(Ci, VI, r, s);
    }
    function K0(r, s) {
      var p = Ci;
      return p |= qo, (Fa.mode & La) !== Kn && (p |= ja), lm(p, Vs, r, s);
    }
    function L0(r, s) {
      return yy(Ci, Vs, r, s);
    }
    function ux(r, s) {
      if (typeof s == "function") {
        var p = s, y = r();
        return p(y), function() {
          p(null);
        };
      } else if (s != null) {
        var Z = s;
        Z.hasOwnProperty("current") || u("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(Z).join(", ") + "}");
        var X = r();
        return Z.current = X, function() {
          Z.current = null;
        };
      }
    }
    function k0(r, s, p) {
      typeof s != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", s !== null ? typeof s : "null");
      var y = p != null ? p.concat([r]) : null, Z = Ci;
      return Z |= qo, (Fa.mode & La) !== Kn && (Z |= ja), lm(Z, Vs, ux.bind(null, s, r), y);
    }
    function ZA(r, s, p) {
      typeof s != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", s !== null ? typeof s : "null");
      var y = p != null ? p.concat([r]) : null;
      return yy(Ci, Vs, ux.bind(null, s, r), y);
    }
    function EV(r, s) {
    }
    var D0 = EV;
    function WS(r, s) {
      var p = xC(), y = s === void 0 ? null : s;
      return p.memoizedState = [r, y], r;
    }
    function Gy(r, s) {
      var p = Zd(), y = s === void 0 ? null : s, Z = p.memoizedState;
      if (Z !== null && y !== null) {
        var X = Z[1];
        if (fy(y, X))
          return Z[0];
      }
      return p.memoizedState = [r, y], r;
    }
    function U0(r, s) {
      var p = xC(), y = s === void 0 ? null : s, Z = r();
      return p.memoizedState = [Z, y], Z;
    }
    function By(r, s) {
      var p = Zd(), y = s === void 0 ? null : s, Z = p.memoizedState;
      if (Z !== null && y !== null) {
        var X = Z[1];
        if (fy(y, X))
          return Z[0];
      }
      var K = r();
      return p.memoizedState = [K, y], K;
    }
    function O0(r) {
      var s = xC();
      return s.memoizedState = r, r;
    }
    function VS(r) {
      var s = Zd(), p = ml, y = p.memoizedState;
      return MS(s, y, r);
    }
    function NS(r) {
      var s = Zd();
      if (ml === null)
        return s.memoizedState = r, r;
      var p = ml.memoizedState;
      return MS(s, p, r);
    }
    function MS(r, s, p) {
      var y = !kt(_f);
      if (y) {
        if (!Ri(p, s)) {
          var Z = lr();
          Fa.lanes = fn(Fa.lanes, Z), nZ(Z), r.baseState = !0;
        }
        return s;
      } else
        return r.baseState && (r.baseState = !1, kS()), r.memoizedState = p, p;
    }
    function cx(r, s, p) {
      var y = Nl();
      Lr(cv(y, Ec)), r(!0);
      var Z = rm.transition;
      rm.transition = {};
      var X = rm.transition;
      rm.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        r(!1), s();
      } finally {
        if (Lr(y), rm.transition = Z, Z === null && X._updatedFibers) {
          var K = X._updatedFibers.size;
          K > 10 && l("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), X._updatedFibers.clear();
        }
      }
    }
    function P0() {
      var r = Ay(!1), s = r[0], p = r[1], y = cx.bind(null, p), Z = xC();
      return Z.memoizedState = y, [s, y];
    }
    function HS() {
      var r = wS(), s = r[0], p = Zd(), y = p.memoizedState;
      return [s, y];
    }
    function XS() {
      var r = T0(), s = r[0], p = Zd(), y = p.memoizedState;
      return [s, y];
    }
    var YS = !1;
    function gx() {
      return YS;
    }
    function J0() {
      var r = xC(), s = Wx(), p = s.identifierPrefix, y;
      if (go()) {
        var Z = ZV();
        y = ":" + p + "R" + Z;
        var X = RC++;
        X > 0 && (y += "H" + X.toString(32)), y += ":";
      } else {
        var K = vS++;
        y = ":" + p + "r" + K.toString(32) + ":";
      }
      return r.memoizedState = y, y;
    }
    function Sy() {
      var r = Zd(), s = r.memoizedState;
      return s;
    }
    function dx(r, s, p) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var y = WA(r), Z = {
        lane: y,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (FS(r))
        ES(s, Z);
      else {
        var X = dS(r, s, Z, y);
        if (X !== null) {
          var K = Mg();
          su(X, r, y, K), Q0(X, s, y);
        }
      }
      Cx(r, y);
    }
    function Ix(r, s, p) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var y = WA(r), Z = {
        lane: y,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (FS(r))
        ES(s, Z);
      else {
        var X = r.alternate;
        if (r.lanes === dn && (X === null || X.lanes === dn)) {
          var K = s.lastRenderedReducer;
          if (K !== null) {
            var j;
            j = jn.current, jn.current = w;
            try {
              var ne = s.lastRenderedState, de = K(ne, p);
              if (Z.hasEagerState = !0, Z.eagerState = de, Ri(de, ne)) {
                VV(r, s, Z, y);
                return;
              }
            } catch {
            } finally {
              jn.current = j;
            }
          }
        }
        var Ge = dS(r, s, Z, y);
        if (Ge !== null) {
          var rt = Mg();
          su(Ge, r, y, rt), Q0(Ge, s, y);
        }
      }
      Cx(r, y);
    }
    function FS(r) {
      var s = r.alternate;
      return r === Fa || s !== null && s === Fa;
    }
    function ES(r, s) {
      hy = Sh = !0;
      var p = r.pending;
      p === null ? s.next = s : (s.next = p.next, p.next = s), r.pending = s;
    }
    function Q0(r, s, p) {
      if (wi(p)) {
        var y = s.lanes;
        y = $i(y, r.pendingLanes);
        var Z = fn(y, p);
        s.lanes = Z, Bp(r, Z);
      }
    }
    function Cx(r, s, p) {
      tc(r, s);
    }
    var j0 = {
      readContext: xs,
      useCallback: Fu,
      useContext: Fu,
      useEffect: Fu,
      useImperativeHandle: Fu,
      useInsertionEffect: Fu,
      useLayoutEffect: Fu,
      useMemo: Fu,
      useReducer: Fu,
      useRef: Fu,
      useState: Fu,
      useDebugValue: Fu,
      useDeferredValue: Fu,
      useTransition: Fu,
      useMutableSource: Fu,
      useSyncExternalStore: Fu,
      useId: Fu,
      unstable_isNewReconciler: Ce
    }, hx = null, fx = null, c = null, d = null, G = null, w = null, H = null;
    {
      var z = function() {
        u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Q = function() {
        u("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      hx = {
        readContext: function(r) {
          return xs(r);
        },
        useCallback: function(r, s) {
          return on = "useCallback", da(), Kf(s), WS(r, s);
        },
        useContext: function(r) {
          return on = "useContext", da(), xs(r);
        },
        useEffect: function(r, s) {
          return on = "useEffect", da(), Kf(s), _0(r, s);
        },
        useImperativeHandle: function(r, s, p) {
          return on = "useImperativeHandle", da(), Kf(p), k0(r, s, p);
        },
        useInsertionEffect: function(r, s) {
          return on = "useInsertionEffect", da(), Kf(s), xS(r, s);
        },
        useLayoutEffect: function(r, s) {
          return on = "useLayoutEffect", da(), Kf(s), K0(r, s);
        },
        useMemo: function(r, s) {
          on = "useMemo", da(), Kf(s);
          var p = jn.current;
          jn.current = G;
          try {
            return U0(r, s);
          } finally {
            jn.current = p;
          }
        },
        useReducer: function(r, s, p) {
          on = "useReducer", da();
          var y = jn.current;
          jn.current = G;
          try {
            return BS(r, s, p);
          } finally {
            jn.current = y;
          }
        },
        useRef: function(r) {
          return on = "useRef", da(), RS(r);
        },
        useState: function(r) {
          on = "useState", da();
          var s = jn.current;
          jn.current = G;
          try {
            return Ay(r);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(r, s) {
          return on = "useDebugValue", da(), void 0;
        },
        useDeferredValue: function(r) {
          return on = "useDeferredValue", da(), O0(r);
        },
        useTransition: function() {
          return on = "useTransition", da(), P0();
        },
        useMutableSource: function(r, s, p) {
          return on = "useMutableSource", da(), void 0;
        },
        useSyncExternalStore: function(r, s, p) {
          return on = "useSyncExternalStore", da(), SS(r, s, p);
        },
        useId: function() {
          return on = "useId", da(), J0();
        },
        unstable_isNewReconciler: Ce
      }, fx = {
        readContext: function(r) {
          return xs(r);
        },
        useCallback: function(r, s) {
          return on = "useCallback", Un(), WS(r, s);
        },
        useContext: function(r) {
          return on = "useContext", Un(), xs(r);
        },
        useEffect: function(r, s) {
          return on = "useEffect", Un(), _0(r, s);
        },
        useImperativeHandle: function(r, s, p) {
          return on = "useImperativeHandle", Un(), k0(r, s, p);
        },
        useInsertionEffect: function(r, s) {
          return on = "useInsertionEffect", Un(), xS(r, s);
        },
        useLayoutEffect: function(r, s) {
          return on = "useLayoutEffect", Un(), K0(r, s);
        },
        useMemo: function(r, s) {
          on = "useMemo", Un();
          var p = jn.current;
          jn.current = G;
          try {
            return U0(r, s);
          } finally {
            jn.current = p;
          }
        },
        useReducer: function(r, s, p) {
          on = "useReducer", Un();
          var y = jn.current;
          jn.current = G;
          try {
            return BS(r, s, p);
          } finally {
            jn.current = y;
          }
        },
        useRef: function(r) {
          return on = "useRef", Un(), RS(r);
        },
        useState: function(r) {
          on = "useState", Un();
          var s = jn.current;
          jn.current = G;
          try {
            return Ay(r);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(r, s) {
          return on = "useDebugValue", Un(), void 0;
        },
        useDeferredValue: function(r) {
          return on = "useDeferredValue", Un(), O0(r);
        },
        useTransition: function() {
          return on = "useTransition", Un(), P0();
        },
        useMutableSource: function(r, s, p) {
          return on = "useMutableSource", Un(), void 0;
        },
        useSyncExternalStore: function(r, s, p) {
          return on = "useSyncExternalStore", Un(), SS(r, s, p);
        },
        useId: function() {
          return on = "useId", Un(), J0();
        },
        unstable_isNewReconciler: Ce
      }, c = {
        readContext: function(r) {
          return xs(r);
        },
        useCallback: function(r, s) {
          return on = "useCallback", Un(), Gy(r, s);
        },
        useContext: function(r) {
          return on = "useContext", Un(), xs(r);
        },
        useEffect: function(r, s) {
          return on = "useEffect", Un(), by(r, s);
        },
        useImperativeHandle: function(r, s, p) {
          return on = "useImperativeHandle", Un(), ZA(r, s, p);
        },
        useInsertionEffect: function(r, s) {
          return on = "useInsertionEffect", Un(), z0(r, s);
        },
        useLayoutEffect: function(r, s) {
          return on = "useLayoutEffect", Un(), L0(r, s);
        },
        useMemo: function(r, s) {
          on = "useMemo", Un();
          var p = jn.current;
          jn.current = w;
          try {
            return By(r, s);
          } finally {
            jn.current = p;
          }
        },
        useReducer: function(r, s, p) {
          on = "useReducer", Un();
          var y = jn.current;
          jn.current = w;
          try {
            return py(r, s, p);
          } finally {
            jn.current = y;
          }
        },
        useRef: function(r) {
          return on = "useRef", Un(), SA();
        },
        useState: function(r) {
          on = "useState", Un();
          var s = jn.current;
          jn.current = w;
          try {
            return wS(r);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(r, s) {
          return on = "useDebugValue", Un(), D0();
        },
        useDeferredValue: function(r) {
          return on = "useDeferredValue", Un(), VS(r);
        },
        useTransition: function() {
          return on = "useTransition", Un(), HS();
        },
        useMutableSource: function(r, s, p) {
          return on = "useMutableSource", Un(), void 0;
        },
        useSyncExternalStore: function(r, s, p) {
          return on = "useSyncExternalStore", Un(), Y0(r, s);
        },
        useId: function() {
          return on = "useId", Un(), Sy();
        },
        unstable_isNewReconciler: Ce
      }, d = {
        readContext: function(r) {
          return xs(r);
        },
        useCallback: function(r, s) {
          return on = "useCallback", Un(), Gy(r, s);
        },
        useContext: function(r) {
          return on = "useContext", Un(), xs(r);
        },
        useEffect: function(r, s) {
          return on = "useEffect", Un(), by(r, s);
        },
        useImperativeHandle: function(r, s, p) {
          return on = "useImperativeHandle", Un(), ZA(r, s, p);
        },
        useInsertionEffect: function(r, s) {
          return on = "useInsertionEffect", Un(), z0(r, s);
        },
        useLayoutEffect: function(r, s) {
          return on = "useLayoutEffect", Un(), L0(r, s);
        },
        useMemo: function(r, s) {
          on = "useMemo", Un();
          var p = jn.current;
          jn.current = H;
          try {
            return By(r, s);
          } finally {
            jn.current = p;
          }
        },
        useReducer: function(r, s, p) {
          on = "useReducer", Un();
          var y = jn.current;
          jn.current = H;
          try {
            return my(r, s, p);
          } finally {
            jn.current = y;
          }
        },
        useRef: function(r) {
          return on = "useRef", Un(), SA();
        },
        useState: function(r) {
          on = "useState", Un();
          var s = jn.current;
          jn.current = H;
          try {
            return T0(r);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(r, s) {
          return on = "useDebugValue", Un(), D0();
        },
        useDeferredValue: function(r) {
          return on = "useDeferredValue", Un(), NS(r);
        },
        useTransition: function() {
          return on = "useTransition", Un(), XS();
        },
        useMutableSource: function(r, s, p) {
          return on = "useMutableSource", Un(), void 0;
        },
        useSyncExternalStore: function(r, s, p) {
          return on = "useSyncExternalStore", Un(), Y0(r, s);
        },
        useId: function() {
          return on = "useId", Un(), Sy();
        },
        unstable_isNewReconciler: Ce
      }, G = {
        readContext: function(r) {
          return z(), xs(r);
        },
        useCallback: function(r, s) {
          return on = "useCallback", Q(), da(), WS(r, s);
        },
        useContext: function(r) {
          return on = "useContext", Q(), da(), xs(r);
        },
        useEffect: function(r, s) {
          return on = "useEffect", Q(), da(), _0(r, s);
        },
        useImperativeHandle: function(r, s, p) {
          return on = "useImperativeHandle", Q(), da(), k0(r, s, p);
        },
        useInsertionEffect: function(r, s) {
          return on = "useInsertionEffect", Q(), da(), xS(r, s);
        },
        useLayoutEffect: function(r, s) {
          return on = "useLayoutEffect", Q(), da(), K0(r, s);
        },
        useMemo: function(r, s) {
          on = "useMemo", Q(), da();
          var p = jn.current;
          jn.current = G;
          try {
            return U0(r, s);
          } finally {
            jn.current = p;
          }
        },
        useReducer: function(r, s, p) {
          on = "useReducer", Q(), da();
          var y = jn.current;
          jn.current = G;
          try {
            return BS(r, s, p);
          } finally {
            jn.current = y;
          }
        },
        useRef: function(r) {
          return on = "useRef", Q(), da(), RS(r);
        },
        useState: function(r) {
          on = "useState", Q(), da();
          var s = jn.current;
          jn.current = G;
          try {
            return Ay(r);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(r, s) {
          return on = "useDebugValue", Q(), da(), void 0;
        },
        useDeferredValue: function(r) {
          return on = "useDeferredValue", Q(), da(), O0(r);
        },
        useTransition: function() {
          return on = "useTransition", Q(), da(), P0();
        },
        useMutableSource: function(r, s, p) {
          return on = "useMutableSource", Q(), da(), void 0;
        },
        useSyncExternalStore: function(r, s, p) {
          return on = "useSyncExternalStore", Q(), da(), SS(r, s, p);
        },
        useId: function() {
          return on = "useId", Q(), da(), J0();
        },
        unstable_isNewReconciler: Ce
      }, w = {
        readContext: function(r) {
          return z(), xs(r);
        },
        useCallback: function(r, s) {
          return on = "useCallback", Q(), Un(), Gy(r, s);
        },
        useContext: function(r) {
          return on = "useContext", Q(), Un(), xs(r);
        },
        useEffect: function(r, s) {
          return on = "useEffect", Q(), Un(), by(r, s);
        },
        useImperativeHandle: function(r, s, p) {
          return on = "useImperativeHandle", Q(), Un(), ZA(r, s, p);
        },
        useInsertionEffect: function(r, s) {
          return on = "useInsertionEffect", Q(), Un(), z0(r, s);
        },
        useLayoutEffect: function(r, s) {
          return on = "useLayoutEffect", Q(), Un(), L0(r, s);
        },
        useMemo: function(r, s) {
          on = "useMemo", Q(), Un();
          var p = jn.current;
          jn.current = w;
          try {
            return By(r, s);
          } finally {
            jn.current = p;
          }
        },
        useReducer: function(r, s, p) {
          on = "useReducer", Q(), Un();
          var y = jn.current;
          jn.current = w;
          try {
            return py(r, s, p);
          } finally {
            jn.current = y;
          }
        },
        useRef: function(r) {
          return on = "useRef", Q(), Un(), SA();
        },
        useState: function(r) {
          on = "useState", Q(), Un();
          var s = jn.current;
          jn.current = w;
          try {
            return wS(r);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(r, s) {
          return on = "useDebugValue", Q(), Un(), D0();
        },
        useDeferredValue: function(r) {
          return on = "useDeferredValue", Q(), Un(), VS(r);
        },
        useTransition: function() {
          return on = "useTransition", Q(), Un(), HS();
        },
        useMutableSource: function(r, s, p) {
          return on = "useMutableSource", Q(), Un(), void 0;
        },
        useSyncExternalStore: function(r, s, p) {
          return on = "useSyncExternalStore", Q(), Un(), Y0(r, s);
        },
        useId: function() {
          return on = "useId", Q(), Un(), Sy();
        },
        unstable_isNewReconciler: Ce
      }, H = {
        readContext: function(r) {
          return z(), xs(r);
        },
        useCallback: function(r, s) {
          return on = "useCallback", Q(), Un(), Gy(r, s);
        },
        useContext: function(r) {
          return on = "useContext", Q(), Un(), xs(r);
        },
        useEffect: function(r, s) {
          return on = "useEffect", Q(), Un(), by(r, s);
        },
        useImperativeHandle: function(r, s, p) {
          return on = "useImperativeHandle", Q(), Un(), ZA(r, s, p);
        },
        useInsertionEffect: function(r, s) {
          return on = "useInsertionEffect", Q(), Un(), z0(r, s);
        },
        useLayoutEffect: function(r, s) {
          return on = "useLayoutEffect", Q(), Un(), L0(r, s);
        },
        useMemo: function(r, s) {
          on = "useMemo", Q(), Un();
          var p = jn.current;
          jn.current = w;
          try {
            return By(r, s);
          } finally {
            jn.current = p;
          }
        },
        useReducer: function(r, s, p) {
          on = "useReducer", Q(), Un();
          var y = jn.current;
          jn.current = w;
          try {
            return my(r, s, p);
          } finally {
            jn.current = y;
          }
        },
        useRef: function(r) {
          return on = "useRef", Q(), Un(), SA();
        },
        useState: function(r) {
          on = "useState", Q(), Un();
          var s = jn.current;
          jn.current = w;
          try {
            return T0(r);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(r, s) {
          return on = "useDebugValue", Q(), Un(), D0();
        },
        useDeferredValue: function(r) {
          return on = "useDeferredValue", Q(), Un(), NS(r);
        },
        useTransition: function() {
          return on = "useTransition", Q(), Un(), XS();
        },
        useMutableSource: function(r, s, p) {
          return on = "useMutableSource", Q(), Un(), void 0;
        },
        useSyncExternalStore: function(r, s, p) {
          return on = "useSyncExternalStore", Q(), Un(), Y0(r, s);
        },
        useId: function() {
          return on = "useId", Q(), Un(), Sy();
        },
        unstable_isNewReconciler: Ce
      };
    }
    var re = t.unstable_now, ce = 0, Xe = -1, Je = -1, ft = -1, _t = !1, Ut = !1;
    function yn() {
      return _t;
    }
    function xn() {
      Ut = !0;
    }
    function _i() {
      _t = !1, Ut = !1;
    }
    function Ar() {
      _t = Ut, Ut = !1;
    }
    function Ui() {
      return ce;
    }
    function Bo() {
      ce = re();
    }
    function ho(r) {
      Je = re(), r.actualStartTime < 0 && (r.actualStartTime = re());
    }
    function Rt(r) {
      Je = -1;
    }
    function en(r, s) {
      if (Je >= 0) {
        var p = re() - Je;
        r.actualDuration += p, s && (r.selfBaseDuration = p), Je = -1;
      }
    }
    function Ct(r) {
      if (Xe >= 0) {
        var s = re() - Xe;
        Xe = -1;
        for (var p = r.return; p !== null; ) {
          switch (p.tag) {
            case b:
              var y = p.stateNode;
              y.effectDuration += s;
              return;
            case P:
              var Z = p.stateNode;
              Z.effectDuration += s;
              return;
          }
          p = p.return;
        }
      }
    }
    function Vn(r) {
      if (ft >= 0) {
        var s = re() - ft;
        ft = -1;
        for (var p = r.return; p !== null; ) {
          switch (p.tag) {
            case b:
              var y = p.stateNode;
              y !== null && (y.passiveEffectDuration += s);
              return;
            case P:
              var Z = p.stateNode;
              Z !== null && (Z.passiveEffectDuration += s);
              return;
          }
          p = p.return;
        }
      }
    }
    function di() {
      Xe = re();
    }
    function si() {
      ft = re();
    }
    function Er(r) {
      for (var s = r.child; s; )
        r.actualDuration += s.actualDuration, s = s.sibling;
    }
    function Zr(r, s) {
      if (r && r.defaultProps) {
        var p = Xn({}, s), y = r.defaultProps;
        for (var Z in y)
          p[Z] === void 0 && (p[Z] = y[Z]);
        return p;
      }
      return s;
    }
    var Ua = {}, pa, Eo, aa, wr, ts, Oo, dc, Al, Ic, Cc, Oc;
    {
      pa = /* @__PURE__ */ new Set(), Eo = /* @__PURE__ */ new Set(), aa = /* @__PURE__ */ new Set(), wr = /* @__PURE__ */ new Set(), Al = /* @__PURE__ */ new Set(), ts = /* @__PURE__ */ new Set(), Ic = /* @__PURE__ */ new Set(), Cc = /* @__PURE__ */ new Set(), Oc = /* @__PURE__ */ new Set();
      var um = /* @__PURE__ */ new Set();
      dc = function(r, s) {
        if (!(r === null || typeof r == "function")) {
          var p = s + "_" + r;
          um.has(p) || (um.add(p), u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s, r));
        }
      }, Oo = function(r, s) {
        if (s === void 0) {
          var p = ci(r) || "Component";
          ts.has(p) || (ts.add(p), u("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", p));
        }
      }, Object.defineProperty(Ua, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Ua);
    }
    function kf(r, s, p, y) {
      var Z = r.memoizedState, X = p(y, Z);
      {
        if (r.mode & Or) {
          ra(!0);
          try {
            X = p(y, Z);
          } finally {
            ra(!1);
          }
        }
        Oo(s, X);
      }
      var K = X == null ? Z : Xn({}, Z, X);
      if (r.memoizedState = K, r.lanes === dn) {
        var j = r.updateQueue;
        j.baseState = K;
      }
    }
    var hc = {
      isMounted: ys,
      enqueueSetState: function(r, s, p) {
        var y = os(r), Z = Mg(), X = WA(y), K = wC(Z, X);
        K.payload = s, p != null && (dc(p, "setState"), K.callback = p);
        var j = Bh(y, K, X);
        j !== null && (su(j, y, X, Z), sy(j, y, X)), tc(y, X);
      },
      enqueueReplaceState: function(r, s, p) {
        var y = os(r), Z = Mg(), X = WA(y), K = wC(Z, X);
        K.tag = nx, K.payload = s, p != null && (dc(p, "replaceState"), K.callback = p);
        var j = Bh(y, K, X);
        j !== null && (su(j, y, X, Z), sy(j, y, X)), tc(y, X);
      },
      enqueueForceUpdate: function(r, s) {
        var p = os(r), y = Mg(), Z = WA(p), X = wC(y, Z);
        X.tag = R0, s != null && (dc(s, "forceUpdate"), X.callback = s);
        var K = Bh(p, X, Z);
        K !== null && (su(K, p, Z, y), sy(K, p, Z)), sI(p, Z);
      }
    };
    function Df(r, s, p, y, Z, X, K) {
      var j = r.stateNode;
      if (typeof j.shouldComponentUpdate == "function") {
        var ne = j.shouldComponentUpdate(y, X, K);
        {
          if (r.mode & Or) {
            ra(!0);
            try {
              ne = j.shouldComponentUpdate(y, X, K);
            } finally {
              ra(!1);
            }
          }
          ne === void 0 && u("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", ci(s) || "Component");
        }
        return ne;
      }
      return s.prototype && s.prototype.isPureReactComponent ? !Yo(p, y) || !Yo(Z, X) : !0;
    }
    function TS(r, s, p) {
      var y = r.stateNode;
      {
        var Z = ci(s) || "Component", X = y.render;
        X || (s.prototype && typeof s.prototype.render == "function" ? u("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", Z) : u("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", Z)), y.getInitialState && !y.getInitialState.isReactClassApproved && !y.state && u("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", Z), y.getDefaultProps && !y.getDefaultProps.isReactClassApproved && u("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", Z), y.propTypes && u("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", Z), y.contextType && u("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", Z), s.childContextTypes && !Oc.has(s) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (r.mode & Or) === Kn && (Oc.add(s), u(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, Z)), s.contextTypes && !Oc.has(s) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (r.mode & Or) === Kn && (Oc.add(s), u(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, Z)), y.contextTypes && u("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", Z), s.contextType && s.contextTypes && !Ic.has(s) && (Ic.add(s), u("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", Z)), typeof y.componentShouldUpdate == "function" && u("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", Z), s.prototype && s.prototype.isPureReactComponent && typeof y.shouldComponentUpdate < "u" && u("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", ci(s) || "A pure component"), typeof y.componentDidUnmount == "function" && u("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", Z), typeof y.componentDidReceiveProps == "function" && u("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", Z), typeof y.componentWillRecieveProps == "function" && u("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", Z), typeof y.UNSAFE_componentWillRecieveProps == "function" && u("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", Z);
        var K = y.props !== p;
        y.props !== void 0 && K && u("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", Z, Z), y.defaultProps && u("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", Z, Z), typeof y.getSnapshotBeforeUpdate == "function" && typeof y.componentDidUpdate != "function" && !aa.has(s) && (aa.add(s), u("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", ci(s))), typeof y.getDerivedStateFromProps == "function" && u("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Z), typeof y.getDerivedStateFromError == "function" && u("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Z), typeof s.getSnapshotBeforeUpdate == "function" && u("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", Z);
        var j = y.state;
        j && (typeof j != "object" || Fr(j)) && u("%s.state: must be set to an object or null", Z), typeof y.getChildContext == "function" && typeof s.childContextTypes != "object" && u("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", Z);
      }
    }
    function _S(r, s) {
      s.updater = hc, r.stateNode = s, ks(s, r), s._reactInternalInstance = Ua;
    }
    function px(r, s, p) {
      var y = !1, Z = kc, X = kc, K = s.contextType;
      if ("contextType" in s) {
        var j = (
          // Allow null for conditional declaration
          K === null || K !== void 0 && K.$$typeof === ut && K._context === void 0
        );
        if (!j && !Cc.has(s)) {
          Cc.add(s);
          var ne = "";
          K === void 0 ? ne = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof K != "object" ? ne = " However, it is set to a " + typeof K + "." : K.$$typeof === me ? ne = " Did you accidentally pass the Context.Provider instead?" : K._context !== void 0 ? ne = " Did you accidentally pass the Context.Consumer instead?" : ne = " However, it is set to an object with keys {" + Object.keys(K).join(", ") + "}.", u("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", ci(s) || "Component", ne);
        }
      }
      if (typeof K == "object" && K !== null)
        X = xs(K);
      else {
        Z = Zf(r, s, !0);
        var de = s.contextTypes;
        y = de != null, X = y ? IA(r, Z) : kc;
      }
      var Ge = new s(p, X);
      if (r.mode & Or) {
        ra(!0);
        try {
          Ge = new s(p, X);
        } finally {
          ra(!1);
        }
      }
      var rt = r.memoizedState = Ge.state !== null && Ge.state !== void 0 ? Ge.state : null;
      _S(r, Ge);
      {
        if (typeof s.getDerivedStateFromProps == "function" && rt === null) {
          var it = ci(s) || "Component";
          Eo.has(it) || (Eo.add(it), u("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", it, Ge.state === null ? "null" : "undefined", it));
        }
        if (typeof s.getDerivedStateFromProps == "function" || typeof Ge.getSnapshotBeforeUpdate == "function") {
          var Vt = null, Xt = null, Jt = null;
          if (typeof Ge.componentWillMount == "function" && Ge.componentWillMount.__suppressDeprecationWarning !== !0 ? Vt = "componentWillMount" : typeof Ge.UNSAFE_componentWillMount == "function" && (Vt = "UNSAFE_componentWillMount"), typeof Ge.componentWillReceiveProps == "function" && Ge.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Xt = "componentWillReceiveProps" : typeof Ge.UNSAFE_componentWillReceiveProps == "function" && (Xt = "UNSAFE_componentWillReceiveProps"), typeof Ge.componentWillUpdate == "function" && Ge.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Jt = "componentWillUpdate" : typeof Ge.UNSAFE_componentWillUpdate == "function" && (Jt = "UNSAFE_componentWillUpdate"), Vt !== null || Xt !== null || Jt !== null) {
            var ri = ci(s) || "Component", Li = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            wr.has(ri) || (wr.add(ri), u(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, ri, Li, Vt !== null ? `
  ` + Vt : "", Xt !== null ? `
  ` + Xt : "", Jt !== null ? `
  ` + Jt : ""));
          }
        }
      }
      return y && jB(r, Z, X), Ge;
    }
    function TV(r, s) {
      var p = s.state;
      typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), p !== s.state && (u("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", gi(r) || "Component"), hc.enqueueReplaceState(s, s.state, null));
    }
    function MY(r, s, p, y) {
      var Z = s.state;
      if (typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(p, y), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(p, y), s.state !== Z) {
        {
          var X = gi(r) || "Component";
          pa.has(X) || (pa.add(X), u("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", X));
        }
        hc.enqueueReplaceState(s, s.state, null);
      }
    }
    function _V(r, s, p, y) {
      TS(r, s, p);
      var Z = r.stateNode;
      Z.props = p, Z.state = r.memoizedState, Z.refs = {}, oy(r);
      var X = s.contextType;
      if (typeof X == "object" && X !== null)
        Z.context = xs(X);
      else {
        var K = Zf(r, s, !0);
        Z.context = IA(r, K);
      }
      {
        if (Z.state === p) {
          var j = ci(s) || "Component";
          Al.has(j) || (Al.add(j), u("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", j));
        }
        r.mode & Or && cc.recordLegacyContextWarning(r, Z), cc.recordUnsafeLifecycleWarnings(r, Z);
      }
      Z.state = r.memoizedState;
      var ne = s.getDerivedStateFromProps;
      if (typeof ne == "function" && (kf(r, s, ne, p), Z.state = r.memoizedState), typeof s.getDerivedStateFromProps != "function" && typeof Z.getSnapshotBeforeUpdate != "function" && (typeof Z.UNSAFE_componentWillMount == "function" || typeof Z.componentWillMount == "function") && (TV(r, Z), V0(r, p, Z, y), Z.state = r.memoizedState), typeof Z.componentDidMount == "function") {
        var de = Ci;
        de |= qo, (r.mode & La) !== Kn && (de |= ja), r.flags |= de;
      }
    }
    function J9(r, s, p, y) {
      var Z = r.stateNode, X = r.memoizedProps;
      Z.props = X;
      var K = Z.context, j = s.contextType, ne = kc;
      if (typeof j == "object" && j !== null)
        ne = xs(j);
      else {
        var de = Zf(r, s, !0);
        ne = IA(r, de);
      }
      var Ge = s.getDerivedStateFromProps, rt = typeof Ge == "function" || typeof Z.getSnapshotBeforeUpdate == "function";
      !rt && (typeof Z.UNSAFE_componentWillReceiveProps == "function" || typeof Z.componentWillReceiveProps == "function") && (X !== p || K !== ne) && MY(r, Z, p, ne), ix();
      var it = r.memoizedState, Vt = Z.state = it;
      if (V0(r, p, Z, y), Vt = r.memoizedState, X === p && it === Vt && !CA() && !N0()) {
        if (typeof Z.componentDidMount == "function") {
          var Xt = Ci;
          Xt |= qo, (r.mode & La) !== Kn && (Xt |= ja), r.flags |= Xt;
        }
        return !1;
      }
      typeof Ge == "function" && (kf(r, s, Ge, p), Vt = r.memoizedState);
      var Jt = N0() || Df(r, s, X, p, it, Vt, ne);
      if (Jt) {
        if (!rt && (typeof Z.UNSAFE_componentWillMount == "function" || typeof Z.componentWillMount == "function") && (typeof Z.componentWillMount == "function" && Z.componentWillMount(), typeof Z.UNSAFE_componentWillMount == "function" && Z.UNSAFE_componentWillMount()), typeof Z.componentDidMount == "function") {
          var ri = Ci;
          ri |= qo, (r.mode & La) !== Kn && (ri |= ja), r.flags |= ri;
        }
      } else {
        if (typeof Z.componentDidMount == "function") {
          var Li = Ci;
          Li |= qo, (r.mode & La) !== Kn && (Li |= ja), r.flags |= Li;
        }
        r.memoizedProps = p, r.memoizedState = Vt;
      }
      return Z.props = p, Z.state = Vt, Z.context = ne, Jt;
    }
    function Q9(r, s, p, y, Z) {
      var X = s.stateNode;
      Yf(r, s);
      var K = s.memoizedProps, j = s.type === s.elementType ? K : Zr(s.type, K);
      X.props = j;
      var ne = s.pendingProps, de = X.context, Ge = p.contextType, rt = kc;
      if (typeof Ge == "object" && Ge !== null)
        rt = xs(Ge);
      else {
        var it = Zf(s, p, !0);
        rt = IA(s, it);
      }
      var Vt = p.getDerivedStateFromProps, Xt = typeof Vt == "function" || typeof X.getSnapshotBeforeUpdate == "function";
      !Xt && (typeof X.UNSAFE_componentWillReceiveProps == "function" || typeof X.componentWillReceiveProps == "function") && (K !== ne || de !== rt) && MY(s, X, y, rt), ix();
      var Jt = s.memoizedState, ri = X.state = Jt;
      if (V0(s, y, X, Z), ri = s.memoizedState, K === ne && Jt === ri && !CA() && !N0() && !be)
        return typeof X.componentDidUpdate == "function" && (K !== r.memoizedProps || Jt !== r.memoizedState) && (s.flags |= Ci), typeof X.getSnapshotBeforeUpdate == "function" && (K !== r.memoizedProps || Jt !== r.memoizedState) && (s.flags |= Qa), !1;
      typeof Vt == "function" && (kf(s, p, Vt, y), ri = s.memoizedState);
      var Li = N0() || Df(s, p, j, y, Jt, ri, rt) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      be;
      return Li ? (!Xt && (typeof X.UNSAFE_componentWillUpdate == "function" || typeof X.componentWillUpdate == "function") && (typeof X.componentWillUpdate == "function" && X.componentWillUpdate(y, ri, rt), typeof X.UNSAFE_componentWillUpdate == "function" && X.UNSAFE_componentWillUpdate(y, ri, rt)), typeof X.componentDidUpdate == "function" && (s.flags |= Ci), typeof X.getSnapshotBeforeUpdate == "function" && (s.flags |= Qa)) : (typeof X.componentDidUpdate == "function" && (K !== r.memoizedProps || Jt !== r.memoizedState) && (s.flags |= Ci), typeof X.getSnapshotBeforeUpdate == "function" && (K !== r.memoizedProps || Jt !== r.memoizedState) && (s.flags |= Qa), s.memoizedProps = y, s.memoizedState = ri), X.props = y, X.state = ri, X.context = rt, Li;
    }
    function Zy(r, s) {
      return {
        value: r,
        source: s,
        stack: ti(s),
        digest: null
      };
    }
    function zV(r, s, p) {
      return {
        value: r,
        source: null,
        stack: p ?? null,
        digest: s ?? null
      };
    }
    function j9(r, s) {
      return !0;
    }
    function KV(r, s) {
      try {
        var p = j9(r, s);
        if (p === !1)
          return;
        var y = s.value, Z = s.source, X = s.stack, K = X !== null ? X : "";
        if (y != null && y._suppressLogging) {
          if (r.tag === h)
            return;
          console.error(y);
        }
        var j = Z ? gi(Z) : null, ne = j ? "The above error occurred in the <" + j + "> component:" : "The above error occurred in one of your React components:", de;
        if (r.tag === b)
          de = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Ge = gi(r) || "Anonymous";
          de = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Ge + ".");
        }
        var rt = ne + `
` + K + `

` + ("" + de);
        console.error(rt);
      } catch (it) {
        setTimeout(function() {
          throw it;
        });
      }
    }
    var q9 = typeof WeakMap == "function" ? WeakMap : Map;
    function HY(r, s, p) {
      var y = wC(Br, p);
      y.tag = vA, y.payload = {
        element: null
      };
      var Z = s.value;
      return y.callback = function() {
        kD(Z), KV(r, s);
      }, y;
    }
    function LV(r, s, p) {
      var y = wC(Br, p);
      y.tag = vA;
      var Z = r.type.getDerivedStateFromError;
      if (typeof Z == "function") {
        var X = s.value;
        y.payload = function() {
          return Z(X);
        }, y.callback = function() {
          DF(r), KV(r, s);
        };
      }
      var K = r.stateNode;
      return K !== null && typeof K.componentDidCatch == "function" && (y.callback = function() {
        DF(r), KV(r, s), typeof Z != "function" && KD(this);
        var ne = s.value, de = s.stack;
        this.componentDidCatch(ne, {
          componentStack: de !== null ? de : ""
        }), typeof Z != "function" && (Zt(r.lanes, yi) || u("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", gi(r) || "Unknown"));
      }), y;
    }
    function XY(r, s, p) {
      var y = r.pingCache, Z;
      if (y === null ? (y = r.pingCache = new q9(), Z = /* @__PURE__ */ new Set(), y.set(s, Z)) : (Z = y.get(s), Z === void 0 && (Z = /* @__PURE__ */ new Set(), y.set(s, Z))), !Z.has(p)) {
        Z.add(p);
        var X = DD.bind(null, r, s, p);
        Os && iZ(r, p), s.then(X, X);
      }
    }
    function $9(r, s, p, y) {
      var Z = r.updateQueue;
      if (Z === null) {
        var X = /* @__PURE__ */ new Set();
        X.add(p), r.updateQueue = X;
      } else
        Z.add(p);
    }
    function ek(r, s) {
      var p = r.tag;
      if ((r.mode & Zi) === Kn && (p === f || p === _ || p === k)) {
        var y = r.alternate;
        y ? (r.updateQueue = y.updateQueue, r.memoizedState = y.memoizedState, r.lanes = y.lanes) : (r.updateQueue = null, r.memoizedState = null);
      }
    }
    function YY(r) {
      var s = r;
      do {
        if (s.tag === U && XV(s))
          return s;
        s = s.return;
      } while (s !== null);
      return null;
    }
    function FY(r, s, p, y, Z) {
      if ((r.mode & Zi) === Kn) {
        if (r === s)
          r.flags |= ss;
        else {
          if (r.flags |= Qi, p.flags |= tI, p.flags &= ~(tC | Wc), p.tag === h) {
            var X = p.alternate;
            if (X === null)
              p.tag = J;
            else {
              var K = wC(Br, yi);
              K.tag = R0, Bh(p, K, yi);
            }
          }
          p.lanes = fn(p.lanes, yi);
        }
        return r;
      }
      return r.flags |= ss, r.lanes = Z, r;
    }
    function tk(r, s, p, y, Z) {
      if (p.flags |= Wc, Os && iZ(r, Z), y !== null && typeof y == "object" && typeof y.then == "function") {
        var X = y;
        ek(p), go() && p.mode & Zi && b0();
        var K = YY(s);
        if (K !== null) {
          K.flags &= ~As, FY(K, s, p, r, Z), K.mode & Zi && XY(r, X, Z), $9(K, r, X);
          return;
        } else {
          if (!$(Z)) {
            XY(r, X, Z), bN();
            return;
          }
          var j = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          y = j;
        }
      } else if (go() && p.mode & Zi) {
        b0();
        var ne = YY(s);
        if (ne !== null) {
          (ne.flags & ss) === Hi && (ne.flags |= As), FY(ne, s, p, r, Z), xI(Zy(y, p));
          return;
        }
      }
      y = Zy(y, p), HD(y);
      var de = s;
      do {
        switch (de.tag) {
          case b: {
            var Ge = y;
            de.flags |= ss;
            var rt = gs(Z);
            de.lanes = fn(de.lanes, rt);
            var it = HY(de, Ge, rt);
            CS(de, it);
            return;
          }
          case h:
            var Vt = y, Xt = de.type, Jt = de.stateNode;
            if ((de.flags & Qi) === Hi && (typeof Xt.getDerivedStateFromError == "function" || Jt !== null && typeof Jt.componentDidCatch == "function" && !YF(Jt))) {
              de.flags |= ss;
              var ri = gs(Z);
              de.lanes = fn(de.lanes, ri);
              var Li = LV(de, Vt, ri);
              CS(de, Li);
              return;
            }
            break;
        }
        de = de.return;
      } while (de !== null);
    }
    function nk() {
      return null;
    }
    var zS = n.ReactCurrentOwner, Zh = !1, kV, KS, DV, UV, OV, wy, PV, mx, LS;
    kV = {}, KS = {}, DV = {}, UV = {}, OV = {}, wy = !1, PV = {}, mx = {}, LS = {};
    function Vg(r, s, p, y) {
      r === null ? s.child = Nf(s, null, p, y) : s.child = WI(s, r.child, p, y);
    }
    function ik(r, s, p, y) {
      s.child = WI(s, r.child, null, y), s.child = WI(s, null, p, y);
    }
    function EY(r, s, p, y, Z) {
      if (s.type !== s.elementType) {
        var X = p.propTypes;
        X && bI(
          X,
          y,
          // Resolved props
          "prop",
          ci(p)
        );
      }
      var K = p.render, j = s.ref, ne, de;
      Gh(s, Z), qr(s);
      {
        if (zS.current = s, ua(!0), ne = om(r, s, K, y, j, Z), de = BA(), s.mode & Or) {
          ra(!0);
          try {
            ne = om(r, s, K, y, j, Z), de = BA();
          } finally {
            ra(!1);
          }
        }
        ua(!1);
      }
      return ha(), r !== null && !Zh ? (Uc(r, s, Z), cm(r, s, Z)) : (go() && de && $B(s), s.flags |= Pi, Vg(r, s, ne, Z), s.child);
    }
    function TY(r, s, p, y, Z) {
      if (r === null) {
        var X = p.type;
        if (lU(X) && p.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        p.defaultProps === void 0) {
          var K = X;
          return K = aG(X), s.tag = k, s.type = K, jV(s, X), _Y(r, s, K, y, Z);
        }
        {
          var j = X.propTypes;
          if (j && bI(
            j,
            y,
            // Resolved props
            "prop",
            ci(X)
          ), p.defaultProps !== void 0) {
            var ne = ci(X) || "Unknown";
            LS[ne] || (u("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", ne), LS[ne] = !0);
          }
        }
        var de = MN(p.type, null, y, s, s.mode, Z);
        return de.ref = s.ref, de.return = s, s.child = de, de;
      }
      {
        var Ge = p.type, rt = Ge.propTypes;
        rt && bI(
          rt,
          y,
          // Resolved props
          "prop",
          ci(Ge)
        );
      }
      var it = r.child, Vt = iN(r, Z);
      if (!Vt) {
        var Xt = it.memoizedProps, Jt = p.compare;
        if (Jt = Jt !== null ? Jt : Yo, Jt(Xt, y) && r.ref === s.ref)
          return cm(r, s, Z);
      }
      s.flags |= Pi;
      var ri = Ny(it, y);
      return ri.ref = s.ref, ri.return = s, s.child = ri, ri;
    }
    function _Y(r, s, p, y, Z) {
      if (s.type !== s.elementType) {
        var X = s.elementType;
        if (X.$$typeof === Ee) {
          var K = X, j = K._payload, ne = K._init;
          try {
            X = ne(j);
          } catch {
            X = null;
          }
          var de = X && X.propTypes;
          de && bI(
            de,
            y,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            ci(X)
          );
        }
      }
      if (r !== null) {
        var Ge = r.memoizedProps;
        if (Yo(Ge, y) && r.ref === s.ref && // Prevent bailout if the implementation changed due to hot reload.
        s.type === r.type)
          if (Zh = !1, s.pendingProps = y = Ge, iN(r, Z))
            (r.flags & tI) !== Hi && (Zh = !0);
          else return s.lanes = r.lanes, cm(r, s, Z);
      }
      return JV(r, s, p, y, Z);
    }
    function zY(r, s, p) {
      var y = s.pendingProps, Z = y.children, X = r !== null ? r.memoizedState : null;
      if (y.mode === "hidden" || le)
        if ((s.mode & Zi) === Kn) {
          var K = {
            baseLanes: dn,
            cachePool: null,
            transitions: null
          };
          s.memoizedState = K, Vx(s, p);
        } else if (Zt(p, Vl)) {
          var rt = {
            baseLanes: dn,
            cachePool: null,
            transitions: null
          };
          s.memoizedState = rt;
          var it = X !== null ? X.baseLanes : p;
          Vx(s, it);
        } else {
          var j = null, ne;
          if (X !== null) {
            var de = X.baseLanes;
            ne = fn(de, p);
          } else
            ne = p;
          s.lanes = s.childLanes = Vl;
          var Ge = {
            baseLanes: ne,
            cachePool: j,
            transitions: null
          };
          return s.memoizedState = Ge, s.updateQueue = null, Vx(s, ne), null;
        }
      else {
        var Vt;
        X !== null ? (Vt = fn(X.baseLanes, p), s.memoizedState = null) : Vt = p, Vx(s, Vt);
      }
      return Vg(r, s, Z, p), s.child;
    }
    function rk(r, s, p) {
      var y = s.pendingProps;
      return Vg(r, s, y, p), s.child;
    }
    function ak(r, s, p) {
      var y = s.pendingProps.children;
      return Vg(r, s, y, p), s.child;
    }
    function ok(r, s, p) {
      {
        s.flags |= Ci;
        {
          var y = s.stateNode;
          y.effectDuration = 0, y.passiveEffectDuration = 0;
        }
      }
      var Z = s.pendingProps, X = Z.children;
      return Vg(r, s, X, p), s.child;
    }
    function KY(r, s) {
      var p = s.ref;
      (r === null && p !== null || r !== null && r.ref !== p) && (s.flags |= Zl, s.flags |= Us);
    }
    function JV(r, s, p, y, Z) {
      if (s.type !== s.elementType) {
        var X = p.propTypes;
        X && bI(
          X,
          y,
          // Resolved props
          "prop",
          ci(p)
        );
      }
      var K;
      {
        var j = Zf(s, p, !0);
        K = IA(s, j);
      }
      var ne, de;
      Gh(s, Z), qr(s);
      {
        if (zS.current = s, ua(!0), ne = om(r, s, p, y, K, Z), de = BA(), s.mode & Or) {
          ra(!0);
          try {
            ne = om(r, s, p, y, K, Z), de = BA();
          } finally {
            ra(!1);
          }
        }
        ua(!1);
      }
      return ha(), r !== null && !Zh ? (Uc(r, s, Z), cm(r, s, Z)) : (go() && de && $B(s), s.flags |= Pi, Vg(r, s, ne, Z), s.child);
    }
    function LY(r, s, p, y, Z) {
      {
        switch (GU(s)) {
          case !1: {
            var X = s.stateNode, K = s.type, j = new K(s.memoizedProps, X.context), ne = j.state;
            X.updater.enqueueSetState(X, ne, null);
            break;
          }
          case !0: {
            s.flags |= Qi, s.flags |= ss;
            var de = new Error("Simulated error coming from DevTools"), Ge = gs(Z);
            s.lanes = fn(s.lanes, Ge);
            var rt = LV(s, Zy(de, s), Ge);
            CS(s, rt);
            break;
          }
        }
        if (s.type !== s.elementType) {
          var it = p.propTypes;
          it && bI(
            it,
            y,
            // Resolved props
            "prop",
            ci(p)
          );
        }
      }
      var Vt;
      BI(p) ? (Vt = !0, h0(s)) : Vt = !1, Gh(s, Z);
      var Xt = s.stateNode, Jt;
      Xt === null ? (vx(r, s), px(s, p, y), _V(s, p, y, Z), Jt = !0) : r === null ? Jt = J9(s, p, y, Z) : Jt = Q9(r, s, p, y, Z);
      var ri = QV(r, s, p, Jt, Vt, Z);
      {
        var Li = s.stateNode;
        Jt && Li.props !== y && (wy || u("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", gi(s) || "a component"), wy = !0);
      }
      return ri;
    }
    function QV(r, s, p, y, Z, X) {
      KY(r, s);
      var K = (s.flags & Qi) !== Hi;
      if (!y && !K)
        return Z && KR(s, p, !1), cm(r, s, X);
      var j = s.stateNode;
      zS.current = s;
      var ne;
      if (K && typeof p.getDerivedStateFromError != "function")
        ne = null, Rt();
      else {
        qr(s);
        {
          if (ua(!0), ne = j.render(), s.mode & Or) {
            ra(!0);
            try {
              j.render();
            } finally {
              ra(!1);
            }
          }
          ua(!1);
        }
        ha();
      }
      return s.flags |= Pi, r !== null && K ? ik(r, s, ne, X) : Vg(r, s, ne, X), s.memoizedState = j.state, Z && KR(s, p, !0), s.child;
    }
    function kY(r) {
      var s = r.stateNode;
      s.pendingContext ? _R(r, s.pendingContext, s.pendingContext !== s.context) : s.context && _R(r, s.context, !1), fS(r, s.containerInfo);
    }
    function sk(r, s, p) {
      if (kY(s), r === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var y = s.pendingProps, Z = s.memoizedState, X = Z.element;
      Yf(r, s), V0(s, y, null, p);
      var K = s.memoizedState;
      s.stateNode;
      var j = K.element;
      if (Z.isDehydrated) {
        var ne = {
          element: j,
          isDehydrated: !1,
          cache: K.cache,
          pendingSuspenseBoundaries: K.pendingSuspenseBoundaries,
          transitions: K.transitions
        }, de = s.updateQueue;
        if (de.baseState = ne, s.memoizedState = ne, s.flags & As) {
          var Ge = Zy(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), s);
          return DY(r, s, j, p, Ge);
        } else if (j !== X) {
          var rt = Zy(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), s);
          return DY(r, s, j, p, rt);
        } else {
          PR(s);
          var it = Nf(s, null, j, p);
          s.child = it;
          for (var Vt = it; Vt; )
            Vt.flags = Vt.flags & ~ar | Dl, Vt = Vt.sibling;
        }
      } else {
        if (Wf(), j === X)
          return cm(r, s, p);
        Vg(r, s, j, p);
      }
      return s.child;
    }
    function DY(r, s, p, y, Z) {
      return Wf(), xI(Z), s.flags |= As, Vg(r, s, p, y), s.child;
    }
    function lk(r, s, p) {
      rx(s), r === null && aS(s);
      var y = s.type, Z = s.pendingProps, X = r !== null ? r.memoizedProps : null, K = Z.children, j = FB(y, Z);
      return j ? K = null : X !== null && FB(y, X) && (s.flags |= Ds), KY(r, s), Vg(r, s, K, p), s.child;
    }
    function uk(r, s) {
      return r === null && aS(s), null;
    }
    function ck(r, s, p, y) {
      vx(r, s);
      var Z = s.pendingProps, X = p, K = X._payload, j = X._init, ne = j(K);
      s.type = ne;
      var de = s.tag = uU(ne), Ge = Zr(ne, Z), rt;
      switch (de) {
        case f:
          return jV(s, ne), s.type = ne = aG(ne), rt = JV(null, s, ne, Ge, y), rt;
        case h:
          return s.type = ne = wN(ne), rt = LY(null, s, ne, Ge, y), rt;
        case _:
          return s.type = ne = RN(ne), rt = EY(null, s, ne, Ge, y), rt;
        case q: {
          if (s.type !== s.elementType) {
            var it = ne.propTypes;
            it && bI(
              it,
              Ge,
              // Resolved for outer only
              "prop",
              ci(ne)
            );
          }
          return rt = TY(
            null,
            s,
            ne,
            Zr(ne.type, Ge),
            // The inner type can have defaults too
            y
          ), rt;
        }
      }
      var Vt = "";
      throw ne !== null && typeof ne == "object" && ne.$$typeof === Ee && (Vt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + ne + ". " + ("Lazy element type must resolve to a class or function." + Vt));
    }
    function gk(r, s, p, y, Z) {
      vx(r, s), s.tag = h;
      var X;
      return BI(p) ? (X = !0, h0(s)) : X = !1, Gh(s, Z), px(s, p, y), _V(s, p, y, Z), QV(null, s, p, !0, X, Z);
    }
    function dk(r, s, p, y) {
      vx(r, s);
      var Z = s.pendingProps, X;
      {
        var K = Zf(s, p, !1);
        X = IA(s, K);
      }
      Gh(s, y);
      var j, ne;
      qr(s);
      {
        if (p.prototype && typeof p.prototype.render == "function") {
          var de = ci(p) || "Unknown";
          kV[de] || (u("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", de, de), kV[de] = !0);
        }
        s.mode & Or && cc.recordLegacyContextWarning(s, null), ua(!0), zS.current = s, j = om(null, s, p, Z, X, y), ne = BA(), ua(!1);
      }
      if (ha(), s.flags |= Pi, typeof j == "object" && j !== null && typeof j.render == "function" && j.$$typeof === void 0) {
        var Ge = ci(p) || "Unknown";
        KS[Ge] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ge, Ge, Ge), KS[Ge] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof j == "object" && j !== null && typeof j.render == "function" && j.$$typeof === void 0
      ) {
        {
          var rt = ci(p) || "Unknown";
          KS[rt] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", rt, rt, rt), KS[rt] = !0);
        }
        s.tag = h, s.memoizedState = null, s.updateQueue = null;
        var it = !1;
        return BI(p) ? (it = !0, h0(s)) : it = !1, s.memoizedState = j.state !== null && j.state !== void 0 ? j.state : null, oy(s), _S(s, j), _V(s, p, Z, y), QV(null, s, p, !0, it, y);
      } else {
        if (s.tag = f, s.mode & Or) {
          ra(!0);
          try {
            j = om(null, s, p, Z, X, y), ne = BA();
          } finally {
            ra(!1);
          }
        }
        return go() && ne && $B(s), Vg(null, s, j, y), jV(s, p), s.child;
      }
    }
    function jV(r, s) {
      {
        if (s && s.childContextTypes && u("%s(...): childContextTypes cannot be defined on a function component.", s.displayName || s.name || "Component"), r.ref !== null) {
          var p = "", y = zo();
          y && (p += `

Check the render method of \`` + y + "`.");
          var Z = y || "", X = r._debugSource;
          X && (Z = X.fileName + ":" + X.lineNumber), OV[Z] || (OV[Z] = !0, u("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", p));
        }
        if (s.defaultProps !== void 0) {
          var K = ci(s) || "Unknown";
          LS[K] || (u("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", K), LS[K] = !0);
        }
        if (typeof s.getDerivedStateFromProps == "function") {
          var j = ci(s) || "Unknown";
          UV[j] || (u("%s: Function components do not support getDerivedStateFromProps.", j), UV[j] = !0);
        }
        if (typeof s.contextType == "object" && s.contextType !== null) {
          var ne = ci(s) || "Unknown";
          DV[ne] || (u("%s: Function components do not support contextType.", ne), DV[ne] = !0);
        }
      }
    }
    var qV = {
      dehydrated: null,
      treeContext: null,
      retryLane: Wr
    };
    function $V(r) {
      return {
        baseLanes: r,
        cachePool: nk(),
        transitions: null
      };
    }
    function Ik(r, s) {
      var p = null;
      return {
        baseLanes: fn(r.baseLanes, s),
        cachePool: p,
        transitions: r.transitions
      };
    }
    function Ck(r, s, p, y) {
      if (s !== null) {
        var Z = s.memoizedState;
        if (Z === null)
          return !1;
      }
      return mS(r, yA);
    }
    function hk(r, s) {
      return ji(r.childLanes, s);
    }
    function UY(r, s, p) {
      var y = s.pendingProps;
      BU(s) && (s.flags |= Qi);
      var Z = Co.current, X = !1, K = (s.flags & Qi) !== Hi;
      if (K || Ck(Z, r) ? (X = !0, s.flags &= ~Qi) : (r === null || r.memoizedState !== null) && (Z = HV(Z, ox)), Z = im(Z), Tf(s, Z), r === null) {
        aS(s);
        var j = s.memoizedState;
        if (j !== null) {
          var ne = j.dehydrated;
          if (ne !== null)
            return vk(s, ne);
        }
        var de = y.children, Ge = y.fallback;
        if (X) {
          var rt = fk(s, de, Ge, p), it = s.child;
          return it.memoizedState = $V(p), s.memoizedState = qV, rt;
        } else
          return eN(s, de);
      } else {
        var Vt = r.memoizedState;
        if (Vt !== null) {
          var Xt = Vt.dehydrated;
          if (Xt !== null)
            return yk(r, s, K, y, Xt, Vt, p);
        }
        if (X) {
          var Jt = y.fallback, ri = y.children, Li = mk(r, s, ri, Jt, p), Ni = s.child, sa = r.child.memoizedState;
          return Ni.memoizedState = sa === null ? $V(p) : Ik(sa, p), Ni.childLanes = hk(r, p), s.memoizedState = qV, Li;
        } else {
          var Jr = y.children, At = pk(r, s, Jr, p);
          return s.memoizedState = null, At;
        }
      }
    }
    function eN(r, s, p) {
      var y = r.mode, Z = {
        mode: "visible",
        children: s
      }, X = tN(Z, y);
      return X.return = r, r.child = X, X;
    }
    function fk(r, s, p, y) {
      var Z = r.mode, X = r.child, K = {
        mode: "hidden",
        children: s
      }, j, ne;
      return (Z & Zi) === Kn && X !== null ? (j = X, j.childLanes = dn, j.pendingProps = K, r.mode & vi && (j.actualDuration = 0, j.actualStartTime = -1, j.selfBaseDuration = 0, j.treeBaseDuration = 0), ne = NA(p, Z, y, null)) : (j = tN(K, Z), ne = NA(p, Z, y, null)), j.return = r, ne.return = r, j.sibling = ne, r.child = j, ne;
    }
    function tN(r, s, p) {
      return OF(r, s, dn, null);
    }
    function OY(r, s) {
      return Ny(r, s);
    }
    function pk(r, s, p, y) {
      var Z = r.child, X = Z.sibling, K = OY(Z, {
        mode: "visible",
        children: p
      });
      if ((s.mode & Zi) === Kn && (K.lanes = y), K.return = s, K.sibling = null, X !== null) {
        var j = s.deletions;
        j === null ? (s.deletions = [X], s.flags |= Gr) : j.push(X);
      }
      return s.child = K, K;
    }
    function mk(r, s, p, y, Z) {
      var X = s.mode, K = r.child, j = K.sibling, ne = {
        mode: "hidden",
        children: p
      }, de;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (X & Zi) === Kn && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        s.child !== K
      ) {
        var Ge = s.child;
        de = Ge, de.childLanes = dn, de.pendingProps = ne, s.mode & vi && (de.actualDuration = 0, de.actualStartTime = -1, de.selfBaseDuration = K.selfBaseDuration, de.treeBaseDuration = K.treeBaseDuration), s.deletions = null;
      } else
        de = OY(K, ne), de.subtreeFlags = K.subtreeFlags & Do;
      var rt;
      return j !== null ? rt = Ny(j, y) : (rt = NA(y, X, Z, null), rt.flags |= ar), rt.return = s, de.return = s, de.sibling = rt, s.child = de, rt;
    }
    function Ax(r, s, p, y) {
      y !== null && xI(y), WI(s, r.child, null, p);
      var Z = s.pendingProps, X = Z.children, K = eN(s, X);
      return K.flags |= ar, s.memoizedState = null, K;
    }
    function Ak(r, s, p, y, Z) {
      var X = s.mode, K = {
        mode: "visible",
        children: p
      }, j = tN(K, X), ne = NA(y, X, Z, null);
      return ne.flags |= ar, j.return = s, ne.return = s, j.sibling = ne, s.child = j, (s.mode & Zi) !== Kn && WI(s, r.child, null, Z), ne;
    }
    function vk(r, s, p) {
      return (r.mode & Zi) === Kn ? (u("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), r.lanes = yi) : kB(s) ? r.lanes = $a : r.lanes = Vl, null;
    }
    function yk(r, s, p, y, Z, X, K) {
      if (p)
        if (s.flags & As) {
          s.flags &= ~As;
          var At = zV(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Ax(r, s, K, At);
        } else {
          if (s.memoizedState !== null)
            return s.child = r.child, s.flags |= Qi, null;
          var Qt = y.children, vt = y.fallback, Zn = Ak(r, s, Qt, vt, K), Ii = s.child;
          return Ii.memoizedState = $V(K), s.memoizedState = qV, Zn;
        }
      else {
        if (eS(), (s.mode & Zi) === Kn)
          return Ax(
            r,
            s,
            K,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (kB(Z)) {
          var j, ne, de;
          {
            var Ge = xR(Z);
            j = Ge.digest, ne = Ge.message, de = Ge.stack;
          }
          var rt;
          ne ? rt = new Error(ne) : rt = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var it = zV(rt, j, de);
          return Ax(r, s, K, it);
        }
        var Vt = Zt(K, r.childLanes);
        if (Zh || Vt) {
          var Xt = Wx();
          if (Xt !== null) {
            var Jt = af(Xt, K);
            if (Jt !== Wr && Jt !== X.retryLane) {
              X.retryLane = Jt;
              var ri = Br;
              Ws(r, Jt), su(Xt, r, Jt, ri);
            }
          }
          bN();
          var Li = zV(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Ax(r, s, K, Li);
        } else if (LB(Z)) {
          s.flags |= Qi, s.child = r.child;
          var Ni = UD.bind(null, r);
          return hV(Z, Ni), null;
        } else {
          wV(s, Z, X.treeContext);
          var sa = y.children, Jr = eN(s, sa);
          return Jr.flags |= Dl, Jr;
        }
      }
    }
    function PY(r, s, p) {
      r.lanes = fn(r.lanes, s);
      var y = r.alternate;
      y !== null && (y.lanes = fn(y.lanes, s)), cS(r.return, s, p);
    }
    function bk(r, s, p) {
      for (var y = s; y !== null; ) {
        if (y.tag === U) {
          var Z = y.memoizedState;
          Z !== null && PY(y, p, r);
        } else if (y.tag === fe)
          PY(y, p, r);
        else if (y.child !== null) {
          y.child.return = y, y = y.child;
          continue;
        }
        if (y === r)
          return;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === r)
            return;
          y = y.return;
        }
        y.sibling.return = y.return, y = y.sibling;
      }
    }
    function Gk(r) {
      for (var s = r, p = null; s !== null; ) {
        var y = s.alternate;
        y !== null && Iy(y) === null && (p = s), s = s.sibling;
      }
      return p;
    }
    function Bk(r) {
      if (r !== void 0 && r !== "forwards" && r !== "backwards" && r !== "together" && !PV[r])
        if (PV[r] = !0, typeof r == "string")
          switch (r.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', r, r.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', r, r.toLowerCase());
              break;
            }
            default:
              u('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', r);
              break;
          }
        else
          u('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', r);
    }
    function Sk(r, s) {
      r !== void 0 && !mx[r] && (r !== "collapsed" && r !== "hidden" ? (mx[r] = !0, u('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', r)) : s !== "forwards" && s !== "backwards" && (mx[r] = !0, u('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', r)));
    }
    function JY(r, s) {
      {
        var p = Fr(r), y = !p && typeof _n(r) == "function";
        if (p || y) {
          var Z = p ? "array" : "iterable";
          return u("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", Z, s, Z), !1;
        }
      }
      return !0;
    }
    function Zk(r, s) {
      if ((s === "forwards" || s === "backwards") && r !== void 0 && r !== null && r !== !1)
        if (Fr(r)) {
          for (var p = 0; p < r.length; p++)
            if (!JY(r[p], p))
              return;
        } else {
          var y = _n(r);
          if (typeof y == "function") {
            var Z = y.call(r);
            if (Z)
              for (var X = Z.next(), K = 0; !X.done; X = Z.next()) {
                if (!JY(X.value, K))
                  return;
                K++;
              }
          } else
            u('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', s);
        }
    }
    function nN(r, s, p, y, Z) {
      var X = r.memoizedState;
      X === null ? r.memoizedState = {
        isBackwards: s,
        rendering: null,
        renderingStartTime: 0,
        last: y,
        tail: p,
        tailMode: Z
      } : (X.isBackwards = s, X.rendering = null, X.renderingStartTime = 0, X.last = y, X.tail = p, X.tailMode = Z);
    }
    function QY(r, s, p) {
      var y = s.pendingProps, Z = y.revealOrder, X = y.tail, K = y.children;
      Bk(Z), Sk(X, Z), Zk(K, Z), Vg(r, s, K, p);
      var j = Co.current, ne = mS(j, yA);
      if (ne)
        j = AS(j, yA), s.flags |= Qi;
      else {
        var de = r !== null && (r.flags & Qi) !== Hi;
        de && bk(s, s.child, p), j = im(j);
      }
      if (Tf(s, j), (s.mode & Zi) === Kn)
        s.memoizedState = null;
      else
        switch (Z) {
          case "forwards": {
            var Ge = Gk(s.child), rt;
            Ge === null ? (rt = s.child, s.child = null) : (rt = Ge.sibling, Ge.sibling = null), nN(
              s,
              !1,
              // isBackwards
              rt,
              Ge,
              X
            );
            break;
          }
          case "backwards": {
            var it = null, Vt = s.child;
            for (s.child = null; Vt !== null; ) {
              var Xt = Vt.alternate;
              if (Xt !== null && Iy(Xt) === null) {
                s.child = Vt;
                break;
              }
              var Jt = Vt.sibling;
              Vt.sibling = it, it = Vt, Vt = Jt;
            }
            nN(
              s,
              !0,
              // isBackwards
              it,
              null,
              // last
              X
            );
            break;
          }
          case "together": {
            nN(
              s,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            s.memoizedState = null;
        }
      return s.child;
    }
    function wk(r, s, p) {
      fS(s, s.stateNode.containerInfo);
      var y = s.pendingProps;
      return r === null ? s.child = WI(s, null, y, p) : Vg(r, s, y, p), s.child;
    }
    var jY = !1;
    function Rk(r, s, p) {
      var y = s.type, Z = y._context, X = s.pendingProps, K = s.memoizedProps, j = X.value;
      {
        "value" in X || jY || (jY = !0, u("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var ne = s.type.propTypes;
        ne && bI(ne, X, "prop", "Context.Provider");
      }
      if (Yu(s, Z, j), K !== null) {
        var de = K.value;
        if (Ri(de, j)) {
          if (K.children === X.children && !CA())
            return cm(r, s, p);
        } else
          pl(s, Z, p);
      }
      var Ge = X.children;
      return Vg(r, s, Ge, p), s.child;
    }
    var qY = !1;
    function xk(r, s, p) {
      var y = s.type;
      y._context === void 0 ? y !== y.Consumer && (qY || (qY = !0, u("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : y = y._context;
      var Z = s.pendingProps, X = Z.children;
      typeof X != "function" && u("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Gh(s, p);
      var K = xs(y);
      qr(s);
      var j;
      return zS.current = s, ua(!0), j = X(K), ua(!1), ha(), s.flags |= Pi, Vg(r, s, j, p), s.child;
    }
    function kS() {
      Zh = !0;
    }
    function vx(r, s) {
      (s.mode & Zi) === Kn && r !== null && (r.alternate = null, s.alternate = null, s.flags |= ar);
    }
    function cm(r, s, p) {
      return r !== null && (s.dependencies = r.dependencies), Rt(), nZ(s.lanes), Zt(p, s.childLanes) ? (bh(r, s), s.child) : null;
    }
    function Wk(r, s, p) {
      {
        var y = s.return;
        if (y === null)
          throw new Error("Cannot swap the root fiber.");
        if (r.alternate = null, s.alternate = null, p.index = s.index, p.sibling = s.sibling, p.return = s.return, p.ref = s.ref, s === y.child)
          y.child = p;
        else {
          var Z = y.child;
          if (Z === null)
            throw new Error("Expected parent to have a child.");
          for (; Z.sibling !== s; )
            if (Z = Z.sibling, Z === null)
              throw new Error("Expected to find the previous sibling.");
          Z.sibling = p;
        }
        var X = y.deletions;
        return X === null ? (y.deletions = [r], y.flags |= Gr) : X.push(r), p.flags |= ar, p;
      }
    }
    function iN(r, s) {
      var p = r.lanes;
      return !!Zt(p, s);
    }
    function Vk(r, s, p) {
      switch (s.tag) {
        case b:
          kY(s), s.stateNode, Wf();
          break;
        case R:
          rx(s);
          break;
        case h: {
          var y = s.type;
          BI(y) && h0(s);
          break;
        }
        case S:
          fS(s, s.stateNode.containerInfo);
          break;
        case E: {
          var Z = s.memoizedProps.value, X = s.type._context;
          Yu(s, X, Z);
          break;
        }
        case P:
          {
            var K = Zt(p, s.childLanes);
            K && (s.flags |= Ci);
            {
              var j = s.stateNode;
              j.effectDuration = 0, j.passiveEffectDuration = 0;
            }
          }
          break;
        case U: {
          var ne = s.memoizedState;
          if (ne !== null) {
            if (ne.dehydrated !== null)
              return Tf(s, im(Co.current)), s.flags |= Qi, null;
            var de = s.child, Ge = de.childLanes;
            if (Zt(p, Ge))
              return UY(r, s, p);
            Tf(s, im(Co.current));
            var rt = cm(r, s, p);
            return rt !== null ? rt.sibling : null;
          } else
            Tf(s, im(Co.current));
          break;
        }
        case fe: {
          var it = (r.flags & Qi) !== Hi, Vt = Zt(p, s.childLanes);
          if (it) {
            if (Vt)
              return QY(r, s, p);
            s.flags |= Qi;
          }
          var Xt = s.memoizedState;
          if (Xt !== null && (Xt.rendering = null, Xt.tail = null, Xt.lastEffect = null), Tf(s, Co.current), Vt)
            break;
          return null;
        }
        case Ae:
        case Te:
          return s.lanes = dn, zY(r, s, p);
      }
      return cm(r, s, p);
    }
    function $Y(r, s, p) {
      if (s._debugNeedsRemount && r !== null)
        return Wk(r, s, MN(s.type, s.key, s.pendingProps, s._debugOwner || null, s.mode, s.lanes));
      if (r !== null) {
        var y = r.memoizedProps, Z = s.pendingProps;
        if (y !== Z || CA() || // Force a re-render if the implementation changed due to hot reload:
        s.type !== r.type)
          Zh = !0;
        else {
          var X = iN(r, p);
          if (!X && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (s.flags & Qi) === Hi)
            return Zh = !1, Vk(r, s, p);
          (r.flags & tI) !== Hi ? Zh = !0 : Zh = !1;
        }
      } else if (Zh = !1, go() && UR(s)) {
        var K = s.index, j = Bd();
        OR(s, j, K);
      }
      switch (s.lanes = dn, s.tag) {
        case v:
          return dk(r, s, s.type, p);
        case O: {
          var ne = s.elementType;
          return ck(r, s, ne, p);
        }
        case f: {
          var de = s.type, Ge = s.pendingProps, rt = s.elementType === de ? Ge : Zr(de, Ge);
          return JV(r, s, de, rt, p);
        }
        case h: {
          var it = s.type, Vt = s.pendingProps, Xt = s.elementType === it ? Vt : Zr(it, Vt);
          return LY(r, s, it, Xt, p);
        }
        case b:
          return sk(r, s, p);
        case R:
          return lk(r, s, p);
        case W:
          return uk(r, s);
        case U:
          return UY(r, s, p);
        case S:
          return wk(r, s, p);
        case _: {
          var Jt = s.type, ri = s.pendingProps, Li = s.elementType === Jt ? ri : Zr(Jt, ri);
          return EY(r, s, Jt, Li, p);
        }
        case x:
          return rk(r, s, p);
        case M:
          return ak(r, s, p);
        case P:
          return ok(r, s, p);
        case E:
          return Rk(r, s, p);
        case T:
          return xk(r, s, p);
        case q: {
          var Ni = s.type, sa = s.pendingProps, Jr = Zr(Ni, sa);
          if (s.type !== s.elementType) {
            var At = Ni.propTypes;
            At && bI(
              At,
              Jr,
              // Resolved for outer only
              "prop",
              ci(Ni)
            );
          }
          return Jr = Zr(Ni.type, Jr), TY(r, s, Ni, Jr, p);
        }
        case k:
          return _Y(r, s, s.type, s.pendingProps, p);
        case J: {
          var Qt = s.type, vt = s.pendingProps, Zn = s.elementType === Qt ? vt : Zr(Qt, vt);
          return gk(r, s, Qt, Zn, p);
        }
        case fe:
          return QY(r, s, p);
        case pe:
          break;
        case Ae:
          return zY(r, s, p);
      }
      throw new Error("Unknown unit of work tag (" + s.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function q0(r) {
      r.flags |= Ci;
    }
    function eF(r) {
      r.flags |= Zl, r.flags |= Us;
    }
    var tF, rN, nF, iF;
    tF = function(r, s, p, y) {
      for (var Z = s.child; Z !== null; ) {
        if (Z.tag === R || Z.tag === W)
          nV(r, Z.stateNode);
        else if (Z.tag !== S) {
          if (Z.child !== null) {
            Z.child.return = Z, Z = Z.child;
            continue;
          }
        }
        if (Z === s)
          return;
        for (; Z.sibling === null; ) {
          if (Z.return === null || Z.return === s)
            return;
          Z = Z.return;
        }
        Z.sibling.return = Z.return, Z = Z.sibling;
      }
    }, rN = function(r, s) {
    }, nF = function(r, s, p, y, Z) {
      var X = r.memoizedProps;
      if (X !== y) {
        var K = s.stateNode, j = pS(), ne = iV(K, p, X, y, Z, j);
        s.updateQueue = ne, ne && q0(s);
      }
    }, iF = function(r, s, p, y) {
      p !== y && q0(s);
    };
    function DS(r, s) {
      if (!go())
        switch (r.tailMode) {
          case "hidden": {
            for (var p = r.tail, y = null; p !== null; )
              p.alternate !== null && (y = p), p = p.sibling;
            y === null ? r.tail = null : y.sibling = null;
            break;
          }
          case "collapsed": {
            for (var Z = r.tail, X = null; Z !== null; )
              Z.alternate !== null && (X = Z), Z = Z.sibling;
            X === null ? !s && r.tail !== null ? r.tail.sibling = null : r.tail = null : X.sibling = null;
            break;
          }
        }
    }
    function fc(r) {
      var s = r.alternate !== null && r.alternate.child === r.child, p = dn, y = Hi;
      if (s) {
        if ((r.mode & vi) !== Kn) {
          for (var ne = r.selfBaseDuration, de = r.child; de !== null; )
            p = fn(p, fn(de.lanes, de.childLanes)), y |= de.subtreeFlags & Do, y |= de.flags & Do, ne += de.treeBaseDuration, de = de.sibling;
          r.treeBaseDuration = ne;
        } else
          for (var Ge = r.child; Ge !== null; )
            p = fn(p, fn(Ge.lanes, Ge.childLanes)), y |= Ge.subtreeFlags & Do, y |= Ge.flags & Do, Ge.return = r, Ge = Ge.sibling;
        r.subtreeFlags |= y;
      } else {
        if ((r.mode & vi) !== Kn) {
          for (var Z = r.actualDuration, X = r.selfBaseDuration, K = r.child; K !== null; )
            p = fn(p, fn(K.lanes, K.childLanes)), y |= K.subtreeFlags, y |= K.flags, Z += K.actualDuration, X += K.treeBaseDuration, K = K.sibling;
          r.actualDuration = Z, r.treeBaseDuration = X;
        } else
          for (var j = r.child; j !== null; )
            p = fn(p, fn(j.lanes, j.childLanes)), y |= j.subtreeFlags, y |= j.flags, j.return = r, j = j.sibling;
        r.subtreeFlags |= y;
      }
      return r.childLanes = p, s;
    }
    function Nk(r, s, p) {
      if (RI() && (s.mode & Zi) !== Kn && (s.flags & Qi) === Hi)
        return Rs(s), Wf(), s.flags |= As | Wc | ss, !1;
      var y = Go(s);
      if (p !== null && p.dehydrated !== null)
        if (r === null) {
          if (!y)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (xV(s), fc(s), (s.mode & vi) !== Kn) {
            var Z = p !== null;
            if (Z) {
              var X = s.child;
              X !== null && (s.treeBaseDuration -= X.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Wf(), (s.flags & Qi) === Hi && (s.memoizedState = null), s.flags |= Ci, fc(s), (s.mode & vi) !== Kn) {
            var K = p !== null;
            if (K) {
              var j = s.child;
              j !== null && (s.treeBaseDuration -= j.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return tu(), !0;
    }
    function rF(r, s, p) {
      var y = s.pendingProps;
      switch (mA(s), s.tag) {
        case v:
        case O:
        case k:
        case f:
        case _:
        case x:
        case M:
        case P:
        case T:
        case q:
          return fc(s), null;
        case h: {
          var Z = s.type;
          return BI(Z) && C0(s), fc(s), null;
        }
        case b: {
          var X = s.stateNode;
          if (gc(s), hA(s), Cy(), X.pendingContext && (X.context = X.pendingContext, X.pendingContext = null), r === null || r.child === null) {
            var K = Go(s);
            if (K)
              q0(s);
            else if (r !== null) {
              var j = r.memoizedState;
              // Check if this is a client root
              (!j.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (s.flags & As) !== Hi) && (s.flags |= Qa, tu());
            }
          }
          return rN(r, s), fc(s), null;
        }
        case R: {
          M0(s);
          var ne = Ef(), de = s.type;
          if (r !== null && s.stateNode != null)
            nF(r, s, de, y, ne), r.ref !== s.ref && eF(s);
          else {
            if (!y) {
              if (s.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return fc(s), null;
            }
            var Ge = pS(), rt = Go(s);
            if (rt)
              RV(s, ne, Ge) && q0(s);
            else {
              var it = AR(de, y, ne, Ge, s);
              tF(it, s, !1, !1), s.stateNode = it, vR(it, de, y, ne) && q0(s);
            }
            s.ref !== null && eF(s);
          }
          return fc(s), null;
        }
        case W: {
          var Vt = y;
          if (r && s.stateNode != null) {
            var Xt = r.memoizedProps;
            iF(r, s, Xt, Vt);
          } else {
            if (typeof Vt != "string" && s.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Jt = Ef(), ri = pS(), Li = Go(s);
            Li ? jR(s) && q0(s) : s.stateNode = rV(Vt, Jt, ri, s);
          }
          return fc(s), null;
        }
        case U: {
          bA(s);
          var Ni = s.memoizedState;
          if (r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
            var sa = Nk(r, s, Ni);
            if (!sa)
              return s.flags & ss ? s : null;
          }
          if ((s.flags & Qi) !== Hi)
            return s.lanes = p, (s.mode & vi) !== Kn && Er(s), s;
          var Jr = Ni !== null, At = r !== null && r.memoizedState !== null;
          if (Jr !== At && Jr) {
            var Qt = s.child;
            if (Qt.flags |= yu, (s.mode & Zi) !== Kn) {
              var vt = r === null && (s.memoizedProps.unstable_avoidThisFallback !== !0 || !Ye);
              vt || mS(Co.current, ox) ? MD() : bN();
            }
          }
          var Zn = s.updateQueue;
          if (Zn !== null && (s.flags |= Ci), fc(s), (s.mode & vi) !== Kn && Jr) {
            var Ii = s.child;
            Ii !== null && (s.treeBaseDuration -= Ii.treeBaseDuration);
          }
          return null;
        }
        case S:
          return gc(s), rN(r, s), r === null && gA(s.stateNode.containerInfo), fc(s), null;
        case E:
          var li = s.type._context;
          return ZC(li, s), fc(s), null;
        case J: {
          var ir = s.type;
          return BI(ir) && C0(s), fc(s), null;
        }
        case fe: {
          bA(s);
          var gr = s.memoizedState;
          if (gr === null)
            return fc(s), null;
          var io = (s.flags & Qi) !== Hi, ba = gr.rendering;
          if (ba === null)
            if (io)
              DS(gr, !1);
            else {
              var vl = XD() && (r === null || (r.flags & Qi) === Hi);
              if (!vl)
                for (var Ga = s.child; Ga !== null; ) {
                  var qs = Iy(Ga);
                  if (qs !== null) {
                    io = !0, s.flags |= Qi, DS(gr, !1);
                    var Pc = qs.updateQueue;
                    return Pc !== null && (s.updateQueue = Pc, s.flags |= Ci), s.subtreeFlags = Hi, ny(s, p), Tf(s, AS(Co.current, yA)), s.child;
                  }
                  Ga = Ga.sibling;
                }
              gr.tail !== null && co() > SF() && (s.flags |= Qi, io = !0, DS(gr, !1), s.lanes = rc);
            }
          else {
            if (!io) {
              var yc = Iy(ba);
              if (yc !== null) {
                s.flags |= Qi, io = !0;
                var MI = yc.updateQueue;
                if (MI !== null && (s.updateQueue = MI, s.flags |= Ci), DS(gr, !0), gr.tail === null && gr.tailMode === "hidden" && !ba.alternate && !go())
                  return fc(s), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              co() * 2 - gr.renderingStartTime > SF() && p !== Vl && (s.flags |= Qi, io = !0, DS(gr, !1), s.lanes = rc);
            }
            if (gr.isBackwards)
              ba.sibling = s.child, s.child = ba;
            else {
              var Hg = gr.last;
              Hg !== null ? Hg.sibling = ba : s.child = ba, gr.last = ba;
            }
          }
          if (gr.tail !== null) {
            var Xg = gr.tail;
            gr.rendering = Xg, gr.tail = Xg.sibling, gr.renderingStartTime = co(), Xg.sibling = null;
            var Jc = Co.current;
            return io ? Jc = AS(Jc, yA) : Jc = im(Jc), Tf(s, Jc), Xg;
          }
          return fc(s), null;
        }
        case pe:
          break;
        case Ae:
        case Te: {
          yN(s);
          var hm = s.memoizedState, oG = hm !== null;
          if (r !== null) {
            var sZ = r.memoizedState, Pf = sZ !== null;
            Pf !== oG && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !le && (s.flags |= yu);
          }
          return !oG || (s.mode & Zi) === Kn ? fc(s) : Zt(Of, Vl) && (fc(s), s.subtreeFlags & (ar | Ci) && (s.flags |= yu)), null;
        }
        case Ke:
          return null;
        case je:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + s.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Mk(r, s, p) {
      switch (mA(s), s.tag) {
        case h: {
          var y = s.type;
          BI(y) && C0(s);
          var Z = s.flags;
          return Z & ss ? (s.flags = Z & ~ss | Qi, (s.mode & vi) !== Kn && Er(s), s) : null;
        }
        case b: {
          s.stateNode, gc(s), hA(s), Cy();
          var X = s.flags;
          return (X & ss) !== Hi && (X & Qi) === Hi ? (s.flags = X & ~ss | Qi, s) : null;
        }
        case R:
          return M0(s), null;
        case U: {
          bA(s);
          var K = s.memoizedState;
          if (K !== null && K.dehydrated !== null) {
            if (s.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Wf();
          }
          var j = s.flags;
          return j & ss ? (s.flags = j & ~ss | Qi, (s.mode & vi) !== Kn && Er(s), s) : null;
        }
        case fe:
          return bA(s), null;
        case S:
          return gc(s), null;
        case E:
          var ne = s.type._context;
          return ZC(ne, s), null;
        case Ae:
        case Te:
          return yN(s), null;
        case Ke:
          return null;
        default:
          return null;
      }
    }
    function aF(r, s, p) {
      switch (mA(s), s.tag) {
        case h: {
          var y = s.type.childContextTypes;
          y != null && C0(s);
          break;
        }
        case b: {
          s.stateNode, gc(s), hA(s), Cy();
          break;
        }
        case R: {
          M0(s);
          break;
        }
        case S:
          gc(s);
          break;
        case U:
          bA(s);
          break;
        case fe:
          bA(s);
          break;
        case E:
          var Z = s.type._context;
          ZC(Z, s);
          break;
        case Ae:
        case Te:
          yN(s);
          break;
      }
    }
    var oF = null;
    oF = /* @__PURE__ */ new Set();
    var yx = !1, pc = !1, Hk = typeof WeakSet == "function" ? WeakSet : Set, Gi = null, $0 = null, eG = null;
    function Xk(r) {
      ms(null, function() {
        throw r;
      }), Ju();
    }
    var Yk = function(r, s) {
      if (s.props = r.memoizedProps, s.state = r.memoizedState, r.mode & vi)
        try {
          di(), s.componentWillUnmount();
        } finally {
          Ct(r);
        }
      else
        s.componentWillUnmount();
    };
    function sF(r, s) {
      try {
        wA(Vs, r);
      } catch (p) {
        To(r, s, p);
      }
    }
    function aN(r, s, p) {
      try {
        Yk(r, p);
      } catch (y) {
        To(r, s, y);
      }
    }
    function Fk(r, s, p) {
      try {
        p.componentDidMount();
      } catch (y) {
        To(r, s, y);
      }
    }
    function lF(r, s) {
      try {
        cF(r);
      } catch (p) {
        To(r, s, p);
      }
    }
    function tG(r, s) {
      var p = r.ref;
      if (p !== null)
        if (typeof p == "function") {
          var y;
          try {
            if (St && ln && r.mode & vi)
              try {
                di(), y = p(null);
              } finally {
                Ct(r);
              }
            else
              y = p(null);
          } catch (Z) {
            To(r, s, Z);
          }
          typeof y == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", gi(r));
        } else
          p.current = null;
    }
    function bx(r, s, p) {
      try {
        p();
      } catch (y) {
        To(r, s, y);
      }
    }
    var uF = !1;
    function Ek(r, s) {
      mR(r.containerInfo), Gi = s, Tk();
      var p = uF;
      return uF = !1, p;
    }
    function Tk() {
      for (; Gi !== null; ) {
        var r = Gi, s = r.child;
        (r.subtreeFlags & Wi) !== Hi && s !== null ? (s.return = r, Gi = s) : _k();
      }
    }
    function _k() {
      for (; Gi !== null; ) {
        var r = Gi;
        ia(r);
        try {
          zk(r);
        } catch (p) {
          To(r, r.return, p);
        }
        Xr();
        var s = r.sibling;
        if (s !== null) {
          s.return = r.return, Gi = s;
          return;
        }
        Gi = r.return;
      }
    }
    function zk(r) {
      var s = r.alternate, p = r.flags;
      if ((p & Qa) !== Hi) {
        switch (ia(r), r.tag) {
          case f:
          case _:
          case k:
            break;
          case h: {
            if (s !== null) {
              var y = s.memoizedProps, Z = s.memoizedState, X = r.stateNode;
              r.type === r.elementType && !wy && (X.props !== r.memoizedProps && u("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gi(r) || "instance"), X.state !== r.memoizedState && u("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gi(r) || "instance"));
              var K = X.getSnapshotBeforeUpdate(r.elementType === r.type ? y : Zr(r.type, y), Z);
              {
                var j = oF;
                K === void 0 && !j.has(r.type) && (j.add(r.type), u("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", gi(r)));
              }
              X.__reactInternalSnapshotBeforeUpdate = K;
            }
            break;
          }
          case b: {
            {
              var ne = r.stateNode;
              IV(ne.containerInfo);
            }
            break;
          }
          case R:
          case W:
          case S:
          case J:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Xr();
      }
    }
    function wh(r, s, p) {
      var y = s.updateQueue, Z = y !== null ? y.lastEffect : null;
      if (Z !== null) {
        var X = Z.next, K = X;
        do {
          if ((K.tag & r) === r) {
            var j = K.destroy;
            K.destroy = void 0, j !== void 0 && ((r & iu) !== nu ? mo(s) : (r & Vs) !== nu && Jl(s), (r & VI) !== nu && rZ(!0), bx(s, p, j), (r & VI) !== nu && rZ(!1), (r & iu) !== nu ? nC() : (r & Vs) !== nu && Mc());
          }
          K = K.next;
        } while (K !== X);
      }
    }
    function wA(r, s) {
      var p = s.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var Z = y.next, X = Z;
        do {
          if ((X.tag & r) === r) {
            (r & iu) !== nu ? Ur(s) : (r & Vs) !== nu && $u(s);
            var K = X.create;
            (r & VI) !== nu && rZ(!0), X.destroy = K(), (r & VI) !== nu && rZ(!1), (r & iu) !== nu ? rI() : (r & Vs) !== nu && bs();
            {
              var j = X.destroy;
              if (j !== void 0 && typeof j != "function") {
                var ne = void 0;
                (X.tag & Vs) !== Hi ? ne = "useLayoutEffect" : (X.tag & VI) !== Hi ? ne = "useInsertionEffect" : ne = "useEffect";
                var de = void 0;
                j === null ? de = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof j.then == "function" ? de = `

It looks like you wrote ` + ne + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + ne + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : de = " You returned: " + j, u("%s must not return anything besides a function, which is used for clean-up.%s", ne, de);
              }
            }
          }
          X = X.next;
        } while (X !== Z);
      }
    }
    function Kk(r, s) {
      if ((s.flags & Ci) !== Hi)
        switch (s.tag) {
          case P: {
            var p = s.stateNode.passiveEffectDuration, y = s.memoizedProps, Z = y.id, X = y.onPostCommit, K = Ui(), j = s.alternate === null ? "mount" : "update";
            yn() && (j = "nested-update"), typeof X == "function" && X(Z, j, p, K);
            var ne = s.return;
            e: for (; ne !== null; ) {
              switch (ne.tag) {
                case b:
                  var de = ne.stateNode;
                  de.passiveEffectDuration += p;
                  break e;
                case P:
                  var Ge = ne.stateNode;
                  Ge.passiveEffectDuration += p;
                  break e;
              }
              ne = ne.return;
            }
            break;
          }
        }
    }
    function Lk(r, s, p, y) {
      if ((p.flags & Gu) !== Hi)
        switch (p.tag) {
          case f:
          case _:
          case k: {
            if (!pc)
              if (p.mode & vi)
                try {
                  di(), wA(Vs | Cs, p);
                } finally {
                  Ct(p);
                }
              else
                wA(Vs | Cs, p);
            break;
          }
          case h: {
            var Z = p.stateNode;
            if (p.flags & Ci && !pc)
              if (s === null)
                if (p.type === p.elementType && !wy && (Z.props !== p.memoizedProps && u("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gi(p) || "instance"), Z.state !== p.memoizedState && u("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gi(p) || "instance")), p.mode & vi)
                  try {
                    di(), Z.componentDidMount();
                  } finally {
                    Ct(p);
                  }
                else
                  Z.componentDidMount();
              else {
                var X = p.elementType === p.type ? s.memoizedProps : Zr(p.type, s.memoizedProps), K = s.memoizedState;
                if (p.type === p.elementType && !wy && (Z.props !== p.memoizedProps && u("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gi(p) || "instance"), Z.state !== p.memoizedState && u("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gi(p) || "instance")), p.mode & vi)
                  try {
                    di(), Z.componentDidUpdate(X, K, Z.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Ct(p);
                  }
                else
                  Z.componentDidUpdate(X, K, Z.__reactInternalSnapshotBeforeUpdate);
              }
            var j = p.updateQueue;
            j !== null && (p.type === p.elementType && !wy && (Z.props !== p.memoizedProps && u("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gi(p) || "instance"), Z.state !== p.memoizedState && u("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gi(p) || "instance")), ly(p, j, Z));
            break;
          }
          case b: {
            var ne = p.updateQueue;
            if (ne !== null) {
              var de = null;
              if (p.child !== null)
                switch (p.child.tag) {
                  case R:
                    de = p.child.stateNode;
                    break;
                  case h:
                    de = p.child.stateNode;
                    break;
                }
              ly(p, ne, de);
            }
            break;
          }
          case R: {
            var Ge = p.stateNode;
            if (s === null && p.flags & Ci) {
              var rt = p.type, it = p.memoizedProps;
              bR(Ge, rt, it);
            }
            break;
          }
          case W:
            break;
          case S:
            break;
          case P: {
            {
              var Vt = p.memoizedProps, Xt = Vt.onCommit, Jt = Vt.onRender, ri = p.stateNode.effectDuration, Li = Ui(), Ni = s === null ? "mount" : "update";
              yn() && (Ni = "nested-update"), typeof Jt == "function" && Jt(p.memoizedProps.id, Ni, p.actualDuration, p.treeBaseDuration, p.actualStartTime, Li);
              {
                typeof Xt == "function" && Xt(p.memoizedProps.id, Ni, ri, Li), _D(p);
                var sa = p.return;
                e: for (; sa !== null; ) {
                  switch (sa.tag) {
                    case b:
                      var Jr = sa.stateNode;
                      Jr.effectDuration += ri;
                      break e;
                    case P:
                      var At = sa.stateNode;
                      At.effectDuration += ri;
                      break e;
                  }
                  sa = sa.return;
                }
              }
            }
            break;
          }
          case U: {
            jk(r, p);
            break;
          }
          case fe:
          case J:
          case pe:
          case Ae:
          case Te:
          case je:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      pc || p.flags & Zl && cF(p);
    }
    function kk(r) {
      switch (r.tag) {
        case f:
        case _:
        case k: {
          if (r.mode & vi)
            try {
              di(), sF(r, r.return);
            } finally {
              Ct(r);
            }
          else
            sF(r, r.return);
          break;
        }
        case h: {
          var s = r.stateNode;
          typeof s.componentDidMount == "function" && Fk(r, r.return, s), lF(r, r.return);
          break;
        }
        case R: {
          lF(r, r.return);
          break;
        }
      }
    }
    function Dk(r, s) {
      for (var p = null, y = r; ; ) {
        if (y.tag === R) {
          if (p === null) {
            p = y;
            try {
              var Z = y.stateNode;
              s ? wR(Z) : gV(y.stateNode, y.memoizedProps);
            } catch (K) {
              To(r, r.return, K);
            }
          }
        } else if (y.tag === W) {
          if (p === null)
            try {
              var X = y.stateNode;
              s ? cV(X) : dV(X, y.memoizedProps);
            } catch (K) {
              To(r, r.return, K);
            }
        } else if (!((y.tag === Ae || y.tag === Te) && y.memoizedState !== null && y !== r)) {
          if (y.child !== null) {
            y.child.return = y, y = y.child;
            continue;
          }
        }
        if (y === r)
          return;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === r)
            return;
          p === y && (p = null), y = y.return;
        }
        p === y && (p = null), y.sibling.return = y.return, y = y.sibling;
      }
    }
    function cF(r) {
      var s = r.ref;
      if (s !== null) {
        var p = r.stateNode, y;
        switch (r.tag) {
          case R:
            y = p;
            break;
          default:
            y = p;
        }
        if (typeof s == "function") {
          var Z;
          if (r.mode & vi)
            try {
              di(), Z = s(y);
            } finally {
              Ct(r);
            }
          else
            Z = s(y);
          typeof Z == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", gi(r));
        } else
          s.hasOwnProperty("current") || u("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", gi(r)), s.current = y;
      }
    }
    function Uk(r) {
      var s = r.alternate;
      s !== null && (s.return = null), r.return = null;
    }
    function gF(r) {
      var s = r.alternate;
      s !== null && (r.alternate = null, gF(s));
      {
        if (r.child = null, r.deletions = null, r.sibling = null, r.tag === R) {
          var p = r.stateNode;
          p !== null && d0(p);
        }
        r.stateNode = null, r._debugOwner = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
      }
    }
    function Ok(r) {
      for (var s = r.return; s !== null; ) {
        if (dF(s))
          return s;
        s = s.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function dF(r) {
      return r.tag === R || r.tag === b || r.tag === S;
    }
    function IF(r) {
      var s = r;
      e: for (; ; ) {
        for (; s.sibling === null; ) {
          if (s.return === null || dF(s.return))
            return null;
          s = s.return;
        }
        for (s.sibling.return = s.return, s = s.sibling; s.tag !== R && s.tag !== W && s.tag !== te; ) {
          if (s.flags & ar || s.child === null || s.tag === S)
            continue e;
          s.child.return = s, s = s.child;
        }
        if (!(s.flags & ar))
          return s.stateNode;
      }
    }
    function Pk(r) {
      var s = Ok(r);
      switch (s.tag) {
        case R: {
          var p = s.stateNode;
          s.flags & Ds && (s0(p), s.flags &= ~Ds);
          var y = IF(r);
          sN(r, y, p);
          break;
        }
        case b:
        case S: {
          var Z = s.stateNode.containerInfo, X = IF(r);
          oN(r, X, Z);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function oN(r, s, p) {
      var y = r.tag, Z = y === R || y === W;
      if (Z) {
        var X = r.stateNode;
        s ? ZR(p, X, s) : BR(p, X);
      } else if (y !== S) {
        var K = r.child;
        if (K !== null) {
          oN(K, s, p);
          for (var j = K.sibling; j !== null; )
            oN(j, s, p), j = j.sibling;
        }
      }
    }
    function sN(r, s, p) {
      var y = r.tag, Z = y === R || y === W;
      if (Z) {
        var X = r.stateNode;
        s ? SR(p, X, s) : _B(p, X);
      } else if (y !== S) {
        var K = r.child;
        if (K !== null) {
          sN(K, s, p);
          for (var j = K.sibling; j !== null; )
            sN(j, s, p), j = j.sibling;
        }
      }
    }
    var mc = null, Rh = !1;
    function Jk(r, s, p) {
      {
        var y = s;
        e: for (; y !== null; ) {
          switch (y.tag) {
            case R: {
              mc = y.stateNode, Rh = !1;
              break e;
            }
            case b: {
              mc = y.stateNode.containerInfo, Rh = !0;
              break e;
            }
            case S: {
              mc = y.stateNode.containerInfo, Rh = !0;
              break e;
            }
          }
          y = y.return;
        }
        if (mc === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        CF(r, s, p), mc = null, Rh = !1;
      }
      Uk(p);
    }
    function RA(r, s, p) {
      for (var y = p.child; y !== null; )
        CF(r, s, y), y = y.sibling;
    }
    function CF(r, s, p) {
      switch (On(p), p.tag) {
        case R:
          pc || tG(p, s);
        case W: {
          {
            var y = mc, Z = Rh;
            mc = null, RA(r, s, p), mc = y, Rh = Z, mc !== null && (Rh ? lV(mc, p.stateNode) : l0(mc, p.stateNode));
          }
          return;
        }
        case te: {
          mc !== null && (Rh ? uV(mc, p.stateNode) : zB(mc, p.stateNode));
          return;
        }
        case S: {
          {
            var X = mc, K = Rh;
            mc = p.stateNode.containerInfo, Rh = !0, RA(r, s, p), mc = X, Rh = K;
          }
          return;
        }
        case f:
        case _:
        case q:
        case k: {
          if (!pc) {
            var j = p.updateQueue;
            if (j !== null) {
              var ne = j.lastEffect;
              if (ne !== null) {
                var de = ne.next, Ge = de;
                do {
                  var rt = Ge, it = rt.destroy, Vt = rt.tag;
                  it !== void 0 && ((Vt & VI) !== nu ? bx(p, s, it) : (Vt & Vs) !== nu && (Jl(p), p.mode & vi ? (di(), bx(p, s, it), Ct(p)) : bx(p, s, it), Mc())), Ge = Ge.next;
                } while (Ge !== de);
              }
            }
          }
          RA(r, s, p);
          return;
        }
        case h: {
          if (!pc) {
            tG(p, s);
            var Xt = p.stateNode;
            typeof Xt.componentWillUnmount == "function" && aN(p, s, Xt);
          }
          RA(r, s, p);
          return;
        }
        case pe: {
          RA(r, s, p);
          return;
        }
        case Ae: {
          if (
            // TODO: Remove this dead flag
            p.mode & Zi
          ) {
            var Jt = pc;
            pc = Jt || p.memoizedState !== null, RA(r, s, p), pc = Jt;
          } else
            RA(r, s, p);
          break;
        }
        default: {
          RA(r, s, p);
          return;
        }
      }
    }
    function Qk(r) {
      r.memoizedState;
    }
    function jk(r, s) {
      var p = s.memoizedState;
      if (p === null) {
        var y = s.alternate;
        if (y !== null) {
          var Z = y.memoizedState;
          if (Z !== null) {
            var X = Z.dehydrated;
            X !== null && NR(X);
          }
        }
      }
    }
    function hF(r) {
      var s = r.updateQueue;
      if (s !== null) {
        r.updateQueue = null;
        var p = r.stateNode;
        p === null && (p = r.stateNode = new Hk()), s.forEach(function(y) {
          var Z = OD.bind(null, r, y);
          if (!p.has(y)) {
            if (p.add(y), Os)
              if ($0 !== null && eG !== null)
                iZ(eG, $0);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            y.then(Z, Z);
          }
        });
      }
    }
    function qk(r, s, p) {
      $0 = p, eG = r, ia(s), fF(s, r), ia(s), $0 = null, eG = null;
    }
    function xh(r, s, p) {
      var y = s.deletions;
      if (y !== null)
        for (var Z = 0; Z < y.length; Z++) {
          var X = y[Z];
          try {
            Jk(r, s, X);
          } catch (ne) {
            To(X, s, ne);
          }
        }
      var K = kr();
      if (s.subtreeFlags & uo)
        for (var j = s.child; j !== null; )
          ia(j), fF(j, r), j = j.sibling;
      ia(K);
    }
    function fF(r, s, p) {
      var y = r.alternate, Z = r.flags;
      switch (r.tag) {
        case f:
        case _:
        case q:
        case k: {
          if (xh(s, r), Uf(r), Z & Ci) {
            try {
              wh(VI | Cs, r, r.return), wA(VI | Cs, r);
            } catch (ir) {
              To(r, r.return, ir);
            }
            if (r.mode & vi) {
              try {
                di(), wh(Vs | Cs, r, r.return);
              } catch (ir) {
                To(r, r.return, ir);
              }
              Ct(r);
            } else
              try {
                wh(Vs | Cs, r, r.return);
              } catch (ir) {
                To(r, r.return, ir);
              }
          }
          return;
        }
        case h: {
          xh(s, r), Uf(r), Z & Zl && y !== null && tG(y, y.return);
          return;
        }
        case R: {
          xh(s, r), Uf(r), Z & Zl && y !== null && tG(y, y.return);
          {
            if (r.flags & Ds) {
              var X = r.stateNode;
              try {
                s0(X);
              } catch (ir) {
                To(r, r.return, ir);
              }
            }
            if (Z & Ci) {
              var K = r.stateNode;
              if (K != null) {
                var j = r.memoizedProps, ne = y !== null ? y.memoizedProps : j, de = r.type, Ge = r.updateQueue;
                if (r.updateQueue = null, Ge !== null)
                  try {
                    GR(K, Ge, de, ne, j, r);
                  } catch (ir) {
                    To(r, r.return, ir);
                  }
              }
            }
          }
          return;
        }
        case W: {
          if (xh(s, r), Uf(r), Z & Ci) {
            if (r.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var rt = r.stateNode, it = r.memoizedProps, Vt = y !== null ? y.memoizedProps : it;
            try {
              sV(rt, Vt, it);
            } catch (ir) {
              To(r, r.return, ir);
            }
          }
          return;
        }
        case b: {
          if (xh(s, r), Uf(r), Z & Ci && y !== null) {
            var Xt = y.memoizedState;
            if (Xt.isDehydrated)
              try {
                VR(s.containerInfo);
              } catch (ir) {
                To(r, r.return, ir);
              }
          }
          return;
        }
        case S: {
          xh(s, r), Uf(r);
          return;
        }
        case U: {
          xh(s, r), Uf(r);
          var Jt = r.child;
          if (Jt.flags & yu) {
            var ri = Jt.stateNode, Li = Jt.memoizedState, Ni = Li !== null;
            if (ri.isHidden = Ni, Ni) {
              var sa = Jt.alternate !== null && Jt.alternate.memoizedState !== null;
              sa || ND();
            }
          }
          if (Z & Ci) {
            try {
              Qk(r);
            } catch (ir) {
              To(r, r.return, ir);
            }
            hF(r);
          }
          return;
        }
        case Ae: {
          var Jr = y !== null && y.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            r.mode & Zi
          ) {
            var At = pc;
            pc = At || Jr, xh(s, r), pc = At;
          } else
            xh(s, r);
          if (Uf(r), Z & yu) {
            var Qt = r.stateNode, vt = r.memoizedState, Zn = vt !== null, Ii = r;
            if (Qt.isHidden = Zn, Zn && !Jr && (Ii.mode & Zi) !== Kn) {
              Gi = Ii;
              for (var li = Ii.child; li !== null; )
                Gi = li, eD(li), li = li.sibling;
            }
            Dk(Ii, Zn);
          }
          return;
        }
        case fe: {
          xh(s, r), Uf(r), Z & Ci && hF(r);
          return;
        }
        case pe:
          return;
        default: {
          xh(s, r), Uf(r);
          return;
        }
      }
    }
    function Uf(r) {
      var s = r.flags;
      if (s & ar) {
        try {
          Pk(r);
        } catch (p) {
          To(r, r.return, p);
        }
        r.flags &= ~ar;
      }
      s & Dl && (r.flags &= ~Dl);
    }
    function $k(r, s, p) {
      $0 = p, eG = s, Gi = r, pF(r, s, p), $0 = null, eG = null;
    }
    function pF(r, s, p) {
      for (var y = (r.mode & Zi) !== Kn; Gi !== null; ) {
        var Z = Gi, X = Z.child;
        if (Z.tag === Ae && y) {
          var K = Z.memoizedState !== null, j = K || yx;
          if (j) {
            lN(r, s, p);
            continue;
          } else {
            var ne = Z.alternate, de = ne !== null && ne.memoizedState !== null, Ge = de || pc, rt = yx, it = pc;
            yx = j, pc = Ge, pc && !it && (Gi = Z, tD(Z));
            for (var Vt = X; Vt !== null; )
              Gi = Vt, pF(
                Vt,
                // New root; bubble back up to here and stop.
                s,
                p
              ), Vt = Vt.sibling;
            Gi = Z, yx = rt, pc = it, lN(r, s, p);
            continue;
          }
        }
        (Z.subtreeFlags & Gu) !== Hi && X !== null ? (X.return = Z, Gi = X) : lN(r, s, p);
      }
    }
    function lN(r, s, p) {
      for (; Gi !== null; ) {
        var y = Gi;
        if ((y.flags & Gu) !== Hi) {
          var Z = y.alternate;
          ia(y);
          try {
            Lk(s, Z, y, p);
          } catch (K) {
            To(y, y.return, K);
          }
          Xr();
        }
        if (y === r) {
          Gi = null;
          return;
        }
        var X = y.sibling;
        if (X !== null) {
          X.return = y.return, Gi = X;
          return;
        }
        Gi = y.return;
      }
    }
    function eD(r) {
      for (; Gi !== null; ) {
        var s = Gi, p = s.child;
        switch (s.tag) {
          case f:
          case _:
          case q:
          case k: {
            if (s.mode & vi)
              try {
                di(), wh(Vs, s, s.return);
              } finally {
                Ct(s);
              }
            else
              wh(Vs, s, s.return);
            break;
          }
          case h: {
            tG(s, s.return);
            var y = s.stateNode;
            typeof y.componentWillUnmount == "function" && aN(s, s.return, y);
            break;
          }
          case R: {
            tG(s, s.return);
            break;
          }
          case Ae: {
            var Z = s.memoizedState !== null;
            if (Z) {
              mF(r);
              continue;
            }
            break;
          }
        }
        p !== null ? (p.return = s, Gi = p) : mF(r);
      }
    }
    function mF(r) {
      for (; Gi !== null; ) {
        var s = Gi;
        if (s === r) {
          Gi = null;
          return;
        }
        var p = s.sibling;
        if (p !== null) {
          p.return = s.return, Gi = p;
          return;
        }
        Gi = s.return;
      }
    }
    function tD(r) {
      for (; Gi !== null; ) {
        var s = Gi, p = s.child;
        if (s.tag === Ae) {
          var y = s.memoizedState !== null;
          if (y) {
            AF(r);
            continue;
          }
        }
        p !== null ? (p.return = s, Gi = p) : AF(r);
      }
    }
    function AF(r) {
      for (; Gi !== null; ) {
        var s = Gi;
        ia(s);
        try {
          kk(s);
        } catch (y) {
          To(s, s.return, y);
        }
        if (Xr(), s === r) {
          Gi = null;
          return;
        }
        var p = s.sibling;
        if (p !== null) {
          p.return = s.return, Gi = p;
          return;
        }
        Gi = s.return;
      }
    }
    function nD(r, s, p, y) {
      Gi = s, iD(s, r, p, y);
    }
    function iD(r, s, p, y) {
      for (; Gi !== null; ) {
        var Z = Gi, X = Z.child;
        (Z.subtreeFlags & Nn) !== Hi && X !== null ? (X.return = Z, Gi = X) : rD(r, s, p, y);
      }
    }
    function rD(r, s, p, y) {
      for (; Gi !== null; ) {
        var Z = Gi;
        if ((Z.flags & gl) !== Hi) {
          ia(Z);
          try {
            aD(s, Z, p, y);
          } catch (K) {
            To(Z, Z.return, K);
          }
          Xr();
        }
        if (Z === r) {
          Gi = null;
          return;
        }
        var X = Z.sibling;
        if (X !== null) {
          X.return = Z.return, Gi = X;
          return;
        }
        Gi = Z.return;
      }
    }
    function aD(r, s, p, y) {
      switch (s.tag) {
        case f:
        case _:
        case k: {
          if (s.mode & vi) {
            si();
            try {
              wA(iu | Cs, s);
            } finally {
              Vn(s);
            }
          } else
            wA(iu | Cs, s);
          break;
        }
      }
    }
    function oD(r) {
      Gi = r, sD();
    }
    function sD() {
      for (; Gi !== null; ) {
        var r = Gi, s = r.child;
        if ((Gi.flags & Gr) !== Hi) {
          var p = r.deletions;
          if (p !== null) {
            for (var y = 0; y < p.length; y++) {
              var Z = p[y];
              Gi = Z, cD(Z, r);
            }
            {
              var X = r.alternate;
              if (X !== null) {
                var K = X.child;
                if (K !== null) {
                  X.child = null;
                  do {
                    var j = K.sibling;
                    K.sibling = null, K = j;
                  } while (K !== null);
                }
              }
            }
            Gi = r;
          }
        }
        (r.subtreeFlags & Nn) !== Hi && s !== null ? (s.return = r, Gi = s) : lD();
      }
    }
    function lD() {
      for (; Gi !== null; ) {
        var r = Gi;
        (r.flags & gl) !== Hi && (ia(r), uD(r), Xr());
        var s = r.sibling;
        if (s !== null) {
          s.return = r.return, Gi = s;
          return;
        }
        Gi = r.return;
      }
    }
    function uD(r) {
      switch (r.tag) {
        case f:
        case _:
        case k: {
          r.mode & vi ? (si(), wh(iu | Cs, r, r.return), Vn(r)) : wh(iu | Cs, r, r.return);
          break;
        }
      }
    }
    function cD(r, s) {
      for (; Gi !== null; ) {
        var p = Gi;
        ia(p), dD(p, s), Xr();
        var y = p.child;
        y !== null ? (y.return = p, Gi = y) : gD(r);
      }
    }
    function gD(r) {
      for (; Gi !== null; ) {
        var s = Gi, p = s.sibling, y = s.return;
        if (gF(s), s === r) {
          Gi = null;
          return;
        }
        if (p !== null) {
          p.return = y, Gi = p;
          return;
        }
        Gi = y;
      }
    }
    function dD(r, s) {
      switch (r.tag) {
        case f:
        case _:
        case k: {
          r.mode & vi ? (si(), wh(iu, r, s), Vn(r)) : wh(iu, r, s);
          break;
        }
      }
    }
    function ID(r) {
      switch (r.tag) {
        case f:
        case _:
        case k: {
          try {
            wA(Vs | Cs, r);
          } catch (p) {
            To(r, r.return, p);
          }
          break;
        }
        case h: {
          var s = r.stateNode;
          try {
            s.componentDidMount();
          } catch (p) {
            To(r, r.return, p);
          }
          break;
        }
      }
    }
    function CD(r) {
      switch (r.tag) {
        case f:
        case _:
        case k: {
          try {
            wA(iu | Cs, r);
          } catch (s) {
            To(r, r.return, s);
          }
          break;
        }
      }
    }
    function hD(r) {
      switch (r.tag) {
        case f:
        case _:
        case k: {
          try {
            wh(Vs | Cs, r, r.return);
          } catch (p) {
            To(r, r.return, p);
          }
          break;
        }
        case h: {
          var s = r.stateNode;
          typeof s.componentWillUnmount == "function" && aN(r, r.return, s);
          break;
        }
      }
    }
    function fD(r) {
      switch (r.tag) {
        case f:
        case _:
        case k:
          try {
            wh(iu | Cs, r, r.return);
          } catch (s) {
            To(r, r.return, s);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var US = Symbol.for;
      US("selector.component"), US("selector.has_pseudo_class"), US("selector.role"), US("selector.test_id"), US("selector.text");
    }
    var pD = [];
    function mD() {
      pD.forEach(function(r) {
        return r();
      });
    }
    var AD = n.ReactCurrentActQueue;
    function vD(r) {
      {
        var s = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), p = typeof jest < "u";
        return p && s !== !1;
      }
    }
    function vF() {
      {
        var r = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !r && AD.current !== null && u("The current testing environment is not configured to support act(...)"), r;
      }
    }
    var yD = Math.ceil, uN = n.ReactCurrentDispatcher, cN = n.ReactCurrentOwner, Ac = n.ReactCurrentBatchConfig, Wh = n.ReactCurrentActQueue, ru = (
      /*             */
      0
    ), yF = (
      /*               */
      1
    ), vc = (
      /*                */
      2
    ), WC = (
      /*                */
      4
    ), gm = 0, OS = 1, Ry = 2, Gx = 3, PS = 4, bF = 5, gN = 6, oa = ru, Ng = null, Ns = null, au = dn, Of = dn, dN = ph(dn), ou = gm, JS = null, Bx = dn, QS = dn, Sx = dn, jS = null, wd = null, IN = 0, GF = 500, BF = 1 / 0, bD = 500, dm = null;
    function qS() {
      BF = co() + bD;
    }
    function SF() {
      return BF;
    }
    var Zx = !1, CN = null, nG = null, xy = !1, xA = null, $S = dn, hN = [], fN = null, GD = 50, eZ = 0, pN = null, mN = !1, wx = !1, BD = 50, iG = 0, Rx = null, tZ = Br, xx = dn, ZF = !1;
    function Wx() {
      return Ng;
    }
    function Mg() {
      return (oa & (vc | WC)) !== ru ? co() : (tZ !== Br || (tZ = co()), tZ);
    }
    function WA(r) {
      var s = r.mode;
      if ((s & Zi) === Kn)
        return yi;
      if ((oa & vc) !== ru && au !== dn)
        return gs(au);
      var p = B0() !== jp;
      if (p) {
        if (Ac.transition !== null) {
          var y = Ac.transition;
          y._updatedFibers || (y._updatedFibers = /* @__PURE__ */ new Set()), y._updatedFibers.add(r);
        }
        return xx === Wr && (xx = lr()), xx;
      }
      var Z = Nl();
      if (Z !== Wr)
        return Z;
      var X = aV();
      return X;
    }
    function SD(r) {
      var s = r.mode;
      return (s & Zi) === Kn ? yi : $n();
    }
    function su(r, s, p, y) {
      JD(), ZF && u("useInsertionEffect must not schedule updates."), mN && (wx = !0), Cl(r, p, y), (oa & vc) !== dn && r === Ng ? qD(s) : (Os && zm(r, s, p), $D(s), r === Ng && ((oa & vc) === ru && (QS = fn(QS, p)), ou === PS && VA(r, au)), Rd(r, y), p === yi && oa === ru && (s.mode & Zi) === Kn && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Wh.isBatchingLegacy && (qS(), DR()));
    }
    function ZD(r, s, p) {
      var y = r.current;
      y.lanes = s, Cl(r, s, p), Rd(r, p);
    }
    function wD(r) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (oa & vc) !== ru
      );
    }
    function Rd(r, s) {
      var p = r.callbackNode;
      V(r, s);
      var y = Fc(r, r === Ng ? au : dn);
      if (y === dn) {
        p !== null && KF(p), r.callbackNode = null, r.callbackPriority = Wr;
        return;
      }
      var Z = to(y), X = r.callbackPriority;
      if (X === Z && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Wh.current !== null && p !== SN)) {
        p == null && X !== yi && u("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      p != null && KF(p);
      var K;
      if (Z === yi)
        r.tag === wf ? (Wh.isBatchingLegacy !== null && (Wh.didScheduleLegacyUpdate = !0), kR(xF.bind(null, r))) : LR(xF.bind(null, r)), Wh.current !== null ? Wh.current.push(Rf) : yR(function() {
          (oa & (vc | WC)) === ru && Rf();
        }), K = null;
      else {
        var j;
        switch (Km(y)) {
          case ql:
            j = ud;
            break;
          case Ec:
            j = cd;
            break;
          case oc:
            j = Nc;
            break;
          case ah:
            j = vg;
            break;
          default:
            j = Nc;
            break;
        }
        K = ZN(j, wF.bind(null, r));
      }
      r.callbackPriority = Z, r.callbackNode = K;
    }
    function wF(r, s) {
      if (_i(), tZ = Br, xx = dn, (oa & (vc | WC)) !== ru)
        throw new Error("Should not already be working.");
      var p = r.callbackNode, y = Cm();
      if (y && r.callbackNode !== p)
        return null;
      var Z = Fc(r, r === Ng ? au : dn);
      if (Z === dn)
        return null;
      var X = !Jn(r, Z) && !mi(r, Z) && !s, K = X ? FD(r, Z) : Nx(r, Z);
      if (K !== gm) {
        if (K === Ry) {
          var j = L(r);
          j !== dn && (Z = j, K = AN(r, j));
        }
        if (K === OS) {
          var ne = JS;
          throw Wy(r, dn), VA(r, Z), Rd(r, co()), ne;
        }
        if (K === gN)
          VA(r, Z);
        else {
          var de = !Jn(r, Z), Ge = r.current.alternate;
          if (de && !xD(Ge)) {
            if (K = Nx(r, Z), K === Ry) {
              var rt = L(r);
              rt !== dn && (Z = rt, K = AN(r, rt));
            }
            if (K === OS) {
              var it = JS;
              throw Wy(r, dn), VA(r, Z), Rd(r, co()), it;
            }
          }
          r.finishedWork = Ge, r.finishedLanes = Z, RD(r, K, Z);
        }
      }
      return Rd(r, co()), r.callbackNode === p ? wF.bind(null, r) : null;
    }
    function AN(r, s) {
      var p = jS;
      if (oi(r)) {
        var y = Wy(r, s);
        y.flags |= As, ii(r.containerInfo);
      }
      var Z = Nx(r, s);
      if (Z !== Ry) {
        var X = wd;
        wd = p, X !== null && RF(X);
      }
      return Z;
    }
    function RF(r) {
      wd === null ? wd = r : wd.push.apply(wd, r);
    }
    function RD(r, s, p) {
      switch (s) {
        case gm:
        case OS:
          throw new Error("Root did not complete. This is a bug in React.");
        case Ry: {
          Vy(r, wd, dm);
          break;
        }
        case Gx: {
          if (VA(r, p), nt(p) && // do not delay if we're inside an act() scope
          !LF()) {
            var y = IN + GF - co();
            if (y > 10) {
              var Z = Fc(r, dn);
              if (Z !== dn)
                break;
              var X = r.suspendedLanes;
              if (!Tn(X, p)) {
                Mg(), lC(r, X);
                break;
              }
              r.timeoutHandle = EB(Vy.bind(null, r, wd, dm), y);
              break;
            }
          }
          Vy(r, wd, dm);
          break;
        }
        case PS: {
          if (VA(r, p), Wn(p))
            break;
          if (!LF()) {
            var K = m(r, p), j = K, ne = co() - j, de = PD(ne) - ne;
            if (de > 10) {
              r.timeoutHandle = EB(Vy.bind(null, r, wd, dm), de);
              break;
            }
          }
          Vy(r, wd, dm);
          break;
        }
        case bF: {
          Vy(r, wd, dm);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function xD(r) {
      for (var s = r; ; ) {
        if (s.flags & xc) {
          var p = s.updateQueue;
          if (p !== null) {
            var y = p.stores;
            if (y !== null)
              for (var Z = 0; Z < y.length; Z++) {
                var X = y[Z], K = X.getSnapshot, j = X.value;
                try {
                  if (!Ri(K(), j))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var ne = s.child;
        if (s.subtreeFlags & xc && ne !== null) {
          ne.return = s, s = ne;
          continue;
        }
        if (s === r)
          return !0;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === r)
            return !0;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return !0;
    }
    function VA(r, s) {
      s = ji(s, Sx), s = ji(s, QS), Gp(r, s);
    }
    function xF(r) {
      if (Ar(), (oa & (vc | WC)) !== ru)
        throw new Error("Should not already be working.");
      Cm();
      var s = Fc(r, dn);
      if (!Zt(s, yi))
        return Rd(r, co()), null;
      var p = Nx(r, s);
      if (r.tag !== wf && p === Ry) {
        var y = L(r);
        y !== dn && (s = y, p = AN(r, y));
      }
      if (p === OS) {
        var Z = JS;
        throw Wy(r, dn), VA(r, s), Rd(r, co()), Z;
      }
      if (p === gN)
        throw new Error("Root did not complete. This is a bug in React.");
      var X = r.current.alternate;
      return r.finishedWork = X, r.finishedLanes = s, Vy(r, wd, dm), Rd(r, co()), null;
    }
    function WD(r, s) {
      s !== dn && (Bp(r, fn(s, yi)), Rd(r, co()), (oa & (vc | WC)) === ru && (qS(), Rf()));
    }
    function vN(r, s) {
      var p = oa;
      oa |= yF;
      try {
        return r(s);
      } finally {
        oa = p, oa === ru && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Wh.isBatchingLegacy && (qS(), DR());
      }
    }
    function VD(r, s, p, y, Z) {
      var X = Nl(), K = Ac.transition;
      try {
        return Ac.transition = null, Lr(ql), r(s, p, y, Z);
      } finally {
        Lr(X), Ac.transition = K, oa === ru && qS();
      }
    }
    function Im(r) {
      xA !== null && xA.tag === wf && (oa & (vc | WC)) === ru && Cm();
      var s = oa;
      oa |= yF;
      var p = Ac.transition, y = Nl();
      try {
        return Ac.transition = null, Lr(ql), r ? r() : void 0;
      } finally {
        Lr(y), Ac.transition = p, oa = s, (oa & (vc | WC)) === ru && Rf();
      }
    }
    function WF() {
      return (oa & (vc | WC)) !== ru;
    }
    function Vx(r, s) {
      Hu(dN, Of, r), Of = fn(Of, s);
    }
    function yN(r) {
      Of = dN.current, Mu(dN, r);
    }
    function Wy(r, s) {
      r.finishedWork = null, r.finishedLanes = dn;
      var p = r.timeoutHandle;
      if (p !== cA && (r.timeoutHandle = cA, TB(p)), Ns !== null)
        for (var y = Ns.return; y !== null; ) {
          var Z = y.alternate;
          aF(Z, y), y = y.return;
        }
      Ng = r;
      var X = Ny(r.current, null);
      return Ns = X, au = Of = s, ou = gm, JS = null, Bx = dn, QS = dn, Sx = dn, jS = null, wd = null, gS(), cc.discardPendingWarnings(), X;
    }
    function VF(r, s) {
      do {
        var p = Ns;
        try {
          if (Xf(), X0(), Xr(), cN.current = null, p === null || p.return === null) {
            ou = OS, JS = s, Ns = null;
            return;
          }
          if (St && p.mode & vi && en(p, !0), wt)
            if (ha(), s !== null && typeof s == "object" && typeof s.then == "function") {
              var y = s;
              ih(p, y, au);
            } else
              Uo(p, s, au);
          tk(r, p.return, p, s, au), XF(p);
        } catch (Z) {
          s = Z, Ns === p && p !== null ? (p = p.return, Ns = p) : p = Ns;
          continue;
        }
        return;
      } while (!0);
    }
    function NF() {
      var r = uN.current;
      return uN.current = j0, r === null ? j0 : r;
    }
    function MF(r) {
      uN.current = r;
    }
    function ND() {
      IN = co();
    }
    function nZ(r) {
      Bx = fn(r, Bx);
    }
    function MD() {
      ou === gm && (ou = Gx);
    }
    function bN() {
      (ou === gm || ou === Gx || ou === Ry) && (ou = PS), Ng !== null && (Ve(Bx) || Ve(QS)) && VA(Ng, au);
    }
    function HD(r) {
      ou !== PS && (ou = Ry), jS === null ? jS = [r] : jS.push(r);
    }
    function XD() {
      return ou === gm;
    }
    function Nx(r, s) {
      var p = oa;
      oa |= vc;
      var y = NF();
      if (Ng !== r || au !== s) {
        if (Os) {
          var Z = r.memoizedUpdaters;
          Z.size > 0 && (iZ(r, au), Z.clear()), rh(r, s);
        }
        dm = Zg(), Wy(r, s);
      }
      Ql(s);
      do
        try {
          YD();
          break;
        } catch (X) {
          VF(r, X);
        }
      while (!0);
      if (Xf(), oa = p, MF(y), Ns !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ec(), Ng = null, au = dn, ou;
    }
    function YD() {
      for (; Ns !== null; )
        HF(Ns);
    }
    function FD(r, s) {
      var p = oa;
      oa |= vc;
      var y = NF();
      if (Ng !== r || au !== s) {
        if (Os) {
          var Z = r.memoizedUpdaters;
          Z.size > 0 && (iZ(r, au), Z.clear()), rh(r, s);
        }
        dm = Zg(), qS(), Wy(r, s);
      }
      Ql(s);
      do
        try {
          ED();
          break;
        } catch (X) {
          VF(r, X);
        }
      while (!0);
      return Xf(), MF(y), oa = p, Ns !== null ? (rC(), gm) : (ec(), Ng = null, au = dn, ou);
    }
    function ED() {
      for (; Ns !== null && !Pl(); )
        HF(Ns);
    }
    function HF(r) {
      var s = r.alternate;
      ia(r);
      var p;
      (r.mode & vi) !== Kn ? (ho(r), p = GN(s, r, Of), en(r, !0)) : p = GN(s, r, Of), Xr(), r.memoizedProps = r.pendingProps, p === null ? XF(r) : Ns = p, cN.current = null;
    }
    function XF(r) {
      var s = r;
      do {
        var p = s.alternate, y = s.return;
        if ((s.flags & Wc) === Hi) {
          ia(s);
          var Z = void 0;
          if ((s.mode & vi) === Kn ? Z = rF(p, s, Of) : (ho(s), Z = rF(p, s, Of), en(s, !1)), Xr(), Z !== null) {
            Ns = Z;
            return;
          }
        } else {
          var X = Mk(p, s);
          if (X !== null) {
            X.flags &= Qu, Ns = X;
            return;
          }
          if ((s.mode & vi) !== Kn) {
            en(s, !1);
            for (var K = s.actualDuration, j = s.child; j !== null; )
              K += j.actualDuration, j = j.sibling;
            s.actualDuration = K;
          }
          if (y !== null)
            y.flags |= Wc, y.subtreeFlags = Hi, y.deletions = null;
          else {
            ou = gN, Ns = null;
            return;
          }
        }
        var ne = s.sibling;
        if (ne !== null) {
          Ns = ne;
          return;
        }
        s = y, Ns = s;
      } while (s !== null);
      ou === gm && (ou = bF);
    }
    function Vy(r, s, p) {
      var y = Nl(), Z = Ac.transition;
      try {
        Ac.transition = null, Lr(ql), TD(r, s, p, y);
      } finally {
        Ac.transition = Z, Lr(y);
      }
      return null;
    }
    function TD(r, s, p, y) {
      do
        Cm();
      while (xA !== null);
      if (QD(), (oa & (vc | WC)) !== ru)
        throw new Error("Should not already be working.");
      var Z = r.finishedWork, X = r.finishedLanes;
      if (ur(X), Z === null)
        return po(), null;
      if (X === dn && u("root.finishedLanes should not be empty during a commit. This is a bug in React."), r.finishedWork = null, r.finishedLanes = dn, Z === r.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      r.callbackNode = null, r.callbackPriority = Wr;
      var K = fn(Z.lanes, Z.childLanes);
      hB(r, K), r === Ng && (Ng = null, Ns = null, au = dn), ((Z.subtreeFlags & Nn) !== Hi || (Z.flags & Nn) !== Hi) && (xy || (xy = !0, fN = p, ZN(Nc, function() {
        return Cm(), null;
      })));
      var j = (Z.subtreeFlags & (Wi | uo | Gu | Nn)) !== Hi, ne = (Z.flags & (Wi | uo | Gu | Nn)) !== Hi;
      if (j || ne) {
        var de = Ac.transition;
        Ac.transition = null;
        var Ge = Nl();
        Lr(ql);
        var rt = oa;
        oa |= WC, cN.current = null, Ek(r, Z), Bo(), qk(r, Z, X), YB(r.containerInfo), r.current = Z, dd(X), $k(Z, r, X), aI(), Ka(), oa = rt, Lr(Ge), Ac.transition = de;
      } else
        r.current = Z, Bo();
      var it = xy;
      if (xy ? (xy = !1, xA = r, $S = X) : (iG = 0, Rx = null), K = r.pendingLanes, K === dn && (nG = null), it || TF(r.current, !1), us(Z.stateNode, y), Os && r.memoizedUpdaters.clear(), mD(), Rd(r, co()), s !== null)
        for (var Vt = r.onRecoverableError, Xt = 0; Xt < s.length; Xt++) {
          var Jt = s[Xt], ri = Jt.stack, Li = Jt.digest;
          Vt(Jt.value, {
            componentStack: ri,
            digest: Li
          });
        }
      if (Zx) {
        Zx = !1;
        var Ni = CN;
        throw CN = null, Ni;
      }
      return Zt($S, yi) && r.tag !== wf && Cm(), K = r.pendingLanes, Zt(K, yi) ? (xn(), r === pN ? eZ++ : (eZ = 0, pN = r)) : eZ = 0, Rf(), po(), null;
    }
    function Cm() {
      if (xA !== null) {
        var r = Km($S), s = of(oc, r), p = Ac.transition, y = Nl();
        try {
          return Ac.transition = null, Lr(s), zD();
        } finally {
          Lr(y), Ac.transition = p;
        }
      }
      return !1;
    }
    function _D(r) {
      hN.push(r), xy || (xy = !0, ZN(Nc, function() {
        return Cm(), null;
      }));
    }
    function zD() {
      if (xA === null)
        return !1;
      var r = fN;
      fN = null;
      var s = xA, p = $S;
      if (xA = null, $S = dn, (oa & (vc | WC)) !== ru)
        throw new Error("Cannot flush passive effects while already rendering.");
      mN = !0, wx = !1, iC(p);
      var y = oa;
      oa |= WC, oD(s.current), nD(s, s.current, p, r);
      {
        var Z = hN;
        hN = [];
        for (var X = 0; X < Z.length; X++) {
          var K = Z[X];
          Kk(s, K);
        }
      }
      Xa(), TF(s.current, !0), oa = y, Rf(), wx ? s === Rx ? iG++ : (iG = 0, Rx = s) : iG = 0, mN = !1, wx = !1, qa(s);
      {
        var j = s.current.stateNode;
        j.effectDuration = 0, j.passiveEffectDuration = 0;
      }
      return !0;
    }
    function YF(r) {
      return nG !== null && nG.has(r);
    }
    function KD(r) {
      nG === null ? nG = /* @__PURE__ */ new Set([r]) : nG.add(r);
    }
    function LD(r) {
      Zx || (Zx = !0, CN = r);
    }
    var kD = LD;
    function FF(r, s, p) {
      var y = Zy(p, s), Z = HY(r, y, yi), X = Bh(r, Z, yi), K = Mg();
      X !== null && (Cl(X, yi, K), Rd(X, K));
    }
    function To(r, s, p) {
      if (Xk(p), rZ(!1), r.tag === b) {
        FF(r, r, p);
        return;
      }
      var y = null;
      for (y = s; y !== null; ) {
        if (y.tag === b) {
          FF(y, r, p);
          return;
        } else if (y.tag === h) {
          var Z = y.type, X = y.stateNode;
          if (typeof Z.getDerivedStateFromError == "function" || typeof X.componentDidCatch == "function" && !YF(X)) {
            var K = Zy(p, r), j = LV(y, K, yi), ne = Bh(y, j, yi), de = Mg();
            ne !== null && (Cl(ne, yi, de), Rd(ne, de));
            return;
          }
        }
        y = y.return;
      }
      u(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, p);
    }
    function DD(r, s, p) {
      var y = r.pingCache;
      y !== null && y.delete(s);
      var Z = Mg();
      lC(r, p), eU(r), Ng === r && Tn(au, p) && (ou === PS || ou === Gx && nt(au) && co() - IN < GF ? Wy(r, dn) : Sx = fn(Sx, p)), Rd(r, Z);
    }
    function EF(r, s) {
      s === Wr && (s = SD(r));
      var p = Mg(), y = Ws(r, s);
      y !== null && (Cl(y, s, p), Rd(y, p));
    }
    function UD(r) {
      var s = r.memoizedState, p = Wr;
      s !== null && (p = s.retryLane), EF(r, p);
    }
    function OD(r, s) {
      var p = Wr, y;
      switch (r.tag) {
        case U:
          y = r.stateNode;
          var Z = r.memoizedState;
          Z !== null && (p = Z.retryLane);
          break;
        case fe:
          y = r.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      y !== null && y.delete(s), EF(r, p);
    }
    function PD(r) {
      return r < 120 ? 120 : r < 480 ? 480 : r < 1080 ? 1080 : r < 1920 ? 1920 : r < 3e3 ? 3e3 : r < 4320 ? 4320 : yD(r / 1960) * 1960;
    }
    function JD() {
      if (eZ > GD)
        throw eZ = 0, pN = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      iG > BD && (iG = 0, Rx = null, u("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function QD() {
      cc.flushLegacyContextWarning(), cc.flushPendingUnsafeLifecycleWarnings();
    }
    function TF(r, s) {
      ia(r), Mx(r, ja, hD), s && Mx(r, bu, fD), Mx(r, ja, ID), s && Mx(r, bu, CD), Xr();
    }
    function Mx(r, s, p) {
      for (var y = r, Z = null; y !== null; ) {
        var X = y.subtreeFlags & s;
        y !== Z && y.child !== null && X !== Hi ? y = y.child : ((y.flags & s) !== Hi && p(y), y.sibling !== null ? y = y.sibling : y = Z = y.return);
      }
    }
    var Hx = null;
    function _F(r) {
      {
        if ((oa & vc) !== ru || !(r.mode & Zi))
          return;
        var s = r.tag;
        if (s !== v && s !== b && s !== h && s !== f && s !== _ && s !== q && s !== k)
          return;
        var p = gi(r) || "ReactComponent";
        if (Hx !== null) {
          if (Hx.has(p))
            return;
          Hx.add(p);
        } else
          Hx = /* @__PURE__ */ new Set([p]);
        var y = Hn;
        try {
          ia(r), u("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          y ? ia(r) : Xr();
        }
      }
    }
    var GN;
    {
      var jD = null;
      GN = function(r, s, p) {
        var y = PF(jD, s);
        try {
          return $Y(r, s, p);
        } catch (X) {
          if (tS() || X !== null && typeof X == "object" && typeof X.then == "function")
            throw X;
          if (Xf(), X0(), aF(r, s), PF(s, y), s.mode & vi && ho(s), ms(null, $Y, null, r, s, p), sd()) {
            var Z = Ju();
            typeof Z == "object" && Z !== null && Z._suppressLogging && typeof X == "object" && X !== null && !X._suppressLogging && (X._suppressLogging = !0);
          }
          throw X;
        }
      };
    }
    var zF = !1, BN;
    BN = /* @__PURE__ */ new Set();
    function qD(r) {
      if (Pa && !gx())
        switch (r.tag) {
          case f:
          case _:
          case k: {
            var s = Ns && gi(Ns) || "Unknown", p = s;
            if (!BN.has(p)) {
              BN.add(p);
              var y = gi(r) || "Unknown";
              u("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", y, s, s);
            }
            break;
          }
          case h: {
            zF || (u("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), zF = !0);
            break;
          }
        }
    }
    function iZ(r, s) {
      if (Os) {
        var p = r.memoizedUpdaters;
        p.forEach(function(y) {
          zm(r, y, s);
        });
      }
    }
    var SN = {};
    function ZN(r, s) {
      {
        var p = Wh.current;
        return p !== null ? (p.push(s), SN) : nI(r, s);
      }
    }
    function KF(r) {
      if (r !== SN)
        return Vc(r);
    }
    function LF() {
      return Wh.current !== null;
    }
    function $D(r) {
      {
        if (r.mode & Zi) {
          if (!vF())
            return;
        } else if (!vD() || oa !== ru || r.tag !== f && r.tag !== _ && r.tag !== k)
          return;
        if (Wh.current === null) {
          var s = Hn;
          try {
            ia(r), u(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, gi(r));
          } finally {
            s ? ia(r) : Xr();
          }
        }
      }
    }
    function eU(r) {
      r.tag !== wf && vF() && Wh.current === null && u(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function rZ(r) {
      ZF = r;
    }
    var VC = null, rG = null, tU = function(r) {
      VC = r;
    };
    function aG(r) {
      {
        if (VC === null)
          return r;
        var s = VC(r);
        return s === void 0 ? r : s.current;
      }
    }
    function wN(r) {
      return aG(r);
    }
    function RN(r) {
      {
        if (VC === null)
          return r;
        var s = VC(r);
        if (s === void 0) {
          if (r != null && typeof r.render == "function") {
            var p = aG(r.render);
            if (r.render !== p) {
              var y = {
                $$typeof: Bt,
                render: p
              };
              return r.displayName !== void 0 && (y.displayName = r.displayName), y;
            }
          }
          return r;
        }
        return s.current;
      }
    }
    function kF(r, s) {
      {
        if (VC === null)
          return !1;
        var p = r.elementType, y = s.type, Z = !1, X = typeof y == "object" && y !== null ? y.$$typeof : null;
        switch (r.tag) {
          case h: {
            typeof y == "function" && (Z = !0);
            break;
          }
          case f: {
            (typeof y == "function" || X === Ee) && (Z = !0);
            break;
          }
          case _: {
            (X === Bt || X === Ee) && (Z = !0);
            break;
          }
          case q:
          case k: {
            (X === we || X === Ee) && (Z = !0);
            break;
          }
          default:
            return !1;
        }
        if (Z) {
          var K = VC(p);
          if (K !== void 0 && K === VC(y))
            return !0;
        }
        return !1;
      }
    }
    function DF(r) {
      {
        if (VC === null || typeof WeakSet != "function")
          return;
        rG === null && (rG = /* @__PURE__ */ new WeakSet()), rG.add(r);
      }
    }
    var nU = function(r, s) {
      {
        if (VC === null)
          return;
        var p = s.staleFamilies, y = s.updatedFamilies;
        Cm(), Im(function() {
          xN(r.current, y, p);
        });
      }
    }, iU = function(r, s) {
      {
        if (r.context !== kc)
          return;
        Cm(), Im(function() {
          aZ(s, r, null, null);
        });
      }
    };
    function xN(r, s, p) {
      {
        var y = r.alternate, Z = r.child, X = r.sibling, K = r.tag, j = r.type, ne = null;
        switch (K) {
          case f:
          case k:
          case h:
            ne = j;
            break;
          case _:
            ne = j.render;
            break;
        }
        if (VC === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var de = !1, Ge = !1;
        if (ne !== null) {
          var rt = VC(ne);
          rt !== void 0 && (p.has(rt) ? Ge = !0 : s.has(rt) && (K === h ? Ge = !0 : de = !0));
        }
        if (rG !== null && (rG.has(r) || y !== null && rG.has(y)) && (Ge = !0), Ge && (r._debugNeedsRemount = !0), Ge || de) {
          var it = Ws(r, yi);
          it !== null && su(it, r, yi, Br);
        }
        Z !== null && !Ge && xN(Z, s, p), X !== null && xN(X, s, p);
      }
    }
    var rU = function(r, s) {
      {
        var p = /* @__PURE__ */ new Set(), y = new Set(s.map(function(Z) {
          return Z.current;
        }));
        return WN(r.current, y, p), p;
      }
    };
    function WN(r, s, p) {
      {
        var y = r.child, Z = r.sibling, X = r.tag, K = r.type, j = null;
        switch (X) {
          case f:
          case k:
          case h:
            j = K;
            break;
          case _:
            j = K.render;
            break;
        }
        var ne = !1;
        j !== null && s.has(j) && (ne = !0), ne ? aU(r, p) : y !== null && WN(y, s, p), Z !== null && WN(Z, s, p);
      }
    }
    function aU(r, s) {
      {
        var p = oU(r, s);
        if (p)
          return;
        for (var y = r; ; ) {
          switch (y.tag) {
            case R:
              s.add(y.stateNode);
              return;
            case S:
              s.add(y.stateNode.containerInfo);
              return;
            case b:
              s.add(y.stateNode.containerInfo);
              return;
          }
          if (y.return === null)
            throw new Error("Expected to reach root first.");
          y = y.return;
        }
      }
    }
    function oU(r, s) {
      for (var p = r, y = !1; ; ) {
        if (p.tag === R)
          y = !0, s.add(p.stateNode);
        else if (p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === r)
          return y;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === r)
            return y;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
      return !1;
    }
    var VN;
    {
      VN = !1;
      try {
        var UF = Object.preventExtensions({});
      } catch {
        VN = !0;
      }
    }
    function sU(r, s, p, y) {
      this.tag = r, this.key = p, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = s, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = y, this.flags = Hi, this.subtreeFlags = Hi, this.deletions = null, this.lanes = dn, this.childLanes = dn, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !VN && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var NI = function(r, s, p, y) {
      return new sU(r, s, p, y);
    };
    function NN(r) {
      var s = r.prototype;
      return !!(s && s.isReactComponent);
    }
    function lU(r) {
      return typeof r == "function" && !NN(r) && r.defaultProps === void 0;
    }
    function uU(r) {
      if (typeof r == "function")
        return NN(r) ? h : f;
      if (r != null) {
        var s = r.$$typeof;
        if (s === Bt)
          return _;
        if (s === we)
          return q;
      }
      return v;
    }
    function Ny(r, s) {
      var p = r.alternate;
      p === null ? (p = NI(r.tag, s, r.key, r.mode), p.elementType = r.elementType, p.type = r.type, p.stateNode = r.stateNode, p._debugSource = r._debugSource, p._debugOwner = r._debugOwner, p._debugHookTypes = r._debugHookTypes, p.alternate = r, r.alternate = p) : (p.pendingProps = s, p.type = r.type, p.flags = Hi, p.subtreeFlags = Hi, p.deletions = null, p.actualDuration = 0, p.actualStartTime = -1), p.flags = r.flags & Do, p.childLanes = r.childLanes, p.lanes = r.lanes, p.child = r.child, p.memoizedProps = r.memoizedProps, p.memoizedState = r.memoizedState, p.updateQueue = r.updateQueue;
      var y = r.dependencies;
      switch (p.dependencies = y === null ? null : {
        lanes: y.lanes,
        firstContext: y.firstContext
      }, p.sibling = r.sibling, p.index = r.index, p.ref = r.ref, p.selfBaseDuration = r.selfBaseDuration, p.treeBaseDuration = r.treeBaseDuration, p._debugNeedsRemount = r._debugNeedsRemount, p.tag) {
        case v:
        case f:
        case k:
          p.type = aG(r.type);
          break;
        case h:
          p.type = wN(r.type);
          break;
        case _:
          p.type = RN(r.type);
          break;
      }
      return p;
    }
    function cU(r, s) {
      r.flags &= Do | ar;
      var p = r.alternate;
      if (p === null)
        r.childLanes = dn, r.lanes = s, r.child = null, r.subtreeFlags = Hi, r.memoizedProps = null, r.memoizedState = null, r.updateQueue = null, r.dependencies = null, r.stateNode = null, r.selfBaseDuration = 0, r.treeBaseDuration = 0;
      else {
        r.childLanes = p.childLanes, r.lanes = p.lanes, r.child = p.child, r.subtreeFlags = Hi, r.deletions = null, r.memoizedProps = p.memoizedProps, r.memoizedState = p.memoizedState, r.updateQueue = p.updateQueue, r.type = p.type;
        var y = p.dependencies;
        r.dependencies = y === null ? null : {
          lanes: y.lanes,
          firstContext: y.firstContext
        }, r.selfBaseDuration = p.selfBaseDuration, r.treeBaseDuration = p.treeBaseDuration;
      }
      return r;
    }
    function gU(r, s, p) {
      var y;
      return r === Ov ? (y = Zi, s === !0 && (y |= Or, y |= La)) : y = Kn, Os && (y |= vi), NI(b, null, null, y);
    }
    function MN(r, s, p, y, Z, X) {
      var K = v, j = r;
      if (typeof r == "function")
        NN(r) ? (K = h, j = wN(j)) : j = aG(j);
      else if (typeof r == "string")
        K = R;
      else
        e: switch (r) {
          case qe:
            return NA(p.children, Z, X, s);
          case gt:
            K = M, Z |= Or, (Z & Zi) !== Kn && (Z |= La);
            break;
          case Pt:
            return dU(p, Z, X, s);
          case Tt:
            return IU(p, Z, X, s);
          case ae:
            return CU(p, Z, X, s);
          case Nt:
            return OF(p, Z, X, s);
          case Kt:
          case Ue:
          case vn:
          case Yt:
          case Oe:
          default: {
            if (typeof r == "object" && r !== null)
              switch (r.$$typeof) {
                case me:
                  K = E;
                  break e;
                case ut:
                  K = T;
                  break e;
                case Bt:
                  K = _, j = RN(j);
                  break e;
                case we:
                  K = q;
                  break e;
                case Ee:
                  K = O, j = null;
                  break e;
              }
            var ne = "";
            {
              (r === void 0 || typeof r == "object" && r !== null && Object.keys(r).length === 0) && (ne += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var de = y ? gi(y) : null;
              de && (ne += `

Check the render method of \`` + de + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (r == null ? r : typeof r) + "." + ne));
          }
        }
      var Ge = NI(K, p, s, Z);
      return Ge.elementType = r, Ge.type = j, Ge.lanes = X, Ge._debugOwner = y, Ge;
    }
    function HN(r, s, p) {
      var y = null;
      y = r._owner;
      var Z = r.type, X = r.key, K = r.props, j = MN(Z, X, K, y, s, p);
      return j._debugSource = r._source, j._debugOwner = r._owner, j;
    }
    function NA(r, s, p, y) {
      var Z = NI(x, r, y, s);
      return Z.lanes = p, Z;
    }
    function dU(r, s, p, y) {
      typeof r.id != "string" && u('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof r.id);
      var Z = NI(P, r, y, s | vi);
      return Z.elementType = Pt, Z.lanes = p, Z.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, Z;
    }
    function IU(r, s, p, y) {
      var Z = NI(U, r, y, s);
      return Z.elementType = Tt, Z.lanes = p, Z;
    }
    function CU(r, s, p, y) {
      var Z = NI(fe, r, y, s);
      return Z.elementType = ae, Z.lanes = p, Z;
    }
    function OF(r, s, p, y) {
      var Z = NI(Ae, r, y, s);
      Z.elementType = Nt, Z.lanes = p;
      var X = {
        isHidden: !1
      };
      return Z.stateNode = X, Z;
    }
    function XN(r, s, p) {
      var y = NI(W, r, null, s);
      return y.lanes = p, y;
    }
    function hU() {
      var r = NI(R, null, null, Kn);
      return r.elementType = "DELETED", r;
    }
    function fU(r) {
      var s = NI(te, null, null, Kn);
      return s.stateNode = r, s;
    }
    function YN(r, s, p) {
      var y = r.children !== null ? r.children : [], Z = NI(S, y, r.key, s);
      return Z.lanes = p, Z.stateNode = {
        containerInfo: r.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: r.implementation
      }, Z;
    }
    function PF(r, s) {
      return r === null && (r = NI(v, null, null, Kn)), r.tag = s.tag, r.key = s.key, r.elementType = s.elementType, r.type = s.type, r.stateNode = s.stateNode, r.return = s.return, r.child = s.child, r.sibling = s.sibling, r.index = s.index, r.ref = s.ref, r.pendingProps = s.pendingProps, r.memoizedProps = s.memoizedProps, r.updateQueue = s.updateQueue, r.memoizedState = s.memoizedState, r.dependencies = s.dependencies, r.mode = s.mode, r.flags = s.flags, r.subtreeFlags = s.subtreeFlags, r.deletions = s.deletions, r.lanes = s.lanes, r.childLanes = s.childLanes, r.alternate = s.alternate, r.actualDuration = s.actualDuration, r.actualStartTime = s.actualStartTime, r.selfBaseDuration = s.selfBaseDuration, r.treeBaseDuration = s.treeBaseDuration, r._debugSource = s._debugSource, r._debugOwner = s._debugOwner, r._debugNeedsRemount = s._debugNeedsRemount, r._debugHookTypes = s._debugHookTypes, r;
    }
    function pU(r, s, p, y, Z) {
      this.tag = s, this.containerInfo = r, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = cA, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Wr, this.eventTimes = mr(dn), this.expirationTimes = mr(Br), this.pendingLanes = dn, this.suspendedLanes = dn, this.pingedLanes = dn, this.expiredLanes = dn, this.mutableReadLanes = dn, this.finishedLanes = dn, this.entangledLanes = dn, this.entanglements = mr(dn), this.identifierPrefix = y, this.onRecoverableError = Z, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var X = this.pendingUpdatersLaneMap = [], K = 0; K < dl; K++)
          X.push(/* @__PURE__ */ new Set());
      }
      switch (s) {
        case Ov:
          this._debugRootType = p ? "hydrateRoot()" : "createRoot()";
          break;
        case wf:
          this._debugRootType = p ? "hydrate()" : "render()";
          break;
      }
    }
    function JF(r, s, p, y, Z, X, K, j, ne, de) {
      var Ge = new pU(r, s, p, j, ne), rt = gU(s, X);
      Ge.current = rt, rt.stateNode = Ge;
      {
        var it = {
          element: y,
          isDehydrated: p,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        rt.memoizedState = it;
      }
      return oy(rt), Ge;
    }
    var FN = "18.3.1";
    function mU(r, s, p) {
      var y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Se(y), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Le,
        key: y == null ? null : "" + y,
        children: r,
        containerInfo: s,
        implementation: p
      };
    }
    var EN, TN;
    EN = !1, TN = {};
    function QF(r) {
      if (!r)
        return kc;
      var s = os(r), p = SV(s);
      if (s.tag === h) {
        var y = s.type;
        if (BI(y))
          return zR(s, y, p);
      }
      return p;
    }
    function AU(r, s) {
      {
        var p = os(r);
        if (p === void 0) {
          if (typeof r.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var y = Object.keys(r).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + y);
        }
        var Z = eh(p);
        if (Z === null)
          return null;
        if (Z.mode & Or) {
          var X = gi(p) || "Component";
          if (!TN[X]) {
            TN[X] = !0;
            var K = Hn;
            try {
              ia(Z), p.mode & Or ? u("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", s, s, X) : u("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", s, s, X);
            } finally {
              K ? ia(K) : Xr();
            }
          }
        }
        return Z.stateNode;
      }
    }
    function jF(r, s, p, y, Z, X, K, j) {
      var ne = !1, de = null;
      return JF(r, s, ne, de, p, y, Z, X, K);
    }
    function qF(r, s, p, y, Z, X, K, j, ne, de) {
      var Ge = !0, rt = JF(p, y, Ge, r, Z, X, K, j, ne);
      rt.context = QF(null);
      var it = rt.current, Vt = Mg(), Xt = WA(it), Jt = wC(Vt, Xt);
      return Jt.callback = s ?? null, Bh(it, Jt, Xt), ZD(rt, Xt, Vt), rt;
    }
    function aZ(r, s, p, y) {
      gd(s, r);
      var Z = s.current, X = Mg(), K = WA(Z);
      oI(K);
      var j = QF(p);
      s.context === null ? s.context = j : s.pendingContext = j, Pa && Hn !== null && !EN && (EN = !0, u(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, gi(Hn) || "Unknown"));
      var ne = wC(X, K);
      ne.payload = {
        element: r
      }, y = y === void 0 ? null : y, y !== null && (typeof y != "function" && u("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", y), ne.callback = y);
      var de = Bh(Z, ne, K);
      return de !== null && (su(de, Z, K, X), sy(de, Z, K)), K;
    }
    function Xx(r) {
      var s = r.current;
      if (!s.child)
        return null;
      switch (s.child.tag) {
        case R:
          return s.child.stateNode;
        default:
          return s.child.stateNode;
      }
    }
    function vU(r) {
      switch (r.tag) {
        case b: {
          var s = r.stateNode;
          if (oi(s)) {
            var p = Y(s);
            WD(s, p);
          }
          break;
        }
        case U: {
          Im(function() {
            var Z = Ws(r, yi);
            if (Z !== null) {
              var X = Mg();
              su(Z, r, yi, X);
            }
          });
          var y = yi;
          _N(r, y);
          break;
        }
      }
    }
    function $F(r, s) {
      var p = r.memoizedState;
      p !== null && p.dehydrated !== null && (p.retryLane = xa(p.retryLane, s));
    }
    function _N(r, s) {
      $F(r, s);
      var p = r.alternate;
      p && $F(p, s);
    }
    function yU(r) {
      if (r.tag === U) {
        var s = Yc, p = Ws(r, s);
        if (p !== null) {
          var y = Mg();
          su(p, r, s, y);
        }
        _N(r, s);
      }
    }
    function bU(r) {
      if (r.tag === U) {
        var s = WA(r), p = Ws(r, s);
        if (p !== null) {
          var y = Mg();
          su(p, r, s, y);
        }
        _N(r, s);
      }
    }
    function eE(r) {
      var s = ld(r);
      return s === null ? null : s.stateNode;
    }
    var tE = function(r) {
      return null;
    };
    function GU(r) {
      return tE(r);
    }
    var nE = function(r) {
      return !1;
    };
    function BU(r) {
      return nE(r);
    }
    var iE = null, rE = null, aE = null, oE = null, sE = null, lE = null, uE = null, cE = null, gE = null;
    {
      var dE = function(r, s, p) {
        var y = s[p], Z = Fr(r) ? r.slice() : Xn({}, r);
        return p + 1 === s.length ? (Fr(Z) ? Z.splice(y, 1) : delete Z[y], Z) : (Z[y] = dE(r[y], s, p + 1), Z);
      }, IE = function(r, s) {
        return dE(r, s, 0);
      }, CE = function(r, s, p, y) {
        var Z = s[y], X = Fr(r) ? r.slice() : Xn({}, r);
        if (y + 1 === s.length) {
          var K = p[y];
          X[K] = X[Z], Fr(X) ? X.splice(Z, 1) : delete X[Z];
        } else
          X[Z] = CE(
            // $FlowFixMe number or string is fine here
            r[Z],
            s,
            p,
            y + 1
          );
        return X;
      }, hE = function(r, s, p) {
        if (s.length !== p.length) {
          l("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var y = 0; y < p.length - 1; y++)
            if (s[y] !== p[y]) {
              l("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return CE(r, s, p, 0);
      }, fE = function(r, s, p, y) {
        if (p >= s.length)
          return y;
        var Z = s[p], X = Fr(r) ? r.slice() : Xn({}, r);
        return X[Z] = fE(r[Z], s, p + 1, y), X;
      }, pE = function(r, s, p) {
        return fE(r, s, 0, p);
      }, zN = function(r, s) {
        for (var p = r.memoizedState; p !== null && s > 0; )
          p = p.next, s--;
        return p;
      };
      iE = function(r, s, p, y) {
        var Z = zN(r, s);
        if (Z !== null) {
          var X = pE(Z.memoizedState, p, y);
          Z.memoizedState = X, Z.baseState = X, r.memoizedProps = Xn({}, r.memoizedProps);
          var K = Ws(r, yi);
          K !== null && su(K, r, yi, Br);
        }
      }, rE = function(r, s, p) {
        var y = zN(r, s);
        if (y !== null) {
          var Z = IE(y.memoizedState, p);
          y.memoizedState = Z, y.baseState = Z, r.memoizedProps = Xn({}, r.memoizedProps);
          var X = Ws(r, yi);
          X !== null && su(X, r, yi, Br);
        }
      }, aE = function(r, s, p, y) {
        var Z = zN(r, s);
        if (Z !== null) {
          var X = hE(Z.memoizedState, p, y);
          Z.memoizedState = X, Z.baseState = X, r.memoizedProps = Xn({}, r.memoizedProps);
          var K = Ws(r, yi);
          K !== null && su(K, r, yi, Br);
        }
      }, oE = function(r, s, p) {
        r.pendingProps = pE(r.memoizedProps, s, p), r.alternate && (r.alternate.pendingProps = r.pendingProps);
        var y = Ws(r, yi);
        y !== null && su(y, r, yi, Br);
      }, sE = function(r, s) {
        r.pendingProps = IE(r.memoizedProps, s), r.alternate && (r.alternate.pendingProps = r.pendingProps);
        var p = Ws(r, yi);
        p !== null && su(p, r, yi, Br);
      }, lE = function(r, s, p) {
        r.pendingProps = hE(r.memoizedProps, s, p), r.alternate && (r.alternate.pendingProps = r.pendingProps);
        var y = Ws(r, yi);
        y !== null && su(y, r, yi, Br);
      }, uE = function(r) {
        var s = Ws(r, yi);
        s !== null && su(s, r, yi, Br);
      }, cE = function(r) {
        tE = r;
      }, gE = function(r) {
        nE = r;
      };
    }
    function SU(r) {
      var s = eh(r);
      return s === null ? null : s.stateNode;
    }
    function ZU(r) {
      return null;
    }
    function wU() {
      return Hn;
    }
    function RU(r) {
      var s = r.findFiberByHostInstance, p = n.ReactCurrentDispatcher;
      return nh({
        bundleType: r.bundleType,
        version: r.version,
        rendererPackageName: r.rendererPackageName,
        rendererConfig: r.rendererConfig,
        overrideHookState: iE,
        overrideHookStateDeletePath: rE,
        overrideHookStateRenamePath: aE,
        overrideProps: oE,
        overridePropsDeletePath: sE,
        overridePropsRenamePath: lE,
        setErrorHandler: cE,
        setSuspenseHandler: gE,
        scheduleUpdate: uE,
        currentDispatcherRef: p,
        findHostInstanceByFiber: SU,
        findFiberByHostInstance: s || ZU,
        // React Refresh
        findHostInstancesForRefresh: rU,
        scheduleRefresh: nU,
        scheduleRoot: iU,
        setRefreshHandler: tU,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: wU,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: FN
      });
    }
    var mE = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(r) {
      console.error(r);
    };
    function KN(r) {
      this._internalRoot = r;
    }
    Yx.prototype.render = KN.prototype.render = function(r) {
      var s = this._internalRoot;
      if (s === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? u("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Fx(arguments[1]) ? u("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && u("You passed a second argument to root.render(...) but it only accepts one argument.");
        var p = s.containerInfo;
        if (p.nodeType !== Kr) {
          var y = eE(s.current);
          y && y.parentNode !== p && u("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      aZ(r, s, null, null);
    }, Yx.prototype.unmount = KN.prototype.unmount = function() {
      typeof arguments[0] == "function" && u("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var r = this._internalRoot;
      if (r !== null) {
        this._internalRoot = null;
        var s = r.containerInfo;
        WF() && u("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Im(function() {
          aZ(null, r, null, null);
        }), FR(s);
      }
    };
    function xU(r, s) {
      if (!Fx(r))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      AE(r);
      var p = !1, y = !1, Z = "", X = mE;
      s != null && (s.hydrate ? l("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof s == "object" && s !== null && s.$$typeof === Oa && u(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), s.unstable_strictMode === !0 && (p = !0), s.identifierPrefix !== void 0 && (Z = s.identifierPrefix), s.onRecoverableError !== void 0 && (X = s.onRecoverableError), s.transitionCallbacks !== void 0 && s.transitionCallbacks);
      var K = jF(r, Ov, null, p, y, Z, X);
      Kv(K.current, r);
      var j = r.nodeType === Kr ? r.parentNode : r;
      return lc(j), new KN(K);
    }
    function Yx(r) {
      this._internalRoot = r;
    }
    function WU(r) {
      r && lf(r);
    }
    Yx.prototype.unstable_scheduleHydration = WU;
    function VU(r, s, p) {
      if (!Fx(r))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      AE(r), s === void 0 && u("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var y = p ?? null, Z = p != null && p.hydratedSources || null, X = !1, K = !1, j = "", ne = mE;
      p != null && (p.unstable_strictMode === !0 && (X = !0), p.identifierPrefix !== void 0 && (j = p.identifierPrefix), p.onRecoverableError !== void 0 && (ne = p.onRecoverableError));
      var de = qF(s, null, r, Ov, y, X, K, j, ne);
      if (Kv(de.current, r), lc(r), Z)
        for (var Ge = 0; Ge < Z.length; Ge++) {
          var rt = Z[Ge];
          YV(de, rt);
        }
      return new Yx(de);
    }
    function Fx(r) {
      return !!(r && (r.nodeType === Es || r.nodeType === _a || r.nodeType === ca || !$e));
    }
    function oZ(r) {
      return !!(r && (r.nodeType === Es || r.nodeType === _a || r.nodeType === ca || r.nodeType === Kr && r.nodeValue === " react-mount-point-unstable "));
    }
    function AE(r) {
      r.nodeType === Es && r.tagName && r.tagName.toUpperCase() === "BODY" && u("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Lv(r) && (r._reactRootContainer ? u("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : u("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var NU = n.ReactCurrentOwner, vE;
    vE = function(r) {
      if (r._reactRootContainer && r.nodeType !== Kr) {
        var s = eE(r._reactRootContainer.current);
        s && s.parentNode !== r && u("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var p = !!r._reactRootContainer, y = LN(r), Z = !!(y && Sf(y));
      Z && !p && u("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), r.nodeType === Es && r.tagName && r.tagName.toUpperCase() === "BODY" && u("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function LN(r) {
      return r ? r.nodeType === _a ? r.documentElement : r.firstChild : null;
    }
    function yE() {
    }
    function MU(r, s, p, y, Z) {
      if (Z) {
        if (typeof y == "function") {
          var X = y;
          y = function() {
            var it = Xx(K);
            X.call(it);
          };
        }
        var K = qF(
          s,
          y,
          r,
          wf,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          yE
        );
        r._reactRootContainer = K, Kv(K.current, r);
        var j = r.nodeType === Kr ? r.parentNode : r;
        return lc(j), Im(), K;
      } else {
        for (var ne; ne = r.lastChild; )
          r.removeChild(ne);
        if (typeof y == "function") {
          var de = y;
          y = function() {
            var it = Xx(Ge);
            de.call(it);
          };
        }
        var Ge = jF(
          r,
          wf,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          yE
        );
        r._reactRootContainer = Ge, Kv(Ge.current, r);
        var rt = r.nodeType === Kr ? r.parentNode : r;
        return lc(rt), Im(function() {
          aZ(s, Ge, p, y);
        }), Ge;
      }
    }
    function HU(r, s) {
      r !== null && typeof r != "function" && u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s, r);
    }
    function Ex(r, s, p, y, Z) {
      vE(p), HU(Z === void 0 ? null : Z, "render");
      var X = p._reactRootContainer, K;
      if (!X)
        K = MU(p, s, r, Z, y);
      else {
        if (K = X, typeof Z == "function") {
          var j = Z;
          Z = function() {
            var ne = Xx(K);
            j.call(ne);
          };
        }
        aZ(s, K, r, Z);
      }
      return Xx(K);
    }
    var bE = !1;
    function XU(r) {
      {
        bE || (bE = !0, u("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var s = NU.current;
        if (s !== null && s.stateNode !== null) {
          var p = s.stateNode._warnedAboutRefsInRender;
          p || u("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", ci(s.type) || "A component"), s.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return r == null ? null : r.nodeType === Es ? r : AU(r, "findDOMNode");
    }
    function YU(r, s, p) {
      if (u("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !oZ(s))
        throw new Error("Target container is not a DOM element.");
      {
        var y = Lv(s) && s._reactRootContainer === void 0;
        y && u("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return Ex(null, r, s, !0, p);
    }
    function FU(r, s, p) {
      if (u("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !oZ(s))
        throw new Error("Target container is not a DOM element.");
      {
        var y = Lv(s) && s._reactRootContainer === void 0;
        y && u("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return Ex(null, r, s, !1, p);
    }
    function EU(r, s, p, y) {
      if (u("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !oZ(p))
        throw new Error("Target container is not a DOM element.");
      if (r == null || !wa(r))
        throw new Error("parentComponent must be a valid React Component");
      return Ex(r, s, p, !1, y);
    }
    var GE = !1;
    function TU(r) {
      if (GE || (GE = !0, u("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !oZ(r))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var s = Lv(r) && r._reactRootContainer === void 0;
        s && u("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (r._reactRootContainer) {
        {
          var p = LN(r), y = p && !Sf(p);
          y && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Im(function() {
          Ex(null, null, r, !1, function() {
            r._reactRootContainer = null, FR(r);
          });
        }), !0;
      } else {
        {
          var Z = LN(r), X = !!(Z && Sf(Z)), K = r.nodeType === Es && oZ(r.parentNode) && !!r.parentNode._reactRootContainer;
          X && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", K ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    gv(vU), Sp(yU), Zp(bU), Hb(Nl), dC(uv), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && u("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Rc(CR), qd(vN, VD, Im);
    function _U(r, s) {
      var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Fx(s))
        throw new Error("Target container is not a DOM element.");
      return mU(r, s, null, p);
    }
    function zU(r, s, p, y) {
      return EU(r, s, p, y);
    }
    var kN = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Sf, fl, yd, ul, kl, vN]
    };
    function KU(r, s) {
      return kN.usingClientEntryPoint || u('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), xU(r, s);
    }
    function LU(r, s, p) {
      return kN.usingClientEntryPoint || u('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), VU(r, s, p);
    }
    function kU(r) {
      return WF() && u("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Im(r);
    }
    var DU = RU({
      findFiberByHostInstance: Up,
      bundleType: 1,
      version: FN,
      rendererPackageName: "react-dom"
    });
    if (!DU && Wt && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var BE = window.location.protocol;
      /^(https?|file):$/.test(BE) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (BE === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Wd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = kN, Wd.createPortal = _U, Wd.createRoot = KU, Wd.findDOMNode = XU, Wd.flushSync = kU, Wd.hydrate = YU, Wd.hydrateRoot = LU, Wd.render = FU, Wd.unmountComponentAtNode = TU, Wd.unstable_batchedUpdates = vN, Wd.unstable_renderSubtreeIntoContainer = zU, Wd.version = FN, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(), Wd;
}
var C5 = {};
function h5() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (C5.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(h5);
    } catch (a) {
      console.error(a);
    }
  }
}
C5.NODE_ENV === "production" ? (h5(), pH.exports = iO()) : pH.exports = rO();
var cX = pH.exports;
const gX = /* @__PURE__ */ Tw(cX), aO = /* @__PURE__ */ d5({
  __proto__: null,
  default: gX
}, [cX]);
var oO = {}, gZ = cX;
if (oO.NODE_ENV === "production")
  FZ.createRoot = gZ.createRoot, FZ.hydrateRoot = gZ.hydrateRoot;
else {
  var _x = gZ.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  FZ.createRoot = function(a, e) {
    _x.usingClientEntryPoint = !0;
    try {
      return gZ.createRoot(a, e);
    } finally {
      _x.usingClientEntryPoint = !1;
    }
  }, FZ.hydrateRoot = function(a, e, t) {
    _x.usingClientEntryPoint = !0;
    try {
      return gZ.hydrateRoot(a, e, t);
    } finally {
      _x.usingClientEntryPoint = !1;
    }
  };
}
/**
 * @remix-run/router v1.19.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Ms() {
  return Ms = Object.assign ? Object.assign.bind() : function(a) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (a[n] = t[n]);
    }
    return a;
  }, Ms.apply(this, arguments);
}
var Xl;
(function(a) {
  a.Pop = "POP", a.Push = "PUSH", a.Replace = "REPLACE";
})(Xl || (Xl = {}));
const HE = "popstate";
function sO(a) {
  a === void 0 && (a = {});
  function e(i, o) {
    let {
      pathname: l = "/",
      search: u = "",
      hash: I = ""
    } = Em(i.location.hash.substr(1));
    return !l.startsWith("/") && !l.startsWith(".") && (l = "/" + l), rw(
      "",
      {
        pathname: l,
        search: u,
        hash: I
      },
      // state defaults to `null` because `window.history.state` does
      o.state && o.state.usr || null,
      o.state && o.state.key || "default"
    );
  }
  function t(i, o) {
    let l = i.document.querySelector("base"), u = "";
    if (l && l.getAttribute("href")) {
      let I = i.location.href, f = I.indexOf("#");
      u = f === -1 ? I : I.slice(0, f);
    }
    return u + "#" + (typeof o == "string" ? o : jA(o));
  }
  function n(i, o) {
    Gl(i.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(o) + ")");
  }
  return uO(e, t, n, a);
}
function ki(a, e) {
  if (a === !1 || a === null || typeof a > "u")
    throw new Error(e);
}
function Gl(a, e) {
  if (!a) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {
    }
  }
}
function lO() {
  return Math.random().toString(36).substr(2, 8);
}
function XE(a, e) {
  return {
    usr: a.state,
    key: a.key,
    idx: e
  };
}
function rw(a, e, t, n) {
  return t === void 0 && (t = null), Ms({
    pathname: typeof a == "string" ? a : a.pathname,
    search: "",
    hash: ""
  }, typeof e == "string" ? Em(e) : e, {
    state: t,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: e && e.key || n || lO()
  });
}
function jA(a) {
  let {
    pathname: e = "/",
    search: t = "",
    hash: n = ""
  } = a;
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function Em(a) {
  let e = {};
  if (a) {
    let t = a.indexOf("#");
    t >= 0 && (e.hash = a.substr(t), a = a.substr(0, t));
    let n = a.indexOf("?");
    n >= 0 && (e.search = a.substr(n), a = a.substr(0, n)), a && (e.pathname = a);
  }
  return e;
}
function uO(a, e, t, n) {
  n === void 0 && (n = {});
  let {
    window: i = document.defaultView,
    v5Compat: o = !1
  } = n, l = i.history, u = Xl.Pop, I = null, f = h();
  f == null && (f = 0, l.replaceState(Ms({}, l.state, {
    idx: f
  }), ""));
  function h() {
    return (l.state || {
      idx: null
    }).idx;
  }
  function v() {
    u = Xl.Pop;
    let x = h(), M = x == null ? null : x - f;
    f = x, I && I({
      action: u,
      location: W.location,
      delta: M
    });
  }
  function b(x, M) {
    u = Xl.Push;
    let T = rw(W.location, x, M);
    t && t(T, x), f = h() + 1;
    let E = XE(T, f), _ = W.createHref(T);
    try {
      l.pushState(E, "", _);
    } catch (P) {
      if (P instanceof DOMException && P.name === "DataCloneError")
        throw P;
      i.location.assign(_);
    }
    o && I && I({
      action: u,
      location: W.location,
      delta: 1
    });
  }
  function S(x, M) {
    u = Xl.Replace;
    let T = rw(W.location, x, M);
    t && t(T, x), f = h();
    let E = XE(T, f), _ = W.createHref(T);
    l.replaceState(E, "", _), o && I && I({
      action: u,
      location: W.location,
      delta: 0
    });
  }
  function R(x) {
    let M = i.location.origin !== "null" ? i.location.origin : i.location.href, T = typeof x == "string" ? x : jA(x);
    return T = T.replace(/ $/, "%20"), ki(M, "No window.location.(origin|href) available to create URL for href: " + T), new URL(T, M);
  }
  let W = {
    get action() {
      return u;
    },
    get location() {
      return a(i, l);
    },
    listen(x) {
      if (I)
        throw new Error("A history only accepts one active listener");
      return i.addEventListener(HE, v), I = x, () => {
        i.removeEventListener(HE, v), I = null;
      };
    },
    createHref(x) {
      return e(i, x);
    },
    createURL: R,
    encodeLocation(x) {
      let M = R(x);
      return {
        pathname: M.pathname,
        search: M.search,
        hash: M.hash
      };
    },
    push: b,
    replace: S,
    go(x) {
      return l.go(x);
    }
  };
  return W;
}
var So;
(function(a) {
  a.data = "data", a.deferred = "deferred", a.redirect = "redirect", a.error = "error";
})(So || (So = {}));
const cO = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function gO(a) {
  return a.index === !0;
}
function aw(a, e, t, n) {
  return t === void 0 && (t = []), n === void 0 && (n = {}), a.map((i, o) => {
    let l = [...t, String(o)], u = typeof i.id == "string" ? i.id : l.join("-");
    if (ki(i.index !== !0 || !i.children, "Cannot specify children on an index route"), ki(!n[u], 'Found a route id collision on id "' + u + `".  Route id's must be globally unique within Data Router usages`), gO(i)) {
      let I = Ms({}, i, e(i), {
        id: u
      });
      return n[u] = I, I;
    } else {
      let I = Ms({}, i, e(i), {
        id: u,
        children: void 0
      });
      return n[u] = I, i.children && (I.children = aw(i.children, e, l, n)), I;
    }
  });
}
function qy(a, e, t) {
  return t === void 0 && (t = "/"), U1(a, e, t, !1);
}
function U1(a, e, t, n) {
  let i = typeof e == "string" ? Em(e) : e, o = Th(i.pathname || "/", t);
  if (o == null)
    return null;
  let l = f5(a);
  IO(l);
  let u = null;
  for (let I = 0; u == null && I < l.length; ++I) {
    let f = BO(o);
    u = bO(l[I], f, n);
  }
  return u;
}
function dO(a, e) {
  let {
    route: t,
    pathname: n,
    params: i
  } = a;
  return {
    id: t.id,
    pathname: n,
    params: i,
    data: e[t.id],
    handle: t.handle
  };
}
function f5(a, e, t, n) {
  e === void 0 && (e = []), t === void 0 && (t = []), n === void 0 && (n = "");
  let i = (o, l, u) => {
    let I = {
      relativePath: u === void 0 ? o.path || "" : u,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: l,
      route: o
    };
    I.relativePath.startsWith("/") && (ki(I.relativePath.startsWith(n), 'Absolute route path "' + I.relativePath + '" nested under path ' + ('"' + n + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), I.relativePath = I.relativePath.slice(n.length));
    let f = op([n, I.relativePath]), h = t.concat(I);
    o.children && o.children.length > 0 && (ki(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      o.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + f + '".')
    ), f5(o.children, e, h, f)), !(o.path == null && !o.index) && e.push({
      path: f,
      score: vO(f, o.index),
      routesMeta: h
    });
  };
  return a.forEach((o, l) => {
    var u;
    if (o.path === "" || !((u = o.path) != null && u.includes("?")))
      i(o, l);
    else
      for (let I of p5(o.path))
        i(o, l, I);
  }), e;
}
function p5(a) {
  let e = a.split("/");
  if (e.length === 0) return [];
  let [t, ...n] = e, i = t.endsWith("?"), o = t.replace(/\?$/, "");
  if (n.length === 0)
    return i ? [o, ""] : [o];
  let l = p5(n.join("/")), u = [];
  return u.push(...l.map((I) => I === "" ? o : [o, I].join("/"))), i && u.push(...l), u.map((I) => a.startsWith("/") && I === "" ? "/" : I);
}
function IO(a) {
  a.sort((e, t) => e.score !== t.score ? t.score - e.score : yO(e.routesMeta.map((n) => n.childrenIndex), t.routesMeta.map((n) => n.childrenIndex)));
}
const CO = /^:[\w-]+$/, hO = 3, fO = 2, pO = 1, mO = 10, AO = -2, YE = (a) => a === "*";
function vO(a, e) {
  let t = a.split("/"), n = t.length;
  return t.some(YE) && (n += AO), e && (n += fO), t.filter((i) => !YE(i)).reduce((i, o) => i + (CO.test(o) ? hO : o === "" ? pO : mO), n);
}
function yO(a, e) {
  return a.length === e.length && a.slice(0, -1).every((n, i) => n === e[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - e[e.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function bO(a, e, t) {
  t === void 0 && (t = !1);
  let {
    routesMeta: n
  } = a, i = {}, o = "/", l = [];
  for (let u = 0; u < n.length; ++u) {
    let I = n[u], f = u === n.length - 1, h = o === "/" ? e : e.slice(o.length) || "/", v = i2({
      path: I.relativePath,
      caseSensitive: I.caseSensitive,
      end: f
    }, h), b = I.route;
    if (!v && f && t && !n[n.length - 1].route.index && (v = i2({
      path: I.relativePath,
      caseSensitive: I.caseSensitive,
      end: !1
    }, h)), !v)
      return null;
    Object.assign(i, v.params), l.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: op([o, v.pathname]),
      pathnameBase: wO(op([o, v.pathnameBase])),
      route: b
    }), v.pathnameBase !== "/" && (o = op([o, v.pathnameBase]));
  }
  return l;
}
function i2(a, e) {
  typeof a == "string" && (a = {
    path: a,
    caseSensitive: !1,
    end: !0
  });
  let [t, n] = GO(a.path, a.caseSensitive, a.end), i = e.match(t);
  if (!i) return null;
  let o = i[0], l = o.replace(/(.)\/+$/, "$1"), u = i.slice(1);
  return {
    params: n.reduce((f, h, v) => {
      let {
        paramName: b,
        isOptional: S
      } = h;
      if (b === "*") {
        let W = u[v] || "";
        l = o.slice(0, o.length - W.length).replace(/(.)\/+$/, "$1");
      }
      const R = u[v];
      return S && !R ? f[b] = void 0 : f[b] = (R || "").replace(/%2F/g, "/"), f;
    }, {}),
    pathname: o,
    pathnameBase: l,
    pattern: a
  };
}
function GO(a, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !0), Gl(a === "*" || !a.endsWith("*") || a.endsWith("/*"), 'Route path "' + a + '" will be treated as if it were ' + ('"' + a.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + a.replace(/\*$/, "/*") + '".'));
  let n = [], i = "^" + a.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (l, u, I) => (n.push({
    paramName: u,
    isOptional: I != null
  }), I ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return a.endsWith("*") ? (n.push({
    paramName: "*"
  }), i += a === "*" || a === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? i += "\\/*$" : a !== "" && a !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), n];
}
function BO(a) {
  try {
    return a.split("/").map((e) => decodeURIComponent(e).replace(/\//g, "%2F")).join("/");
  } catch (e) {
    return Gl(!1, 'The URL path "' + a + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), a;
  }
}
function Th(a, e) {
  if (e === "/") return a;
  if (!a.toLowerCase().startsWith(e.toLowerCase()))
    return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length, n = a.charAt(t);
  return n && n !== "/" ? null : a.slice(t) || "/";
}
function SO(a, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: n = "",
    hash: i = ""
  } = typeof a == "string" ? Em(a) : a;
  return {
    pathname: t ? t.startsWith("/") ? t : ZO(t, e) : e,
    search: RO(n),
    hash: xO(i)
  };
}
function ZO(a, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return a.split("/").forEach((i) => {
    i === ".." ? t.length > 1 && t.pop() : i !== "." && t.push(i);
  }), t.length > 1 ? t.join("/") : "/";
}
function ON(a, e, t, n) {
  return "Cannot include a '" + a + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(n) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function m5(a) {
  return a.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0);
}
function nW(a, e) {
  let t = m5(a);
  return e ? t.map((n, i) => i === t.length - 1 ? n.pathname : n.pathnameBase) : t.map((n) => n.pathnameBase);
}
function iW(a, e, t, n) {
  n === void 0 && (n = !1);
  let i;
  typeof a == "string" ? i = Em(a) : (i = Ms({}, a), ki(!i.pathname || !i.pathname.includes("?"), ON("?", "pathname", "search", i)), ki(!i.pathname || !i.pathname.includes("#"), ON("#", "pathname", "hash", i)), ki(!i.search || !i.search.includes("#"), ON("#", "search", "hash", i)));
  let o = a === "" || i.pathname === "", l = o ? "/" : i.pathname, u;
  if (l == null)
    u = t;
  else {
    let v = e.length - 1;
    if (!n && l.startsWith("..")) {
      let b = l.split("/");
      for (; b[0] === ".."; )
        b.shift(), v -= 1;
      i.pathname = b.join("/");
    }
    u = v >= 0 ? e[v] : "/";
  }
  let I = SO(i, u), f = l && l !== "/" && l.endsWith("/"), h = (o || l === ".") && t.endsWith("/");
  return !I.pathname.endsWith("/") && (f || h) && (I.pathname += "/"), I;
}
const op = (a) => a.join("/").replace(/\/\/+/g, "/"), wO = (a) => a.replace(/\/+$/, "").replace(/^\/*/, "/"), RO = (a) => !a || a === "?" ? "" : a.startsWith("?") ? a : "?" + a, xO = (a) => !a || a === "#" ? "" : a.startsWith("#") ? a : "#" + a;
class r2 {
  constructor(e, t, n, i) {
    i === void 0 && (i = !1), this.status = e, this.statusText = t || "", this.internal = i, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n;
  }
}
function rW(a) {
  return a != null && typeof a.status == "number" && typeof a.statusText == "string" && typeof a.internal == "boolean" && "data" in a;
}
const A5 = ["post", "put", "patch", "delete"], WO = new Set(A5), VO = ["get", ...A5], NO = new Set(VO), MO = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), HO = /* @__PURE__ */ new Set([307, 308]), PN = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, XO = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, dZ = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, dX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, YO = (a) => ({
  hasErrorBoundary: !!a.hasErrorBoundary
}), v5 = "remix-router-transitions";
function FO(a) {
  const e = a.window ? a.window : typeof window < "u" ? window : void 0, t = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u", n = !t;
  ki(a.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let i;
  if (a.mapRouteProperties)
    i = a.mapRouteProperties;
  else if (a.detectErrorBoundary) {
    let Le = a.detectErrorBoundary;
    i = (qe) => ({
      hasErrorBoundary: Le(qe)
    });
  } else
    i = YO;
  let o = {}, l = aw(a.routes, i, void 0, o), u, I = a.basename || "/", f = a.unstable_dataStrategy || KO, h = a.unstable_patchRoutesOnNavigation, v = Ms({
    v7_fetcherPersist: !1,
    v7_normalizeFormMethod: !1,
    v7_partialHydration: !1,
    v7_prependBasename: !1,
    v7_relativeSplatPath: !1,
    v7_skipActionErrorRevalidation: !1
  }, a.future), b = null, S = /* @__PURE__ */ new Set(), R = 1e3, W = /* @__PURE__ */ new Set(), x = null, M = null, T = null, E = a.hydrationData != null, _ = qy(l, a.history.location, I), P = null;
  if (_ == null && !h) {
    let Le = Eg(404, {
      pathname: a.history.location.pathname
    }), {
      matches: qe,
      route: gt
    } = UE(l);
    _ = qe, P = {
      [gt.id]: Le
    };
  }
  _ && !a.hydrationData && Sa(_, l, a.history.location.pathname).active && (_ = null);
  let U;
  if (_)
    if (_.some((Le) => Le.route.lazy))
      U = !1;
    else if (!_.some((Le) => Le.route.loader))
      U = !0;
    else if (v.v7_partialHydration) {
      let Le = a.hydrationData ? a.hydrationData.loaderData : null, qe = a.hydrationData ? a.hydrationData.errors : null, gt = (Pt) => Pt.route.loader ? typeof Pt.route.loader == "function" && Pt.route.loader.hydrate === !0 ? !1 : Le && Le[Pt.route.id] !== void 0 || qe && qe[Pt.route.id] !== void 0 : !0;
      if (qe) {
        let Pt = _.findIndex((me) => qe[me.route.id] !== void 0);
        U = _.slice(0, Pt + 1).every(gt);
      } else
        U = _.every(gt);
    } else
      U = a.hydrationData != null;
  else if (U = !1, _ = [], v.v7_partialHydration) {
    let Le = Sa(null, l, a.history.location.pathname);
    Le.active && Le.matches && (_ = Le.matches);
  }
  let q, k = {
    historyAction: a.history.action,
    location: a.history.location,
    matches: _,
    initialized: U,
    navigation: PN,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: a.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: a.hydrationData && a.hydrationData.loaderData || {},
    actionData: a.hydrationData && a.hydrationData.actionData || null,
    errors: a.hydrationData && a.hydrationData.errors || P,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, O = Xl.Pop, J = !1, te, fe = !1, pe = /* @__PURE__ */ new Map(), Ae = null, Te = !1, Ke = !1, je = [], ee = /* @__PURE__ */ new Set(), Ce = /* @__PURE__ */ new Map(), be = 0, le = -1, Ye = /* @__PURE__ */ new Map(), $e = /* @__PURE__ */ new Set(), ke = /* @__PURE__ */ new Map(), ot = /* @__PURE__ */ new Map(), wt = /* @__PURE__ */ new Set(), St = /* @__PURE__ */ new Map(), ln = /* @__PURE__ */ new Map(), hn = /* @__PURE__ */ new Map(), mn = !1;
  function Pn() {
    if (b = a.history.listen((Le) => {
      let {
        action: qe,
        location: gt,
        delta: Pt
      } = Le;
      if (mn) {
        mn = !1;
        return;
      }
      Gl(ln.size === 0 || Pt != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let me = Ht({
        currentLocation: k.location,
        nextLocation: gt,
        historyAction: qe
      });
      if (me && Pt != null) {
        mn = !0, a.history.go(Pt * -1), ht(me, {
          state: "blocked",
          location: gt,
          proceed() {
            ht(me, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: gt
            }), a.history.go(Pt);
          },
          reset() {
            let ut = new Map(k.blockers);
            ut.set(me, dZ), Wt({
              blockers: ut
            });
          }
        });
        return;
      }
      return nn(qe, gt);
    }), t) {
      tP(e, pe);
      let Le = () => nP(e, pe);
      e.addEventListener("pagehide", Le), Ae = () => e.removeEventListener("pagehide", Le);
    }
    return k.initialized || nn(Xl.Pop, k.location, {
      initialHydration: !0
    }), q;
  }
  function he() {
    b && b(), Ae && Ae(), S.clear(), te && te.abort(), k.fetchers.forEach((Le, qe) => Ie(qe)), k.blockers.forEach((Le, qe) => _e(qe));
  }
  function Lt(Le) {
    return S.add(Le), () => S.delete(Le);
  }
  function Wt(Le, qe) {
    qe === void 0 && (qe = {}), k = Ms({}, k, Le);
    let gt = [], Pt = [];
    v.v7_fetcherPersist && k.fetchers.forEach((me, ut) => {
      me.state === "idle" && (wt.has(ut) ? Pt.push(ut) : gt.push(ut));
    }), [...S].forEach((me) => me(k, {
      deletedFetchers: Pt,
      unstable_viewTransitionOpts: qe.viewTransitionOpts,
      unstable_flushSync: qe.flushSync === !0
    })), v.v7_fetcherPersist && (gt.forEach((me) => k.fetchers.delete(me)), Pt.forEach((me) => Ie(me)));
  }
  function tn(Le, qe, gt) {
    var Pt, me;
    let {
      flushSync: ut
    } = gt === void 0 ? {} : gt, Bt = k.actionData != null && k.navigation.formMethod != null && Fh(k.navigation.formMethod) && k.navigation.state === "loading" && ((Pt = Le.state) == null ? void 0 : Pt._isRedirect) !== !0, Tt;
    qe.actionData ? Object.keys(qe.actionData).length > 0 ? Tt = qe.actionData : Tt = null : Bt ? Tt = k.actionData : Tt = null;
    let ae = qe.loaderData ? kE(k.loaderData, qe.loaderData, qe.matches || [], qe.errors) : k.loaderData, we = k.blockers;
    we.size > 0 && (we = new Map(we), we.forEach((Oe, Nt) => we.set(Nt, dZ)));
    let Ee = J === !0 || k.navigation.formMethod != null && Fh(k.navigation.formMethod) && ((me = Le.state) == null ? void 0 : me._isRedirect) !== !0;
    u && (l = u, u = void 0), Te || O === Xl.Pop || (O === Xl.Push ? a.history.push(Le, Le.state) : O === Xl.Replace && a.history.replace(Le, Le.state));
    let Ue;
    if (O === Xl.Pop) {
      let Oe = pe.get(k.location.pathname);
      Oe && Oe.has(Le.pathname) ? Ue = {
        currentLocation: k.location,
        nextLocation: Le
      } : pe.has(Le.pathname) && (Ue = {
        currentLocation: Le,
        nextLocation: k.location
      });
    } else if (fe) {
      let Oe = pe.get(k.location.pathname);
      Oe ? Oe.add(Le.pathname) : (Oe = /* @__PURE__ */ new Set([Le.pathname]), pe.set(k.location.pathname, Oe)), Ue = {
        currentLocation: k.location,
        nextLocation: Le
      };
    }
    Wt(Ms({}, qe, {
      actionData: Tt,
      loaderData: ae,
      historyAction: O,
      location: Le,
      initialized: !0,
      navigation: PN,
      revalidation: "idle",
      restoreScrollPosition: Cr(Le, qe.matches || k.matches),
      preventScrollReset: Ee,
      blockers: we
    }), {
      viewTransitionOpts: Ue,
      flushSync: ut === !0
    }), O = Xl.Pop, J = !1, fe = !1, Te = !1, Ke = !1, je = [];
  }
  async function Gt(Le, qe) {
    if (typeof Le == "number") {
      a.history.go(Le);
      return;
    }
    let gt = mH(k.location, k.matches, I, v.v7_prependBasename, Le, v.v7_relativeSplatPath, qe?.fromRouteId, qe?.relative), {
      path: Pt,
      submission: me,
      error: ut
    } = FE(v.v7_normalizeFormMethod, !1, gt, qe), Bt = k.location, Tt = rw(k.location, Pt, qe && qe.state);
    Tt = Ms({}, Tt, a.history.encodeLocation(Tt));
    let ae = qe && qe.replace != null ? qe.replace : void 0, we = Xl.Push;
    ae === !0 ? we = Xl.Replace : ae === !1 || me != null && Fh(me.formMethod) && me.formAction === k.location.pathname + k.location.search && (we = Xl.Replace);
    let Ee = qe && "preventScrollReset" in qe ? qe.preventScrollReset === !0 : void 0, Ue = (qe && qe.unstable_flushSync) === !0, Oe = Ht({
      currentLocation: Bt,
      nextLocation: Tt,
      historyAction: we
    });
    if (Oe) {
      ht(Oe, {
        state: "blocked",
        location: Tt,
        proceed() {
          ht(Oe, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: Tt
          }), Gt(Le, qe);
        },
        reset() {
          let Nt = new Map(k.blockers);
          Nt.set(Oe, dZ), Wt({
            blockers: Nt
          });
        }
      });
      return;
    }
    return await nn(we, Tt, {
      submission: me,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: ut,
      preventScrollReset: Ee,
      replace: qe && qe.replace,
      enableViewTransition: qe && qe.unstable_viewTransition,
      flushSync: Ue
    });
  }
  function Rn() {
    if (qn(), Wt({
      revalidation: "loading"
    }), k.navigation.state !== "submitting") {
      if (k.navigation.state === "idle") {
        nn(k.historyAction, k.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      nn(O || k.historyAction, k.navigation.location, {
        overrideNavigation: k.navigation
      });
    }
  }
  async function nn(Le, qe, gt) {
    te && te.abort(), te = null, O = Le, Te = (gt && gt.startUninterruptedRevalidation) === !0, pi(k.location, k.matches), J = (gt && gt.preventScrollReset) === !0, fe = (gt && gt.enableViewTransition) === !0;
    let Pt = u || l, me = gt && gt.overrideNavigation, ut = qy(Pt, qe, I), Bt = (gt && gt.flushSync) === !0, Tt = Sa(ut, Pt, qe.pathname);
    if (Tt.active && Tt.matches && (ut = Tt.matches), !ut) {
      let {
        error: Kt,
        notFoundMatches: vn,
        route: Yt
      } = an(qe.pathname);
      tn(qe, {
        matches: vn,
        loaderData: {},
        errors: {
          [Yt.id]: Kt
        }
      }, {
        flushSync: Bt
      });
      return;
    }
    if (k.initialized && !Ke && PO(k.location, qe) && !(gt && gt.submission && Fh(gt.submission.formMethod))) {
      tn(qe, {
        matches: ut
      }, {
        flushSync: Bt
      });
      return;
    }
    te = new AbortController();
    let ae = sG(a.history, qe, te.signal, gt && gt.submission), we;
    if (gt && gt.pendingError)
      we = [YG(ut).route.id, {
        type: So.error,
        error: gt.pendingError
      }];
    else if (gt && gt.submission && Fh(gt.submission.formMethod)) {
      let Kt = await Bn(ae, qe, gt.submission, ut, Tt.active, {
        replace: gt.replace,
        flushSync: Bt
      });
      if (Kt.shortCircuited)
        return;
      if (Kt.pendingActionResult) {
        let [vn, Yt] = Kt.pendingActionResult;
        if (YI(Yt) && rW(Yt.error) && Yt.error.status === 404) {
          te = null, tn(qe, {
            matches: Kt.matches,
            loaderData: {},
            errors: {
              [vn]: Yt.error
            }
          });
          return;
        }
      }
      ut = Kt.matches || ut, we = Kt.pendingActionResult, me = JN(qe, gt.submission), Bt = !1, Tt.active = !1, ae = sG(a.history, ae.url, ae.signal);
    }
    let {
      shortCircuited: Ee,
      matches: Ue,
      loaderData: Oe,
      errors: Nt
    } = await Se(ae, qe, ut, Tt.active, me, gt && gt.submission, gt && gt.fetcherSubmission, gt && gt.replace, gt && gt.initialHydration === !0, Bt, we);
    Ee || (te = null, tn(qe, Ms({
      matches: Ue || ut
    }, DE(we), {
      loaderData: Oe,
      errors: Nt
    })));
  }
  async function Bn(Le, qe, gt, Pt, me, ut) {
    ut === void 0 && (ut = {}), qn();
    let Bt = $O(qe, gt);
    if (Wt({
      navigation: Bt
    }, {
      flushSync: ut.flushSync === !0
    }), me) {
      let we = await zr(Pt, qe.pathname, Le.signal);
      if (we.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (we.type === "error") {
        let {
          boundaryId: Ee,
          error: Ue
        } = fi(qe.pathname, we);
        return {
          matches: we.partialMatches,
          pendingActionResult: [Ee, {
            type: So.error,
            error: Ue
          }]
        };
      } else if (we.matches)
        Pt = we.matches;
      else {
        let {
          notFoundMatches: Ee,
          error: Ue,
          route: Oe
        } = an(qe.pathname);
        return {
          matches: Ee,
          pendingActionResult: [Oe.id, {
            type: So.error,
            error: Ue
          }]
        };
      }
    }
    let Tt, ae = EZ(Pt, qe);
    if (!ae.route.action && !ae.route.lazy)
      Tt = {
        type: So.error,
        error: Eg(405, {
          method: Le.method,
          pathname: qe.pathname,
          routeId: ae.route.id
        })
      };
    else if (Tt = (await rn("action", Le, [ae], Pt))[0], Le.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (ib(Tt)) {
      let we;
      return ut && ut.replace != null ? we = ut.replace : we = zE(Tt.response.headers.get("Location"), new URL(Le.url), I) === k.location.pathname + k.location.search, await Sn(Le, Tt, {
        submission: gt,
        replace: we
      }), {
        shortCircuited: !0
      };
    }
    if (nb(Tt))
      throw Eg(400, {
        type: "defer-action"
      });
    if (YI(Tt)) {
      let we = YG(Pt, ae.route.id);
      return (ut && ut.replace) !== !0 && (O = Xl.Push), {
        matches: Pt,
        pendingActionResult: [we.route.id, Tt]
      };
    }
    return {
      matches: Pt,
      pendingActionResult: [ae.route.id, Tt]
    };
  }
  async function Se(Le, qe, gt, Pt, me, ut, Bt, Tt, ae, we, Ee) {
    let Ue = me || JN(qe, ut), Oe = ut || Bt || QE(Ue), Nt = !Te && (!v.v7_partialHydration || !ae);
    if (Pt) {
      if (Nt) {
        let We = oe(Ee);
        Wt(Ms({
          navigation: Ue
        }, We !== void 0 ? {
          actionData: We
        } : {}), {
          flushSync: we
        });
      }
      let ue = await zr(gt, qe.pathname, Le.signal);
      if (ue.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (ue.type === "error") {
        let {
          boundaryId: We,
          error: et
        } = fi(qe.pathname, ue);
        return {
          matches: ue.partialMatches,
          loaderData: {},
          errors: {
            [We]: et
          }
        };
      } else if (ue.matches)
        gt = ue.matches;
      else {
        let {
          error: We,
          notFoundMatches: et,
          route: Mt
        } = an(qe.pathname);
        return {
          matches: et,
          loaderData: {},
          errors: {
            [Mt.id]: We
          }
        };
      }
    }
    let Kt = u || l, [vn, Yt] = EE(a.history, k, gt, Oe, qe, v.v7_partialHydration && ae === !0, v.v7_skipActionErrorRevalidation, Ke, je, ee, wt, ke, $e, Kt, I, Ee);
    if (xi((ue) => !(gt && gt.some((We) => We.route.id === ue)) || vn && vn.some((We) => We.route.id === ue)), le = ++be, vn.length === 0 && Yt.length === 0) {
      let ue = Ot();
      return tn(qe, Ms({
        matches: gt,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: Ee && YI(Ee[1]) ? {
          [Ee[0]]: Ee[1].error
        } : null
      }, DE(Ee), ue ? {
        fetchers: new Map(k.fetchers)
      } : {}), {
        flushSync: we
      }), {
        shortCircuited: !0
      };
    }
    if (Nt) {
      let ue = {};
      if (!Pt) {
        ue.navigation = Ue;
        let We = oe(Ee);
        We !== void 0 && (ue.actionData = We);
      }
      Yt.length > 0 && (ue.fetchers = ct(Yt)), Wt(ue, {
        flushSync: we
      });
    }
    Yt.forEach((ue) => {
      Ce.has(ue.key) && ye(ue.key), ue.controller && Ce.set(ue.key, ue.controller);
    });
    let Yn = () => Yt.forEach((ue) => ye(ue.key));
    te && te.signal.addEventListener("abort", Yn);
    let {
      loaderResults: Fn,
      fetcherResults: _n
    } = await gn(k.matches, gt, vn, Yt, Le);
    if (Le.signal.aborted)
      return {
        shortCircuited: !0
      };
    te && te.signal.removeEventListener("abort", Yn), Yt.forEach((ue) => Ce.delete(ue.key));
    let Xn = OE([...Fn, ..._n]);
    if (Xn) {
      if (Xn.idx >= vn.length) {
        let ue = Yt[Xn.idx - vn.length].key;
        $e.add(ue);
      }
      return await Sn(Le, Xn.result, {
        replace: Tt
      }), {
        shortCircuited: !0
      };
    }
    let {
      loaderData: or,
      errors: Ei
    } = LE(k, gt, vn, Fn, Ee, Yt, _n, St);
    St.forEach((ue, We) => {
      ue.subscribe((et) => {
        (et || ue.done) && St.delete(We);
      });
    }), v.v7_partialHydration && ae && k.errors && Object.entries(k.errors).filter((ue) => {
      let [We] = ue;
      return !vn.some((et) => et.route.id === We);
    }).forEach((ue) => {
      let [We, et] = ue;
      Ei = Object.assign(Ei || {}, {
        [We]: et
      });
    });
    let pr = Ot(), Ln = Re(le), ge = pr || Ln || Yt.length > 0;
    return Ms({
      matches: gt,
      loaderData: or,
      errors: Ei
    }, ge ? {
      fetchers: new Map(k.fetchers)
    } : {});
  }
  function oe(Le) {
    if (Le && !YI(Le[1]))
      return {
        [Le[0]]: Le[1].data
      };
    if (k.actionData)
      return Object.keys(k.actionData).length === 0 ? null : k.actionData;
  }
  function ct(Le) {
    return Le.forEach((qe) => {
      let gt = k.fetchers.get(qe.key), Pt = IZ(void 0, gt ? gt.data : void 0);
      k.fetchers.set(qe.key, Pt);
    }), new Map(k.fetchers);
  }
  function Ft(Le, qe, gt, Pt) {
    if (n)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    Ce.has(Le) && ye(Le);
    let me = (Pt && Pt.unstable_flushSync) === !0, ut = u || l, Bt = mH(k.location, k.matches, I, v.v7_prependBasename, gt, v.v7_relativeSplatPath, qe, Pt?.relative), Tt = qy(ut, Bt, I), ae = Sa(Tt, ut, Bt);
    if (ae.active && ae.matches && (Tt = ae.matches), !Tt) {
      An(Le, qe, Eg(404, {
        pathname: Bt
      }), {
        flushSync: me
      });
      return;
    }
    let {
      path: we,
      submission: Ee,
      error: Ue
    } = FE(v.v7_normalizeFormMethod, !0, Bt, Pt);
    if (Ue) {
      An(Le, qe, Ue, {
        flushSync: me
      });
      return;
    }
    let Oe = EZ(Tt, we);
    if (J = (Pt && Pt.preventScrollReset) === !0, Ee && Fh(Ee.formMethod)) {
      pt(Le, qe, we, Oe, Tt, ae.active, me, Ee);
      return;
    }
    ke.set(Le, {
      routeId: qe,
      path: we
    }), zt(Le, qe, we, Oe, Tt, ae.active, me, Ee);
  }
  async function pt(Le, qe, gt, Pt, me, ut, Bt, Tt) {
    qn(), ke.delete(Le);
    function ae(Mt) {
      if (!Mt.route.action && !Mt.route.lazy) {
        let bn = Eg(405, {
          method: Tt.formMethod,
          pathname: gt,
          routeId: qe
        });
        return An(Le, qe, bn, {
          flushSync: Bt
        }), !0;
      }
      return !1;
    }
    if (!ut && ae(Pt))
      return;
    let we = k.fetchers.get(Le);
    qt(Le, eP(Tt, we), {
      flushSync: Bt
    });
    let Ee = new AbortController(), Ue = sG(a.history, gt, Ee.signal, Tt);
    if (ut) {
      let Mt = await zr(me, gt, Ue.signal);
      if (Mt.type === "aborted")
        return;
      if (Mt.type === "error") {
        let {
          error: bn
        } = fi(gt, Mt);
        An(Le, qe, bn, {
          flushSync: Bt
        });
        return;
      } else if (Mt.matches) {
        if (me = Mt.matches, Pt = EZ(me, gt), ae(Pt))
          return;
      } else {
        An(Le, qe, Eg(404, {
          pathname: gt
        }), {
          flushSync: Bt
        });
        return;
      }
    }
    Ce.set(Le, Ee);
    let Oe = be, Kt = (await rn("action", Ue, [Pt], me))[0];
    if (Ue.signal.aborted) {
      Ce.get(Le) === Ee && Ce.delete(Le);
      return;
    }
    if (v.v7_fetcherPersist && wt.has(Le)) {
      if (ib(Kt) || YI(Kt)) {
        qt(Le, LA(void 0));
        return;
      }
    } else {
      if (ib(Kt))
        if (Ce.delete(Le), le > Oe) {
          qt(Le, LA(void 0));
          return;
        } else
          return $e.add(Le), qt(Le, IZ(Tt)), Sn(Ue, Kt, {
            fetcherSubmission: Tt
          });
      if (YI(Kt)) {
        An(Le, qe, Kt.error);
        return;
      }
    }
    if (nb(Kt))
      throw Eg(400, {
        type: "defer-action"
      });
    let vn = k.navigation.location || k.location, Yt = sG(a.history, vn, Ee.signal), Yn = u || l, Fn = k.navigation.state !== "idle" ? qy(Yn, k.navigation.location, I) : k.matches;
    ki(Fn, "Didn't find any matches after fetcher action");
    let _n = ++be;
    Ye.set(Le, _n);
    let Xn = IZ(Tt, Kt.data);
    k.fetchers.set(Le, Xn);
    let [or, Ei] = EE(a.history, k, Fn, Tt, vn, !1, v.v7_skipActionErrorRevalidation, Ke, je, ee, wt, ke, $e, Yn, I, [Pt.route.id, Kt]);
    Ei.filter((Mt) => Mt.key !== Le).forEach((Mt) => {
      let bn = Mt.key, Ai = k.fetchers.get(bn), ve = IZ(void 0, Ai ? Ai.data : void 0);
      k.fetchers.set(bn, ve), Ce.has(bn) && ye(bn), Mt.controller && Ce.set(bn, Mt.controller);
    }), Wt({
      fetchers: new Map(k.fetchers)
    });
    let pr = () => Ei.forEach((Mt) => ye(Mt.key));
    Ee.signal.addEventListener("abort", pr);
    let {
      loaderResults: Ln,
      fetcherResults: ge
    } = await gn(k.matches, Fn, or, Ei, Yt);
    if (Ee.signal.aborted)
      return;
    Ee.signal.removeEventListener("abort", pr), Ye.delete(Le), Ce.delete(Le), Ei.forEach((Mt) => Ce.delete(Mt.key));
    let ue = OE([...Ln, ...ge]);
    if (ue) {
      if (ue.idx >= or.length) {
        let Mt = Ei[ue.idx - or.length].key;
        $e.add(Mt);
      }
      return Sn(Yt, ue.result);
    }
    let {
      loaderData: We,
      errors: et
    } = LE(k, k.matches, or, Ln, void 0, Ei, ge, St);
    if (k.fetchers.has(Le)) {
      let Mt = LA(Kt.data);
      k.fetchers.set(Le, Mt);
    }
    Re(_n), k.navigation.state === "loading" && _n > le ? (ki(O, "Expected pending action"), te && te.abort(), tn(k.navigation.location, {
      matches: Fn,
      loaderData: We,
      errors: et,
      fetchers: new Map(k.fetchers)
    })) : (Wt({
      errors: et,
      loaderData: kE(k.loaderData, We, Fn, et),
      fetchers: new Map(k.fetchers)
    }), Ke = !1);
  }
  async function zt(Le, qe, gt, Pt, me, ut, Bt, Tt) {
    let ae = k.fetchers.get(Le);
    qt(Le, IZ(Tt, ae ? ae.data : void 0), {
      flushSync: Bt
    });
    let we = new AbortController(), Ee = sG(a.history, gt, we.signal);
    if (ut) {
      let Kt = await zr(me, gt, Ee.signal);
      if (Kt.type === "aborted")
        return;
      if (Kt.type === "error") {
        let {
          error: vn
        } = fi(gt, Kt);
        An(Le, qe, vn, {
          flushSync: Bt
        });
        return;
      } else if (Kt.matches)
        me = Kt.matches, Pt = EZ(me, gt);
      else {
        An(Le, qe, Eg(404, {
          pathname: gt
        }), {
          flushSync: Bt
        });
        return;
      }
    }
    Ce.set(Le, we);
    let Ue = be, Nt = (await rn("loader", Ee, [Pt], me))[0];
    if (nb(Nt) && (Nt = await S5(Nt, Ee.signal, !0) || Nt), Ce.get(Le) === we && Ce.delete(Le), !Ee.signal.aborted) {
      if (wt.has(Le)) {
        qt(Le, LA(void 0));
        return;
      }
      if (ib(Nt))
        if (le > Ue) {
          qt(Le, LA(void 0));
          return;
        } else {
          $e.add(Le), await Sn(Ee, Nt);
          return;
        }
      if (YI(Nt)) {
        An(Le, qe, Nt.error);
        return;
      }
      ki(!nb(Nt), "Unhandled fetcher deferred data"), qt(Le, LA(Nt.data));
    }
  }
  async function Sn(Le, qe, gt) {
    let {
      submission: Pt,
      fetcherSubmission: me,
      replace: ut
    } = gt === void 0 ? {} : gt;
    qe.response.headers.has("X-Remix-Revalidate") && (Ke = !0);
    let Bt = qe.response.headers.get("Location");
    ki(Bt, "Expected a Location header on the redirect Response"), Bt = zE(Bt, new URL(Le.url), I);
    let Tt = rw(k.location, Bt, {
      _isRedirect: !0
    });
    if (t) {
      let Nt = !1;
      if (qe.response.headers.has("X-Remix-Reload-Document"))
        Nt = !0;
      else if (dX.test(Bt)) {
        const Kt = a.history.createURL(Bt);
        Nt = // Hard reload if it's an absolute URL to a new origin
        Kt.origin !== e.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        Th(Kt.pathname, I) == null;
      }
      if (Nt) {
        ut ? e.location.replace(Bt) : e.location.assign(Bt);
        return;
      }
    }
    te = null;
    let ae = ut === !0 || qe.response.headers.has("X-Remix-Replace") ? Xl.Replace : Xl.Push, {
      formMethod: we,
      formAction: Ee,
      formEncType: Ue
    } = k.navigation;
    !Pt && !me && we && Ee && Ue && (Pt = QE(k.navigation));
    let Oe = Pt || me;
    if (HO.has(qe.response.status) && Oe && Fh(Oe.formMethod))
      await nn(ae, Tt, {
        submission: Ms({}, Oe, {
          formAction: Bt
        }),
        // Preserve this flag across redirects
        preventScrollReset: J
      });
    else {
      let Nt = JN(Tt, Pt);
      await nn(ae, Tt, {
        overrideNavigation: Nt,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: me,
        // Preserve this flag across redirects
        preventScrollReset: J
      });
    }
  }
  async function rn(Le, qe, gt, Pt) {
    try {
      let me = await LO(f, Le, qe, gt, Pt, o, i);
      return await Promise.all(me.map((ut, Bt) => {
        if (QO(ut)) {
          let Tt = ut.result;
          return {
            type: So.redirect,
            response: UO(Tt, qe, gt[Bt].route.id, Pt, I, v.v7_relativeSplatPath)
          };
        }
        return DO(ut);
      }));
    } catch (me) {
      return gt.map(() => ({
        type: So.error,
        error: me
      }));
    }
  }
  async function gn(Le, qe, gt, Pt, me) {
    let [ut, ...Bt] = await Promise.all([gt.length ? rn("loader", me, gt, qe) : [], ...Pt.map((Tt) => {
      if (Tt.matches && Tt.match && Tt.controller) {
        let ae = sG(a.history, Tt.path, Tt.controller.signal);
        return rn("loader", ae, [Tt.match], Tt.matches).then((we) => we[0]);
      } else
        return Promise.resolve({
          type: So.error,
          error: Eg(404, {
            pathname: Tt.path
          })
        });
    })]);
    return await Promise.all([JE(Le, gt, ut, ut.map(() => me.signal), !1, k.loaderData), JE(Le, Pt.map((Tt) => Tt.match), Bt, Pt.map((Tt) => Tt.controller ? Tt.controller.signal : null), !0)]), {
      loaderResults: ut,
      fetcherResults: Bt
    };
  }
  function qn() {
    Ke = !0, je.push(...xi()), ke.forEach((Le, qe) => {
      Ce.has(qe) && (ee.add(qe), ye(qe));
    });
  }
  function qt(Le, qe, gt) {
    gt === void 0 && (gt = {}), k.fetchers.set(Le, qe), Wt({
      fetchers: new Map(k.fetchers)
    }, {
      flushSync: (gt && gt.flushSync) === !0
    });
  }
  function An(Le, qe, gt, Pt) {
    Pt === void 0 && (Pt = {});
    let me = YG(k.matches, qe);
    Ie(Le), Wt({
      errors: {
        [me.route.id]: gt
      },
      fetchers: new Map(k.fetchers)
    }, {
      flushSync: (Pt && Pt.flushSync) === !0
    });
  }
  function Fe(Le) {
    return v.v7_fetcherPersist && (ot.set(Le, (ot.get(Le) || 0) + 1), wt.has(Le) && wt.delete(Le)), k.fetchers.get(Le) || XO;
  }
  function Ie(Le) {
    let qe = k.fetchers.get(Le);
    Ce.has(Le) && !(qe && qe.state === "loading" && Ye.has(Le)) && ye(Le), ke.delete(Le), Ye.delete(Le), $e.delete(Le), wt.delete(Le), ee.delete(Le), k.fetchers.delete(Le);
  }
  function at(Le) {
    if (v.v7_fetcherPersist) {
      let qe = (ot.get(Le) || 0) - 1;
      qe <= 0 ? (ot.delete(Le), wt.add(Le)) : ot.set(Le, qe);
    } else
      Ie(Le);
    Wt({
      fetchers: new Map(k.fetchers)
    });
  }
  function ye(Le) {
    let qe = Ce.get(Le);
    ki(qe, "Expected fetch controller: " + Le), qe.abort(), Ce.delete(Le);
  }
  function Pe(Le) {
    for (let qe of Le) {
      let gt = Fe(qe), Pt = LA(gt.data);
      k.fetchers.set(qe, Pt);
    }
  }
  function Ot() {
    let Le = [], qe = !1;
    for (let gt of $e) {
      let Pt = k.fetchers.get(gt);
      ki(Pt, "Expected fetcher: " + gt), Pt.state === "loading" && ($e.delete(gt), Le.push(gt), qe = !0);
    }
    return Pe(Le), qe;
  }
  function Re(Le) {
    let qe = [];
    for (let [gt, Pt] of Ye)
      if (Pt < Le) {
        let me = k.fetchers.get(gt);
        ki(me, "Expected fetcher: " + gt), me.state === "loading" && (ye(gt), Ye.delete(gt), qe.push(gt));
      }
    return Pe(qe), qe.length > 0;
  }
  function lt(Le, qe) {
    let gt = k.blockers.get(Le) || dZ;
    return ln.get(Le) !== qe && ln.set(Le, qe), gt;
  }
  function _e(Le) {
    k.blockers.delete(Le), ln.delete(Le);
  }
  function ht(Le, qe) {
    let gt = k.blockers.get(Le) || dZ;
    ki(gt.state === "unblocked" && qe.state === "blocked" || gt.state === "blocked" && qe.state === "blocked" || gt.state === "blocked" && qe.state === "proceeding" || gt.state === "blocked" && qe.state === "unblocked" || gt.state === "proceeding" && qe.state === "unblocked", "Invalid blocker state transition: " + gt.state + " -> " + qe.state);
    let Pt = new Map(k.blockers);
    Pt.set(Le, qe), Wt({
      blockers: Pt
    });
  }
  function Ht(Le) {
    let {
      currentLocation: qe,
      nextLocation: gt,
      historyAction: Pt
    } = Le;
    if (ln.size === 0)
      return;
    ln.size > 1 && Gl(!1, "A router only supports one blocker at a time");
    let me = Array.from(ln.entries()), [ut, Bt] = me[me.length - 1], Tt = k.blockers.get(ut);
    if (!(Tt && Tt.state === "proceeding") && Bt({
      currentLocation: qe,
      nextLocation: gt,
      historyAction: Pt
    }))
      return ut;
  }
  function an(Le) {
    let qe = Eg(404, {
      pathname: Le
    }), gt = u || l, {
      matches: Pt,
      route: me
    } = UE(gt);
    return xi(), {
      notFoundMatches: Pt,
      route: me,
      error: qe
    };
  }
  function fi(Le, qe) {
    return {
      boundaryId: YG(qe.partialMatches).route.id,
      error: Eg(400, {
        type: "route-discovery",
        pathname: Le,
        message: qe.error != null && "message" in qe.error ? qe.error : String(qe.error)
      })
    };
  }
  function xi(Le) {
    let qe = [];
    return St.forEach((gt, Pt) => {
      (!Le || Le(Pt)) && (gt.cancel(), qe.push(Pt), St.delete(Pt));
    }), qe;
  }
  function Ir(Le, qe, gt) {
    if (x = Le, T = qe, M = gt || null, !E && k.navigation === PN) {
      E = !0;
      let Pt = Cr(k.location, k.matches);
      Pt != null && Wt({
        restoreScrollPosition: Pt
      });
    }
    return () => {
      x = null, T = null, M = null;
    };
  }
  function Xi(Le, qe) {
    return M && M(Le, qe.map((Pt) => dO(Pt, k.loaderData))) || Le.key;
  }
  function pi(Le, qe) {
    if (x && T) {
      let gt = Xi(Le, qe);
      x[gt] = T();
    }
  }
  function Cr(Le, qe) {
    if (x) {
      let gt = Xi(Le, qe), Pt = x[gt];
      if (typeof Pt == "number")
        return Pt;
    }
    return null;
  }
  function Sa(Le, qe, gt) {
    if (h) {
      if (W.has(gt))
        return {
          active: !1,
          matches: Le
        };
      if (Le) {
        if (Object.keys(Le[0].params).length > 0)
          return {
            active: !0,
            matches: U1(qe, gt, I, !0)
          };
      } else
        return {
          active: !0,
          matches: U1(qe, gt, I, !0) || []
        };
    }
    return {
      active: !1,
      matches: null
    };
  }
  async function zr(Le, qe, gt) {
    let Pt = Le;
    for (; ; ) {
      let me = u == null, ut = u || l;
      try {
        await zO(h, qe, Pt, ut, o, i, hn, gt);
      } catch (ae) {
        return {
          type: "error",
          error: ae,
          partialMatches: Pt
        };
      } finally {
        me && (l = [...l]);
      }
      if (gt.aborted)
        return {
          type: "aborted"
        };
      let Bt = qy(ut, qe, I);
      if (Bt)
        return na(qe, W), {
          type: "success",
          matches: Bt
        };
      let Tt = U1(ut, qe, I, !0);
      if (!Tt || Pt.length === Tt.length && Pt.every((ae, we) => ae.route.id === Tt[we].route.id))
        return na(qe, W), {
          type: "success",
          matches: null
        };
      Pt = Tt;
    }
  }
  function na(Le, qe) {
    if (qe.size >= R) {
      let gt = qe.values().next().value;
      qe.delete(gt);
    }
    qe.add(Le);
  }
  function la(Le) {
    o = {}, u = aw(Le, i, void 0, o);
  }
  function Oa(Le, qe) {
    let gt = u == null;
    b5(Le, qe, u || l, o, i), gt && (l = [...l], Wt({}));
  }
  return q = {
    get basename() {
      return I;
    },
    get future() {
      return v;
    },
    get state() {
      return k;
    },
    get routes() {
      return l;
    },
    get window() {
      return e;
    },
    initialize: Pn,
    subscribe: Lt,
    enableScrollRestoration: Ir,
    navigate: Gt,
    fetch: Ft,
    revalidate: Rn,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (Le) => a.history.createHref(Le),
    encodeLocation: (Le) => a.history.encodeLocation(Le),
    getFetcher: Fe,
    deleteFetcher: at,
    dispose: he,
    getBlocker: lt,
    deleteBlocker: _e,
    patchRoutes: Oa,
    _internalFetchControllers: Ce,
    _internalActiveDeferreds: St,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: la
  }, q;
}
function EO(a) {
  return a != null && ("formData" in a && a.formData != null || "body" in a && a.body !== void 0);
}
function mH(a, e, t, n, i, o, l, u) {
  let I, f;
  if (l) {
    I = [];
    for (let v of e)
      if (I.push(v), v.route.id === l) {
        f = v;
        break;
      }
  } else
    I = e, f = e[e.length - 1];
  let h = iW(i || ".", nW(I, o), Th(a.pathname, t) || a.pathname, u === "path");
  return i == null && (h.search = a.search, h.hash = a.hash), (i == null || i === "" || i === ".") && f && f.route.index && !IX(h.search) && (h.search = h.search ? h.search.replace(/^\?/, "?index&") : "?index"), n && t !== "/" && (h.pathname = h.pathname === "/" ? t : op([t, h.pathname])), jA(h);
}
function FE(a, e, t, n) {
  if (!n || !EO(n))
    return {
      path: t
    };
  if (n.formMethod && !qO(n.formMethod))
    return {
      path: t,
      error: Eg(405, {
        method: n.formMethod
      })
    };
  let i = () => ({
    path: t,
    error: Eg(400, {
      type: "invalid-body"
    })
  }), o = n.formMethod || "get", l = a ? o.toUpperCase() : o.toLowerCase(), u = G5(t);
  if (n.body !== void 0) {
    if (n.formEncType === "text/plain") {
      if (!Fh(l))
        return i();
      let b = typeof n.body == "string" ? n.body : n.body instanceof FormData || n.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(n.body.entries()).reduce((S, R) => {
          let [W, x] = R;
          return "" + S + W + "=" + x + `
`;
        }, "")
      ) : String(n.body);
      return {
        path: t,
        submission: {
          formMethod: l,
          formAction: u,
          formEncType: n.formEncType,
          formData: void 0,
          json: void 0,
          text: b
        }
      };
    } else if (n.formEncType === "application/json") {
      if (!Fh(l))
        return i();
      try {
        let b = typeof n.body == "string" ? JSON.parse(n.body) : n.body;
        return {
          path: t,
          submission: {
            formMethod: l,
            formAction: u,
            formEncType: n.formEncType,
            formData: void 0,
            json: b,
            text: void 0
          }
        };
      } catch {
        return i();
      }
    }
  }
  ki(typeof FormData == "function", "FormData is not available in this environment");
  let I, f;
  if (n.formData)
    I = AH(n.formData), f = n.formData;
  else if (n.body instanceof FormData)
    I = AH(n.body), f = n.body;
  else if (n.body instanceof URLSearchParams)
    I = n.body, f = KE(I);
  else if (n.body == null)
    I = new URLSearchParams(), f = new FormData();
  else
    try {
      I = new URLSearchParams(n.body), f = KE(I);
    } catch {
      return i();
    }
  let h = {
    formMethod: l,
    formAction: u,
    formEncType: n && n.formEncType || "application/x-www-form-urlencoded",
    formData: f,
    json: void 0,
    text: void 0
  };
  if (Fh(h.formMethod))
    return {
      path: t,
      submission: h
    };
  let v = Em(t);
  return e && v.search && IX(v.search) && I.append("index", ""), v.search = "?" + I, {
    path: jA(v),
    submission: h
  };
}
function TO(a, e) {
  let t = a;
  if (e) {
    let n = a.findIndex((i) => i.route.id === e);
    n >= 0 && (t = a.slice(0, n));
  }
  return t;
}
function EE(a, e, t, n, i, o, l, u, I, f, h, v, b, S, R, W) {
  let x = W ? YI(W[1]) ? W[1].error : W[1].data : void 0, M = a.createURL(e.location), T = a.createURL(i), E = W && YI(W[1]) ? W[0] : void 0, _ = E ? TO(t, E) : t, P = W ? W[1].statusCode : void 0, U = l && P && P >= 400, q = _.filter((O, J) => {
    let {
      route: te
    } = O;
    if (te.lazy)
      return !0;
    if (te.loader == null)
      return !1;
    if (o)
      return typeof te.loader != "function" || te.loader.hydrate ? !0 : e.loaderData[te.id] === void 0 && // Don't re-run if the loader ran and threw an error
      (!e.errors || e.errors[te.id] === void 0);
    if (_O(e.loaderData, e.matches[J], O) || I.some((Ae) => Ae === O.route.id))
      return !0;
    let fe = e.matches[J], pe = O;
    return TE(O, Ms({
      currentUrl: M,
      currentParams: fe.params,
      nextUrl: T,
      nextParams: pe.params
    }, n, {
      actionResult: x,
      actionStatus: P,
      defaultShouldRevalidate: U ? !1 : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        u || M.pathname + M.search === T.pathname + T.search || // Search params affect all loaders
        M.search !== T.search || y5(fe, pe)
      )
    }));
  }), k = [];
  return v.forEach((O, J) => {
    if (o || !t.some((Te) => Te.route.id === O.routeId) || h.has(J))
      return;
    let te = qy(S, O.path, R);
    if (!te) {
      k.push({
        key: J,
        routeId: O.routeId,
        path: O.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fe = e.fetchers.get(J), pe = EZ(te, O.path), Ae = !1;
    b.has(J) ? Ae = !1 : f.has(J) ? (f.delete(J), Ae = !0) : fe && fe.state !== "idle" && fe.data === void 0 ? Ae = u : Ae = TE(pe, Ms({
      currentUrl: M,
      currentParams: e.matches[e.matches.length - 1].params,
      nextUrl: T,
      nextParams: t[t.length - 1].params
    }, n, {
      actionResult: x,
      actionStatus: P,
      defaultShouldRevalidate: U ? !1 : u
    })), Ae && k.push({
      key: J,
      routeId: O.routeId,
      path: O.path,
      matches: te,
      match: pe,
      controller: new AbortController()
    });
  }), [q, k];
}
function _O(a, e, t) {
  let n = (
    // [a] -> [a, b]
    !e || // [a, b] -> [a, c]
    t.route.id !== e.route.id
  ), i = a[t.route.id] === void 0;
  return n || i;
}
function y5(a, e) {
  let t = a.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    a.pathname !== e.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    t != null && t.endsWith("*") && a.params["*"] !== e.params["*"]
  );
}
function TE(a, e) {
  if (a.route.shouldRevalidate) {
    let t = a.route.shouldRevalidate(e);
    if (typeof t == "boolean")
      return t;
  }
  return e.defaultShouldRevalidate;
}
async function zO(a, e, t, n, i, o, l, u) {
  let I = [e, ...t.map((f) => f.route.id)].join("-");
  try {
    let f = l.get(I);
    f || (f = a({
      path: e,
      matches: t,
      patch: (h, v) => {
        u.aborted || b5(h, v, n, i, o);
      }
    }), l.set(I, f)), f && JO(f) && await f;
  } finally {
    l.delete(I);
  }
}
function b5(a, e, t, n, i) {
  if (a) {
    var o;
    let l = n[a];
    ki(l, "No route found to patch children into: routeId = " + a);
    let u = aw(e, i, [a, "patch", String(((o = l.children) == null ? void 0 : o.length) || "0")], n);
    l.children ? l.children.push(...u) : l.children = u;
  } else {
    let l = aw(e, i, ["patch", String(t.length || "0")], n);
    t.push(...l);
  }
}
async function _E(a, e, t) {
  if (!a.lazy)
    return;
  let n = await a.lazy();
  if (!a.lazy)
    return;
  let i = t[a.id];
  ki(i, "No route found in manifest");
  let o = {};
  for (let l in n) {
    let I = i[l] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    l !== "hasErrorBoundary";
    Gl(!I, 'Route "' + i.id + '" has a static property "' + l + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + l + '" will be ignored.')), !I && !cO.has(l) && (o[l] = n[l]);
  }
  Object.assign(i, o), Object.assign(i, Ms({}, e(i), {
    lazy: void 0
  }));
}
function KO(a) {
  return Promise.all(a.matches.map((e) => e.resolve()));
}
async function LO(a, e, t, n, i, o, l, u) {
  let I = n.reduce((v, b) => v.add(b.route.id), /* @__PURE__ */ new Set()), f = /* @__PURE__ */ new Set(), h = await a({
    matches: i.map((v) => {
      let b = I.has(v.route.id);
      return Ms({}, v, {
        shouldLoad: b,
        resolve: (R) => (f.add(v.route.id), b ? kO(e, t, v, o, l, R, u) : Promise.resolve({
          type: So.data,
          result: void 0
        }))
      });
    }),
    request: t,
    params: i[0].params,
    context: u
  });
  return i.forEach((v) => ki(f.has(v.route.id), '`match.resolve()` was not called for route id "' + v.route.id + '". You must call `match.resolve()` on every match passed to `dataStrategy` to ensure all routes are properly loaded.')), h.filter((v, b) => I.has(i[b].route.id));
}
async function kO(a, e, t, n, i, o, l) {
  let u, I, f = (h) => {
    let v, b = new Promise((W, x) => v = x);
    I = () => v(), e.signal.addEventListener("abort", I);
    let S = (W) => typeof h != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + a + '" [routeId: ' + t.route.id + "]"))) : h({
      request: e,
      params: t.params,
      context: l
    }, ...W !== void 0 ? [W] : []), R;
    return o ? R = o((W) => S(W)) : R = (async () => {
      try {
        return {
          type: "data",
          result: await S()
        };
      } catch (W) {
        return {
          type: "error",
          result: W
        };
      }
    })(), Promise.race([R, b]);
  };
  try {
    let h = t.route[a];
    if (t.route.lazy)
      if (h) {
        let v, [b] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          f(h).catch((S) => {
            v = S;
          }),
          _E(t.route, i, n)
        ]);
        if (v !== void 0)
          throw v;
        u = b;
      } else if (await _E(t.route, i, n), h = t.route[a], h)
        u = await f(h);
      else if (a === "action") {
        let v = new URL(e.url), b = v.pathname + v.search;
        throw Eg(405, {
          method: e.method,
          pathname: b,
          routeId: t.route.id
        });
      } else
        return {
          type: So.data,
          result: void 0
        };
    else if (h)
      u = await f(h);
    else {
      let v = new URL(e.url), b = v.pathname + v.search;
      throw Eg(404, {
        pathname: b
      });
    }
    ki(u.result !== void 0, "You defined " + (a === "action" ? "an action" : "a loader") + " for route " + ('"' + t.route.id + "\" but didn't return anything from your `" + a + "` ") + "function. Please return a value or `null`.");
  } catch (h) {
    return {
      type: So.error,
      result: h
    };
  } finally {
    I && e.signal.removeEventListener("abort", I);
  }
  return u;
}
async function DO(a) {
  let {
    result: e,
    type: t
  } = a;
  if (B5(e)) {
    let f;
    try {
      let h = e.headers.get("Content-Type");
      h && /\bapplication\/json\b/.test(h) ? e.body == null ? f = null : f = await e.json() : f = await e.text();
    } catch (h) {
      return {
        type: So.error,
        error: h
      };
    }
    return t === So.error ? {
      type: So.error,
      error: new r2(e.status, e.statusText, f),
      statusCode: e.status,
      headers: e.headers
    } : {
      type: So.data,
      data: f,
      statusCode: e.status,
      headers: e.headers
    };
  }
  if (t === So.error) {
    if (PE(e)) {
      var n;
      if (e.data instanceof Error) {
        var i;
        return {
          type: So.error,
          error: e.data,
          statusCode: (i = e.init) == null ? void 0 : i.status
        };
      }
      e = new r2(((n = e.init) == null ? void 0 : n.status) || 500, void 0, e.data);
    }
    return {
      type: So.error,
      error: e,
      statusCode: rW(e) ? e.status : void 0
    };
  }
  if (jO(e)) {
    var o, l;
    return {
      type: So.deferred,
      deferredData: e,
      statusCode: (o = e.init) == null ? void 0 : o.status,
      headers: ((l = e.init) == null ? void 0 : l.headers) && new Headers(e.init.headers)
    };
  }
  if (PE(e)) {
    var u, I;
    return {
      type: So.data,
      data: e.data,
      statusCode: (u = e.init) == null ? void 0 : u.status,
      headers: (I = e.init) != null && I.headers ? new Headers(e.init.headers) : void 0
    };
  }
  return {
    type: So.data,
    data: e
  };
}
function UO(a, e, t, n, i, o) {
  let l = a.headers.get("Location");
  if (ki(l, "Redirects returned/thrown from loaders/actions must have a Location header"), !dX.test(l)) {
    let u = n.slice(0, n.findIndex((I) => I.route.id === t) + 1);
    l = mH(new URL(e.url), u, i, !0, l, o), a.headers.set("Location", l);
  }
  return a;
}
function zE(a, e, t) {
  if (dX.test(a)) {
    let n = a, i = n.startsWith("//") ? new URL(e.protocol + n) : new URL(n), o = Th(i.pathname, t) != null;
    if (i.origin === e.origin && o)
      return i.pathname + i.search + i.hash;
  }
  return a;
}
function sG(a, e, t, n) {
  let i = a.createURL(G5(e)).toString(), o = {
    signal: t
  };
  if (n && Fh(n.formMethod)) {
    let {
      formMethod: l,
      formEncType: u
    } = n;
    o.method = l.toUpperCase(), u === "application/json" ? (o.headers = new Headers({
      "Content-Type": u
    }), o.body = JSON.stringify(n.json)) : u === "text/plain" ? o.body = n.text : u === "application/x-www-form-urlencoded" && n.formData ? o.body = AH(n.formData) : o.body = n.formData;
  }
  return new Request(i, o);
}
function AH(a) {
  let e = new URLSearchParams();
  for (let [t, n] of a.entries())
    e.append(t, typeof n == "string" ? n : n.name);
  return e;
}
function KE(a) {
  let e = new FormData();
  for (let [t, n] of a.entries())
    e.append(t, n);
  return e;
}
function OO(a, e, t, n, i, o) {
  let l = {}, u = null, I, f = !1, h = {}, v = n && YI(n[1]) ? n[1].error : void 0;
  return t.forEach((b, S) => {
    let R = e[S].route.id;
    if (ki(!ib(b), "Cannot handle redirect results in processLoaderData"), YI(b)) {
      let W = b.error;
      v !== void 0 && (W = v, v = void 0), u = u || {};
      {
        let x = YG(a, R);
        u[x.route.id] == null && (u[x.route.id] = W);
      }
      l[R] = void 0, f || (f = !0, I = rW(b.error) ? b.error.status : 500), b.headers && (h[R] = b.headers);
    } else
      nb(b) ? (i.set(R, b.deferredData), l[R] = b.deferredData.data, b.statusCode != null && b.statusCode !== 200 && !f && (I = b.statusCode), b.headers && (h[R] = b.headers)) : (l[R] = b.data, b.statusCode && b.statusCode !== 200 && !f && (I = b.statusCode), b.headers && (h[R] = b.headers));
  }), v !== void 0 && n && (u = {
    [n[0]]: v
  }, l[n[0]] = void 0), {
    loaderData: l,
    errors: u,
    statusCode: I || 200,
    loaderHeaders: h
  };
}
function LE(a, e, t, n, i, o, l, u) {
  let {
    loaderData: I,
    errors: f
  } = OO(e, t, n, i, u);
  for (let h = 0; h < o.length; h++) {
    let {
      key: v,
      match: b,
      controller: S
    } = o[h];
    ki(l !== void 0 && l[h] !== void 0, "Did not find corresponding fetcher result");
    let R = l[h];
    if (!(S && S.signal.aborted))
      if (YI(R)) {
        let W = YG(a.matches, b?.route.id);
        f && f[W.route.id] || (f = Ms({}, f, {
          [W.route.id]: R.error
        })), a.fetchers.delete(v);
      } else if (ib(R))
        ki(!1, "Unhandled fetcher revalidation redirect");
      else if (nb(R))
        ki(!1, "Unhandled fetcher deferred data");
      else {
        let W = LA(R.data);
        a.fetchers.set(v, W);
      }
  }
  return {
    loaderData: I,
    errors: f
  };
}
function kE(a, e, t, n) {
  let i = Ms({}, e);
  for (let o of t) {
    let l = o.route.id;
    if (e.hasOwnProperty(l) ? e[l] !== void 0 && (i[l] = e[l]) : a[l] !== void 0 && o.route.loader && (i[l] = a[l]), n && n.hasOwnProperty(l))
      break;
  }
  return i;
}
function DE(a) {
  return a ? YI(a[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [a[0]]: a[1].data
    }
  } : {};
}
function YG(a, e) {
  return (e ? a.slice(0, a.findIndex((n) => n.route.id === e) + 1) : [...a]).reverse().find((n) => n.route.hasErrorBoundary === !0) || a[0];
}
function UE(a) {
  let e = a.length === 1 ? a[0] : a.find((t) => t.index || !t.path || t.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route: e
    }],
    route: e
  };
}
function Eg(a, e) {
  let {
    pathname: t,
    routeId: n,
    method: i,
    type: o,
    message: l
  } = e === void 0 ? {} : e, u = "Unknown Server Error", I = "Unknown @remix-run/router error";
  return a === 400 ? (u = "Bad Request", o === "route-discovery" ? I = 'Unable to match URL "' + t + '" - the `unstable_patchRoutesOnNavigation()` ' + (`function threw the following error:
` + l) : i && t && n ? I = "You made a " + i + ' request to "' + t + '" but ' + ('did not provide a `loader` for route "' + n + '", ') + "so there is no way to handle the request." : o === "defer-action" ? I = "defer() is not supported in actions" : o === "invalid-body" && (I = "Unable to encode submission body")) : a === 403 ? (u = "Forbidden", I = 'Route "' + n + '" does not match URL "' + t + '"') : a === 404 ? (u = "Not Found", I = 'No route matches URL "' + t + '"') : a === 405 && (u = "Method Not Allowed", i && t && n ? I = "You made a " + i.toUpperCase() + ' request to "' + t + '" but ' + ('did not provide an `action` for route "' + n + '", ') + "so there is no way to handle the request." : i && (I = 'Invalid request method "' + i.toUpperCase() + '"')), new r2(a || 500, u, new Error(I), !0);
}
function OE(a) {
  for (let e = a.length - 1; e >= 0; e--) {
    let t = a[e];
    if (ib(t))
      return {
        result: t,
        idx: e
      };
  }
}
function G5(a) {
  let e = typeof a == "string" ? Em(a) : a;
  return jA(Ms({}, e, {
    hash: ""
  }));
}
function PO(a, e) {
  return a.pathname !== e.pathname || a.search !== e.search ? !1 : a.hash === "" ? e.hash !== "" : a.hash === e.hash ? !0 : e.hash !== "";
}
function JO(a) {
  return typeof a == "object" && a != null && "then" in a;
}
function QO(a) {
  return B5(a.result) && MO.has(a.result.status);
}
function nb(a) {
  return a.type === So.deferred;
}
function YI(a) {
  return a.type === So.error;
}
function ib(a) {
  return (a && a.type) === So.redirect;
}
function PE(a) {
  return typeof a == "object" && a != null && "type" in a && "data" in a && "init" in a && a.type === "DataWithResponseInit";
}
function jO(a) {
  let e = a;
  return e && typeof e == "object" && typeof e.data == "object" && typeof e.subscribe == "function" && typeof e.cancel == "function" && typeof e.resolveData == "function";
}
function B5(a) {
  return a != null && typeof a.status == "number" && typeof a.statusText == "string" && typeof a.headers == "object" && typeof a.body < "u";
}
function qO(a) {
  return NO.has(a.toLowerCase());
}
function Fh(a) {
  return WO.has(a.toLowerCase());
}
async function JE(a, e, t, n, i, o) {
  for (let l = 0; l < t.length; l++) {
    let u = t[l], I = e[l];
    if (!I)
      continue;
    let f = a.find((v) => v.route.id === I.route.id), h = f != null && !y5(f, I) && (o && o[I.route.id]) !== void 0;
    if (nb(u) && (i || h)) {
      let v = n[l];
      ki(v, "Expected an AbortSignal for revalidating fetcher deferred result"), await S5(u, v, i).then((b) => {
        b && (t[l] = b || t[l]);
      });
    }
  }
}
async function S5(a, e, t) {
  if (t === void 0 && (t = !1), !await a.deferredData.resolveData(e)) {
    if (t)
      try {
        return {
          type: So.data,
          data: a.deferredData.unwrappedData
        };
      } catch (i) {
        return {
          type: So.error,
          error: i
        };
      }
    return {
      type: So.data,
      data: a.deferredData.data
    };
  }
}
function IX(a) {
  return new URLSearchParams(a).getAll("index").some((e) => e === "");
}
function EZ(a, e) {
  let t = typeof e == "string" ? Em(e).search : e.search;
  if (a[a.length - 1].route.index && IX(t || ""))
    return a[a.length - 1];
  let n = m5(a);
  return n[n.length - 1];
}
function QE(a) {
  let {
    formMethod: e,
    formAction: t,
    formEncType: n,
    text: i,
    formData: o,
    json: l
  } = a;
  if (!(!e || !t || !n)) {
    if (i != null)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: void 0,
        json: void 0,
        text: i
      };
    if (o != null)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: o,
        json: void 0,
        text: void 0
      };
    if (l !== void 0)
      return {
        formMethod: e,
        formAction: t,
        formEncType: n,
        formData: void 0,
        json: l,
        text: void 0
      };
  }
}
function JN(a, e) {
  return e ? {
    state: "loading",
    location: a,
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text
  } : {
    state: "loading",
    location: a,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function $O(a, e) {
  return {
    state: "submitting",
    location: a,
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text
  };
}
function IZ(a, e) {
  return a ? {
    state: "loading",
    formMethod: a.formMethod,
    formAction: a.formAction,
    formEncType: a.formEncType,
    formData: a.formData,
    json: a.json,
    text: a.text,
    data: e
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function eP(a, e) {
  return {
    state: "submitting",
    formMethod: a.formMethod,
    formAction: a.formAction,
    formEncType: a.formEncType,
    formData: a.formData,
    json: a.json,
    text: a.text,
    data: e ? e.data : void 0
  };
}
function LA(a) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: a
  };
}
function tP(a, e) {
  try {
    let t = a.sessionStorage.getItem(v5);
    if (t) {
      let n = JSON.parse(t);
      for (let [i, o] of Object.entries(n || {}))
        o && Array.isArray(o) && e.set(i, new Set(o || []));
    }
  } catch {
  }
}
function nP(a, e) {
  if (e.size > 0) {
    let t = {};
    for (let [n, i] of e)
      t[n] = [...i];
    try {
      a.sessionStorage.setItem(v5, JSON.stringify(t));
    } catch (n) {
      Gl(!1, "Failed to save applied view transitions in sessionStorage (" + n + ").");
    }
  }
}
var Ba = {};
function a2() {
  return a2 = Object.assign ? Object.assign.bind() : function(a) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (a[n] = t[n]);
    }
    return a;
  }, a2.apply(this, arguments);
}
const uB = /* @__PURE__ */ xe.createContext(null);
Ba.NODE_ENV !== "production" && (uB.displayName = "DataRouter");
const aW = /* @__PURE__ */ xe.createContext(null);
Ba.NODE_ENV !== "production" && (aW.displayName = "DataRouterState");
const iP = /* @__PURE__ */ xe.createContext(null);
Ba.NODE_ENV !== "production" && (iP.displayName = "Await");
const _C = /* @__PURE__ */ xe.createContext(null);
Ba.NODE_ENV !== "production" && (_C.displayName = "Navigation");
const oW = /* @__PURE__ */ xe.createContext(null);
Ba.NODE_ENV !== "production" && (oW.displayName = "Location");
const dp = /* @__PURE__ */ xe.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
Ba.NODE_ENV !== "production" && (dp.displayName = "Route");
const CX = /* @__PURE__ */ xe.createContext(null);
Ba.NODE_ENV !== "production" && (CX.displayName = "RouteError");
function rP(a, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e;
  cB() || (Ba.NODE_ENV !== "production" ? ki(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : ki(!1));
  let {
    basename: n,
    navigator: i
  } = xe.useContext(_C), {
    hash: o,
    pathname: l,
    search: u
  } = _w(a, {
    relative: t
  }), I = l;
  return n !== "/" && (I = l === "/" ? n : op([n, l])), i.createHref({
    pathname: I,
    search: u,
    hash: o
  });
}
function cB() {
  return xe.useContext(oW) != null;
}
function Pg() {
  return cB() || (Ba.NODE_ENV !== "production" ? ki(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : ki(!1)), xe.useContext(oW).location;
}
const Z5 = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function w5(a) {
  xe.useContext(_C).static || xe.useLayoutEffect(a);
}
function Sb() {
  let {
    isDataRoute: a
  } = xe.useContext(dp);
  return a ? pP() : aP();
}
function aP() {
  cB() || (Ba.NODE_ENV !== "production" ? ki(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : ki(!1));
  let a = xe.useContext(uB), {
    basename: e,
    future: t,
    navigator: n
  } = xe.useContext(_C), {
    matches: i
  } = xe.useContext(dp), {
    pathname: o
  } = Pg(), l = JSON.stringify(nW(i, t.v7_relativeSplatPath)), u = xe.useRef(!1);
  return w5(() => {
    u.current = !0;
  }), xe.useCallback(function(f, h) {
    if (h === void 0 && (h = {}), Ba.NODE_ENV !== "production" && Gl(u.current, Z5), !u.current) return;
    if (typeof f == "number") {
      n.go(f);
      return;
    }
    let v = iW(f, JSON.parse(l), o, h.relative === "path");
    a == null && e !== "/" && (v.pathname = v.pathname === "/" ? e : op([e, v.pathname])), (h.replace ? n.replace : n.push)(v, h.state, h);
  }, [e, n, l, o, a]);
}
function _w(a, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    future: n
  } = xe.useContext(_C), {
    matches: i
  } = xe.useContext(dp), {
    pathname: o
  } = Pg(), l = JSON.stringify(nW(i, n.v7_relativeSplatPath));
  return xe.useMemo(() => iW(a, JSON.parse(l), o, t === "path"), [a, l, o, t]);
}
function oP(a, e, t, n) {
  cB() || (Ba.NODE_ENV !== "production" ? ki(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : ki(!1));
  let {
    navigator: i
  } = xe.useContext(_C), {
    matches: o
  } = xe.useContext(dp), l = o[o.length - 1], u = l ? l.params : {}, I = l ? l.pathname : "/", f = l ? l.pathnameBase : "/", h = l && l.route;
  if (Ba.NODE_ENV !== "production") {
    let M = h && h.path || "";
    x5(I, !h || M.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + I + '" (under <Route path="' + M + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + M + '"> to <Route ') + ('path="' + (M === "/" ? "*" : M + "/*") + '">.'));
  }
  let v = Pg(), b;
  b = v;
  let S = b.pathname || "/", R = S;
  if (f !== "/") {
    let M = f.replace(/^\//, "").split("/");
    R = "/" + S.replace(/^\//, "").split("/").slice(M.length).join("/");
  }
  let W = qy(a, {
    pathname: R
  });
  return Ba.NODE_ENV !== "production" && (Ba.NODE_ENV !== "production" && Gl(h || W != null, 'No routes matched location "' + b.pathname + b.search + b.hash + '" '), Ba.NODE_ENV !== "production" && Gl(W == null || W[W.length - 1].route.element !== void 0 || W[W.length - 1].route.Component !== void 0 || W[W.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + b.pathname + b.search + b.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.')), gP(W && W.map((M) => Object.assign({}, M, {
    params: Object.assign({}, u, M.params),
    pathname: op([
      f,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(M.pathname).pathname : M.pathname
    ]),
    pathnameBase: M.pathnameBase === "/" ? f : op([
      f,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(M.pathnameBase).pathname : M.pathnameBase
    ])
  })), o, t, n);
}
function sP() {
  let a = fP(), e = rW(a) ? a.status + " " + a.statusText : a instanceof Error ? a.message : JSON.stringify(a), t = a instanceof Error ? a.stack : null, n = "rgba(200,200,200, 0.5)", i = {
    padding: "0.5rem",
    backgroundColor: n
  }, o = {
    padding: "2px 4px",
    backgroundColor: n
  }, l = null;
  return Ba.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", a), l = /* @__PURE__ */ xe.createElement(xe.Fragment, null, /* @__PURE__ */ xe.createElement("p", null, "💿 Hey developer 👋"), /* @__PURE__ */ xe.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ xe.createElement("code", {
    style: o
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ xe.createElement("code", {
    style: o
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ xe.createElement(xe.Fragment, null, /* @__PURE__ */ xe.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ xe.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, e), t ? /* @__PURE__ */ xe.createElement("pre", {
    style: i
  }, t) : null, l);
}
const lP = /* @__PURE__ */ xe.createElement(sP, null);
class uP extends xe.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return {
      error: e
    };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    console.error("React Router caught the following error during render", e, t);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ xe.createElement(dp.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ xe.createElement(CX.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function cP(a) {
  let {
    routeContext: e,
    match: t,
    children: n
  } = a, i = xe.useContext(uB);
  return i && i.static && i.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ xe.createElement(dp.Provider, {
    value: e
  }, n);
}
function gP(a, e, t, n) {
  var i;
  if (e === void 0 && (e = []), t === void 0 && (t = null), n === void 0 && (n = null), a == null) {
    var o;
    if (!t)
      return null;
    if (t.errors)
      a = t.matches;
    else if ((o = n) != null && o.v7_partialHydration && e.length === 0 && !t.initialized && t.matches.length > 0)
      a = t.matches;
    else
      return null;
  }
  let l = a, u = (i = t) == null ? void 0 : i.errors;
  if (u != null) {
    let h = l.findIndex((v) => v.route.id && u?.[v.route.id] !== void 0);
    h >= 0 || (Ba.NODE_ENV !== "production" ? ki(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(u).join(",")) : ki(!1)), l = l.slice(0, Math.min(l.length, h + 1));
  }
  let I = !1, f = -1;
  if (t && n && n.v7_partialHydration)
    for (let h = 0; h < l.length; h++) {
      let v = l[h];
      if ((v.route.HydrateFallback || v.route.hydrateFallbackElement) && (f = h), v.route.id) {
        let {
          loaderData: b,
          errors: S
        } = t, R = v.route.loader && b[v.route.id] === void 0 && (!S || S[v.route.id] === void 0);
        if (v.route.lazy || R) {
          I = !0, f >= 0 ? l = l.slice(0, f + 1) : l = [l[0]];
          break;
        }
      }
    }
  return l.reduceRight((h, v, b) => {
    let S, R = !1, W = null, x = null;
    t && (S = u && v.route.id ? u[v.route.id] : void 0, W = v.route.errorElement || lP, I && (f < 0 && b === 0 ? (x5("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), R = !0, x = null) : f === b && (R = !0, x = v.route.hydrateFallbackElement || null)));
    let M = e.concat(l.slice(0, b + 1)), T = () => {
      let E;
      return S ? E = W : R ? E = x : v.route.Component ? E = /* @__PURE__ */ xe.createElement(v.route.Component, null) : v.route.element ? E = v.route.element : E = h, /* @__PURE__ */ xe.createElement(cP, {
        match: v,
        routeContext: {
          outlet: h,
          matches: M,
          isDataRoute: t != null
        },
        children: E
      });
    };
    return t && (v.route.ErrorBoundary || v.route.errorElement || b === 0) ? /* @__PURE__ */ xe.createElement(uP, {
      location: t.location,
      revalidation: t.revalidation,
      component: W,
      error: S,
      children: T(),
      routeContext: {
        outlet: null,
        matches: M,
        isDataRoute: !0
      }
    }) : T();
  }, null);
}
var R5 = /* @__PURE__ */ function(a) {
  return a.UseBlocker = "useBlocker", a.UseRevalidator = "useRevalidator", a.UseNavigateStable = "useNavigate", a;
}(R5 || {}), ow = /* @__PURE__ */ function(a) {
  return a.UseBlocker = "useBlocker", a.UseLoaderData = "useLoaderData", a.UseActionData = "useActionData", a.UseRouteError = "useRouteError", a.UseNavigation = "useNavigation", a.UseRouteLoaderData = "useRouteLoaderData", a.UseMatches = "useMatches", a.UseRevalidator = "useRevalidator", a.UseNavigateStable = "useNavigate", a.UseRouteId = "useRouteId", a;
}(ow || {});
function hX(a) {
  return a + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function dP(a) {
  let e = xe.useContext(uB);
  return e || (Ba.NODE_ENV !== "production" ? ki(!1, hX(a)) : ki(!1)), e;
}
function IP(a) {
  let e = xe.useContext(aW);
  return e || (Ba.NODE_ENV !== "production" ? ki(!1, hX(a)) : ki(!1)), e;
}
function CP(a) {
  let e = xe.useContext(dp);
  return e || (Ba.NODE_ENV !== "production" ? ki(!1, hX(a)) : ki(!1)), e;
}
function fX(a) {
  let e = CP(a), t = e.matches[e.matches.length - 1];
  return t.route.id || (Ba.NODE_ENV !== "production" ? ki(!1, a + ' can only be used on routes that contain a unique "id"') : ki(!1)), t.route.id;
}
function hP() {
  return fX(ow.UseRouteId);
}
function fP() {
  var a;
  let e = xe.useContext(CX), t = IP(ow.UseRouteError), n = fX(ow.UseRouteError);
  return e !== void 0 ? e : (a = t.errors) == null ? void 0 : a[n];
}
function pP() {
  let {
    router: a
  } = dP(R5.UseNavigateStable), e = fX(ow.UseNavigateStable), t = xe.useRef(!1);
  return w5(() => {
    t.current = !0;
  }), xe.useCallback(function(i, o) {
    o === void 0 && (o = {}), Ba.NODE_ENV !== "production" && Gl(t.current, Z5), t.current && (typeof i == "number" ? a.navigate(i) : a.navigate(i, a2({
      fromRouteId: e
    }, o)));
  }, [a, e]);
}
const jE = {};
function x5(a, e, t) {
  !e && !jE[a] && (jE[a] = !0, Ba.NODE_ENV !== "production" && Gl(!1, t));
}
function mP(a) {
  let {
    to: e,
    replace: t,
    state: n,
    relative: i
  } = a;
  cB() || (Ba.NODE_ENV !== "production" ? ki(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : ki(!1));
  let {
    future: o,
    static: l
  } = xe.useContext(_C);
  Ba.NODE_ENV !== "production" && Gl(!l, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let {
    matches: u
  } = xe.useContext(dp), {
    pathname: I
  } = Pg(), f = Sb(), h = iW(e, nW(u, o.v7_relativeSplatPath), I, i === "path"), v = JSON.stringify(h);
  return xe.useEffect(() => f(JSON.parse(v), {
    replace: t,
    state: n,
    relative: i
  }), [f, v, i, t, n]), null;
}
function AP(a) {
  let {
    basename: e = "/",
    children: t = null,
    location: n,
    navigationType: i = Xl.Pop,
    navigator: o,
    static: l = !1,
    future: u
  } = a;
  cB() && (Ba.NODE_ENV !== "production" ? ki(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : ki(!1));
  let I = e.replace(/^\/*/, "/"), f = xe.useMemo(() => ({
    basename: I,
    navigator: o,
    static: l,
    future: a2({
      v7_relativeSplatPath: !1
    }, u)
  }), [I, u, o, l]);
  typeof n == "string" && (n = Em(n));
  let {
    pathname: h = "/",
    search: v = "",
    hash: b = "",
    state: S = null,
    key: R = "default"
  } = n, W = xe.useMemo(() => {
    let x = Th(h, I);
    return x == null ? null : {
      location: {
        pathname: x,
        search: v,
        hash: b,
        state: S,
        key: R
      },
      navigationType: i
    };
  }, [I, h, v, b, S, R, i]);
  return Ba.NODE_ENV !== "production" && Gl(W != null, '<Router basename="' + I + '"> is not able to match the URL ' + ('"' + h + v + b + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), W == null ? null : /* @__PURE__ */ xe.createElement(_C.Provider, {
    value: f
  }, /* @__PURE__ */ xe.createElement(oW.Provider, {
    children: t,
    value: W
  }));
}
new Promise(() => {
});
function vP(a) {
  let e = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: a.ErrorBoundary != null || a.errorElement != null
  };
  return a.Component && (Ba.NODE_ENV !== "production" && a.element && Ba.NODE_ENV !== "production" && Gl(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(e, {
    element: /* @__PURE__ */ xe.createElement(a.Component),
    Component: void 0
  })), a.HydrateFallback && (Ba.NODE_ENV !== "production" && a.hydrateFallbackElement && Ba.NODE_ENV !== "production" && Gl(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."), Object.assign(e, {
    hydrateFallbackElement: /* @__PURE__ */ xe.createElement(a.HydrateFallback),
    HydrateFallback: void 0
  })), a.ErrorBoundary && (Ba.NODE_ENV !== "production" && a.errorElement && Ba.NODE_ENV !== "production" && Gl(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(e, {
    errorElement: /* @__PURE__ */ xe.createElement(a.ErrorBoundary),
    ErrorBoundary: void 0
  })), e;
}
var zC = {};
function qA() {
  return qA = Object.assign ? Object.assign.bind() : function(a) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (a[n] = t[n]);
    }
    return a;
  }, qA.apply(this, arguments);
}
function pX(a, e) {
  if (a == null) return {};
  var t = {}, n = Object.keys(a), i, o;
  for (o = 0; o < n.length; o++)
    i = n[o], !(e.indexOf(i) >= 0) && (t[i] = a[i]);
  return t;
}
const O1 = "get", P1 = "application/x-www-form-urlencoded";
function sW(a) {
  return a != null && typeof a.tagName == "string";
}
function yP(a) {
  return sW(a) && a.tagName.toLowerCase() === "button";
}
function bP(a) {
  return sW(a) && a.tagName.toLowerCase() === "form";
}
function GP(a) {
  return sW(a) && a.tagName.toLowerCase() === "input";
}
function BP(a) {
  return !!(a.metaKey || a.altKey || a.ctrlKey || a.shiftKey);
}
function SP(a, e) {
  return a.button === 0 && // Ignore everything but left clicks
  (!e || e === "_self") && // Let browser handle "target=_blank" etc.
  !BP(a);
}
function vH(a) {
  return a === void 0 && (a = ""), new URLSearchParams(typeof a == "string" || Array.isArray(a) || a instanceof URLSearchParams ? a : Object.keys(a).reduce((e, t) => {
    let n = a[t];
    return e.concat(Array.isArray(n) ? n.map((i) => [t, i]) : [[t, n]]);
  }, []));
}
function ZP(a, e) {
  let t = vH(a);
  return e && e.forEach((n, i) => {
    t.has(i) || e.getAll(i).forEach((o) => {
      t.append(i, o);
    });
  }), t;
}
let zx = null;
function wP() {
  if (zx === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), zx = !1;
    } catch {
      zx = !0;
    }
  return zx;
}
const RP = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function QN(a) {
  return a != null && !RP.has(a) ? (zC.NODE_ENV !== "production" && Gl(!1, '"' + a + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + P1 + '"')), null) : a;
}
function xP(a, e) {
  let t, n, i, o, l;
  if (bP(a)) {
    let u = a.getAttribute("action");
    n = u ? Th(u, e) : null, t = a.getAttribute("method") || O1, i = QN(a.getAttribute("enctype")) || P1, o = new FormData(a);
  } else if (yP(a) || GP(a) && (a.type === "submit" || a.type === "image")) {
    let u = a.form;
    if (u == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let I = a.getAttribute("formaction") || u.getAttribute("action");
    if (n = I ? Th(I, e) : null, t = a.getAttribute("formmethod") || u.getAttribute("method") || O1, i = QN(a.getAttribute("formenctype")) || QN(u.getAttribute("enctype")) || P1, o = new FormData(u, a), !wP()) {
      let {
        name: f,
        type: h,
        value: v
      } = a;
      if (h === "image") {
        let b = f ? f + "." : "";
        o.append(b + "x", "0"), o.append(b + "y", "0");
      } else f && o.append(f, v);
    }
  } else {
    if (sW(a))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    t = O1, n = null, i = P1, l = a;
  }
  return o && i === "text/plain" && (l = o, o = void 0), {
    action: n,
    method: t.toLowerCase(),
    encType: i,
    formData: o,
    body: l
  };
}
const WP = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], VP = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"], NP = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"], MP = "6";
try {
  window.__reactRouterVersion = MP;
} catch {
}
function HP(a, e) {
  return FO({
    basename: e?.basename,
    future: qA({}, e?.future, {
      v7_prependBasename: !0
    }),
    history: sO({
      window: e?.window
    }),
    hydrationData: e?.hydrationData || XP(),
    routes: a,
    mapRouteProperties: vP,
    unstable_dataStrategy: e?.unstable_dataStrategy,
    unstable_patchRoutesOnNavigation: e?.unstable_patchRoutesOnNavigation,
    window: e?.window
  }).initialize();
}
function XP() {
  var a;
  let e = (a = window) == null ? void 0 : a.__staticRouterHydrationData;
  return e && e.errors && (e = qA({}, e, {
    errors: YP(e.errors)
  })), e;
}
function YP(a) {
  if (!a) return null;
  let e = Object.entries(a), t = {};
  for (let [n, i] of e)
    if (i && i.__type === "RouteErrorResponse")
      t[n] = new r2(i.status, i.statusText, i.data, i.internal === !0);
    else if (i && i.__type === "Error") {
      if (i.__subType) {
        let o = window[i.__subType];
        if (typeof o == "function")
          try {
            let l = new o(i.message);
            l.stack = "", t[n] = l;
          } catch {
          }
      }
      if (t[n] == null) {
        let o = new Error(i.message);
        o.stack = "", t[n] = o;
      }
    } else
      t[n] = i;
  return t;
}
const mX = /* @__PURE__ */ xe.createContext({
  isTransitioning: !1
});
zC.NODE_ENV !== "production" && (mX.displayName = "ViewTransition");
const W5 = /* @__PURE__ */ xe.createContext(/* @__PURE__ */ new Map());
zC.NODE_ENV !== "production" && (W5.displayName = "Fetchers");
const FP = "startTransition", qE = jU[FP], EP = "flushSync", $E = aO[EP];
function TP(a) {
  qE ? qE(a) : a();
}
function CZ(a) {
  $E ? $E(a) : a();
}
class _P {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, t) => {
      this.resolve = (n) => {
        this.status === "pending" && (this.status = "resolved", e(n));
      }, this.reject = (n) => {
        this.status === "pending" && (this.status = "rejected", t(n));
      };
    });
  }
}
function zP(a) {
  let {
    fallbackElement: e,
    router: t,
    future: n
  } = a, [i, o] = xe.useState(t.state), [l, u] = xe.useState(), [I, f] = xe.useState({
    isTransitioning: !1
  }), [h, v] = xe.useState(), [b, S] = xe.useState(), [R, W] = xe.useState(), x = xe.useRef(/* @__PURE__ */ new Map()), {
    v7_startTransition: M
  } = n || {}, T = xe.useCallback((k) => {
    M ? TP(k) : k();
  }, [M]), E = xe.useCallback((k, O) => {
    let {
      deletedFetchers: J,
      unstable_flushSync: te,
      unstable_viewTransitionOpts: fe
    } = O;
    J.forEach((Ae) => x.current.delete(Ae)), k.fetchers.forEach((Ae, Te) => {
      Ae.data !== void 0 && x.current.set(Te, Ae.data);
    });
    let pe = t.window == null || t.window.document == null || typeof t.window.document.startViewTransition != "function";
    if (!fe || pe) {
      te ? CZ(() => o(k)) : T(() => o(k));
      return;
    }
    if (te) {
      CZ(() => {
        b && (h && h.resolve(), b.skipTransition()), f({
          isTransitioning: !0,
          flushSync: !0,
          currentLocation: fe.currentLocation,
          nextLocation: fe.nextLocation
        });
      });
      let Ae = t.window.document.startViewTransition(() => {
        CZ(() => o(k));
      });
      Ae.finished.finally(() => {
        CZ(() => {
          v(void 0), S(void 0), u(void 0), f({
            isTransitioning: !1
          });
        });
      }), CZ(() => S(Ae));
      return;
    }
    b ? (h && h.resolve(), b.skipTransition(), W({
      state: k,
      currentLocation: fe.currentLocation,
      nextLocation: fe.nextLocation
    })) : (u(k), f({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: fe.currentLocation,
      nextLocation: fe.nextLocation
    }));
  }, [t.window, b, h, x, T]);
  xe.useLayoutEffect(() => t.subscribe(E), [t, E]), xe.useEffect(() => {
    I.isTransitioning && !I.flushSync && v(new _P());
  }, [I]), xe.useEffect(() => {
    if (h && l && t.window) {
      let k = l, O = h.promise, J = t.window.document.startViewTransition(async () => {
        T(() => o(k)), await O;
      });
      J.finished.finally(() => {
        v(void 0), S(void 0), u(void 0), f({
          isTransitioning: !1
        });
      }), S(J);
    }
  }, [T, l, h, t.window]), xe.useEffect(() => {
    h && l && i.location.key === l.location.key && h.resolve();
  }, [h, b, i.location, l]), xe.useEffect(() => {
    !I.isTransitioning && R && (u(R.state), f({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: R.currentLocation,
      nextLocation: R.nextLocation
    }), W(void 0));
  }, [I.isTransitioning, R]), xe.useEffect(() => {
    zC.NODE_ENV !== "production" && Gl(e == null || !t.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
  }, []);
  let _ = xe.useMemo(() => ({
    createHref: t.createHref,
    encodeLocation: t.encodeLocation,
    go: (k) => t.navigate(k),
    push: (k, O, J) => t.navigate(k, {
      state: O,
      preventScrollReset: J?.preventScrollReset
    }),
    replace: (k, O, J) => t.navigate(k, {
      replace: !0,
      state: O,
      preventScrollReset: J?.preventScrollReset
    })
  }), [t]), P = t.basename || "/", U = xe.useMemo(() => ({
    router: t,
    navigator: _,
    static: !1,
    basename: P
  }), [t, _, P]), q = xe.useMemo(() => ({
    v7_relativeSplatPath: t.future.v7_relativeSplatPath
  }), [t.future.v7_relativeSplatPath]);
  return /* @__PURE__ */ xe.createElement(xe.Fragment, null, /* @__PURE__ */ xe.createElement(uB.Provider, {
    value: U
  }, /* @__PURE__ */ xe.createElement(aW.Provider, {
    value: i
  }, /* @__PURE__ */ xe.createElement(W5.Provider, {
    value: x.current
  }, /* @__PURE__ */ xe.createElement(mX.Provider, {
    value: I
  }, /* @__PURE__ */ xe.createElement(AP, {
    basename: P,
    location: i.location,
    navigationType: i.historyAction,
    navigator: _,
    future: q
  }, i.initialized || t.future.v7_partialHydration ? /* @__PURE__ */ xe.createElement(KP, {
    routes: t.routes,
    future: t.future,
    state: i
  }) : e))))), null);
}
const KP = /* @__PURE__ */ xe.memo(LP);
function LP(a) {
  let {
    routes: e,
    future: t,
    state: n
  } = a;
  return oP(e, void 0, n, t);
}
const kP = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", DP = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, AX = /* @__PURE__ */ xe.forwardRef(function(e, t) {
  let {
    onClick: n,
    relative: i,
    reloadDocument: o,
    replace: l,
    state: u,
    target: I,
    to: f,
    preventScrollReset: h,
    unstable_viewTransition: v
  } = e, b = pX(e, WP), {
    basename: S
  } = xe.useContext(_C), R, W = !1;
  if (typeof f == "string" && DP.test(f) && (R = f, kP))
    try {
      let E = new URL(window.location.href), _ = f.startsWith("//") ? new URL(E.protocol + f) : new URL(f), P = Th(_.pathname, S);
      _.origin === E.origin && P != null ? f = P + _.search + _.hash : W = !0;
    } catch {
      zC.NODE_ENV !== "production" && Gl(!1, '<Link to="' + f + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let x = rP(f, {
    relative: i
  }), M = JP(f, {
    replace: l,
    state: u,
    target: I,
    preventScrollReset: h,
    relative: i,
    unstable_viewTransition: v
  });
  function T(E) {
    n && n(E), E.defaultPrevented || M(E);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ xe.createElement("a", qA({}, b, {
      href: R || x,
      onClick: W || o ? n : T,
      ref: t,
      target: I
    }))
  );
});
zC.NODE_ENV !== "production" && (AX.displayName = "Link");
const UP = /* @__PURE__ */ xe.forwardRef(function(e, t) {
  let {
    "aria-current": n = "page",
    caseSensitive: i = !1,
    className: o = "",
    end: l = !1,
    style: u,
    to: I,
    unstable_viewTransition: f,
    children: h
  } = e, v = pX(e, VP), b = _w(I, {
    relative: v.relative
  }), S = Pg(), R = xe.useContext(aW), {
    navigator: W,
    basename: x
  } = xe.useContext(_C), M = R != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  tJ(b) && f === !0, T = W.encodeLocation ? W.encodeLocation(b).pathname : b.pathname, E = S.pathname, _ = R && R.navigation && R.navigation.location ? R.navigation.location.pathname : null;
  i || (E = E.toLowerCase(), _ = _ ? _.toLowerCase() : null, T = T.toLowerCase()), _ && x && (_ = Th(_, x) || _);
  const P = T !== "/" && T.endsWith("/") ? T.length - 1 : T.length;
  let U = E === T || !l && E.startsWith(T) && E.charAt(P) === "/", q = _ != null && (_ === T || !l && _.startsWith(T) && _.charAt(T.length) === "/"), k = {
    isActive: U,
    isPending: q,
    isTransitioning: M
  }, O = U ? n : void 0, J;
  typeof o == "function" ? J = o(k) : J = [o, U ? "active" : null, q ? "pending" : null, M ? "transitioning" : null].filter(Boolean).join(" ");
  let te = typeof u == "function" ? u(k) : u;
  return /* @__PURE__ */ xe.createElement(AX, qA({}, v, {
    "aria-current": O,
    className: J,
    ref: t,
    style: te,
    to: I,
    unstable_viewTransition: f
  }), typeof h == "function" ? h(k) : h);
});
zC.NODE_ENV !== "production" && (UP.displayName = "NavLink");
const OP = /* @__PURE__ */ xe.forwardRef((a, e) => {
  let {
    fetcherKey: t,
    navigate: n,
    reloadDocument: i,
    replace: o,
    state: l,
    method: u = O1,
    action: I,
    onSubmit: f,
    relative: h,
    preventScrollReset: v,
    unstable_viewTransition: b
  } = a, S = pX(a, NP), R = $P(), W = eJ(I, {
    relative: h
  }), x = u.toLowerCase() === "get" ? "get" : "post", M = (T) => {
    if (f && f(T), T.defaultPrevented) return;
    T.preventDefault();
    let E = T.nativeEvent.submitter, _ = E?.getAttribute("formmethod") || u;
    R(E || T.currentTarget, {
      fetcherKey: t,
      method: _,
      navigate: n,
      replace: o,
      state: l,
      relative: h,
      preventScrollReset: v,
      unstable_viewTransition: b
    });
  };
  return /* @__PURE__ */ xe.createElement("form", qA({
    ref: e,
    method: x,
    action: W,
    onSubmit: i ? f : M
  }, S));
});
zC.NODE_ENV !== "production" && (OP.displayName = "Form");
var o2;
(function(a) {
  a.UseScrollRestoration = "useScrollRestoration", a.UseSubmit = "useSubmit", a.UseSubmitFetcher = "useSubmitFetcher", a.UseFetcher = "useFetcher", a.useViewTransitionState = "useViewTransitionState";
})(o2 || (o2 = {}));
var eT;
(function(a) {
  a.UseFetcher = "useFetcher", a.UseFetchers = "useFetchers", a.UseScrollRestoration = "useScrollRestoration";
})(eT || (eT = {}));
function PP(a) {
  return a + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function V5(a) {
  let e = xe.useContext(uB);
  return e || (zC.NODE_ENV !== "production" ? ki(!1, PP(a)) : ki(!1)), e;
}
function JP(a, e) {
  let {
    target: t,
    replace: n,
    state: i,
    preventScrollReset: o,
    relative: l,
    unstable_viewTransition: u
  } = e === void 0 ? {} : e, I = Sb(), f = Pg(), h = _w(a, {
    relative: l
  });
  return xe.useCallback((v) => {
    if (SP(v, t)) {
      v.preventDefault();
      let b = n !== void 0 ? n : jA(f) === jA(h);
      I(a, {
        replace: b,
        state: i,
        preventScrollReset: o,
        relative: l,
        unstable_viewTransition: u
      });
    }
  }, [f, I, h, n, i, t, a, o, l, u]);
}
function N5(a) {
  zC.NODE_ENV !== "production" && Gl(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.");
  let e = xe.useRef(vH(a)), t = xe.useRef(!1), n = Pg(), i = xe.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    ZP(n.search, t.current ? null : e.current)
  ), [n.search]), o = Sb(), l = xe.useCallback((u, I) => {
    const f = vH(typeof u == "function" ? u(i) : u);
    t.current = !0, o("?" + f, I);
  }, [o, i]);
  return [i, l];
}
function QP() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let jP = 0, qP = () => "__" + String(++jP) + "__";
function $P() {
  let {
    router: a
  } = V5(o2.UseSubmit), {
    basename: e
  } = xe.useContext(_C), t = hP();
  return xe.useCallback(function(n, i) {
    i === void 0 && (i = {}), QP();
    let {
      action: o,
      method: l,
      encType: u,
      formData: I,
      body: f
    } = xP(n, e);
    if (i.navigate === !1) {
      let h = i.fetcherKey || qP();
      a.fetch(h, t, i.action || o, {
        preventScrollReset: i.preventScrollReset,
        formData: I,
        body: f,
        formMethod: i.method || l,
        formEncType: i.encType || u,
        unstable_flushSync: i.unstable_flushSync
      });
    } else
      a.navigate(i.action || o, {
        preventScrollReset: i.preventScrollReset,
        formData: I,
        body: f,
        formMethod: i.method || l,
        formEncType: i.encType || u,
        replace: i.replace,
        state: i.state,
        fromRouteId: t,
        unstable_flushSync: i.unstable_flushSync,
        unstable_viewTransition: i.unstable_viewTransition
      });
  }, [a, e, t]);
}
function eJ(a, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    basename: n
  } = xe.useContext(_C), i = xe.useContext(dp);
  i || (zC.NODE_ENV !== "production" ? ki(!1, "useFormAction must be used inside a RouteContext") : ki(!1));
  let [o] = i.matches.slice(-1), l = qA({}, _w(a || ".", {
    relative: t
  })), u = Pg();
  if (a == null) {
    l.search = u.search;
    let I = new URLSearchParams(l.search);
    I.has("index") && I.get("index") === "" && (I.delete("index"), l.search = I.toString() ? "?" + I.toString() : "");
  }
  return (!a || a === ".") && o.route.index && (l.search = l.search ? l.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (l.pathname = l.pathname === "/" ? n : op([n, l.pathname])), jA(l);
}
function tJ(a, e) {
  e === void 0 && (e = {});
  let t = xe.useContext(mX);
  t == null && (zC.NODE_ENV !== "production" ? ki(!1, "`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : ki(!1));
  let {
    basename: n
  } = V5(o2.useViewTransitionState), i = _w(a, {
    relative: e.relative
  });
  if (!t.isTransitioning)
    return !1;
  let o = Th(t.currentLocation.pathname, n) || t.currentLocation.pathname, l = Th(t.nextLocation.pathname, n) || t.nextLocation.pathname;
  return i2(i.pathname, l) != null || i2(i.pathname, o) != null;
}
function sw() {
  return sw = Object.assign ? Object.assign.bind() : function(a) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (a[n] = t[n]);
    }
    return a;
  }, sw.apply(null, arguments);
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const lW = "167", Oy = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Py = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, M5 = 0, yH = 1, H5 = 2, nJ = 3, X5 = 0, uW = 1, LZ = 2, Yh = 3, Nm = 0, Dg = 1, ep = 2, Vm = 0, ub = 1, bH = 2, GH = 3, BH = 4, Y5 = 5, kA = 100, F5 = 101, E5 = 102, T5 = 103, _5 = 104, z5 = 200, K5 = 201, L5 = 202, k5 = 203, s2 = 204, l2 = 205, D5 = 206, U5 = 207, O5 = 208, P5 = 209, J5 = 210, Q5 = 211, j5 = 212, q5 = 213, $5 = 214, ez = 0, tz = 1, nz = 2, lw = 3, iz = 4, rz = 5, az = 6, oz = 7, zw = 0, sz = 1, lz = 2, sp = 0, uz = 1, cz = 2, gz = 3, vX = 4, dz = 5, Iz = 6, Cz = 7, SH = "attached", hz = "detached", cW = 300, Mm = 301, $A = 302, uw = 303, cw = 304, gB = 306, gw = 1e3, XC = 1001, dw = 1002, _u = 1003, yX = 1004, iJ = 1004, FG = 1005, rJ = 1005, nl = 1006, kZ = 1007, aJ = 1007, np = 1008, oJ = 1008, _h = 1009, bX = 1010, GX = 1011, qG = 1012, gW = 1013, Hm = 1014, kg = 1015, Zb = 1016, dW = 1017, IW = 1018, Ab = 1020, BX = 35902, SX = 1021, ZX = 1022, rg = 1023, wX = 1024, RX = 1025, cb = 1026, vb = 1027, CW = 1028, Kw = 1029, xX = 1030, hW = 1031, sJ = 1032, fW = 1033, DZ = 33776, UZ = 33777, OZ = 33778, PZ = 33779, u2 = 35840, c2 = 35841, g2 = 35842, d2 = 35843, I2 = 36196, C2 = 37492, h2 = 37496, f2 = 37808, p2 = 37809, m2 = 37810, A2 = 37811, v2 = 37812, y2 = 37813, b2 = 37814, G2 = 37815, B2 = 37816, S2 = 37817, Z2 = 37818, w2 = 37819, R2 = 37820, x2 = 37821, JZ = 36492, W2 = 36494, V2 = 36495, WX = 36283, N2 = 36284, M2 = 36285, H2 = 36286, fz = 2200, pz = 2201, mz = 2202, Iw = 2300, X2 = 2301, J1 = 2302, rb = 2400, ab = 2401, Cw = 2402, pW = 2500, VX = 2501, lJ = 0, uJ = 1, cJ = 2, Az = 3200, vz = 3201, gJ = 3202, dJ = 3203, iv = 0, yz = 1, Sm = "", HC = "srgb", Tm = "srgb-linear", mW = "display-p3", Lw = "display-p3-linear", hw = "linear", Po = "srgb", fw = "rec709", pw = "p3", IJ = 0, Jy = 7680, CJ = 7681, hJ = 7682, fJ = 7683, pJ = 34055, mJ = 34056, AJ = 5386, vJ = 512, yJ = 513, bJ = 514, GJ = 515, BJ = 516, SJ = 517, ZJ = 518, ZH = 519, bz = 512, Gz = 513, Bz = 514, NX = 515, Sz = 516, Zz = 517, wz = 518, Rz = 519, mw = 35044, xz = 35048, wJ = 35040, RJ = 35045, xJ = 35049, WJ = 35041, VJ = 35046, NJ = 35050, MJ = 35042, HJ = "100", wH = "300 es", ip = 2e3, Aw = 2001;
class Ip {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let o = 0, l = i.length; o < l; o++)
        i[o].call(this, e);
      e.target = null;
    }
  }
}
const Qc = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let tT = 1234567;
const gb = Math.PI / 180, $G = 180 / Math.PI;
function zI() {
  const a = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Qc[a & 255] + Qc[a >> 8 & 255] + Qc[a >> 16 & 255] + Qc[a >> 24 & 255] + "-" + Qc[e & 255] + Qc[e >> 8 & 255] + "-" + Qc[e >> 16 & 15 | 64] + Qc[e >> 24 & 255] + "-" + Qc[t & 63 | 128] + Qc[t >> 8 & 255] + "-" + Qc[t >> 16 & 255] + Qc[t >> 24 & 255] + Qc[n & 255] + Qc[n >> 8 & 255] + Qc[n >> 16 & 255] + Qc[n >> 24 & 255]).toLowerCase();
}
function el(a, e, t) {
  return Math.max(e, Math.min(t, a));
}
function MX(a, e) {
  return (a % e + e) % e;
}
function XJ(a, e, t, n, i) {
  return n + (a - e) * (i - n) / (t - e);
}
function YJ(a, e, t) {
  return a !== e ? (t - a) / (e - a) : 0;
}
function QZ(a, e, t) {
  return (1 - t) * a + t * e;
}
function FJ(a, e, t, n) {
  return QZ(a, e, 1 - Math.exp(-t * n));
}
function EJ(a, e = 1) {
  return e - Math.abs(MX(a, e * 2) - e);
}
function TJ(a, e, t) {
  return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e), a * a * (3 - 2 * a));
}
function _J(a, e, t) {
  return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e), a * a * a * (a * (a * 6 - 15) + 10));
}
function zJ(a, e) {
  return a + Math.floor(Math.random() * (e - a + 1));
}
function KJ(a, e) {
  return a + Math.random() * (e - a);
}
function LJ(a) {
  return a * (0.5 - Math.random());
}
function kJ(a) {
  a !== void 0 && (tT = a);
  let e = tT += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function DJ(a) {
  return a * gb;
}
function UJ(a) {
  return a * $G;
}
function OJ(a) {
  return (a & a - 1) === 0 && a !== 0;
}
function PJ(a) {
  return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
}
function JJ(a) {
  return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
}
function QJ(a, e, t, n, i) {
  const o = Math.cos, l = Math.sin, u = o(t / 2), I = l(t / 2), f = o((e + n) / 2), h = l((e + n) / 2), v = o((e - n) / 2), b = l((e - n) / 2), S = o((n - e) / 2), R = l((n - e) / 2);
  switch (i) {
    case "XYX":
      a.set(u * h, I * v, I * b, u * f);
      break;
    case "YZY":
      a.set(I * b, u * h, I * v, u * f);
      break;
    case "ZXZ":
      a.set(I * v, I * b, u * h, u * f);
      break;
    case "XZX":
      a.set(u * h, I * R, I * S, u * f);
      break;
    case "YXY":
      a.set(I * S, u * h, I * R, u * f);
      break;
    case "ZYZ":
      a.set(I * R, I * S, u * h, u * f);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function Kg(a, e) {
  switch (e.constructor) {
    case Float32Array:
      return a;
    case Uint32Array:
      return a / 4294967295;
    case Uint16Array:
      return a / 65535;
    case Uint8Array:
      return a / 255;
    case Int32Array:
      return Math.max(a / 2147483647, -1);
    case Int16Array:
      return Math.max(a / 32767, -1);
    case Int8Array:
      return Math.max(a / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Mr(a, e) {
  switch (e.constructor) {
    case Float32Array:
      return a;
    case Uint32Array:
      return Math.round(a * 4294967295);
    case Uint16Array:
      return Math.round(a * 65535);
    case Uint8Array:
      return Math.round(a * 255);
    case Int32Array:
      return Math.round(a * 2147483647);
    case Int16Array:
      return Math.round(a * 32767);
    case Int8Array:
      return Math.round(a * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const jJ = {
  DEG2RAD: gb,
  RAD2DEG: $G,
  generateUUID: zI,
  clamp: el,
  euclideanModulo: MX,
  mapLinear: XJ,
  inverseLerp: YJ,
  lerp: QZ,
  damp: FJ,
  pingpong: EJ,
  smoothstep: TJ,
  smootherstep: _J,
  randInt: zJ,
  randFloat: KJ,
  randFloatSpread: LJ,
  seededRandom: kJ,
  degToRad: DJ,
  radToDeg: UJ,
  isPowerOfTwo: OJ,
  ceilPowerOfTwo: PJ,
  floorPowerOfTwo: JJ,
  setQuaternionFromProperEuler: QJ,
  normalize: Mr,
  denormalize: Kg
};
class sn {
  constructor(e = 0, t = 0) {
    sn.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(el(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), i = Math.sin(t), o = this.x - e.x, l = this.y - e.y;
    return this.x = o * n - l * i + e.x, this.y = o * i + l * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Nr {
  constructor(e, t, n, i, o, l, u, I, f) {
    Nr.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, o, l, u, I, f);
  }
  set(e, t, n, i, o, l, u, I, f) {
    const h = this.elements;
    return h[0] = e, h[1] = i, h[2] = u, h[3] = t, h[4] = o, h[5] = I, h[6] = n, h[7] = l, h[8] = f, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, o = this.elements, l = n[0], u = n[3], I = n[6], f = n[1], h = n[4], v = n[7], b = n[2], S = n[5], R = n[8], W = i[0], x = i[3], M = i[6], T = i[1], E = i[4], _ = i[7], P = i[2], U = i[5], q = i[8];
    return o[0] = l * W + u * T + I * P, o[3] = l * x + u * E + I * U, o[6] = l * M + u * _ + I * q, o[1] = f * W + h * T + v * P, o[4] = f * x + h * E + v * U, o[7] = f * M + h * _ + v * q, o[2] = b * W + S * T + R * P, o[5] = b * x + S * E + R * U, o[8] = b * M + S * _ + R * q, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], u = e[5], I = e[6], f = e[7], h = e[8];
    return t * l * h - t * u * f - n * o * h + n * u * I + i * o * f - i * l * I;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], u = e[5], I = e[6], f = e[7], h = e[8], v = h * l - u * f, b = u * I - h * o, S = f * o - l * I, R = t * v + n * b + i * S;
    if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const W = 1 / R;
    return e[0] = v * W, e[1] = (i * f - h * n) * W, e[2] = (u * n - i * l) * W, e[3] = b * W, e[4] = (h * t - i * I) * W, e[5] = (i * o - u * t) * W, e[6] = S * W, e[7] = (n * I - f * t) * W, e[8] = (l * t - n * o) * W, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, i, o, l, u) {
    const I = Math.cos(o), f = Math.sin(o);
    return this.set(
      n * I,
      n * f,
      -n * (I * l + f * u) + l + e,
      -i * f,
      i * I,
      -i * (-f * l + I * u) + u + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(jN.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(jN.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(jN.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const jN = /* @__PURE__ */ new Nr();
function Wz(a) {
  for (let e = a.length - 1; e >= 0; --e)
    if (a[e] >= 65535) return !0;
  return !1;
}
const qJ = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function EG(a, e) {
  return new qJ[a](e);
}
function vw(a) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", a);
}
function Vz() {
  const a = vw("canvas");
  return a.style.display = "block", a;
}
const nT = {};
function DG(a) {
  a in nT || (nT[a] = !0, console.warn(a));
}
function $J(a, e, t) {
  return new Promise(function(n, i) {
    function o() {
      switch (a.clientWaitSync(e, a.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case a.WAIT_FAILED:
          i();
          break;
        case a.TIMEOUT_EXPIRED:
          setTimeout(o, t);
          break;
        default:
          n();
      }
    }
    setTimeout(o, t);
  });
}
const iT = /* @__PURE__ */ new Nr().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), rT = /* @__PURE__ */ new Nr().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), hZ = {
  [Tm]: {
    transfer: hw,
    primaries: fw,
    luminanceCoefficients: [0.2126, 0.7152, 0.0722],
    toReference: (a) => a,
    fromReference: (a) => a
  },
  [HC]: {
    transfer: Po,
    primaries: fw,
    luminanceCoefficients: [0.2126, 0.7152, 0.0722],
    toReference: (a) => a.convertSRGBToLinear(),
    fromReference: (a) => a.convertLinearToSRGB()
  },
  [Lw]: {
    transfer: hw,
    primaries: pw,
    luminanceCoefficients: [0.2289, 0.6917, 0.0793],
    toReference: (a) => a.applyMatrix3(rT),
    fromReference: (a) => a.applyMatrix3(iT)
  },
  [mW]: {
    transfer: Po,
    primaries: pw,
    luminanceCoefficients: [0.2289, 0.6917, 0.0793],
    toReference: (a) => a.convertSRGBToLinear().applyMatrix3(rT),
    fromReference: (a) => a.applyMatrix3(iT).convertLinearToSRGB()
  }
}, eQ = /* @__PURE__ */ new Set([Tm, Lw]), Ta = {
  enabled: !0,
  _workingColorSpace: Tm,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(a) {
    if (!eQ.has(a))
      throw new Error(`Unsupported working color space, "${a}".`);
    this._workingColorSpace = a;
  },
  convert: function(a, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return a;
    const n = hZ[e].toReference, i = hZ[t].fromReference;
    return i(n(a));
  },
  fromWorkingColorSpace: function(a, e) {
    return this.convert(a, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(a, e) {
    return this.convert(a, e, this._workingColorSpace);
  },
  getPrimaries: function(a) {
    return hZ[a].primaries;
  },
  getTransfer: function(a) {
    return a === Sm ? hw : hZ[a].transfer;
  },
  getLuminanceCoefficients: function(a, e = this._workingColorSpace) {
    return a.fromArray(hZ[e].luminanceCoefficients);
  }
};
function UG(a) {
  return a < 0.04045 ? a * 0.0773993808 : Math.pow(a * 0.9478672986 + 0.0521327014, 2.4);
}
function qN(a) {
  return a < 31308e-7 ? a * 12.92 : 1.055 * Math.pow(a, 0.41666) - 0.055;
}
let lG;
class Nz {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      lG === void 0 && (lG = vw("canvas")), lG.width = e.width, lG.height = e.height;
      const n = lG.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = lG;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = vw("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height), o = i.data;
      for (let l = 0; l < o.length; l++)
        o[l] = UG(o[l] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(UG(t[n] / 255) * 255) : t[n] = UG(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let tQ = 0;
class ob {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: tQ++ }), this.uuid = zI(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let l = 0, u = i.length; l < u; l++)
          i[l].isDataTexture ? o.push($N(i[l].image)) : o.push($N(i[l]));
      } else
        o = $N(i);
      n.url = o;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function $N(a) {
  return typeof HTMLImageElement < "u" && a instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && a instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && a instanceof ImageBitmap ? Nz.getDataURL(a) : a.data ? {
    data: Array.from(a.data),
    width: a.width,
    height: a.height,
    type: a.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let nQ = 0;
class Fs extends Ip {
  constructor(e = Fs.DEFAULT_IMAGE, t = Fs.DEFAULT_MAPPING, n = XC, i = XC, o = nl, l = np, u = rg, I = _h, f = Fs.DEFAULT_ANISOTROPY, h = Sm) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: nQ++ }), this.uuid = zI(), this.name = "", this.source = new ob(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = o, this.minFilter = l, this.anisotropy = f, this.format = u, this.internalFormat = null, this.type = I, this.offset = new sn(0, 0), this.repeat = new sn(1, 1), this.center = new sn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Nr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== cW) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case gw:
          e.x = e.x - Math.floor(e.x);
          break;
        case XC:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case dw:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case gw:
          e.y = e.y - Math.floor(e.y);
          break;
        case XC:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case dw:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Fs.DEFAULT_IMAGE = null;
Fs.DEFAULT_MAPPING = cW;
Fs.DEFAULT_ANISOTROPY = 1;
class ro {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    ro.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, o = this.w, l = e.elements;
    return this.x = l[0] * t + l[4] * n + l[8] * i + l[12] * o, this.y = l[1] * t + l[5] * n + l[9] * i + l[13] * o, this.z = l[2] * t + l[6] * n + l[10] * i + l[14] * o, this.w = l[3] * t + l[7] * n + l[11] * i + l[15] * o, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, o;
    const I = e.elements, f = I[0], h = I[4], v = I[8], b = I[1], S = I[5], R = I[9], W = I[2], x = I[6], M = I[10];
    if (Math.abs(h - b) < 0.01 && Math.abs(v - W) < 0.01 && Math.abs(R - x) < 0.01) {
      if (Math.abs(h + b) < 0.1 && Math.abs(v + W) < 0.1 && Math.abs(R + x) < 0.1 && Math.abs(f + S + M - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const E = (f + 1) / 2, _ = (S + 1) / 2, P = (M + 1) / 2, U = (h + b) / 4, q = (v + W) / 4, k = (R + x) / 4;
      return E > _ && E > P ? E < 0.01 ? (n = 0, i = 0.707106781, o = 0.707106781) : (n = Math.sqrt(E), i = U / n, o = q / n) : _ > P ? _ < 0.01 ? (n = 0.707106781, i = 0, o = 0.707106781) : (i = Math.sqrt(_), n = U / i, o = k / i) : P < 0.01 ? (n = 0.707106781, i = 0.707106781, o = 0) : (o = Math.sqrt(P), n = q / o, i = k / o), this.set(n, i, o, t), this;
    }
    let T = Math.sqrt((x - R) * (x - R) + (v - W) * (v - W) + (b - h) * (b - h));
    return Math.abs(T) < 1e-3 && (T = 1), this.x = (x - R) / T, this.y = (v - W) / T, this.z = (b - h) / T, this.w = Math.acos((f + S + M - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Mz extends Ip {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new ro(0, 0, e, t), this.scissorTest = !1, this.viewport = new ro(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: nl,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const o = new Fs(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    o.flipY = !1, o.generateMipmaps = n.generateMipmaps, o.internalFormat = n.internalFormat, this.textures = [];
    const l = n.count;
    for (let u = 0; u < l; u++)
      this.textures[u] = o.clone(), this.textures[u].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let i = 0, o = this.textures.length; i < o; i++)
        this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, i = e.textures.length; n < i; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new ob(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class EC extends Mz {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class AW extends Fs {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = _u, this.minFilter = _u, this.wrapR = XC, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class iQ extends EC {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new AW(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class HX extends Fs {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = _u, this.minFilter = _u, this.wrapR = XC, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class rQ extends EC {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new HX(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
let zu = class {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
  }
  static slerpFlat(e, t, n, i, o, l, u) {
    let I = n[i + 0], f = n[i + 1], h = n[i + 2], v = n[i + 3];
    const b = o[l + 0], S = o[l + 1], R = o[l + 2], W = o[l + 3];
    if (u === 0) {
      e[t + 0] = I, e[t + 1] = f, e[t + 2] = h, e[t + 3] = v;
      return;
    }
    if (u === 1) {
      e[t + 0] = b, e[t + 1] = S, e[t + 2] = R, e[t + 3] = W;
      return;
    }
    if (v !== W || I !== b || f !== S || h !== R) {
      let x = 1 - u;
      const M = I * b + f * S + h * R + v * W, T = M >= 0 ? 1 : -1, E = 1 - M * M;
      if (E > Number.EPSILON) {
        const P = Math.sqrt(E), U = Math.atan2(P, M * T);
        x = Math.sin(x * U) / P, u = Math.sin(u * U) / P;
      }
      const _ = u * T;
      if (I = I * x + b * _, f = f * x + S * _, h = h * x + R * _, v = v * x + W * _, x === 1 - u) {
        const P = 1 / Math.sqrt(I * I + f * f + h * h + v * v);
        I *= P, f *= P, h *= P, v *= P;
      }
    }
    e[t] = I, e[t + 1] = f, e[t + 2] = h, e[t + 3] = v;
  }
  static multiplyQuaternionsFlat(e, t, n, i, o, l) {
    const u = n[i], I = n[i + 1], f = n[i + 2], h = n[i + 3], v = o[l], b = o[l + 1], S = o[l + 2], R = o[l + 3];
    return e[t] = u * R + h * v + I * S - f * b, e[t + 1] = I * R + h * b + f * v - u * S, e[t + 2] = f * R + h * S + u * b - I * v, e[t + 3] = h * R - u * v - I * b - f * S, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, i) {
    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const n = e._x, i = e._y, o = e._z, l = e._order, u = Math.cos, I = Math.sin, f = u(n / 2), h = u(i / 2), v = u(o / 2), b = I(n / 2), S = I(i / 2), R = I(o / 2);
    switch (l) {
      case "XYZ":
        this._x = b * h * v + f * S * R, this._y = f * S * v - b * h * R, this._z = f * h * R + b * S * v, this._w = f * h * v - b * S * R;
        break;
      case "YXZ":
        this._x = b * h * v + f * S * R, this._y = f * S * v - b * h * R, this._z = f * h * R - b * S * v, this._w = f * h * v + b * S * R;
        break;
      case "ZXY":
        this._x = b * h * v - f * S * R, this._y = f * S * v + b * h * R, this._z = f * h * R + b * S * v, this._w = f * h * v - b * S * R;
        break;
      case "ZYX":
        this._x = b * h * v - f * S * R, this._y = f * S * v + b * h * R, this._z = f * h * R - b * S * v, this._w = f * h * v + b * S * R;
        break;
      case "YZX":
        this._x = b * h * v + f * S * R, this._y = f * S * v + b * h * R, this._z = f * h * R - b * S * v, this._w = f * h * v - b * S * R;
        break;
      case "XZY":
        this._x = b * h * v - f * S * R, this._y = f * S * v - b * h * R, this._z = f * h * R + b * S * v, this._w = f * h * v + b * S * R;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, i = Math.sin(n);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], i = t[4], o = t[8], l = t[1], u = t[5], I = t[9], f = t[2], h = t[6], v = t[10], b = n + u + v;
    if (b > 0) {
      const S = 0.5 / Math.sqrt(b + 1);
      this._w = 0.25 / S, this._x = (h - I) * S, this._y = (o - f) * S, this._z = (l - i) * S;
    } else if (n > u && n > v) {
      const S = 2 * Math.sqrt(1 + n - u - v);
      this._w = (h - I) / S, this._x = 0.25 * S, this._y = (i + l) / S, this._z = (o + f) / S;
    } else if (u > v) {
      const S = 2 * Math.sqrt(1 + u - n - v);
      this._w = (o - f) / S, this._x = (i + l) / S, this._y = 0.25 * S, this._z = (I + h) / S;
    } else {
      const S = 2 * Math.sqrt(1 + v - n - u);
      this._w = (l - i) / S, this._x = (o + f) / S, this._y = (I + h) / S, this._z = 0.25 * S;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(el(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, i = e._y, o = e._z, l = e._w, u = t._x, I = t._y, f = t._z, h = t._w;
    return this._x = n * h + l * u + i * f - o * I, this._y = i * h + l * I + o * u - n * f, this._z = o * h + l * f + n * I - i * u, this._w = l * h - n * u - i * I - o * f, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x, i = this._y, o = this._z, l = this._w;
    let u = l * e._w + n * e._x + i * e._y + o * e._z;
    if (u < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, u = -u) : this.copy(e), u >= 1)
      return this._w = l, this._x = n, this._y = i, this._z = o, this;
    const I = 1 - u * u;
    if (I <= Number.EPSILON) {
      const S = 1 - t;
      return this._w = S * l + t * this._w, this._x = S * n + t * this._x, this._y = S * i + t * this._y, this._z = S * o + t * this._z, this.normalize(), this;
    }
    const f = Math.sqrt(I), h = Math.atan2(f, u), v = Math.sin((1 - t) * h) / f, b = Math.sin(t * h) / f;
    return this._w = l * v + this._w * b, this._x = n * v + this._x * b, this._y = i * v + this._y * b, this._z = o * v + this._z * b, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), o = Math.sqrt(n);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      o * Math.sin(t),
      o * Math.cos(t)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
};
class Ze {
  constructor(e = 0, t = 0, n = 0) {
    Ze.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(aT.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(aT.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[3] * n + o[6] * i, this.y = o[1] * t + o[4] * n + o[7] * i, this.z = o[2] * t + o[5] * n + o[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements, l = 1 / (o[3] * t + o[7] * n + o[11] * i + o[15]);
    return this.x = (o[0] * t + o[4] * n + o[8] * i + o[12]) * l, this.y = (o[1] * t + o[5] * n + o[9] * i + o[13]) * l, this.z = (o[2] * t + o[6] * n + o[10] * i + o[14]) * l, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z, I = e.w, f = 2 * (l * i - u * n), h = 2 * (u * t - o * i), v = 2 * (o * n - l * t);
    return this.x = t + I * f + l * v - u * h, this.y = n + I * h + u * f - o * v, this.z = i + I * v + o * h - l * f, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[4] * n + o[8] * i, this.y = o[1] * t + o[5] * n + o[9] * i, this.z = o[2] * t + o[6] * n + o[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, i = e.y, o = e.z, l = t.x, u = t.y, I = t.z;
    return this.x = i * I - o * u, this.y = o * l - n * I, this.z = n * u - i * l, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return eM.copy(this).projectOnVector(e), this.sub(eM);
  }
  reflect(e) {
    return this.sub(eM.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(el(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const eM = /* @__PURE__ */ new Ze(), aT = /* @__PURE__ */ new zu();
class Ug {
  constructor(e = new Ze(1 / 0, 1 / 0, 1 / 0), t = new Ze(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Vh.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Vh.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Vh.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const o = n.getAttribute("position");
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let l = 0, u = o.count; l < u; l++)
          e.isMesh === !0 ? e.getVertexPosition(l, Vh) : Vh.fromBufferAttribute(o, l), Vh.applyMatrix4(e.matrixWorld), this.expandByPoint(Vh);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Kx.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Kx.copy(n.boundingBox)), Kx.applyMatrix4(e.matrixWorld), this.union(Kx);
    }
    const i = e.children;
    for (let o = 0, l = i.length; o < l; o++)
      this.expandByObject(i[o], t);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Vh), Vh.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(fZ), Lx.subVectors(this.max, fZ), uG.subVectors(e.a, fZ), cG.subVectors(e.b, fZ), gG.subVectors(e.c, fZ), MA.subVectors(cG, uG), HA.subVectors(gG, cG), My.subVectors(uG, gG);
    let t = [
      0,
      -MA.z,
      MA.y,
      0,
      -HA.z,
      HA.y,
      0,
      -My.z,
      My.y,
      MA.z,
      0,
      -MA.x,
      HA.z,
      0,
      -HA.x,
      My.z,
      0,
      -My.x,
      -MA.y,
      MA.x,
      0,
      -HA.y,
      HA.x,
      0,
      -My.y,
      My.x,
      0
    ];
    return !tM(t, uG, cG, gG, Lx) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !tM(t, uG, cG, gG, Lx)) ? !1 : (kx.crossVectors(MA, HA), t = [kx.x, kx.y, kx.z], tM(t, uG, cG, gG, Lx));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Vh).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Vh).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (fm[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), fm[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), fm[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), fm[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), fm[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), fm[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), fm[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), fm[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(fm), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const fm = [
  /* @__PURE__ */ new Ze(),
  /* @__PURE__ */ new Ze(),
  /* @__PURE__ */ new Ze(),
  /* @__PURE__ */ new Ze(),
  /* @__PURE__ */ new Ze(),
  /* @__PURE__ */ new Ze(),
  /* @__PURE__ */ new Ze(),
  /* @__PURE__ */ new Ze()
], Vh = /* @__PURE__ */ new Ze(), Kx = /* @__PURE__ */ new Ug(), uG = /* @__PURE__ */ new Ze(), cG = /* @__PURE__ */ new Ze(), gG = /* @__PURE__ */ new Ze(), MA = /* @__PURE__ */ new Ze(), HA = /* @__PURE__ */ new Ze(), My = /* @__PURE__ */ new Ze(), fZ = /* @__PURE__ */ new Ze(), Lx = /* @__PURE__ */ new Ze(), kx = /* @__PURE__ */ new Ze(), Hy = /* @__PURE__ */ new Ze();
function tM(a, e, t, n, i) {
  for (let o = 0, l = a.length - 3; o <= l; o += 3) {
    Hy.fromArray(a, o);
    const u = i.x * Math.abs(Hy.x) + i.y * Math.abs(Hy.y) + i.z * Math.abs(Hy.z), I = e.dot(Hy), f = t.dot(Hy), h = n.dot(Hy);
    if (Math.max(-Math.max(I, f, h), Math.min(I, f, h)) > u)
      return !1;
  }
  return !0;
}
const aQ = /* @__PURE__ */ new Ug(), pZ = /* @__PURE__ */ new Ze(), nM = /* @__PURE__ */ new Ze();
class og {
  constructor(e = new Ze(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : aQ.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let o = 0, l = e.length; o < l; o++)
      i = Math.max(i, n.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    pZ.subVectors(e, this.center);
    const t = pZ.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(pZ, i / n), this.radius += i;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (nM.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(pZ.copy(e.center).add(nM)), this.expandByPoint(pZ.copy(e.center).sub(nM))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const pm = /* @__PURE__ */ new Ze(), iM = /* @__PURE__ */ new Ze(), Dx = /* @__PURE__ */ new Ze(), XA = /* @__PURE__ */ new Ze(), rM = /* @__PURE__ */ new Ze(), Ux = /* @__PURE__ */ new Ze(), aM = /* @__PURE__ */ new Ze();
let wb = class {
  constructor(e = new Ze(), t = new Ze(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, pm)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = pm.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (pm.copy(this.origin).addScaledVector(this.direction, t), pm.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    iM.copy(e).add(t).multiplyScalar(0.5), Dx.copy(t).sub(e).normalize(), XA.copy(this.origin).sub(iM);
    const o = e.distanceTo(t) * 0.5, l = -this.direction.dot(Dx), u = XA.dot(this.direction), I = -XA.dot(Dx), f = XA.lengthSq(), h = Math.abs(1 - l * l);
    let v, b, S, R;
    if (h > 0)
      if (v = l * I - u, b = l * u - I, R = o * h, v >= 0)
        if (b >= -R)
          if (b <= R) {
            const W = 1 / h;
            v *= W, b *= W, S = v * (v + l * b + 2 * u) + b * (l * v + b + 2 * I) + f;
          } else
            b = o, v = Math.max(0, -(l * b + u)), S = -v * v + b * (b + 2 * I) + f;
        else
          b = -o, v = Math.max(0, -(l * b + u)), S = -v * v + b * (b + 2 * I) + f;
      else
        b <= -R ? (v = Math.max(0, -(-l * o + u)), b = v > 0 ? -o : Math.min(Math.max(-o, -I), o), S = -v * v + b * (b + 2 * I) + f) : b <= R ? (v = 0, b = Math.min(Math.max(-o, -I), o), S = b * (b + 2 * I) + f) : (v = Math.max(0, -(l * o + u)), b = v > 0 ? o : Math.min(Math.max(-o, -I), o), S = -v * v + b * (b + 2 * I) + f);
    else
      b = l > 0 ? -o : o, v = Math.max(0, -(l * b + u)), S = -v * v + b * (b + 2 * I) + f;
    return n && n.copy(this.origin).addScaledVector(this.direction, v), i && i.copy(iM).addScaledVector(Dx, b), S;
  }
  intersectSphere(e, t) {
    pm.subVectors(e.center, this.origin);
    const n = pm.dot(this.direction), i = pm.dot(pm) - n * n, o = e.radius * e.radius;
    if (i > o) return null;
    const l = Math.sqrt(o - i), u = n - l, I = n + l;
    return I < 0 ? null : u < 0 ? this.at(I, t) : this.at(u, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, o, l, u, I;
    const f = 1 / this.direction.x, h = 1 / this.direction.y, v = 1 / this.direction.z, b = this.origin;
    return f >= 0 ? (n = (e.min.x - b.x) * f, i = (e.max.x - b.x) * f) : (n = (e.max.x - b.x) * f, i = (e.min.x - b.x) * f), h >= 0 ? (o = (e.min.y - b.y) * h, l = (e.max.y - b.y) * h) : (o = (e.max.y - b.y) * h, l = (e.min.y - b.y) * h), n > l || o > i || ((o > n || isNaN(n)) && (n = o), (l < i || isNaN(i)) && (i = l), v >= 0 ? (u = (e.min.z - b.z) * v, I = (e.max.z - b.z) * v) : (u = (e.max.z - b.z) * v, I = (e.min.z - b.z) * v), n > I || u > i) || ((u > n || n !== n) && (n = u), (I < i || i !== i) && (i = I), i < 0) ? null : this.at(n >= 0 ? n : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, pm) !== null;
  }
  intersectTriangle(e, t, n, i, o) {
    rM.subVectors(t, e), Ux.subVectors(n, e), aM.crossVectors(rM, Ux);
    let l = this.direction.dot(aM), u;
    if (l > 0) {
      if (i) return null;
      u = 1;
    } else if (l < 0)
      u = -1, l = -l;
    else
      return null;
    XA.subVectors(this.origin, e);
    const I = u * this.direction.dot(Ux.crossVectors(XA, Ux));
    if (I < 0)
      return null;
    const f = u * this.direction.dot(rM.cross(XA));
    if (f < 0 || I + f > l)
      return null;
    const h = -u * XA.dot(aM);
    return h < 0 ? null : this.at(h / l, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
class tr {
  constructor(e, t, n, i, o, l, u, I, f, h, v, b, S, R, W, x) {
    tr.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, o, l, u, I, f, h, v, b, S, R, W, x);
  }
  set(e, t, n, i, o, l, u, I, f, h, v, b, S, R, W, x) {
    const M = this.elements;
    return M[0] = e, M[4] = t, M[8] = n, M[12] = i, M[1] = o, M[5] = l, M[9] = u, M[13] = I, M[2] = f, M[6] = h, M[10] = v, M[14] = b, M[3] = S, M[7] = R, M[11] = W, M[15] = x, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new tr().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, i = 1 / dG.setFromMatrixColumn(e, 0).length(), o = 1 / dG.setFromMatrixColumn(e, 1).length(), l = 1 / dG.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * o, t[5] = n[5] * o, t[6] = n[6] * o, t[7] = 0, t[8] = n[8] * l, t[9] = n[9] * l, t[10] = n[10] * l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, i = e.y, o = e.z, l = Math.cos(n), u = Math.sin(n), I = Math.cos(i), f = Math.sin(i), h = Math.cos(o), v = Math.sin(o);
    if (e.order === "XYZ") {
      const b = l * h, S = l * v, R = u * h, W = u * v;
      t[0] = I * h, t[4] = -I * v, t[8] = f, t[1] = S + R * f, t[5] = b - W * f, t[9] = -u * I, t[2] = W - b * f, t[6] = R + S * f, t[10] = l * I;
    } else if (e.order === "YXZ") {
      const b = I * h, S = I * v, R = f * h, W = f * v;
      t[0] = b + W * u, t[4] = R * u - S, t[8] = l * f, t[1] = l * v, t[5] = l * h, t[9] = -u, t[2] = S * u - R, t[6] = W + b * u, t[10] = l * I;
    } else if (e.order === "ZXY") {
      const b = I * h, S = I * v, R = f * h, W = f * v;
      t[0] = b - W * u, t[4] = -l * v, t[8] = R + S * u, t[1] = S + R * u, t[5] = l * h, t[9] = W - b * u, t[2] = -l * f, t[6] = u, t[10] = l * I;
    } else if (e.order === "ZYX") {
      const b = l * h, S = l * v, R = u * h, W = u * v;
      t[0] = I * h, t[4] = R * f - S, t[8] = b * f + W, t[1] = I * v, t[5] = W * f + b, t[9] = S * f - R, t[2] = -f, t[6] = u * I, t[10] = l * I;
    } else if (e.order === "YZX") {
      const b = l * I, S = l * f, R = u * I, W = u * f;
      t[0] = I * h, t[4] = W - b * v, t[8] = R * v + S, t[1] = v, t[5] = l * h, t[9] = -u * h, t[2] = -f * h, t[6] = S * v + R, t[10] = b - W * v;
    } else if (e.order === "XZY") {
      const b = l * I, S = l * f, R = u * I, W = u * f;
      t[0] = I * h, t[4] = -v, t[8] = f * h, t[1] = b * v + W, t[5] = l * h, t[9] = S * v - R, t[2] = R * v - S, t[6] = u * h, t[10] = W * v + b;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(oQ, e, sQ);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return HI.subVectors(e, t), HI.lengthSq() === 0 && (HI.z = 1), HI.normalize(), YA.crossVectors(n, HI), YA.lengthSq() === 0 && (Math.abs(n.z) === 1 ? HI.x += 1e-4 : HI.z += 1e-4, HI.normalize(), YA.crossVectors(n, HI)), YA.normalize(), Ox.crossVectors(HI, YA), i[0] = YA.x, i[4] = Ox.x, i[8] = HI.x, i[1] = YA.y, i[5] = Ox.y, i[9] = HI.y, i[2] = YA.z, i[6] = Ox.z, i[10] = HI.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, o = this.elements, l = n[0], u = n[4], I = n[8], f = n[12], h = n[1], v = n[5], b = n[9], S = n[13], R = n[2], W = n[6], x = n[10], M = n[14], T = n[3], E = n[7], _ = n[11], P = n[15], U = i[0], q = i[4], k = i[8], O = i[12], J = i[1], te = i[5], fe = i[9], pe = i[13], Ae = i[2], Te = i[6], Ke = i[10], je = i[14], ee = i[3], Ce = i[7], be = i[11], le = i[15];
    return o[0] = l * U + u * J + I * Ae + f * ee, o[4] = l * q + u * te + I * Te + f * Ce, o[8] = l * k + u * fe + I * Ke + f * be, o[12] = l * O + u * pe + I * je + f * le, o[1] = h * U + v * J + b * Ae + S * ee, o[5] = h * q + v * te + b * Te + S * Ce, o[9] = h * k + v * fe + b * Ke + S * be, o[13] = h * O + v * pe + b * je + S * le, o[2] = R * U + W * J + x * Ae + M * ee, o[6] = R * q + W * te + x * Te + M * Ce, o[10] = R * k + W * fe + x * Ke + M * be, o[14] = R * O + W * pe + x * je + M * le, o[3] = T * U + E * J + _ * Ae + P * ee, o[7] = T * q + E * te + _ * Te + P * Ce, o[11] = T * k + E * fe + _ * Ke + P * be, o[15] = T * O + E * pe + _ * je + P * le, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], i = e[8], o = e[12], l = e[1], u = e[5], I = e[9], f = e[13], h = e[2], v = e[6], b = e[10], S = e[14], R = e[3], W = e[7], x = e[11], M = e[15];
    return R * (+o * I * v - i * f * v - o * u * b + n * f * b + i * u * S - n * I * S) + W * (+t * I * S - t * f * b + o * l * b - i * l * S + i * f * h - o * I * h) + x * (+t * f * v - t * u * S - o * l * v + n * l * S + o * u * h - n * f * h) + M * (-i * u * h - t * I * v + t * u * b + i * l * v - n * l * b + n * I * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], u = e[5], I = e[6], f = e[7], h = e[8], v = e[9], b = e[10], S = e[11], R = e[12], W = e[13], x = e[14], M = e[15], T = v * x * f - W * b * f + W * I * S - u * x * S - v * I * M + u * b * M, E = R * b * f - h * x * f - R * I * S + l * x * S + h * I * M - l * b * M, _ = h * W * f - R * v * f + R * u * S - l * W * S - h * u * M + l * v * M, P = R * v * I - h * W * I - R * u * b + l * W * b + h * u * x - l * v * x, U = t * T + n * E + i * _ + o * P;
    if (U === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const q = 1 / U;
    return e[0] = T * q, e[1] = (W * b * o - v * x * o - W * i * S + n * x * S + v * i * M - n * b * M) * q, e[2] = (u * x * o - W * I * o + W * i * f - n * x * f - u * i * M + n * I * M) * q, e[3] = (v * I * o - u * b * o - v * i * f + n * b * f + u * i * S - n * I * S) * q, e[4] = E * q, e[5] = (h * x * o - R * b * o + R * i * S - t * x * S - h * i * M + t * b * M) * q, e[6] = (R * I * o - l * x * o - R * i * f + t * x * f + l * i * M - t * I * M) * q, e[7] = (l * b * o - h * I * o + h * i * f - t * b * f - l * i * S + t * I * S) * q, e[8] = _ * q, e[9] = (R * v * o - h * W * o - R * n * S + t * W * S + h * n * M - t * v * M) * q, e[10] = (l * W * o - R * u * o + R * n * f - t * W * f - l * n * M + t * u * M) * q, e[11] = (h * u * o - l * v * o - h * n * f + t * v * f + l * n * S - t * u * S) * q, e[12] = P * q, e[13] = (h * W * i - R * v * i + R * n * b - t * W * b - h * n * x + t * v * x) * q, e[14] = (R * u * i - l * W * i - R * n * I + t * W * I + l * n * x - t * u * x) * q, e[15] = (l * v * i - h * u * i + h * n * I - t * v * I - l * n * b + t * u * b) * q, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, i = e.y, o = e.z;
    return t[0] *= n, t[4] *= i, t[8] *= o, t[1] *= n, t[5] *= i, t[9] *= o, t[2] *= n, t[6] *= i, t[10] *= o, t[3] *= n, t[7] *= i, t[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), i = Math.sin(t), o = 1 - n, l = e.x, u = e.y, I = e.z, f = o * l, h = o * u;
    return this.set(
      f * l + n,
      f * u - i * I,
      f * I + i * u,
      0,
      f * u + i * I,
      h * u + n,
      h * I - i * l,
      0,
      f * I - i * u,
      h * I + i * l,
      o * I * I + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, i, o, l) {
    return this.set(
      1,
      n,
      o,
      0,
      e,
      1,
      l,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const i = this.elements, o = t._x, l = t._y, u = t._z, I = t._w, f = o + o, h = l + l, v = u + u, b = o * f, S = o * h, R = o * v, W = l * h, x = l * v, M = u * v, T = I * f, E = I * h, _ = I * v, P = n.x, U = n.y, q = n.z;
    return i[0] = (1 - (W + M)) * P, i[1] = (S + _) * P, i[2] = (R - E) * P, i[3] = 0, i[4] = (S - _) * U, i[5] = (1 - (b + M)) * U, i[6] = (x + T) * U, i[7] = 0, i[8] = (R + E) * q, i[9] = (x - T) * q, i[10] = (1 - (b + W)) * q, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, n) {
    const i = this.elements;
    let o = dG.set(i[0], i[1], i[2]).length();
    const l = dG.set(i[4], i[5], i[6]).length(), u = dG.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o), e.x = i[12], e.y = i[13], e.z = i[14], Nh.copy(this);
    const f = 1 / o, h = 1 / l, v = 1 / u;
    return Nh.elements[0] *= f, Nh.elements[1] *= f, Nh.elements[2] *= f, Nh.elements[4] *= h, Nh.elements[5] *= h, Nh.elements[6] *= h, Nh.elements[8] *= v, Nh.elements[9] *= v, Nh.elements[10] *= v, t.setFromRotationMatrix(Nh), n.x = o, n.y = l, n.z = u, this;
  }
  makePerspective(e, t, n, i, o, l, u = ip) {
    const I = this.elements, f = 2 * o / (t - e), h = 2 * o / (n - i), v = (t + e) / (t - e), b = (n + i) / (n - i);
    let S, R;
    if (u === ip)
      S = -(l + o) / (l - o), R = -2 * l * o / (l - o);
    else if (u === Aw)
      S = -l / (l - o), R = -l * o / (l - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + u);
    return I[0] = f, I[4] = 0, I[8] = v, I[12] = 0, I[1] = 0, I[5] = h, I[9] = b, I[13] = 0, I[2] = 0, I[6] = 0, I[10] = S, I[14] = R, I[3] = 0, I[7] = 0, I[11] = -1, I[15] = 0, this;
  }
  makeOrthographic(e, t, n, i, o, l, u = ip) {
    const I = this.elements, f = 1 / (t - e), h = 1 / (n - i), v = 1 / (l - o), b = (t + e) * f, S = (n + i) * h;
    let R, W;
    if (u === ip)
      R = (l + o) * v, W = -2 * v;
    else if (u === Aw)
      R = o * v, W = -1 * v;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + u);
    return I[0] = 2 * f, I[4] = 0, I[8] = 0, I[12] = -b, I[1] = 0, I[5] = 2 * h, I[9] = 0, I[13] = -S, I[2] = 0, I[6] = 0, I[10] = W, I[14] = -R, I[3] = 0, I[7] = 0, I[11] = 0, I[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const dG = /* @__PURE__ */ new Ze(), Nh = /* @__PURE__ */ new tr(), oQ = /* @__PURE__ */ new Ze(0, 0, 0), sQ = /* @__PURE__ */ new Ze(1, 1, 1), YA = /* @__PURE__ */ new Ze(), Ox = /* @__PURE__ */ new Ze(), HI = /* @__PURE__ */ new Ze(), oT = /* @__PURE__ */ new tr(), sT = /* @__PURE__ */ new zu();
class Kd {
  constructor(e = 0, t = 0, n = 0, i = Kd.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements, o = i[0], l = i[4], u = i[8], I = i[1], f = i[5], h = i[9], v = i[2], b = i[6], S = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(el(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, S), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(b, f), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-el(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(u, S), this._z = Math.atan2(I, f)) : (this._y = Math.atan2(-v, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(el(b, -1, 1)), Math.abs(b) < 0.9999999 ? (this._y = Math.atan2(-v, S), this._z = Math.atan2(-l, f)) : (this._y = 0, this._z = Math.atan2(I, o));
        break;
      case "ZYX":
        this._y = Math.asin(-el(v, -1, 1)), Math.abs(v) < 0.9999999 ? (this._x = Math.atan2(b, S), this._z = Math.atan2(I, o)) : (this._x = 0, this._z = Math.atan2(-l, f));
        break;
      case "YZX":
        this._z = Math.asin(el(I, -1, 1)), Math.abs(I) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._y = Math.atan2(-v, o)) : (this._x = 0, this._y = Math.atan2(u, S));
        break;
      case "XZY":
        this._z = Math.asin(-el(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(b, f), this._y = Math.atan2(u, o)) : (this._x = Math.atan2(-h, S), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return oT.makeRotationFromQuaternion(e), this.setFromRotationMatrix(oT, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return sT.setFromEuler(this), this.setFromQuaternion(sT, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Kd.DEFAULT_ORDER = "XYZ";
class db {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let lQ = 0;
const lT = /* @__PURE__ */ new Ze(), IG = /* @__PURE__ */ new zu(), mm = /* @__PURE__ */ new tr(), Px = /* @__PURE__ */ new Ze(), mZ = /* @__PURE__ */ new Ze(), uQ = /* @__PURE__ */ new Ze(), cQ = /* @__PURE__ */ new zu(), uT = /* @__PURE__ */ new Ze(1, 0, 0), cT = /* @__PURE__ */ new Ze(0, 1, 0), gT = /* @__PURE__ */ new Ze(0, 0, 1), dT = { type: "added" }, gQ = { type: "removed" }, CG = { type: "childadded", child: null }, oM = { type: "childremoved", child: null };
class Aa extends Ip {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: lQ++ }), this.uuid = zI(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Aa.DEFAULT_UP.clone();
    const e = new Ze(), t = new Kd(), n = new zu(), i = new Ze(1, 1, 1);
    function o() {
      n.setFromEuler(t, !1);
    }
    function l() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(o), n._onChange(l), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new tr()
      },
      normalMatrix: {
        value: new Nr()
      }
    }), this.matrix = new tr(), this.matrixWorld = new tr(), this.matrixAutoUpdate = Aa.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Aa.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new db(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return IG.setFromAxisAngle(e, t), this.quaternion.multiply(IG), this;
  }
  rotateOnWorldAxis(e, t) {
    return IG.setFromAxisAngle(e, t), this.quaternion.premultiply(IG), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(uT, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(cT, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(gT, e);
  }
  translateOnAxis(e, t) {
    return lT.copy(e).applyQuaternion(this.quaternion), this.position.add(lT.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(uT, e);
  }
  translateY(e) {
    return this.translateOnAxis(cT, e);
  }
  translateZ(e) {
    return this.translateOnAxis(gT, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(mm.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? Px.copy(e) : Px.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), mZ.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? mm.lookAt(mZ, Px, this.up) : mm.lookAt(Px, mZ, this.up), this.quaternion.setFromRotationMatrix(mm), i && (mm.extractRotation(i.matrixWorld), IG.setFromRotationMatrix(mm), this.quaternion.premultiply(IG.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(dT), CG.child = e, this.dispatchEvent(CG), CG.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(gQ), oM.child = e, this.dispatchEvent(oM), oM.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), mm.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), mm.multiply(e.parent.matrixWorld)), e.applyMatrix4(mm), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(dT), CG.child = e, this.dispatchEvent(CG), CG.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const l = this.children[n].getObjectByProperty(e, t);
      if (l !== void 0)
        return l;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let o = 0, l = i.length; o < l; o++)
      i[o].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(mZ, e, uQ), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(mZ, cQ, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
      const i = this.children;
      for (let o = 0, l = i.length; o < l; o++)
        i[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((u) => ({
      boxInitialized: u.boxInitialized,
      boxMin: u.box.min.toArray(),
      boxMax: u.box.max.toArray(),
      sphereInitialized: u.sphereInitialized,
      sphereRadius: u.sphere.radius,
      sphereCenter: u.sphere.center.toArray()
    })), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function o(u, I) {
      return u[I.uuid] === void 0 && (u[I.uuid] = I.toJSON(e)), I.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const u = this.geometry.parameters;
      if (u !== void 0 && u.shapes !== void 0) {
        const I = u.shapes;
        if (Array.isArray(I))
          for (let f = 0, h = I.length; f < h; f++) {
            const v = I[f];
            o(e.shapes, v);
          }
        else
          o(e.shapes, I);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const u = [];
        for (let I = 0, f = this.material.length; I < f; I++)
          u.push(o(e.materials, this.material[I]));
        i.material = u;
      } else
        i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let u = 0; u < this.children.length; u++)
        i.children.push(this.children[u].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let u = 0; u < this.animations.length; u++) {
        const I = this.animations[u];
        i.animations.push(o(e.animations, I));
      }
    }
    if (t) {
      const u = l(e.geometries), I = l(e.materials), f = l(e.textures), h = l(e.images), v = l(e.shapes), b = l(e.skeletons), S = l(e.animations), R = l(e.nodes);
      u.length > 0 && (n.geometries = u), I.length > 0 && (n.materials = I), f.length > 0 && (n.textures = f), h.length > 0 && (n.images = h), v.length > 0 && (n.shapes = v), b.length > 0 && (n.skeletons = b), S.length > 0 && (n.animations = S), R.length > 0 && (n.nodes = R);
    }
    return n.object = i, n;
    function l(u) {
      const I = [];
      for (const f in u) {
        const h = u[f];
        delete h.metadata, I.push(h);
      }
      return I;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Aa.DEFAULT_UP = /* @__PURE__ */ new Ze(0, 1, 0);
Aa.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Aa.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Mh = /* @__PURE__ */ new Ze(), Am = /* @__PURE__ */ new Ze(), sM = /* @__PURE__ */ new Ze(), vm = /* @__PURE__ */ new Ze(), hG = /* @__PURE__ */ new Ze(), fG = /* @__PURE__ */ new Ze(), IT = /* @__PURE__ */ new Ze(), lM = /* @__PURE__ */ new Ze(), uM = /* @__PURE__ */ new Ze(), cM = /* @__PURE__ */ new Ze();
class EI {
  constructor(e = new Ze(), t = new Ze(), n = new Ze()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Mh.subVectors(e, t), i.cross(Mh);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, i, o) {
    Mh.subVectors(i, t), Am.subVectors(n, t), sM.subVectors(e, t);
    const l = Mh.dot(Mh), u = Mh.dot(Am), I = Mh.dot(sM), f = Am.dot(Am), h = Am.dot(sM), v = l * f - u * u;
    if (v === 0)
      return o.set(0, 0, 0), null;
    const b = 1 / v, S = (f * I - u * h) * b, R = (l * h - u * I) * b;
    return o.set(1 - S - R, R, S);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, vm) === null ? !1 : vm.x >= 0 && vm.y >= 0 && vm.x + vm.y <= 1;
  }
  static getInterpolation(e, t, n, i, o, l, u, I) {
    return this.getBarycoord(e, t, n, i, vm) === null ? (I.x = 0, I.y = 0, "z" in I && (I.z = 0), "w" in I && (I.w = 0), null) : (I.setScalar(0), I.addScaledVector(o, vm.x), I.addScaledVector(l, vm.y), I.addScaledVector(u, vm.z), I);
  }
  static isFrontFacing(e, t, n, i) {
    return Mh.subVectors(n, t), Am.subVectors(e, t), Mh.cross(Am).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Mh.subVectors(this.c, this.b), Am.subVectors(this.a, this.b), Mh.cross(Am).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return EI.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return EI.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, i, o) {
    return EI.getInterpolation(e, this.a, this.b, this.c, t, n, i, o);
  }
  containsPoint(e) {
    return EI.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return EI.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, i = this.b, o = this.c;
    let l, u;
    hG.subVectors(i, n), fG.subVectors(o, n), lM.subVectors(e, n);
    const I = hG.dot(lM), f = fG.dot(lM);
    if (I <= 0 && f <= 0)
      return t.copy(n);
    uM.subVectors(e, i);
    const h = hG.dot(uM), v = fG.dot(uM);
    if (h >= 0 && v <= h)
      return t.copy(i);
    const b = I * v - h * f;
    if (b <= 0 && I >= 0 && h <= 0)
      return l = I / (I - h), t.copy(n).addScaledVector(hG, l);
    cM.subVectors(e, o);
    const S = hG.dot(cM), R = fG.dot(cM);
    if (R >= 0 && S <= R)
      return t.copy(o);
    const W = S * f - I * R;
    if (W <= 0 && f >= 0 && R <= 0)
      return u = f / (f - R), t.copy(n).addScaledVector(fG, u);
    const x = h * R - S * v;
    if (x <= 0 && v - h >= 0 && S - R >= 0)
      return IT.subVectors(o, i), u = (v - h) / (v - h + (S - R)), t.copy(i).addScaledVector(IT, u);
    const M = 1 / (x + W + b);
    return l = W * M, u = b * M, t.copy(n).addScaledVector(hG, l).addScaledVector(fG, u);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Hz = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, FA = { h: 0, s: 0, l: 0 }, Jx = { h: 0, s: 0, l: 0 };
function gM(a, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? a + (e - a) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? a + (e - a) * 6 * (2 / 3 - t) : a;
}
class hi {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = HC) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ta.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, i = Ta.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Ta.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, n, i = Ta.workingColorSpace) {
    if (e = MX(e, 1), t = el(t, 0, 1), n = el(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const o = n <= 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - o;
      this.r = gM(l, o, e + 1 / 3), this.g = gM(l, o, e), this.b = gM(l, o, e - 1 / 3);
    }
    return Ta.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = HC) {
    function n(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const l = i[1], u = i[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              t
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = i[1], l = o.length;
      if (l === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (l === 6)
        return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = HC) {
    const n = Hz[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = UG(e.r), this.g = UG(e.g), this.b = UG(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = qN(e.r), this.g = qN(e.g), this.b = qN(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = HC) {
    return Ta.fromWorkingColorSpace(jc.copy(this), e), Math.round(el(jc.r * 255, 0, 255)) * 65536 + Math.round(el(jc.g * 255, 0, 255)) * 256 + Math.round(el(jc.b * 255, 0, 255));
  }
  getHexString(e = HC) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Ta.workingColorSpace) {
    Ta.fromWorkingColorSpace(jc.copy(this), t);
    const n = jc.r, i = jc.g, o = jc.b, l = Math.max(n, i, o), u = Math.min(n, i, o);
    let I, f;
    const h = (u + l) / 2;
    if (u === l)
      I = 0, f = 0;
    else {
      const v = l - u;
      switch (f = h <= 0.5 ? v / (l + u) : v / (2 - l - u), l) {
        case n:
          I = (i - o) / v + (i < o ? 6 : 0);
          break;
        case i:
          I = (o - n) / v + 2;
          break;
        case o:
          I = (n - i) / v + 4;
          break;
      }
      I /= 6;
    }
    return e.h = I, e.s = f, e.l = h, e;
  }
  getRGB(e, t = Ta.workingColorSpace) {
    return Ta.fromWorkingColorSpace(jc.copy(this), t), e.r = jc.r, e.g = jc.g, e.b = jc.b, e;
  }
  getStyle(e = HC) {
    Ta.fromWorkingColorSpace(jc.copy(this), e);
    const t = jc.r, n = jc.g, i = jc.b;
    return e !== HC ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(FA), this.setHSL(FA.h + e, FA.s + t, FA.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(FA), e.getHSL(Jx);
    const n = QZ(FA.h, Jx.h, t), i = QZ(FA.s, Jx.s, t), o = QZ(FA.l, Jx.l, t);
    return this.setHSL(n, i, o), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, i = this.b, o = e.elements;
    return this.r = o[0] * t + o[3] * n + o[6] * i, this.g = o[1] * t + o[4] * n + o[7] * i, this.b = o[2] * t + o[5] * n + o[8] * i, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const jc = /* @__PURE__ */ new hi();
hi.NAMES = Hz;
let dQ = 0;
class Gc extends Ip {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: dQ++ }), this.uuid = zI(), this.name = "", this.type = "Material", this.blending = ub, this.side = Nm, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = s2, this.blendDst = l2, this.blendEquation = kA, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new hi(0, 0, 0), this.blendAlpha = 0, this.depthFunc = lw, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = ZH, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Jy, this.stencilZFail = Jy, this.stencilZPass = Jy, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== ub && (n.blending = this.blending), this.side !== Nm && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== s2 && (n.blendSrc = this.blendSrc), this.blendDst !== l2 && (n.blendDst = this.blendDst), this.blendEquation !== kA && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== lw && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== ZH && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Jy && (n.stencilFail = this.stencilFail), this.stencilZFail !== Jy && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Jy && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(o) {
      const l = [];
      for (const u in o) {
        const I = o[u];
        delete I.metadata, l.push(I);
      }
      return l;
    }
    if (t) {
      const o = i(e.textures), l = i(e.images);
      o.length > 0 && (n.textures = o), l.length > 0 && (n.images = l);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let o = 0; o !== i; ++o)
        n[o] = t[o].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
  onBeforeRender() {
    console.warn("Material: onBeforeRender() has been removed.");
  }
}
class rv extends Gc {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new hi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Kd(), this.combine = zw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Zm = /* @__PURE__ */ IQ();
function IQ() {
  const a = new ArrayBuffer(4), e = new Float32Array(a), t = new Uint32Array(a), n = new Uint32Array(512), i = new Uint32Array(512);
  for (let I = 0; I < 256; ++I) {
    const f = I - 127;
    f < -27 ? (n[I] = 0, n[I | 256] = 32768, i[I] = 24, i[I | 256] = 24) : f < -14 ? (n[I] = 1024 >> -f - 14, n[I | 256] = 1024 >> -f - 14 | 32768, i[I] = -f - 1, i[I | 256] = -f - 1) : f <= 15 ? (n[I] = f + 15 << 10, n[I | 256] = f + 15 << 10 | 32768, i[I] = 13, i[I | 256] = 13) : f < 128 ? (n[I] = 31744, n[I | 256] = 64512, i[I] = 24, i[I | 256] = 24) : (n[I] = 31744, n[I | 256] = 64512, i[I] = 13, i[I | 256] = 13);
  }
  const o = new Uint32Array(2048), l = new Uint32Array(64), u = new Uint32Array(64);
  for (let I = 1; I < 1024; ++I) {
    let f = I << 13, h = 0;
    for (; !(f & 8388608); )
      f <<= 1, h -= 8388608;
    f &= -8388609, h += 947912704, o[I] = f | h;
  }
  for (let I = 1024; I < 2048; ++I)
    o[I] = 939524096 + (I - 1024 << 13);
  for (let I = 1; I < 31; ++I)
    l[I] = I << 23;
  l[31] = 1199570944, l[32] = 2147483648;
  for (let I = 33; I < 63; ++I)
    l[I] = 2147483648 + (I - 32 << 23);
  l[63] = 3347054592;
  for (let I = 1; I < 64; ++I)
    I !== 32 && (u[I] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: l,
    offsetTable: u
  };
}
function Md(a) {
  Math.abs(a) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), a = el(a, -65504, 65504), Zm.floatView[0] = a;
  const e = Zm.uint32View[0], t = e >> 23 & 511;
  return Zm.baseTable[t] + ((e & 8388607) >> Zm.shiftTable[t]);
}
function TZ(a) {
  const e = a >> 10;
  return Zm.uint32View[0] = Zm.mantissaTable[Zm.offsetTable[e] + (a & 1023)] + Zm.exponentTable[e], Zm.floatView[0];
}
const CQ = {
  toHalfFloat: Md,
  fromHalfFloat: TZ
}, Hl = /* @__PURE__ */ new Ze(), Qx = /* @__PURE__ */ new sn();
class Zo {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = mw, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = kg, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return DG("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Qx.fromBufferAttribute(this, t), Qx.applyMatrix3(e), this.setXY(t, Qx.x, Qx.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        Hl.fromBufferAttribute(this, t), Hl.applyMatrix3(e), this.setXYZ(t, Hl.x, Hl.y, Hl.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Hl.fromBufferAttribute(this, t), Hl.applyMatrix4(e), this.setXYZ(t, Hl.x, Hl.y, Hl.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Hl.fromBufferAttribute(this, t), Hl.applyNormalMatrix(e), this.setXYZ(t, Hl.x, Hl.y, Hl.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Hl.fromBufferAttribute(this, t), Hl.transformDirection(e), this.setXYZ(t, Hl.x, Hl.y, Hl.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Kg(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = Mr(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array), i = Mr(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, o) {
    return e *= this.itemSize, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array), i = Mr(i, this.array), o = Mr(o, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== mw && (e.usage = this.usage), e;
  }
}
class hQ extends Zo {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class fQ extends Zo {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class pQ extends Zo {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class mQ extends Zo {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class XX extends Zo {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class AQ extends Zo {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class YX extends Zo {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class vQ extends Zo {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = TZ(this.array[e * this.itemSize]);
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.array[e * this.itemSize] = Md(t), this;
  }
  getY(e) {
    let t = TZ(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.array[e * this.itemSize + 1] = Md(t), this;
  }
  getZ(e) {
    let t = TZ(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.array[e * this.itemSize + 2] = Md(t), this;
  }
  getW(e) {
    let t = TZ(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.array[e * this.itemSize + 3] = Md(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array)), this.array[e + 0] = Md(t), this.array[e + 1] = Md(n), this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array), i = Mr(i, this.array)), this.array[e + 0] = Md(t), this.array[e + 1] = Md(n), this.array[e + 2] = Md(i), this;
  }
  setXYZW(e, t, n, i, o) {
    return e *= this.itemSize, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array), i = Mr(i, this.array), o = Mr(o, this.array)), this.array[e + 0] = Md(t), this.array[e + 1] = Md(n), this.array[e + 2] = Md(i), this.array[e + 3] = Md(o), this;
  }
}
class Mi extends Zo {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let yQ = 0;
const NC = /* @__PURE__ */ new tr(), dM = /* @__PURE__ */ new Aa(), pG = /* @__PURE__ */ new Ze(), XI = /* @__PURE__ */ new Ug(), AZ = /* @__PURE__ */ new Ug(), Eu = /* @__PURE__ */ new Ze();
class _r extends Ip {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: yQ++ }), this.uuid = zI(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Wz(e) ? YX : XX)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const o = new Nr().getNormalMatrix(e);
      n.applyNormalMatrix(o), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return NC.makeRotationFromQuaternion(e), this.applyMatrix4(NC), this;
  }
  rotateX(e) {
    return NC.makeRotationX(e), this.applyMatrix4(NC), this;
  }
  rotateY(e) {
    return NC.makeRotationY(e), this.applyMatrix4(NC), this;
  }
  rotateZ(e) {
    return NC.makeRotationZ(e), this.applyMatrix4(NC), this;
  }
  translate(e, t, n) {
    return NC.makeTranslation(e, t, n), this.applyMatrix4(NC), this;
  }
  scale(e, t, n) {
    return NC.makeScale(e, t, n), this.applyMatrix4(NC), this;
  }
  lookAt(e) {
    return dM.lookAt(e), dM.updateMatrix(), this.applyMatrix4(dM.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(pG).negate(), this.translate(pG.x, pG.y, pG.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const o = e[n];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new Mi(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ug());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new Ze(-1 / 0, -1 / 0, -1 / 0),
        new Ze(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, i = t.length; n < i; n++) {
          const o = t[n];
          XI.setFromBufferAttribute(o), this.morphTargetsRelative ? (Eu.addVectors(this.boundingBox.min, XI.min), this.boundingBox.expandByPoint(Eu), Eu.addVectors(this.boundingBox.max, XI.max), this.boundingBox.expandByPoint(Eu)) : (this.boundingBox.expandByPoint(XI.min), this.boundingBox.expandByPoint(XI.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new og());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Ze(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (XI.setFromBufferAttribute(e), t)
        for (let o = 0, l = t.length; o < l; o++) {
          const u = t[o];
          AZ.setFromBufferAttribute(u), this.morphTargetsRelative ? (Eu.addVectors(XI.min, AZ.min), XI.expandByPoint(Eu), Eu.addVectors(XI.max, AZ.max), XI.expandByPoint(Eu)) : (XI.expandByPoint(AZ.min), XI.expandByPoint(AZ.max));
        }
      XI.getCenter(n);
      let i = 0;
      for (let o = 0, l = e.count; o < l; o++)
        Eu.fromBufferAttribute(e, o), i = Math.max(i, n.distanceToSquared(Eu));
      if (t)
        for (let o = 0, l = t.length; o < l; o++) {
          const u = t[o], I = this.morphTargetsRelative;
          for (let f = 0, h = u.count; f < h; f++)
            Eu.fromBufferAttribute(u, f), I && (pG.fromBufferAttribute(e, f), Eu.add(pG)), i = Math.max(i, n.distanceToSquared(Eu));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = t.position, i = t.normal, o = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Zo(new Float32Array(4 * n.count), 4));
    const l = this.getAttribute("tangent"), u = [], I = [];
    for (let k = 0; k < n.count; k++)
      u[k] = new Ze(), I[k] = new Ze();
    const f = new Ze(), h = new Ze(), v = new Ze(), b = new sn(), S = new sn(), R = new sn(), W = new Ze(), x = new Ze();
    function M(k, O, J) {
      f.fromBufferAttribute(n, k), h.fromBufferAttribute(n, O), v.fromBufferAttribute(n, J), b.fromBufferAttribute(o, k), S.fromBufferAttribute(o, O), R.fromBufferAttribute(o, J), h.sub(f), v.sub(f), S.sub(b), R.sub(b);
      const te = 1 / (S.x * R.y - R.x * S.y);
      isFinite(te) && (W.copy(h).multiplyScalar(R.y).addScaledVector(v, -S.y).multiplyScalar(te), x.copy(v).multiplyScalar(S.x).addScaledVector(h, -R.x).multiplyScalar(te), u[k].add(W), u[O].add(W), u[J].add(W), I[k].add(x), I[O].add(x), I[J].add(x));
    }
    let T = this.groups;
    T.length === 0 && (T = [{
      start: 0,
      count: e.count
    }]);
    for (let k = 0, O = T.length; k < O; ++k) {
      const J = T[k], te = J.start, fe = J.count;
      for (let pe = te, Ae = te + fe; pe < Ae; pe += 3)
        M(
          e.getX(pe + 0),
          e.getX(pe + 1),
          e.getX(pe + 2)
        );
    }
    const E = new Ze(), _ = new Ze(), P = new Ze(), U = new Ze();
    function q(k) {
      P.fromBufferAttribute(i, k), U.copy(P);
      const O = u[k];
      E.copy(O), E.sub(P.multiplyScalar(P.dot(O))).normalize(), _.crossVectors(U, O);
      const te = _.dot(I[k]) < 0 ? -1 : 1;
      l.setXYZW(k, E.x, E.y, E.z, te);
    }
    for (let k = 0, O = T.length; k < O; ++k) {
      const J = T[k], te = J.start, fe = J.count;
      for (let pe = te, Ae = te + fe; pe < Ae; pe += 3)
        q(e.getX(pe + 0)), q(e.getX(pe + 1)), q(e.getX(pe + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Zo(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let b = 0, S = n.count; b < S; b++)
          n.setXYZ(b, 0, 0, 0);
      const i = new Ze(), o = new Ze(), l = new Ze(), u = new Ze(), I = new Ze(), f = new Ze(), h = new Ze(), v = new Ze();
      if (e)
        for (let b = 0, S = e.count; b < S; b += 3) {
          const R = e.getX(b + 0), W = e.getX(b + 1), x = e.getX(b + 2);
          i.fromBufferAttribute(t, R), o.fromBufferAttribute(t, W), l.fromBufferAttribute(t, x), h.subVectors(l, o), v.subVectors(i, o), h.cross(v), u.fromBufferAttribute(n, R), I.fromBufferAttribute(n, W), f.fromBufferAttribute(n, x), u.add(h), I.add(h), f.add(h), n.setXYZ(R, u.x, u.y, u.z), n.setXYZ(W, I.x, I.y, I.z), n.setXYZ(x, f.x, f.y, f.z);
        }
      else
        for (let b = 0, S = t.count; b < S; b += 3)
          i.fromBufferAttribute(t, b + 0), o.fromBufferAttribute(t, b + 1), l.fromBufferAttribute(t, b + 2), h.subVectors(l, o), v.subVectors(i, o), h.cross(v), n.setXYZ(b + 0, h.x, h.y, h.z), n.setXYZ(b + 1, h.x, h.y, h.z), n.setXYZ(b + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Eu.fromBufferAttribute(e, t), Eu.normalize(), e.setXYZ(t, Eu.x, Eu.y, Eu.z);
  }
  toNonIndexed() {
    function e(u, I) {
      const f = u.array, h = u.itemSize, v = u.normalized, b = new f.constructor(I.length * h);
      let S = 0, R = 0;
      for (let W = 0, x = I.length; W < x; W++) {
        u.isInterleavedBufferAttribute ? S = I[W] * u.data.stride + u.offset : S = I[W] * h;
        for (let M = 0; M < h; M++)
          b[R++] = f[S++];
      }
      return new Zo(b, h, v);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new _r(), n = this.index.array, i = this.attributes;
    for (const u in i) {
      const I = i[u], f = e(I, n);
      t.setAttribute(u, f);
    }
    const o = this.morphAttributes;
    for (const u in o) {
      const I = [], f = o[u];
      for (let h = 0, v = f.length; h < v; h++) {
        const b = f[h], S = e(b, n);
        I.push(S);
      }
      t.morphAttributes[u] = I;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let u = 0, I = l.length; u < I; u++) {
      const f = l[u];
      t.addGroup(f.start, f.count, f.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const I = this.parameters;
      for (const f in I)
        I[f] !== void 0 && (e[f] = I[f]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const I in n) {
      const f = n[I];
      e.data.attributes[I] = f.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const I in this.morphAttributes) {
      const f = this.morphAttributes[I], h = [];
      for (let v = 0, b = f.length; v < b; v++) {
        const S = f[v];
        h.push(S.toJSON(e.data));
      }
      h.length > 0 && (i[I] = h, o = !0);
    }
    o && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const l = this.groups;
    l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
    const u = this.boundingSphere;
    return u !== null && (e.data.boundingSphere = {
      center: u.center.toArray(),
      radius: u.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const f in i) {
      const h = i[f];
      this.setAttribute(f, h.clone(t));
    }
    const o = e.morphAttributes;
    for (const f in o) {
      const h = [], v = o[f];
      for (let b = 0, S = v.length; b < S; b++)
        h.push(v[b].clone(t));
      this.morphAttributes[f] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const l = e.groups;
    for (let f = 0, h = l.length; f < h; f++) {
      const v = l[f];
      this.addGroup(v.start, v.count, v.materialIndex);
    }
    const u = e.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    const I = e.boundingSphere;
    return I !== null && (this.boundingSphere = I.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const CT = /* @__PURE__ */ new tr(), Xy = /* @__PURE__ */ new wb(), jx = /* @__PURE__ */ new og(), hT = /* @__PURE__ */ new Ze(), mG = /* @__PURE__ */ new Ze(), AG = /* @__PURE__ */ new Ze(), vG = /* @__PURE__ */ new Ze(), IM = /* @__PURE__ */ new Ze(), qx = /* @__PURE__ */ new Ze(), $x = /* @__PURE__ */ new sn(), e1 = /* @__PURE__ */ new sn(), t1 = /* @__PURE__ */ new sn(), fT = /* @__PURE__ */ new Ze(), pT = /* @__PURE__ */ new Ze(), mT = /* @__PURE__ */ new Ze(), n1 = /* @__PURE__ */ new Ze(), i1 = /* @__PURE__ */ new Ze();
class Fl extends Aa {
  constructor(e = new _r(), t = new rv()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, i = n.attributes.position, o = n.morphAttributes.position, l = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const u = this.morphTargetInfluences;
    if (o && u) {
      qx.set(0, 0, 0);
      for (let I = 0, f = o.length; I < f; I++) {
        const h = u[I], v = o[I];
        h !== 0 && (IM.fromBufferAttribute(v, e), l ? qx.addScaledVector(IM, h) : qx.addScaledVector(IM.sub(t), h));
      }
      t.add(qx);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.material, o = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), jx.copy(n.boundingSphere), jx.applyMatrix4(o), Xy.copy(e.ray).recast(e.near), !(jx.containsPoint(Xy.origin) === !1 && (Xy.intersectSphere(jx, hT) === null || Xy.origin.distanceToSquared(hT) > (e.far - e.near) ** 2)) && (CT.copy(o).invert(), Xy.copy(e.ray).applyMatrix4(CT), !(n.boundingBox !== null && Xy.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Xy)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const o = this.geometry, l = this.material, u = o.index, I = o.attributes.position, f = o.attributes.uv, h = o.attributes.uv1, v = o.attributes.normal, b = o.groups, S = o.drawRange;
    if (u !== null)
      if (Array.isArray(l))
        for (let R = 0, W = b.length; R < W; R++) {
          const x = b[R], M = l[x.materialIndex], T = Math.max(x.start, S.start), E = Math.min(u.count, Math.min(x.start + x.count, S.start + S.count));
          for (let _ = T, P = E; _ < P; _ += 3) {
            const U = u.getX(_), q = u.getX(_ + 1), k = u.getX(_ + 2);
            i = r1(this, M, e, n, f, h, v, U, q, k), i && (i.faceIndex = Math.floor(_ / 3), i.face.materialIndex = x.materialIndex, t.push(i));
          }
        }
      else {
        const R = Math.max(0, S.start), W = Math.min(u.count, S.start + S.count);
        for (let x = R, M = W; x < M; x += 3) {
          const T = u.getX(x), E = u.getX(x + 1), _ = u.getX(x + 2);
          i = r1(this, l, e, n, f, h, v, T, E, _), i && (i.faceIndex = Math.floor(x / 3), t.push(i));
        }
      }
    else if (I !== void 0)
      if (Array.isArray(l))
        for (let R = 0, W = b.length; R < W; R++) {
          const x = b[R], M = l[x.materialIndex], T = Math.max(x.start, S.start), E = Math.min(I.count, Math.min(x.start + x.count, S.start + S.count));
          for (let _ = T, P = E; _ < P; _ += 3) {
            const U = _, q = _ + 1, k = _ + 2;
            i = r1(this, M, e, n, f, h, v, U, q, k), i && (i.faceIndex = Math.floor(_ / 3), i.face.materialIndex = x.materialIndex, t.push(i));
          }
        }
      else {
        const R = Math.max(0, S.start), W = Math.min(I.count, S.start + S.count);
        for (let x = R, M = W; x < M; x += 3) {
          const T = x, E = x + 1, _ = x + 2;
          i = r1(this, l, e, n, f, h, v, T, E, _), i && (i.faceIndex = Math.floor(x / 3), t.push(i));
        }
      }
  }
}
function bQ(a, e, t, n, i, o, l, u) {
  let I;
  if (e.side === Dg ? I = n.intersectTriangle(l, o, i, !0, u) : I = n.intersectTriangle(i, o, l, e.side === Nm, u), I === null) return null;
  i1.copy(u), i1.applyMatrix4(a.matrixWorld);
  const f = t.ray.origin.distanceTo(i1);
  return f < t.near || f > t.far ? null : {
    distance: f,
    point: i1.clone(),
    object: a
  };
}
function r1(a, e, t, n, i, o, l, u, I, f) {
  a.getVertexPosition(u, mG), a.getVertexPosition(I, AG), a.getVertexPosition(f, vG);
  const h = bQ(a, e, t, n, mG, AG, vG, n1);
  if (h) {
    i && ($x.fromBufferAttribute(i, u), e1.fromBufferAttribute(i, I), t1.fromBufferAttribute(i, f), h.uv = EI.getInterpolation(n1, mG, AG, vG, $x, e1, t1, new sn())), o && ($x.fromBufferAttribute(o, u), e1.fromBufferAttribute(o, I), t1.fromBufferAttribute(o, f), h.uv1 = EI.getInterpolation(n1, mG, AG, vG, $x, e1, t1, new sn())), l && (fT.fromBufferAttribute(l, u), pT.fromBufferAttribute(l, I), mT.fromBufferAttribute(l, f), h.normal = EI.getInterpolation(n1, mG, AG, vG, fT, pT, mT, new Ze()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const v = {
      a: u,
      b: I,
      c: f,
      normal: new Ze(),
      materialIndex: 0
    };
    EI.getNormal(mG, AG, vG, v.normal), h.face = v;
  }
  return h;
}
class Rb extends _r {
  constructor(e = 1, t = 1, n = 1, i = 1, o = 1, l = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: i,
      heightSegments: o,
      depthSegments: l
    };
    const u = this;
    i = Math.floor(i), o = Math.floor(o), l = Math.floor(l);
    const I = [], f = [], h = [], v = [];
    let b = 0, S = 0;
    R("z", "y", "x", -1, -1, n, t, e, l, o, 0), R("z", "y", "x", 1, -1, n, t, -e, l, o, 1), R("x", "z", "y", 1, 1, e, n, t, i, l, 2), R("x", "z", "y", 1, -1, e, n, -t, i, l, 3), R("x", "y", "z", 1, -1, e, t, n, i, o, 4), R("x", "y", "z", -1, -1, e, t, -n, i, o, 5), this.setIndex(I), this.setAttribute("position", new Mi(f, 3)), this.setAttribute("normal", new Mi(h, 3)), this.setAttribute("uv", new Mi(v, 2));
    function R(W, x, M, T, E, _, P, U, q, k, O) {
      const J = _ / q, te = P / k, fe = _ / 2, pe = P / 2, Ae = U / 2, Te = q + 1, Ke = k + 1;
      let je = 0, ee = 0;
      const Ce = new Ze();
      for (let be = 0; be < Ke; be++) {
        const le = be * te - pe;
        for (let Ye = 0; Ye < Te; Ye++) {
          const $e = Ye * J - fe;
          Ce[W] = $e * T, Ce[x] = le * E, Ce[M] = Ae, f.push(Ce.x, Ce.y, Ce.z), Ce[W] = 0, Ce[x] = 0, Ce[M] = U > 0 ? 1 : -1, h.push(Ce.x, Ce.y, Ce.z), v.push(Ye / q), v.push(1 - be / k), je += 1;
        }
      }
      for (let be = 0; be < k; be++)
        for (let le = 0; le < q; le++) {
          const Ye = b + le + Te * be, $e = b + le + Te * (be + 1), ke = b + (le + 1) + Te * (be + 1), ot = b + (le + 1) + Te * be;
          I.push(Ye, $e, ot), I.push($e, ke, ot), ee += 6;
        }
      u.addGroup(S, ee, O), S += ee, b += je;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Rb(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function eB(a) {
  const e = {};
  for (const t in a) {
    e[t] = {};
    for (const n in a[t]) {
      const i = a[t][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
    }
  }
  return e;
}
function Fg(a) {
  const e = {};
  for (let t = 0; t < a.length; t++) {
    const n = eB(a[t]);
    for (const i in n)
      e[i] = n[i];
  }
  return e;
}
function GQ(a) {
  const e = [];
  for (let t = 0; t < a.length; t++)
    e.push(a[t].clone());
  return e;
}
function Xz(a) {
  const e = a.getRenderTarget();
  return e === null ? a.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Ta.workingColorSpace;
}
const Yz = { clone: eB, merge: Fg };
var BQ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, SQ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class zh extends Gc {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = BQ, this.fragmentShader = SQ, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = eB(e.uniforms), this.uniformsGroups = GQ(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const l = this.uniforms[i].value;
      l && l.isTexture ? t.uniforms[i] = {
        type: "t",
        value: l.toJSON(e).uuid
      } : l && l.isColor ? t.uniforms[i] = {
        type: "c",
        value: l.getHex()
      } : l && l.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: l.toArray()
      } : l && l.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: l.toArray()
      } : l && l.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: l.toArray()
      } : l && l.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: l.toArray()
      } : l && l.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: l.toArray()
      } : t.uniforms[i] = {
        value: l
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class kw extends Aa {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new tr(), this.projectionMatrix = new tr(), this.projectionMatrixInverse = new tr(), this.coordinateSystem = ip;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const EA = /* @__PURE__ */ new Ze(), AT = /* @__PURE__ */ new sn(), vT = /* @__PURE__ */ new sn();
let tl = class extends kw {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = $G * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(gb * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return $G * 2 * Math.atan(
      Math.tan(gb * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, t, n) {
    EA.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(EA.x, EA.y).multiplyScalar(-e / EA.z), EA.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(EA.x, EA.y).multiplyScalar(-e / EA.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, AT, vT), t.subVectors(vT, AT);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, i, o, l) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(gb * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, o = -0.5 * i;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const I = l.fullWidth, f = l.fullHeight;
      o += l.offsetX * i / I, t -= l.offsetY * n / f, i *= l.width / I, n *= l.height / f;
    }
    const u = this.filmOffset;
    u !== 0 && (o += e * u / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
};
const yG = -90, bG = 1;
class Fz extends Aa {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new tl(yG, bG, e, t);
    i.layers = this.layers, this.add(i);
    const o = new tl(yG, bG, e, t);
    o.layers = this.layers, this.add(o);
    const l = new tl(yG, bG, e, t);
    l.layers = this.layers, this.add(l);
    const u = new tl(yG, bG, e, t);
    u.layers = this.layers, this.add(u);
    const I = new tl(yG, bG, e, t);
    I.layers = this.layers, this.add(I);
    const f = new tl(yG, bG, e, t);
    f.layers = this.layers, this.add(f);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, i, o, l, u, I] = t;
    for (const f of t) this.remove(f);
    if (e === ip)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), l.up.set(0, 0, 1), l.lookAt(0, -1, 0), u.up.set(0, 1, 0), u.lookAt(0, 0, 1), I.up.set(0, 1, 0), I.lookAt(0, 0, -1);
    else if (e === Aw)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), l.up.set(0, 0, -1), l.lookAt(0, -1, 0), u.up.set(0, -1, 0), u.lookAt(0, 0, 1), I.up.set(0, -1, 0), I.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const f of t)
      this.add(f), f.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, l, u, I, f, h] = this.children, v = e.getRenderTarget(), b = e.getActiveCubeFace(), S = e.getActiveMipmapLevel(), R = e.xr.enabled;
    e.xr.enabled = !1;
    const W = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, o), e.setRenderTarget(n, 1, i), e.render(t, l), e.setRenderTarget(n, 2, i), e.render(t, u), e.setRenderTarget(n, 3, i), e.render(t, I), e.setRenderTarget(n, 4, i), e.render(t, f), n.texture.generateMipmaps = W, e.setRenderTarget(n, 5, i), e.render(t, h), e.setRenderTarget(v, b, S), e.xr.enabled = R, n.texture.needsPMREMUpdate = !0;
  }
}
class Dw extends Fs {
  constructor(e, t, n, i, o, l, u, I, f, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Mm, super(e, t, n, i, o, l, u, I, f, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Ez extends EC {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
    this.texture = new Dw(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : nl;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new Rb(5, 5, 5), o = new zh({
      name: "CubemapFromEquirect",
      uniforms: eB(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Dg,
      blending: Vm
    });
    o.uniforms.tEquirect.value = t;
    const l = new Fl(i, o), u = t.minFilter;
    return t.minFilter === np && (t.minFilter = nl), new Fz(1, 10, this).update(e, l), t.minFilter = u, l.geometry.dispose(), l.material.dispose(), this;
  }
  clear(e, t, n, i) {
    const o = e.getRenderTarget();
    for (let l = 0; l < 6; l++)
      e.setRenderTarget(this, l), e.clear(t, n, i);
    e.setRenderTarget(o);
  }
}
const CM = /* @__PURE__ */ new Ze(), ZQ = /* @__PURE__ */ new Ze(), wQ = /* @__PURE__ */ new Nr();
class Gm {
  constructor(e = new Ze(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = CM.subVectors(n, t).cross(ZQ.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(CM), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(n, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || wQ.getNormalMatrix(e), i = this.coplanarPoint(CM).applyMatrix4(e), o = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Yy = /* @__PURE__ */ new og(), a1 = /* @__PURE__ */ new Ze();
class Uw {
  constructor(e = new Gm(), t = new Gm(), n = new Gm(), i = new Gm(), o = new Gm(), l = new Gm()) {
    this.planes = [e, t, n, i, o, l];
  }
  set(e, t, n, i, o, l) {
    const u = this.planes;
    return u[0].copy(e), u[1].copy(t), u[2].copy(n), u[3].copy(i), u[4].copy(o), u[5].copy(l), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = ip) {
    const n = this.planes, i = e.elements, o = i[0], l = i[1], u = i[2], I = i[3], f = i[4], h = i[5], v = i[6], b = i[7], S = i[8], R = i[9], W = i[10], x = i[11], M = i[12], T = i[13], E = i[14], _ = i[15];
    if (n[0].setComponents(I - o, b - f, x - S, _ - M).normalize(), n[1].setComponents(I + o, b + f, x + S, _ + M).normalize(), n[2].setComponents(I + l, b + h, x + R, _ + T).normalize(), n[3].setComponents(I - l, b - h, x - R, _ - T).normalize(), n[4].setComponents(I - u, b - v, x - W, _ - E).normalize(), t === ip)
      n[5].setComponents(I + u, b + v, x + W, _ + E).normalize();
    else if (t === Aw)
      n[5].setComponents(u, v, W, E).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Yy.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), Yy.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Yy);
  }
  intersectsSprite(e) {
    return Yy.center.set(0, 0, 0), Yy.radius = 0.7071067811865476, Yy.applyMatrix4(e.matrixWorld), this.intersectsSphere(Yy);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, i = -e.radius;
    for (let o = 0; o < 6; o++)
      if (t[o].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (a1.x = i.normal.x > 0 ? e.max.x : e.min.x, a1.y = i.normal.y > 0 ? e.max.y : e.min.y, a1.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(a1) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Tz() {
  let a = null, e = !1, t = null, n = null;
  function i(o, l) {
    t(o, l), n = a.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = a.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      a.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(o) {
      t = o;
    },
    setContext: function(o) {
      a = o;
    }
  };
}
function RQ(a) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(u, I) {
    const f = u.array, h = u.usage, v = f.byteLength, b = a.createBuffer();
    a.bindBuffer(I, b), a.bufferData(I, f, h), u.onUploadCallback();
    let S;
    if (f instanceof Float32Array)
      S = a.FLOAT;
    else if (f instanceof Uint16Array)
      u.isFloat16BufferAttribute ? S = a.HALF_FLOAT : S = a.UNSIGNED_SHORT;
    else if (f instanceof Int16Array)
      S = a.SHORT;
    else if (f instanceof Uint32Array)
      S = a.UNSIGNED_INT;
    else if (f instanceof Int32Array)
      S = a.INT;
    else if (f instanceof Int8Array)
      S = a.BYTE;
    else if (f instanceof Uint8Array)
      S = a.UNSIGNED_BYTE;
    else if (f instanceof Uint8ClampedArray)
      S = a.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
    return {
      buffer: b,
      type: S,
      bytesPerElement: f.BYTES_PER_ELEMENT,
      version: u.version,
      size: v
    };
  }
  function n(u, I, f) {
    const h = I.array, v = I._updateRange, b = I.updateRanges;
    if (a.bindBuffer(f, u), v.count === -1 && b.length === 0 && a.bufferSubData(f, 0, h), b.length !== 0) {
      for (let S = 0, R = b.length; S < R; S++) {
        const W = b[S];
        a.bufferSubData(
          f,
          W.start * h.BYTES_PER_ELEMENT,
          h,
          W.start,
          W.count
        );
      }
      I.clearUpdateRanges();
    }
    v.count !== -1 && (a.bufferSubData(
      f,
      v.offset * h.BYTES_PER_ELEMENT,
      h,
      v.offset,
      v.count
    ), v.count = -1), I.onUploadCallback();
  }
  function i(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), e.get(u);
  }
  function o(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const I = e.get(u);
    I && (a.deleteBuffer(I.buffer), e.delete(u));
  }
  function l(u, I) {
    if (u.isInterleavedBufferAttribute && (u = u.data), u.isGLBufferAttribute) {
      const h = e.get(u);
      (!h || h.version < u.version) && e.set(u, {
        buffer: u.buffer,
        type: u.type,
        bytesPerElement: u.elementSize,
        version: u.version
      });
      return;
    }
    const f = e.get(u);
    if (f === void 0)
      e.set(u, t(u, I));
    else if (f.version < u.version) {
      if (f.size !== u.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(f.buffer, u, I), f.version = u.version;
    }
  }
  return {
    get: i,
    remove: o,
    update: l
  };
}
class dB extends _r {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: i
    };
    const o = e / 2, l = t / 2, u = Math.floor(n), I = Math.floor(i), f = u + 1, h = I + 1, v = e / u, b = t / I, S = [], R = [], W = [], x = [];
    for (let M = 0; M < h; M++) {
      const T = M * b - l;
      for (let E = 0; E < f; E++) {
        const _ = E * v - o;
        R.push(_, -T, 0), W.push(0, 0, 1), x.push(E / u), x.push(1 - M / I);
      }
    }
    for (let M = 0; M < I; M++)
      for (let T = 0; T < u; T++) {
        const E = T + f * M, _ = T + f * (M + 1), P = T + 1 + f * (M + 1), U = T + 1 + f * M;
        S.push(E, _, U), S.push(_, P, U);
      }
    this.setIndex(S), this.setAttribute("position", new Mi(R, 3)), this.setAttribute("normal", new Mi(W, 3)), this.setAttribute("uv", new Mi(x, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new dB(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var xQ = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, WQ = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, VQ = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, NQ = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, MQ = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, HQ = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, XQ = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, YQ = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, FQ = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, EQ = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, TQ = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, _Q = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, zQ = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, KQ = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, LQ = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, kQ = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, DQ = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, UQ = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, OQ = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, PQ = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, JQ = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, QQ = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, jQ = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, qQ = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, $Q = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, e4 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, t4 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, n4 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, i4 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, r4 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, a4 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", o4 = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, s4 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, l4 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, u4 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, c4 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, g4 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, d4 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, I4 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, C4 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, h4 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, f4 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, p4 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, m4 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, A4 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, v4 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, y4 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, b4 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, G4 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, B4 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, S4 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Z4 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, w4 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, R4 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, x4 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, W4 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, V4 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, N4 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, M4 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, H4 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, X4 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Y4 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, F4 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, E4 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, T4 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, _4 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, z4 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, K4 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, L4 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, k4 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, D4 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, U4 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, O4 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, P4 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, J4 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Q4 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, j4 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, q4 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, $4 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, ej = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, tj = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, nj = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, ij = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, rj = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, aj = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, oj = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, sj = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, lj = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, uj = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, cj = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, gj = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, dj = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Ij = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Cj = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, hj = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, fj = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, pj = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, mj = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Aj = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, vj = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, yj = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, bj = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Gj = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Bj = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Sj = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Zj = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, wj = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Rj = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, xj = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Wj = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Vj = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Nj = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Mj = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Hj = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Xj = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Yj = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Fj = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Ej = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Tj = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, _j = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, zj = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Kj = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Lj = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, kj = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Dj = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Uj = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Oj = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Pj = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Jj = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Qj = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, jj = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qj = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, $j = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, e7 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, t7 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, n7 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, i7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, r7 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, a7 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, o7 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, s7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Tr = {
  alphahash_fragment: xQ,
  alphahash_pars_fragment: WQ,
  alphamap_fragment: VQ,
  alphamap_pars_fragment: NQ,
  alphatest_fragment: MQ,
  alphatest_pars_fragment: HQ,
  aomap_fragment: XQ,
  aomap_pars_fragment: YQ,
  batching_pars_vertex: FQ,
  batching_vertex: EQ,
  begin_vertex: TQ,
  beginnormal_vertex: _Q,
  bsdfs: zQ,
  iridescence_fragment: KQ,
  bumpmap_pars_fragment: LQ,
  clipping_planes_fragment: kQ,
  clipping_planes_pars_fragment: DQ,
  clipping_planes_pars_vertex: UQ,
  clipping_planes_vertex: OQ,
  color_fragment: PQ,
  color_pars_fragment: JQ,
  color_pars_vertex: QQ,
  color_vertex: jQ,
  common: qQ,
  cube_uv_reflection_fragment: $Q,
  defaultnormal_vertex: e4,
  displacementmap_pars_vertex: t4,
  displacementmap_vertex: n4,
  emissivemap_fragment: i4,
  emissivemap_pars_fragment: r4,
  colorspace_fragment: a4,
  colorspace_pars_fragment: o4,
  envmap_fragment: s4,
  envmap_common_pars_fragment: l4,
  envmap_pars_fragment: u4,
  envmap_pars_vertex: c4,
  envmap_physical_pars_fragment: y4,
  envmap_vertex: g4,
  fog_vertex: d4,
  fog_pars_vertex: I4,
  fog_fragment: C4,
  fog_pars_fragment: h4,
  gradientmap_pars_fragment: f4,
  lightmap_pars_fragment: p4,
  lights_lambert_fragment: m4,
  lights_lambert_pars_fragment: A4,
  lights_pars_begin: v4,
  lights_toon_fragment: b4,
  lights_toon_pars_fragment: G4,
  lights_phong_fragment: B4,
  lights_phong_pars_fragment: S4,
  lights_physical_fragment: Z4,
  lights_physical_pars_fragment: w4,
  lights_fragment_begin: R4,
  lights_fragment_maps: x4,
  lights_fragment_end: W4,
  logdepthbuf_fragment: V4,
  logdepthbuf_pars_fragment: N4,
  logdepthbuf_pars_vertex: M4,
  logdepthbuf_vertex: H4,
  map_fragment: X4,
  map_pars_fragment: Y4,
  map_particle_fragment: F4,
  map_particle_pars_fragment: E4,
  metalnessmap_fragment: T4,
  metalnessmap_pars_fragment: _4,
  morphinstance_vertex: z4,
  morphcolor_vertex: K4,
  morphnormal_vertex: L4,
  morphtarget_pars_vertex: k4,
  morphtarget_vertex: D4,
  normal_fragment_begin: U4,
  normal_fragment_maps: O4,
  normal_pars_fragment: P4,
  normal_pars_vertex: J4,
  normal_vertex: Q4,
  normalmap_pars_fragment: j4,
  clearcoat_normal_fragment_begin: q4,
  clearcoat_normal_fragment_maps: $4,
  clearcoat_pars_fragment: ej,
  iridescence_pars_fragment: tj,
  opaque_fragment: nj,
  packing: ij,
  premultiplied_alpha_fragment: rj,
  project_vertex: aj,
  dithering_fragment: oj,
  dithering_pars_fragment: sj,
  roughnessmap_fragment: lj,
  roughnessmap_pars_fragment: uj,
  shadowmap_pars_fragment: cj,
  shadowmap_pars_vertex: gj,
  shadowmap_vertex: dj,
  shadowmask_pars_fragment: Ij,
  skinbase_vertex: Cj,
  skinning_pars_vertex: hj,
  skinning_vertex: fj,
  skinnormal_vertex: pj,
  specularmap_fragment: mj,
  specularmap_pars_fragment: Aj,
  tonemapping_fragment: vj,
  tonemapping_pars_fragment: yj,
  transmission_fragment: bj,
  transmission_pars_fragment: Gj,
  uv_pars_fragment: Bj,
  uv_pars_vertex: Sj,
  uv_vertex: Zj,
  worldpos_vertex: wj,
  background_vert: Rj,
  background_frag: xj,
  backgroundCube_vert: Wj,
  backgroundCube_frag: Vj,
  cube_vert: Nj,
  cube_frag: Mj,
  depth_vert: Hj,
  depth_frag: Xj,
  distanceRGBA_vert: Yj,
  distanceRGBA_frag: Fj,
  equirect_vert: Ej,
  equirect_frag: Tj,
  linedashed_vert: _j,
  linedashed_frag: zj,
  meshbasic_vert: Kj,
  meshbasic_frag: Lj,
  meshlambert_vert: kj,
  meshlambert_frag: Dj,
  meshmatcap_vert: Uj,
  meshmatcap_frag: Oj,
  meshnormal_vert: Pj,
  meshnormal_frag: Jj,
  meshphong_vert: Qj,
  meshphong_frag: jj,
  meshphysical_vert: qj,
  meshphysical_frag: $j,
  meshtoon_vert: e7,
  meshtoon_frag: t7,
  points_vert: n7,
  points_frag: i7,
  shadow_vert: r7,
  shadow_frag: a7,
  sprite_vert: o7,
  sprite_frag: s7
}, ai = {
  common: {
    diffuse: { value: /* @__PURE__ */ new hi(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Nr() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Nr() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Nr() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Nr() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Nr() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Nr() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Nr() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Nr() },
    normalScale: { value: /* @__PURE__ */ new sn(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Nr() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Nr() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Nr() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Nr() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new hi(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new hi(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Nr() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Nr() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new hi(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new sn(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Nr() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Nr() },
    alphaTest: { value: 0 }
  }
}, Eh = {
  basic: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.specularmap,
      ai.envmap,
      ai.aomap,
      ai.lightmap,
      ai.fog
    ]),
    vertexShader: Tr.meshbasic_vert,
    fragmentShader: Tr.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.specularmap,
      ai.envmap,
      ai.aomap,
      ai.lightmap,
      ai.emissivemap,
      ai.bumpmap,
      ai.normalmap,
      ai.displacementmap,
      ai.fog,
      ai.lights,
      {
        emissive: { value: /* @__PURE__ */ new hi(0) }
      }
    ]),
    vertexShader: Tr.meshlambert_vert,
    fragmentShader: Tr.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.specularmap,
      ai.envmap,
      ai.aomap,
      ai.lightmap,
      ai.emissivemap,
      ai.bumpmap,
      ai.normalmap,
      ai.displacementmap,
      ai.fog,
      ai.lights,
      {
        emissive: { value: /* @__PURE__ */ new hi(0) },
        specular: { value: /* @__PURE__ */ new hi(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Tr.meshphong_vert,
    fragmentShader: Tr.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.envmap,
      ai.aomap,
      ai.lightmap,
      ai.emissivemap,
      ai.bumpmap,
      ai.normalmap,
      ai.displacementmap,
      ai.roughnessmap,
      ai.metalnessmap,
      ai.fog,
      ai.lights,
      {
        emissive: { value: /* @__PURE__ */ new hi(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Tr.meshphysical_vert,
    fragmentShader: Tr.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.aomap,
      ai.lightmap,
      ai.emissivemap,
      ai.bumpmap,
      ai.normalmap,
      ai.displacementmap,
      ai.gradientmap,
      ai.fog,
      ai.lights,
      {
        emissive: { value: /* @__PURE__ */ new hi(0) }
      }
    ]),
    vertexShader: Tr.meshtoon_vert,
    fragmentShader: Tr.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.bumpmap,
      ai.normalmap,
      ai.displacementmap,
      ai.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Tr.meshmatcap_vert,
    fragmentShader: Tr.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Fg([
      ai.points,
      ai.fog
    ]),
    vertexShader: Tr.points_vert,
    fragmentShader: Tr.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Tr.linedashed_vert,
    fragmentShader: Tr.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.displacementmap
    ]),
    vertexShader: Tr.depth_vert,
    fragmentShader: Tr.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.bumpmap,
      ai.normalmap,
      ai.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Tr.meshnormal_vert,
    fragmentShader: Tr.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Fg([
      ai.sprite,
      ai.fog
    ]),
    vertexShader: Tr.sprite_vert,
    fragmentShader: Tr.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Nr() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Tr.background_vert,
    fragmentShader: Tr.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Nr() }
    },
    vertexShader: Tr.backgroundCube_vert,
    fragmentShader: Tr.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Tr.cube_vert,
    fragmentShader: Tr.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Tr.equirect_vert,
    fragmentShader: Tr.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Fg([
      ai.common,
      ai.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Ze() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Tr.distanceRGBA_vert,
    fragmentShader: Tr.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Fg([
      ai.lights,
      ai.fog,
      {
        color: { value: /* @__PURE__ */ new hi(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Tr.shadow_vert,
    fragmentShader: Tr.shadow_frag
  }
};
Eh.physical = {
  uniforms: /* @__PURE__ */ Fg([
    Eh.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Nr() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Nr() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new sn(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Nr() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Nr() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Nr() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new hi(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Nr() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Nr() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Nr() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new sn() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Nr() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new hi(0) },
      specularColor: { value: /* @__PURE__ */ new hi(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Nr() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Nr() },
      anisotropyVector: { value: /* @__PURE__ */ new sn() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Nr() }
    }
  ]),
  vertexShader: Tr.meshphysical_vert,
  fragmentShader: Tr.meshphysical_frag
};
const o1 = { r: 0, b: 0, g: 0 }, Fy = /* @__PURE__ */ new Kd(), l7 = /* @__PURE__ */ new tr();
function u7(a, e, t, n, i, o, l) {
  const u = new hi(0);
  let I = o === !0 ? 0 : 1, f, h, v = null, b = 0, S = null;
  function R(T) {
    let E = T.isScene === !0 ? T.background : null;
    return E && E.isTexture && (E = (T.backgroundBlurriness > 0 ? t : e).get(E)), E;
  }
  function W(T) {
    let E = !1;
    const _ = R(T);
    _ === null ? M(u, I) : _ && _.isColor && (M(_, 1), E = !0);
    const P = a.xr.getEnvironmentBlendMode();
    P === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, l) : P === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, l), (a.autoClear || E) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil));
  }
  function x(T, E) {
    const _ = R(E);
    _ && (_.isCubeTexture || _.mapping === gB) ? (h === void 0 && (h = new Fl(
      new Rb(1, 1, 1),
      new zh({
        name: "BackgroundCubeMaterial",
        uniforms: eB(Eh.backgroundCube.uniforms),
        vertexShader: Eh.backgroundCube.vertexShader,
        fragmentShader: Eh.backgroundCube.fragmentShader,
        side: Dg,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(P, U, q) {
      this.matrixWorld.copyPosition(q.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(h)), Fy.copy(E.backgroundRotation), Fy.x *= -1, Fy.y *= -1, Fy.z *= -1, _.isCubeTexture && _.isRenderTargetTexture === !1 && (Fy.y *= -1, Fy.z *= -1), h.material.uniforms.envMap.value = _, h.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = E.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = E.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(l7.makeRotationFromEuler(Fy)), h.material.toneMapped = Ta.getTransfer(_.colorSpace) !== Po, (v !== _ || b !== _.version || S !== a.toneMapping) && (h.material.needsUpdate = !0, v = _, b = _.version, S = a.toneMapping), h.layers.enableAll(), T.unshift(h, h.geometry, h.material, 0, 0, null)) : _ && _.isTexture && (f === void 0 && (f = new Fl(
      new dB(2, 2),
      new zh({
        name: "BackgroundMaterial",
        uniforms: eB(Eh.background.uniforms),
        vertexShader: Eh.background.vertexShader,
        fragmentShader: Eh.background.fragmentShader,
        side: Nm,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), f.geometry.deleteAttribute("normal"), Object.defineProperty(f.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(f)), f.material.uniforms.t2D.value = _, f.material.uniforms.backgroundIntensity.value = E.backgroundIntensity, f.material.toneMapped = Ta.getTransfer(_.colorSpace) !== Po, _.matrixAutoUpdate === !0 && _.updateMatrix(), f.material.uniforms.uvTransform.value.copy(_.matrix), (v !== _ || b !== _.version || S !== a.toneMapping) && (f.material.needsUpdate = !0, v = _, b = _.version, S = a.toneMapping), f.layers.enableAll(), T.unshift(f, f.geometry, f.material, 0, 0, null));
  }
  function M(T, E) {
    T.getRGB(o1, Xz(a)), n.buffers.color.setClear(o1.r, o1.g, o1.b, E, l);
  }
  return {
    getClearColor: function() {
      return u;
    },
    setClearColor: function(T, E = 1) {
      u.set(T), I = E, M(u, I);
    },
    getClearAlpha: function() {
      return I;
    },
    setClearAlpha: function(T) {
      I = T, M(u, I);
    },
    render: W,
    addToRenderList: x
  };
}
function c7(a, e) {
  const t = a.getParameter(a.MAX_VERTEX_ATTRIBS), n = {}, i = b(null);
  let o = i, l = !1;
  function u(J, te, fe, pe, Ae) {
    let Te = !1;
    const Ke = v(pe, fe, te);
    o !== Ke && (o = Ke, f(o.object)), Te = S(J, pe, fe, Ae), Te && R(J, pe, fe, Ae), Ae !== null && e.update(Ae, a.ELEMENT_ARRAY_BUFFER), (Te || l) && (l = !1, _(J, te, fe, pe), Ae !== null && a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e.get(Ae).buffer));
  }
  function I() {
    return a.createVertexArray();
  }
  function f(J) {
    return a.bindVertexArray(J);
  }
  function h(J) {
    return a.deleteVertexArray(J);
  }
  function v(J, te, fe) {
    const pe = fe.wireframe === !0;
    let Ae = n[J.id];
    Ae === void 0 && (Ae = {}, n[J.id] = Ae);
    let Te = Ae[te.id];
    Te === void 0 && (Te = {}, Ae[te.id] = Te);
    let Ke = Te[pe];
    return Ke === void 0 && (Ke = b(I()), Te[pe] = Ke), Ke;
  }
  function b(J) {
    const te = [], fe = [], pe = [];
    for (let Ae = 0; Ae < t; Ae++)
      te[Ae] = 0, fe[Ae] = 0, pe[Ae] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: te,
      enabledAttributes: fe,
      attributeDivisors: pe,
      object: J,
      attributes: {},
      index: null
    };
  }
  function S(J, te, fe, pe) {
    const Ae = o.attributes, Te = te.attributes;
    let Ke = 0;
    const je = fe.getAttributes();
    for (const ee in je)
      if (je[ee].location >= 0) {
        const be = Ae[ee];
        let le = Te[ee];
        if (le === void 0 && (ee === "instanceMatrix" && J.instanceMatrix && (le = J.instanceMatrix), ee === "instanceColor" && J.instanceColor && (le = J.instanceColor)), be === void 0 || be.attribute !== le || le && be.data !== le.data) return !0;
        Ke++;
      }
    return o.attributesNum !== Ke || o.index !== pe;
  }
  function R(J, te, fe, pe) {
    const Ae = {}, Te = te.attributes;
    let Ke = 0;
    const je = fe.getAttributes();
    for (const ee in je)
      if (je[ee].location >= 0) {
        let be = Te[ee];
        be === void 0 && (ee === "instanceMatrix" && J.instanceMatrix && (be = J.instanceMatrix), ee === "instanceColor" && J.instanceColor && (be = J.instanceColor));
        const le = {};
        le.attribute = be, be && be.data && (le.data = be.data), Ae[ee] = le, Ke++;
      }
    o.attributes = Ae, o.attributesNum = Ke, o.index = pe;
  }
  function W() {
    const J = o.newAttributes;
    for (let te = 0, fe = J.length; te < fe; te++)
      J[te] = 0;
  }
  function x(J) {
    M(J, 0);
  }
  function M(J, te) {
    const fe = o.newAttributes, pe = o.enabledAttributes, Ae = o.attributeDivisors;
    fe[J] = 1, pe[J] === 0 && (a.enableVertexAttribArray(J), pe[J] = 1), Ae[J] !== te && (a.vertexAttribDivisor(J, te), Ae[J] = te);
  }
  function T() {
    const J = o.newAttributes, te = o.enabledAttributes;
    for (let fe = 0, pe = te.length; fe < pe; fe++)
      te[fe] !== J[fe] && (a.disableVertexAttribArray(fe), te[fe] = 0);
  }
  function E(J, te, fe, pe, Ae, Te, Ke) {
    Ke === !0 ? a.vertexAttribIPointer(J, te, fe, Ae, Te) : a.vertexAttribPointer(J, te, fe, pe, Ae, Te);
  }
  function _(J, te, fe, pe) {
    W();
    const Ae = pe.attributes, Te = fe.getAttributes(), Ke = te.defaultAttributeValues;
    for (const je in Te) {
      const ee = Te[je];
      if (ee.location >= 0) {
        let Ce = Ae[je];
        if (Ce === void 0 && (je === "instanceMatrix" && J.instanceMatrix && (Ce = J.instanceMatrix), je === "instanceColor" && J.instanceColor && (Ce = J.instanceColor)), Ce !== void 0) {
          const be = Ce.normalized, le = Ce.itemSize, Ye = e.get(Ce);
          if (Ye === void 0) continue;
          const $e = Ye.buffer, ke = Ye.type, ot = Ye.bytesPerElement, wt = ke === a.INT || ke === a.UNSIGNED_INT || Ce.gpuType === gW;
          if (Ce.isInterleavedBufferAttribute) {
            const St = Ce.data, ln = St.stride, hn = Ce.offset;
            if (St.isInstancedInterleavedBuffer) {
              for (let mn = 0; mn < ee.locationSize; mn++)
                M(ee.location + mn, St.meshPerAttribute);
              J.isInstancedMesh !== !0 && pe._maxInstanceCount === void 0 && (pe._maxInstanceCount = St.meshPerAttribute * St.count);
            } else
              for (let mn = 0; mn < ee.locationSize; mn++)
                x(ee.location + mn);
            a.bindBuffer(a.ARRAY_BUFFER, $e);
            for (let mn = 0; mn < ee.locationSize; mn++)
              E(
                ee.location + mn,
                le / ee.locationSize,
                ke,
                be,
                ln * ot,
                (hn + le / ee.locationSize * mn) * ot,
                wt
              );
          } else {
            if (Ce.isInstancedBufferAttribute) {
              for (let St = 0; St < ee.locationSize; St++)
                M(ee.location + St, Ce.meshPerAttribute);
              J.isInstancedMesh !== !0 && pe._maxInstanceCount === void 0 && (pe._maxInstanceCount = Ce.meshPerAttribute * Ce.count);
            } else
              for (let St = 0; St < ee.locationSize; St++)
                x(ee.location + St);
            a.bindBuffer(a.ARRAY_BUFFER, $e);
            for (let St = 0; St < ee.locationSize; St++)
              E(
                ee.location + St,
                le / ee.locationSize,
                ke,
                be,
                le * ot,
                le / ee.locationSize * St * ot,
                wt
              );
          }
        } else if (Ke !== void 0) {
          const be = Ke[je];
          if (be !== void 0)
            switch (be.length) {
              case 2:
                a.vertexAttrib2fv(ee.location, be);
                break;
              case 3:
                a.vertexAttrib3fv(ee.location, be);
                break;
              case 4:
                a.vertexAttrib4fv(ee.location, be);
                break;
              default:
                a.vertexAttrib1fv(ee.location, be);
            }
        }
      }
    }
    T();
  }
  function P() {
    k();
    for (const J in n) {
      const te = n[J];
      for (const fe in te) {
        const pe = te[fe];
        for (const Ae in pe)
          h(pe[Ae].object), delete pe[Ae];
        delete te[fe];
      }
      delete n[J];
    }
  }
  function U(J) {
    if (n[J.id] === void 0) return;
    const te = n[J.id];
    for (const fe in te) {
      const pe = te[fe];
      for (const Ae in pe)
        h(pe[Ae].object), delete pe[Ae];
      delete te[fe];
    }
    delete n[J.id];
  }
  function q(J) {
    for (const te in n) {
      const fe = n[te];
      if (fe[J.id] === void 0) continue;
      const pe = fe[J.id];
      for (const Ae in pe)
        h(pe[Ae].object), delete pe[Ae];
      delete fe[J.id];
    }
  }
  function k() {
    O(), l = !0, o !== i && (o = i, f(o.object));
  }
  function O() {
    i.geometry = null, i.program = null, i.wireframe = !1;
  }
  return {
    setup: u,
    reset: k,
    resetDefaultState: O,
    dispose: P,
    releaseStatesOfGeometry: U,
    releaseStatesOfProgram: q,
    initAttributes: W,
    enableAttribute: x,
    disableUnusedAttributes: T
  };
}
function g7(a, e, t) {
  let n;
  function i(f) {
    n = f;
  }
  function o(f, h) {
    a.drawArrays(n, f, h), t.update(h, n, 1);
  }
  function l(f, h, v) {
    v !== 0 && (a.drawArraysInstanced(n, f, h, v), t.update(h, n, v));
  }
  function u(f, h, v) {
    if (v === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, f, 0, h, 0, v);
    let S = 0;
    for (let R = 0; R < v; R++)
      S += h[R];
    t.update(S, n, 1);
  }
  function I(f, h, v, b) {
    if (v === 0) return;
    const S = e.get("WEBGL_multi_draw");
    if (S === null)
      for (let R = 0; R < f.length; R++)
        l(f[R], h[R], b[R]);
    else {
      S.multiDrawArraysInstancedWEBGL(n, f, 0, h, 0, b, 0, v);
      let R = 0;
      for (let W = 0; W < v; W++)
        R += h[W];
      for (let W = 0; W < b.length; W++)
        t.update(R, n, b[W]);
    }
  }
  this.setMode = i, this.render = o, this.renderInstances = l, this.renderMultiDraw = u, this.renderMultiDrawInstances = I;
}
function d7(a, e, t, n) {
  let i;
  function o() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const U = e.get("EXT_texture_filter_anisotropic");
      i = a.getParameter(U.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function l(U) {
    return !(U !== rg && n.convert(U) !== a.getParameter(a.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function u(U) {
    const q = U === Zb && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(U !== _h && n.convert(U) !== a.getParameter(a.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    U !== kg && !q);
  }
  function I(U) {
    if (U === "highp") {
      if (a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision > 0 && a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision > 0)
        return "highp";
      U = "mediump";
    }
    return U === "mediump" && a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision > 0 && a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let f = t.precision !== void 0 ? t.precision : "highp";
  const h = I(f);
  h !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", h, "instead."), f = h);
  const v = t.logarithmicDepthBuffer === !0, b = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), S = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS), R = a.getParameter(a.MAX_TEXTURE_SIZE), W = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE), x = a.getParameter(a.MAX_VERTEX_ATTRIBS), M = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS), T = a.getParameter(a.MAX_VARYING_VECTORS), E = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS), _ = S > 0, P = a.getParameter(a.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: o,
    getMaxPrecision: I,
    textureFormatReadable: l,
    textureTypeReadable: u,
    precision: f,
    logarithmicDepthBuffer: v,
    maxTextures: b,
    maxVertexTextures: S,
    maxTextureSize: R,
    maxCubemapSize: W,
    maxAttributes: x,
    maxVertexUniforms: M,
    maxVaryings: T,
    maxFragmentUniforms: E,
    vertexTextures: _,
    maxSamples: P
  };
}
function I7(a) {
  const e = this;
  let t = null, n = 0, i = !1, o = !1;
  const l = new Gm(), u = new Nr(), I = { value: null, needsUpdate: !1 };
  this.uniform = I, this.numPlanes = 0, this.numIntersection = 0, this.init = function(v, b) {
    const S = v.length !== 0 || b || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || i;
    return i = b, n = v.length, S;
  }, this.beginShadows = function() {
    o = !0, h(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(v, b) {
    t = h(v, b, 0);
  }, this.setState = function(v, b, S) {
    const R = v.clippingPlanes, W = v.clipIntersection, x = v.clipShadows, M = a.get(v);
    if (!i || R === null || R.length === 0 || o && !x)
      o ? h(null) : f();
    else {
      const T = o ? 0 : n, E = T * 4;
      let _ = M.clippingState || null;
      I.value = _, _ = h(R, b, E, S);
      for (let P = 0; P !== E; ++P)
        _[P] = t[P];
      M.clippingState = _, this.numIntersection = W ? this.numPlanes : 0, this.numPlanes += T;
    }
  };
  function f() {
    I.value !== t && (I.value = t, I.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function h(v, b, S, R) {
    const W = v !== null ? v.length : 0;
    let x = null;
    if (W !== 0) {
      if (x = I.value, R !== !0 || x === null) {
        const M = S + W * 4, T = b.matrixWorldInverse;
        u.getNormalMatrix(T), (x === null || x.length < M) && (x = new Float32Array(M));
        for (let E = 0, _ = S; E !== W; ++E, _ += 4)
          l.copy(v[E]).applyMatrix4(T, u), l.normal.toArray(x, _), x[_ + 3] = l.constant;
      }
      I.value = x, I.needsUpdate = !0;
    }
    return e.numPlanes = W, e.numIntersection = 0, x;
  }
}
function C7(a) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(l, u) {
    return u === uw ? l.mapping = Mm : u === cw && (l.mapping = $A), l;
  }
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping;
      if (u === uw || u === cw)
        if (e.has(l)) {
          const I = e.get(l).texture;
          return t(I, l.mapping);
        } else {
          const I = l.image;
          if (I && I.height > 0) {
            const f = new Ez(I.height);
            return f.fromEquirectangularTexture(a, l), e.set(l, f), l.addEventListener("dispose", i), t(f.texture, l.mapping);
          } else
            return null;
        }
    }
    return l;
  }
  function i(l) {
    const u = l.target;
    u.removeEventListener("dispose", i);
    const I = e.get(u);
    I !== void 0 && (e.delete(u), I.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: o
  };
}
class wm extends kw {
  constructor(e = -1, t = 1, n = 1, i = -1, o = 0.1, l = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = o, this.far = l, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, i, o, l) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let o = n - e, l = n + e, u = i + t, I = i - t;
    if (this.view !== null && this.view.enabled) {
      const f = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += f * this.view.offsetX, l = o + f * this.view.width, u -= h * this.view.offsetY, I = u - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, l, u, I, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const TG = 4, yT = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], $y = 20, hM = /* @__PURE__ */ new wm(), bT = /* @__PURE__ */ new hi();
let fM = null, pM = 0, mM = 0, AM = !1;
const Qy = (1 + Math.sqrt(5)) / 2, GG = 1 / Qy, GT = [
  /* @__PURE__ */ new Ze(-Qy, GG, 0),
  /* @__PURE__ */ new Ze(Qy, GG, 0),
  /* @__PURE__ */ new Ze(-GG, 0, Qy),
  /* @__PURE__ */ new Ze(GG, 0, Qy),
  /* @__PURE__ */ new Ze(0, Qy, -GG),
  /* @__PURE__ */ new Ze(0, Qy, GG),
  /* @__PURE__ */ new Ze(-1, 1, -1),
  /* @__PURE__ */ new Ze(1, 1, -1),
  /* @__PURE__ */ new Ze(-1, 1, 1),
  /* @__PURE__ */ new Ze(1, 1, 1)
];
class RH {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, i = 100) {
    fM = this._renderer.getRenderTarget(), pM = this._renderer.getActiveCubeFace(), mM = this._renderer.getActiveMipmapLevel(), AM = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, n, i, o), t > 0 && this._blur(o, 0, 0, t), this._applyPMREM(o), this._cleanup(o), o;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = ZT(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = ST(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(fM, pM, mM), this._renderer.xr.enabled = AM, e.scissorTest = !1, s1(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Mm || e.mapping === $A ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), fM = this._renderer.getRenderTarget(), pM = this._renderer.getActiveCubeFace(), mM = this._renderer.getActiveMipmapLevel(), AM = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: nl,
      minFilter: nl,
      generateMipmaps: !1,
      type: Zb,
      format: rg,
      colorSpace: Tm,
      depthBuffer: !1
    }, i = BT(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = BT(e, t, n);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = h7(o)), this._blurMaterial = f7(o, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Fl(this._lodPlanes[0], e);
    this._renderer.compile(t, hM);
  }
  _sceneToCubeUV(e, t, n, i) {
    const u = new tl(90, 1, t, n), I = [1, -1, 1, 1, 1, 1], f = [1, 1, 1, -1, -1, -1], h = this._renderer, v = h.autoClear, b = h.toneMapping;
    h.getClearColor(bT), h.toneMapping = sp, h.autoClear = !1;
    const S = new rv({
      name: "PMREM.Background",
      side: Dg,
      depthWrite: !1,
      depthTest: !1
    }), R = new Fl(new Rb(), S);
    let W = !1;
    const x = e.background;
    x ? x.isColor && (S.color.copy(x), e.background = null, W = !0) : (S.color.copy(bT), W = !0);
    for (let M = 0; M < 6; M++) {
      const T = M % 3;
      T === 0 ? (u.up.set(0, I[M], 0), u.lookAt(f[M], 0, 0)) : T === 1 ? (u.up.set(0, 0, I[M]), u.lookAt(0, f[M], 0)) : (u.up.set(0, I[M], 0), u.lookAt(0, 0, f[M]));
      const E = this._cubeSize;
      s1(i, T * E, M > 2 ? E : 0, E, E), h.setRenderTarget(i), W && h.render(R, u), h.render(e, u);
    }
    R.geometry.dispose(), R.material.dispose(), h.toneMapping = b, h.autoClear = v, e.background = x;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, i = e.mapping === Mm || e.mapping === $A;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = ZT()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = ST());
    const o = i ? this._cubemapMaterial : this._equirectMaterial, l = new Fl(this._lodPlanes[0], o), u = o.uniforms;
    u.envMap.value = e;
    const I = this._cubeSize;
    s1(t, 0, 0, 3 * I, 2 * I), n.setRenderTarget(t), n.render(l, hM);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const l = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), u = GT[(i - o - 1) % GT.length];
      this._blur(e, o - 1, o, l, u);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, i, o) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      l,
      t,
      n,
      i,
      "latitudinal",
      o
    ), this._halfBlur(
      l,
      e,
      n,
      n,
      i,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, t, n, i, o, l, u) {
    const I = this._renderer, f = this._blurMaterial;
    l !== "latitudinal" && l !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const h = 3, v = new Fl(this._lodPlanes[i], f), b = f.uniforms, S = this._sizeLods[n] - 1, R = isFinite(o) ? Math.PI / (2 * S) : 2 * Math.PI / (2 * $y - 1), W = o / R, x = isFinite(o) ? 1 + Math.floor(h * W) : $y;
    x > $y && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${$y}`);
    const M = [];
    let T = 0;
    for (let q = 0; q < $y; ++q) {
      const k = q / W, O = Math.exp(-k * k / 2);
      M.push(O), q === 0 ? T += O : q < x && (T += 2 * O);
    }
    for (let q = 0; q < M.length; q++)
      M[q] = M[q] / T;
    b.envMap.value = e.texture, b.samples.value = x, b.weights.value = M, b.latitudinal.value = l === "latitudinal", u && (b.poleAxis.value = u);
    const { _lodMax: E } = this;
    b.dTheta.value = R, b.mipInt.value = E - n;
    const _ = this._sizeLods[i], P = 3 * _ * (i > E - TG ? i - E + TG : 0), U = 4 * (this._cubeSize - _);
    s1(t, P, U, 3 * _, 2 * _), I.setRenderTarget(t), I.render(v, hM);
  }
}
function h7(a) {
  const e = [], t = [], n = [];
  let i = a;
  const o = a - TG + 1 + yT.length;
  for (let l = 0; l < o; l++) {
    const u = Math.pow(2, i);
    t.push(u);
    let I = 1 / u;
    l > a - TG ? I = yT[l - a + TG - 1] : l === 0 && (I = 0), n.push(I);
    const f = 1 / (u - 2), h = -f, v = 1 + f, b = [h, h, v, h, v, v, h, h, v, v, h, v], S = 6, R = 6, W = 3, x = 2, M = 1, T = new Float32Array(W * R * S), E = new Float32Array(x * R * S), _ = new Float32Array(M * R * S);
    for (let U = 0; U < S; U++) {
      const q = U % 3 * 2 / 3 - 1, k = U > 2 ? 0 : -1, O = [
        q,
        k,
        0,
        q + 2 / 3,
        k,
        0,
        q + 2 / 3,
        k + 1,
        0,
        q,
        k,
        0,
        q + 2 / 3,
        k + 1,
        0,
        q,
        k + 1,
        0
      ];
      T.set(O, W * R * U), E.set(b, x * R * U);
      const J = [U, U, U, U, U, U];
      _.set(J, M * R * U);
    }
    const P = new _r();
    P.setAttribute("position", new Zo(T, W)), P.setAttribute("uv", new Zo(E, x)), P.setAttribute("faceIndex", new Zo(_, M)), e.push(P), i > TG && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function BT(a, e, t) {
  const n = new EC(a, e, t);
  return n.texture.mapping = gB, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function s1(a, e, t, n, i) {
  a.viewport.set(e, t, n, i), a.scissor.set(e, t, n, i);
}
function f7(a, e, t) {
  const n = new Float32Array($y), i = new Ze(0, 1, 0);
  return new zh({
    name: "SphericalGaussianBlur",
    defines: {
      n: $y,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${a}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: FX(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Vm,
    depthTest: !1,
    depthWrite: !1
  });
}
function ST() {
  return new zh({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: FX(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Vm,
    depthTest: !1,
    depthWrite: !1
  });
}
function ZT() {
  return new zh({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: FX(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Vm,
    depthTest: !1,
    depthWrite: !1
  });
}
function FX() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function p7(a) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(u) {
    if (u && u.isTexture) {
      const I = u.mapping, f = I === uw || I === cw, h = I === Mm || I === $A;
      if (f || h) {
        let v = e.get(u);
        const b = v !== void 0 ? v.texture.pmremVersion : 0;
        if (u.isRenderTargetTexture && u.pmremVersion !== b)
          return t === null && (t = new RH(a)), v = f ? t.fromEquirectangular(u, v) : t.fromCubemap(u, v), v.texture.pmremVersion = u.pmremVersion, e.set(u, v), v.texture;
        if (v !== void 0)
          return v.texture;
        {
          const S = u.image;
          return f && S && S.height > 0 || h && S && i(S) ? (t === null && (t = new RH(a)), v = f ? t.fromEquirectangular(u) : t.fromCubemap(u), v.texture.pmremVersion = u.pmremVersion, e.set(u, v), u.addEventListener("dispose", o), v.texture) : null;
        }
      }
    }
    return u;
  }
  function i(u) {
    let I = 0;
    const f = 6;
    for (let h = 0; h < f; h++)
      u[h] !== void 0 && I++;
    return I === f;
  }
  function o(u) {
    const I = u.target;
    I.removeEventListener("dispose", o);
    const f = e.get(I);
    f !== void 0 && (e.delete(I), f.dispose());
  }
  function l() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: l
  };
}
function m7(a) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = a.getExtension(n);
    }
    return e[n] = i, i;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function() {
      t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const i = t(n);
      return i === null && DG("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function A7(a, e, t, n) {
  const i = {}, o = /* @__PURE__ */ new WeakMap();
  function l(v) {
    const b = v.target;
    b.index !== null && e.remove(b.index);
    for (const R in b.attributes)
      e.remove(b.attributes[R]);
    for (const R in b.morphAttributes) {
      const W = b.morphAttributes[R];
      for (let x = 0, M = W.length; x < M; x++)
        e.remove(W[x]);
    }
    b.removeEventListener("dispose", l), delete i[b.id];
    const S = o.get(b);
    S && (e.remove(S), o.delete(b)), n.releaseStatesOfGeometry(b), b.isInstancedBufferGeometry === !0 && delete b._maxInstanceCount, t.memory.geometries--;
  }
  function u(v, b) {
    return i[b.id] === !0 || (b.addEventListener("dispose", l), i[b.id] = !0, t.memory.geometries++), b;
  }
  function I(v) {
    const b = v.attributes;
    for (const R in b)
      e.update(b[R], a.ARRAY_BUFFER);
    const S = v.morphAttributes;
    for (const R in S) {
      const W = S[R];
      for (let x = 0, M = W.length; x < M; x++)
        e.update(W[x], a.ARRAY_BUFFER);
    }
  }
  function f(v) {
    const b = [], S = v.index, R = v.attributes.position;
    let W = 0;
    if (S !== null) {
      const T = S.array;
      W = S.version;
      for (let E = 0, _ = T.length; E < _; E += 3) {
        const P = T[E + 0], U = T[E + 1], q = T[E + 2];
        b.push(P, U, U, q, q, P);
      }
    } else if (R !== void 0) {
      const T = R.array;
      W = R.version;
      for (let E = 0, _ = T.length / 3 - 1; E < _; E += 3) {
        const P = E + 0, U = E + 1, q = E + 2;
        b.push(P, U, U, q, q, P);
      }
    } else
      return;
    const x = new (Wz(b) ? YX : XX)(b, 1);
    x.version = W;
    const M = o.get(v);
    M && e.remove(M), o.set(v, x);
  }
  function h(v) {
    const b = o.get(v);
    if (b) {
      const S = v.index;
      S !== null && b.version < S.version && f(v);
    } else
      f(v);
    return o.get(v);
  }
  return {
    get: u,
    update: I,
    getWireframeAttribute: h
  };
}
function v7(a, e, t) {
  let n;
  function i(b) {
    n = b;
  }
  let o, l;
  function u(b) {
    o = b.type, l = b.bytesPerElement;
  }
  function I(b, S) {
    a.drawElements(n, S, o, b * l), t.update(S, n, 1);
  }
  function f(b, S, R) {
    R !== 0 && (a.drawElementsInstanced(n, S, o, b * l, R), t.update(S, n, R));
  }
  function h(b, S, R) {
    if (R === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, S, 0, o, b, 0, R);
    let x = 0;
    for (let M = 0; M < R; M++)
      x += S[M];
    t.update(x, n, 1);
  }
  function v(b, S, R, W) {
    if (R === 0) return;
    const x = e.get("WEBGL_multi_draw");
    if (x === null)
      for (let M = 0; M < b.length; M++)
        f(b[M] / l, S[M], W[M]);
    else {
      x.multiDrawElementsInstancedWEBGL(n, S, 0, o, b, 0, W, 0, R);
      let M = 0;
      for (let T = 0; T < R; T++)
        M += S[T];
      for (let T = 0; T < W.length; T++)
        t.update(M, n, W[T]);
    }
  }
  this.setMode = i, this.setIndex = u, this.render = I, this.renderInstances = f, this.renderMultiDraw = h, this.renderMultiDrawInstances = v;
}
function y7(a) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(o, l, u) {
    switch (t.calls++, l) {
      case a.TRIANGLES:
        t.triangles += u * (o / 3);
        break;
      case a.LINES:
        t.lines += u * (o / 2);
        break;
      case a.LINE_STRIP:
        t.lines += u * (o - 1);
        break;
      case a.LINE_LOOP:
        t.lines += u * o;
        break;
      case a.POINTS:
        t.points += u * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", l);
        break;
    }
  }
  function i() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function b7(a, e, t) {
  const n = /* @__PURE__ */ new WeakMap(), i = new ro();
  function o(l, u, I) {
    const f = l.morphTargetInfluences, h = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color, v = h !== void 0 ? h.length : 0;
    let b = n.get(u);
    if (b === void 0 || b.count !== v) {
      let O = function() {
        q.dispose(), n.delete(u), u.removeEventListener("dispose", O);
      };
      b !== void 0 && b.texture.dispose();
      const S = u.morphAttributes.position !== void 0, R = u.morphAttributes.normal !== void 0, W = u.morphAttributes.color !== void 0, x = u.morphAttributes.position || [], M = u.morphAttributes.normal || [], T = u.morphAttributes.color || [];
      let E = 0;
      S === !0 && (E = 1), R === !0 && (E = 2), W === !0 && (E = 3);
      let _ = u.attributes.position.count * E, P = 1;
      _ > e.maxTextureSize && (P = Math.ceil(_ / e.maxTextureSize), _ = e.maxTextureSize);
      const U = new Float32Array(_ * P * 4 * v), q = new AW(U, _, P, v);
      q.type = kg, q.needsUpdate = !0;
      const k = E * 4;
      for (let J = 0; J < v; J++) {
        const te = x[J], fe = M[J], pe = T[J], Ae = _ * P * 4 * J;
        for (let Te = 0; Te < te.count; Te++) {
          const Ke = Te * k;
          S === !0 && (i.fromBufferAttribute(te, Te), U[Ae + Ke + 0] = i.x, U[Ae + Ke + 1] = i.y, U[Ae + Ke + 2] = i.z, U[Ae + Ke + 3] = 0), R === !0 && (i.fromBufferAttribute(fe, Te), U[Ae + Ke + 4] = i.x, U[Ae + Ke + 5] = i.y, U[Ae + Ke + 6] = i.z, U[Ae + Ke + 7] = 0), W === !0 && (i.fromBufferAttribute(pe, Te), U[Ae + Ke + 8] = i.x, U[Ae + Ke + 9] = i.y, U[Ae + Ke + 10] = i.z, U[Ae + Ke + 11] = pe.itemSize === 4 ? i.w : 1);
        }
      }
      b = {
        count: v,
        texture: q,
        size: new sn(_, P)
      }, n.set(u, b), u.addEventListener("dispose", O);
    }
    if (l.isInstancedMesh === !0 && l.morphTexture !== null)
      I.getUniforms().setValue(a, "morphTexture", l.morphTexture, t);
    else {
      let S = 0;
      for (let W = 0; W < f.length; W++)
        S += f[W];
      const R = u.morphTargetsRelative ? 1 : 1 - S;
      I.getUniforms().setValue(a, "morphTargetBaseInfluence", R), I.getUniforms().setValue(a, "morphTargetInfluences", f);
    }
    I.getUniforms().setValue(a, "morphTargetsTexture", b.texture, t), I.getUniforms().setValue(a, "morphTargetsTextureSize", b.size);
  }
  return {
    update: o
  };
}
function G7(a, e, t, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function o(I) {
    const f = n.render.frame, h = I.geometry, v = e.get(I, h);
    if (i.get(v) !== f && (e.update(v), i.set(v, f)), I.isInstancedMesh && (I.hasEventListener("dispose", u) === !1 && I.addEventListener("dispose", u), i.get(I) !== f && (t.update(I.instanceMatrix, a.ARRAY_BUFFER), I.instanceColor !== null && t.update(I.instanceColor, a.ARRAY_BUFFER), i.set(I, f))), I.isSkinnedMesh) {
      const b = I.skeleton;
      i.get(b) !== f && (b.update(), i.set(b, f));
    }
    return v;
  }
  function l() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function u(I) {
    const f = I.target;
    f.removeEventListener("dispose", u), t.remove(f.instanceMatrix), f.instanceColor !== null && t.remove(f.instanceColor);
  }
  return {
    update: o,
    dispose: l
  };
}
class vW extends Fs {
  constructor(e, t, n, i, o, l, u, I, f, h = cb) {
    if (h !== cb && h !== vb)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && h === cb && (n = Hm), n === void 0 && h === vb && (n = Ab), super(null, i, o, l, u, I, h, n, f), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = u !== void 0 ? u : _u, this.minFilter = I !== void 0 ? I : _u, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const _z = /* @__PURE__ */ new Fs(), wT = /* @__PURE__ */ new vW(1, 1), zz = /* @__PURE__ */ new AW(), Kz = /* @__PURE__ */ new HX(), Lz = /* @__PURE__ */ new Dw(), RT = [], xT = [], WT = new Float32Array(16), VT = new Float32Array(9), NT = new Float32Array(4);
function IB(a, e, t) {
  const n = a[0];
  if (n <= 0 || n > 0) return a;
  const i = e * t;
  let o = RT[i];
  if (o === void 0 && (o = new Float32Array(i), RT[i] = o), e !== 0) {
    n.toArray(o, 0);
    for (let l = 1, u = 0; l !== e; ++l)
      u += t, a[l].toArray(o, u);
  }
  return o;
}
function lu(a, e) {
  if (a.length !== e.length) return !1;
  for (let t = 0, n = a.length; t < n; t++)
    if (a[t] !== e[t]) return !1;
  return !0;
}
function uu(a, e) {
  for (let t = 0, n = e.length; t < n; t++)
    a[t] = e[t];
}
function yW(a, e) {
  let t = xT[e];
  t === void 0 && (t = new Int32Array(e), xT[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = a.allocateTextureUnit();
  return t;
}
function B7(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1f(this.addr, e), t[0] = e);
}
function S7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (a.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (lu(t, e)) return;
    a.uniform2fv(this.addr, e), uu(t, e);
  }
}
function Z7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (a.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (lu(t, e)) return;
    a.uniform3fv(this.addr, e), uu(t, e);
  }
}
function w7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (lu(t, e)) return;
    a.uniform4fv(this.addr, e), uu(t, e);
  }
}
function R7(a, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (lu(t, e)) return;
    a.uniformMatrix2fv(this.addr, !1, e), uu(t, e);
  } else {
    if (lu(t, n)) return;
    NT.set(n), a.uniformMatrix2fv(this.addr, !1, NT), uu(t, n);
  }
}
function x7(a, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (lu(t, e)) return;
    a.uniformMatrix3fv(this.addr, !1, e), uu(t, e);
  } else {
    if (lu(t, n)) return;
    VT.set(n), a.uniformMatrix3fv(this.addr, !1, VT), uu(t, n);
  }
}
function W7(a, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (lu(t, e)) return;
    a.uniformMatrix4fv(this.addr, !1, e), uu(t, e);
  } else {
    if (lu(t, n)) return;
    WT.set(n), a.uniformMatrix4fv(this.addr, !1, WT), uu(t, n);
  }
}
function V7(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1i(this.addr, e), t[0] = e);
}
function N7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (a.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (lu(t, e)) return;
    a.uniform2iv(this.addr, e), uu(t, e);
  }
}
function M7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (lu(t, e)) return;
    a.uniform3iv(this.addr, e), uu(t, e);
  }
}
function H7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (lu(t, e)) return;
    a.uniform4iv(this.addr, e), uu(t, e);
  }
}
function X7(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1ui(this.addr, e), t[0] = e);
}
function Y7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (a.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (lu(t, e)) return;
    a.uniform2uiv(this.addr, e), uu(t, e);
  }
}
function F7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (lu(t, e)) return;
    a.uniform3uiv(this.addr, e), uu(t, e);
  }
}
function E7(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (lu(t, e)) return;
    a.uniform4uiv(this.addr, e), uu(t, e);
  }
}
function T7(a, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (a.uniform1i(this.addr, i), n[0] = i);
  let o;
  this.type === a.SAMPLER_2D_SHADOW ? (wT.compareFunction = NX, o = wT) : o = _z, t.setTexture2D(e || o, i);
}
function _7(a, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (a.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || Kz, i);
}
function z7(a, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (a.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || Lz, i);
}
function K7(a, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (a.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || zz, i);
}
function L7(a) {
  switch (a) {
    case 5126:
      return B7;
    case 35664:
      return S7;
    case 35665:
      return Z7;
    case 35666:
      return w7;
    case 35674:
      return R7;
    case 35675:
      return x7;
    case 35676:
      return W7;
    case 5124:
    case 35670:
      return V7;
    case 35667:
    case 35671:
      return N7;
    case 35668:
    case 35672:
      return M7;
    case 35669:
    case 35673:
      return H7;
    case 5125:
      return X7;
    case 36294:
      return Y7;
    case 36295:
      return F7;
    case 36296:
      return E7;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return T7;
    case 35679:
    case 36299:
    case 36307:
      return _7;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return z7;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return K7;
  }
}
function k7(a, e) {
  a.uniform1fv(this.addr, e);
}
function D7(a, e) {
  const t = IB(e, this.size, 2);
  a.uniform2fv(this.addr, t);
}
function U7(a, e) {
  const t = IB(e, this.size, 3);
  a.uniform3fv(this.addr, t);
}
function O7(a, e) {
  const t = IB(e, this.size, 4);
  a.uniform4fv(this.addr, t);
}
function P7(a, e) {
  const t = IB(e, this.size, 4);
  a.uniformMatrix2fv(this.addr, !1, t);
}
function J7(a, e) {
  const t = IB(e, this.size, 9);
  a.uniformMatrix3fv(this.addr, !1, t);
}
function Q7(a, e) {
  const t = IB(e, this.size, 16);
  a.uniformMatrix4fv(this.addr, !1, t);
}
function j7(a, e) {
  a.uniform1iv(this.addr, e);
}
function q7(a, e) {
  a.uniform2iv(this.addr, e);
}
function $7(a, e) {
  a.uniform3iv(this.addr, e);
}
function e8(a, e) {
  a.uniform4iv(this.addr, e);
}
function t8(a, e) {
  a.uniform1uiv(this.addr, e);
}
function n8(a, e) {
  a.uniform2uiv(this.addr, e);
}
function i8(a, e) {
  a.uniform3uiv(this.addr, e);
}
function r8(a, e) {
  a.uniform4uiv(this.addr, e);
}
function a8(a, e, t) {
  const n = this.cache, i = e.length, o = yW(t, i);
  lu(n, o) || (a.uniform1iv(this.addr, o), uu(n, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture2D(e[l] || _z, o[l]);
}
function o8(a, e, t) {
  const n = this.cache, i = e.length, o = yW(t, i);
  lu(n, o) || (a.uniform1iv(this.addr, o), uu(n, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture3D(e[l] || Kz, o[l]);
}
function s8(a, e, t) {
  const n = this.cache, i = e.length, o = yW(t, i);
  lu(n, o) || (a.uniform1iv(this.addr, o), uu(n, o));
  for (let l = 0; l !== i; ++l)
    t.setTextureCube(e[l] || Lz, o[l]);
}
function l8(a, e, t) {
  const n = this.cache, i = e.length, o = yW(t, i);
  lu(n, o) || (a.uniform1iv(this.addr, o), uu(n, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture2DArray(e[l] || zz, o[l]);
}
function u8(a) {
  switch (a) {
    case 5126:
      return k7;
    case 35664:
      return D7;
    case 35665:
      return U7;
    case 35666:
      return O7;
    case 35674:
      return P7;
    case 35675:
      return J7;
    case 35676:
      return Q7;
    case 5124:
    case 35670:
      return j7;
    case 35667:
    case 35671:
      return q7;
    case 35668:
    case 35672:
      return $7;
    case 35669:
    case 35673:
      return e8;
    case 5125:
      return t8;
    case 36294:
      return n8;
    case 36295:
      return i8;
    case 36296:
      return r8;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return a8;
    case 35679:
    case 36299:
    case 36307:
      return o8;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return s8;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return l8;
  }
}
class c8 {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = L7(t.type);
  }
}
class g8 {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = u8(t.type);
  }
}
class d8 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let o = 0, l = i.length; o !== l; ++o) {
      const u = i[o];
      u.setValue(e, t[u.id], n);
    }
  }
}
const vM = /(\w+)(\])?(\[|\.)?/g;
function MT(a, e) {
  a.seq.push(e), a.map[e.id] = e;
}
function I8(a, e, t) {
  const n = a.name, i = n.length;
  for (vM.lastIndex = 0; ; ) {
    const o = vM.exec(n), l = vM.lastIndex;
    let u = o[1];
    const I = o[2] === "]", f = o[3];
    if (I && (u = u | 0), f === void 0 || f === "[" && l + 2 === i) {
      MT(t, f === void 0 ? new c8(u, a, e) : new g8(u, a, e));
      break;
    } else {
      let v = t.map[u];
      v === void 0 && (v = new d8(u), MT(t, v)), t = v;
    }
  }
}
class Q1 {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const o = e.getActiveUniform(t, i), l = e.getUniformLocation(t, o.name);
      I8(o, l, this);
    }
  }
  setValue(e, t, n, i) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let o = 0, l = t.length; o !== l; ++o) {
      const u = t[o], I = n[u.id];
      I.needsUpdate !== !1 && u.setValue(e, I.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const l = e[i];
      l.id in t && n.push(l);
    }
    return n;
  }
}
function HT(a, e, t) {
  const n = a.createShader(e);
  return a.shaderSource(n, t), a.compileShader(n), n;
}
const C8 = 37297;
let h8 = 0;
function f8(a, e) {
  const t = a.split(`
`), n = [], i = Math.max(e - 6, 0), o = Math.min(e + 6, t.length);
  for (let l = i; l < o; l++) {
    const u = l + 1;
    n.push(`${u === e ? ">" : " "} ${u}: ${t[l]}`);
  }
  return n.join(`
`);
}
function p8(a) {
  const e = Ta.getPrimaries(Ta.workingColorSpace), t = Ta.getPrimaries(a);
  let n;
  switch (e === t ? n = "" : e === pw && t === fw ? n = "LinearDisplayP3ToLinearSRGB" : e === fw && t === pw && (n = "LinearSRGBToLinearDisplayP3"), a) {
    case Tm:
    case Lw:
      return [n, "LinearTransferOETF"];
    case HC:
    case mW:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", a), [n, "LinearTransferOETF"];
  }
}
function XT(a, e, t) {
  const n = a.getShaderParameter(e, a.COMPILE_STATUS), i = a.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const l = parseInt(o[1]);
    return t.toUpperCase() + `

` + i + `

` + f8(a.getShaderSource(e), l);
  } else
    return i;
}
function m8(a, e) {
  const t = p8(e);
  return `vec4 ${a}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function A8(a, e) {
  let t;
  switch (e) {
    case uz:
      t = "Linear";
      break;
    case cz:
      t = "Reinhard";
      break;
    case gz:
      t = "OptimizedCineon";
      break;
    case vX:
      t = "ACESFilmic";
      break;
    case Iz:
      t = "AgX";
      break;
    case Cz:
      t = "Neutral";
      break;
    case dz:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + a + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
const l1 = /* @__PURE__ */ new Ze();
function v8() {
  Ta.getLuminanceCoefficients(l1);
  const a = l1.x.toFixed(4), e = l1.y.toFixed(4), t = l1.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${a}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function y8(a) {
  return [
    a.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    a.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(_Z).join(`
`);
}
function b8(a) {
  const e = [];
  for (const t in a) {
    const n = a[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function G8(a, e) {
  const t = {}, n = a.getProgramParameter(e, a.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const o = a.getActiveAttrib(e, i), l = o.name;
    let u = 1;
    o.type === a.FLOAT_MAT2 && (u = 2), o.type === a.FLOAT_MAT3 && (u = 3), o.type === a.FLOAT_MAT4 && (u = 4), t[l] = {
      type: o.type,
      location: a.getAttribLocation(e, l),
      locationSize: u
    };
  }
  return t;
}
function _Z(a) {
  return a !== "";
}
function YT(a, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return a.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function FT(a, e) {
  return a.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const B8 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function xH(a) {
  return a.replace(B8, Z8);
}
const S8 = /* @__PURE__ */ new Map();
function Z8(a, e) {
  let t = Tr[e];
  if (t === void 0) {
    const n = S8.get(e);
    if (n !== void 0)
      t = Tr[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return xH(t);
}
const w8 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function ET(a) {
  return a.replace(w8, R8);
}
function R8(a, e, t, n) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function TT(a) {
  let e = `precision ${a.precision} float;
	precision ${a.precision} int;
	precision ${a.precision} sampler2D;
	precision ${a.precision} samplerCube;
	precision ${a.precision} sampler3D;
	precision ${a.precision} sampler2DArray;
	precision ${a.precision} sampler2DShadow;
	precision ${a.precision} samplerCubeShadow;
	precision ${a.precision} sampler2DArrayShadow;
	precision ${a.precision} isampler2D;
	precision ${a.precision} isampler3D;
	precision ${a.precision} isamplerCube;
	precision ${a.precision} isampler2DArray;
	precision ${a.precision} usampler2D;
	precision ${a.precision} usampler3D;
	precision ${a.precision} usamplerCube;
	precision ${a.precision} usampler2DArray;
	`;
  return a.precision === "highp" ? e += `
#define HIGH_PRECISION` : a.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : a.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function x8(a) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return a.shadowMapType === uW ? e = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === LZ ? e = "SHADOWMAP_TYPE_PCF_SOFT" : a.shadowMapType === Yh && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function W8(a) {
  let e = "ENVMAP_TYPE_CUBE";
  if (a.envMap)
    switch (a.envMapMode) {
      case Mm:
      case $A:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case gB:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function V8(a) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (a.envMap)
    switch (a.envMapMode) {
      case $A:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function N8(a) {
  let e = "ENVMAP_BLENDING_NONE";
  if (a.envMap)
    switch (a.combine) {
      case zw:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case sz:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case lz:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function M8(a) {
  const e = a.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function H8(a, e, t, n) {
  const i = a.getContext(), o = t.defines;
  let l = t.vertexShader, u = t.fragmentShader;
  const I = x8(t), f = W8(t), h = V8(t), v = N8(t), b = M8(t), S = y8(t), R = b8(o), W = i.createProgram();
  let x, M, T = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (x = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R
  ].filter(_Z).join(`
`), x.length > 0 && (x += `
`), M = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R
  ].filter(_Z).join(`
`), M.length > 0 && (M += `
`)) : (x = [
    TT(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + h : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + I : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(_Z).join(`
`), M = [
    TT(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + f : "",
    t.envMap ? "#define " + h : "",
    t.envMap ? "#define " + v : "",
    b ? "#define CUBEUV_TEXEL_WIDTH " + b.texelWidth : "",
    b ? "#define CUBEUV_TEXEL_HEIGHT " + b.texelHeight : "",
    b ? "#define CUBEUV_MAX_MIP " + b.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.dispersion ? "#define USE_DISPERSION" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + I : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== sp ? "#define TONE_MAPPING" : "",
    t.toneMapping !== sp ? Tr.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== sp ? A8("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Tr.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    m8("linearToOutputTexel", t.outputColorSpace),
    v8(),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(_Z).join(`
`)), l = xH(l), l = YT(l, t), l = FT(l, t), u = xH(u), u = YT(u, t), u = FT(u, t), l = ET(l), u = ET(u), t.isRawShaderMaterial !== !0 && (T = `#version 300 es
`, x = [
    S,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + x, M = [
    "#define varying in",
    t.glslVersion === wH ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === wH ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + M);
  const E = T + x + l, _ = T + M + u, P = HT(i, i.VERTEX_SHADER, E), U = HT(i, i.FRAGMENT_SHADER, _);
  i.attachShader(W, P), i.attachShader(W, U), t.index0AttributeName !== void 0 ? i.bindAttribLocation(W, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(W, 0, "position"), i.linkProgram(W);
  function q(te) {
    if (a.debug.checkShaderErrors) {
      const fe = i.getProgramInfoLog(W).trim(), pe = i.getShaderInfoLog(P).trim(), Ae = i.getShaderInfoLog(U).trim();
      let Te = !0, Ke = !0;
      if (i.getProgramParameter(W, i.LINK_STATUS) === !1)
        if (Te = !1, typeof a.debug.onShaderError == "function")
          a.debug.onShaderError(i, W, P, U);
        else {
          const je = XT(i, P, "vertex"), ee = XT(i, U, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(W, i.VALIDATE_STATUS) + `

Material Name: ` + te.name + `
Material Type: ` + te.type + `

Program Info Log: ` + fe + `
` + je + `
` + ee
          );
        }
      else fe !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", fe) : (pe === "" || Ae === "") && (Ke = !1);
      Ke && (te.diagnostics = {
        runnable: Te,
        programLog: fe,
        vertexShader: {
          log: pe,
          prefix: x
        },
        fragmentShader: {
          log: Ae,
          prefix: M
        }
      });
    }
    i.deleteShader(P), i.deleteShader(U), k = new Q1(i, W), O = G8(i, W);
  }
  let k;
  this.getUniforms = function() {
    return k === void 0 && q(this), k;
  };
  let O;
  this.getAttributes = function() {
    return O === void 0 && q(this), O;
  };
  let J = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return J === !1 && (J = i.getProgramParameter(W, C8)), J;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(W), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = h8++, this.cacheKey = e, this.usedTimes = 1, this.program = W, this.vertexShader = P, this.fragmentShader = U, this;
}
let X8 = 0;
class Y8 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), o = this._getShaderStage(n), l = this._getShaderCacheForMaterial(e);
    return l.has(i) === !1 && (l.add(i), i.usedTimes++), l.has(o) === !1 && (l.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new F8(e), t.set(e, n)), n;
  }
}
class F8 {
  constructor(e) {
    this.id = X8++, this.code = e, this.usedTimes = 0;
  }
}
function E8(a, e, t, n, i, o, l) {
  const u = new db(), I = new Y8(), f = /* @__PURE__ */ new Set(), h = [], v = i.logarithmicDepthBuffer, b = i.vertexTextures;
  let S = i.precision;
  const R = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function W(O) {
    return f.add(O), O === 0 ? "uv" : `uv${O}`;
  }
  function x(O, J, te, fe, pe) {
    const Ae = fe.fog, Te = pe.geometry, Ke = O.isMeshStandardMaterial ? fe.environment : null, je = (O.isMeshStandardMaterial ? t : e).get(O.envMap || Ke), ee = je && je.mapping === gB ? je.image.height : null, Ce = R[O.type];
    O.precision !== null && (S = i.getMaxPrecision(O.precision), S !== O.precision && console.warn("THREE.WebGLProgram.getParameters:", O.precision, "not supported, using", S, "instead."));
    const be = Te.morphAttributes.position || Te.morphAttributes.normal || Te.morphAttributes.color, le = be !== void 0 ? be.length : 0;
    let Ye = 0;
    Te.morphAttributes.position !== void 0 && (Ye = 1), Te.morphAttributes.normal !== void 0 && (Ye = 2), Te.morphAttributes.color !== void 0 && (Ye = 3);
    let $e, ke, ot, wt;
    if (Ce) {
      const Xi = Eh[Ce];
      $e = Xi.vertexShader, ke = Xi.fragmentShader;
    } else
      $e = O.vertexShader, ke = O.fragmentShader, I.update(O), ot = I.getVertexShaderID(O), wt = I.getFragmentShaderID(O);
    const St = a.getRenderTarget(), ln = pe.isInstancedMesh === !0, hn = pe.isBatchedMesh === !0, mn = !!O.map, Pn = !!O.matcap, he = !!je, Lt = !!O.aoMap, Wt = !!O.lightMap, tn = !!O.bumpMap, Gt = !!O.normalMap, Rn = !!O.displacementMap, nn = !!O.emissiveMap, Bn = !!O.metalnessMap, Se = !!O.roughnessMap, oe = O.anisotropy > 0, ct = O.clearcoat > 0, Ft = O.dispersion > 0, pt = O.iridescence > 0, zt = O.sheen > 0, Sn = O.transmission > 0, rn = oe && !!O.anisotropyMap, gn = ct && !!O.clearcoatMap, qn = ct && !!O.clearcoatNormalMap, qt = ct && !!O.clearcoatRoughnessMap, An = pt && !!O.iridescenceMap, Fe = pt && !!O.iridescenceThicknessMap, Ie = zt && !!O.sheenColorMap, at = zt && !!O.sheenRoughnessMap, ye = !!O.specularMap, Pe = !!O.specularColorMap, Ot = !!O.specularIntensityMap, Re = Sn && !!O.transmissionMap, lt = Sn && !!O.thicknessMap, _e = !!O.gradientMap, ht = !!O.alphaMap, Ht = O.alphaTest > 0, an = !!O.alphaHash, fi = !!O.extensions;
    let xi = sp;
    O.toneMapped && (St === null || St.isXRRenderTarget === !0) && (xi = a.toneMapping);
    const Ir = {
      shaderID: Ce,
      shaderType: O.type,
      shaderName: O.name,
      vertexShader: $e,
      fragmentShader: ke,
      defines: O.defines,
      customVertexShaderID: ot,
      customFragmentShaderID: wt,
      isRawShaderMaterial: O.isRawShaderMaterial === !0,
      glslVersion: O.glslVersion,
      precision: S,
      batching: hn,
      batchingColor: hn && pe._colorsTexture !== null,
      instancing: ln,
      instancingColor: ln && pe.instanceColor !== null,
      instancingMorph: ln && pe.morphTexture !== null,
      supportsVertexTextures: b,
      outputColorSpace: St === null ? a.outputColorSpace : St.isXRRenderTarget === !0 ? St.texture.colorSpace : Tm,
      alphaToCoverage: !!O.alphaToCoverage,
      map: mn,
      matcap: Pn,
      envMap: he,
      envMapMode: he && je.mapping,
      envMapCubeUVHeight: ee,
      aoMap: Lt,
      lightMap: Wt,
      bumpMap: tn,
      normalMap: Gt,
      displacementMap: b && Rn,
      emissiveMap: nn,
      normalMapObjectSpace: Gt && O.normalMapType === yz,
      normalMapTangentSpace: Gt && O.normalMapType === iv,
      metalnessMap: Bn,
      roughnessMap: Se,
      anisotropy: oe,
      anisotropyMap: rn,
      clearcoat: ct,
      clearcoatMap: gn,
      clearcoatNormalMap: qn,
      clearcoatRoughnessMap: qt,
      dispersion: Ft,
      iridescence: pt,
      iridescenceMap: An,
      iridescenceThicknessMap: Fe,
      sheen: zt,
      sheenColorMap: Ie,
      sheenRoughnessMap: at,
      specularMap: ye,
      specularColorMap: Pe,
      specularIntensityMap: Ot,
      transmission: Sn,
      transmissionMap: Re,
      thicknessMap: lt,
      gradientMap: _e,
      opaque: O.transparent === !1 && O.blending === ub && O.alphaToCoverage === !1,
      alphaMap: ht,
      alphaTest: Ht,
      alphaHash: an,
      combine: O.combine,
      //
      mapUv: mn && W(O.map.channel),
      aoMapUv: Lt && W(O.aoMap.channel),
      lightMapUv: Wt && W(O.lightMap.channel),
      bumpMapUv: tn && W(O.bumpMap.channel),
      normalMapUv: Gt && W(O.normalMap.channel),
      displacementMapUv: Rn && W(O.displacementMap.channel),
      emissiveMapUv: nn && W(O.emissiveMap.channel),
      metalnessMapUv: Bn && W(O.metalnessMap.channel),
      roughnessMapUv: Se && W(O.roughnessMap.channel),
      anisotropyMapUv: rn && W(O.anisotropyMap.channel),
      clearcoatMapUv: gn && W(O.clearcoatMap.channel),
      clearcoatNormalMapUv: qn && W(O.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: qt && W(O.clearcoatRoughnessMap.channel),
      iridescenceMapUv: An && W(O.iridescenceMap.channel),
      iridescenceThicknessMapUv: Fe && W(O.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ie && W(O.sheenColorMap.channel),
      sheenRoughnessMapUv: at && W(O.sheenRoughnessMap.channel),
      specularMapUv: ye && W(O.specularMap.channel),
      specularColorMapUv: Pe && W(O.specularColorMap.channel),
      specularIntensityMapUv: Ot && W(O.specularIntensityMap.channel),
      transmissionMapUv: Re && W(O.transmissionMap.channel),
      thicknessMapUv: lt && W(O.thicknessMap.channel),
      alphaMapUv: ht && W(O.alphaMap.channel),
      //
      vertexTangents: !!Te.attributes.tangent && (Gt || oe),
      vertexColors: O.vertexColors,
      vertexAlphas: O.vertexColors === !0 && !!Te.attributes.color && Te.attributes.color.itemSize === 4,
      pointsUvs: pe.isPoints === !0 && !!Te.attributes.uv && (mn || ht),
      fog: !!Ae,
      useFog: O.fog === !0,
      fogExp2: !!Ae && Ae.isFogExp2,
      flatShading: O.flatShading === !0,
      sizeAttenuation: O.sizeAttenuation === !0,
      logarithmicDepthBuffer: v,
      skinning: pe.isSkinnedMesh === !0,
      morphTargets: Te.morphAttributes.position !== void 0,
      morphNormals: Te.morphAttributes.normal !== void 0,
      morphColors: Te.morphAttributes.color !== void 0,
      morphTargetsCount: le,
      morphTextureStride: Ye,
      numDirLights: J.directional.length,
      numPointLights: J.point.length,
      numSpotLights: J.spot.length,
      numSpotLightMaps: J.spotLightMap.length,
      numRectAreaLights: J.rectArea.length,
      numHemiLights: J.hemi.length,
      numDirLightShadows: J.directionalShadowMap.length,
      numPointLightShadows: J.pointShadowMap.length,
      numSpotLightShadows: J.spotShadowMap.length,
      numSpotLightShadowsWithMaps: J.numSpotLightShadowsWithMaps,
      numLightProbes: J.numLightProbes,
      numClippingPlanes: l.numPlanes,
      numClipIntersection: l.numIntersection,
      dithering: O.dithering,
      shadowMapEnabled: a.shadowMap.enabled && te.length > 0,
      shadowMapType: a.shadowMap.type,
      toneMapping: xi,
      decodeVideoTexture: mn && O.map.isVideoTexture === !0 && Ta.getTransfer(O.map.colorSpace) === Po,
      premultipliedAlpha: O.premultipliedAlpha,
      doubleSided: O.side === ep,
      flipSided: O.side === Dg,
      useDepthPacking: O.depthPacking >= 0,
      depthPacking: O.depthPacking || 0,
      index0AttributeName: O.index0AttributeName,
      extensionClipCullDistance: fi && O.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (fi && O.extensions.multiDraw === !0 || hn) && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: O.customProgramCacheKey()
    };
    return Ir.vertexUv1s = f.has(1), Ir.vertexUv2s = f.has(2), Ir.vertexUv3s = f.has(3), f.clear(), Ir;
  }
  function M(O) {
    const J = [];
    if (O.shaderID ? J.push(O.shaderID) : (J.push(O.customVertexShaderID), J.push(O.customFragmentShaderID)), O.defines !== void 0)
      for (const te in O.defines)
        J.push(te), J.push(O.defines[te]);
    return O.isRawShaderMaterial === !1 && (T(J, O), E(J, O), J.push(a.outputColorSpace)), J.push(O.customProgramCacheKey), J.join();
  }
  function T(O, J) {
    O.push(J.precision), O.push(J.outputColorSpace), O.push(J.envMapMode), O.push(J.envMapCubeUVHeight), O.push(J.mapUv), O.push(J.alphaMapUv), O.push(J.lightMapUv), O.push(J.aoMapUv), O.push(J.bumpMapUv), O.push(J.normalMapUv), O.push(J.displacementMapUv), O.push(J.emissiveMapUv), O.push(J.metalnessMapUv), O.push(J.roughnessMapUv), O.push(J.anisotropyMapUv), O.push(J.clearcoatMapUv), O.push(J.clearcoatNormalMapUv), O.push(J.clearcoatRoughnessMapUv), O.push(J.iridescenceMapUv), O.push(J.iridescenceThicknessMapUv), O.push(J.sheenColorMapUv), O.push(J.sheenRoughnessMapUv), O.push(J.specularMapUv), O.push(J.specularColorMapUv), O.push(J.specularIntensityMapUv), O.push(J.transmissionMapUv), O.push(J.thicknessMapUv), O.push(J.combine), O.push(J.fogExp2), O.push(J.sizeAttenuation), O.push(J.morphTargetsCount), O.push(J.morphAttributeCount), O.push(J.numDirLights), O.push(J.numPointLights), O.push(J.numSpotLights), O.push(J.numSpotLightMaps), O.push(J.numHemiLights), O.push(J.numRectAreaLights), O.push(J.numDirLightShadows), O.push(J.numPointLightShadows), O.push(J.numSpotLightShadows), O.push(J.numSpotLightShadowsWithMaps), O.push(J.numLightProbes), O.push(J.shadowMapType), O.push(J.toneMapping), O.push(J.numClippingPlanes), O.push(J.numClipIntersection), O.push(J.depthPacking);
  }
  function E(O, J) {
    u.disableAll(), J.supportsVertexTextures && u.enable(0), J.instancing && u.enable(1), J.instancingColor && u.enable(2), J.instancingMorph && u.enable(3), J.matcap && u.enable(4), J.envMap && u.enable(5), J.normalMapObjectSpace && u.enable(6), J.normalMapTangentSpace && u.enable(7), J.clearcoat && u.enable(8), J.iridescence && u.enable(9), J.alphaTest && u.enable(10), J.vertexColors && u.enable(11), J.vertexAlphas && u.enable(12), J.vertexUv1s && u.enable(13), J.vertexUv2s && u.enable(14), J.vertexUv3s && u.enable(15), J.vertexTangents && u.enable(16), J.anisotropy && u.enable(17), J.alphaHash && u.enable(18), J.batching && u.enable(19), J.dispersion && u.enable(20), J.batchingColor && u.enable(21), O.push(u.mask), u.disableAll(), J.fog && u.enable(0), J.useFog && u.enable(1), J.flatShading && u.enable(2), J.logarithmicDepthBuffer && u.enable(3), J.skinning && u.enable(4), J.morphTargets && u.enable(5), J.morphNormals && u.enable(6), J.morphColors && u.enable(7), J.premultipliedAlpha && u.enable(8), J.shadowMapEnabled && u.enable(9), J.doubleSided && u.enable(10), J.flipSided && u.enable(11), J.useDepthPacking && u.enable(12), J.dithering && u.enable(13), J.transmission && u.enable(14), J.sheen && u.enable(15), J.opaque && u.enable(16), J.pointsUvs && u.enable(17), J.decodeVideoTexture && u.enable(18), J.alphaToCoverage && u.enable(19), O.push(u.mask);
  }
  function _(O) {
    const J = R[O.type];
    let te;
    if (J) {
      const fe = Eh[J];
      te = Yz.clone(fe.uniforms);
    } else
      te = O.uniforms;
    return te;
  }
  function P(O, J) {
    let te;
    for (let fe = 0, pe = h.length; fe < pe; fe++) {
      const Ae = h[fe];
      if (Ae.cacheKey === J) {
        te = Ae, ++te.usedTimes;
        break;
      }
    }
    return te === void 0 && (te = new H8(a, J, O, o), h.push(te)), te;
  }
  function U(O) {
    if (--O.usedTimes === 0) {
      const J = h.indexOf(O);
      h[J] = h[h.length - 1], h.pop(), O.destroy();
    }
  }
  function q(O) {
    I.remove(O);
  }
  function k() {
    I.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: M,
    getUniforms: _,
    acquireProgram: P,
    releaseProgram: U,
    releaseShaderCache: q,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: k
  };
}
function T8() {
  let a = /* @__PURE__ */ new WeakMap();
  function e(o) {
    let l = a.get(o);
    return l === void 0 && (l = {}, a.set(o, l)), l;
  }
  function t(o) {
    a.delete(o);
  }
  function n(o, l, u) {
    a.get(o)[l] = u;
  }
  function i() {
    a = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: i
  };
}
function _8(a, e) {
  return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.material.id !== e.material.id ? a.material.id - e.material.id : a.z !== e.z ? a.z - e.z : a.id - e.id;
}
function _T(a, e) {
  return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.z !== e.z ? e.z - a.z : a.id - e.id;
}
function zT() {
  const a = [];
  let e = 0;
  const t = [], n = [], i = [];
  function o() {
    e = 0, t.length = 0, n.length = 0, i.length = 0;
  }
  function l(v, b, S, R, W, x) {
    let M = a[e];
    return M === void 0 ? (M = {
      id: v.id,
      object: v,
      geometry: b,
      material: S,
      groupOrder: R,
      renderOrder: v.renderOrder,
      z: W,
      group: x
    }, a[e] = M) : (M.id = v.id, M.object = v, M.geometry = b, M.material = S, M.groupOrder = R, M.renderOrder = v.renderOrder, M.z = W, M.group = x), e++, M;
  }
  function u(v, b, S, R, W, x) {
    const M = l(v, b, S, R, W, x);
    S.transmission > 0 ? n.push(M) : S.transparent === !0 ? i.push(M) : t.push(M);
  }
  function I(v, b, S, R, W, x) {
    const M = l(v, b, S, R, W, x);
    S.transmission > 0 ? n.unshift(M) : S.transparent === !0 ? i.unshift(M) : t.unshift(M);
  }
  function f(v, b) {
    t.length > 1 && t.sort(v || _8), n.length > 1 && n.sort(b || _T), i.length > 1 && i.sort(b || _T);
  }
  function h() {
    for (let v = e, b = a.length; v < b; v++) {
      const S = a[v];
      if (S.id === null) break;
      S.id = null, S.object = null, S.geometry = null, S.material = null, S.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: o,
    push: u,
    unshift: I,
    finish: h,
    sort: f
  };
}
function z8() {
  let a = /* @__PURE__ */ new WeakMap();
  function e(n, i) {
    const o = a.get(n);
    let l;
    return o === void 0 ? (l = new zT(), a.set(n, [l])) : i >= o.length ? (l = new zT(), o.push(l)) : l = o[i], l;
  }
  function t() {
    a = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function K8() {
  const a = {};
  return {
    get: function(e) {
      if (a[e.id] !== void 0)
        return a[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new Ze(),
            color: new hi()
          };
          break;
        case "SpotLight":
          t = {
            position: new Ze(),
            direction: new Ze(),
            color: new hi(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new Ze(),
            color: new hi(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new Ze(),
            skyColor: new hi(),
            groundColor: new hi()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new hi(),
            position: new Ze(),
            halfWidth: new Ze(),
            halfHeight: new Ze()
          };
          break;
      }
      return a[e.id] = t, t;
    }
  };
}
function L8() {
  const a = {};
  return {
    get: function(e) {
      if (a[e.id] !== void 0)
        return a[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new sn()
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new sn()
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new sn(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return a[e.id] = t, t;
    }
  };
}
let k8 = 0;
function D8(a, e) {
  return (e.castShadow ? 2 : 0) - (a.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (a.map ? 1 : 0);
}
function U8(a) {
  const e = new K8(), t = L8(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let f = 0; f < 9; f++) n.probe.push(new Ze());
  const i = new Ze(), o = new tr(), l = new tr();
  function u(f) {
    let h = 0, v = 0, b = 0;
    for (let O = 0; O < 9; O++) n.probe[O].set(0, 0, 0);
    let S = 0, R = 0, W = 0, x = 0, M = 0, T = 0, E = 0, _ = 0, P = 0, U = 0, q = 0;
    f.sort(D8);
    for (let O = 0, J = f.length; O < J; O++) {
      const te = f[O], fe = te.color, pe = te.intensity, Ae = te.distance, Te = te.shadow && te.shadow.map ? te.shadow.map.texture : null;
      if (te.isAmbientLight)
        h += fe.r * pe, v += fe.g * pe, b += fe.b * pe;
      else if (te.isLightProbe) {
        for (let Ke = 0; Ke < 9; Ke++)
          n.probe[Ke].addScaledVector(te.sh.coefficients[Ke], pe);
        q++;
      } else if (te.isDirectionalLight) {
        const Ke = e.get(te);
        if (Ke.color.copy(te.color).multiplyScalar(te.intensity), te.castShadow) {
          const je = te.shadow, ee = t.get(te);
          ee.shadowIntensity = je.intensity, ee.shadowBias = je.bias, ee.shadowNormalBias = je.normalBias, ee.shadowRadius = je.radius, ee.shadowMapSize = je.mapSize, n.directionalShadow[S] = ee, n.directionalShadowMap[S] = Te, n.directionalShadowMatrix[S] = te.shadow.matrix, T++;
        }
        n.directional[S] = Ke, S++;
      } else if (te.isSpotLight) {
        const Ke = e.get(te);
        Ke.position.setFromMatrixPosition(te.matrixWorld), Ke.color.copy(fe).multiplyScalar(pe), Ke.distance = Ae, Ke.coneCos = Math.cos(te.angle), Ke.penumbraCos = Math.cos(te.angle * (1 - te.penumbra)), Ke.decay = te.decay, n.spot[W] = Ke;
        const je = te.shadow;
        if (te.map && (n.spotLightMap[P] = te.map, P++, je.updateMatrices(te), te.castShadow && U++), n.spotLightMatrix[W] = je.matrix, te.castShadow) {
          const ee = t.get(te);
          ee.shadowIntensity = je.intensity, ee.shadowBias = je.bias, ee.shadowNormalBias = je.normalBias, ee.shadowRadius = je.radius, ee.shadowMapSize = je.mapSize, n.spotShadow[W] = ee, n.spotShadowMap[W] = Te, _++;
        }
        W++;
      } else if (te.isRectAreaLight) {
        const Ke = e.get(te);
        Ke.color.copy(fe).multiplyScalar(pe), Ke.halfWidth.set(te.width * 0.5, 0, 0), Ke.halfHeight.set(0, te.height * 0.5, 0), n.rectArea[x] = Ke, x++;
      } else if (te.isPointLight) {
        const Ke = e.get(te);
        if (Ke.color.copy(te.color).multiplyScalar(te.intensity), Ke.distance = te.distance, Ke.decay = te.decay, te.castShadow) {
          const je = te.shadow, ee = t.get(te);
          ee.shadowIntensity = je.intensity, ee.shadowBias = je.bias, ee.shadowNormalBias = je.normalBias, ee.shadowRadius = je.radius, ee.shadowMapSize = je.mapSize, ee.shadowCameraNear = je.camera.near, ee.shadowCameraFar = je.camera.far, n.pointShadow[R] = ee, n.pointShadowMap[R] = Te, n.pointShadowMatrix[R] = te.shadow.matrix, E++;
        }
        n.point[R] = Ke, R++;
      } else if (te.isHemisphereLight) {
        const Ke = e.get(te);
        Ke.skyColor.copy(te.color).multiplyScalar(pe), Ke.groundColor.copy(te.groundColor).multiplyScalar(pe), n.hemi[M] = Ke, M++;
      }
    }
    x > 0 && (a.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = ai.LTC_FLOAT_1, n.rectAreaLTC2 = ai.LTC_FLOAT_2) : (n.rectAreaLTC1 = ai.LTC_HALF_1, n.rectAreaLTC2 = ai.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = v, n.ambient[2] = b;
    const k = n.hash;
    (k.directionalLength !== S || k.pointLength !== R || k.spotLength !== W || k.rectAreaLength !== x || k.hemiLength !== M || k.numDirectionalShadows !== T || k.numPointShadows !== E || k.numSpotShadows !== _ || k.numSpotMaps !== P || k.numLightProbes !== q) && (n.directional.length = S, n.spot.length = W, n.rectArea.length = x, n.point.length = R, n.hemi.length = M, n.directionalShadow.length = T, n.directionalShadowMap.length = T, n.pointShadow.length = E, n.pointShadowMap.length = E, n.spotShadow.length = _, n.spotShadowMap.length = _, n.directionalShadowMatrix.length = T, n.pointShadowMatrix.length = E, n.spotLightMatrix.length = _ + P - U, n.spotLightMap.length = P, n.numSpotLightShadowsWithMaps = U, n.numLightProbes = q, k.directionalLength = S, k.pointLength = R, k.spotLength = W, k.rectAreaLength = x, k.hemiLength = M, k.numDirectionalShadows = T, k.numPointShadows = E, k.numSpotShadows = _, k.numSpotMaps = P, k.numLightProbes = q, n.version = k8++);
  }
  function I(f, h) {
    let v = 0, b = 0, S = 0, R = 0, W = 0;
    const x = h.matrixWorldInverse;
    for (let M = 0, T = f.length; M < T; M++) {
      const E = f[M];
      if (E.isDirectionalLight) {
        const _ = n.directional[v];
        _.direction.setFromMatrixPosition(E.matrixWorld), i.setFromMatrixPosition(E.target.matrixWorld), _.direction.sub(i), _.direction.transformDirection(x), v++;
      } else if (E.isSpotLight) {
        const _ = n.spot[S];
        _.position.setFromMatrixPosition(E.matrixWorld), _.position.applyMatrix4(x), _.direction.setFromMatrixPosition(E.matrixWorld), i.setFromMatrixPosition(E.target.matrixWorld), _.direction.sub(i), _.direction.transformDirection(x), S++;
      } else if (E.isRectAreaLight) {
        const _ = n.rectArea[R];
        _.position.setFromMatrixPosition(E.matrixWorld), _.position.applyMatrix4(x), l.identity(), o.copy(E.matrixWorld), o.premultiply(x), l.extractRotation(o), _.halfWidth.set(E.width * 0.5, 0, 0), _.halfHeight.set(0, E.height * 0.5, 0), _.halfWidth.applyMatrix4(l), _.halfHeight.applyMatrix4(l), R++;
      } else if (E.isPointLight) {
        const _ = n.point[b];
        _.position.setFromMatrixPosition(E.matrixWorld), _.position.applyMatrix4(x), b++;
      } else if (E.isHemisphereLight) {
        const _ = n.hemi[W];
        _.direction.setFromMatrixPosition(E.matrixWorld), _.direction.transformDirection(x), W++;
      }
    }
  }
  return {
    setup: u,
    setupView: I,
    state: n
  };
}
function KT(a) {
  const e = new U8(a), t = [], n = [];
  function i(h) {
    f.camera = h, t.length = 0, n.length = 0;
  }
  function o(h) {
    t.push(h);
  }
  function l(h) {
    n.push(h);
  }
  function u() {
    e.setup(t);
  }
  function I(h) {
    e.setupView(t, h);
  }
  const f = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: i,
    state: f,
    setupLights: u,
    setupLightsView: I,
    pushLight: o,
    pushShadow: l
  };
}
function O8(a) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(i, o = 0) {
    const l = e.get(i);
    let u;
    return l === void 0 ? (u = new KT(a), e.set(i, [u])) : o >= l.length ? (u = new KT(a), l.push(u)) : u = l[o], u;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: n
  };
}
class EX extends Gc {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Az, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class TX extends Gc {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const P8 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, J8 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Q8(a, e, t) {
  let n = new Uw();
  const i = new sn(), o = new sn(), l = new ro(), u = new EX({ depthPacking: vz }), I = new TX(), f = {}, h = t.maxTextureSize, v = { [Nm]: Dg, [Dg]: Nm, [ep]: ep }, b = new zh({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new sn() },
      radius: { value: 4 }
    },
    vertexShader: P8,
    fragmentShader: J8
  }), S = b.clone();
  S.defines.HORIZONTAL_PASS = 1;
  const R = new _r();
  R.setAttribute(
    "position",
    new Zo(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const W = new Fl(R, b), x = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = uW;
  let M = this.type;
  this.render = function(U, q, k) {
    if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || U.length === 0) return;
    const O = a.getRenderTarget(), J = a.getActiveCubeFace(), te = a.getActiveMipmapLevel(), fe = a.state;
    fe.setBlending(Vm), fe.buffers.color.setClear(1, 1, 1, 1), fe.buffers.depth.setTest(!0), fe.setScissorTest(!1);
    const pe = M !== Yh && this.type === Yh, Ae = M === Yh && this.type !== Yh;
    for (let Te = 0, Ke = U.length; Te < Ke; Te++) {
      const je = U[Te], ee = je.shadow;
      if (ee === void 0) {
        console.warn("THREE.WebGLShadowMap:", je, "has no shadow.");
        continue;
      }
      if (ee.autoUpdate === !1 && ee.needsUpdate === !1) continue;
      i.copy(ee.mapSize);
      const Ce = ee.getFrameExtents();
      if (i.multiply(Ce), o.copy(ee.mapSize), (i.x > h || i.y > h) && (i.x > h && (o.x = Math.floor(h / Ce.x), i.x = o.x * Ce.x, ee.mapSize.x = o.x), i.y > h && (o.y = Math.floor(h / Ce.y), i.y = o.y * Ce.y, ee.mapSize.y = o.y)), ee.map === null || pe === !0 || Ae === !0) {
        const le = this.type !== Yh ? { minFilter: _u, magFilter: _u } : {};
        ee.map !== null && ee.map.dispose(), ee.map = new EC(i.x, i.y, le), ee.map.texture.name = je.name + ".shadowMap", ee.camera.updateProjectionMatrix();
      }
      a.setRenderTarget(ee.map), a.clear();
      const be = ee.getViewportCount();
      for (let le = 0; le < be; le++) {
        const Ye = ee.getViewport(le);
        l.set(
          o.x * Ye.x,
          o.y * Ye.y,
          o.x * Ye.z,
          o.y * Ye.w
        ), fe.viewport(l), ee.updateMatrices(je, le), n = ee.getFrustum(), _(q, k, ee.camera, je, this.type);
      }
      ee.isPointLightShadow !== !0 && this.type === Yh && T(ee, k), ee.needsUpdate = !1;
    }
    M = this.type, x.needsUpdate = !1, a.setRenderTarget(O, J, te);
  };
  function T(U, q) {
    const k = e.update(W);
    b.defines.VSM_SAMPLES !== U.blurSamples && (b.defines.VSM_SAMPLES = U.blurSamples, S.defines.VSM_SAMPLES = U.blurSamples, b.needsUpdate = !0, S.needsUpdate = !0), U.mapPass === null && (U.mapPass = new EC(i.x, i.y)), b.uniforms.shadow_pass.value = U.map.texture, b.uniforms.resolution.value = U.mapSize, b.uniforms.radius.value = U.radius, a.setRenderTarget(U.mapPass), a.clear(), a.renderBufferDirect(q, null, k, b, W, null), S.uniforms.shadow_pass.value = U.mapPass.texture, S.uniforms.resolution.value = U.mapSize, S.uniforms.radius.value = U.radius, a.setRenderTarget(U.map), a.clear(), a.renderBufferDirect(q, null, k, S, W, null);
  }
  function E(U, q, k, O) {
    let J = null;
    const te = k.isPointLight === !0 ? U.customDistanceMaterial : U.customDepthMaterial;
    if (te !== void 0)
      J = te;
    else if (J = k.isPointLight === !0 ? I : u, a.localClippingEnabled && q.clipShadows === !0 && Array.isArray(q.clippingPlanes) && q.clippingPlanes.length !== 0 || q.displacementMap && q.displacementScale !== 0 || q.alphaMap && q.alphaTest > 0 || q.map && q.alphaTest > 0) {
      const fe = J.uuid, pe = q.uuid;
      let Ae = f[fe];
      Ae === void 0 && (Ae = {}, f[fe] = Ae);
      let Te = Ae[pe];
      Te === void 0 && (Te = J.clone(), Ae[pe] = Te, q.addEventListener("dispose", P)), J = Te;
    }
    if (J.visible = q.visible, J.wireframe = q.wireframe, O === Yh ? J.side = q.shadowSide !== null ? q.shadowSide : q.side : J.side = q.shadowSide !== null ? q.shadowSide : v[q.side], J.alphaMap = q.alphaMap, J.alphaTest = q.alphaTest, J.map = q.map, J.clipShadows = q.clipShadows, J.clippingPlanes = q.clippingPlanes, J.clipIntersection = q.clipIntersection, J.displacementMap = q.displacementMap, J.displacementScale = q.displacementScale, J.displacementBias = q.displacementBias, J.wireframeLinewidth = q.wireframeLinewidth, J.linewidth = q.linewidth, k.isPointLight === !0 && J.isMeshDistanceMaterial === !0) {
      const fe = a.properties.get(J);
      fe.light = k;
    }
    return J;
  }
  function _(U, q, k, O, J) {
    if (U.visible === !1) return;
    if (U.layers.test(q.layers) && (U.isMesh || U.isLine || U.isPoints) && (U.castShadow || U.receiveShadow && J === Yh) && (!U.frustumCulled || n.intersectsObject(U))) {
      U.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, U.matrixWorld);
      const pe = e.update(U), Ae = U.material;
      if (Array.isArray(Ae)) {
        const Te = pe.groups;
        for (let Ke = 0, je = Te.length; Ke < je; Ke++) {
          const ee = Te[Ke], Ce = Ae[ee.materialIndex];
          if (Ce && Ce.visible) {
            const be = E(U, Ce, O, J);
            U.onBeforeShadow(a, U, q, k, pe, be, ee), a.renderBufferDirect(k, null, pe, be, U, ee), U.onAfterShadow(a, U, q, k, pe, be, ee);
          }
        }
      } else if (Ae.visible) {
        const Te = E(U, Ae, O, J);
        U.onBeforeShadow(a, U, q, k, pe, Te, null), a.renderBufferDirect(k, null, pe, Te, U, null), U.onAfterShadow(a, U, q, k, pe, Te, null);
      }
    }
    const fe = U.children;
    for (let pe = 0, Ae = fe.length; pe < Ae; pe++)
      _(fe[pe], q, k, O, J);
  }
  function P(U) {
    U.target.removeEventListener("dispose", P);
    for (const k in f) {
      const O = f[k], J = U.target.uuid;
      J in O && (O[J].dispose(), delete O[J]);
    }
  }
}
function j8(a) {
  function e() {
    let Re = !1;
    const lt = new ro();
    let _e = null;
    const ht = new ro(0, 0, 0, 0);
    return {
      setMask: function(Ht) {
        _e !== Ht && !Re && (a.colorMask(Ht, Ht, Ht, Ht), _e = Ht);
      },
      setLocked: function(Ht) {
        Re = Ht;
      },
      setClear: function(Ht, an, fi, xi, Ir) {
        Ir === !0 && (Ht *= xi, an *= xi, fi *= xi), lt.set(Ht, an, fi, xi), ht.equals(lt) === !1 && (a.clearColor(Ht, an, fi, xi), ht.copy(lt));
      },
      reset: function() {
        Re = !1, _e = null, ht.set(-1, 0, 0, 0);
      }
    };
  }
  function t() {
    let Re = !1, lt = null, _e = null, ht = null;
    return {
      setTest: function(Ht) {
        Ht ? wt(a.DEPTH_TEST) : St(a.DEPTH_TEST);
      },
      setMask: function(Ht) {
        lt !== Ht && !Re && (a.depthMask(Ht), lt = Ht);
      },
      setFunc: function(Ht) {
        if (_e !== Ht) {
          switch (Ht) {
            case ez:
              a.depthFunc(a.NEVER);
              break;
            case tz:
              a.depthFunc(a.ALWAYS);
              break;
            case nz:
              a.depthFunc(a.LESS);
              break;
            case lw:
              a.depthFunc(a.LEQUAL);
              break;
            case iz:
              a.depthFunc(a.EQUAL);
              break;
            case rz:
              a.depthFunc(a.GEQUAL);
              break;
            case az:
              a.depthFunc(a.GREATER);
              break;
            case oz:
              a.depthFunc(a.NOTEQUAL);
              break;
            default:
              a.depthFunc(a.LEQUAL);
          }
          _e = Ht;
        }
      },
      setLocked: function(Ht) {
        Re = Ht;
      },
      setClear: function(Ht) {
        ht !== Ht && (a.clearDepth(Ht), ht = Ht);
      },
      reset: function() {
        Re = !1, lt = null, _e = null, ht = null;
      }
    };
  }
  function n() {
    let Re = !1, lt = null, _e = null, ht = null, Ht = null, an = null, fi = null, xi = null, Ir = null;
    return {
      setTest: function(Xi) {
        Re || (Xi ? wt(a.STENCIL_TEST) : St(a.STENCIL_TEST));
      },
      setMask: function(Xi) {
        lt !== Xi && !Re && (a.stencilMask(Xi), lt = Xi);
      },
      setFunc: function(Xi, pi, Cr) {
        (_e !== Xi || ht !== pi || Ht !== Cr) && (a.stencilFunc(Xi, pi, Cr), _e = Xi, ht = pi, Ht = Cr);
      },
      setOp: function(Xi, pi, Cr) {
        (an !== Xi || fi !== pi || xi !== Cr) && (a.stencilOp(Xi, pi, Cr), an = Xi, fi = pi, xi = Cr);
      },
      setLocked: function(Xi) {
        Re = Xi;
      },
      setClear: function(Xi) {
        Ir !== Xi && (a.clearStencil(Xi), Ir = Xi);
      },
      reset: function() {
        Re = !1, lt = null, _e = null, ht = null, Ht = null, an = null, fi = null, xi = null, Ir = null;
      }
    };
  }
  const i = new e(), o = new t(), l = new n(), u = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap();
  let f = {}, h = {}, v = /* @__PURE__ */ new WeakMap(), b = [], S = null, R = !1, W = null, x = null, M = null, T = null, E = null, _ = null, P = null, U = new hi(0, 0, 0), q = 0, k = !1, O = null, J = null, te = null, fe = null, pe = null;
  const Ae = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Te = !1, Ke = 0;
  const je = a.getParameter(a.VERSION);
  je.indexOf("WebGL") !== -1 ? (Ke = parseFloat(/^WebGL (\d)/.exec(je)[1]), Te = Ke >= 1) : je.indexOf("OpenGL ES") !== -1 && (Ke = parseFloat(/^OpenGL ES (\d)/.exec(je)[1]), Te = Ke >= 2);
  let ee = null, Ce = {};
  const be = a.getParameter(a.SCISSOR_BOX), le = a.getParameter(a.VIEWPORT), Ye = new ro().fromArray(be), $e = new ro().fromArray(le);
  function ke(Re, lt, _e, ht) {
    const Ht = new Uint8Array(4), an = a.createTexture();
    a.bindTexture(Re, an), a.texParameteri(Re, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(Re, a.TEXTURE_MAG_FILTER, a.NEAREST);
    for (let fi = 0; fi < _e; fi++)
      Re === a.TEXTURE_3D || Re === a.TEXTURE_2D_ARRAY ? a.texImage3D(lt, 0, a.RGBA, 1, 1, ht, 0, a.RGBA, a.UNSIGNED_BYTE, Ht) : a.texImage2D(lt + fi, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, Ht);
    return an;
  }
  const ot = {};
  ot[a.TEXTURE_2D] = ke(a.TEXTURE_2D, a.TEXTURE_2D, 1), ot[a.TEXTURE_CUBE_MAP] = ke(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ot[a.TEXTURE_2D_ARRAY] = ke(a.TEXTURE_2D_ARRAY, a.TEXTURE_2D_ARRAY, 1, 1), ot[a.TEXTURE_3D] = ke(a.TEXTURE_3D, a.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), o.setClear(1), l.setClear(0), wt(a.DEPTH_TEST), o.setFunc(lw), tn(!1), Gt(yH), wt(a.CULL_FACE), Lt(Vm);
  function wt(Re) {
    f[Re] !== !0 && (a.enable(Re), f[Re] = !0);
  }
  function St(Re) {
    f[Re] !== !1 && (a.disable(Re), f[Re] = !1);
  }
  function ln(Re, lt) {
    return h[Re] !== lt ? (a.bindFramebuffer(Re, lt), h[Re] = lt, Re === a.DRAW_FRAMEBUFFER && (h[a.FRAMEBUFFER] = lt), Re === a.FRAMEBUFFER && (h[a.DRAW_FRAMEBUFFER] = lt), !0) : !1;
  }
  function hn(Re, lt) {
    let _e = b, ht = !1;
    if (Re) {
      _e = v.get(lt), _e === void 0 && (_e = [], v.set(lt, _e));
      const Ht = Re.textures;
      if (_e.length !== Ht.length || _e[0] !== a.COLOR_ATTACHMENT0) {
        for (let an = 0, fi = Ht.length; an < fi; an++)
          _e[an] = a.COLOR_ATTACHMENT0 + an;
        _e.length = Ht.length, ht = !0;
      }
    } else
      _e[0] !== a.BACK && (_e[0] = a.BACK, ht = !0);
    ht && a.drawBuffers(_e);
  }
  function mn(Re) {
    return S !== Re ? (a.useProgram(Re), S = Re, !0) : !1;
  }
  const Pn = {
    [kA]: a.FUNC_ADD,
    [F5]: a.FUNC_SUBTRACT,
    [E5]: a.FUNC_REVERSE_SUBTRACT
  };
  Pn[T5] = a.MIN, Pn[_5] = a.MAX;
  const he = {
    [z5]: a.ZERO,
    [K5]: a.ONE,
    [L5]: a.SRC_COLOR,
    [s2]: a.SRC_ALPHA,
    [J5]: a.SRC_ALPHA_SATURATE,
    [O5]: a.DST_COLOR,
    [D5]: a.DST_ALPHA,
    [k5]: a.ONE_MINUS_SRC_COLOR,
    [l2]: a.ONE_MINUS_SRC_ALPHA,
    [P5]: a.ONE_MINUS_DST_COLOR,
    [U5]: a.ONE_MINUS_DST_ALPHA,
    [Q5]: a.CONSTANT_COLOR,
    [j5]: a.ONE_MINUS_CONSTANT_COLOR,
    [q5]: a.CONSTANT_ALPHA,
    [$5]: a.ONE_MINUS_CONSTANT_ALPHA
  };
  function Lt(Re, lt, _e, ht, Ht, an, fi, xi, Ir, Xi) {
    if (Re === Vm) {
      R === !0 && (St(a.BLEND), R = !1);
      return;
    }
    if (R === !1 && (wt(a.BLEND), R = !0), Re !== Y5) {
      if (Re !== W || Xi !== k) {
        if ((x !== kA || E !== kA) && (a.blendEquation(a.FUNC_ADD), x = kA, E = kA), Xi)
          switch (Re) {
            case ub:
              a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA);
              break;
            case bH:
              a.blendFunc(a.ONE, a.ONE);
              break;
            case GH:
              a.blendFuncSeparate(a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ZERO, a.ONE);
              break;
            case BH:
              a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Re);
              break;
          }
        else
          switch (Re) {
            case ub:
              a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA);
              break;
            case bH:
              a.blendFunc(a.SRC_ALPHA, a.ONE);
              break;
            case GH:
              a.blendFuncSeparate(a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ZERO, a.ONE);
              break;
            case BH:
              a.blendFunc(a.ZERO, a.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Re);
              break;
          }
        M = null, T = null, _ = null, P = null, U.set(0, 0, 0), q = 0, W = Re, k = Xi;
      }
      return;
    }
    Ht = Ht || lt, an = an || _e, fi = fi || ht, (lt !== x || Ht !== E) && (a.blendEquationSeparate(Pn[lt], Pn[Ht]), x = lt, E = Ht), (_e !== M || ht !== T || an !== _ || fi !== P) && (a.blendFuncSeparate(he[_e], he[ht], he[an], he[fi]), M = _e, T = ht, _ = an, P = fi), (xi.equals(U) === !1 || Ir !== q) && (a.blendColor(xi.r, xi.g, xi.b, Ir), U.copy(xi), q = Ir), W = Re, k = !1;
  }
  function Wt(Re, lt) {
    Re.side === ep ? St(a.CULL_FACE) : wt(a.CULL_FACE);
    let _e = Re.side === Dg;
    lt && (_e = !_e), tn(_e), Re.blending === ub && Re.transparent === !1 ? Lt(Vm) : Lt(Re.blending, Re.blendEquation, Re.blendSrc, Re.blendDst, Re.blendEquationAlpha, Re.blendSrcAlpha, Re.blendDstAlpha, Re.blendColor, Re.blendAlpha, Re.premultipliedAlpha), o.setFunc(Re.depthFunc), o.setTest(Re.depthTest), o.setMask(Re.depthWrite), i.setMask(Re.colorWrite);
    const ht = Re.stencilWrite;
    l.setTest(ht), ht && (l.setMask(Re.stencilWriteMask), l.setFunc(Re.stencilFunc, Re.stencilRef, Re.stencilFuncMask), l.setOp(Re.stencilFail, Re.stencilZFail, Re.stencilZPass)), nn(Re.polygonOffset, Re.polygonOffsetFactor, Re.polygonOffsetUnits), Re.alphaToCoverage === !0 ? wt(a.SAMPLE_ALPHA_TO_COVERAGE) : St(a.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function tn(Re) {
    O !== Re && (Re ? a.frontFace(a.CW) : a.frontFace(a.CCW), O = Re);
  }
  function Gt(Re) {
    Re !== M5 ? (wt(a.CULL_FACE), Re !== J && (Re === yH ? a.cullFace(a.BACK) : Re === H5 ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : St(a.CULL_FACE), J = Re;
  }
  function Rn(Re) {
    Re !== te && (Te && a.lineWidth(Re), te = Re);
  }
  function nn(Re, lt, _e) {
    Re ? (wt(a.POLYGON_OFFSET_FILL), (fe !== lt || pe !== _e) && (a.polygonOffset(lt, _e), fe = lt, pe = _e)) : St(a.POLYGON_OFFSET_FILL);
  }
  function Bn(Re) {
    Re ? wt(a.SCISSOR_TEST) : St(a.SCISSOR_TEST);
  }
  function Se(Re) {
    Re === void 0 && (Re = a.TEXTURE0 + Ae - 1), ee !== Re && (a.activeTexture(Re), ee = Re);
  }
  function oe(Re, lt, _e) {
    _e === void 0 && (ee === null ? _e = a.TEXTURE0 + Ae - 1 : _e = ee);
    let ht = Ce[_e];
    ht === void 0 && (ht = { type: void 0, texture: void 0 }, Ce[_e] = ht), (ht.type !== Re || ht.texture !== lt) && (ee !== _e && (a.activeTexture(_e), ee = _e), a.bindTexture(Re, lt || ot[Re]), ht.type = Re, ht.texture = lt);
  }
  function ct() {
    const Re = Ce[ee];
    Re !== void 0 && Re.type !== void 0 && (a.bindTexture(Re.type, null), Re.type = void 0, Re.texture = void 0);
  }
  function Ft() {
    try {
      a.compressedTexImage2D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function pt() {
    try {
      a.compressedTexImage3D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function zt() {
    try {
      a.texSubImage2D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function Sn() {
    try {
      a.texSubImage3D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function rn() {
    try {
      a.compressedTexSubImage2D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function gn() {
    try {
      a.compressedTexSubImage3D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function qn() {
    try {
      a.texStorage2D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function qt() {
    try {
      a.texStorage3D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function An() {
    try {
      a.texImage2D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function Fe() {
    try {
      a.texImage3D.apply(a, arguments);
    } catch (Re) {
      console.error("THREE.WebGLState:", Re);
    }
  }
  function Ie(Re) {
    Ye.equals(Re) === !1 && (a.scissor(Re.x, Re.y, Re.z, Re.w), Ye.copy(Re));
  }
  function at(Re) {
    $e.equals(Re) === !1 && (a.viewport(Re.x, Re.y, Re.z, Re.w), $e.copy(Re));
  }
  function ye(Re, lt) {
    let _e = I.get(lt);
    _e === void 0 && (_e = /* @__PURE__ */ new WeakMap(), I.set(lt, _e));
    let ht = _e.get(Re);
    ht === void 0 && (ht = a.getUniformBlockIndex(lt, Re.name), _e.set(Re, ht));
  }
  function Pe(Re, lt) {
    const ht = I.get(lt).get(Re);
    u.get(lt) !== ht && (a.uniformBlockBinding(lt, ht, Re.__bindingPointIndex), u.set(lt, ht));
  }
  function Ot() {
    a.disable(a.BLEND), a.disable(a.CULL_FACE), a.disable(a.DEPTH_TEST), a.disable(a.POLYGON_OFFSET_FILL), a.disable(a.SCISSOR_TEST), a.disable(a.STENCIL_TEST), a.disable(a.SAMPLE_ALPHA_TO_COVERAGE), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ONE, a.ZERO), a.blendFuncSeparate(a.ONE, a.ZERO, a.ONE, a.ZERO), a.blendColor(0, 0, 0, 0), a.colorMask(!0, !0, !0, !0), a.clearColor(0, 0, 0, 0), a.depthMask(!0), a.depthFunc(a.LESS), a.clearDepth(1), a.stencilMask(4294967295), a.stencilFunc(a.ALWAYS, 0, 4294967295), a.stencilOp(a.KEEP, a.KEEP, a.KEEP), a.clearStencil(0), a.cullFace(a.BACK), a.frontFace(a.CCW), a.polygonOffset(0, 0), a.activeTexture(a.TEXTURE0), a.bindFramebuffer(a.FRAMEBUFFER, null), a.bindFramebuffer(a.DRAW_FRAMEBUFFER, null), a.bindFramebuffer(a.READ_FRAMEBUFFER, null), a.useProgram(null), a.lineWidth(1), a.scissor(0, 0, a.canvas.width, a.canvas.height), a.viewport(0, 0, a.canvas.width, a.canvas.height), f = {}, ee = null, Ce = {}, h = {}, v = /* @__PURE__ */ new WeakMap(), b = [], S = null, R = !1, W = null, x = null, M = null, T = null, E = null, _ = null, P = null, U = new hi(0, 0, 0), q = 0, k = !1, O = null, J = null, te = null, fe = null, pe = null, Ye.set(0, 0, a.canvas.width, a.canvas.height), $e.set(0, 0, a.canvas.width, a.canvas.height), i.reset(), o.reset(), l.reset();
  }
  return {
    buffers: {
      color: i,
      depth: o,
      stencil: l
    },
    enable: wt,
    disable: St,
    bindFramebuffer: ln,
    drawBuffers: hn,
    useProgram: mn,
    setBlending: Lt,
    setMaterial: Wt,
    setFlipSided: tn,
    setCullFace: Gt,
    setLineWidth: Rn,
    setPolygonOffset: nn,
    setScissorTest: Bn,
    activeTexture: Se,
    bindTexture: oe,
    unbindTexture: ct,
    compressedTexImage2D: Ft,
    compressedTexImage3D: pt,
    texImage2D: An,
    texImage3D: Fe,
    updateUBOMapping: ye,
    uniformBlockBinding: Pe,
    texStorage2D: qn,
    texStorage3D: qt,
    texSubImage2D: zt,
    texSubImage3D: Sn,
    compressedTexSubImage2D: rn,
    compressedTexSubImage3D: gn,
    scissor: Ie,
    viewport: at,
    reset: Ot
  };
}
function q8(a, e) {
  const t = a.image && a.image.width ? a.image.width / a.image.height : 1;
  return t > e ? (a.repeat.x = 1, a.repeat.y = t / e, a.offset.x = 0, a.offset.y = (1 - a.repeat.y) / 2) : (a.repeat.x = e / t, a.repeat.y = 1, a.offset.x = (1 - a.repeat.x) / 2, a.offset.y = 0), a;
}
function $8(a, e) {
  const t = a.image && a.image.width ? a.image.width / a.image.height : 1;
  return t > e ? (a.repeat.x = e / t, a.repeat.y = 1, a.offset.x = (1 - a.repeat.x) / 2, a.offset.y = 0) : (a.repeat.x = 1, a.repeat.y = t / e, a.offset.x = 0, a.offset.y = (1 - a.repeat.y) / 2), a;
}
function eq(a) {
  return a.repeat.x = 1, a.repeat.y = 1, a.offset.x = 0, a.offset.y = 0, a;
}
function WH(a, e, t, n) {
  const i = tq(n);
  switch (t) {
    case SX:
      return a * e;
    case wX:
      return a * e;
    case RX:
      return a * e * 2;
    case CW:
      return a * e / i.components * i.byteLength;
    case Kw:
      return a * e / i.components * i.byteLength;
    case xX:
      return a * e * 2 / i.components * i.byteLength;
    case hW:
      return a * e * 2 / i.components * i.byteLength;
    case ZX:
      return a * e * 3 / i.components * i.byteLength;
    case rg:
      return a * e * 4 / i.components * i.byteLength;
    case fW:
      return a * e * 4 / i.components * i.byteLength;
    case DZ:
    case UZ:
      return Math.floor((a + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case OZ:
    case PZ:
      return Math.floor((a + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case c2:
    case d2:
      return Math.max(a, 16) * Math.max(e, 8) / 4;
    case u2:
    case g2:
      return Math.max(a, 8) * Math.max(e, 8) / 2;
    case I2:
    case C2:
      return Math.floor((a + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case h2:
      return Math.floor((a + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case f2:
      return Math.floor((a + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case p2:
      return Math.floor((a + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case m2:
      return Math.floor((a + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case A2:
      return Math.floor((a + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case v2:
      return Math.floor((a + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case y2:
      return Math.floor((a + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case b2:
      return Math.floor((a + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case G2:
      return Math.floor((a + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case B2:
      return Math.floor((a + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case S2:
      return Math.floor((a + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Z2:
      return Math.floor((a + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case w2:
      return Math.floor((a + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case R2:
      return Math.floor((a + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case x2:
      return Math.floor((a + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case JZ:
    case W2:
    case V2:
      return Math.ceil(a / 4) * Math.ceil(e / 4) * 16;
    case WX:
    case N2:
      return Math.ceil(a / 4) * Math.ceil(e / 4) * 8;
    case M2:
    case H2:
      return Math.ceil(a / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${t} format.`
  );
}
function tq(a) {
  switch (a) {
    case _h:
    case bX:
      return { byteLength: 1, components: 1 };
    case qG:
    case GX:
    case Zb:
      return { byteLength: 2, components: 1 };
    case dW:
    case IW:
      return { byteLength: 2, components: 4 };
    case Hm:
    case gW:
    case kg:
      return { byteLength: 4, components: 1 };
    case BX:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${a}.`);
}
const nq = {
  contain: q8,
  cover: $8,
  fill: eq,
  getByteLength: WH
};
function iq(a, e, t, n, i, o, l) {
  const u = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, I = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), f = new sn(), h = /* @__PURE__ */ new WeakMap();
  let v;
  const b = /* @__PURE__ */ new WeakMap();
  let S = !1;
  try {
    S = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function R(Se, oe) {
    return S ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(Se, oe)
    ) : vw("canvas");
  }
  function W(Se, oe, ct) {
    let Ft = 1;
    const pt = Bn(Se);
    if ((pt.width > ct || pt.height > ct) && (Ft = ct / Math.max(pt.width, pt.height)), Ft < 1)
      if (typeof HTMLImageElement < "u" && Se instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Se instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Se instanceof ImageBitmap || typeof VideoFrame < "u" && Se instanceof VideoFrame) {
        const zt = Math.floor(Ft * pt.width), Sn = Math.floor(Ft * pt.height);
        v === void 0 && (v = R(zt, Sn));
        const rn = oe ? R(zt, Sn) : v;
        return rn.width = zt, rn.height = Sn, rn.getContext("2d").drawImage(Se, 0, 0, zt, Sn), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + pt.width + "x" + pt.height + ") to (" + zt + "x" + Sn + ")."), rn;
      } else
        return "data" in Se && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + pt.width + "x" + pt.height + ")."), Se;
    return Se;
  }
  function x(Se) {
    return Se.generateMipmaps && Se.minFilter !== _u && Se.minFilter !== nl;
  }
  function M(Se) {
    a.generateMipmap(Se);
  }
  function T(Se, oe, ct, Ft, pt = !1) {
    if (Se !== null) {
      if (a[Se] !== void 0) return a[Se];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Se + "'");
    }
    let zt = oe;
    if (oe === a.RED && (ct === a.FLOAT && (zt = a.R32F), ct === a.HALF_FLOAT && (zt = a.R16F), ct === a.UNSIGNED_BYTE && (zt = a.R8)), oe === a.RED_INTEGER && (ct === a.UNSIGNED_BYTE && (zt = a.R8UI), ct === a.UNSIGNED_SHORT && (zt = a.R16UI), ct === a.UNSIGNED_INT && (zt = a.R32UI), ct === a.BYTE && (zt = a.R8I), ct === a.SHORT && (zt = a.R16I), ct === a.INT && (zt = a.R32I)), oe === a.RG && (ct === a.FLOAT && (zt = a.RG32F), ct === a.HALF_FLOAT && (zt = a.RG16F), ct === a.UNSIGNED_BYTE && (zt = a.RG8)), oe === a.RG_INTEGER && (ct === a.UNSIGNED_BYTE && (zt = a.RG8UI), ct === a.UNSIGNED_SHORT && (zt = a.RG16UI), ct === a.UNSIGNED_INT && (zt = a.RG32UI), ct === a.BYTE && (zt = a.RG8I), ct === a.SHORT && (zt = a.RG16I), ct === a.INT && (zt = a.RG32I)), oe === a.RGB && ct === a.UNSIGNED_INT_5_9_9_9_REV && (zt = a.RGB9_E5), oe === a.RGBA) {
      const Sn = pt ? hw : Ta.getTransfer(Ft);
      ct === a.FLOAT && (zt = a.RGBA32F), ct === a.HALF_FLOAT && (zt = a.RGBA16F), ct === a.UNSIGNED_BYTE && (zt = Sn === Po ? a.SRGB8_ALPHA8 : a.RGBA8), ct === a.UNSIGNED_SHORT_4_4_4_4 && (zt = a.RGBA4), ct === a.UNSIGNED_SHORT_5_5_5_1 && (zt = a.RGB5_A1);
    }
    return (zt === a.R16F || zt === a.R32F || zt === a.RG16F || zt === a.RG32F || zt === a.RGBA16F || zt === a.RGBA32F) && e.get("EXT_color_buffer_float"), zt;
  }
  function E(Se, oe) {
    let ct;
    return Se ? oe === null || oe === Hm || oe === Ab ? ct = a.DEPTH24_STENCIL8 : oe === kg ? ct = a.DEPTH32F_STENCIL8 : oe === qG && (ct = a.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : oe === null || oe === Hm || oe === Ab ? ct = a.DEPTH_COMPONENT24 : oe === kg ? ct = a.DEPTH_COMPONENT32F : oe === qG && (ct = a.DEPTH_COMPONENT16), ct;
  }
  function _(Se, oe) {
    return x(Se) === !0 || Se.isFramebufferTexture && Se.minFilter !== _u && Se.minFilter !== nl ? Math.log2(Math.max(oe.width, oe.height)) + 1 : Se.mipmaps !== void 0 && Se.mipmaps.length > 0 ? Se.mipmaps.length : Se.isCompressedTexture && Array.isArray(Se.image) ? oe.mipmaps.length : 1;
  }
  function P(Se) {
    const oe = Se.target;
    oe.removeEventListener("dispose", P), q(oe), oe.isVideoTexture && h.delete(oe);
  }
  function U(Se) {
    const oe = Se.target;
    oe.removeEventListener("dispose", U), O(oe);
  }
  function q(Se) {
    const oe = n.get(Se);
    if (oe.__webglInit === void 0) return;
    const ct = Se.source, Ft = b.get(ct);
    if (Ft) {
      const pt = Ft[oe.__cacheKey];
      pt.usedTimes--, pt.usedTimes === 0 && k(Se), Object.keys(Ft).length === 0 && b.delete(ct);
    }
    n.remove(Se);
  }
  function k(Se) {
    const oe = n.get(Se);
    a.deleteTexture(oe.__webglTexture);
    const ct = Se.source, Ft = b.get(ct);
    delete Ft[oe.__cacheKey], l.memory.textures--;
  }
  function O(Se) {
    const oe = n.get(Se);
    if (Se.depthTexture && Se.depthTexture.dispose(), Se.isWebGLCubeRenderTarget)
      for (let Ft = 0; Ft < 6; Ft++) {
        if (Array.isArray(oe.__webglFramebuffer[Ft]))
          for (let pt = 0; pt < oe.__webglFramebuffer[Ft].length; pt++) a.deleteFramebuffer(oe.__webglFramebuffer[Ft][pt]);
        else
          a.deleteFramebuffer(oe.__webglFramebuffer[Ft]);
        oe.__webglDepthbuffer && a.deleteRenderbuffer(oe.__webglDepthbuffer[Ft]);
      }
    else {
      if (Array.isArray(oe.__webglFramebuffer))
        for (let Ft = 0; Ft < oe.__webglFramebuffer.length; Ft++) a.deleteFramebuffer(oe.__webglFramebuffer[Ft]);
      else
        a.deleteFramebuffer(oe.__webglFramebuffer);
      if (oe.__webglDepthbuffer && a.deleteRenderbuffer(oe.__webglDepthbuffer), oe.__webglMultisampledFramebuffer && a.deleteFramebuffer(oe.__webglMultisampledFramebuffer), oe.__webglColorRenderbuffer)
        for (let Ft = 0; Ft < oe.__webglColorRenderbuffer.length; Ft++)
          oe.__webglColorRenderbuffer[Ft] && a.deleteRenderbuffer(oe.__webglColorRenderbuffer[Ft]);
      oe.__webglDepthRenderbuffer && a.deleteRenderbuffer(oe.__webglDepthRenderbuffer);
    }
    const ct = Se.textures;
    for (let Ft = 0, pt = ct.length; Ft < pt; Ft++) {
      const zt = n.get(ct[Ft]);
      zt.__webglTexture && (a.deleteTexture(zt.__webglTexture), l.memory.textures--), n.remove(ct[Ft]);
    }
    n.remove(Se);
  }
  let J = 0;
  function te() {
    J = 0;
  }
  function fe() {
    const Se = J;
    return Se >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + Se + " texture units while this GPU supports only " + i.maxTextures), J += 1, Se;
  }
  function pe(Se) {
    const oe = [];
    return oe.push(Se.wrapS), oe.push(Se.wrapT), oe.push(Se.wrapR || 0), oe.push(Se.magFilter), oe.push(Se.minFilter), oe.push(Se.anisotropy), oe.push(Se.internalFormat), oe.push(Se.format), oe.push(Se.type), oe.push(Se.generateMipmaps), oe.push(Se.premultiplyAlpha), oe.push(Se.flipY), oe.push(Se.unpackAlignment), oe.push(Se.colorSpace), oe.join();
  }
  function Ae(Se, oe) {
    const ct = n.get(Se);
    if (Se.isVideoTexture && Rn(Se), Se.isRenderTargetTexture === !1 && Se.version > 0 && ct.__version !== Se.version) {
      const Ft = Se.image;
      if (Ft === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Ft.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        $e(ct, Se, oe);
        return;
      }
    }
    t.bindTexture(a.TEXTURE_2D, ct.__webglTexture, a.TEXTURE0 + oe);
  }
  function Te(Se, oe) {
    const ct = n.get(Se);
    if (Se.version > 0 && ct.__version !== Se.version) {
      $e(ct, Se, oe);
      return;
    }
    t.bindTexture(a.TEXTURE_2D_ARRAY, ct.__webglTexture, a.TEXTURE0 + oe);
  }
  function Ke(Se, oe) {
    const ct = n.get(Se);
    if (Se.version > 0 && ct.__version !== Se.version) {
      $e(ct, Se, oe);
      return;
    }
    t.bindTexture(a.TEXTURE_3D, ct.__webglTexture, a.TEXTURE0 + oe);
  }
  function je(Se, oe) {
    const ct = n.get(Se);
    if (Se.version > 0 && ct.__version !== Se.version) {
      ke(ct, Se, oe);
      return;
    }
    t.bindTexture(a.TEXTURE_CUBE_MAP, ct.__webglTexture, a.TEXTURE0 + oe);
  }
  const ee = {
    [gw]: a.REPEAT,
    [XC]: a.CLAMP_TO_EDGE,
    [dw]: a.MIRRORED_REPEAT
  }, Ce = {
    [_u]: a.NEAREST,
    [yX]: a.NEAREST_MIPMAP_NEAREST,
    [FG]: a.NEAREST_MIPMAP_LINEAR,
    [nl]: a.LINEAR,
    [kZ]: a.LINEAR_MIPMAP_NEAREST,
    [np]: a.LINEAR_MIPMAP_LINEAR
  }, be = {
    [bz]: a.NEVER,
    [Rz]: a.ALWAYS,
    [Gz]: a.LESS,
    [NX]: a.LEQUAL,
    [Bz]: a.EQUAL,
    [wz]: a.GEQUAL,
    [Sz]: a.GREATER,
    [Zz]: a.NOTEQUAL
  };
  function le(Se, oe) {
    if (oe.type === kg && e.has("OES_texture_float_linear") === !1 && (oe.magFilter === nl || oe.magFilter === kZ || oe.magFilter === FG || oe.magFilter === np || oe.minFilter === nl || oe.minFilter === kZ || oe.minFilter === FG || oe.minFilter === np) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), a.texParameteri(Se, a.TEXTURE_WRAP_S, ee[oe.wrapS]), a.texParameteri(Se, a.TEXTURE_WRAP_T, ee[oe.wrapT]), (Se === a.TEXTURE_3D || Se === a.TEXTURE_2D_ARRAY) && a.texParameteri(Se, a.TEXTURE_WRAP_R, ee[oe.wrapR]), a.texParameteri(Se, a.TEXTURE_MAG_FILTER, Ce[oe.magFilter]), a.texParameteri(Se, a.TEXTURE_MIN_FILTER, Ce[oe.minFilter]), oe.compareFunction && (a.texParameteri(Se, a.TEXTURE_COMPARE_MODE, a.COMPARE_REF_TO_TEXTURE), a.texParameteri(Se, a.TEXTURE_COMPARE_FUNC, be[oe.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (oe.magFilter === _u || oe.minFilter !== FG && oe.minFilter !== np || oe.type === kg && e.has("OES_texture_float_linear") === !1) return;
      if (oe.anisotropy > 1 || n.get(oe).__currentAnisotropy) {
        const ct = e.get("EXT_texture_filter_anisotropic");
        a.texParameterf(Se, ct.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(oe.anisotropy, i.getMaxAnisotropy())), n.get(oe).__currentAnisotropy = oe.anisotropy;
      }
    }
  }
  function Ye(Se, oe) {
    let ct = !1;
    Se.__webglInit === void 0 && (Se.__webglInit = !0, oe.addEventListener("dispose", P));
    const Ft = oe.source;
    let pt = b.get(Ft);
    pt === void 0 && (pt = {}, b.set(Ft, pt));
    const zt = pe(oe);
    if (zt !== Se.__cacheKey) {
      pt[zt] === void 0 && (pt[zt] = {
        texture: a.createTexture(),
        usedTimes: 0
      }, l.memory.textures++, ct = !0), pt[zt].usedTimes++;
      const Sn = pt[Se.__cacheKey];
      Sn !== void 0 && (pt[Se.__cacheKey].usedTimes--, Sn.usedTimes === 0 && k(oe)), Se.__cacheKey = zt, Se.__webglTexture = pt[zt].texture;
    }
    return ct;
  }
  function $e(Se, oe, ct) {
    let Ft = a.TEXTURE_2D;
    (oe.isDataArrayTexture || oe.isCompressedArrayTexture) && (Ft = a.TEXTURE_2D_ARRAY), oe.isData3DTexture && (Ft = a.TEXTURE_3D);
    const pt = Ye(Se, oe), zt = oe.source;
    t.bindTexture(Ft, Se.__webglTexture, a.TEXTURE0 + ct);
    const Sn = n.get(zt);
    if (zt.version !== Sn.__version || pt === !0) {
      t.activeTexture(a.TEXTURE0 + ct);
      const rn = Ta.getPrimaries(Ta.workingColorSpace), gn = oe.colorSpace === Sm ? null : Ta.getPrimaries(oe.colorSpace), qn = oe.colorSpace === Sm || rn === gn ? a.NONE : a.BROWSER_DEFAULT_WEBGL;
      a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, oe.flipY), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, oe.premultiplyAlpha), a.pixelStorei(a.UNPACK_ALIGNMENT, oe.unpackAlignment), a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL, qn);
      let qt = W(oe.image, !1, i.maxTextureSize);
      qt = nn(oe, qt);
      const An = o.convert(oe.format, oe.colorSpace), Fe = o.convert(oe.type);
      let Ie = T(oe.internalFormat, An, Fe, oe.colorSpace, oe.isVideoTexture);
      le(Ft, oe);
      let at;
      const ye = oe.mipmaps, Pe = oe.isVideoTexture !== !0, Ot = Sn.__version === void 0 || pt === !0, Re = zt.dataReady, lt = _(oe, qt);
      if (oe.isDepthTexture)
        Ie = E(oe.format === vb, oe.type), Ot && (Pe ? t.texStorage2D(a.TEXTURE_2D, 1, Ie, qt.width, qt.height) : t.texImage2D(a.TEXTURE_2D, 0, Ie, qt.width, qt.height, 0, An, Fe, null));
      else if (oe.isDataTexture)
        if (ye.length > 0) {
          Pe && Ot && t.texStorage2D(a.TEXTURE_2D, lt, Ie, ye[0].width, ye[0].height);
          for (let _e = 0, ht = ye.length; _e < ht; _e++)
            at = ye[_e], Pe ? Re && t.texSubImage2D(a.TEXTURE_2D, _e, 0, 0, at.width, at.height, An, Fe, at.data) : t.texImage2D(a.TEXTURE_2D, _e, Ie, at.width, at.height, 0, An, Fe, at.data);
          oe.generateMipmaps = !1;
        } else
          Pe ? (Ot && t.texStorage2D(a.TEXTURE_2D, lt, Ie, qt.width, qt.height), Re && t.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, qt.width, qt.height, An, Fe, qt.data)) : t.texImage2D(a.TEXTURE_2D, 0, Ie, qt.width, qt.height, 0, An, Fe, qt.data);
      else if (oe.isCompressedTexture)
        if (oe.isCompressedArrayTexture) {
          Pe && Ot && t.texStorage3D(a.TEXTURE_2D_ARRAY, lt, Ie, ye[0].width, ye[0].height, qt.depth);
          for (let _e = 0, ht = ye.length; _e < ht; _e++)
            if (at = ye[_e], oe.format !== rg)
              if (An !== null)
                if (Pe) {
                  if (Re)
                    if (oe.layerUpdates.size > 0) {
                      const Ht = WH(at.width, at.height, oe.format, oe.type);
                      for (const an of oe.layerUpdates) {
                        const fi = at.data.subarray(
                          an * Ht / at.data.BYTES_PER_ELEMENT,
                          (an + 1) * Ht / at.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(a.TEXTURE_2D_ARRAY, _e, 0, 0, an, at.width, at.height, 1, An, fi, 0, 0);
                      }
                      oe.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(a.TEXTURE_2D_ARRAY, _e, 0, 0, 0, at.width, at.height, qt.depth, An, at.data, 0, 0);
                } else
                  t.compressedTexImage3D(a.TEXTURE_2D_ARRAY, _e, Ie, at.width, at.height, qt.depth, 0, at.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              Pe ? Re && t.texSubImage3D(a.TEXTURE_2D_ARRAY, _e, 0, 0, 0, at.width, at.height, qt.depth, An, Fe, at.data) : t.texImage3D(a.TEXTURE_2D_ARRAY, _e, Ie, at.width, at.height, qt.depth, 0, An, Fe, at.data);
        } else {
          Pe && Ot && t.texStorage2D(a.TEXTURE_2D, lt, Ie, ye[0].width, ye[0].height);
          for (let _e = 0, ht = ye.length; _e < ht; _e++)
            at = ye[_e], oe.format !== rg ? An !== null ? Pe ? Re && t.compressedTexSubImage2D(a.TEXTURE_2D, _e, 0, 0, at.width, at.height, An, at.data) : t.compressedTexImage2D(a.TEXTURE_2D, _e, Ie, at.width, at.height, 0, at.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Pe ? Re && t.texSubImage2D(a.TEXTURE_2D, _e, 0, 0, at.width, at.height, An, Fe, at.data) : t.texImage2D(a.TEXTURE_2D, _e, Ie, at.width, at.height, 0, An, Fe, at.data);
        }
      else if (oe.isDataArrayTexture)
        if (Pe) {
          if (Ot && t.texStorage3D(a.TEXTURE_2D_ARRAY, lt, Ie, qt.width, qt.height, qt.depth), Re)
            if (oe.layerUpdates.size > 0) {
              const _e = WH(qt.width, qt.height, oe.format, oe.type);
              for (const ht of oe.layerUpdates) {
                const Ht = qt.data.subarray(
                  ht * _e / qt.data.BYTES_PER_ELEMENT,
                  (ht + 1) * _e / qt.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, ht, qt.width, qt.height, 1, An, Fe, Ht);
              }
              oe.clearLayerUpdates();
            } else
              t.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, 0, qt.width, qt.height, qt.depth, An, Fe, qt.data);
        } else
          t.texImage3D(a.TEXTURE_2D_ARRAY, 0, Ie, qt.width, qt.height, qt.depth, 0, An, Fe, qt.data);
      else if (oe.isData3DTexture)
        Pe ? (Ot && t.texStorage3D(a.TEXTURE_3D, lt, Ie, qt.width, qt.height, qt.depth), Re && t.texSubImage3D(a.TEXTURE_3D, 0, 0, 0, 0, qt.width, qt.height, qt.depth, An, Fe, qt.data)) : t.texImage3D(a.TEXTURE_3D, 0, Ie, qt.width, qt.height, qt.depth, 0, An, Fe, qt.data);
      else if (oe.isFramebufferTexture) {
        if (Ot)
          if (Pe)
            t.texStorage2D(a.TEXTURE_2D, lt, Ie, qt.width, qt.height);
          else {
            let _e = qt.width, ht = qt.height;
            for (let Ht = 0; Ht < lt; Ht++)
              t.texImage2D(a.TEXTURE_2D, Ht, Ie, _e, ht, 0, An, Fe, null), _e >>= 1, ht >>= 1;
          }
      } else if (ye.length > 0) {
        if (Pe && Ot) {
          const _e = Bn(ye[0]);
          t.texStorage2D(a.TEXTURE_2D, lt, Ie, _e.width, _e.height);
        }
        for (let _e = 0, ht = ye.length; _e < ht; _e++)
          at = ye[_e], Pe ? Re && t.texSubImage2D(a.TEXTURE_2D, _e, 0, 0, An, Fe, at) : t.texImage2D(a.TEXTURE_2D, _e, Ie, An, Fe, at);
        oe.generateMipmaps = !1;
      } else if (Pe) {
        if (Ot) {
          const _e = Bn(qt);
          t.texStorage2D(a.TEXTURE_2D, lt, Ie, _e.width, _e.height);
        }
        Re && t.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, An, Fe, qt);
      } else
        t.texImage2D(a.TEXTURE_2D, 0, Ie, An, Fe, qt);
      x(oe) && M(Ft), Sn.__version = zt.version, oe.onUpdate && oe.onUpdate(oe);
    }
    Se.__version = oe.version;
  }
  function ke(Se, oe, ct) {
    if (oe.image.length !== 6) return;
    const Ft = Ye(Se, oe), pt = oe.source;
    t.bindTexture(a.TEXTURE_CUBE_MAP, Se.__webglTexture, a.TEXTURE0 + ct);
    const zt = n.get(pt);
    if (pt.version !== zt.__version || Ft === !0) {
      t.activeTexture(a.TEXTURE0 + ct);
      const Sn = Ta.getPrimaries(Ta.workingColorSpace), rn = oe.colorSpace === Sm ? null : Ta.getPrimaries(oe.colorSpace), gn = oe.colorSpace === Sm || Sn === rn ? a.NONE : a.BROWSER_DEFAULT_WEBGL;
      a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, oe.flipY), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, oe.premultiplyAlpha), a.pixelStorei(a.UNPACK_ALIGNMENT, oe.unpackAlignment), a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL, gn);
      const qn = oe.isCompressedTexture || oe.image[0].isCompressedTexture, qt = oe.image[0] && oe.image[0].isDataTexture, An = [];
      for (let ht = 0; ht < 6; ht++)
        !qn && !qt ? An[ht] = W(oe.image[ht], !0, i.maxCubemapSize) : An[ht] = qt ? oe.image[ht].image : oe.image[ht], An[ht] = nn(oe, An[ht]);
      const Fe = An[0], Ie = o.convert(oe.format, oe.colorSpace), at = o.convert(oe.type), ye = T(oe.internalFormat, Ie, at, oe.colorSpace), Pe = oe.isVideoTexture !== !0, Ot = zt.__version === void 0 || Ft === !0, Re = pt.dataReady;
      let lt = _(oe, Fe);
      le(a.TEXTURE_CUBE_MAP, oe);
      let _e;
      if (qn) {
        Pe && Ot && t.texStorage2D(a.TEXTURE_CUBE_MAP, lt, ye, Fe.width, Fe.height);
        for (let ht = 0; ht < 6; ht++) {
          _e = An[ht].mipmaps;
          for (let Ht = 0; Ht < _e.length; Ht++) {
            const an = _e[Ht];
            oe.format !== rg ? Ie !== null ? Pe ? Re && t.compressedTexSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, Ht, 0, 0, an.width, an.height, Ie, an.data) : t.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, Ht, ye, an.width, an.height, 0, an.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Pe ? Re && t.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, Ht, 0, 0, an.width, an.height, Ie, at, an.data) : t.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, Ht, ye, an.width, an.height, 0, Ie, at, an.data);
          }
        }
      } else {
        if (_e = oe.mipmaps, Pe && Ot) {
          _e.length > 0 && lt++;
          const ht = Bn(An[0]);
          t.texStorage2D(a.TEXTURE_CUBE_MAP, lt, ye, ht.width, ht.height);
        }
        for (let ht = 0; ht < 6; ht++)
          if (qt) {
            Pe ? Re && t.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, 0, 0, 0, An[ht].width, An[ht].height, Ie, at, An[ht].data) : t.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, 0, ye, An[ht].width, An[ht].height, 0, Ie, at, An[ht].data);
            for (let Ht = 0; Ht < _e.length; Ht++) {
              const fi = _e[Ht].image[ht].image;
              Pe ? Re && t.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, Ht + 1, 0, 0, fi.width, fi.height, Ie, at, fi.data) : t.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, Ht + 1, ye, fi.width, fi.height, 0, Ie, at, fi.data);
            }
          } else {
            Pe ? Re && t.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, 0, 0, 0, Ie, at, An[ht]) : t.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, 0, ye, Ie, at, An[ht]);
            for (let Ht = 0; Ht < _e.length; Ht++) {
              const an = _e[Ht];
              Pe ? Re && t.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, Ht + 1, 0, 0, Ie, at, an.image[ht]) : t.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + ht, Ht + 1, ye, Ie, at, an.image[ht]);
            }
          }
      }
      x(oe) && M(a.TEXTURE_CUBE_MAP), zt.__version = pt.version, oe.onUpdate && oe.onUpdate(oe);
    }
    Se.__version = oe.version;
  }
  function ot(Se, oe, ct, Ft, pt, zt) {
    const Sn = o.convert(ct.format, ct.colorSpace), rn = o.convert(ct.type), gn = T(ct.internalFormat, Sn, rn, ct.colorSpace);
    if (!n.get(oe).__hasExternalTextures) {
      const qt = Math.max(1, oe.width >> zt), An = Math.max(1, oe.height >> zt);
      pt === a.TEXTURE_3D || pt === a.TEXTURE_2D_ARRAY ? t.texImage3D(pt, zt, gn, qt, An, oe.depth, 0, Sn, rn, null) : t.texImage2D(pt, zt, gn, qt, An, 0, Sn, rn, null);
    }
    t.bindFramebuffer(a.FRAMEBUFFER, Se), Gt(oe) ? u.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER, Ft, pt, n.get(ct).__webglTexture, 0, tn(oe)) : (pt === a.TEXTURE_2D || pt >= a.TEXTURE_CUBE_MAP_POSITIVE_X && pt <= a.TEXTURE_CUBE_MAP_NEGATIVE_Z) && a.framebufferTexture2D(a.FRAMEBUFFER, Ft, pt, n.get(ct).__webglTexture, zt), t.bindFramebuffer(a.FRAMEBUFFER, null);
  }
  function wt(Se, oe, ct) {
    if (a.bindRenderbuffer(a.RENDERBUFFER, Se), oe.depthBuffer) {
      const Ft = oe.depthTexture, pt = Ft && Ft.isDepthTexture ? Ft.type : null, zt = E(oe.stencilBuffer, pt), Sn = oe.stencilBuffer ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT, rn = tn(oe);
      Gt(oe) ? u.renderbufferStorageMultisampleEXT(a.RENDERBUFFER, rn, zt, oe.width, oe.height) : ct ? a.renderbufferStorageMultisample(a.RENDERBUFFER, rn, zt, oe.width, oe.height) : a.renderbufferStorage(a.RENDERBUFFER, zt, oe.width, oe.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, Sn, a.RENDERBUFFER, Se);
    } else {
      const Ft = oe.textures;
      for (let pt = 0; pt < Ft.length; pt++) {
        const zt = Ft[pt], Sn = o.convert(zt.format, zt.colorSpace), rn = o.convert(zt.type), gn = T(zt.internalFormat, Sn, rn, zt.colorSpace), qn = tn(oe);
        ct && Gt(oe) === !1 ? a.renderbufferStorageMultisample(a.RENDERBUFFER, qn, gn, oe.width, oe.height) : Gt(oe) ? u.renderbufferStorageMultisampleEXT(a.RENDERBUFFER, qn, gn, oe.width, oe.height) : a.renderbufferStorage(a.RENDERBUFFER, gn, oe.width, oe.height);
      }
    }
    a.bindRenderbuffer(a.RENDERBUFFER, null);
  }
  function St(Se, oe) {
    if (oe && oe.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(a.FRAMEBUFFER, Se), !(oe.depthTexture && oe.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(oe.depthTexture).__webglTexture || oe.depthTexture.image.width !== oe.width || oe.depthTexture.image.height !== oe.height) && (oe.depthTexture.image.width = oe.width, oe.depthTexture.image.height = oe.height, oe.depthTexture.needsUpdate = !0), Ae(oe.depthTexture, 0);
    const Ft = n.get(oe.depthTexture).__webglTexture, pt = tn(oe);
    if (oe.depthTexture.format === cb)
      Gt(oe) ? u.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, Ft, 0, pt) : a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, Ft, 0);
    else if (oe.depthTexture.format === vb)
      Gt(oe) ? u.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, Ft, 0, pt) : a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, Ft, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function ln(Se) {
    const oe = n.get(Se), ct = Se.isWebGLCubeRenderTarget === !0;
    if (Se.depthTexture && !oe.__autoAllocateDepthBuffer) {
      if (ct) throw new Error("target.depthTexture not supported in Cube render targets");
      St(oe.__webglFramebuffer, Se);
    } else if (ct) {
      oe.__webglDepthbuffer = [];
      for (let Ft = 0; Ft < 6; Ft++)
        t.bindFramebuffer(a.FRAMEBUFFER, oe.__webglFramebuffer[Ft]), oe.__webglDepthbuffer[Ft] = a.createRenderbuffer(), wt(oe.__webglDepthbuffer[Ft], Se, !1);
    } else
      t.bindFramebuffer(a.FRAMEBUFFER, oe.__webglFramebuffer), oe.__webglDepthbuffer = a.createRenderbuffer(), wt(oe.__webglDepthbuffer, Se, !1);
    t.bindFramebuffer(a.FRAMEBUFFER, null);
  }
  function hn(Se, oe, ct) {
    const Ft = n.get(Se);
    oe !== void 0 && ot(Ft.__webglFramebuffer, Se, Se.texture, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, 0), ct !== void 0 && ln(Se);
  }
  function mn(Se) {
    const oe = Se.texture, ct = n.get(Se), Ft = n.get(oe);
    Se.addEventListener("dispose", U);
    const pt = Se.textures, zt = Se.isWebGLCubeRenderTarget === !0, Sn = pt.length > 1;
    if (Sn || (Ft.__webglTexture === void 0 && (Ft.__webglTexture = a.createTexture()), Ft.__version = oe.version, l.memory.textures++), zt) {
      ct.__webglFramebuffer = [];
      for (let rn = 0; rn < 6; rn++)
        if (oe.mipmaps && oe.mipmaps.length > 0) {
          ct.__webglFramebuffer[rn] = [];
          for (let gn = 0; gn < oe.mipmaps.length; gn++)
            ct.__webglFramebuffer[rn][gn] = a.createFramebuffer();
        } else
          ct.__webglFramebuffer[rn] = a.createFramebuffer();
    } else {
      if (oe.mipmaps && oe.mipmaps.length > 0) {
        ct.__webglFramebuffer = [];
        for (let rn = 0; rn < oe.mipmaps.length; rn++)
          ct.__webglFramebuffer[rn] = a.createFramebuffer();
      } else
        ct.__webglFramebuffer = a.createFramebuffer();
      if (Sn)
        for (let rn = 0, gn = pt.length; rn < gn; rn++) {
          const qn = n.get(pt[rn]);
          qn.__webglTexture === void 0 && (qn.__webglTexture = a.createTexture(), l.memory.textures++);
        }
      if (Se.samples > 0 && Gt(Se) === !1) {
        ct.__webglMultisampledFramebuffer = a.createFramebuffer(), ct.__webglColorRenderbuffer = [], t.bindFramebuffer(a.FRAMEBUFFER, ct.__webglMultisampledFramebuffer);
        for (let rn = 0; rn < pt.length; rn++) {
          const gn = pt[rn];
          ct.__webglColorRenderbuffer[rn] = a.createRenderbuffer(), a.bindRenderbuffer(a.RENDERBUFFER, ct.__webglColorRenderbuffer[rn]);
          const qn = o.convert(gn.format, gn.colorSpace), qt = o.convert(gn.type), An = T(gn.internalFormat, qn, qt, gn.colorSpace, Se.isXRRenderTarget === !0), Fe = tn(Se);
          a.renderbufferStorageMultisample(a.RENDERBUFFER, Fe, An, Se.width, Se.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0 + rn, a.RENDERBUFFER, ct.__webglColorRenderbuffer[rn]);
        }
        a.bindRenderbuffer(a.RENDERBUFFER, null), Se.depthBuffer && (ct.__webglDepthRenderbuffer = a.createRenderbuffer(), wt(ct.__webglDepthRenderbuffer, Se, !0)), t.bindFramebuffer(a.FRAMEBUFFER, null);
      }
    }
    if (zt) {
      t.bindTexture(a.TEXTURE_CUBE_MAP, Ft.__webglTexture), le(a.TEXTURE_CUBE_MAP, oe);
      for (let rn = 0; rn < 6; rn++)
        if (oe.mipmaps && oe.mipmaps.length > 0)
          for (let gn = 0; gn < oe.mipmaps.length; gn++)
            ot(ct.__webglFramebuffer[rn][gn], Se, oe, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + rn, gn);
        else
          ot(ct.__webglFramebuffer[rn], Se, oe, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + rn, 0);
      x(oe) && M(a.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Sn) {
      for (let rn = 0, gn = pt.length; rn < gn; rn++) {
        const qn = pt[rn], qt = n.get(qn);
        t.bindTexture(a.TEXTURE_2D, qt.__webglTexture), le(a.TEXTURE_2D, qn), ot(ct.__webglFramebuffer, Se, qn, a.COLOR_ATTACHMENT0 + rn, a.TEXTURE_2D, 0), x(qn) && M(a.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let rn = a.TEXTURE_2D;
      if ((Se.isWebGL3DRenderTarget || Se.isWebGLArrayRenderTarget) && (rn = Se.isWebGL3DRenderTarget ? a.TEXTURE_3D : a.TEXTURE_2D_ARRAY), t.bindTexture(rn, Ft.__webglTexture), le(rn, oe), oe.mipmaps && oe.mipmaps.length > 0)
        for (let gn = 0; gn < oe.mipmaps.length; gn++)
          ot(ct.__webglFramebuffer[gn], Se, oe, a.COLOR_ATTACHMENT0, rn, gn);
      else
        ot(ct.__webglFramebuffer, Se, oe, a.COLOR_ATTACHMENT0, rn, 0);
      x(oe) && M(rn), t.unbindTexture();
    }
    Se.depthBuffer && ln(Se);
  }
  function Pn(Se) {
    const oe = Se.textures;
    for (let ct = 0, Ft = oe.length; ct < Ft; ct++) {
      const pt = oe[ct];
      if (x(pt)) {
        const zt = Se.isWebGLCubeRenderTarget ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D, Sn = n.get(pt).__webglTexture;
        t.bindTexture(zt, Sn), M(zt), t.unbindTexture();
      }
    }
  }
  const he = [], Lt = [];
  function Wt(Se) {
    if (Se.samples > 0) {
      if (Gt(Se) === !1) {
        const oe = Se.textures, ct = Se.width, Ft = Se.height;
        let pt = a.COLOR_BUFFER_BIT;
        const zt = Se.stencilBuffer ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT, Sn = n.get(Se), rn = oe.length > 1;
        if (rn)
          for (let gn = 0; gn < oe.length; gn++)
            t.bindFramebuffer(a.FRAMEBUFFER, Sn.__webglMultisampledFramebuffer), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0 + gn, a.RENDERBUFFER, null), t.bindFramebuffer(a.FRAMEBUFFER, Sn.__webglFramebuffer), a.framebufferTexture2D(a.DRAW_FRAMEBUFFER, a.COLOR_ATTACHMENT0 + gn, a.TEXTURE_2D, null, 0);
        t.bindFramebuffer(a.READ_FRAMEBUFFER, Sn.__webglMultisampledFramebuffer), t.bindFramebuffer(a.DRAW_FRAMEBUFFER, Sn.__webglFramebuffer);
        for (let gn = 0; gn < oe.length; gn++) {
          if (Se.resolveDepthBuffer && (Se.depthBuffer && (pt |= a.DEPTH_BUFFER_BIT), Se.stencilBuffer && Se.resolveStencilBuffer && (pt |= a.STENCIL_BUFFER_BIT)), rn) {
            a.framebufferRenderbuffer(a.READ_FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, Sn.__webglColorRenderbuffer[gn]);
            const qn = n.get(oe[gn]).__webglTexture;
            a.framebufferTexture2D(a.DRAW_FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, qn, 0);
          }
          a.blitFramebuffer(0, 0, ct, Ft, 0, 0, ct, Ft, pt, a.NEAREST), I === !0 && (he.length = 0, Lt.length = 0, he.push(a.COLOR_ATTACHMENT0 + gn), Se.depthBuffer && Se.resolveDepthBuffer === !1 && (he.push(zt), Lt.push(zt), a.invalidateFramebuffer(a.DRAW_FRAMEBUFFER, Lt)), a.invalidateFramebuffer(a.READ_FRAMEBUFFER, he));
        }
        if (t.bindFramebuffer(a.READ_FRAMEBUFFER, null), t.bindFramebuffer(a.DRAW_FRAMEBUFFER, null), rn)
          for (let gn = 0; gn < oe.length; gn++) {
            t.bindFramebuffer(a.FRAMEBUFFER, Sn.__webglMultisampledFramebuffer), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0 + gn, a.RENDERBUFFER, Sn.__webglColorRenderbuffer[gn]);
            const qn = n.get(oe[gn]).__webglTexture;
            t.bindFramebuffer(a.FRAMEBUFFER, Sn.__webglFramebuffer), a.framebufferTexture2D(a.DRAW_FRAMEBUFFER, a.COLOR_ATTACHMENT0 + gn, a.TEXTURE_2D, qn, 0);
          }
        t.bindFramebuffer(a.DRAW_FRAMEBUFFER, Sn.__webglMultisampledFramebuffer);
      } else if (Se.depthBuffer && Se.resolveDepthBuffer === !1 && I) {
        const oe = Se.stencilBuffer ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT;
        a.invalidateFramebuffer(a.DRAW_FRAMEBUFFER, [oe]);
      }
    }
  }
  function tn(Se) {
    return Math.min(i.maxSamples, Se.samples);
  }
  function Gt(Se) {
    const oe = n.get(Se);
    return Se.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && oe.__useRenderToTexture !== !1;
  }
  function Rn(Se) {
    const oe = l.render.frame;
    h.get(Se) !== oe && (h.set(Se, oe), Se.update());
  }
  function nn(Se, oe) {
    const ct = Se.colorSpace, Ft = Se.format, pt = Se.type;
    return Se.isCompressedTexture === !0 || Se.isVideoTexture === !0 || ct !== Tm && ct !== Sm && (Ta.getTransfer(ct) === Po ? (Ft !== rg || pt !== _h) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ct)), oe;
  }
  function Bn(Se) {
    return typeof HTMLImageElement < "u" && Se instanceof HTMLImageElement ? (f.width = Se.naturalWidth || Se.width, f.height = Se.naturalHeight || Se.height) : typeof VideoFrame < "u" && Se instanceof VideoFrame ? (f.width = Se.displayWidth, f.height = Se.displayHeight) : (f.width = Se.width, f.height = Se.height), f;
  }
  this.allocateTextureUnit = fe, this.resetTextureUnits = te, this.setTexture2D = Ae, this.setTexture2DArray = Te, this.setTexture3D = Ke, this.setTextureCube = je, this.rebindTextures = hn, this.setupRenderTarget = mn, this.updateRenderTargetMipmap = Pn, this.updateMultisampleRenderTarget = Wt, this.setupDepthRenderbuffer = ln, this.setupFrameBufferTexture = ot, this.useMultisampledRTT = Gt;
}
function kz(a, e) {
  function t(n, i = Sm) {
    let o;
    const l = Ta.getTransfer(i);
    if (n === _h) return a.UNSIGNED_BYTE;
    if (n === dW) return a.UNSIGNED_SHORT_4_4_4_4;
    if (n === IW) return a.UNSIGNED_SHORT_5_5_5_1;
    if (n === BX) return a.UNSIGNED_INT_5_9_9_9_REV;
    if (n === bX) return a.BYTE;
    if (n === GX) return a.SHORT;
    if (n === qG) return a.UNSIGNED_SHORT;
    if (n === gW) return a.INT;
    if (n === Hm) return a.UNSIGNED_INT;
    if (n === kg) return a.FLOAT;
    if (n === Zb) return a.HALF_FLOAT;
    if (n === SX) return a.ALPHA;
    if (n === ZX) return a.RGB;
    if (n === rg) return a.RGBA;
    if (n === wX) return a.LUMINANCE;
    if (n === RX) return a.LUMINANCE_ALPHA;
    if (n === cb) return a.DEPTH_COMPONENT;
    if (n === vb) return a.DEPTH_STENCIL;
    if (n === CW) return a.RED;
    if (n === Kw) return a.RED_INTEGER;
    if (n === xX) return a.RG;
    if (n === hW) return a.RG_INTEGER;
    if (n === fW) return a.RGBA_INTEGER;
    if (n === DZ || n === UZ || n === OZ || n === PZ)
      if (l === Po)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (n === DZ) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === UZ) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === OZ) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === PZ) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (n === DZ) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === UZ) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === OZ) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === PZ) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === u2 || n === c2 || n === g2 || n === d2)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (n === u2) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === c2) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === g2) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === d2) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === I2 || n === C2 || n === h2)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (n === I2 || n === C2) return l === Po ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (n === h2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === f2 || n === p2 || n === m2 || n === A2 || n === v2 || n === y2 || n === b2 || n === G2 || n === B2 || n === S2 || n === Z2 || n === w2 || n === R2 || n === x2)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (n === f2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === p2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === m2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === A2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === v2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === y2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === b2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === G2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === B2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === S2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === Z2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === w2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === R2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === x2) return l === Po ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === JZ || n === W2 || n === V2)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (n === JZ) return l === Po ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === W2) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === V2) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === WX || n === N2 || n === M2 || n === H2)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (n === JZ) return o.COMPRESSED_RED_RGTC1_EXT;
        if (n === N2) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === M2) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === H2) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === Ab ? a.UNSIGNED_INT_24_8 : a[n] !== void 0 ? a[n] : null;
  }
  return { convert: t };
}
class Dz extends tl {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class _G extends Aa {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const rq = { type: "move" };
class yM {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new _G(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new _G(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Ze(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Ze()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new _G(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Ze(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Ze()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let i = null, o = null, l = null;
    const u = this._targetRay, I = this._grip, f = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (f && e.hand) {
        l = !0;
        for (const W of e.hand.values()) {
          const x = t.getJointPose(W, n), M = this._getHandJoint(f, W);
          x !== null && (M.matrix.fromArray(x.transform.matrix), M.matrix.decompose(M.position, M.rotation, M.scale), M.matrixWorldNeedsUpdate = !0, M.jointRadius = x.radius), M.visible = x !== null;
        }
        const h = f.joints["index-finger-tip"], v = f.joints["thumb-tip"], b = h.position.distanceTo(v.position), S = 0.02, R = 5e-3;
        f.inputState.pinching && b > S + R ? (f.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !f.inputState.pinching && b <= S - R && (f.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        I !== null && e.gripSpace && (o = t.getPose(e.gripSpace, n), o !== null && (I.matrix.fromArray(o.transform.matrix), I.matrix.decompose(I.position, I.rotation, I.scale), I.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (I.hasLinearVelocity = !0, I.linearVelocity.copy(o.linearVelocity)) : I.hasLinearVelocity = !1, o.angularVelocity ? (I.hasAngularVelocity = !0, I.angularVelocity.copy(o.angularVelocity)) : I.hasAngularVelocity = !1));
      u !== null && (i = t.getPose(e.targetRaySpace, n), i === null && o !== null && (i = o), i !== null && (u.matrix.fromArray(i.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(i.linearVelocity)) : u.hasLinearVelocity = !1, i.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(i.angularVelocity)) : u.hasAngularVelocity = !1, this.dispatchEvent(rq)));
    }
    return u !== null && (u.visible = i !== null), I !== null && (I.visible = o !== null), f !== null && (f.visible = l !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new _G();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
const aq = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, oq = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class sq {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, n) {
    if (this.texture === null) {
      const i = new Fs(), o = e.properties.get(i);
      o.__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, n = new zh({
        vertexShader: aq,
        fragmentShader: oq,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: t.z },
          depthHeight: { value: t.w }
        }
      });
      this.mesh = new Fl(new dB(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class lq extends Ip {
  constructor(e, t) {
    super();
    const n = this;
    let i = null, o = 1, l = null, u = "local-floor", I = 1, f = null, h = null, v = null, b = null, S = null, R = null;
    const W = new sq(), x = t.getContextAttributes();
    let M = null, T = null;
    const E = [], _ = [], P = new sn();
    let U = null;
    const q = new tl();
    q.layers.enable(1), q.viewport = new ro();
    const k = new tl();
    k.layers.enable(2), k.viewport = new ro();
    const O = [q, k], J = new Dz();
    J.layers.enable(1), J.layers.enable(2);
    let te = null, fe = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(ke) {
      let ot = E[ke];
      return ot === void 0 && (ot = new yM(), E[ke] = ot), ot.getTargetRaySpace();
    }, this.getControllerGrip = function(ke) {
      let ot = E[ke];
      return ot === void 0 && (ot = new yM(), E[ke] = ot), ot.getGripSpace();
    }, this.getHand = function(ke) {
      let ot = E[ke];
      return ot === void 0 && (ot = new yM(), E[ke] = ot), ot.getHandSpace();
    };
    function pe(ke) {
      const ot = _.indexOf(ke.inputSource);
      if (ot === -1)
        return;
      const wt = E[ot];
      wt !== void 0 && (wt.update(ke.inputSource, ke.frame, f || l), wt.dispatchEvent({ type: ke.type, data: ke.inputSource }));
    }
    function Ae() {
      i.removeEventListener("select", pe), i.removeEventListener("selectstart", pe), i.removeEventListener("selectend", pe), i.removeEventListener("squeeze", pe), i.removeEventListener("squeezestart", pe), i.removeEventListener("squeezeend", pe), i.removeEventListener("end", Ae), i.removeEventListener("inputsourceschange", Te);
      for (let ke = 0; ke < E.length; ke++) {
        const ot = _[ke];
        ot !== null && (_[ke] = null, E[ke].disconnect(ot));
      }
      te = null, fe = null, W.reset(), e.setRenderTarget(M), S = null, b = null, v = null, i = null, T = null, $e.stop(), n.isPresenting = !1, e.setPixelRatio(U), e.setSize(P.width, P.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(ke) {
      o = ke, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(ke) {
      u = ke, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return f || l;
    }, this.setReferenceSpace = function(ke) {
      f = ke;
    }, this.getBaseLayer = function() {
      return b !== null ? b : S;
    }, this.getBinding = function() {
      return v;
    }, this.getFrame = function() {
      return R;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(ke) {
      if (i = ke, i !== null) {
        if (M = e.getRenderTarget(), i.addEventListener("select", pe), i.addEventListener("selectstart", pe), i.addEventListener("selectend", pe), i.addEventListener("squeeze", pe), i.addEventListener("squeezestart", pe), i.addEventListener("squeezeend", pe), i.addEventListener("end", Ae), i.addEventListener("inputsourceschange", Te), x.xrCompatible !== !0 && await t.makeXRCompatible(), U = e.getPixelRatio(), e.getSize(P), i.renderState.layers === void 0) {
          const ot = {
            antialias: x.antialias,
            alpha: !0,
            depth: x.depth,
            stencil: x.stencil,
            framebufferScaleFactor: o
          };
          S = new XRWebGLLayer(i, t, ot), i.updateRenderState({ baseLayer: S }), e.setPixelRatio(1), e.setSize(S.framebufferWidth, S.framebufferHeight, !1), T = new EC(
            S.framebufferWidth,
            S.framebufferHeight,
            {
              format: rg,
              type: _h,
              colorSpace: e.outputColorSpace,
              stencilBuffer: x.stencil
            }
          );
        } else {
          let ot = null, wt = null, St = null;
          x.depth && (St = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ot = x.stencil ? vb : cb, wt = x.stencil ? Ab : Hm);
          const ln = {
            colorFormat: t.RGBA8,
            depthFormat: St,
            scaleFactor: o
          };
          v = new XRWebGLBinding(i, t), b = v.createProjectionLayer(ln), i.updateRenderState({ layers: [b] }), e.setPixelRatio(1), e.setSize(b.textureWidth, b.textureHeight, !1), T = new EC(
            b.textureWidth,
            b.textureHeight,
            {
              format: rg,
              type: _h,
              depthTexture: new vW(b.textureWidth, b.textureHeight, wt, void 0, void 0, void 0, void 0, void 0, void 0, ot),
              stencilBuffer: x.stencil,
              colorSpace: e.outputColorSpace,
              samples: x.antialias ? 4 : 0,
              resolveDepthBuffer: b.ignoreDepthValues === !1
            }
          );
        }
        T.isXRRenderTarget = !0, this.setFoveation(I), f = null, l = await i.requestReferenceSpace(u), $e.setContext(i), $e.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return W.getDepthTexture();
    };
    function Te(ke) {
      for (let ot = 0; ot < ke.removed.length; ot++) {
        const wt = ke.removed[ot], St = _.indexOf(wt);
        St >= 0 && (_[St] = null, E[St].disconnect(wt));
      }
      for (let ot = 0; ot < ke.added.length; ot++) {
        const wt = ke.added[ot];
        let St = _.indexOf(wt);
        if (St === -1) {
          for (let hn = 0; hn < E.length; hn++)
            if (hn >= _.length) {
              _.push(wt), St = hn;
              break;
            } else if (_[hn] === null) {
              _[hn] = wt, St = hn;
              break;
            }
          if (St === -1) break;
        }
        const ln = E[St];
        ln && ln.connect(wt);
      }
    }
    const Ke = new Ze(), je = new Ze();
    function ee(ke, ot, wt) {
      Ke.setFromMatrixPosition(ot.matrixWorld), je.setFromMatrixPosition(wt.matrixWorld);
      const St = Ke.distanceTo(je), ln = ot.projectionMatrix.elements, hn = wt.projectionMatrix.elements, mn = ln[14] / (ln[10] - 1), Pn = ln[14] / (ln[10] + 1), he = (ln[9] + 1) / ln[5], Lt = (ln[9] - 1) / ln[5], Wt = (ln[8] - 1) / ln[0], tn = (hn[8] + 1) / hn[0], Gt = mn * Wt, Rn = mn * tn, nn = St / (-Wt + tn), Bn = nn * -Wt;
      ot.matrixWorld.decompose(ke.position, ke.quaternion, ke.scale), ke.translateX(Bn), ke.translateZ(nn), ke.matrixWorld.compose(ke.position, ke.quaternion, ke.scale), ke.matrixWorldInverse.copy(ke.matrixWorld).invert();
      const Se = mn + nn, oe = Pn + nn, ct = Gt - Bn, Ft = Rn + (St - Bn), pt = he * Pn / oe * Se, zt = Lt * Pn / oe * Se;
      ke.projectionMatrix.makePerspective(ct, Ft, pt, zt, Se, oe), ke.projectionMatrixInverse.copy(ke.projectionMatrix).invert();
    }
    function Ce(ke, ot) {
      ot === null ? ke.matrixWorld.copy(ke.matrix) : ke.matrixWorld.multiplyMatrices(ot.matrixWorld, ke.matrix), ke.matrixWorldInverse.copy(ke.matrixWorld).invert();
    }
    this.updateCamera = function(ke) {
      if (i === null) return;
      W.texture !== null && (ke.near = W.depthNear, ke.far = W.depthFar), J.near = k.near = q.near = ke.near, J.far = k.far = q.far = ke.far, (te !== J.near || fe !== J.far) && (i.updateRenderState({
        depthNear: J.near,
        depthFar: J.far
      }), te = J.near, fe = J.far, q.near = te, q.far = fe, k.near = te, k.far = fe, q.updateProjectionMatrix(), k.updateProjectionMatrix(), ke.updateProjectionMatrix());
      const ot = ke.parent, wt = J.cameras;
      Ce(J, ot);
      for (let St = 0; St < wt.length; St++)
        Ce(wt[St], ot);
      wt.length === 2 ? ee(J, q, k) : J.projectionMatrix.copy(q.projectionMatrix), be(ke, J, ot);
    };
    function be(ke, ot, wt) {
      wt === null ? ke.matrix.copy(ot.matrixWorld) : (ke.matrix.copy(wt.matrixWorld), ke.matrix.invert(), ke.matrix.multiply(ot.matrixWorld)), ke.matrix.decompose(ke.position, ke.quaternion, ke.scale), ke.updateMatrixWorld(!0), ke.projectionMatrix.copy(ot.projectionMatrix), ke.projectionMatrixInverse.copy(ot.projectionMatrixInverse), ke.isPerspectiveCamera && (ke.fov = $G * 2 * Math.atan(1 / ke.projectionMatrix.elements[5]), ke.zoom = 1);
    }
    this.getCamera = function() {
      return J;
    }, this.getFoveation = function() {
      if (!(b === null && S === null))
        return I;
    }, this.setFoveation = function(ke) {
      I = ke, b !== null && (b.fixedFoveation = ke), S !== null && S.fixedFoveation !== void 0 && (S.fixedFoveation = ke);
    }, this.hasDepthSensing = function() {
      return W.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return W.getMesh(J);
    };
    let le = null;
    function Ye(ke, ot) {
      if (h = ot.getViewerPose(f || l), R = ot, h !== null) {
        const wt = h.views;
        S !== null && (e.setRenderTargetFramebuffer(T, S.framebuffer), e.setRenderTarget(T));
        let St = !1;
        wt.length !== J.cameras.length && (J.cameras.length = 0, St = !0);
        for (let hn = 0; hn < wt.length; hn++) {
          const mn = wt[hn];
          let Pn = null;
          if (S !== null)
            Pn = S.getViewport(mn);
          else {
            const Lt = v.getViewSubImage(b, mn);
            Pn = Lt.viewport, hn === 0 && (e.setRenderTargetTextures(
              T,
              Lt.colorTexture,
              b.ignoreDepthValues ? void 0 : Lt.depthStencilTexture
            ), e.setRenderTarget(T));
          }
          let he = O[hn];
          he === void 0 && (he = new tl(), he.layers.enable(hn), he.viewport = new ro(), O[hn] = he), he.matrix.fromArray(mn.transform.matrix), he.matrix.decompose(he.position, he.quaternion, he.scale), he.projectionMatrix.fromArray(mn.projectionMatrix), he.projectionMatrixInverse.copy(he.projectionMatrix).invert(), he.viewport.set(Pn.x, Pn.y, Pn.width, Pn.height), hn === 0 && (J.matrix.copy(he.matrix), J.matrix.decompose(J.position, J.quaternion, J.scale)), St === !0 && J.cameras.push(he);
        }
        const ln = i.enabledFeatures;
        if (ln && ln.includes("depth-sensing")) {
          const hn = v.getDepthInformation(wt[0]);
          hn && hn.isValid && hn.texture && W.init(e, hn, i.renderState);
        }
      }
      for (let wt = 0; wt < E.length; wt++) {
        const St = _[wt], ln = E[wt];
        St !== null && ln !== void 0 && ln.update(St, ot, f || l);
      }
      le && le(ke, ot), ot.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: ot }), R = null;
    }
    const $e = new Tz();
    $e.setAnimationLoop(Ye), this.setAnimationLoop = function(ke) {
      le = ke;
    }, this.dispose = function() {
    };
  }
}
const Ey = /* @__PURE__ */ new Kd(), uq = /* @__PURE__ */ new tr();
function cq(a, e) {
  function t(x, M) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), M.value.copy(x.matrix);
  }
  function n(x, M) {
    M.color.getRGB(x.fogColor.value, Xz(a)), M.isFog ? (x.fogNear.value = M.near, x.fogFar.value = M.far) : M.isFogExp2 && (x.fogDensity.value = M.density);
  }
  function i(x, M, T, E, _) {
    M.isMeshBasicMaterial || M.isMeshLambertMaterial ? o(x, M) : M.isMeshToonMaterial ? (o(x, M), v(x, M)) : M.isMeshPhongMaterial ? (o(x, M), h(x, M)) : M.isMeshStandardMaterial ? (o(x, M), b(x, M), M.isMeshPhysicalMaterial && S(x, M, _)) : M.isMeshMatcapMaterial ? (o(x, M), R(x, M)) : M.isMeshDepthMaterial ? o(x, M) : M.isMeshDistanceMaterial ? (o(x, M), W(x, M)) : M.isMeshNormalMaterial ? o(x, M) : M.isLineBasicMaterial ? (l(x, M), M.isLineDashedMaterial && u(x, M)) : M.isPointsMaterial ? I(x, M, T, E) : M.isSpriteMaterial ? f(x, M) : M.isShadowMaterial ? (x.color.value.copy(M.color), x.opacity.value = M.opacity) : M.isShaderMaterial && (M.uniformsNeedUpdate = !1);
  }
  function o(x, M) {
    x.opacity.value = M.opacity, M.color && x.diffuse.value.copy(M.color), M.emissive && x.emissive.value.copy(M.emissive).multiplyScalar(M.emissiveIntensity), M.map && (x.map.value = M.map, t(M.map, x.mapTransform)), M.alphaMap && (x.alphaMap.value = M.alphaMap, t(M.alphaMap, x.alphaMapTransform)), M.bumpMap && (x.bumpMap.value = M.bumpMap, t(M.bumpMap, x.bumpMapTransform), x.bumpScale.value = M.bumpScale, M.side === Dg && (x.bumpScale.value *= -1)), M.normalMap && (x.normalMap.value = M.normalMap, t(M.normalMap, x.normalMapTransform), x.normalScale.value.copy(M.normalScale), M.side === Dg && x.normalScale.value.negate()), M.displacementMap && (x.displacementMap.value = M.displacementMap, t(M.displacementMap, x.displacementMapTransform), x.displacementScale.value = M.displacementScale, x.displacementBias.value = M.displacementBias), M.emissiveMap && (x.emissiveMap.value = M.emissiveMap, t(M.emissiveMap, x.emissiveMapTransform)), M.specularMap && (x.specularMap.value = M.specularMap, t(M.specularMap, x.specularMapTransform)), M.alphaTest > 0 && (x.alphaTest.value = M.alphaTest);
    const T = e.get(M), E = T.envMap, _ = T.envMapRotation;
    E && (x.envMap.value = E, Ey.copy(_), Ey.x *= -1, Ey.y *= -1, Ey.z *= -1, E.isCubeTexture && E.isRenderTargetTexture === !1 && (Ey.y *= -1, Ey.z *= -1), x.envMapRotation.value.setFromMatrix4(uq.makeRotationFromEuler(Ey)), x.flipEnvMap.value = E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1, x.reflectivity.value = M.reflectivity, x.ior.value = M.ior, x.refractionRatio.value = M.refractionRatio), M.lightMap && (x.lightMap.value = M.lightMap, x.lightMapIntensity.value = M.lightMapIntensity, t(M.lightMap, x.lightMapTransform)), M.aoMap && (x.aoMap.value = M.aoMap, x.aoMapIntensity.value = M.aoMapIntensity, t(M.aoMap, x.aoMapTransform));
  }
  function l(x, M) {
    x.diffuse.value.copy(M.color), x.opacity.value = M.opacity, M.map && (x.map.value = M.map, t(M.map, x.mapTransform));
  }
  function u(x, M) {
    x.dashSize.value = M.dashSize, x.totalSize.value = M.dashSize + M.gapSize, x.scale.value = M.scale;
  }
  function I(x, M, T, E) {
    x.diffuse.value.copy(M.color), x.opacity.value = M.opacity, x.size.value = M.size * T, x.scale.value = E * 0.5, M.map && (x.map.value = M.map, t(M.map, x.uvTransform)), M.alphaMap && (x.alphaMap.value = M.alphaMap, t(M.alphaMap, x.alphaMapTransform)), M.alphaTest > 0 && (x.alphaTest.value = M.alphaTest);
  }
  function f(x, M) {
    x.diffuse.value.copy(M.color), x.opacity.value = M.opacity, x.rotation.value = M.rotation, M.map && (x.map.value = M.map, t(M.map, x.mapTransform)), M.alphaMap && (x.alphaMap.value = M.alphaMap, t(M.alphaMap, x.alphaMapTransform)), M.alphaTest > 0 && (x.alphaTest.value = M.alphaTest);
  }
  function h(x, M) {
    x.specular.value.copy(M.specular), x.shininess.value = Math.max(M.shininess, 1e-4);
  }
  function v(x, M) {
    M.gradientMap && (x.gradientMap.value = M.gradientMap);
  }
  function b(x, M) {
    x.metalness.value = M.metalness, M.metalnessMap && (x.metalnessMap.value = M.metalnessMap, t(M.metalnessMap, x.metalnessMapTransform)), x.roughness.value = M.roughness, M.roughnessMap && (x.roughnessMap.value = M.roughnessMap, t(M.roughnessMap, x.roughnessMapTransform)), M.envMap && (x.envMapIntensity.value = M.envMapIntensity);
  }
  function S(x, M, T) {
    x.ior.value = M.ior, M.sheen > 0 && (x.sheenColor.value.copy(M.sheenColor).multiplyScalar(M.sheen), x.sheenRoughness.value = M.sheenRoughness, M.sheenColorMap && (x.sheenColorMap.value = M.sheenColorMap, t(M.sheenColorMap, x.sheenColorMapTransform)), M.sheenRoughnessMap && (x.sheenRoughnessMap.value = M.sheenRoughnessMap, t(M.sheenRoughnessMap, x.sheenRoughnessMapTransform))), M.clearcoat > 0 && (x.clearcoat.value = M.clearcoat, x.clearcoatRoughness.value = M.clearcoatRoughness, M.clearcoatMap && (x.clearcoatMap.value = M.clearcoatMap, t(M.clearcoatMap, x.clearcoatMapTransform)), M.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = M.clearcoatRoughnessMap, t(M.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)), M.clearcoatNormalMap && (x.clearcoatNormalMap.value = M.clearcoatNormalMap, t(M.clearcoatNormalMap, x.clearcoatNormalMapTransform), x.clearcoatNormalScale.value.copy(M.clearcoatNormalScale), M.side === Dg && x.clearcoatNormalScale.value.negate())), M.dispersion > 0 && (x.dispersion.value = M.dispersion), M.iridescence > 0 && (x.iridescence.value = M.iridescence, x.iridescenceIOR.value = M.iridescenceIOR, x.iridescenceThicknessMinimum.value = M.iridescenceThicknessRange[0], x.iridescenceThicknessMaximum.value = M.iridescenceThicknessRange[1], M.iridescenceMap && (x.iridescenceMap.value = M.iridescenceMap, t(M.iridescenceMap, x.iridescenceMapTransform)), M.iridescenceThicknessMap && (x.iridescenceThicknessMap.value = M.iridescenceThicknessMap, t(M.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))), M.transmission > 0 && (x.transmission.value = M.transmission, x.transmissionSamplerMap.value = T.texture, x.transmissionSamplerSize.value.set(T.width, T.height), M.transmissionMap && (x.transmissionMap.value = M.transmissionMap, t(M.transmissionMap, x.transmissionMapTransform)), x.thickness.value = M.thickness, M.thicknessMap && (x.thicknessMap.value = M.thicknessMap, t(M.thicknessMap, x.thicknessMapTransform)), x.attenuationDistance.value = M.attenuationDistance, x.attenuationColor.value.copy(M.attenuationColor)), M.anisotropy > 0 && (x.anisotropyVector.value.set(M.anisotropy * Math.cos(M.anisotropyRotation), M.anisotropy * Math.sin(M.anisotropyRotation)), M.anisotropyMap && (x.anisotropyMap.value = M.anisotropyMap, t(M.anisotropyMap, x.anisotropyMapTransform))), x.specularIntensity.value = M.specularIntensity, x.specularColor.value.copy(M.specularColor), M.specularColorMap && (x.specularColorMap.value = M.specularColorMap, t(M.specularColorMap, x.specularColorMapTransform)), M.specularIntensityMap && (x.specularIntensityMap.value = M.specularIntensityMap, t(M.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function R(x, M) {
    M.matcap && (x.matcap.value = M.matcap);
  }
  function W(x, M) {
    const T = e.get(M).light;
    x.referencePosition.value.setFromMatrixPosition(T.matrixWorld), x.nearDistance.value = T.shadow.camera.near, x.farDistance.value = T.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i
  };
}
function gq(a, e, t, n) {
  let i = {}, o = {}, l = [];
  const u = a.getParameter(a.MAX_UNIFORM_BUFFER_BINDINGS);
  function I(T, E) {
    const _ = E.program;
    n.uniformBlockBinding(T, _);
  }
  function f(T, E) {
    let _ = i[T.id];
    _ === void 0 && (R(T), _ = h(T), i[T.id] = _, T.addEventListener("dispose", x));
    const P = E.program;
    n.updateUBOMapping(T, P);
    const U = e.render.frame;
    o[T.id] !== U && (b(T), o[T.id] = U);
  }
  function h(T) {
    const E = v();
    T.__bindingPointIndex = E;
    const _ = a.createBuffer(), P = T.__size, U = T.usage;
    return a.bindBuffer(a.UNIFORM_BUFFER, _), a.bufferData(a.UNIFORM_BUFFER, P, U), a.bindBuffer(a.UNIFORM_BUFFER, null), a.bindBufferBase(a.UNIFORM_BUFFER, E, _), _;
  }
  function v() {
    for (let T = 0; T < u; T++)
      if (l.indexOf(T) === -1)
        return l.push(T), T;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function b(T) {
    const E = i[T.id], _ = T.uniforms, P = T.__cache;
    a.bindBuffer(a.UNIFORM_BUFFER, E);
    for (let U = 0, q = _.length; U < q; U++) {
      const k = Array.isArray(_[U]) ? _[U] : [_[U]];
      for (let O = 0, J = k.length; O < J; O++) {
        const te = k[O];
        if (S(te, U, O, P) === !0) {
          const fe = te.__offset, pe = Array.isArray(te.value) ? te.value : [te.value];
          let Ae = 0;
          for (let Te = 0; Te < pe.length; Te++) {
            const Ke = pe[Te], je = W(Ke);
            typeof Ke == "number" || typeof Ke == "boolean" ? (te.__data[0] = Ke, a.bufferSubData(a.UNIFORM_BUFFER, fe + Ae, te.__data)) : Ke.isMatrix3 ? (te.__data[0] = Ke.elements[0], te.__data[1] = Ke.elements[1], te.__data[2] = Ke.elements[2], te.__data[3] = 0, te.__data[4] = Ke.elements[3], te.__data[5] = Ke.elements[4], te.__data[6] = Ke.elements[5], te.__data[7] = 0, te.__data[8] = Ke.elements[6], te.__data[9] = Ke.elements[7], te.__data[10] = Ke.elements[8], te.__data[11] = 0) : (Ke.toArray(te.__data, Ae), Ae += je.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          a.bufferSubData(a.UNIFORM_BUFFER, fe, te.__data);
        }
      }
    }
    a.bindBuffer(a.UNIFORM_BUFFER, null);
  }
  function S(T, E, _, P) {
    const U = T.value, q = E + "_" + _;
    if (P[q] === void 0)
      return typeof U == "number" || typeof U == "boolean" ? P[q] = U : P[q] = U.clone(), !0;
    {
      const k = P[q];
      if (typeof U == "number" || typeof U == "boolean") {
        if (k !== U)
          return P[q] = U, !0;
      } else if (k.equals(U) === !1)
        return k.copy(U), !0;
    }
    return !1;
  }
  function R(T) {
    const E = T.uniforms;
    let _ = 0;
    const P = 16;
    for (let q = 0, k = E.length; q < k; q++) {
      const O = Array.isArray(E[q]) ? E[q] : [E[q]];
      for (let J = 0, te = O.length; J < te; J++) {
        const fe = O[J], pe = Array.isArray(fe.value) ? fe.value : [fe.value];
        for (let Ae = 0, Te = pe.length; Ae < Te; Ae++) {
          const Ke = pe[Ae], je = W(Ke), ee = _ % P, Ce = ee % je.boundary, be = ee + Ce;
          _ += Ce, be !== 0 && P - be < je.storage && (_ += P - be), fe.__data = new Float32Array(je.storage / Float32Array.BYTES_PER_ELEMENT), fe.__offset = _, _ += je.storage;
        }
      }
    }
    const U = _ % P;
    return U > 0 && (_ += P - U), T.__size = _, T.__cache = {}, this;
  }
  function W(T) {
    const E = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof T == "number" || typeof T == "boolean" ? (E.boundary = 4, E.storage = 4) : T.isVector2 ? (E.boundary = 8, E.storage = 8) : T.isVector3 || T.isColor ? (E.boundary = 16, E.storage = 12) : T.isVector4 ? (E.boundary = 16, E.storage = 16) : T.isMatrix3 ? (E.boundary = 48, E.storage = 48) : T.isMatrix4 ? (E.boundary = 64, E.storage = 64) : T.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", T), E;
  }
  function x(T) {
    const E = T.target;
    E.removeEventListener("dispose", x);
    const _ = l.indexOf(E.__bindingPointIndex);
    l.splice(_, 1), a.deleteBuffer(i[E.id]), delete i[E.id], delete o[E.id];
  }
  function M() {
    for (const T in i)
      a.deleteBuffer(i[T]);
    l = [], i = {}, o = {};
  }
  return {
    bind: I,
    update: f,
    dispose: M
  };
}
class Uz {
  constructor(e = {}) {
    const {
      canvas: t = Vz(),
      context: n = null,
      depth: i = !0,
      stencil: o = !1,
      alpha: l = !1,
      antialias: u = !1,
      premultipliedAlpha: I = !0,
      preserveDrawingBuffer: f = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: v = !1
    } = e;
    this.isWebGLRenderer = !0;
    let b;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      b = n.getContextAttributes().alpha;
    } else
      b = l;
    const S = new Uint32Array(4), R = new Int32Array(4);
    let W = null, x = null;
    const M = [], T = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = HC, this.toneMapping = sp, this.toneMappingExposure = 1;
    const E = this;
    let _ = !1, P = 0, U = 0, q = null, k = -1, O = null;
    const J = new ro(), te = new ro();
    let fe = null;
    const pe = new hi(0);
    let Ae = 0, Te = t.width, Ke = t.height, je = 1, ee = null, Ce = null;
    const be = new ro(0, 0, Te, Ke), le = new ro(0, 0, Te, Ke);
    let Ye = !1;
    const $e = new Uw();
    let ke = !1, ot = !1;
    const wt = new tr(), St = new Ze(), ln = new ro(), hn = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let mn = !1;
    function Pn() {
      return q === null ? je : 1;
    }
    let he = n;
    function Lt(ae, we) {
      return t.getContext(ae, we);
    }
    try {
      const ae = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: u,
        premultipliedAlpha: I,
        preserveDrawingBuffer: f,
        powerPreference: h,
        failIfMajorPerformanceCaveat: v
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${lW}`), t.addEventListener("webglcontextlost", _e, !1), t.addEventListener("webglcontextrestored", ht, !1), t.addEventListener("webglcontextcreationerror", Ht, !1), he === null) {
        const we = "webgl2";
        if (he = Lt(we, ae), he === null)
          throw Lt(we) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (ae) {
      throw console.error("THREE.WebGLRenderer: " + ae.message), ae;
    }
    let Wt, tn, Gt, Rn, nn, Bn, Se, oe, ct, Ft, pt, zt, Sn, rn, gn, qn, qt, An, Fe, Ie, at, ye, Pe, Ot;
    function Re() {
      Wt = new m7(he), Wt.init(), ye = new kz(he, Wt), tn = new d7(he, Wt, e, ye), Gt = new j8(he), Rn = new y7(he), nn = new T8(), Bn = new iq(he, Wt, Gt, nn, tn, ye, Rn), Se = new C7(E), oe = new p7(E), ct = new RQ(he), Pe = new c7(he, ct), Ft = new A7(he, ct, Rn, Pe), pt = new G7(he, Ft, ct, Rn), Fe = new b7(he, tn, Bn), qn = new I7(nn), zt = new E8(E, Se, oe, Wt, tn, Pe, qn), Sn = new cq(E, nn), rn = new z8(), gn = new O8(Wt), An = new u7(E, Se, oe, Gt, pt, b, I), qt = new Q8(E, pt, tn), Ot = new gq(he, Rn, tn, Gt), Ie = new g7(he, Wt, Rn), at = new v7(he, Wt, Rn), Rn.programs = zt.programs, E.capabilities = tn, E.extensions = Wt, E.properties = nn, E.renderLists = rn, E.shadowMap = qt, E.state = Gt, E.info = Rn;
    }
    Re();
    const lt = new lq(E, he);
    this.xr = lt, this.getContext = function() {
      return he;
    }, this.getContextAttributes = function() {
      return he.getContextAttributes();
    }, this.forceContextLoss = function() {
      const ae = Wt.get("WEBGL_lose_context");
      ae && ae.loseContext();
    }, this.forceContextRestore = function() {
      const ae = Wt.get("WEBGL_lose_context");
      ae && ae.restoreContext();
    }, this.getPixelRatio = function() {
      return je;
    }, this.setPixelRatio = function(ae) {
      ae !== void 0 && (je = ae, this.setSize(Te, Ke, !1));
    }, this.getSize = function(ae) {
      return ae.set(Te, Ke);
    }, this.setSize = function(ae, we, Ee = !0) {
      if (lt.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      Te = ae, Ke = we, t.width = Math.floor(ae * je), t.height = Math.floor(we * je), Ee === !0 && (t.style.width = ae + "px", t.style.height = we + "px"), this.setViewport(0, 0, ae, we);
    }, this.getDrawingBufferSize = function(ae) {
      return ae.set(Te * je, Ke * je).floor();
    }, this.setDrawingBufferSize = function(ae, we, Ee) {
      Te = ae, Ke = we, je = Ee, t.width = Math.floor(ae * Ee), t.height = Math.floor(we * Ee), this.setViewport(0, 0, ae, we);
    }, this.getCurrentViewport = function(ae) {
      return ae.copy(J);
    }, this.getViewport = function(ae) {
      return ae.copy(be);
    }, this.setViewport = function(ae, we, Ee, Ue) {
      ae.isVector4 ? be.set(ae.x, ae.y, ae.z, ae.w) : be.set(ae, we, Ee, Ue), Gt.viewport(J.copy(be).multiplyScalar(je).round());
    }, this.getScissor = function(ae) {
      return ae.copy(le);
    }, this.setScissor = function(ae, we, Ee, Ue) {
      ae.isVector4 ? le.set(ae.x, ae.y, ae.z, ae.w) : le.set(ae, we, Ee, Ue), Gt.scissor(te.copy(le).multiplyScalar(je).round());
    }, this.getScissorTest = function() {
      return Ye;
    }, this.setScissorTest = function(ae) {
      Gt.setScissorTest(Ye = ae);
    }, this.setOpaqueSort = function(ae) {
      ee = ae;
    }, this.setTransparentSort = function(ae) {
      Ce = ae;
    }, this.getClearColor = function(ae) {
      return ae.copy(An.getClearColor());
    }, this.setClearColor = function() {
      An.setClearColor.apply(An, arguments);
    }, this.getClearAlpha = function() {
      return An.getClearAlpha();
    }, this.setClearAlpha = function() {
      An.setClearAlpha.apply(An, arguments);
    }, this.clear = function(ae = !0, we = !0, Ee = !0) {
      let Ue = 0;
      if (ae) {
        let Oe = !1;
        if (q !== null) {
          const Nt = q.texture.format;
          Oe = Nt === fW || Nt === hW || Nt === Kw;
        }
        if (Oe) {
          const Nt = q.texture.type, Kt = Nt === _h || Nt === Hm || Nt === qG || Nt === Ab || Nt === dW || Nt === IW, vn = An.getClearColor(), Yt = An.getClearAlpha(), Yn = vn.r, Fn = vn.g, _n = vn.b;
          Kt ? (S[0] = Yn, S[1] = Fn, S[2] = _n, S[3] = Yt, he.clearBufferuiv(he.COLOR, 0, S)) : (R[0] = Yn, R[1] = Fn, R[2] = _n, R[3] = Yt, he.clearBufferiv(he.COLOR, 0, R));
        } else
          Ue |= he.COLOR_BUFFER_BIT;
      }
      we && (Ue |= he.DEPTH_BUFFER_BIT), Ee && (Ue |= he.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), he.clear(Ue);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", _e, !1), t.removeEventListener("webglcontextrestored", ht, !1), t.removeEventListener("webglcontextcreationerror", Ht, !1), rn.dispose(), gn.dispose(), nn.dispose(), Se.dispose(), oe.dispose(), pt.dispose(), Pe.dispose(), Ot.dispose(), zt.dispose(), lt.dispose(), lt.removeEventListener("sessionstart", Cr), lt.removeEventListener("sessionend", Sa), zr.stop();
    };
    function _e(ae) {
      ae.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0;
    }
    function ht() {
      console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
      const ae = Rn.autoReset, we = qt.enabled, Ee = qt.autoUpdate, Ue = qt.needsUpdate, Oe = qt.type;
      Re(), Rn.autoReset = ae, qt.enabled = we, qt.autoUpdate = Ee, qt.needsUpdate = Ue, qt.type = Oe;
    }
    function Ht(ae) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ae.statusMessage);
    }
    function an(ae) {
      const we = ae.target;
      we.removeEventListener("dispose", an), fi(we);
    }
    function fi(ae) {
      xi(ae), nn.remove(ae);
    }
    function xi(ae) {
      const we = nn.get(ae).programs;
      we !== void 0 && (we.forEach(function(Ee) {
        zt.releaseProgram(Ee);
      }), ae.isShaderMaterial && zt.releaseShaderCache(ae));
    }
    this.renderBufferDirect = function(ae, we, Ee, Ue, Oe, Nt) {
      we === null && (we = hn);
      const Kt = Oe.isMesh && Oe.matrixWorld.determinant() < 0, vn = ut(ae, we, Ee, Ue, Oe);
      Gt.setMaterial(Ue, Kt);
      let Yt = Ee.index, Yn = 1;
      if (Ue.wireframe === !0) {
        if (Yt = Ft.getWireframeAttribute(Ee), Yt === void 0) return;
        Yn = 2;
      }
      const Fn = Ee.drawRange, _n = Ee.attributes.position;
      let Xn = Fn.start * Yn, or = (Fn.start + Fn.count) * Yn;
      Nt !== null && (Xn = Math.max(Xn, Nt.start * Yn), or = Math.min(or, (Nt.start + Nt.count) * Yn)), Yt !== null ? (Xn = Math.max(Xn, 0), or = Math.min(or, Yt.count)) : _n != null && (Xn = Math.max(Xn, 0), or = Math.min(or, _n.count));
      const Ei = or - Xn;
      if (Ei < 0 || Ei === 1 / 0) return;
      Pe.setup(Oe, Ue, vn, Ee, Yt);
      let pr, Ln = Ie;
      if (Yt !== null && (pr = ct.get(Yt), Ln = at, Ln.setIndex(pr)), Oe.isMesh)
        Ue.wireframe === !0 ? (Gt.setLineWidth(Ue.wireframeLinewidth * Pn()), Ln.setMode(he.LINES)) : Ln.setMode(he.TRIANGLES);
      else if (Oe.isLine) {
        let ge = Ue.linewidth;
        ge === void 0 && (ge = 1), Gt.setLineWidth(ge * Pn()), Oe.isLineSegments ? Ln.setMode(he.LINES) : Oe.isLineLoop ? Ln.setMode(he.LINE_LOOP) : Ln.setMode(he.LINE_STRIP);
      } else Oe.isPoints ? Ln.setMode(he.POINTS) : Oe.isSprite && Ln.setMode(he.TRIANGLES);
      if (Oe.isBatchedMesh)
        if (Oe._multiDrawInstances !== null)
          Ln.renderMultiDrawInstances(Oe._multiDrawStarts, Oe._multiDrawCounts, Oe._multiDrawCount, Oe._multiDrawInstances);
        else if (Wt.get("WEBGL_multi_draw"))
          Ln.renderMultiDraw(Oe._multiDrawStarts, Oe._multiDrawCounts, Oe._multiDrawCount);
        else {
          const ge = Oe._multiDrawStarts, ue = Oe._multiDrawCounts, We = Oe._multiDrawCount, et = Yt ? ct.get(Yt).bytesPerElement : 1, Mt = nn.get(Ue).currentProgram.getUniforms();
          for (let bn = 0; bn < We; bn++)
            Mt.setValue(he, "_gl_DrawID", bn), Ln.render(ge[bn] / et, ue[bn]);
        }
      else if (Oe.isInstancedMesh)
        Ln.renderInstances(Xn, Ei, Oe.count);
      else if (Ee.isInstancedBufferGeometry) {
        const ge = Ee._maxInstanceCount !== void 0 ? Ee._maxInstanceCount : 1 / 0, ue = Math.min(Ee.instanceCount, ge);
        Ln.renderInstances(Xn, Ei, ue);
      } else
        Ln.render(Xn, Ei);
    };
    function Ir(ae, we, Ee) {
      ae.transparent === !0 && ae.side === ep && ae.forceSinglePass === !1 ? (ae.side = Dg, ae.needsUpdate = !0, gt(ae, we, Ee), ae.side = Nm, ae.needsUpdate = !0, gt(ae, we, Ee), ae.side = ep) : gt(ae, we, Ee);
    }
    this.compile = function(ae, we, Ee = null) {
      Ee === null && (Ee = ae), x = gn.get(Ee), x.init(we), T.push(x), Ee.traverseVisible(function(Oe) {
        Oe.isLight && Oe.layers.test(we.layers) && (x.pushLight(Oe), Oe.castShadow && x.pushShadow(Oe));
      }), ae !== Ee && ae.traverseVisible(function(Oe) {
        Oe.isLight && Oe.layers.test(we.layers) && (x.pushLight(Oe), Oe.castShadow && x.pushShadow(Oe));
      }), x.setupLights();
      const Ue = /* @__PURE__ */ new Set();
      return ae.traverse(function(Oe) {
        const Nt = Oe.material;
        if (Nt)
          if (Array.isArray(Nt))
            for (let Kt = 0; Kt < Nt.length; Kt++) {
              const vn = Nt[Kt];
              Ir(vn, Ee, Oe), Ue.add(vn);
            }
          else
            Ir(Nt, Ee, Oe), Ue.add(Nt);
      }), T.pop(), x = null, Ue;
    }, this.compileAsync = function(ae, we, Ee = null) {
      const Ue = this.compile(ae, we, Ee);
      return new Promise((Oe) => {
        function Nt() {
          if (Ue.forEach(function(Kt) {
            nn.get(Kt).currentProgram.isReady() && Ue.delete(Kt);
          }), Ue.size === 0) {
            Oe(ae);
            return;
          }
          setTimeout(Nt, 10);
        }
        Wt.get("KHR_parallel_shader_compile") !== null ? Nt() : setTimeout(Nt, 10);
      });
    };
    let Xi = null;
    function pi(ae) {
      Xi && Xi(ae);
    }
    function Cr() {
      zr.stop();
    }
    function Sa() {
      zr.start();
    }
    const zr = new Tz();
    zr.setAnimationLoop(pi), typeof self < "u" && zr.setContext(self), this.setAnimationLoop = function(ae) {
      Xi = ae, lt.setAnimationLoop(ae), ae === null ? zr.stop() : zr.start();
    }, lt.addEventListener("sessionstart", Cr), lt.addEventListener("sessionend", Sa), this.render = function(ae, we) {
      if (we !== void 0 && we.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_ === !0) return;
      if (ae.matrixWorldAutoUpdate === !0 && ae.updateMatrixWorld(), we.parent === null && we.matrixWorldAutoUpdate === !0 && we.updateMatrixWorld(), lt.enabled === !0 && lt.isPresenting === !0 && (lt.cameraAutoUpdate === !0 && lt.updateCamera(we), we = lt.getCamera()), ae.isScene === !0 && ae.onBeforeRender(E, ae, we, q), x = gn.get(ae, T.length), x.init(we), T.push(x), wt.multiplyMatrices(we.projectionMatrix, we.matrixWorldInverse), $e.setFromProjectionMatrix(wt), ot = this.localClippingEnabled, ke = qn.init(this.clippingPlanes, ot), W = rn.get(ae, M.length), W.init(), M.push(W), lt.enabled === !0 && lt.isPresenting === !0) {
        const Nt = E.xr.getDepthSensingMesh();
        Nt !== null && na(Nt, we, -1 / 0, E.sortObjects);
      }
      na(ae, we, 0, E.sortObjects), W.finish(), E.sortObjects === !0 && W.sort(ee, Ce), mn = lt.enabled === !1 || lt.isPresenting === !1 || lt.hasDepthSensing() === !1, mn && An.addToRenderList(W, ae), this.info.render.frame++, ke === !0 && qn.beginShadows();
      const Ee = x.state.shadowsArray;
      qt.render(Ee, ae, we), ke === !0 && qn.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const Ue = W.opaque, Oe = W.transmissive;
      if (x.setupLights(), we.isArrayCamera) {
        const Nt = we.cameras;
        if (Oe.length > 0)
          for (let Kt = 0, vn = Nt.length; Kt < vn; Kt++) {
            const Yt = Nt[Kt];
            Oa(Ue, Oe, ae, Yt);
          }
        mn && An.render(ae);
        for (let Kt = 0, vn = Nt.length; Kt < vn; Kt++) {
          const Yt = Nt[Kt];
          la(W, ae, Yt, Yt.viewport);
        }
      } else
        Oe.length > 0 && Oa(Ue, Oe, ae, we), mn && An.render(ae), la(W, ae, we);
      q !== null && (Bn.updateMultisampleRenderTarget(q), Bn.updateRenderTargetMipmap(q)), ae.isScene === !0 && ae.onAfterRender(E, ae, we), Pe.resetDefaultState(), k = -1, O = null, T.pop(), T.length > 0 ? (x = T[T.length - 1], ke === !0 && qn.setGlobalState(E.clippingPlanes, x.state.camera)) : x = null, M.pop(), M.length > 0 ? W = M[M.length - 1] : W = null;
    };
    function na(ae, we, Ee, Ue) {
      if (ae.visible === !1) return;
      if (ae.layers.test(we.layers)) {
        if (ae.isGroup)
          Ee = ae.renderOrder;
        else if (ae.isLOD)
          ae.autoUpdate === !0 && ae.update(we);
        else if (ae.isLight)
          x.pushLight(ae), ae.castShadow && x.pushShadow(ae);
        else if (ae.isSprite) {
          if (!ae.frustumCulled || $e.intersectsSprite(ae)) {
            Ue && ln.setFromMatrixPosition(ae.matrixWorld).applyMatrix4(wt);
            const Kt = pt.update(ae), vn = ae.material;
            vn.visible && W.push(ae, Kt, vn, Ee, ln.z, null);
          }
        } else if ((ae.isMesh || ae.isLine || ae.isPoints) && (!ae.frustumCulled || $e.intersectsObject(ae))) {
          const Kt = pt.update(ae), vn = ae.material;
          if (Ue && (ae.boundingSphere !== void 0 ? (ae.boundingSphere === null && ae.computeBoundingSphere(), ln.copy(ae.boundingSphere.center)) : (Kt.boundingSphere === null && Kt.computeBoundingSphere(), ln.copy(Kt.boundingSphere.center)), ln.applyMatrix4(ae.matrixWorld).applyMatrix4(wt)), Array.isArray(vn)) {
            const Yt = Kt.groups;
            for (let Yn = 0, Fn = Yt.length; Yn < Fn; Yn++) {
              const _n = Yt[Yn], Xn = vn[_n.materialIndex];
              Xn && Xn.visible && W.push(ae, Kt, Xn, Ee, ln.z, _n);
            }
          } else vn.visible && W.push(ae, Kt, vn, Ee, ln.z, null);
        }
      }
      const Nt = ae.children;
      for (let Kt = 0, vn = Nt.length; Kt < vn; Kt++)
        na(Nt[Kt], we, Ee, Ue);
    }
    function la(ae, we, Ee, Ue) {
      const Oe = ae.opaque, Nt = ae.transmissive, Kt = ae.transparent;
      x.setupLightsView(Ee), ke === !0 && qn.setGlobalState(E.clippingPlanes, Ee), Ue && Gt.viewport(J.copy(Ue)), Oe.length > 0 && Le(Oe, we, Ee), Nt.length > 0 && Le(Nt, we, Ee), Kt.length > 0 && Le(Kt, we, Ee), Gt.buffers.depth.setTest(!0), Gt.buffers.depth.setMask(!0), Gt.buffers.color.setMask(!0), Gt.setPolygonOffset(!1);
    }
    function Oa(ae, we, Ee, Ue) {
      if ((Ee.isScene === !0 ? Ee.overrideMaterial : null) !== null)
        return;
      x.state.transmissionRenderTarget[Ue.id] === void 0 && (x.state.transmissionRenderTarget[Ue.id] = new EC(1, 1, {
        generateMipmaps: !0,
        type: Wt.has("EXT_color_buffer_half_float") || Wt.has("EXT_color_buffer_float") ? Zb : _h,
        minFilter: np,
        samples: 4,
        stencilBuffer: o,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Ta.workingColorSpace
      }));
      const Nt = x.state.transmissionRenderTarget[Ue.id], Kt = Ue.viewport || J;
      Nt.setSize(Kt.z, Kt.w);
      const vn = E.getRenderTarget();
      E.setRenderTarget(Nt), E.getClearColor(pe), Ae = E.getClearAlpha(), Ae < 1 && E.setClearColor(16777215, 0.5), E.clear(), mn && An.render(Ee);
      const Yt = E.toneMapping;
      E.toneMapping = sp;
      const Yn = Ue.viewport;
      if (Ue.viewport !== void 0 && (Ue.viewport = void 0), x.setupLightsView(Ue), ke === !0 && qn.setGlobalState(E.clippingPlanes, Ue), Le(ae, Ee, Ue), Bn.updateMultisampleRenderTarget(Nt), Bn.updateRenderTargetMipmap(Nt), Wt.has("WEBGL_multisampled_render_to_texture") === !1) {
        let Fn = !1;
        for (let _n = 0, Xn = we.length; _n < Xn; _n++) {
          const or = we[_n], Ei = or.object, pr = or.geometry, Ln = or.material, ge = or.group;
          if (Ln.side === ep && Ei.layers.test(Ue.layers)) {
            const ue = Ln.side;
            Ln.side = Dg, Ln.needsUpdate = !0, qe(Ei, Ee, Ue, pr, Ln, ge), Ln.side = ue, Ln.needsUpdate = !0, Fn = !0;
          }
        }
        Fn === !0 && (Bn.updateMultisampleRenderTarget(Nt), Bn.updateRenderTargetMipmap(Nt));
      }
      E.setRenderTarget(vn), E.setClearColor(pe, Ae), Yn !== void 0 && (Ue.viewport = Yn), E.toneMapping = Yt;
    }
    function Le(ae, we, Ee) {
      const Ue = we.isScene === !0 ? we.overrideMaterial : null;
      for (let Oe = 0, Nt = ae.length; Oe < Nt; Oe++) {
        const Kt = ae[Oe], vn = Kt.object, Yt = Kt.geometry, Yn = Ue === null ? Kt.material : Ue, Fn = Kt.group;
        vn.layers.test(Ee.layers) && qe(vn, we, Ee, Yt, Yn, Fn);
      }
    }
    function qe(ae, we, Ee, Ue, Oe, Nt) {
      ae.onBeforeRender(E, we, Ee, Ue, Oe, Nt), ae.modelViewMatrix.multiplyMatrices(Ee.matrixWorldInverse, ae.matrixWorld), ae.normalMatrix.getNormalMatrix(ae.modelViewMatrix), Oe.transparent === !0 && Oe.side === ep && Oe.forceSinglePass === !1 ? (Oe.side = Dg, Oe.needsUpdate = !0, E.renderBufferDirect(Ee, we, Ue, Oe, ae, Nt), Oe.side = Nm, Oe.needsUpdate = !0, E.renderBufferDirect(Ee, we, Ue, Oe, ae, Nt), Oe.side = ep) : E.renderBufferDirect(Ee, we, Ue, Oe, ae, Nt), ae.onAfterRender(E, we, Ee, Ue, Oe, Nt);
    }
    function gt(ae, we, Ee) {
      we.isScene !== !0 && (we = hn);
      const Ue = nn.get(ae), Oe = x.state.lights, Nt = x.state.shadowsArray, Kt = Oe.state.version, vn = zt.getParameters(ae, Oe.state, Nt, we, Ee), Yt = zt.getProgramCacheKey(vn);
      let Yn = Ue.programs;
      Ue.environment = ae.isMeshStandardMaterial ? we.environment : null, Ue.fog = we.fog, Ue.envMap = (ae.isMeshStandardMaterial ? oe : Se).get(ae.envMap || Ue.environment), Ue.envMapRotation = Ue.environment !== null && ae.envMap === null ? we.environmentRotation : ae.envMapRotation, Yn === void 0 && (ae.addEventListener("dispose", an), Yn = /* @__PURE__ */ new Map(), Ue.programs = Yn);
      let Fn = Yn.get(Yt);
      if (Fn !== void 0) {
        if (Ue.currentProgram === Fn && Ue.lightsStateVersion === Kt)
          return me(ae, vn), Fn;
      } else
        vn.uniforms = zt.getUniforms(ae), ae.onBeforeCompile(vn, E), Fn = zt.acquireProgram(vn, Yt), Yn.set(Yt, Fn), Ue.uniforms = vn.uniforms;
      const _n = Ue.uniforms;
      return (!ae.isShaderMaterial && !ae.isRawShaderMaterial || ae.clipping === !0) && (_n.clippingPlanes = qn.uniform), me(ae, vn), Ue.needsLights = Tt(ae), Ue.lightsStateVersion = Kt, Ue.needsLights && (_n.ambientLightColor.value = Oe.state.ambient, _n.lightProbe.value = Oe.state.probe, _n.directionalLights.value = Oe.state.directional, _n.directionalLightShadows.value = Oe.state.directionalShadow, _n.spotLights.value = Oe.state.spot, _n.spotLightShadows.value = Oe.state.spotShadow, _n.rectAreaLights.value = Oe.state.rectArea, _n.ltc_1.value = Oe.state.rectAreaLTC1, _n.ltc_2.value = Oe.state.rectAreaLTC2, _n.pointLights.value = Oe.state.point, _n.pointLightShadows.value = Oe.state.pointShadow, _n.hemisphereLights.value = Oe.state.hemi, _n.directionalShadowMap.value = Oe.state.directionalShadowMap, _n.directionalShadowMatrix.value = Oe.state.directionalShadowMatrix, _n.spotShadowMap.value = Oe.state.spotShadowMap, _n.spotLightMatrix.value = Oe.state.spotLightMatrix, _n.spotLightMap.value = Oe.state.spotLightMap, _n.pointShadowMap.value = Oe.state.pointShadowMap, _n.pointShadowMatrix.value = Oe.state.pointShadowMatrix), Ue.currentProgram = Fn, Ue.uniformsList = null, Fn;
    }
    function Pt(ae) {
      if (ae.uniformsList === null) {
        const we = ae.currentProgram.getUniforms();
        ae.uniformsList = Q1.seqWithValue(we.seq, ae.uniforms);
      }
      return ae.uniformsList;
    }
    function me(ae, we) {
      const Ee = nn.get(ae);
      Ee.outputColorSpace = we.outputColorSpace, Ee.batching = we.batching, Ee.batchingColor = we.batchingColor, Ee.instancing = we.instancing, Ee.instancingColor = we.instancingColor, Ee.instancingMorph = we.instancingMorph, Ee.skinning = we.skinning, Ee.morphTargets = we.morphTargets, Ee.morphNormals = we.morphNormals, Ee.morphColors = we.morphColors, Ee.morphTargetsCount = we.morphTargetsCount, Ee.numClippingPlanes = we.numClippingPlanes, Ee.numIntersection = we.numClipIntersection, Ee.vertexAlphas = we.vertexAlphas, Ee.vertexTangents = we.vertexTangents, Ee.toneMapping = we.toneMapping;
    }
    function ut(ae, we, Ee, Ue, Oe) {
      we.isScene !== !0 && (we = hn), Bn.resetTextureUnits();
      const Nt = we.fog, Kt = Ue.isMeshStandardMaterial ? we.environment : null, vn = q === null ? E.outputColorSpace : q.isXRRenderTarget === !0 ? q.texture.colorSpace : Tm, Yt = (Ue.isMeshStandardMaterial ? oe : Se).get(Ue.envMap || Kt), Yn = Ue.vertexColors === !0 && !!Ee.attributes.color && Ee.attributes.color.itemSize === 4, Fn = !!Ee.attributes.tangent && (!!Ue.normalMap || Ue.anisotropy > 0), _n = !!Ee.morphAttributes.position, Xn = !!Ee.morphAttributes.normal, or = !!Ee.morphAttributes.color;
      let Ei = sp;
      Ue.toneMapped && (q === null || q.isXRRenderTarget === !0) && (Ei = E.toneMapping);
      const pr = Ee.morphAttributes.position || Ee.morphAttributes.normal || Ee.morphAttributes.color, Ln = pr !== void 0 ? pr.length : 0, ge = nn.get(Ue), ue = x.state.lights;
      if (ke === !0 && (ot === !0 || ae !== O)) {
        const $t = ae === O && Ue.id === k;
        qn.setState(Ue, ae, $t);
      }
      let We = !1;
      Ue.version === ge.__version ? (ge.needsLights && ge.lightsStateVersion !== ue.state.version || ge.outputColorSpace !== vn || Oe.isBatchedMesh && ge.batching === !1 || !Oe.isBatchedMesh && ge.batching === !0 || Oe.isBatchedMesh && ge.batchingColor === !0 && Oe.colorTexture === null || Oe.isBatchedMesh && ge.batchingColor === !1 && Oe.colorTexture !== null || Oe.isInstancedMesh && ge.instancing === !1 || !Oe.isInstancedMesh && ge.instancing === !0 || Oe.isSkinnedMesh && ge.skinning === !1 || !Oe.isSkinnedMesh && ge.skinning === !0 || Oe.isInstancedMesh && ge.instancingColor === !0 && Oe.instanceColor === null || Oe.isInstancedMesh && ge.instancingColor === !1 && Oe.instanceColor !== null || Oe.isInstancedMesh && ge.instancingMorph === !0 && Oe.morphTexture === null || Oe.isInstancedMesh && ge.instancingMorph === !1 && Oe.morphTexture !== null || ge.envMap !== Yt || Ue.fog === !0 && ge.fog !== Nt || ge.numClippingPlanes !== void 0 && (ge.numClippingPlanes !== qn.numPlanes || ge.numIntersection !== qn.numIntersection) || ge.vertexAlphas !== Yn || ge.vertexTangents !== Fn || ge.morphTargets !== _n || ge.morphNormals !== Xn || ge.morphColors !== or || ge.toneMapping !== Ei || ge.morphTargetsCount !== Ln) && (We = !0) : (We = !0, ge.__version = Ue.version);
      let et = ge.currentProgram;
      We === !0 && (et = gt(Ue, we, Oe));
      let Mt = !1, bn = !1, Ai = !1;
      const ve = et.getUniforms(), Be = ge.uniforms;
      if (Gt.useProgram(et.program) && (Mt = !0, bn = !0, Ai = !0), Ue.id !== k && (k = Ue.id, bn = !0), Mt || O !== ae) {
        ve.setValue(he, "projectionMatrix", ae.projectionMatrix), ve.setValue(he, "viewMatrix", ae.matrixWorldInverse);
        const $t = ve.map.cameraPosition;
        $t !== void 0 && $t.setValue(he, St.setFromMatrixPosition(ae.matrixWorld)), tn.logarithmicDepthBuffer && ve.setValue(
          he,
          "logDepthBufFC",
          2 / (Math.log(ae.far + 1) / Math.LN2)
        ), (Ue.isMeshPhongMaterial || Ue.isMeshToonMaterial || Ue.isMeshLambertMaterial || Ue.isMeshBasicMaterial || Ue.isMeshStandardMaterial || Ue.isShaderMaterial) && ve.setValue(he, "isOrthographic", ae.isOrthographicCamera === !0), O !== ae && (O = ae, bn = !0, Ai = !0);
      }
      if (Oe.isSkinnedMesh) {
        ve.setOptional(he, Oe, "bindMatrix"), ve.setOptional(he, Oe, "bindMatrixInverse");
        const $t = Oe.skeleton;
        $t && ($t.boneTexture === null && $t.computeBoneTexture(), ve.setValue(he, "boneTexture", $t.boneTexture, Bn));
      }
      Oe.isBatchedMesh && (ve.setOptional(he, Oe, "batchingTexture"), ve.setValue(he, "batchingTexture", Oe._matricesTexture, Bn), ve.setOptional(he, Oe, "batchingIdTexture"), ve.setValue(he, "batchingIdTexture", Oe._indirectTexture, Bn), ve.setOptional(he, Oe, "batchingColorTexture"), Oe._colorsTexture !== null && ve.setValue(he, "batchingColorTexture", Oe._colorsTexture, Bn));
      const mt = Ee.morphAttributes;
      if ((mt.position !== void 0 || mt.normal !== void 0 || mt.color !== void 0) && Fe.update(Oe, Ee, et), (bn || ge.receiveShadow !== Oe.receiveShadow) && (ge.receiveShadow = Oe.receiveShadow, ve.setValue(he, "receiveShadow", Oe.receiveShadow)), Ue.isMeshGouraudMaterial && Ue.envMap !== null && (Be.envMap.value = Yt, Be.flipEnvMap.value = Yt.isCubeTexture && Yt.isRenderTargetTexture === !1 ? -1 : 1), Ue.isMeshStandardMaterial && Ue.envMap === null && we.environment !== null && (Be.envMapIntensity.value = we.environmentIntensity), bn && (ve.setValue(he, "toneMappingExposure", E.toneMappingExposure), ge.needsLights && Bt(Be, Ai), Nt && Ue.fog === !0 && Sn.refreshFogUniforms(Be, Nt), Sn.refreshMaterialUniforms(Be, Ue, je, Ke, x.state.transmissionRenderTarget[ae.id]), Q1.upload(he, Pt(ge), Be, Bn)), Ue.isShaderMaterial && Ue.uniformsNeedUpdate === !0 && (Q1.upload(he, Pt(ge), Be, Bn), Ue.uniformsNeedUpdate = !1), Ue.isSpriteMaterial && ve.setValue(he, "center", Oe.center), ve.setValue(he, "modelViewMatrix", Oe.modelViewMatrix), ve.setValue(he, "normalMatrix", Oe.normalMatrix), ve.setValue(he, "modelMatrix", Oe.matrixWorld), Ue.isShaderMaterial || Ue.isRawShaderMaterial) {
        const $t = Ue.uniformsGroups;
        for (let In = 0, un = $t.length; In < un; In++) {
          const Bi = $t[In];
          Ot.update(Bi, et), Ot.bind(Bi, et);
        }
      }
      return et;
    }
    function Bt(ae, we) {
      ae.ambientLightColor.needsUpdate = we, ae.lightProbe.needsUpdate = we, ae.directionalLights.needsUpdate = we, ae.directionalLightShadows.needsUpdate = we, ae.pointLights.needsUpdate = we, ae.pointLightShadows.needsUpdate = we, ae.spotLights.needsUpdate = we, ae.spotLightShadows.needsUpdate = we, ae.rectAreaLights.needsUpdate = we, ae.hemisphereLights.needsUpdate = we;
    }
    function Tt(ae) {
      return ae.isMeshLambertMaterial || ae.isMeshToonMaterial || ae.isMeshPhongMaterial || ae.isMeshStandardMaterial || ae.isShadowMaterial || ae.isShaderMaterial && ae.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return P;
    }, this.getActiveMipmapLevel = function() {
      return U;
    }, this.getRenderTarget = function() {
      return q;
    }, this.setRenderTargetTextures = function(ae, we, Ee) {
      nn.get(ae.texture).__webglTexture = we, nn.get(ae.depthTexture).__webglTexture = Ee;
      const Ue = nn.get(ae);
      Ue.__hasExternalTextures = !0, Ue.__autoAllocateDepthBuffer = Ee === void 0, Ue.__autoAllocateDepthBuffer || Wt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Ue.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(ae, we) {
      const Ee = nn.get(ae);
      Ee.__webglFramebuffer = we, Ee.__useDefaultFramebuffer = we === void 0;
    }, this.setRenderTarget = function(ae, we = 0, Ee = 0) {
      q = ae, P = we, U = Ee;
      let Ue = !0, Oe = null, Nt = !1, Kt = !1;
      if (ae) {
        const Yt = nn.get(ae);
        Yt.__useDefaultFramebuffer !== void 0 ? (Gt.bindFramebuffer(he.FRAMEBUFFER, null), Ue = !1) : Yt.__webglFramebuffer === void 0 ? Bn.setupRenderTarget(ae) : Yt.__hasExternalTextures && Bn.rebindTextures(ae, nn.get(ae.texture).__webglTexture, nn.get(ae.depthTexture).__webglTexture);
        const Yn = ae.texture;
        (Yn.isData3DTexture || Yn.isDataArrayTexture || Yn.isCompressedArrayTexture) && (Kt = !0);
        const Fn = nn.get(ae).__webglFramebuffer;
        ae.isWebGLCubeRenderTarget ? (Array.isArray(Fn[we]) ? Oe = Fn[we][Ee] : Oe = Fn[we], Nt = !0) : ae.samples > 0 && Bn.useMultisampledRTT(ae) === !1 ? Oe = nn.get(ae).__webglMultisampledFramebuffer : Array.isArray(Fn) ? Oe = Fn[Ee] : Oe = Fn, J.copy(ae.viewport), te.copy(ae.scissor), fe = ae.scissorTest;
      } else
        J.copy(be).multiplyScalar(je).floor(), te.copy(le).multiplyScalar(je).floor(), fe = Ye;
      if (Gt.bindFramebuffer(he.FRAMEBUFFER, Oe) && Ue && Gt.drawBuffers(ae, Oe), Gt.viewport(J), Gt.scissor(te), Gt.setScissorTest(fe), Nt) {
        const Yt = nn.get(ae.texture);
        he.framebufferTexture2D(he.FRAMEBUFFER, he.COLOR_ATTACHMENT0, he.TEXTURE_CUBE_MAP_POSITIVE_X + we, Yt.__webglTexture, Ee);
      } else if (Kt) {
        const Yt = nn.get(ae.texture), Yn = we || 0;
        he.framebufferTextureLayer(he.FRAMEBUFFER, he.COLOR_ATTACHMENT0, Yt.__webglTexture, Ee || 0, Yn);
      }
      k = -1;
    }, this.readRenderTargetPixels = function(ae, we, Ee, Ue, Oe, Nt, Kt) {
      if (!(ae && ae.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let vn = nn.get(ae).__webglFramebuffer;
      if (ae.isWebGLCubeRenderTarget && Kt !== void 0 && (vn = vn[Kt]), vn) {
        Gt.bindFramebuffer(he.FRAMEBUFFER, vn);
        try {
          const Yt = ae.texture, Yn = Yt.format, Fn = Yt.type;
          if (!tn.textureFormatReadable(Yn)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!tn.textureTypeReadable(Fn)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          we >= 0 && we <= ae.width - Ue && Ee >= 0 && Ee <= ae.height - Oe && he.readPixels(we, Ee, Ue, Oe, ye.convert(Yn), ye.convert(Fn), Nt);
        } finally {
          const Yt = q !== null ? nn.get(q).__webglFramebuffer : null;
          Gt.bindFramebuffer(he.FRAMEBUFFER, Yt);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(ae, we, Ee, Ue, Oe, Nt, Kt) {
      if (!(ae && ae.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let vn = nn.get(ae).__webglFramebuffer;
      if (ae.isWebGLCubeRenderTarget && Kt !== void 0 && (vn = vn[Kt]), vn) {
        Gt.bindFramebuffer(he.FRAMEBUFFER, vn);
        try {
          const Yt = ae.texture, Yn = Yt.format, Fn = Yt.type;
          if (!tn.textureFormatReadable(Yn))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          if (!tn.textureTypeReadable(Fn))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          if (we >= 0 && we <= ae.width - Ue && Ee >= 0 && Ee <= ae.height - Oe) {
            const _n = he.createBuffer();
            he.bindBuffer(he.PIXEL_PACK_BUFFER, _n), he.bufferData(he.PIXEL_PACK_BUFFER, Nt.byteLength, he.STREAM_READ), he.readPixels(we, Ee, Ue, Oe, ye.convert(Yn), ye.convert(Fn), 0), he.flush();
            const Xn = he.fenceSync(he.SYNC_GPU_COMMANDS_COMPLETE, 0);
            await $J(he, Xn, 4);
            try {
              he.bindBuffer(he.PIXEL_PACK_BUFFER, _n), he.getBufferSubData(he.PIXEL_PACK_BUFFER, 0, Nt);
            } finally {
              he.deleteBuffer(_n), he.deleteSync(Xn);
            }
            return Nt;
          }
        } finally {
          const Yt = q !== null ? nn.get(q).__webglFramebuffer : null;
          Gt.bindFramebuffer(he.FRAMEBUFFER, Yt);
        }
      }
    }, this.copyFramebufferToTexture = function(ae, we = null, Ee = 0) {
      ae.isTexture !== !0 && (DG("WebGLRenderer: copyFramebufferToTexture function signature has changed."), we = arguments[0] || null, ae = arguments[1]);
      const Ue = Math.pow(2, -Ee), Oe = Math.floor(ae.image.width * Ue), Nt = Math.floor(ae.image.height * Ue), Kt = we !== null ? we.x : 0, vn = we !== null ? we.y : 0;
      Bn.setTexture2D(ae, 0), he.copyTexSubImage2D(he.TEXTURE_2D, Ee, 0, 0, Kt, vn, Oe, Nt), Gt.unbindTexture();
    }, this.copyTextureToTexture = function(ae, we, Ee = null, Ue = null, Oe = 0) {
      ae.isTexture !== !0 && (DG("WebGLRenderer: copyTextureToTexture function signature has changed."), Ue = arguments[0] || null, ae = arguments[1], we = arguments[2], Oe = arguments[3] || 0, Ee = null);
      let Nt, Kt, vn, Yt, Yn, Fn;
      Ee !== null ? (Nt = Ee.max.x - Ee.min.x, Kt = Ee.max.y - Ee.min.y, vn = Ee.min.x, Yt = Ee.min.y) : (Nt = ae.image.width, Kt = ae.image.height, vn = 0, Yt = 0), Ue !== null ? (Yn = Ue.x, Fn = Ue.y) : (Yn = 0, Fn = 0);
      const _n = ye.convert(we.format), Xn = ye.convert(we.type);
      Bn.setTexture2D(we, 0), he.pixelStorei(he.UNPACK_FLIP_Y_WEBGL, we.flipY), he.pixelStorei(he.UNPACK_PREMULTIPLY_ALPHA_WEBGL, we.premultiplyAlpha), he.pixelStorei(he.UNPACK_ALIGNMENT, we.unpackAlignment);
      const or = he.getParameter(he.UNPACK_ROW_LENGTH), Ei = he.getParameter(he.UNPACK_IMAGE_HEIGHT), pr = he.getParameter(he.UNPACK_SKIP_PIXELS), Ln = he.getParameter(he.UNPACK_SKIP_ROWS), ge = he.getParameter(he.UNPACK_SKIP_IMAGES), ue = ae.isCompressedTexture ? ae.mipmaps[Oe] : ae.image;
      he.pixelStorei(he.UNPACK_ROW_LENGTH, ue.width), he.pixelStorei(he.UNPACK_IMAGE_HEIGHT, ue.height), he.pixelStorei(he.UNPACK_SKIP_PIXELS, vn), he.pixelStorei(he.UNPACK_SKIP_ROWS, Yt), ae.isDataTexture ? he.texSubImage2D(he.TEXTURE_2D, Oe, Yn, Fn, Nt, Kt, _n, Xn, ue.data) : ae.isCompressedTexture ? he.compressedTexSubImage2D(he.TEXTURE_2D, Oe, Yn, Fn, ue.width, ue.height, _n, ue.data) : he.texSubImage2D(he.TEXTURE_2D, Oe, Yn, Fn, Nt, Kt, _n, Xn, ue), he.pixelStorei(he.UNPACK_ROW_LENGTH, or), he.pixelStorei(he.UNPACK_IMAGE_HEIGHT, Ei), he.pixelStorei(he.UNPACK_SKIP_PIXELS, pr), he.pixelStorei(he.UNPACK_SKIP_ROWS, Ln), he.pixelStorei(he.UNPACK_SKIP_IMAGES, ge), Oe === 0 && we.generateMipmaps && he.generateMipmap(he.TEXTURE_2D), Gt.unbindTexture();
    }, this.copyTextureToTexture3D = function(ae, we, Ee = null, Ue = null, Oe = 0) {
      ae.isTexture !== !0 && (DG("WebGLRenderer: copyTextureToTexture3D function signature has changed."), Ee = arguments[0] || null, Ue = arguments[1] || null, ae = arguments[2], we = arguments[3], Oe = arguments[4] || 0);
      let Nt, Kt, vn, Yt, Yn, Fn, _n, Xn, or;
      const Ei = ae.isCompressedTexture ? ae.mipmaps[Oe] : ae.image;
      Ee !== null ? (Nt = Ee.max.x - Ee.min.x, Kt = Ee.max.y - Ee.min.y, vn = Ee.max.z - Ee.min.z, Yt = Ee.min.x, Yn = Ee.min.y, Fn = Ee.min.z) : (Nt = Ei.width, Kt = Ei.height, vn = Ei.depth, Yt = 0, Yn = 0, Fn = 0), Ue !== null ? (_n = Ue.x, Xn = Ue.y, or = Ue.z) : (_n = 0, Xn = 0, or = 0);
      const pr = ye.convert(we.format), Ln = ye.convert(we.type);
      let ge;
      if (we.isData3DTexture)
        Bn.setTexture3D(we, 0), ge = he.TEXTURE_3D;
      else if (we.isDataArrayTexture || we.isCompressedArrayTexture)
        Bn.setTexture2DArray(we, 0), ge = he.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      he.pixelStorei(he.UNPACK_FLIP_Y_WEBGL, we.flipY), he.pixelStorei(he.UNPACK_PREMULTIPLY_ALPHA_WEBGL, we.premultiplyAlpha), he.pixelStorei(he.UNPACK_ALIGNMENT, we.unpackAlignment);
      const ue = he.getParameter(he.UNPACK_ROW_LENGTH), We = he.getParameter(he.UNPACK_IMAGE_HEIGHT), et = he.getParameter(he.UNPACK_SKIP_PIXELS), Mt = he.getParameter(he.UNPACK_SKIP_ROWS), bn = he.getParameter(he.UNPACK_SKIP_IMAGES);
      he.pixelStorei(he.UNPACK_ROW_LENGTH, Ei.width), he.pixelStorei(he.UNPACK_IMAGE_HEIGHT, Ei.height), he.pixelStorei(he.UNPACK_SKIP_PIXELS, Yt), he.pixelStorei(he.UNPACK_SKIP_ROWS, Yn), he.pixelStorei(he.UNPACK_SKIP_IMAGES, Fn), ae.isDataTexture || ae.isData3DTexture ? he.texSubImage3D(ge, Oe, _n, Xn, or, Nt, Kt, vn, pr, Ln, Ei.data) : we.isCompressedArrayTexture ? he.compressedTexSubImage3D(ge, Oe, _n, Xn, or, Nt, Kt, vn, pr, Ei.data) : he.texSubImage3D(ge, Oe, _n, Xn, or, Nt, Kt, vn, pr, Ln, Ei), he.pixelStorei(he.UNPACK_ROW_LENGTH, ue), he.pixelStorei(he.UNPACK_IMAGE_HEIGHT, We), he.pixelStorei(he.UNPACK_SKIP_PIXELS, et), he.pixelStorei(he.UNPACK_SKIP_ROWS, Mt), he.pixelStorei(he.UNPACK_SKIP_IMAGES, bn), Oe === 0 && we.generateMipmaps && he.generateMipmap(ge), Gt.unbindTexture();
    }, this.initRenderTarget = function(ae) {
      nn.get(ae).__webglFramebuffer === void 0 && Bn.setupRenderTarget(ae);
    }, this.initTexture = function(ae) {
      ae.isCubeTexture ? Bn.setTextureCube(ae, 0) : ae.isData3DTexture ? Bn.setTexture3D(ae, 0) : ae.isDataArrayTexture || ae.isCompressedArrayTexture ? Bn.setTexture2DArray(ae, 0) : Bn.setTexture2D(ae, 0), Gt.unbindTexture();
    }, this.resetState = function() {
      P = 0, U = 0, q = null, Gt.reset(), Pe.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return ip;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === mW ? "display-p3" : "srgb", t.unpackColorSpace = Ta.workingColorSpace === Lw ? "display-p3" : "srgb";
  }
}
class bW {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new hi(e), this.density = t;
  }
  clone() {
    return new bW(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class GW {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new hi(e), this.near = t, this.far = n;
  }
  clone() {
    return new GW(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
let Y2 = class extends Aa {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Kd(), this.environmentIntensity = 1, this.environmentRotation = new Kd(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
};
class BW {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = mw, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = zI();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return DG("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = zI()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = zI()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Yg = /* @__PURE__ */ new Ze();
class yb {
  constructor(e, t, n, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Yg.fromBufferAttribute(this, t), Yg.applyMatrix4(e), this.setXYZ(t, Yg.x, Yg.y, Yg.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Yg.fromBufferAttribute(this, t), Yg.applyNormalMatrix(e), this.setXYZ(t, Yg.x, Yg.y, Yg.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Yg.fromBufferAttribute(this, t), Yg.transformDirection(e), this.setXYZ(t, Yg.x, Yg.y, Yg.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = Kg(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = Mr(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
  }
  setX(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = Mr(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Kg(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array), i = Mr(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, o) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Mr(t, this.array), n = Mr(n, this.array), i = Mr(i, this.array), o = Mr(o, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = o, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return new Zo(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new yb(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class _X extends Gc {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new hi(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let BG;
const vZ = /* @__PURE__ */ new Ze(), SG = /* @__PURE__ */ new Ze(), ZG = /* @__PURE__ */ new Ze(), wG = /* @__PURE__ */ new sn(), yZ = /* @__PURE__ */ new sn(), Oz = /* @__PURE__ */ new tr(), u1 = /* @__PURE__ */ new Ze(), bZ = /* @__PURE__ */ new Ze(), c1 = /* @__PURE__ */ new Ze(), LT = /* @__PURE__ */ new sn(), bM = /* @__PURE__ */ new sn(), kT = /* @__PURE__ */ new sn();
class Pz extends Aa {
  constructor(e = new _X()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", BG === void 0) {
      BG = new _r();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new BW(t, 5);
      BG.setIndex([0, 1, 2, 0, 2, 3]), BG.setAttribute("position", new yb(n, 3, 0, !1)), BG.setAttribute("uv", new yb(n, 2, 3, !1));
    }
    this.geometry = BG, this.material = e, this.center = new sn(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), SG.setFromMatrixScale(this.matrixWorld), Oz.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ZG.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && SG.multiplyScalar(-ZG.z);
    const n = this.material.rotation;
    let i, o;
    n !== 0 && (o = Math.cos(n), i = Math.sin(n));
    const l = this.center;
    g1(u1.set(-0.5, -0.5, 0), ZG, l, SG, i, o), g1(bZ.set(0.5, -0.5, 0), ZG, l, SG, i, o), g1(c1.set(0.5, 0.5, 0), ZG, l, SG, i, o), LT.set(0, 0), bM.set(1, 0), kT.set(1, 1);
    let u = e.ray.intersectTriangle(u1, bZ, c1, !1, vZ);
    if (u === null && (g1(bZ.set(-0.5, 0.5, 0), ZG, l, SG, i, o), bM.set(0, 1), u = e.ray.intersectTriangle(u1, c1, bZ, !1, vZ), u === null))
      return;
    const I = e.ray.origin.distanceTo(vZ);
    I < e.near || I > e.far || t.push({
      distance: I,
      point: vZ.clone(),
      uv: EI.getInterpolation(vZ, u1, bZ, c1, LT, bM, kT, new sn()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function g1(a, e, t, n, i, o) {
  wG.subVectors(a, t).addScalar(0.5).multiply(n), i !== void 0 ? (yZ.x = o * wG.x - i * wG.y, yZ.y = i * wG.x + o * wG.y) : yZ.copy(wG), a.copy(e), a.x += yZ.x, a.y += yZ.y, a.applyMatrix4(Oz);
}
const d1 = /* @__PURE__ */ new Ze(), DT = /* @__PURE__ */ new Ze();
class Jz extends Aa {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const o = t[n];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(t < i[o].distance); o++)
      ;
    return i.splice(o, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let o = t[n].distance;
        if (t[n].object.visible && (o -= o * t[n].hysteresis), e < o)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      d1.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(d1);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      d1.setFromMatrixPosition(e.matrixWorld), DT.setFromMatrixPosition(this.matrixWorld);
      const n = d1.distanceTo(DT) / e.zoom;
      t[0].object.visible = !0;
      let i, o;
      for (i = 1, o = t.length; i < o; i++) {
        let l = t[i].distance;
        if (t[i].object.visible && (l -= l * t[i].hysteresis), n >= l)
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < o; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let i = 0, o = n.length; i < o; i++) {
      const l = n[i];
      t.object.levels.push({
        object: l.object.uuid,
        distance: l.distance,
        hysteresis: l.hysteresis
      });
    }
    return t;
  }
}
const UT = /* @__PURE__ */ new Ze(), OT = /* @__PURE__ */ new ro(), PT = /* @__PURE__ */ new ro(), dq = /* @__PURE__ */ new Ze(), JT = /* @__PURE__ */ new tr(), I1 = /* @__PURE__ */ new Ze(), GM = /* @__PURE__ */ new og(), QT = /* @__PURE__ */ new tr(), BM = /* @__PURE__ */ new wb();
class Qz extends Fl {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = SH, this.bindMatrix = new tr(), this.bindMatrixInverse = new tr(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Ug()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, I1), this.boundingBox.expandByPoint(I1);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new og()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, I1), this.boundingSphere.expandByPoint(I1);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, i = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), GM.copy(this.boundingSphere), GM.applyMatrix4(i), e.ray.intersectsSphere(GM) !== !1 && (QT.copy(i).invert(), BM.copy(e.ray).applyMatrix4(QT), !(this.boundingBox !== null && BM.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, BM)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new ro(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === SH ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === hz ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, i = this.geometry;
    OT.fromBufferAttribute(i.attributes.skinIndex, e), PT.fromBufferAttribute(i.attributes.skinWeight, e), UT.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const l = PT.getComponent(o);
      if (l !== 0) {
        const u = OT.getComponent(o);
        JT.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]), t.addScaledVector(dq.copy(UT).applyMatrix4(JT), l);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class zX extends Aa {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class lp extends Fs {
  constructor(e = null, t = 1, n = 1, i, o, l, u, I, f = _u, h = _u, v, b) {
    super(null, l, u, I, f, h, i, o, v, b), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const jT = /* @__PURE__ */ new tr(), Iq = /* @__PURE__ */ new tr();
class SW {
  constructor(e = [], t = []) {
    this.uuid = zI(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new tr());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new tr();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o] ? e[o].matrixWorld : Iq;
      jT.multiplyMatrices(u, t[o]), jT.toArray(n, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new SW(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new lp(t, e, e, rg, kg);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const o = e.bones[n];
      let l = t[o];
      l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", o), l = new zX()), this.bones.push(l), this.boneInverses.push(new tr().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let i = 0, o = t.length; i < o; i++) {
      const l = t[i];
      e.bones.push(l.uuid);
      const u = n[i];
      e.boneInverses.push(u.toArray());
    }
    return e;
  }
}
class tB extends Zo {
  constructor(e, t, n, i = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const RG = /* @__PURE__ */ new tr(), qT = /* @__PURE__ */ new tr(), C1 = [], $T = /* @__PURE__ */ new Ug(), Cq = /* @__PURE__ */ new tr(), GZ = /* @__PURE__ */ new Fl(), BZ = /* @__PURE__ */ new og();
class OG extends Fl {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new tB(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n; i++)
      this.setMatrixAt(i, Cq);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new Ug()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, RG), $T.copy(e.boundingBox).applyMatrix4(RG), this.boundingBox.union($T);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new og()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, RG), BZ.copy(e.boundingSphere).applyMatrix4(RG), this.boundingSphere.union(BZ);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, o = n.length + 1, l = e * o + 1;
    for (let u = 0; u < n.length; u++)
      n[u] = i[l + u];
  }
  raycast(e, t) {
    const n = this.matrixWorld, i = this.count;
    if (GZ.geometry = this.geometry, GZ.material = this.material, GZ.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), BZ.copy(this.boundingSphere), BZ.applyMatrix4(n), e.ray.intersectsSphere(BZ) !== !1))
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, RG), qT.multiplyMatrices(n, RG), GZ.matrixWorld = qT, GZ.raycast(e, C1);
        for (let l = 0, u = C1.length; l < u; l++) {
          const I = C1[l];
          I.instanceId = o, I.object = this, t.push(I);
        }
        C1.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new tB(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences, i = n.length + 1;
    this.morphTexture === null && (this.morphTexture = new lp(new Float32Array(i * this.count), i, this.count, CW, kg));
    const o = this.morphTexture.source.data.data;
    let l = 0;
    for (let f = 0; f < n.length; f++)
      l += n[f];
    const u = this.geometry.morphTargetsRelative ? 1 : 1 - l, I = i * e;
    o[I] = u, o.set(n, I + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
function hq(a, e) {
  return a.z - e.z;
}
function fq(a, e) {
  return e.z - a.z;
}
class pq {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t, n) {
    const i = this.pool, o = this.list;
    this.index >= i.length && i.push({
      start: -1,
      count: -1,
      z: -1,
      index: -1
    });
    const l = i[this.index];
    o.push(l), this.index++, l.start = e.start, l.count = e.count, l.z = t, l.index = n;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const TA = /* @__PURE__ */ new tr(), SM = /* @__PURE__ */ new tr(), mq = /* @__PURE__ */ new tr(), Aq = /* @__PURE__ */ new hi(1, 1, 1), e_ = /* @__PURE__ */ new tr(), ZM = /* @__PURE__ */ new Uw(), h1 = /* @__PURE__ */ new Ug(), Ty = /* @__PURE__ */ new og(), SZ = /* @__PURE__ */ new Ze(), t_ = /* @__PURE__ */ new Ze(), vq = /* @__PURE__ */ new Ze(), wM = /* @__PURE__ */ new pq(), qc = /* @__PURE__ */ new Fl(), f1 = [];
function yq(a, e, t = 0) {
  const n = e.itemSize;
  if (a.isInterleavedBufferAttribute || a.array.constructor !== e.array.constructor) {
    const i = a.count;
    for (let o = 0; o < i; o++)
      for (let l = 0; l < n; l++)
        e.setComponent(o + t, l, a.getComponent(o, l));
  } else
    e.array.set(a.array, t * n);
  e.needsUpdate = !0;
}
class jz extends Fl {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  constructor(e, t, n = t * 2, i) {
    super(new _r(), i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawInfo = [], this._drawRanges = [], this._reservedRanges = [], this._bounds = [], this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new lp(t, e, e, rg, kg);
    this._matricesTexture = n;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e), n = new lp(t, e, e, Kw, Hm);
    this._indirectTexture = n;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxIndexCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1), n = new lp(t, e, e, rg, kg);
    n.colorSpace = Ta.workingColorSpace, this._colorsTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const l = e.getAttribute(o), { array: u, itemSize: I, normalized: f } = l, h = new u.constructor(n * I), v = new Zo(h, I, f);
        t.setAttribute(o, v);
      }
      if (e.getIndex() !== null) {
        const o = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new Zo(o, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (!e.hasAttribute(n))
        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const i = e.getAttribute(n), o = t.getAttribute(n);
      if (i.itemSize !== o.itemSize || i.normalized !== o.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ug());
    const e = this._geometryCount, t = this.boundingBox, n = this._drawInfo;
    t.makeEmpty();
    for (let i = 0; i < e; i++) {
      if (n[i].active === !1) continue;
      const o = n[i].geometryIndex;
      this.getMatrixAt(i, TA), this.getBoundingBoxAt(o, h1).applyMatrix4(TA), t.union(h1);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new og());
    const e = this.boundingSphere, t = this._drawInfo;
    e.makeEmpty();
    for (let n = 0, i = t.length; n < i; n++) {
      if (t[n].active === !1) continue;
      const o = t[n].geometryIndex;
      this.getMatrixAt(n, TA), this.getBoundingSphereAt(o, Ty).applyMatrix4(TA), e.union(Ty);
    }
  }
  addInstance(e) {
    if (this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    this._drawInfo.push({
      visible: !0,
      active: !0,
      geometryIndex: e
    });
    const t = this._drawInfo.length - 1, n = this._matricesTexture, i = n.image.data;
    mq.toArray(i, t * 16), n.needsUpdate = !0;
    const o = this._colorsTexture;
    return o && (Aq.toArray(o.image.data, t * 4), o.needsUpdate = !0), t;
  }
  addGeometry(e, t = -1, n = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1
    };
    let o = null;
    const l = this._reservedRanges, u = this._drawRanges, I = this._bounds;
    this._geometryCount !== 0 && (o = l[l.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, o === null ? i.vertexStart = 0 : i.vertexStart = o.vertexStart + o.vertexCount;
    const f = e.getIndex(), h = f !== null;
    if (h && (n === -1 ? i.indexCount = f.count : i.indexCount = n, o === null ? i.indexStart = 0 : i.indexStart = o.indexStart + o.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const v = this._geometryCount;
    return this._geometryCount++, l.push(i), u.push({
      start: h ? i.indexStart : i.vertexStart,
      count: -1
    }), I.push({
      boxInitialized: !1,
      box: new Ug(),
      sphereInitialized: !1,
      sphere: new og()
    }), this.setGeometryAt(v, e), v;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, i = n.getIndex() !== null, o = n.getIndex(), l = t.getIndex(), u = this._reservedRanges[e];
    if (i && l.count > u.indexCount || t.attributes.position.count > u.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const I = u.vertexStart, f = u.vertexCount;
    for (const S in n.attributes) {
      const R = t.getAttribute(S), W = n.getAttribute(S);
      yq(R, W, I);
      const x = R.itemSize;
      for (let M = R.count, T = f; M < T; M++) {
        const E = I + M;
        for (let _ = 0; _ < x; _++)
          W.setComponent(E, _, 0);
      }
      W.needsUpdate = !0, W.addUpdateRange(I * x, f * x);
    }
    if (i) {
      const S = u.indexStart;
      for (let R = 0; R < l.count; R++)
        o.setX(S + R, I + l.getX(R));
      for (let R = l.count, W = u.indexCount; R < W; R++)
        o.setX(S + R, I);
      o.needsUpdate = !0, o.addUpdateRange(S, u.indexCount);
    }
    const h = this._bounds[e];
    t.boundingBox !== null ? (h.box.copy(t.boundingBox), h.boxInitialized = !0) : h.boxInitialized = !1, t.boundingSphere !== null ? (h.sphere.copy(t.boundingSphere), h.sphereInitialized = !0) : h.sphereInitialized = !1;
    const v = this._drawRanges[e], b = t.getAttribute("position");
    return v.count = i ? l.count : b.count, this._visibilityChanged = !0, e;
  }
  /*
  	deleteGeometry( geometryId ) {
  
  		// TODO: delete geometry and associated instances
  
  	}
  	*/
  /*
  	deleteInstance( instanceId ) {
  
  		// Note: User needs to call optimize() afterward to pack the data.
  
  		const drawInfo = this._drawInfo;
  		if ( instanceId >= drawInfo.length || drawInfo[ instanceId ].active === false ) {
  
  			return this;
  
  		}
  
  		drawInfo[ instanceId ].active = false;
  		this._visibilityChanged = true;
  
  		return this;
  
  	}
  	*/
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const n = this._bounds[e], i = n.box, o = this.geometry;
    if (n.boxInitialized === !1) {
      i.makeEmpty();
      const l = o.index, u = o.attributes.position, I = this._drawRanges[e];
      for (let f = I.start, h = I.start + I.count; f < h; f++) {
        let v = f;
        l && (v = l.getX(v)), i.expandByPoint(SZ.fromBufferAttribute(u, v));
      }
      n.boxInitialized = !0;
    }
    return t.copy(i), t;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const n = this._bounds[e], i = n.sphere, o = this.geometry;
    if (n.sphereInitialized === !1) {
      i.makeEmpty(), this.getBoundingBoxAt(e, h1), h1.getCenter(i.center);
      const l = o.index, u = o.attributes.position, I = this._drawRanges[e];
      let f = 0;
      for (let h = I.start, v = I.start + I.count; h < v; h++) {
        let b = h;
        l && (b = l.getX(b)), SZ.fromBufferAttribute(u, b), f = Math.max(f, i.center.distanceToSquared(SZ));
      }
      i.radius = Math.sqrt(f), n.sphereInitialized = !0;
    }
    return t.copy(i), t;
  }
  setMatrixAt(e, t) {
    const n = this._drawInfo, i = this._matricesTexture, o = this._matricesTexture.image.data;
    return e >= n.length || n[e].active === !1 ? this : (t.toArray(o, e * 16), i.needsUpdate = !0, this);
  }
  getMatrixAt(e, t) {
    const n = this._drawInfo, i = this._matricesTexture.image.data;
    return e >= n.length || n[e].active === !1 ? null : t.fromArray(i, e * 16);
  }
  setColorAt(e, t) {
    this._colorsTexture === null && this._initColorsTexture();
    const n = this._colorsTexture, i = this._colorsTexture.image.data, o = this._drawInfo;
    return e >= o.length || o[e].active === !1 ? this : (t.toArray(i, e * 4), n.needsUpdate = !0, this);
  }
  getColorAt(e, t) {
    const n = this._colorsTexture.image.data, i = this._drawInfo;
    return e >= i.length || i[e].active === !1 ? null : t.fromArray(n, e * 4);
  }
  setVisibleAt(e, t) {
    const n = this._drawInfo;
    return e >= n.length || n[e].active === !1 || n[e].visible === t ? this : (n[e].visible = t, this._visibilityChanged = !0, this);
  }
  getVisibleAt(e) {
    const t = this._drawInfo;
    return e >= t.length || t[e].active === !1 ? !1 : t[e].visible;
  }
  raycast(e, t) {
    const n = this._drawInfo, i = this._drawRanges, o = this.matrixWorld, l = this.geometry;
    qc.material = this.material, qc.geometry.index = l.index, qc.geometry.attributes = l.attributes, qc.geometry.boundingBox === null && (qc.geometry.boundingBox = new Ug()), qc.geometry.boundingSphere === null && (qc.geometry.boundingSphere = new og());
    for (let u = 0, I = n.length; u < I; u++) {
      if (!n[u].visible || !n[u].active)
        continue;
      const f = n[u].geometryIndex, h = i[f];
      qc.geometry.setDrawRange(h.start, h.count), this.getMatrixAt(u, qc.matrixWorld).premultiply(o), this.getBoundingBoxAt(f, qc.geometry.boundingBox), this.getBoundingSphereAt(f, qc.geometry.boundingSphere), qc.raycast(e, f1);
      for (let v = 0, b = f1.length; v < b; v++) {
        const S = f1[v];
        S.object = this, S.batchId = u, t.push(S);
      }
      f1.length = 0;
    }
    qc.material = null, qc.geometry.index = null, qc.geometry.attributes = {}, qc.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._drawInfo = e._drawInfo.map((t) => ({ ...t })), this._bounds = e._bounds.map((t) => ({
      boxInitialized: t.boxInitialized,
      box: t.box.clone(),
      sphereInitialized: t.sphereInitialized,
      sphere: t.sphere.clone()
    })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null), this;
  }
  onBeforeRender(e, t, n, i, o) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const l = i.getIndex(), u = l === null ? 1 : l.array.BYTES_PER_ELEMENT, I = this._drawInfo, f = this._multiDrawStarts, h = this._multiDrawCounts, v = this._drawRanges, b = this.perObjectFrustumCulled, S = this._indirectTexture, R = S.image.data;
    b && (e_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), ZM.setFromProjectionMatrix(
      e_,
      e.coordinateSystem
    ));
    let W = 0;
    if (this.sortObjects) {
      SM.copy(this.matrixWorld).invert(), SZ.setFromMatrixPosition(n.matrixWorld).applyMatrix4(SM), t_.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(SM);
      for (let T = 0, E = I.length; T < E; T++)
        if (I[T].visible && I[T].active) {
          const _ = I[T].geometryIndex;
          this.getMatrixAt(T, TA), this.getBoundingSphereAt(_, Ty).applyMatrix4(TA);
          let P = !1;
          if (b && (P = !ZM.intersectsSphere(Ty)), !P) {
            const U = vq.subVectors(Ty.center, SZ).dot(t_);
            wM.push(v[_], U, T);
          }
        }
      const x = wM.list, M = this.customSort;
      M === null ? x.sort(o.transparent ? fq : hq) : M.call(this, x, n);
      for (let T = 0, E = x.length; T < E; T++) {
        const _ = x[T];
        f[W] = _.start * u, h[W] = _.count, R[W] = _.index, W++;
      }
      wM.reset();
    } else
      for (let x = 0, M = I.length; x < M; x++)
        if (I[x].visible && I[x].active) {
          const T = I[x].geometryIndex;
          let E = !1;
          if (b && (this.getMatrixAt(x, TA), this.getBoundingSphereAt(T, Ty).applyMatrix4(TA), E = !ZM.intersectsSphere(Ty)), !E) {
            const _ = v[T];
            f[W] = _.start * u, h[W] = _.count, R[W] = x, W++;
          }
        }
    S.needsUpdate = !0, this._multiDrawCount = W, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, i, o, l) {
    this.onBeforeRender(e, null, i, o, l);
  }
}
class Jg extends Gc {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new hi(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const F2 = /* @__PURE__ */ new Ze(), E2 = /* @__PURE__ */ new Ze(), n_ = /* @__PURE__ */ new tr(), ZZ = /* @__PURE__ */ new wb(), p1 = /* @__PURE__ */ new og(), RM = /* @__PURE__ */ new Ze(), i_ = /* @__PURE__ */ new Ze();
class ev extends Aa {
  constructor(e = new _r(), t = new Jg()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let i = 1, o = t.count; i < o; i++)
        F2.fromBufferAttribute(t, i - 1), E2.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += F2.distanceTo(E2);
      e.setAttribute("lineDistance", new Mi(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, o = e.params.Line.threshold, l = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), p1.copy(n.boundingSphere), p1.applyMatrix4(i), p1.radius += o, e.ray.intersectsSphere(p1) === !1) return;
    n_.copy(i).invert(), ZZ.copy(e.ray).applyMatrix4(n_);
    const u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), I = u * u, f = this.isLineSegments ? 2 : 1, h = n.index, b = n.attributes.position;
    if (h !== null) {
      const S = Math.max(0, l.start), R = Math.min(h.count, l.start + l.count);
      for (let W = S, x = R - 1; W < x; W += f) {
        const M = h.getX(W), T = h.getX(W + 1), E = m1(this, e, ZZ, I, M, T);
        E && t.push(E);
      }
      if (this.isLineLoop) {
        const W = h.getX(R - 1), x = h.getX(S), M = m1(this, e, ZZ, I, W, x);
        M && t.push(M);
      }
    } else {
      const S = Math.max(0, l.start), R = Math.min(b.count, l.start + l.count);
      for (let W = S, x = R - 1; W < x; W += f) {
        const M = m1(this, e, ZZ, I, W, W + 1);
        M && t.push(M);
      }
      if (this.isLineLoop) {
        const W = m1(this, e, ZZ, I, R - 1, S);
        W && t.push(W);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
}
function m1(a, e, t, n, i, o) {
  const l = a.geometry.attributes.position;
  if (F2.fromBufferAttribute(l, i), E2.fromBufferAttribute(l, o), t.distanceSqToSegment(F2, E2, RM, i_) > n) return;
  RM.applyMatrix4(a.matrixWorld);
  const I = e.ray.origin.distanceTo(RM);
  if (!(I < e.near || I > e.far))
    return {
      distance: I,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: i_.clone().applyMatrix4(a.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: a
    };
}
const r_ = /* @__PURE__ */ new Ze(), a_ = /* @__PURE__ */ new Ze();
class Cp extends ev {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let i = 0, o = t.count; i < o; i += 2)
        r_.fromBufferAttribute(t, i), a_.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + r_.distanceTo(a_);
      e.setAttribute("lineDistance", new Mi(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class qz extends ev {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class KX extends Gc {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new hi(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const o_ = /* @__PURE__ */ new tr(), VH = /* @__PURE__ */ new wb(), A1 = /* @__PURE__ */ new og(), v1 = /* @__PURE__ */ new Ze();
class $z extends Aa {
  constructor(e = new _r(), t = new KX()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, o = e.params.Points.threshold, l = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), A1.copy(n.boundingSphere), A1.applyMatrix4(i), A1.radius += o, e.ray.intersectsSphere(A1) === !1) return;
    o_.copy(i).invert(), VH.copy(e.ray).applyMatrix4(o_);
    const u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), I = u * u, f = n.index, v = n.attributes.position;
    if (f !== null) {
      const b = Math.max(0, l.start), S = Math.min(f.count, l.start + l.count);
      for (let R = b, W = S; R < W; R++) {
        const x = f.getX(R);
        v1.fromBufferAttribute(v, x), s_(v1, x, I, i, e, t, this);
      }
    } else {
      const b = Math.max(0, l.start), S = Math.min(v.count, l.start + l.count);
      for (let R = b, W = S; R < W; R++)
        v1.fromBufferAttribute(v, R), s_(v1, R, I, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
}
function s_(a, e, t, n, i, o, l) {
  const u = VH.distanceSqToPoint(a);
  if (u < t) {
    const I = new Ze();
    VH.closestPointToPoint(a, I), I.applyMatrix4(n);
    const f = i.ray.origin.distanceTo(I);
    if (f < i.near || f > i.far) return;
    o.push({
      distance: f,
      distanceToRay: Math.sqrt(u),
      point: I,
      index: e,
      face: null,
      object: l
    });
  }
}
class bq extends Fs {
  constructor(e, t, n, i, o, l, u, I, f) {
    super(e, t, n, i, o, l, u, I, f), this.isVideoTexture = !0, this.minFilter = l !== void 0 ? l : nl, this.magFilter = o !== void 0 ? o : nl, this.generateMipmaps = !1;
    const h = this;
    function v() {
      h.needsUpdate = !0, e.requestVideoFrameCallback(v);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(v);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class Gq extends Fs {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = _u, this.minFilter = _u, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class ZW extends Fs {
  constructor(e, t, n, i, o, l, u, I, f, h, v, b) {
    super(null, l, u, I, f, h, i, o, v, b), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Bq extends ZW {
  constructor(e, t, n, i, o, l) {
    super(e, t, n, o, l), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = XC, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Sq extends ZW {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, Mm), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class Zq extends Fs {
  constructor(e, t, n, i, o, l, u, I, f) {
    super(e, t, n, i, o, l, u, I, f), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Kh {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, i = this.getPoint(0), o = 0;
    t.push(0);
    for (let l = 1; l <= e; l++)
      n = this.getPoint(l / e), o += n.distanceTo(i), t.push(o), i = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const o = n.length;
    let l;
    t ? l = t : l = e * n[o - 1];
    let u = 0, I = o - 1, f;
    for (; u <= I; )
      if (i = Math.floor(u + (I - u) / 2), f = n[i] - l, f < 0)
        u = i + 1;
      else if (f > 0)
        I = i - 1;
      else {
        I = i;
        break;
      }
    if (i = I, n[i] === l)
      return i / (o - 1);
    const h = n[i], b = n[i + 1] - h, S = (l - h) / b;
    return (i + S) / (o - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let i = e - 1e-4, o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const l = this.getPoint(i), u = this.getPoint(o), I = t || (l.isVector2 ? new sn() : new Ze());
    return I.copy(u).sub(l).normalize(), I;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new Ze(), i = [], o = [], l = [], u = new Ze(), I = new tr();
    for (let S = 0; S <= e; S++) {
      const R = S / e;
      i[S] = this.getTangentAt(R, new Ze());
    }
    o[0] = new Ze(), l[0] = new Ze();
    let f = Number.MAX_VALUE;
    const h = Math.abs(i[0].x), v = Math.abs(i[0].y), b = Math.abs(i[0].z);
    h <= f && (f = h, n.set(1, 0, 0)), v <= f && (f = v, n.set(0, 1, 0)), b <= f && n.set(0, 0, 1), u.crossVectors(i[0], n).normalize(), o[0].crossVectors(i[0], u), l[0].crossVectors(i[0], o[0]);
    for (let S = 1; S <= e; S++) {
      if (o[S] = o[S - 1].clone(), l[S] = l[S - 1].clone(), u.crossVectors(i[S - 1], i[S]), u.length() > Number.EPSILON) {
        u.normalize();
        const R = Math.acos(el(i[S - 1].dot(i[S]), -1, 1));
        o[S].applyMatrix4(I.makeRotationAxis(u, R));
      }
      l[S].crossVectors(i[S], o[S]);
    }
    if (t === !0) {
      let S = Math.acos(el(o[0].dot(o[e]), -1, 1));
      S /= e, i[0].dot(u.crossVectors(o[0], o[e])) > 0 && (S = -S);
      for (let R = 1; R <= e; R++)
        o[R].applyMatrix4(I.makeRotationAxis(i[R], S * R)), l[R].crossVectors(i[R], o[R]);
    }
    return {
      tangents: i,
      normals: o,
      binormals: l
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class wW extends Kh {
  constructor(e = 0, t = 0, n = 1, i = 1, o = 0, l = Math.PI * 2, u = !1, I = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = o, this.aEndAngle = l, this.aClockwise = u, this.aRotation = I;
  }
  getPoint(e, t = new sn()) {
    const n = t, i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const l = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += i;
    for (; o > i; ) o -= i;
    o < Number.EPSILON && (l ? o = 0 : o = i), this.aClockwise === !0 && !l && (o === i ? o = -i : o = o - i);
    const u = this.aStartAngle + e * o;
    let I = this.aX + this.xRadius * Math.cos(u), f = this.aY + this.yRadius * Math.sin(u);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), v = Math.sin(this.aRotation), b = I - this.aX, S = f - this.aY;
      I = b * h - S * v + this.aX, f = b * v + S * h + this.aY;
    }
    return n.set(I, f);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class eK extends wW {
  constructor(e, t, n, i, o, l) {
    super(e, t, n, n, i, o, l), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function LX() {
  let a = 0, e = 0, t = 0, n = 0;
  function i(o, l, u, I) {
    a = o, e = u, t = -3 * o + 3 * l - 2 * u - I, n = 2 * o - 2 * l + u + I;
  }
  return {
    initCatmullRom: function(o, l, u, I, f) {
      i(l, u, f * (u - o), f * (I - l));
    },
    initNonuniformCatmullRom: function(o, l, u, I, f, h, v) {
      let b = (l - o) / f - (u - o) / (f + h) + (u - l) / h, S = (u - l) / h - (I - l) / (h + v) + (I - u) / v;
      b *= h, S *= h, i(l, u, b, S);
    },
    calc: function(o) {
      const l = o * o, u = l * o;
      return a + e * o + t * l + n * u;
    }
  };
}
const y1 = /* @__PURE__ */ new Ze(), xM = /* @__PURE__ */ new LX(), WM = /* @__PURE__ */ new LX(), VM = /* @__PURE__ */ new LX();
class tK extends Kh {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
  }
  getPoint(e, t = new Ze()) {
    const n = t, i = this.points, o = i.length, l = (o - (this.closed ? 0 : 1)) * e;
    let u = Math.floor(l), I = l - u;
    this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / o) + 1) * o : I === 0 && u === o - 1 && (u = o - 2, I = 1);
    let f, h;
    this.closed || u > 0 ? f = i[(u - 1) % o] : (y1.subVectors(i[0], i[1]).add(i[0]), f = y1);
    const v = i[u % o], b = i[(u + 1) % o];
    if (this.closed || u + 2 < o ? h = i[(u + 2) % o] : (y1.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), h = y1), this.curveType === "centripetal" || this.curveType === "chordal") {
      const S = this.curveType === "chordal" ? 0.5 : 0.25;
      let R = Math.pow(f.distanceToSquared(v), S), W = Math.pow(v.distanceToSquared(b), S), x = Math.pow(b.distanceToSquared(h), S);
      W < 1e-4 && (W = 1), R < 1e-4 && (R = W), x < 1e-4 && (x = W), xM.initNonuniformCatmullRom(f.x, v.x, b.x, h.x, R, W, x), WM.initNonuniformCatmullRom(f.y, v.y, b.y, h.y, R, W, x), VM.initNonuniformCatmullRom(f.z, v.z, b.z, h.z, R, W, x);
    } else this.curveType === "catmullrom" && (xM.initCatmullRom(f.x, v.x, b.x, h.x, this.tension), WM.initCatmullRom(f.y, v.y, b.y, h.y, this.tension), VM.initCatmullRom(f.z, v.z, b.z, h.z, this.tension));
    return n.set(
      xM.calc(I),
      WM.calc(I),
      VM.calc(I)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new Ze().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function l_(a, e, t, n, i) {
  const o = (n - e) * 0.5, l = (i - t) * 0.5, u = a * a, I = a * u;
  return (2 * t - 2 * n + o + l) * I + (-3 * t + 3 * n - 2 * o - l) * u + o * a + t;
}
function wq(a, e) {
  const t = 1 - a;
  return t * t * e;
}
function Rq(a, e) {
  return 2 * (1 - a) * a * e;
}
function xq(a, e) {
  return a * a * e;
}
function jZ(a, e, t, n) {
  return wq(a, e) + Rq(a, t) + xq(a, n);
}
function Wq(a, e) {
  const t = 1 - a;
  return t * t * t * e;
}
function Vq(a, e) {
  const t = 1 - a;
  return 3 * t * t * a * e;
}
function Nq(a, e) {
  return 3 * (1 - a) * a * a * e;
}
function Mq(a, e) {
  return a * a * a * e;
}
function qZ(a, e, t, n, i) {
  return Wq(a, e) + Vq(a, t) + Nq(a, n) + Mq(a, i);
}
class kX extends Kh {
  constructor(e = new sn(), t = new sn(), n = new sn(), i = new sn()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new sn()) {
    const n = t, i = this.v0, o = this.v1, l = this.v2, u = this.v3;
    return n.set(
      qZ(e, i.x, o.x, l.x, u.x),
      qZ(e, i.y, o.y, l.y, u.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class nK extends Kh {
  constructor(e = new Ze(), t = new Ze(), n = new Ze(), i = new Ze()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new Ze()) {
    const n = t, i = this.v0, o = this.v1, l = this.v2, u = this.v3;
    return n.set(
      qZ(e, i.x, o.x, l.x, u.x),
      qZ(e, i.y, o.y, l.y, u.y),
      qZ(e, i.z, o.z, l.z, u.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class DX extends Kh {
  constructor(e = new sn(), t = new sn()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new sn()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new sn()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class iK extends Kh {
  constructor(e = new Ze(), t = new Ze()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Ze()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Ze()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class UX extends Kh {
  constructor(e = new sn(), t = new sn(), n = new sn()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new sn()) {
    const n = t, i = this.v0, o = this.v1, l = this.v2;
    return n.set(
      jZ(e, i.x, o.x, l.x),
      jZ(e, i.y, o.y, l.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class OX extends Kh {
  constructor(e = new Ze(), t = new Ze(), n = new Ze()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new Ze()) {
    const n = t, i = this.v0, o = this.v1, l = this.v2;
    return n.set(
      jZ(e, i.x, o.x, l.x),
      jZ(e, i.y, o.y, l.y),
      jZ(e, i.z, o.z, l.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class PX extends Kh {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new sn()) {
    const n = t, i = this.points, o = (i.length - 1) * e, l = Math.floor(o), u = o - l, I = i[l === 0 ? l : l - 1], f = i[l], h = i[l > i.length - 2 ? i.length - 1 : l + 1], v = i[l > i.length - 3 ? i.length - 1 : l + 2];
    return n.set(
      l_(u, I.x, f.x, h.x, v.x),
      l_(u, I.y, f.y, h.y, v.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new sn().fromArray(i));
    }
    return this;
  }
}
var T2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: eK,
  CatmullRomCurve3: tK,
  CubicBezierCurve: kX,
  CubicBezierCurve3: nK,
  EllipseCurve: wW,
  LineCurve: DX,
  LineCurve3: iK,
  QuadraticBezierCurve: UX,
  QuadraticBezierCurve3: OX,
  SplineCurve: PX
});
class rK extends Kh {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new T2[n](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= n) {
        const l = i[o] - n, u = this.curves[o], I = u.getLength(), f = I === 0 ? 0 : 1 - l / I;
        return u.getPointAt(f, t);
      }
      o++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const l = o[i], u = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e, I = l.getPoints(u);
      for (let f = 0; f < I.length; f++) {
        const h = I[f];
        n && n.equals(h) || (t.push(h), n = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new T2[i.type]().fromJSON(i));
    }
    return this;
  }
}
class yw extends rK {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new sn(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new DX(this.currentPoint.clone(), new sn(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const o = new UX(
      this.currentPoint.clone(),
      new sn(e, t),
      new sn(n, i)
    );
    return this.curves.push(o), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, o, l) {
    const u = new kX(
      this.currentPoint.clone(),
      new sn(e, t),
      new sn(n, i),
      new sn(o, l)
    );
    return this.curves.push(u), this.currentPoint.set(o, l), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new PX(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, o, l) {
    const u = this.currentPoint.x, I = this.currentPoint.y;
    return this.absarc(
      e + u,
      t + I,
      n,
      i,
      o,
      l
    ), this;
  }
  absarc(e, t, n, i, o, l) {
    return this.absellipse(e, t, n, n, i, o, l), this;
  }
  ellipse(e, t, n, i, o, l, u, I) {
    const f = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + f, t + h, n, i, o, l, u, I), this;
  }
  absellipse(e, t, n, i, o, l, u, I) {
    const f = new wW(e, t, n, i, o, l, u, I);
    if (this.curves.length > 0) {
      const v = f.getPoint(0);
      v.equals(this.currentPoint) || this.lineTo(v.x, v.y);
    }
    this.curves.push(f);
    const h = f.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Ow extends _r {
  constructor(e = [new sn(0, -0.5), new sn(0.5, 0), new sn(0, 0.5)], t = 12, n = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: i
    }, t = Math.floor(t), i = el(i, 0, Math.PI * 2);
    const o = [], l = [], u = [], I = [], f = [], h = 1 / t, v = new Ze(), b = new sn(), S = new Ze(), R = new Ze(), W = new Ze();
    let x = 0, M = 0;
    for (let T = 0; T <= e.length - 1; T++)
      switch (T) {
        case 0:
          x = e[T + 1].x - e[T].x, M = e[T + 1].y - e[T].y, S.x = M * 1, S.y = -x, S.z = M * 0, W.copy(S), S.normalize(), I.push(S.x, S.y, S.z);
          break;
        case e.length - 1:
          I.push(W.x, W.y, W.z);
          break;
        default:
          x = e[T + 1].x - e[T].x, M = e[T + 1].y - e[T].y, S.x = M * 1, S.y = -x, S.z = M * 0, R.copy(S), S.x += W.x, S.y += W.y, S.z += W.z, S.normalize(), I.push(S.x, S.y, S.z), W.copy(R);
      }
    for (let T = 0; T <= t; T++) {
      const E = n + T * h * i, _ = Math.sin(E), P = Math.cos(E);
      for (let U = 0; U <= e.length - 1; U++) {
        v.x = e[U].x * _, v.y = e[U].y, v.z = e[U].x * P, l.push(v.x, v.y, v.z), b.x = T / t, b.y = U / (e.length - 1), u.push(b.x, b.y);
        const q = I[3 * U + 0] * _, k = I[3 * U + 1], O = I[3 * U + 0] * P;
        f.push(q, k, O);
      }
    }
    for (let T = 0; T < t; T++)
      for (let E = 0; E < e.length - 1; E++) {
        const _ = E + T * e.length, P = _, U = _ + e.length, q = _ + e.length + 1, k = _ + 1;
        o.push(P, U, k), o.push(q, k, U);
      }
    this.setIndex(o), this.setAttribute("position", new Mi(l, 3)), this.setAttribute("uv", new Mi(u, 2)), this.setAttribute("normal", new Mi(f, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ow(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class RW extends Ow {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const o = new yw();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0), o.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(o.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: n,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new RW(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class xW extends _r {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: i
    }, t = Math.max(3, t);
    const o = [], l = [], u = [], I = [], f = new Ze(), h = new sn();
    l.push(0, 0, 0), u.push(0, 0, 1), I.push(0.5, 0.5);
    for (let v = 0, b = 3; v <= t; v++, b += 3) {
      const S = n + v / t * i;
      f.x = e * Math.cos(S), f.y = e * Math.sin(S), l.push(f.x, f.y, f.z), u.push(0, 0, 1), h.x = (l[b] / e + 1) / 2, h.y = (l[b + 1] / e + 1) / 2, I.push(h.x, h.y);
    }
    for (let v = 1; v <= t; v++)
      o.push(v, v + 1, 0);
    this.setIndex(o), this.setAttribute("position", new Mi(l, 3)), this.setAttribute("normal", new Mi(u, 3)), this.setAttribute("uv", new Mi(I, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new xW(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class CB extends _r {
  constructor(e = 1, t = 1, n = 1, i = 32, o = 1, l = !1, u = 0, I = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: i,
      heightSegments: o,
      openEnded: l,
      thetaStart: u,
      thetaLength: I
    };
    const f = this;
    i = Math.floor(i), o = Math.floor(o);
    const h = [], v = [], b = [], S = [];
    let R = 0;
    const W = [], x = n / 2;
    let M = 0;
    T(), l === !1 && (e > 0 && E(!0), t > 0 && E(!1)), this.setIndex(h), this.setAttribute("position", new Mi(v, 3)), this.setAttribute("normal", new Mi(b, 3)), this.setAttribute("uv", new Mi(S, 2));
    function T() {
      const _ = new Ze(), P = new Ze();
      let U = 0;
      const q = (t - e) / n;
      for (let k = 0; k <= o; k++) {
        const O = [], J = k / o, te = J * (t - e) + e;
        for (let fe = 0; fe <= i; fe++) {
          const pe = fe / i, Ae = pe * I + u, Te = Math.sin(Ae), Ke = Math.cos(Ae);
          P.x = te * Te, P.y = -J * n + x, P.z = te * Ke, v.push(P.x, P.y, P.z), _.set(Te, q, Ke).normalize(), b.push(_.x, _.y, _.z), S.push(pe, 1 - J), O.push(R++);
        }
        W.push(O);
      }
      for (let k = 0; k < i; k++)
        for (let O = 0; O < o; O++) {
          const J = W[O][k], te = W[O + 1][k], fe = W[O + 1][k + 1], pe = W[O][k + 1];
          h.push(J, te, pe), h.push(te, fe, pe), U += 6;
        }
      f.addGroup(M, U, 0), M += U;
    }
    function E(_) {
      const P = R, U = new sn(), q = new Ze();
      let k = 0;
      const O = _ === !0 ? e : t, J = _ === !0 ? 1 : -1;
      for (let fe = 1; fe <= i; fe++)
        v.push(0, x * J, 0), b.push(0, J, 0), S.push(0.5, 0.5), R++;
      const te = R;
      for (let fe = 0; fe <= i; fe++) {
        const Ae = fe / i * I + u, Te = Math.cos(Ae), Ke = Math.sin(Ae);
        q.x = O * Ke, q.y = x * J, q.z = O * Te, v.push(q.x, q.y, q.z), b.push(0, J, 0), U.x = Te * 0.5 + 0.5, U.y = Ke * 0.5 * J + 0.5, S.push(U.x, U.y), R++;
      }
      for (let fe = 0; fe < i; fe++) {
        const pe = P + fe, Ae = te + fe;
        _ === !0 ? h.push(Ae, Ae + 1, pe) : h.push(Ae + 1, Ae, pe), k += 3;
      }
      f.addGroup(M, k, _ === !0 ? 1 : 2), M += k;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new CB(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class WW extends CB {
  constructor(e = 1, t = 1, n = 32, i = 1, o = !1, l = 0, u = Math.PI * 2) {
    super(0, e, t, n, i, o, l, u), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: i,
      openEnded: o,
      thetaStart: l,
      thetaLength: u
    };
  }
  static fromJSON(e) {
    return new WW(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class av extends _r {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: i
    };
    const o = [], l = [];
    u(i), f(n), h(), this.setAttribute("position", new Mi(o, 3)), this.setAttribute("normal", new Mi(o.slice(), 3)), this.setAttribute("uv", new Mi(l, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function u(T) {
      const E = new Ze(), _ = new Ze(), P = new Ze();
      for (let U = 0; U < t.length; U += 3)
        S(t[U + 0], E), S(t[U + 1], _), S(t[U + 2], P), I(E, _, P, T);
    }
    function I(T, E, _, P) {
      const U = P + 1, q = [];
      for (let k = 0; k <= U; k++) {
        q[k] = [];
        const O = T.clone().lerp(_, k / U), J = E.clone().lerp(_, k / U), te = U - k;
        for (let fe = 0; fe <= te; fe++)
          fe === 0 && k === U ? q[k][fe] = O : q[k][fe] = O.clone().lerp(J, fe / te);
      }
      for (let k = 0; k < U; k++)
        for (let O = 0; O < 2 * (U - k) - 1; O++) {
          const J = Math.floor(O / 2);
          O % 2 === 0 ? (b(q[k][J + 1]), b(q[k + 1][J]), b(q[k][J])) : (b(q[k][J + 1]), b(q[k + 1][J + 1]), b(q[k + 1][J]));
        }
    }
    function f(T) {
      const E = new Ze();
      for (let _ = 0; _ < o.length; _ += 3)
        E.x = o[_ + 0], E.y = o[_ + 1], E.z = o[_ + 2], E.normalize().multiplyScalar(T), o[_ + 0] = E.x, o[_ + 1] = E.y, o[_ + 2] = E.z;
    }
    function h() {
      const T = new Ze();
      for (let E = 0; E < o.length; E += 3) {
        T.x = o[E + 0], T.y = o[E + 1], T.z = o[E + 2];
        const _ = x(T) / 2 / Math.PI + 0.5, P = M(T) / Math.PI + 0.5;
        l.push(_, 1 - P);
      }
      R(), v();
    }
    function v() {
      for (let T = 0; T < l.length; T += 6) {
        const E = l[T + 0], _ = l[T + 2], P = l[T + 4], U = Math.max(E, _, P), q = Math.min(E, _, P);
        U > 0.9 && q < 0.1 && (E < 0.2 && (l[T + 0] += 1), _ < 0.2 && (l[T + 2] += 1), P < 0.2 && (l[T + 4] += 1));
      }
    }
    function b(T) {
      o.push(T.x, T.y, T.z);
    }
    function S(T, E) {
      const _ = T * 3;
      E.x = e[_ + 0], E.y = e[_ + 1], E.z = e[_ + 2];
    }
    function R() {
      const T = new Ze(), E = new Ze(), _ = new Ze(), P = new Ze(), U = new sn(), q = new sn(), k = new sn();
      for (let O = 0, J = 0; O < o.length; O += 9, J += 6) {
        T.set(o[O + 0], o[O + 1], o[O + 2]), E.set(o[O + 3], o[O + 4], o[O + 5]), _.set(o[O + 6], o[O + 7], o[O + 8]), U.set(l[J + 0], l[J + 1]), q.set(l[J + 2], l[J + 3]), k.set(l[J + 4], l[J + 5]), P.copy(T).add(E).add(_).divideScalar(3);
        const te = x(P);
        W(U, J + 0, T, te), W(q, J + 2, E, te), W(k, J + 4, _, te);
      }
    }
    function W(T, E, _, P) {
      P < 0 && T.x === 1 && (l[E] = T.x - 1), _.x === 0 && _.z === 0 && (l[E] = P / 2 / Math.PI + 0.5);
    }
    function x(T) {
      return Math.atan2(T.z, -T.x);
    }
    function M(T) {
      return Math.atan2(-T.y, Math.sqrt(T.x * T.x + T.z * T.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new av(e.vertices, e.indices, e.radius, e.details);
  }
}
class VW extends av {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, o = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      // (±1/φ, ±φ, 0)
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      0,
      // (±φ, 0, ±1/φ)
      -n,
      0,
      -i,
      n,
      0,
      -i,
      -n,
      0,
      i,
      n,
      0,
      i
    ], l = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(o, l, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new VW(e.radius, e.detail);
  }
}
const b1 = /* @__PURE__ */ new Ze(), G1 = /* @__PURE__ */ new Ze(), NM = /* @__PURE__ */ new Ze(), B1 = /* @__PURE__ */ new EI();
class aK extends _r {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), o = Math.cos(gb * t), l = e.getIndex(), u = e.getAttribute("position"), I = l ? l.count : u.count, f = [0, 0, 0], h = ["a", "b", "c"], v = new Array(3), b = {}, S = [];
      for (let R = 0; R < I; R += 3) {
        l ? (f[0] = l.getX(R), f[1] = l.getX(R + 1), f[2] = l.getX(R + 2)) : (f[0] = R, f[1] = R + 1, f[2] = R + 2);
        const { a: W, b: x, c: M } = B1;
        if (W.fromBufferAttribute(u, f[0]), x.fromBufferAttribute(u, f[1]), M.fromBufferAttribute(u, f[2]), B1.getNormal(NM), v[0] = `${Math.round(W.x * i)},${Math.round(W.y * i)},${Math.round(W.z * i)}`, v[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(x.z * i)}`, v[2] = `${Math.round(M.x * i)},${Math.round(M.y * i)},${Math.round(M.z * i)}`, !(v[0] === v[1] || v[1] === v[2] || v[2] === v[0]))
          for (let T = 0; T < 3; T++) {
            const E = (T + 1) % 3, _ = v[T], P = v[E], U = B1[h[T]], q = B1[h[E]], k = `${_}_${P}`, O = `${P}_${_}`;
            O in b && b[O] ? (NM.dot(b[O].normal) <= o && (S.push(U.x, U.y, U.z), S.push(q.x, q.y, q.z)), b[O] = null) : k in b || (b[k] = {
              index0: f[T],
              index1: f[E],
              normal: NM.clone()
            });
          }
      }
      for (const R in b)
        if (b[R]) {
          const { index0: W, index1: x } = b[R];
          b1.fromBufferAttribute(u, W), G1.fromBufferAttribute(u, x), S.push(b1.x, b1.y, b1.z), S.push(G1.x, G1.y, G1.z);
        }
      this.setAttribute("position", new Mi(S, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
let Ib = class extends yw {
  constructor(e) {
    super(e), this.uuid = zI(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new yw().fromJSON(i));
    }
    return this;
  }
};
const Hq = {
  triangulate: function(a, e, t = 2) {
    const n = e && e.length, i = n ? e[0] * t : a.length;
    let o = oK(a, 0, i, t, !0);
    const l = [];
    if (!o || o.next === o.prev) return l;
    let u, I, f, h, v, b, S;
    if (n && (o = Tq(a, e, o, t)), a.length > 80 * t) {
      u = f = a[0], I = h = a[1];
      for (let R = t; R < i; R += t)
        v = a[R], b = a[R + 1], v < u && (u = v), b < I && (I = b), v > f && (f = v), b > h && (h = b);
      S = Math.max(f - u, h - I), S = S !== 0 ? 32767 / S : 0;
    }
    return bw(o, l, t, u, I, S, 0), l;
  }
};
function oK(a, e, t, n, i) {
  let o, l;
  if (i === Qq(a, e, t, n) > 0)
    for (o = e; o < t; o += n) l = u_(o, a[o], a[o + 1], l);
  else
    for (o = t - n; o >= e; o -= n) l = u_(o, a[o], a[o + 1], l);
  return l && NW(l, l.next) && (Bw(l), l = l.next), l;
}
function bb(a, e) {
  if (!a) return a;
  e || (e = a);
  let t = a, n;
  do
    if (n = !1, !t.steiner && (NW(t, t.next) || Xs(t.prev, t, t.next) === 0)) {
      if (Bw(t), t = e = t.prev, t === t.next) break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function bw(a, e, t, n, i, o, l) {
  if (!a) return;
  !l && o && kq(a, n, i, o);
  let u = a, I, f;
  for (; a.prev !== a.next; ) {
    if (I = a.prev, f = a.next, o ? Yq(a, n, i, o) : Xq(a)) {
      e.push(I.i / t | 0), e.push(a.i / t | 0), e.push(f.i / t | 0), Bw(a), a = f.next, u = f.next;
      continue;
    }
    if (a = f, a === u) {
      l ? l === 1 ? (a = Fq(bb(a), e, t), bw(a, e, t, n, i, o, 2)) : l === 2 && Eq(a, e, t, n, i, o) : bw(bb(a), e, t, n, i, o, 1);
      break;
    }
  }
}
function Xq(a) {
  const e = a.prev, t = a, n = a.next;
  if (Xs(e, t, n) >= 0) return !1;
  const i = e.x, o = t.x, l = n.x, u = e.y, I = t.y, f = n.y, h = i < o ? i < l ? i : l : o < l ? o : l, v = u < I ? u < f ? u : f : I < f ? I : f, b = i > o ? i > l ? i : l : o > l ? o : l, S = u > I ? u > f ? u : f : I > f ? I : f;
  let R = n.next;
  for (; R !== e; ) {
    if (R.x >= h && R.x <= b && R.y >= v && R.y <= S && zG(i, u, o, I, l, f, R.x, R.y) && Xs(R.prev, R, R.next) >= 0) return !1;
    R = R.next;
  }
  return !0;
}
function Yq(a, e, t, n) {
  const i = a.prev, o = a, l = a.next;
  if (Xs(i, o, l) >= 0) return !1;
  const u = i.x, I = o.x, f = l.x, h = i.y, v = o.y, b = l.y, S = u < I ? u < f ? u : f : I < f ? I : f, R = h < v ? h < b ? h : b : v < b ? v : b, W = u > I ? u > f ? u : f : I > f ? I : f, x = h > v ? h > b ? h : b : v > b ? v : b, M = NH(S, R, e, t, n), T = NH(W, x, e, t, n);
  let E = a.prevZ, _ = a.nextZ;
  for (; E && E.z >= M && _ && _.z <= T; ) {
    if (E.x >= S && E.x <= W && E.y >= R && E.y <= x && E !== i && E !== l && zG(u, h, I, v, f, b, E.x, E.y) && Xs(E.prev, E, E.next) >= 0 || (E = E.prevZ, _.x >= S && _.x <= W && _.y >= R && _.y <= x && _ !== i && _ !== l && zG(u, h, I, v, f, b, _.x, _.y) && Xs(_.prev, _, _.next) >= 0)) return !1;
    _ = _.nextZ;
  }
  for (; E && E.z >= M; ) {
    if (E.x >= S && E.x <= W && E.y >= R && E.y <= x && E !== i && E !== l && zG(u, h, I, v, f, b, E.x, E.y) && Xs(E.prev, E, E.next) >= 0) return !1;
    E = E.prevZ;
  }
  for (; _ && _.z <= T; ) {
    if (_.x >= S && _.x <= W && _.y >= R && _.y <= x && _ !== i && _ !== l && zG(u, h, I, v, f, b, _.x, _.y) && Xs(_.prev, _, _.next) >= 0) return !1;
    _ = _.nextZ;
  }
  return !0;
}
function Fq(a, e, t) {
  let n = a;
  do {
    const i = n.prev, o = n.next.next;
    !NW(i, o) && sK(i, n, n.next, o) && Gw(i, o) && Gw(o, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(o.i / t | 0), Bw(n), Bw(n.next), n = a = o), n = n.next;
  } while (n !== a);
  return bb(n);
}
function Eq(a, e, t, n, i, o) {
  let l = a;
  do {
    let u = l.next.next;
    for (; u !== l.prev; ) {
      if (l.i !== u.i && Oq(l, u)) {
        let I = lK(l, u);
        l = bb(l, l.next), I = bb(I, I.next), bw(l, e, t, n, i, o, 0), bw(I, e, t, n, i, o, 0);
        return;
      }
      u = u.next;
    }
    l = l.next;
  } while (l !== a);
}
function Tq(a, e, t, n) {
  const i = [];
  let o, l, u, I, f;
  for (o = 0, l = e.length; o < l; o++)
    u = e[o] * n, I = o < l - 1 ? e[o + 1] * n : a.length, f = oK(a, u, I, n, !1), f === f.next && (f.steiner = !0), i.push(Uq(f));
  for (i.sort(_q), o = 0; o < i.length; o++)
    t = zq(i[o], t);
  return t;
}
function _q(a, e) {
  return a.x - e.x;
}
function zq(a, e) {
  const t = Kq(a, e);
  if (!t)
    return e;
  const n = lK(t, a);
  return bb(n, n.next), bb(t, t.next);
}
function Kq(a, e) {
  let t = e, n = -1 / 0, i;
  const o = a.x, l = a.y;
  do {
    if (l <= t.y && l >= t.next.y && t.next.y !== t.y) {
      const b = t.x + (l - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (b <= o && b > n && (n = b, i = t.x < t.next.x ? t : t.next, b === o))
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const u = i, I = i.x, f = i.y;
  let h = 1 / 0, v;
  t = i;
  do
    o >= t.x && t.x >= I && o !== t.x && zG(l < f ? o : n, l, I, f, l < f ? n : o, l, t.x, t.y) && (v = Math.abs(l - t.y) / (o - t.x), Gw(t, a) && (v < h || v === h && (t.x > i.x || t.x === i.x && Lq(i, t))) && (i = t, h = v)), t = t.next;
  while (t !== u);
  return i;
}
function Lq(a, e) {
  return Xs(a.prev, a, e.prev) < 0 && Xs(e.next, a, a.next) < 0;
}
function kq(a, e, t, n) {
  let i = a;
  do
    i.z === 0 && (i.z = NH(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== a);
  i.prevZ.nextZ = null, i.prevZ = null, Dq(i);
}
function Dq(a) {
  let e, t, n, i, o, l, u, I, f = 1;
  do {
    for (t = a, a = null, o = null, l = 0; t; ) {
      for (l++, n = t, u = 0, e = 0; e < f && (u++, n = n.nextZ, !!n); e++)
        ;
      for (I = f; u > 0 || I > 0 && n; )
        u !== 0 && (I === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, u--) : (i = n, n = n.nextZ, I--), o ? o.nextZ = i : a = i, i.prevZ = o, o = i;
      t = n;
    }
    o.nextZ = null, f *= 2;
  } while (l > 1);
  return a;
}
function NH(a, e, t, n, i) {
  return a = (a - t) * i | 0, e = (e - n) * i | 0, a = (a | a << 8) & 16711935, a = (a | a << 4) & 252645135, a = (a | a << 2) & 858993459, a = (a | a << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, a | e << 1;
}
function Uq(a) {
  let e = a, t = a;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== a);
  return t;
}
function zG(a, e, t, n, i, o, l, u) {
  return (i - l) * (e - u) >= (a - l) * (o - u) && (a - l) * (n - u) >= (t - l) * (e - u) && (t - l) * (o - u) >= (i - l) * (n - u);
}
function Oq(a, e) {
  return a.next.i !== e.i && a.prev.i !== e.i && !Pq(a, e) && // dones't intersect other edges
  (Gw(a, e) && Gw(e, a) && Jq(a, e) && // locally visible
  (Xs(a.prev, a, e.prev) || Xs(a, e.prev, e)) || // does not create opposite-facing sectors
  NW(a, e) && Xs(a.prev, a, a.next) > 0 && Xs(e.prev, e, e.next) > 0);
}
function Xs(a, e, t) {
  return (e.y - a.y) * (t.x - e.x) - (e.x - a.x) * (t.y - e.y);
}
function NW(a, e) {
  return a.x === e.x && a.y === e.y;
}
function sK(a, e, t, n) {
  const i = Z1(Xs(a, e, t)), o = Z1(Xs(a, e, n)), l = Z1(Xs(t, n, a)), u = Z1(Xs(t, n, e));
  return !!(i !== o && l !== u || i === 0 && S1(a, t, e) || o === 0 && S1(a, n, e) || l === 0 && S1(t, a, n) || u === 0 && S1(t, e, n));
}
function S1(a, e, t) {
  return e.x <= Math.max(a.x, t.x) && e.x >= Math.min(a.x, t.x) && e.y <= Math.max(a.y, t.y) && e.y >= Math.min(a.y, t.y);
}
function Z1(a) {
  return a > 0 ? 1 : a < 0 ? -1 : 0;
}
function Pq(a, e) {
  let t = a;
  do {
    if (t.i !== a.i && t.next.i !== a.i && t.i !== e.i && t.next.i !== e.i && sK(t, t.next, a, e)) return !0;
    t = t.next;
  } while (t !== a);
  return !1;
}
function Gw(a, e) {
  return Xs(a.prev, a, a.next) < 0 ? Xs(a, e, a.next) >= 0 && Xs(a, a.prev, e) >= 0 : Xs(a, e, a.prev) < 0 || Xs(a, a.next, e) < 0;
}
function Jq(a, e) {
  let t = a, n = !1;
  const i = (a.x + e.x) / 2, o = (a.y + e.y) / 2;
  do
    t.y > o != t.next.y > o && t.next.y !== t.y && i < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== a);
  return n;
}
function lK(a, e) {
  const t = new MH(a.i, a.x, a.y), n = new MH(e.i, e.x, e.y), i = a.next, o = e.prev;
  return a.next = e, e.prev = a, t.next = i, i.prev = t, n.next = t, t.prev = n, o.next = n, n.prev = o, n;
}
function u_(a, e, t, n) {
  const i = new MH(a, e, t);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function Bw(a) {
  a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
}
function MH(a, e, t) {
  this.i = a, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function Qq(a, e, t, n) {
  let i = 0;
  for (let o = e, l = t - n; o < t; o += n)
    i += (a[l] - a[o]) * (a[o + 1] + a[l + 1]), l = o;
  return i;
}
class up {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, o = 0; o < t; i = o++)
      n += e[i].x * e[o].y - e[o].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return up.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], i = [], o = [];
    c_(e), g_(n, e);
    let l = e.length;
    t.forEach(c_);
    for (let I = 0; I < t.length; I++)
      i.push(l), l += t[I].length, g_(n, t[I]);
    const u = Hq.triangulate(n, i);
    for (let I = 0; I < u.length; I += 3)
      o.push(u.slice(I, I + 3));
    return o;
  }
}
function c_(a) {
  const e = a.length;
  e > 2 && a[e - 1].equals(a[0]) && a.pop();
}
function g_(a, e) {
  for (let t = 0; t < e.length; t++)
    a.push(e[t].x), a.push(e[t].y);
}
class MW extends _r {
  constructor(e = new Ib([new sn(0.5, 0.5), new sn(-0.5, 0.5), new sn(-0.5, -0.5), new sn(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, i = [], o = [];
    for (let u = 0, I = e.length; u < I; u++) {
      const f = e[u];
      l(f);
    }
    this.setAttribute("position", new Mi(i, 3)), this.setAttribute("uv", new Mi(o, 2)), this.computeVertexNormals();
    function l(u) {
      const I = [], f = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, v = t.depth !== void 0 ? t.depth : 1;
      let b = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, S = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, R = t.bevelSize !== void 0 ? t.bevelSize : S - 0.1, W = t.bevelOffset !== void 0 ? t.bevelOffset : 0, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const M = t.extrudePath, T = t.UVGenerator !== void 0 ? t.UVGenerator : jq;
      let E, _ = !1, P, U, q, k;
      M && (E = M.getSpacedPoints(h), _ = !0, b = !1, P = M.computeFrenetFrames(h, !1), U = new Ze(), q = new Ze(), k = new Ze()), b || (x = 0, S = 0, R = 0, W = 0);
      const O = u.extractPoints(f);
      let J = O.shape;
      const te = O.holes;
      if (!up.isClockWise(J)) {
        J = J.reverse();
        for (let he = 0, Lt = te.length; he < Lt; he++) {
          const Wt = te[he];
          up.isClockWise(Wt) && (te[he] = Wt.reverse());
        }
      }
      const pe = up.triangulateShape(J, te), Ae = J;
      for (let he = 0, Lt = te.length; he < Lt; he++) {
        const Wt = te[he];
        J = J.concat(Wt);
      }
      function Te(he, Lt, Wt) {
        return Lt || console.error("THREE.ExtrudeGeometry: vec does not exist"), he.clone().addScaledVector(Lt, Wt);
      }
      const Ke = J.length, je = pe.length;
      function ee(he, Lt, Wt) {
        let tn, Gt, Rn;
        const nn = he.x - Lt.x, Bn = he.y - Lt.y, Se = Wt.x - he.x, oe = Wt.y - he.y, ct = nn * nn + Bn * Bn, Ft = nn * oe - Bn * Se;
        if (Math.abs(Ft) > Number.EPSILON) {
          const pt = Math.sqrt(ct), zt = Math.sqrt(Se * Se + oe * oe), Sn = Lt.x - Bn / pt, rn = Lt.y + nn / pt, gn = Wt.x - oe / zt, qn = Wt.y + Se / zt, qt = ((gn - Sn) * oe - (qn - rn) * Se) / (nn * oe - Bn * Se);
          tn = Sn + nn * qt - he.x, Gt = rn + Bn * qt - he.y;
          const An = tn * tn + Gt * Gt;
          if (An <= 2)
            return new sn(tn, Gt);
          Rn = Math.sqrt(An / 2);
        } else {
          let pt = !1;
          nn > Number.EPSILON ? Se > Number.EPSILON && (pt = !0) : nn < -Number.EPSILON ? Se < -Number.EPSILON && (pt = !0) : Math.sign(Bn) === Math.sign(oe) && (pt = !0), pt ? (tn = -Bn, Gt = nn, Rn = Math.sqrt(ct)) : (tn = nn, Gt = Bn, Rn = Math.sqrt(ct / 2));
        }
        return new sn(tn / Rn, Gt / Rn);
      }
      const Ce = [];
      for (let he = 0, Lt = Ae.length, Wt = Lt - 1, tn = he + 1; he < Lt; he++, Wt++, tn++)
        Wt === Lt && (Wt = 0), tn === Lt && (tn = 0), Ce[he] = ee(Ae[he], Ae[Wt], Ae[tn]);
      const be = [];
      let le, Ye = Ce.concat();
      for (let he = 0, Lt = te.length; he < Lt; he++) {
        const Wt = te[he];
        le = [];
        for (let tn = 0, Gt = Wt.length, Rn = Gt - 1, nn = tn + 1; tn < Gt; tn++, Rn++, nn++)
          Rn === Gt && (Rn = 0), nn === Gt && (nn = 0), le[tn] = ee(Wt[tn], Wt[Rn], Wt[nn]);
        be.push(le), Ye = Ye.concat(le);
      }
      for (let he = 0; he < x; he++) {
        const Lt = he / x, Wt = S * Math.cos(Lt * Math.PI / 2), tn = R * Math.sin(Lt * Math.PI / 2) + W;
        for (let Gt = 0, Rn = Ae.length; Gt < Rn; Gt++) {
          const nn = Te(Ae[Gt], Ce[Gt], tn);
          St(nn.x, nn.y, -Wt);
        }
        for (let Gt = 0, Rn = te.length; Gt < Rn; Gt++) {
          const nn = te[Gt];
          le = be[Gt];
          for (let Bn = 0, Se = nn.length; Bn < Se; Bn++) {
            const oe = Te(nn[Bn], le[Bn], tn);
            St(oe.x, oe.y, -Wt);
          }
        }
      }
      const $e = R + W;
      for (let he = 0; he < Ke; he++) {
        const Lt = b ? Te(J[he], Ye[he], $e) : J[he];
        _ ? (q.copy(P.normals[0]).multiplyScalar(Lt.x), U.copy(P.binormals[0]).multiplyScalar(Lt.y), k.copy(E[0]).add(q).add(U), St(k.x, k.y, k.z)) : St(Lt.x, Lt.y, 0);
      }
      for (let he = 1; he <= h; he++)
        for (let Lt = 0; Lt < Ke; Lt++) {
          const Wt = b ? Te(J[Lt], Ye[Lt], $e) : J[Lt];
          _ ? (q.copy(P.normals[he]).multiplyScalar(Wt.x), U.copy(P.binormals[he]).multiplyScalar(Wt.y), k.copy(E[he]).add(q).add(U), St(k.x, k.y, k.z)) : St(Wt.x, Wt.y, v / h * he);
        }
      for (let he = x - 1; he >= 0; he--) {
        const Lt = he / x, Wt = S * Math.cos(Lt * Math.PI / 2), tn = R * Math.sin(Lt * Math.PI / 2) + W;
        for (let Gt = 0, Rn = Ae.length; Gt < Rn; Gt++) {
          const nn = Te(Ae[Gt], Ce[Gt], tn);
          St(nn.x, nn.y, v + Wt);
        }
        for (let Gt = 0, Rn = te.length; Gt < Rn; Gt++) {
          const nn = te[Gt];
          le = be[Gt];
          for (let Bn = 0, Se = nn.length; Bn < Se; Bn++) {
            const oe = Te(nn[Bn], le[Bn], tn);
            _ ? St(oe.x, oe.y + E[h - 1].y, E[h - 1].x + Wt) : St(oe.x, oe.y, v + Wt);
          }
        }
      }
      ke(), ot();
      function ke() {
        const he = i.length / 3;
        if (b) {
          let Lt = 0, Wt = Ke * Lt;
          for (let tn = 0; tn < je; tn++) {
            const Gt = pe[tn];
            ln(Gt[2] + Wt, Gt[1] + Wt, Gt[0] + Wt);
          }
          Lt = h + x * 2, Wt = Ke * Lt;
          for (let tn = 0; tn < je; tn++) {
            const Gt = pe[tn];
            ln(Gt[0] + Wt, Gt[1] + Wt, Gt[2] + Wt);
          }
        } else {
          for (let Lt = 0; Lt < je; Lt++) {
            const Wt = pe[Lt];
            ln(Wt[2], Wt[1], Wt[0]);
          }
          for (let Lt = 0; Lt < je; Lt++) {
            const Wt = pe[Lt];
            ln(Wt[0] + Ke * h, Wt[1] + Ke * h, Wt[2] + Ke * h);
          }
        }
        n.addGroup(he, i.length / 3 - he, 0);
      }
      function ot() {
        const he = i.length / 3;
        let Lt = 0;
        wt(Ae, Lt), Lt += Ae.length;
        for (let Wt = 0, tn = te.length; Wt < tn; Wt++) {
          const Gt = te[Wt];
          wt(Gt, Lt), Lt += Gt.length;
        }
        n.addGroup(he, i.length / 3 - he, 1);
      }
      function wt(he, Lt) {
        let Wt = he.length;
        for (; --Wt >= 0; ) {
          const tn = Wt;
          let Gt = Wt - 1;
          Gt < 0 && (Gt = he.length - 1);
          for (let Rn = 0, nn = h + x * 2; Rn < nn; Rn++) {
            const Bn = Ke * Rn, Se = Ke * (Rn + 1), oe = Lt + tn + Bn, ct = Lt + Gt + Bn, Ft = Lt + Gt + Se, pt = Lt + tn + Se;
            hn(oe, ct, Ft, pt);
          }
        }
      }
      function St(he, Lt, Wt) {
        I.push(he), I.push(Lt), I.push(Wt);
      }
      function ln(he, Lt, Wt) {
        mn(he), mn(Lt), mn(Wt);
        const tn = i.length / 3, Gt = T.generateTopUV(n, i, tn - 3, tn - 2, tn - 1);
        Pn(Gt[0]), Pn(Gt[1]), Pn(Gt[2]);
      }
      function hn(he, Lt, Wt, tn) {
        mn(he), mn(Lt), mn(tn), mn(Lt), mn(Wt), mn(tn);
        const Gt = i.length / 3, Rn = T.generateSideWallUV(n, i, Gt - 6, Gt - 3, Gt - 2, Gt - 1);
        Pn(Rn[0]), Pn(Rn[1]), Pn(Rn[3]), Pn(Rn[1]), Pn(Rn[2]), Pn(Rn[3]);
      }
      function mn(he) {
        i.push(I[he * 3 + 0]), i.push(I[he * 3 + 1]), i.push(I[he * 3 + 2]);
      }
      function Pn(he) {
        o.push(he.x), o.push(he.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return qq(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let o = 0, l = e.shapes.length; o < l; o++) {
      const u = t[e.shapes[o]];
      n.push(u);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new T2[i.type]().fromJSON(i)), new MW(n, e.options);
  }
}
const jq = {
  generateTopUV: function(a, e, t, n, i) {
    const o = e[t * 3], l = e[t * 3 + 1], u = e[n * 3], I = e[n * 3 + 1], f = e[i * 3], h = e[i * 3 + 1];
    return [
      new sn(o, l),
      new sn(u, I),
      new sn(f, h)
    ];
  },
  generateSideWallUV: function(a, e, t, n, i, o) {
    const l = e[t * 3], u = e[t * 3 + 1], I = e[t * 3 + 2], f = e[n * 3], h = e[n * 3 + 1], v = e[n * 3 + 2], b = e[i * 3], S = e[i * 3 + 1], R = e[i * 3 + 2], W = e[o * 3], x = e[o * 3 + 1], M = e[o * 3 + 2];
    return Math.abs(u - h) < Math.abs(l - f) ? [
      new sn(l, 1 - I),
      new sn(f, 1 - v),
      new sn(b, 1 - R),
      new sn(W, 1 - M)
    ] : [
      new sn(u, 1 - I),
      new sn(h, 1 - v),
      new sn(S, 1 - R),
      new sn(x, 1 - M)
    ];
  }
};
function qq(a, e, t) {
  if (t.shapes = [], Array.isArray(a))
    for (let n = 0, i = a.length; n < i; n++) {
      const o = a[n];
      t.shapes.push(o.uuid);
    }
  else
    t.shapes.push(a.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class HW extends av {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], o = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, o, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new HW(e.radius, e.detail);
  }
}
class Pw extends av {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Pw(e.radius, e.detail);
  }
}
class XW extends _r {
  constructor(e = 0.5, t = 1, n = 32, i = 1, o = 0, l = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: o,
      thetaLength: l
    }, n = Math.max(3, n), i = Math.max(1, i);
    const u = [], I = [], f = [], h = [];
    let v = e;
    const b = (t - e) / i, S = new Ze(), R = new sn();
    for (let W = 0; W <= i; W++) {
      for (let x = 0; x <= n; x++) {
        const M = o + x / n * l;
        S.x = v * Math.cos(M), S.y = v * Math.sin(M), I.push(S.x, S.y, S.z), f.push(0, 0, 1), R.x = (S.x / t + 1) / 2, R.y = (S.y / t + 1) / 2, h.push(R.x, R.y);
      }
      v += b;
    }
    for (let W = 0; W < i; W++) {
      const x = W * (n + 1);
      for (let M = 0; M < n; M++) {
        const T = M + x, E = T, _ = T + n + 1, P = T + n + 2, U = T + 1;
        u.push(E, _, U), u.push(_, P, U);
      }
    }
    this.setIndex(u), this.setAttribute("position", new Mi(I, 3)), this.setAttribute("normal", new Mi(f, 3)), this.setAttribute("uv", new Mi(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new XW(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class YW extends _r {
  constructor(e = new Ib([new sn(0, 0.5), new sn(-0.5, -0.5), new sn(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], i = [], o = [], l = [];
    let u = 0, I = 0;
    if (Array.isArray(e) === !1)
      f(e);
    else
      for (let h = 0; h < e.length; h++)
        f(e[h]), this.addGroup(u, I, h), u += I, I = 0;
    this.setIndex(n), this.setAttribute("position", new Mi(i, 3)), this.setAttribute("normal", new Mi(o, 3)), this.setAttribute("uv", new Mi(l, 2));
    function f(h) {
      const v = i.length / 3, b = h.extractPoints(t);
      let S = b.shape;
      const R = b.holes;
      up.isClockWise(S) === !1 && (S = S.reverse());
      for (let x = 0, M = R.length; x < M; x++) {
        const T = R[x];
        up.isClockWise(T) === !0 && (R[x] = T.reverse());
      }
      const W = up.triangulateShape(S, R);
      for (let x = 0, M = R.length; x < M; x++) {
        const T = R[x];
        S = S.concat(T);
      }
      for (let x = 0, M = S.length; x < M; x++) {
        const T = S[x];
        i.push(T.x, T.y, 0), o.push(0, 0, 1), l.push(T.x, T.y);
      }
      for (let x = 0, M = W.length; x < M; x++) {
        const T = W[x], E = T[0] + v, _ = T[1] + v, P = T[2] + v;
        n.push(E, _, P), I += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return $q(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const l = t[e.shapes[i]];
      n.push(l);
    }
    return new YW(n, e.curveSegments);
  }
}
function $q(a, e) {
  if (e.shapes = [], Array.isArray(a))
    for (let t = 0, n = a.length; t < n; t++) {
      const i = a[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(a.uuid);
  return e;
}
class Jw extends _r {
  constructor(e = 1, t = 32, n = 16, i = 0, o = Math.PI * 2, l = 0, u = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: i,
      phiLength: o,
      thetaStart: l,
      thetaLength: u
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const I = Math.min(l + u, Math.PI);
    let f = 0;
    const h = [], v = new Ze(), b = new Ze(), S = [], R = [], W = [], x = [];
    for (let M = 0; M <= n; M++) {
      const T = [], E = M / n;
      let _ = 0;
      M === 0 && l === 0 ? _ = 0.5 / t : M === n && I === Math.PI && (_ = -0.5 / t);
      for (let P = 0; P <= t; P++) {
        const U = P / t;
        v.x = -e * Math.cos(i + U * o) * Math.sin(l + E * u), v.y = e * Math.cos(l + E * u), v.z = e * Math.sin(i + U * o) * Math.sin(l + E * u), R.push(v.x, v.y, v.z), b.copy(v).normalize(), W.push(b.x, b.y, b.z), x.push(U + _, 1 - E), T.push(f++);
      }
      h.push(T);
    }
    for (let M = 0; M < n; M++)
      for (let T = 0; T < t; T++) {
        const E = h[M][T + 1], _ = h[M][T], P = h[M + 1][T], U = h[M + 1][T + 1];
        (M !== 0 || l > 0) && S.push(E, _, U), (M !== n - 1 || I < Math.PI) && S.push(_, P, U);
      }
    this.setIndex(S), this.setAttribute("position", new Mi(R, 3)), this.setAttribute("normal", new Mi(W, 3)), this.setAttribute("uv", new Mi(x, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Jw(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class FW extends av {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new FW(e.radius, e.detail);
  }
}
class EW extends _r {
  constructor(e = 1, t = 0.4, n = 12, i = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: i,
      arc: o
    }, n = Math.floor(n), i = Math.floor(i);
    const l = [], u = [], I = [], f = [], h = new Ze(), v = new Ze(), b = new Ze();
    for (let S = 0; S <= n; S++)
      for (let R = 0; R <= i; R++) {
        const W = R / i * o, x = S / n * Math.PI * 2;
        v.x = (e + t * Math.cos(x)) * Math.cos(W), v.y = (e + t * Math.cos(x)) * Math.sin(W), v.z = t * Math.sin(x), u.push(v.x, v.y, v.z), h.x = e * Math.cos(W), h.y = e * Math.sin(W), b.subVectors(v, h).normalize(), I.push(b.x, b.y, b.z), f.push(R / i), f.push(S / n);
      }
    for (let S = 1; S <= n; S++)
      for (let R = 1; R <= i; R++) {
        const W = (i + 1) * S + R - 1, x = (i + 1) * (S - 1) + R - 1, M = (i + 1) * (S - 1) + R, T = (i + 1) * S + R;
        l.push(W, x, T), l.push(x, M, T);
      }
    this.setIndex(l), this.setAttribute("position", new Mi(u, 3)), this.setAttribute("normal", new Mi(I, 3)), this.setAttribute("uv", new Mi(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new EW(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class TW extends _r {
  constructor(e = 1, t = 0.4, n = 64, i = 8, o = 2, l = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: i,
      p: o,
      q: l
    }, n = Math.floor(n), i = Math.floor(i);
    const u = [], I = [], f = [], h = [], v = new Ze(), b = new Ze(), S = new Ze(), R = new Ze(), W = new Ze(), x = new Ze(), M = new Ze();
    for (let E = 0; E <= n; ++E) {
      const _ = E / n * o * Math.PI * 2;
      T(_, o, l, e, S), T(_ + 0.01, o, l, e, R), x.subVectors(R, S), M.addVectors(R, S), W.crossVectors(x, M), M.crossVectors(W, x), W.normalize(), M.normalize();
      for (let P = 0; P <= i; ++P) {
        const U = P / i * Math.PI * 2, q = -t * Math.cos(U), k = t * Math.sin(U);
        v.x = S.x + (q * M.x + k * W.x), v.y = S.y + (q * M.y + k * W.y), v.z = S.z + (q * M.z + k * W.z), I.push(v.x, v.y, v.z), b.subVectors(v, S).normalize(), f.push(b.x, b.y, b.z), h.push(E / n), h.push(P / i);
      }
    }
    for (let E = 1; E <= n; E++)
      for (let _ = 1; _ <= i; _++) {
        const P = (i + 1) * (E - 1) + (_ - 1), U = (i + 1) * E + (_ - 1), q = (i + 1) * E + _, k = (i + 1) * (E - 1) + _;
        u.push(P, U, k), u.push(U, q, k);
      }
    this.setIndex(u), this.setAttribute("position", new Mi(I, 3)), this.setAttribute("normal", new Mi(f, 3)), this.setAttribute("uv", new Mi(h, 2));
    function T(E, _, P, U, q) {
      const k = Math.cos(E), O = Math.sin(E), J = P / _ * E, te = Math.cos(J);
      q.x = U * (2 + te) * 0.5 * k, q.y = U * (2 + te) * O * 0.5, q.z = U * Math.sin(J) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new TW(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class _W extends _r {
  constructor(e = new OX(new Ze(-1, -1, 0), new Ze(-1, 1, 0), new Ze(1, 1, 0)), t = 64, n = 1, i = 8, o = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: i,
      closed: o
    };
    const l = e.computeFrenetFrames(t, o);
    this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
    const u = new Ze(), I = new Ze(), f = new sn();
    let h = new Ze();
    const v = [], b = [], S = [], R = [];
    W(), this.setIndex(R), this.setAttribute("position", new Mi(v, 3)), this.setAttribute("normal", new Mi(b, 3)), this.setAttribute("uv", new Mi(S, 2));
    function W() {
      for (let E = 0; E < t; E++)
        x(E);
      x(o === !1 ? t : 0), T(), M();
    }
    function x(E) {
      h = e.getPointAt(E / t, h);
      const _ = l.normals[E], P = l.binormals[E];
      for (let U = 0; U <= i; U++) {
        const q = U / i * Math.PI * 2, k = Math.sin(q), O = -Math.cos(q);
        I.x = O * _.x + k * P.x, I.y = O * _.y + k * P.y, I.z = O * _.z + k * P.z, I.normalize(), b.push(I.x, I.y, I.z), u.x = h.x + n * I.x, u.y = h.y + n * I.y, u.z = h.z + n * I.z, v.push(u.x, u.y, u.z);
      }
    }
    function M() {
      for (let E = 1; E <= t; E++)
        for (let _ = 1; _ <= i; _++) {
          const P = (i + 1) * (E - 1) + (_ - 1), U = (i + 1) * E + (_ - 1), q = (i + 1) * E + _, k = (i + 1) * (E - 1) + _;
          R.push(P, U, k), R.push(U, q, k);
        }
    }
    function T() {
      for (let E = 0; E <= t; E++)
        for (let _ = 0; _ <= i; _++)
          f.x = E / t, f.y = _ / i, S.push(f.x, f.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new _W(
      new T2[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class uK extends _r {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), i = new Ze(), o = new Ze();
      if (e.index !== null) {
        const l = e.attributes.position, u = e.index;
        let I = e.groups;
        I.length === 0 && (I = [{ start: 0, count: u.count, materialIndex: 0 }]);
        for (let f = 0, h = I.length; f < h; ++f) {
          const v = I[f], b = v.start, S = v.count;
          for (let R = b, W = b + S; R < W; R += 3)
            for (let x = 0; x < 3; x++) {
              const M = u.getX(R + x), T = u.getX(R + (x + 1) % 3);
              i.fromBufferAttribute(l, M), o.fromBufferAttribute(l, T), d_(i, o, n) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const l = e.attributes.position;
        for (let u = 0, I = l.count / 3; u < I; u++)
          for (let f = 0; f < 3; f++) {
            const h = 3 * u + f, v = 3 * u + (f + 1) % 3;
            i.fromBufferAttribute(l, h), o.fromBufferAttribute(l, v), d_(i, o, n) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new Mi(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function d_(a, e, t) {
  const n = `${a.x},${a.y},${a.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${a.x},${a.y},${a.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var I_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Rb,
  CapsuleGeometry: RW,
  CircleGeometry: xW,
  ConeGeometry: WW,
  CylinderGeometry: CB,
  DodecahedronGeometry: VW,
  EdgesGeometry: aK,
  ExtrudeGeometry: MW,
  IcosahedronGeometry: HW,
  LatheGeometry: Ow,
  OctahedronGeometry: Pw,
  PlaneGeometry: dB,
  PolyhedronGeometry: av,
  RingGeometry: XW,
  ShapeGeometry: YW,
  SphereGeometry: Jw,
  TetrahedronGeometry: FW,
  TorusGeometry: EW,
  TorusKnotGeometry: TW,
  TubeGeometry: _W,
  WireframeGeometry: uK
});
class cK extends Gc {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new hi(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class gK extends zh {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class JX extends Gc {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new hi(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = iv, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Kd(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class dK extends JX {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new sn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return el(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new hi(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new hi(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new hi(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class IK extends Gc {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new hi(16777215), this.specular = new hi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = iv, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Kd(), this.combine = zw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class CK extends Gc {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new hi(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = iv, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class hK extends Gc {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = iv, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class fK extends Gc {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new hi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = iv, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Kd(), this.combine = zw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class pK extends Gc {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new hi(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = iv, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class mK extends Jg {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function sb(a, e, t) {
  return !a || // let 'undefined' and 'null' pass
  !t && a.constructor === e ? a : typeof e.BYTES_PER_ELEMENT == "number" ? new e(a) : Array.prototype.slice.call(a);
}
function AK(a) {
  return ArrayBuffer.isView(a) && !(a instanceof DataView);
}
function vK(a) {
  function e(i, o) {
    return a[i] - a[o];
  }
  const t = a.length, n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function HH(a, e, t) {
  const n = a.length, i = new a.constructor(n);
  for (let o = 0, l = 0; l !== n; ++o) {
    const u = t[o] * e;
    for (let I = 0; I !== e; ++I)
      i[l++] = a[u + I];
  }
  return i;
}
function QX(a, e, t, n) {
  let i = 1, o = a[0];
  for (; o !== void 0 && o[n] === void 0; )
    o = a[i++];
  if (o === void 0) return;
  let l = o[n];
  if (l !== void 0)
    if (Array.isArray(l))
      do
        l = o[n], l !== void 0 && (e.push(o.time), t.push.apply(t, l)), o = a[i++];
      while (o !== void 0);
    else if (l.toArray !== void 0)
      do
        l = o[n], l !== void 0 && (e.push(o.time), l.toArray(t, t.length)), o = a[i++];
      while (o !== void 0);
    else
      do
        l = o[n], l !== void 0 && (e.push(o.time), t.push(l)), o = a[i++];
      while (o !== void 0);
}
function e6(a, e, t, n, i = 30) {
  const o = a.clone();
  o.name = e;
  const l = [];
  for (let I = 0; I < o.tracks.length; ++I) {
    const f = o.tracks[I], h = f.getValueSize(), v = [], b = [];
    for (let S = 0; S < f.times.length; ++S) {
      const R = f.times[S] * i;
      if (!(R < t || R >= n)) {
        v.push(f.times[S]);
        for (let W = 0; W < h; ++W)
          b.push(f.values[S * h + W]);
      }
    }
    v.length !== 0 && (f.times = sb(v, f.times.constructor), f.values = sb(b, f.values.constructor), l.push(f));
  }
  o.tracks = l;
  let u = 1 / 0;
  for (let I = 0; I < o.tracks.length; ++I)
    u > o.tracks[I].times[0] && (u = o.tracks[I].times[0]);
  for (let I = 0; I < o.tracks.length; ++I)
    o.tracks[I].shift(-1 * u);
  return o.resetDuration(), o;
}
function t6(a, e = 0, t = a, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length, o = e / n;
  for (let l = 0; l < i; ++l) {
    const u = t.tracks[l], I = u.ValueTypeName;
    if (I === "bool" || I === "string") continue;
    const f = a.tracks.find(function(M) {
      return M.name === u.name && M.ValueTypeName === I;
    });
    if (f === void 0) continue;
    let h = 0;
    const v = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = v / 3);
    let b = 0;
    const S = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (b = S / 3);
    const R = u.times.length - 1;
    let W;
    if (o <= u.times[0]) {
      const M = h, T = v - h;
      W = u.values.slice(M, T);
    } else if (o >= u.times[R]) {
      const M = R * v + h, T = M + v - h;
      W = u.values.slice(M, T);
    } else {
      const M = u.createInterpolant(), T = h, E = v - h;
      M.evaluate(o), W = M.resultBuffer.slice(T, E);
    }
    I === "quaternion" && new zu().fromArray(W).normalize().conjugate().toArray(W);
    const x = f.times.length;
    for (let M = 0; M < x; ++M) {
      const T = M * S + b;
      if (I === "quaternion")
        zu.multiplyQuaternionsFlat(
          f.values,
          T,
          W,
          0,
          f.values,
          T
        );
      else {
        const E = S - b * 2;
        for (let _ = 0; _ < E; ++_)
          f.values[T + _] -= W[_];
      }
    }
  }
  return a.blendMode = VX, a;
}
const n6 = {
  convertArray: sb,
  isTypedArray: AK,
  getKeyframeOrder: vK,
  sortedArray: HH,
  flattenJSON: QX,
  subclip: e6,
  makeClipAdditive: t6
};
class Qw {
  constructor(e, t, n, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, i = t[n], o = t[n - 1];
    e: {
      t: {
        let l;
        n: {
          i: if (!(e < i)) {
            for (let u = n + 2; ; ) {
              if (i === void 0) {
                if (e < o) break i;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === u) break;
              if (o = i, i = t[++n], e < i)
                break t;
            }
            l = t.length;
            break n;
          }
          if (!(e >= o)) {
            const u = t[1];
            e < u && (n = 2, o = u);
            for (let I = n - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === I) break;
              if (i = o, o = t[--n - 1], e >= o)
                break t;
            }
            l = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < l; ) {
          const u = n + l >>> 1;
          e < t[u] ? l = u : n = u + 1;
        }
        if (i = t[n], o = t[n - 1], o === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, o, i);
    }
    return this.interpolate_(n, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, o = e * i;
    for (let l = 0; l !== i; ++l)
      t[l] = n[o + l];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class yK extends Qw {
  constructor(e, t, n, i) {
    super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: rb,
      endingEnd: rb
    };
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let o = e - 2, l = e + 1, u = i[o], I = i[l];
    if (u === void 0)
      switch (this.getSettings_().endingStart) {
        case ab:
          o = e, u = 2 * t - n;
          break;
        case Cw:
          o = i.length - 2, u = t + i[o] - i[o + 1];
          break;
        default:
          o = e, u = n;
      }
    if (I === void 0)
      switch (this.getSettings_().endingEnd) {
        case ab:
          l = e, I = 2 * n - t;
          break;
        case Cw:
          l = 1, I = n + i[1] - i[0];
          break;
        default:
          l = e - 1, I = t;
      }
    const f = (n - t) * 0.5, h = this.valueSize;
    this._weightPrev = f / (t - u), this._weightNext = f / (I - n), this._offsetPrev = o * h, this._offsetNext = l * h;
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, I = e * u, f = I - u, h = this._offsetPrev, v = this._offsetNext, b = this._weightPrev, S = this._weightNext, R = (n - t) / (i - t), W = R * R, x = W * R, M = -b * x + 2 * b * W - b * R, T = (1 + b) * x + (-1.5 - 2 * b) * W + (-0.5 + b) * R + 1, E = (-1 - S) * x + (1.5 + S) * W + 0.5 * R, _ = S * x - S * W;
    for (let P = 0; P !== u; ++P)
      o[P] = M * l[h + P] + T * l[f + P] + E * l[I + P] + _ * l[v + P];
    return o;
  }
}
class jX extends Qw {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, I = e * u, f = I - u, h = (n - t) / (i - t), v = 1 - h;
    for (let b = 0; b !== u; ++b)
      o[b] = l[f + b] * v + l[I + b] * h;
    return o;
  }
}
class bK extends Qw {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Lh {
  constructor(e, t, n, i) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = sb(t, this.TimeBufferType), this.values = sb(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: sb(e.times, Array),
        values: sb(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new bK(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new jX(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new yK(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Iw:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case X2:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case J1:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Iw;
      case this.InterpolantFactoryMethodLinear:
        return X2;
      case this.InterpolantFactoryMethodSmooth:
        return J1;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, i = n.length;
    let o = 0, l = i - 1;
    for (; o !== i && n[o] < e; )
      ++o;
    for (; l !== -1 && n[l] > t; )
      --l;
    if (++l, o !== 0 || l !== i) {
      o >= l && (l = Math.max(l, 1), o = l - 1);
      const u = this.getValueSize();
      this.times = n.slice(o, l), this.values = this.values.slice(o * u, l * u);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, i = this.values, o = n.length;
    o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let l = null;
    for (let u = 0; u !== o; u++) {
      const I = n[u];
      if (typeof I == "number" && isNaN(I)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, u, I), e = !1;
        break;
      }
      if (l !== null && l > I) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, u, I, l), e = !1;
        break;
      }
      l = I;
    }
    if (i !== void 0 && AK(i))
      for (let u = 0, I = i.length; u !== I; ++u) {
        const f = i[u];
        if (isNaN(f)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, u, f), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === J1, o = e.length - 1;
    let l = 1;
    for (let u = 1; u < o; ++u) {
      let I = !1;
      const f = e[u], h = e[u + 1];
      if (f !== h && (u !== 1 || f !== e[0]))
        if (i)
          I = !0;
        else {
          const v = u * n, b = v - n, S = v + n;
          for (let R = 0; R !== n; ++R) {
            const W = t[v + R];
            if (W !== t[b + R] || W !== t[S + R]) {
              I = !0;
              break;
            }
          }
        }
      if (I) {
        if (u !== l) {
          e[l] = e[u];
          const v = u * n, b = l * n;
          for (let S = 0; S !== n; ++S)
            t[b + S] = t[v + S];
        }
        ++l;
      }
    }
    if (o > 0) {
      e[l] = e[o];
      for (let u = o * n, I = l * n, f = 0; f !== n; ++f)
        t[I + f] = t[u + f];
      ++l;
    }
    return l !== e.length ? (this.times = e.slice(0, l), this.values = t.slice(0, l * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
Lh.prototype.TimeBufferType = Float32Array;
Lh.prototype.ValueBufferType = Float32Array;
Lh.prototype.DefaultInterpolation = X2;
class xb extends Lh {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, n) {
    super(e, t, n);
  }
}
xb.prototype.ValueTypeName = "bool";
xb.prototype.ValueBufferType = Array;
xb.prototype.DefaultInterpolation = Iw;
xb.prototype.InterpolantFactoryMethodLinear = void 0;
xb.prototype.InterpolantFactoryMethodSmooth = void 0;
class qX extends Lh {
}
qX.prototype.ValueTypeName = "color";
class Sw extends Lh {
}
Sw.prototype.ValueTypeName = "number";
class GK extends Qw {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, I = (n - t) / (i - t);
    let f = e * u;
    for (let h = f + u; f !== h; f += 4)
      zu.slerpFlat(o, 0, l, f - u, l, f, I);
    return o;
  }
}
class jw extends Lh {
  InterpolantFactoryMethodLinear(e) {
    return new GK(this.times, this.values, this.getValueSize(), e);
  }
}
jw.prototype.ValueTypeName = "quaternion";
jw.prototype.InterpolantFactoryMethodSmooth = void 0;
class Wb extends Lh {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, n) {
    super(e, t, n);
  }
}
Wb.prototype.ValueTypeName = "string";
Wb.prototype.ValueBufferType = Array;
Wb.prototype.DefaultInterpolation = Iw;
Wb.prototype.InterpolantFactoryMethodLinear = void 0;
Wb.prototype.InterpolantFactoryMethodSmooth = void 0;
class Zw extends Lh {
}
Zw.prototype.ValueTypeName = "vector";
class ww {
  constructor(e = "", t = -1, n = [], i = pW) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = zI(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, i = 1 / (e.fps || 1);
    for (let l = 0, u = n.length; l !== u; ++l)
      t.push(r6(n[l]).scale(i));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return o.uuid = e.uuid, o;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let o = 0, l = n.length; o !== l; ++o)
      t.push(Lh.toJSON(n[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const o = t.length, l = [];
    for (let u = 0; u < o; u++) {
      let I = [], f = [];
      I.push(
        (u + o - 1) % o,
        u,
        (u + 1) % o
      ), f.push(0, 1, 0);
      const h = vK(I);
      I = HH(I, 1, h), f = HH(f, 1, h), !i && I[0] === 0 && (I.push(o), f.push(f[0])), l.push(
        new Sw(
          ".morphTargetInfluences[" + t[u].name + "]",
          I,
          f
        ).scale(1 / n)
      );
    }
    return new this(e, -1, l);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < n.length; i++)
      if (n[i].name === t)
        return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {}, o = /^([\w-]*?)([\d]+)$/;
    for (let u = 0, I = e.length; u < I; u++) {
      const f = e[u], h = f.name.match(o);
      if (h && h.length > 1) {
        const v = h[1];
        let b = i[v];
        b || (i[v] = b = []), b.push(f);
      }
    }
    const l = [];
    for (const u in i)
      l.push(this.CreateFromMorphTargetSequence(u, i[u], t, n));
    return l;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(v, b, S, R, W) {
      if (S.length !== 0) {
        const x = [], M = [];
        QX(S, x, M, R), x.length !== 0 && W.push(new v(b, x, M));
      }
    }, i = [], o = e.name || "default", l = e.fps || 30, u = e.blendMode;
    let I = e.length || -1;
    const f = e.hierarchy || [];
    for (let v = 0; v < f.length; v++) {
      const b = f[v].keys;
      if (!(!b || b.length === 0))
        if (b[0].morphTargets) {
          const S = {};
          let R;
          for (R = 0; R < b.length; R++)
            if (b[R].morphTargets)
              for (let W = 0; W < b[R].morphTargets.length; W++)
                S[b[R].morphTargets[W]] = -1;
          for (const W in S) {
            const x = [], M = [];
            for (let T = 0; T !== b[R].morphTargets.length; ++T) {
              const E = b[R];
              x.push(E.time), M.push(E.morphTarget === W ? 1 : 0);
            }
            i.push(new Sw(".morphTargetInfluence[" + W + "]", x, M));
          }
          I = S.length * l;
        } else {
          const S = ".bones[" + t[v].name + "]";
          n(
            Zw,
            S + ".position",
            b,
            "pos",
            i
          ), n(
            jw,
            S + ".quaternion",
            b,
            "rot",
            i
          ), n(
            Zw,
            S + ".scale",
            b,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(o, I, i, u);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const o = this.tracks[n];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function i6(a) {
  switch (a.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Sw;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Zw;
    case "color":
      return qX;
    case "quaternion":
      return jw;
    case "bool":
    case "boolean":
      return xb;
    case "string":
      return Wb;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
}
function r6(a) {
  if (a.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = i6(a.type);
  if (a.times === void 0) {
    const t = [], n = [];
    QX(a.keys, t, n, "value"), a.times = t, a.values = n;
  }
  return e.parse !== void 0 ? e.parse(a) : new e(a.name, a.times, a.values, a.interpolation);
}
const Rm = {
  enabled: !1,
  files: {},
  add: function(a, e) {
    this.enabled !== !1 && (this.files[a] = e);
  },
  get: function(a) {
    if (this.enabled !== !1)
      return this.files[a];
  },
  remove: function(a) {
    delete this.files[a];
  },
  clear: function() {
    this.files = {};
  }
};
class $X {
  constructor(e, t, n) {
    const i = this;
    let o = !1, l = 0, u = 0, I;
    const f = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(h) {
      u++, o === !1 && i.onStart !== void 0 && i.onStart(h, l, u), o = !0;
    }, this.itemEnd = function(h) {
      l++, i.onProgress !== void 0 && i.onProgress(h, l, u), l === u && (o = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(h) {
      i.onError !== void 0 && i.onError(h);
    }, this.resolveURL = function(h) {
      return I ? I(h) : h;
    }, this.setURLModifier = function(h) {
      return I = h, this;
    }, this.addHandler = function(h, v) {
      return f.push(h, v), this;
    }, this.removeHandler = function(h) {
      const v = f.indexOf(h);
      return v !== -1 && f.splice(v, 2), this;
    }, this.getHandler = function(h) {
      for (let v = 0, b = f.length; v < b; v += 2) {
        const S = f[v], R = f[v + 1];
        if (S.global && (S.lastIndex = 0), S.test(h))
          return R;
      }
      return null;
    };
  }
}
const BK = /* @__PURE__ */ new $X();
class kd {
  constructor(e) {
    this.manager = e !== void 0 ? e : BK, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(i, o) {
      n.load(e, i, t, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
kd.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const ym = {};
class a6 extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class Xm extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = Rm.get(e);
    if (o !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(o), this.manager.itemEnd(e);
      }, 0), o;
    if (ym[e] !== void 0) {
      ym[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      return;
    }
    ym[e] = [], ym[e].push({
      onLoad: t,
      onProgress: n,
      onError: i
    });
    const l = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), u = this.mimeType, I = this.responseType;
    fetch(l).then((f) => {
      if (f.status === 200 || f.status === 0) {
        if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0)
          return f;
        const h = ym[e], v = f.body.getReader(), b = f.headers.get("X-File-Size") || f.headers.get("Content-Length"), S = b ? parseInt(b) : 0, R = S !== 0;
        let W = 0;
        const x = new ReadableStream({
          start(M) {
            T();
            function T() {
              v.read().then(({ done: E, value: _ }) => {
                if (E)
                  M.close();
                else {
                  W += _.byteLength;
                  const P = new ProgressEvent("progress", { lengthComputable: R, loaded: W, total: S });
                  for (let U = 0, q = h.length; U < q; U++) {
                    const k = h[U];
                    k.onProgress && k.onProgress(P);
                  }
                  M.enqueue(_), T();
                }
              }, (E) => {
                M.error(E);
              });
            }
          }
        });
        return new Response(x);
      } else
        throw new a6(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`, f);
    }).then((f) => {
      switch (I) {
        case "arraybuffer":
          return f.arrayBuffer();
        case "blob":
          return f.blob();
        case "document":
          return f.text().then((h) => new DOMParser().parseFromString(h, u));
        case "json":
          return f.json();
        default:
          if (u === void 0)
            return f.text();
          {
            const v = /charset="?([^;"\s]*)"?/i.exec(u), b = v && v[1] ? v[1].toLowerCase() : void 0, S = new TextDecoder(b);
            return f.arrayBuffer().then((R) => S.decode(R));
          }
      }
    }).then((f) => {
      Rm.add(e, f);
      const h = ym[e];
      delete ym[e];
      for (let v = 0, b = h.length; v < b; v++) {
        const S = h[v];
        S.onLoad && S.onLoad(f);
      }
    }).catch((f) => {
      const h = ym[e];
      if (h === void 0)
        throw this.manager.itemError(e), f;
      delete ym[e];
      for (let v = 0, b = h.length; v < b; v++) {
        const S = h[v];
        S.onError && S.onError(f);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class o6 extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = new Xm(this.manager);
    l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (I) {
        i ? i(I) : console.error(I), o.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = ww.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class s6 extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = [], u = new ZW(), I = new Xm(this.manager);
    I.setPath(this.path), I.setResponseType("arraybuffer"), I.setRequestHeader(this.requestHeader), I.setWithCredentials(o.withCredentials);
    let f = 0;
    function h(v) {
      I.load(e[v], function(b) {
        const S = o.parse(b, !0);
        l[v] = {
          width: S.width,
          height: S.height,
          format: S.format,
          mipmaps: S.mipmaps
        }, f += 1, f === 6 && (S.mipmapCount === 1 && (u.minFilter = nl), u.image = l, u.format = S.format, u.needsUpdate = !0, t && t(u));
      }, n, i);
    }
    if (Array.isArray(e))
      for (let v = 0, b = e.length; v < b; ++v)
        h(v);
    else
      I.load(e, function(v) {
        const b = o.parse(v, !0);
        if (b.isCubemap) {
          const S = b.mipmaps.length / b.mipmapCount;
          for (let R = 0; R < S; R++) {
            l[R] = { mipmaps: [] };
            for (let W = 0; W < b.mipmapCount; W++)
              l[R].mipmaps.push(b.mipmaps[R * b.mipmapCount + W]), l[R].format = b.format, l[R].width = b.width, l[R].height = b.height;
          }
          u.image = l;
        } else
          u.image.width = b.width, u.image.height = b.height, u.mipmaps = b.mipmaps;
        b.mipmapCount === 1 && (u.minFilter = nl), u.format = b.format, u.needsUpdate = !0, t && t(u);
      }, n, i);
    return u;
  }
}
class Rw extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = Rm.get(e);
    if (l !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    const u = vw("img");
    function I() {
      h(), Rm.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function f(v) {
      h(), i && i(v), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function h() {
      u.removeEventListener("load", I, !1), u.removeEventListener("error", f, !1);
    }
    return u.addEventListener("load", I, !1), u.addEventListener("error", f, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (u.crossOrigin = this.crossOrigin), o.manager.itemStart(e), u.src = e, u;
  }
}
class l6 extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = new Dw();
    o.colorSpace = HC;
    const l = new Rw(this.manager);
    l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
    let u = 0;
    function I(f) {
      l.load(e[f], function(h) {
        o.images[f] = h, u++, u === 6 && (o.needsUpdate = !0, t && t(o));
      }, void 0, i);
    }
    for (let f = 0; f < e.length; ++f)
      I(f);
    return o;
  }
}
class u6 extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = new lp(), u = new Xm(this.manager);
    return u.setResponseType("arraybuffer"), u.setRequestHeader(this.requestHeader), u.setPath(this.path), u.setWithCredentials(o.withCredentials), u.load(e, function(I) {
      let f;
      try {
        f = o.parse(I);
      } catch (h) {
        if (i !== void 0)
          i(h);
        else {
          console.error(h);
          return;
        }
      }
      f.image !== void 0 ? l.image = f.image : f.data !== void 0 && (l.image.width = f.width, l.image.height = f.height, l.image.data = f.data), l.wrapS = f.wrapS !== void 0 ? f.wrapS : XC, l.wrapT = f.wrapT !== void 0 ? f.wrapT : XC, l.magFilter = f.magFilter !== void 0 ? f.magFilter : nl, l.minFilter = f.minFilter !== void 0 ? f.minFilter : nl, l.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1, f.colorSpace !== void 0 && (l.colorSpace = f.colorSpace), f.flipY !== void 0 && (l.flipY = f.flipY), f.format !== void 0 && (l.format = f.format), f.type !== void 0 && (l.type = f.type), f.mipmaps !== void 0 && (l.mipmaps = f.mipmaps, l.minFilter = np), f.mipmapCount === 1 && (l.minFilter = nl), f.generateMipmaps !== void 0 && (l.generateMipmaps = f.generateMipmaps), l.needsUpdate = !0, t && t(l, f);
    }, n, i), l;
  }
}
class c6 extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = new Fs(), l = new Rw(this.manager);
    return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(e, function(u) {
      o.image = u, o.needsUpdate = !0, t !== void 0 && t(o);
    }, n, i), o;
  }
}
class ov extends Aa {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new hi(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
  }
}
class SK extends ov {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Aa.DEFAULT_UP), this.updateMatrix(), this.groundColor = new hi(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const MM = /* @__PURE__ */ new tr(), C_ = /* @__PURE__ */ new Ze(), h_ = /* @__PURE__ */ new Ze();
class eY {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new sn(512, 512), this.map = null, this.mapPass = null, this.matrix = new tr(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Uw(), this._frameExtents = new sn(1, 1), this._viewportCount = 1, this._viewports = [
      new ro(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    C_.setFromMatrixPosition(e.matrixWorld), t.position.copy(C_), h_.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(h_), t.updateMatrixWorld(), MM.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(MM), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(MM);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class g6 extends eY {
  constructor() {
    super(new tl(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = $G * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, o = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || o !== t.far) && (t.fov = n, t.aspect = i, t.far = o, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class ZK extends ov {
  constructor(e, t, n = 0, i = Math.PI / 3, o = 0, l = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Aa.DEFAULT_UP), this.updateMatrix(), this.target = new Aa(), this.distance = n, this.angle = i, this.penumbra = o, this.decay = l, this.map = null, this.shadow = new g6();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const f_ = /* @__PURE__ */ new tr(), wZ = /* @__PURE__ */ new Ze(), HM = /* @__PURE__ */ new Ze();
class d6 extends eY {
  constructor() {
    super(new tl(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new sn(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new ro(2, 1, 1, 1),
      // negative X
      new ro(0, 1, 1, 1),
      // positive Z
      new ro(3, 1, 1, 1),
      // negative Z
      new ro(1, 1, 1, 1),
      // positive Y
      new ro(3, 0, 1, 1),
      // negative Y
      new ro(1, 0, 1, 1)
    ], this._cubeDirections = [
      new Ze(1, 0, 0),
      new Ze(-1, 0, 0),
      new Ze(0, 0, 1),
      new Ze(0, 0, -1),
      new Ze(0, 1, 0),
      new Ze(0, -1, 0)
    ], this._cubeUps = [
      new Ze(0, 1, 0),
      new Ze(0, 1, 0),
      new Ze(0, 1, 0),
      new Ze(0, 1, 0),
      new Ze(0, 0, 1),
      new Ze(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, i = this.matrix, o = e.distance || n.far;
    o !== n.far && (n.far = o, n.updateProjectionMatrix()), wZ.setFromMatrixPosition(e.matrixWorld), n.position.copy(wZ), HM.copy(n.position), HM.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(HM), n.updateMatrixWorld(), i.makeTranslation(-wZ.x, -wZ.y, -wZ.z), f_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(f_);
  }
}
class wK extends ov {
  constructor(e, t, n = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new d6();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class I6 extends eY {
  constructor() {
    super(new wm(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class RK extends ov {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Aa.DEFAULT_UP), this.updateMatrix(), this.target = new Aa(), this.shadow = new I6();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class xK extends ov {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class WK extends ov {
  constructor(e, t, n = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class VK {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new Ze());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.282095), t.addScaledVector(l[1], 0.488603 * i), t.addScaledVector(l[2], 0.488603 * o), t.addScaledVector(l[3], 0.488603 * n), t.addScaledVector(l[4], 1.092548 * (n * i)), t.addScaledVector(l[5], 1.092548 * (i * o)), t.addScaledVector(l[6], 0.315392 * (3 * o * o - 1)), t.addScaledVector(l[7], 1.092548 * (n * o)), t.addScaledVector(l[8], 0.546274 * (n * n - i * i)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.886227), t.addScaledVector(l[1], 2 * 0.511664 * i), t.addScaledVector(l[2], 2 * 0.511664 * o), t.addScaledVector(l[3], 2 * 0.511664 * n), t.addScaledVector(l[4], 2 * 0.429043 * n * i), t.addScaledVector(l[5], 2 * 0.429043 * i * o), t.addScaledVector(l[6], 0.743125 * o * o - 0.247708), t.addScaledVector(l[7], 2 * 0.429043 * n * o), t.addScaledVector(l[8], 0.429043 * (n * n - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].toArray(e, t + i * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, i = e.y, o = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * o, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * o, t[6] = 0.315392 * (3 * o * o - 1), t[7] = 1.092548 * n * o, t[8] = 0.546274 * (n * n - i * i);
  }
}
class NK extends ov {
  constructor(e = new VK(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class zW extends kd {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, i) {
    const o = this, l = new Xm(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (I) {
        i ? i(I) : console.error(I), o.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = this.textures;
    function n(o) {
      return t[o] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", o), t[o];
    }
    const i = zW.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new hi().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const o in e.uniforms) {
        const l = e.uniforms[o];
        switch (i.uniforms[o] = {}, l.type) {
          case "t":
            i.uniforms[o].value = n(l.value);
            break;
          case "c":
            i.uniforms[o].value = new hi().setHex(l.value);
            break;
          case "v2":
            i.uniforms[o].value = new sn().fromArray(l.value);
            break;
          case "v3":
            i.uniforms[o].value = new Ze().fromArray(l.value);
            break;
          case "v4":
            i.uniforms[o].value = new ro().fromArray(l.value);
            break;
          case "m3":
            i.uniforms[o].value = new Nr().fromArray(l.value);
            break;
          case "m4":
            i.uniforms[o].value = new tr().fromArray(l.value);
            break;
          default:
            i.uniforms[o].value = l.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const o in e.extensions)
        i.extensions[o] = e.extensions[o];
    if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]), i.normalScale = new sn().fromArray(o);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new sn().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: cK,
      SpriteMaterial: _X,
      RawShaderMaterial: gK,
      ShaderMaterial: zh,
      PointsMaterial: KX,
      MeshPhysicalMaterial: dK,
      MeshStandardMaterial: JX,
      MeshPhongMaterial: IK,
      MeshToonMaterial: CK,
      MeshNormalMaterial: hK,
      MeshLambertMaterial: fK,
      MeshDepthMaterial: EX,
      MeshDistanceMaterial: TX,
      MeshBasicMaterial: rv,
      MeshMatcapMaterial: pK,
      LineDashedMaterial: mK,
      LineBasicMaterial: Jg,
      Material: Gc
    };
    return new t[e]();
  }
}
class XH {
  static decodeText(e) {
    if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class MK extends _r {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class HK extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = new Xm(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (I) {
        i ? i(I) : console.error(I), o.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = {}, n = {};
    function i(S, R) {
      if (t[R] !== void 0) return t[R];
      const x = S.interleavedBuffers[R], M = o(S, x.buffer), T = EG(x.type, M), E = new BW(T, x.stride);
      return E.uuid = x.uuid, t[R] = E, E;
    }
    function o(S, R) {
      if (n[R] !== void 0) return n[R];
      const x = S.arrayBuffers[R], M = new Uint32Array(x).buffer;
      return n[R] = M, M;
    }
    const l = e.isInstancedBufferGeometry ? new MK() : new _r(), u = e.data.index;
    if (u !== void 0) {
      const S = EG(u.type, u.array);
      l.setIndex(new Zo(S, 1));
    }
    const I = e.data.attributes;
    for (const S in I) {
      const R = I[S];
      let W;
      if (R.isInterleavedBufferAttribute) {
        const x = i(e.data, R.data);
        W = new yb(x, R.itemSize, R.offset, R.normalized);
      } else {
        const x = EG(R.type, R.array), M = R.isInstancedBufferAttribute ? tB : Zo;
        W = new M(x, R.itemSize, R.normalized);
      }
      R.name !== void 0 && (W.name = R.name), R.usage !== void 0 && W.setUsage(R.usage), l.setAttribute(S, W);
    }
    const f = e.data.morphAttributes;
    if (f)
      for (const S in f) {
        const R = f[S], W = [];
        for (let x = 0, M = R.length; x < M; x++) {
          const T = R[x];
          let E;
          if (T.isInterleavedBufferAttribute) {
            const _ = i(e.data, T.data);
            E = new yb(_, T.itemSize, T.offset, T.normalized);
          } else {
            const _ = EG(T.type, T.array);
            E = new Zo(_, T.itemSize, T.normalized);
          }
          T.name !== void 0 && (E.name = T.name), W.push(E);
        }
        l.morphAttributes[S] = W;
      }
    e.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
    const v = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (v !== void 0)
      for (let S = 0, R = v.length; S !== R; ++S) {
        const W = v[S];
        l.addGroup(W.start, W.count, W.materialIndex);
      }
    const b = e.data.boundingSphere;
    if (b !== void 0) {
      const S = new Ze();
      b.center !== void 0 && S.fromArray(b.center), l.boundingSphere = new og(S, b.radius);
    }
    return e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l;
  }
}
class C6 extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = this.path === "" ? XH.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || l;
    const u = new Xm(this.manager);
    u.setPath(this.path), u.setRequestHeader(this.requestHeader), u.setWithCredentials(this.withCredentials), u.load(e, function(I) {
      let f = null;
      try {
        f = JSON.parse(I);
      } catch (v) {
        i !== void 0 && i(v), console.error("THREE:ObjectLoader: Can't parse " + e + ".", v.message);
        return;
      }
      const h = f.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      o.parse(f, t);
    }, n, i);
  }
  async loadAsync(e, t) {
    const n = this, i = this.path === "" ? XH.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new Xm(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const l = await o.loadAsync(e, t), u = JSON.parse(l), I = u.metadata;
    if (I === void 0 || I.type === void 0 || I.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(u);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), o = this.parseGeometries(e.geometries, i), l = this.parseImages(e.images, function() {
      t !== void 0 && t(f);
    }), u = this.parseTextures(e.textures, l), I = this.parseMaterials(e.materials, u), f = this.parseObject(e.object, o, I, u, n), h = this.parseSkeletons(e.skeletons, f);
    if (this.bindSkeletons(f, h), this.bindLightTargets(f), t !== void 0) {
      let v = !1;
      for (const b in l)
        if (l[b].data instanceof HTMLImageElement) {
          v = !0;
          break;
        }
      v === !1 && t(f);
    }
    return f;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), o = await this.parseImagesAsync(e.images), l = this.parseTextures(e.textures, o), u = this.parseMaterials(e.materials, l), I = this.parseObject(e.object, i, u, l, t), f = this.parseSkeletons(e.skeletons, I);
    return this.bindSkeletons(I, f), this.bindLightTargets(I), I;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const o = new Ib().fromJSON(e[n]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, i = {};
    if (t.traverse(function(o) {
      o.isBone && (i[o.uuid] = o);
    }), e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const u = new SW().fromJSON(e[o], i);
        n[u.uuid] = u;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new HK();
      for (let o = 0, l = e.length; o < l; o++) {
        let u;
        const I = e[o];
        switch (I.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            u = i.parse(I);
            break;
          default:
            I.type in I_ ? u = I_[I.type].fromJSON(I, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${I.type}"`);
        }
        u.uuid = I.uuid, I.name !== void 0 && (u.name = I.name), I.userData !== void 0 && (u.userData = I.userData), n[I.uuid] = u;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, i = {};
    if (e !== void 0) {
      const o = new zW();
      o.setTextures(t);
      for (let l = 0, u = e.length; l < u; l++) {
        const I = e[l];
        n[I.uuid] === void 0 && (n[I.uuid] = o.parse(I)), i[I.uuid] = n[I.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n], o = ww.parse(i);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, i = {};
    let o;
    function l(I) {
      return n.manager.itemStart(I), o.load(I, function() {
        n.manager.itemEnd(I);
      }, void 0, function() {
        n.manager.itemError(I), n.manager.itemEnd(I);
      });
    }
    function u(I) {
      if (typeof I == "string") {
        const f = I, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : n.resourcePath + f;
        return l(h);
      } else
        return I.data ? {
          data: EG(I.type, I.data),
          width: I.width,
          height: I.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const I = new $X(t);
      o = new Rw(I), o.setCrossOrigin(this.crossOrigin);
      for (let f = 0, h = e.length; f < h; f++) {
        const v = e[f], b = v.url;
        if (Array.isArray(b)) {
          const S = [];
          for (let R = 0, W = b.length; R < W; R++) {
            const x = b[R], M = u(x);
            M !== null && (M instanceof HTMLImageElement ? S.push(M) : S.push(new lp(M.data, M.width, M.height)));
          }
          i[v.uuid] = new ob(S);
        } else {
          const S = u(v.url);
          i[v.uuid] = new ob(S);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let i;
    async function o(l) {
      if (typeof l == "string") {
        const u = l, I = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : t.resourcePath + u;
        return await i.loadAsync(I);
      } else
        return l.data ? {
          data: EG(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new Rw(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let l = 0, u = e.length; l < u; l++) {
        const I = e[l], f = I.url;
        if (Array.isArray(f)) {
          const h = [];
          for (let v = 0, b = f.length; v < b; v++) {
            const S = f[v], R = await o(S);
            R !== null && (R instanceof HTMLImageElement ? h.push(R) : h.push(new lp(R.data, R.width, R.height)));
          }
          n[I.uuid] = new ob(h);
        } else {
          const h = await o(I.url);
          n[I.uuid] = new ob(h);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(o, l) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), l[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const u = e[o];
        u.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', u.uuid), t[u.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", u.image);
        const I = t[u.image], f = I.data;
        let h;
        Array.isArray(f) ? (h = new Dw(), f.length === 6 && (h.needsUpdate = !0)) : (f && f.data ? h = new lp() : h = new Fs(), f && (h.needsUpdate = !0)), h.source = I, h.uuid = u.uuid, u.name !== void 0 && (h.name = u.name), u.mapping !== void 0 && (h.mapping = n(u.mapping, h6)), u.channel !== void 0 && (h.channel = u.channel), u.offset !== void 0 && h.offset.fromArray(u.offset), u.repeat !== void 0 && h.repeat.fromArray(u.repeat), u.center !== void 0 && h.center.fromArray(u.center), u.rotation !== void 0 && (h.rotation = u.rotation), u.wrap !== void 0 && (h.wrapS = n(u.wrap[0], p_), h.wrapT = n(u.wrap[1], p_)), u.format !== void 0 && (h.format = u.format), u.internalFormat !== void 0 && (h.internalFormat = u.internalFormat), u.type !== void 0 && (h.type = u.type), u.colorSpace !== void 0 && (h.colorSpace = u.colorSpace), u.minFilter !== void 0 && (h.minFilter = n(u.minFilter, m_)), u.magFilter !== void 0 && (h.magFilter = n(u.magFilter, m_)), u.anisotropy !== void 0 && (h.anisotropy = u.anisotropy), u.flipY !== void 0 && (h.flipY = u.flipY), u.generateMipmaps !== void 0 && (h.generateMipmaps = u.generateMipmaps), u.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = u.premultiplyAlpha), u.unpackAlignment !== void 0 && (h.unpackAlignment = u.unpackAlignment), u.compareFunction !== void 0 && (h.compareFunction = u.compareFunction), u.userData !== void 0 && (h.userData = u.userData), i[u.uuid] = h;
      }
    return i;
  }
  parseObject(e, t, n, i, o) {
    let l;
    function u(b) {
      return t[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", b), t[b];
    }
    function I(b) {
      if (b !== void 0) {
        if (Array.isArray(b)) {
          const S = [];
          for (let R = 0, W = b.length; R < W; R++) {
            const x = b[R];
            n[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), S.push(n[x]);
          }
          return S;
        }
        return n[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", b), n[b];
      }
    }
    function f(b) {
      return i[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", b), i[b];
    }
    let h, v;
    switch (e.type) {
      case "Scene":
        l = new Y2(), e.background !== void 0 && (Number.isInteger(e.background) ? l.background = new hi(e.background) : l.background = f(e.background)), e.environment !== void 0 && (l.environment = f(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? l.fog = new GW(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (l.fog = new bW(e.fog.color, e.fog.density)), e.fog.name !== "" && (l.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (l.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (l.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && l.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (l.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && l.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        l = new tl(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (l.focus = e.focus), e.zoom !== void 0 && (l.zoom = e.zoom), e.filmGauge !== void 0 && (l.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (l.filmOffset = e.filmOffset), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        l = new wm(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (l.zoom = e.zoom), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        l = new xK(e.color, e.intensity);
        break;
      case "DirectionalLight":
        l = new RK(e.color, e.intensity), l.target = e.target || "";
        break;
      case "PointLight":
        l = new wK(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        l = new WK(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        l = new ZK(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), l.target = e.target || "";
        break;
      case "HemisphereLight":
        l = new SK(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        l = new NK().fromJSON(e);
        break;
      case "SkinnedMesh":
        h = u(e.geometry), v = I(e.material), l = new Qz(h, v), e.bindMode !== void 0 && (l.bindMode = e.bindMode), e.bindMatrix !== void 0 && l.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (l.skeleton = e.skeleton);
        break;
      case "Mesh":
        h = u(e.geometry), v = I(e.material), l = new Fl(h, v);
        break;
      case "InstancedMesh":
        h = u(e.geometry), v = I(e.material);
        const b = e.count, S = e.instanceMatrix, R = e.instanceColor;
        l = new OG(h, v, b), l.instanceMatrix = new tB(new Float32Array(S.array), 16), R !== void 0 && (l.instanceColor = new tB(new Float32Array(R.array), R.itemSize));
        break;
      case "BatchedMesh":
        h = u(e.geometry), v = I(e.material), l = new jz(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, v), l.geometry = h, l.perObjectFrustumCulled = e.perObjectFrustumCulled, l.sortObjects = e.sortObjects, l._drawRanges = e.drawRanges, l._reservedRanges = e.reservedRanges, l._visibility = e.visibility, l._active = e.active, l._bounds = e.bounds.map((W) => {
          const x = new Ug();
          x.min.fromArray(W.boxMin), x.max.fromArray(W.boxMax);
          const M = new og();
          return M.radius = W.sphereRadius, M.center.fromArray(W.sphereCenter), {
            boxInitialized: W.boxInitialized,
            box: x,
            sphereInitialized: W.sphereInitialized,
            sphere: M
          };
        }), l._maxInstanceCount = e.maxInstanceCount, l._maxVertexCount = e.maxVertexCount, l._maxIndexCount = e.maxIndexCount, l._geometryInitialized = e.geometryInitialized, l._geometryCount = e.geometryCount, l._matricesTexture = f(e.matricesTexture.uuid), e.colorsTexture !== void 0 && (l._colorsTexture = f(e.colorsTexture.uuid));
        break;
      case "LOD":
        l = new Jz();
        break;
      case "Line":
        l = new ev(u(e.geometry), I(e.material));
        break;
      case "LineLoop":
        l = new qz(u(e.geometry), I(e.material));
        break;
      case "LineSegments":
        l = new Cp(u(e.geometry), I(e.material));
        break;
      case "PointCloud":
      case "Points":
        l = new $z(u(e.geometry), I(e.material));
        break;
      case "Sprite":
        l = new Pz(I(e.material));
        break;
      case "Group":
        l = new _G();
        break;
      case "Bone":
        l = new zX();
        break;
      default:
        l = new Aa();
    }
    if (l.uuid = e.uuid, e.name !== void 0 && (l.name = e.name), e.matrix !== void 0 ? (l.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (l.matrixAutoUpdate = e.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (e.position !== void 0 && l.position.fromArray(e.position), e.rotation !== void 0 && l.rotation.fromArray(e.rotation), e.quaternion !== void 0 && l.quaternion.fromArray(e.quaternion), e.scale !== void 0 && l.scale.fromArray(e.scale)), e.up !== void 0 && l.up.fromArray(e.up), e.castShadow !== void 0 && (l.castShadow = e.castShadow), e.receiveShadow !== void 0 && (l.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (l.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (l.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (l.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (l.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && l.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (l.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (l.visible = e.visible), e.frustumCulled !== void 0 && (l.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (l.renderOrder = e.renderOrder), e.userData !== void 0 && (l.userData = e.userData), e.layers !== void 0 && (l.layers.mask = e.layers), e.children !== void 0) {
      const b = e.children;
      for (let S = 0; S < b.length; S++)
        l.add(this.parseObject(b[S], t, n, i, o));
    }
    if (e.animations !== void 0) {
      const b = e.animations;
      for (let S = 0; S < b.length; S++) {
        const R = b[S];
        l.animations.push(o[R]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (l.autoUpdate = e.autoUpdate);
      const b = e.levels;
      for (let S = 0; S < b.length; S++) {
        const R = b[S], W = l.getObjectByProperty("uuid", R.object);
        W !== void 0 && l.addLevel(W, R.distance, R.hysteresis);
      }
    }
    return l;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const i = t[n.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
      }
    });
  }
  bindLightTargets(e) {
    e.traverse(function(t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const n = t.target, i = e.getObjectByProperty("uuid", n);
        i !== void 0 ? t.target = i : t.target = new Aa();
      }
    });
  }
}
const h6 = {
  UVMapping: cW,
  CubeReflectionMapping: Mm,
  CubeRefractionMapping: $A,
  EquirectangularReflectionMapping: uw,
  EquirectangularRefractionMapping: cw,
  CubeUVReflectionMapping: gB
}, p_ = {
  RepeatWrapping: gw,
  ClampToEdgeWrapping: XC,
  MirroredRepeatWrapping: dw
}, m_ = {
  NearestFilter: _u,
  NearestMipmapNearestFilter: yX,
  NearestMipmapLinearFilter: FG,
  LinearFilter: nl,
  LinearMipmapNearestFilter: kZ,
  LinearMipmapLinearFilter: np
};
class f6 extends kd {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = Rm.get(e);
    if (l !== void 0) {
      if (o.manager.itemStart(e), l.then) {
        l.then((f) => {
          t && t(f), o.manager.itemEnd(e);
        }).catch((f) => {
          i && i(f);
        });
        return;
      }
      return setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    }
    const u = {};
    u.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", u.headers = this.requestHeader;
    const I = fetch(e, u).then(function(f) {
      return f.blob();
    }).then(function(f) {
      return createImageBitmap(f, Object.assign(o.options, { colorSpaceConversion: "none" }));
    }).then(function(f) {
      return Rm.add(e, f), t && t(f), o.manager.itemEnd(e), f;
    }).catch(function(f) {
      i && i(f), Rm.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
    });
    Rm.add(e, I), o.manager.itemStart(e);
  }
}
let w1;
class tY {
  static getContext() {
    return w1 === void 0 && (w1 = new (window.AudioContext || window.webkitAudioContext)()), w1;
  }
  static setContext(e) {
    w1 = e;
  }
}
class p6 extends kd {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this, l = new Xm(this.manager);
    l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(I) {
      try {
        const f = I.slice(0);
        tY.getContext().decodeAudioData(f, function(v) {
          t(v);
        }).catch(u);
      } catch (f) {
        u(f);
      }
    }, n, i);
    function u(I) {
      i ? i(I) : console.error(I), o.manager.itemError(e);
    }
  }
}
const A_ = /* @__PURE__ */ new tr(), v_ = /* @__PURE__ */ new tr(), _y = /* @__PURE__ */ new tr();
class m6 {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new tl(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new tl(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, _y.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, o = i * t.near / t.focus, l = t.near * Math.tan(gb * t.fov * 0.5) / t.zoom;
      let u, I;
      v_.elements[12] = -i, A_.elements[12] = i, u = -l * t.aspect + o, I = l * t.aspect + o, _y.elements[0] = 2 * t.near / (I - u), _y.elements[8] = (I + u) / (I - u), this.cameraL.projectionMatrix.copy(_y), u = -l * t.aspect - o, I = l * t.aspect - o, _y.elements[0] = 2 * t.near / (I - u), _y.elements[8] = (I + u) / (I - u), this.cameraR.projectionMatrix.copy(_y);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(v_), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(A_);
  }
}
class nY {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = y_(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = y_();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function y_() {
  return (typeof performance > "u" ? Date : performance).now();
}
const zy = /* @__PURE__ */ new Ze(), b_ = /* @__PURE__ */ new zu(), A6 = /* @__PURE__ */ new Ze(), Ky = /* @__PURE__ */ new Ze();
class v6 extends Aa {
  constructor() {
    super(), this.type = "AudioListener", this.context = tY.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new nY();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(zy, b_, A6), Ky.set(0, 0, -1).applyQuaternion(b_), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(zy.x, i), t.positionY.linearRampToValueAtTime(zy.y, i), t.positionZ.linearRampToValueAtTime(zy.z, i), t.forwardX.linearRampToValueAtTime(Ky.x, i), t.forwardY.linearRampToValueAtTime(Ky.y, i), t.forwardZ.linearRampToValueAtTime(Ky.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition(zy.x, zy.y, zy.z), t.setOrientation(Ky.x, Ky.y, Ky.z, n.x, n.y, n.z);
  }
}
class XK extends Aa {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const Ly = /* @__PURE__ */ new Ze(), G_ = /* @__PURE__ */ new zu(), y6 = /* @__PURE__ */ new Ze(), ky = /* @__PURE__ */ new Ze();
class b6 extends XK {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(Ly, G_, y6), ky.set(0, 0, 1).applyQuaternion(G_);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Ly.x, n), t.positionY.linearRampToValueAtTime(Ly.y, n), t.positionZ.linearRampToValueAtTime(Ly.z, n), t.orientationX.linearRampToValueAtTime(ky.x, n), t.orientationY.linearRampToValueAtTime(ky.y, n), t.orientationZ.linearRampToValueAtTime(ky.z, n);
    } else
      t.setPosition(Ly.x, Ly.y, Ly.z), t.setOrientation(ky.x, ky.y, ky.z);
  }
}
class G6 {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class YK {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let i, o, l;
    switch (t) {
      case "quaternion":
        i = this._slerp, o = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, o = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        i = this._lerp, o = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = o, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, i = this.valueSize, o = e * i + i;
    let l = this.cumulativeWeight;
    if (l === 0) {
      for (let u = 0; u !== i; ++u)
        n[o + u] = n[u];
      l = t;
    } else {
      l += t;
      const u = t / l;
      this._mixBufferRegion(n, o, 0, u, i);
    }
    this.cumulativeWeight = l;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, i = e * t + t, o = this.cumulativeWeight, l = this.cumulativeWeightAdditive, u = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
      const I = t * this._origIndex;
      this._mixBufferRegion(
        n,
        i,
        I,
        1 - o,
        t
      );
    }
    l > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let I = t, f = t + t; I !== f; ++I)
      if (n[I] !== n[I + t]) {
        u.setValue(n, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
    e.getValue(t, i);
    for (let o = n, l = i; o !== l; ++o)
      t[o] = t[i + o % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, i, o) {
    if (i >= 0.5)
      for (let l = 0; l !== o; ++l)
        e[t + l] = e[n + l];
  }
  _slerp(e, t, n, i) {
    zu.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, o) {
    const l = this._workIndex * o;
    zu.multiplyQuaternionsFlat(e, l, e, t, e, n), zu.slerpFlat(e, t, e, t, e, l, i);
  }
  _lerp(e, t, n, i, o) {
    const l = 1 - i;
    for (let u = 0; u !== o; ++u) {
      const I = t + u;
      e[I] = e[I] * l + e[n + u] * i;
    }
  }
  _lerpAdditive(e, t, n, i, o) {
    for (let l = 0; l !== o; ++l) {
      const u = t + l;
      e[u] = e[u] + e[n + l] * i;
    }
  }
}
const iY = "\\[\\]\\.:\\/", B6 = new RegExp("[" + iY + "]", "g"), rY = "[^" + iY + "]", S6 = "[^" + iY.replace("\\.", "") + "]", Z6 = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", rY), w6 = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", S6), R6 = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", rY), x6 = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", rY), W6 = new RegExp(
  "^" + Z6 + w6 + R6 + x6 + "$"
), V6 = ["material", "materials", "bones", "map"];
class N6 {
  constructor(e, t, n) {
    const i = n || Na.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = n.length; i !== o; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Na {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || Na.parseTrackName(t), this.node = Na.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Na.Composite(e, t, n) : new Na(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(B6, "");
  }
  static parseTrackName(e) {
    const t = W6.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = n.nodeName.substring(i + 1);
      V6.indexOf(o) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = o);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(o) {
        for (let l = 0; l < o.length; l++) {
          const u = o[l];
          if (u.name === t || u.uuid === t)
            return u;
          const I = n(u.children);
          if (I) return I;
        }
        return null;
      }, i = n(e.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i)
      e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i)
      n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i)
      n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i)
      n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, i = t.propertyName;
    let o = t.propertyIndex;
    if (e || (e = Na.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let f = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === f) {
              f = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (f !== void 0) {
        if (e[f] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[f];
      }
    }
    const l = e[i];
    if (l === void 0) {
      const f = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + i + " but it wasn't found.", e);
      return;
    }
    let u = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? u = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (u = this.Versioning.MatrixWorldNeedsUpdate);
    let I = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]);
      }
      I = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o;
    } else l.fromArray !== void 0 && l.toArray !== void 0 ? (I = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (I = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[I], this.setValue = this.SetterByBindingTypeAndVersioning[I][u];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Na.Composite = N6;
Na.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Na.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Na.prototype.GetterByBindingType = [
  Na.prototype._getValue_direct,
  Na.prototype._getValue_array,
  Na.prototype._getValue_arrayElement,
  Na.prototype._getValue_toArray
];
Na.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Na.prototype._setValue_direct,
    Na.prototype._setValue_direct_setNeedsUpdate,
    Na.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Na.prototype._setValue_array,
    Na.prototype._setValue_array_setNeedsUpdate,
    Na.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Na.prototype._setValue_arrayElement,
    Na.prototype._setValue_arrayElement_setNeedsUpdate,
    Na.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Na.prototype._setValue_fromArray,
    Na.prototype._setValue_fromArray_setNeedsUpdate,
    Na.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class M6 {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = zI(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, o = this._bindings, l = o.length;
    let u, I = e.length, f = this.nCachedObjects_;
    for (let h = 0, v = arguments.length; h !== v; ++h) {
      const b = arguments[h], S = b.uuid;
      let R = t[S];
      if (R === void 0) {
        R = I++, t[S] = R, e.push(b);
        for (let W = 0, x = l; W !== x; ++W)
          o[W].push(new Na(b, n[W], i[W]));
      } else if (R < f) {
        u = e[R];
        const W = --f, x = e[W];
        t[x.uuid] = R, e[R] = x, t[S] = W, e[W] = b;
        for (let M = 0, T = l; M !== T; ++M) {
          const E = o[M], _ = E[W];
          let P = E[R];
          E[R] = _, P === void 0 && (P = new Na(b, n[M], i[M])), E[W] = P;
        }
      } else e[R] !== u && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = f;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let o = this.nCachedObjects_;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const I = arguments[l], f = I.uuid, h = t[f];
      if (h !== void 0 && h >= o) {
        const v = o++, b = e[v];
        t[b.uuid] = h, e[h] = b, t[f] = v, e[v] = I;
        for (let S = 0, R = i; S !== R; ++S) {
          const W = n[S], x = W[v], M = W[h];
          W[h] = x, W[v] = M;
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let o = this.nCachedObjects_, l = e.length;
    for (let u = 0, I = arguments.length; u !== I; ++u) {
      const f = arguments[u], h = f.uuid, v = t[h];
      if (v !== void 0)
        if (delete t[h], v < o) {
          const b = --o, S = e[b], R = --l, W = e[R];
          t[S.uuid] = v, e[v] = S, t[W.uuid] = b, e[b] = W, e.pop();
          for (let x = 0, M = i; x !== M; ++x) {
            const T = n[x], E = T[b], _ = T[R];
            T[v] = E, T[b] = _, T.pop();
          }
        } else {
          const b = --l, S = e[b];
          b > 0 && (t[S.uuid] = v), e[v] = S, e.pop();
          for (let R = 0, W = i; R !== W; ++R) {
            const x = n[R];
            x[v] = x[b], x.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const o = this._bindings;
    if (i !== void 0) return o[i];
    const l = this._paths, u = this._parsedPaths, I = this._objects, f = I.length, h = this.nCachedObjects_, v = new Array(f);
    i = o.length, n[e] = i, l.push(e), u.push(t), o.push(v);
    for (let b = h, S = I.length; b !== S; ++b) {
      const R = I[b];
      v[b] = new Na(R, e, t);
    }
    return v;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const i = this._paths, o = this._parsedPaths, l = this._bindings, u = l.length - 1, I = l[u], f = e[u];
      t[f] = n, l[n] = I, l.pop(), o[n] = o[u], o.pop(), i[n] = i[u], i.pop();
    }
  }
}
class FK {
  constructor(e, t, n = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
    const o = t.tracks, l = o.length, u = new Array(l), I = {
      endingStart: rb,
      endingEnd: rb
    };
    for (let f = 0; f !== l; ++f) {
      const h = o[f].createInterpolant(null);
      u[f] = h, h.settings = I;
    }
    this._interpolantSettings = I, this._interpolants = u, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = pz, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const i = this._clip.duration, o = e._clip.duration, l = o / i, u = i / o;
      e.warp(1, l, t), this.warp(u, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer, o = i.time, l = this.timeScale;
    let u = this._timeScaleInterpolant;
    u === null && (u = i._lendControlInterpolant(), this._timeScaleInterpolant = u);
    const I = u.parameterPositions, f = u.sampleValues;
    return I[0] = o, I[1] = o + n, f[0] = e / l, f[1] = t / l, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const I = (e - o) * n;
      I < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * I);
    }
    t *= this._updateTimeScale(e);
    const l = this._updateTime(t), u = this._updateWeight(e);
    if (u > 0) {
      const I = this._interpolants, f = this._propertyBindings;
      switch (this.blendMode) {
        case VX:
          for (let h = 0, v = I.length; h !== v; ++h)
            I[h].evaluate(l), f[h].accumulateAdditive(u);
          break;
        case pW:
        default:
          for (let h = 0, v = I.length; h !== v; ++h)
            I[h].evaluate(l), f[h].accumulate(i, u);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let i = this.time + e, o = this._loopCount;
    const l = n === mz;
    if (e === 0)
      return o === -1 ? i : l && (o & 1) === 1 ? t - i : i;
    if (n === fz) {
      o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), i >= t || i < 0) {
        const u = Math.floor(i / t);
        i -= t * u, o += Math.abs(u);
        const I = this.repetitions - o;
        if (I <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (I === 1) {
            const f = e < 0;
            this._setEndings(f, !f, l);
          } else
            this._setEndings(!1, !1, l);
          this._loopCount = o, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: u
          });
        }
      } else
        this.time = i;
      if (l && (o & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n ? (i.endingStart = ab, i.endingEnd = ab) : (e ? i.endingStart = this.zeroSlopeAtStart ? ab : rb : i.endingStart = Cw, t ? i.endingEnd = this.zeroSlopeAtEnd ? ab : rb : i.endingEnd = Cw);
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer, o = i.time;
    let l = this._weightInterpolant;
    l === null && (l = i._lendControlInterpolant(), this._weightInterpolant = l);
    const u = l.parameterPositions, I = l.sampleValues;
    return u[0] = o, I[0] = t, u[1] = o + e, I[1] = n, this;
  }
}
const H6 = new Float32Array(1);
class X6 extends Ip {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, i = e._clip.tracks, o = i.length, l = e._propertyBindings, u = e._interpolants, I = n.uuid, f = this._bindingsByRootAndName;
    let h = f[I];
    h === void 0 && (h = {}, f[I] = h);
    for (let v = 0; v !== o; ++v) {
      const b = i[v], S = b.name;
      let R = h[S];
      if (R !== void 0)
        ++R.referenceCount, l[v] = R;
      else {
        if (R = l[v], R !== void 0) {
          R._cacheIndex === null && (++R.referenceCount, this._addInactiveBinding(R, I, S));
          continue;
        }
        const W = t && t._propertyBindings[v].binding.parsedPath;
        R = new YK(
          Na.create(n, S, W),
          b.ValueTypeName,
          b.getValueSize()
        ), ++R.referenceCount, this._addInactiveBinding(R, I, S), l[v] = R;
      }
      u[v].resultBuffer = R.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, o = this._actionsByClip[i];
        this._bindAction(
          e,
          o && o.knownActions[0]
        ), this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const o = t[n];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const o = t[n];
        --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions, o = this._actionsByClip;
    let l = o[t];
    if (l === void 0)
      l = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, o[t] = l;
    else {
      const u = l.knownActions;
      e._byClipCacheIndex = u.length, u.push(e);
    }
    e._cacheIndex = i.length, i.push(e), l.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
    const o = e._clip.uuid, l = this._actionsByClip, u = l[o], I = u.knownActions, f = I[I.length - 1], h = e._byClipCacheIndex;
    f._byClipCacheIndex = h, I[h] = f, I.pop(), e._byClipCacheIndex = null;
    const v = u.actionByRoot, b = (e._localRoot || this._root).uuid;
    delete v[b], I.length === 0 && delete l[o], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const o = t[n];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = n, t[n] = o;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = n, t[n] = o;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName, o = this._bindings;
    let l = i[t];
    l === void 0 && (l = {}, i[t] = l), l[n] = e, e._cacheIndex = o.length, o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, i = n.rootNode.uuid, o = n.path, l = this._bindingsByRootAndName, u = l[i], I = t[t.length - 1], f = e._cacheIndex;
    I._cacheIndex = f, t[f] = I, t.pop(), delete u[o], Object.keys(u).length === 0 && delete l[i];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = n, t[n] = o;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = n, t[n] = o;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new jX(
      new Float32Array(2),
      new Float32Array(2),
      1,
      H6
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, o = t[i];
    e.__cacheIndex = i, t[i] = e, o.__cacheIndex = n, t[n] = o;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const i = t || this._root, o = i.uuid;
    let l = typeof e == "string" ? ww.findByName(i, e) : e;
    const u = l !== null ? l.uuid : e, I = this._actionsByClip[u];
    let f = null;
    if (n === void 0 && (l !== null ? n = l.blendMode : n = pW), I !== void 0) {
      const v = I.actionByRoot[o];
      if (v !== void 0 && v.blendMode === n)
        return v;
      f = I.knownActions[0], l === null && (l = f._clip);
    }
    if (l === null) return null;
    const h = new FK(this, l, t, n);
    return this._bindAction(h, f), this._addInactiveAction(h, u, o), h;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, i = n.uuid, o = typeof e == "string" ? ww.findByName(n, e) : e, l = o ? o.uuid : e, u = this._actionsByClip[l];
    return u !== void 0 && u.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, i = this.time += e, o = Math.sign(e), l = this._accuIndex ^= 1;
    for (let f = 0; f !== n; ++f)
      t[f]._update(i, e, o, l);
    const u = this._bindings, I = this._nActiveBindings;
    for (let f = 0; f !== I; ++f)
      u[f].apply(l);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, i = this._actionsByClip, o = i[n];
    if (o !== void 0) {
      const l = o.knownActions;
      for (let u = 0, I = l.length; u !== I; ++u) {
        const f = l[u];
        this._deactivateAction(f);
        const h = f._cacheIndex, v = t[t.length - 1];
        f._cacheIndex = null, f._byClipCacheIndex = null, v._cacheIndex = h, t[h] = v, t.pop(), this._removeInactiveBindingsForAction(f);
      }
      delete i[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const l in n) {
      const u = n[l].actionByRoot, I = u[t];
      I !== void 0 && (this._deactivateAction(I), this._removeInactiveAction(I));
    }
    const i = this._bindingsByRootAndName, o = i[t];
    if (o !== void 0)
      for (const l in o) {
        const u = o[l];
        u.restoreOriginalState(), this._removeInactiveBinding(u);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class aY {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new aY(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let Y6 = 0;
class F6 extends Ip {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: Y6++ }), this.name = "", this.usage = mw, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) {
      const o = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let l = 0; l < o.length; l++)
        this.uniforms.push(o[l].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class E6 extends BW {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class T6 {
  constructor(e, t, n, i, o) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = o, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
const B_ = /* @__PURE__ */ new tr();
class oY {
  constructor(e, t, n = 0, i = 1 / 0) {
    this.ray = new wb(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new db(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return B_.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(B_), this;
  }
  intersectObject(e, t = !0, n = []) {
    return YH(e, this, n, t), n.sort(S_), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, o = e.length; i < o; i++)
      YH(e[i], this, n, t);
    return n.sort(S_), n;
  }
}
function S_(a, e) {
  return a.distance - e.distance;
}
function YH(a, e, t, n) {
  let i = !0;
  if (a.layers.test(e.layers) && a.raycast(e, t) === !1 && (i = !1), i === !0 && n === !0) {
    const o = a.children;
    for (let l = 0, u = o.length; l < u; l++)
      YH(o[l], e, t, !0);
  }
}
class FH {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(el(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _6 {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class sY {
  constructor(e, t, n, i) {
    sY.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i);
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 4; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  set(e, t, n, i) {
    const o = this.elements;
    return o[0] = e, o[2] = t, o[1] = n, o[3] = i, this;
  }
}
const Z_ = /* @__PURE__ */ new sn();
class z6 {
  constructor(e = new sn(1 / 0, 1 / 0), t = new sn(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Z_.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y;
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Z_).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const w_ = /* @__PURE__ */ new Ze(), R1 = /* @__PURE__ */ new Ze();
class K6 {
  constructor(e = new Ze(), t = new Ze()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    w_.subVectors(e, this.start), R1.subVectors(this.end, this.start);
    const n = R1.dot(R1);
    let o = R1.dot(w_) / n;
    return t && (o = el(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const R_ = /* @__PURE__ */ new Ze();
class L6 extends Aa {
  constructor(e, t) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new _r(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let l = 0, u = 1, I = 32; l < I; l++, u++) {
      const f = l / I * Math.PI * 2, h = u / I * Math.PI * 2;
      i.push(
        Math.cos(f),
        Math.sin(f),
        1,
        Math.cos(h),
        Math.sin(h),
        1
      );
    }
    n.setAttribute("position", new Mi(i, 3));
    const o = new Jg({ fog: !1, toneMapped: !1 });
    this.cone = new Cp(n, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), R_.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(R_), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const _A = /* @__PURE__ */ new Ze(), x1 = /* @__PURE__ */ new tr(), XM = /* @__PURE__ */ new tr();
class k6 extends Cp {
  constructor(e) {
    const t = EK(e), n = new _r(), i = [], o = [], l = new hi(0, 0, 1), u = new hi(0, 1, 0);
    for (let f = 0; f < t.length; f++) {
      const h = t[f];
      h.parent && h.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), o.push(l.r, l.g, l.b), o.push(u.r, u.g, u.b));
    }
    n.setAttribute("position", new Mi(i, 3)), n.setAttribute("color", new Mi(o, 3));
    const I = new Jg({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, I), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, i = n.getAttribute("position");
    XM.copy(this.root.matrixWorld).invert();
    for (let o = 0, l = 0; o < t.length; o++) {
      const u = t[o];
      u.parent && u.parent.isBone && (x1.multiplyMatrices(XM, u.matrixWorld), _A.setFromMatrixPosition(x1), i.setXYZ(l, _A.x, _A.y, _A.z), x1.multiplyMatrices(XM, u.parent.matrixWorld), _A.setFromMatrixPosition(x1), i.setXYZ(l + 1, _A.x, _A.y, _A.z), l += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function EK(a) {
  const e = [];
  a.isBone === !0 && e.push(a);
  for (let t = 0; t < a.children.length; t++)
    e.push.apply(e, EK(a.children[t]));
  return e;
}
class D6 extends Fl {
  constructor(e, t, n) {
    const i = new Jw(t, 4, 2), o = new rv({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const U6 = /* @__PURE__ */ new Ze(), x_ = /* @__PURE__ */ new hi(), W_ = /* @__PURE__ */ new hi();
class O6 extends Aa {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const i = new Pw(t);
    i.rotateY(Math.PI * 0.5), this.material = new rv({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"), l = new Float32Array(o.count * 3);
    i.setAttribute("color", new Zo(l, 3)), this.add(new Fl(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      x_.copy(this.light.color), W_.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const o = n < i / 2 ? x_ : W_;
        t.setXYZ(n, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(U6.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class P6 extends Cp {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    n = new hi(n), i = new hi(i);
    const o = t / 2, l = e / t, u = e / 2, I = [], f = [];
    for (let b = 0, S = 0, R = -u; b <= t; b++, R += l) {
      I.push(-u, 0, R, u, 0, R), I.push(R, 0, -u, R, 0, u);
      const W = b === o ? n : i;
      W.toArray(f, S), S += 3, W.toArray(f, S), S += 3, W.toArray(f, S), S += 3, W.toArray(f, S), S += 3;
    }
    const h = new _r();
    h.setAttribute("position", new Mi(I, 3)), h.setAttribute("color", new Mi(f, 3));
    const v = new Jg({ vertexColors: !0, toneMapped: !1 });
    super(h, v), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class J6 extends Cp {
  constructor(e = 10, t = 16, n = 8, i = 64, o = 4473924, l = 8947848) {
    o = new hi(o), l = new hi(l);
    const u = [], I = [];
    if (t > 1)
      for (let v = 0; v < t; v++) {
        const b = v / t * (Math.PI * 2), S = Math.sin(b) * e, R = Math.cos(b) * e;
        u.push(0, 0, 0), u.push(S, 0, R);
        const W = v & 1 ? o : l;
        I.push(W.r, W.g, W.b), I.push(W.r, W.g, W.b);
      }
    for (let v = 0; v < n; v++) {
      const b = v & 1 ? o : l, S = e - e / n * v;
      for (let R = 0; R < i; R++) {
        let W = R / i * (Math.PI * 2), x = Math.sin(W) * S, M = Math.cos(W) * S;
        u.push(x, 0, M), I.push(b.r, b.g, b.b), W = (R + 1) / i * (Math.PI * 2), x = Math.sin(W) * S, M = Math.cos(W) * S, u.push(x, 0, M), I.push(b.r, b.g, b.b);
      }
    }
    const f = new _r();
    f.setAttribute("position", new Mi(u, 3)), f.setAttribute("color", new Mi(I, 3));
    const h = new Jg({ vertexColors: !0, toneMapped: !1 });
    super(f, h), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const V_ = /* @__PURE__ */ new Ze(), W1 = /* @__PURE__ */ new Ze(), N_ = /* @__PURE__ */ new Ze();
class Q6 extends Aa {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let i = new _r();
    i.setAttribute("position", new Mi([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const o = new Jg({ fog: !1, toneMapped: !1 });
    this.lightPlane = new ev(i, o), this.add(this.lightPlane), i = new _r(), i.setAttribute("position", new Mi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ev(i, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), V_.setFromMatrixPosition(this.light.matrixWorld), W1.setFromMatrixPosition(this.light.target.matrixWorld), N_.subVectors(W1, V_), this.lightPlane.lookAt(W1), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(W1), this.targetLine.scale.z = N_.length();
  }
}
const V1 = /* @__PURE__ */ new Ze(), $s = /* @__PURE__ */ new kw();
class j6 extends Cp {
  constructor(e) {
    const t = new _r(), n = new Jg({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], o = [], l = {};
    u("n1", "n2"), u("n2", "n4"), u("n4", "n3"), u("n3", "n1"), u("f1", "f2"), u("f2", "f4"), u("f4", "f3"), u("f3", "f1"), u("n1", "f1"), u("n2", "f2"), u("n3", "f3"), u("n4", "f4"), u("p", "n1"), u("p", "n2"), u("p", "n3"), u("p", "n4"), u("u1", "u2"), u("u2", "u3"), u("u3", "u1"), u("c", "t"), u("p", "c"), u("cn1", "cn2"), u("cn3", "cn4"), u("cf1", "cf2"), u("cf3", "cf4");
    function u(R, W) {
      I(R), I(W);
    }
    function I(R) {
      i.push(0, 0, 0), o.push(0, 0, 0), l[R] === void 0 && (l[R] = []), l[R].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Mi(i, 3)), t.setAttribute("color", new Mi(o, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = l, this.update();
    const f = new hi(16755200), h = new hi(16711680), v = new hi(43775), b = new hi(16777215), S = new hi(3355443);
    this.setColors(f, h, v, b, S);
  }
  setColors(e, t, n, i, o) {
    const u = this.geometry.getAttribute("color");
    u.setXYZ(0, e.r, e.g, e.b), u.setXYZ(1, e.r, e.g, e.b), u.setXYZ(2, e.r, e.g, e.b), u.setXYZ(3, e.r, e.g, e.b), u.setXYZ(4, e.r, e.g, e.b), u.setXYZ(5, e.r, e.g, e.b), u.setXYZ(6, e.r, e.g, e.b), u.setXYZ(7, e.r, e.g, e.b), u.setXYZ(8, e.r, e.g, e.b), u.setXYZ(9, e.r, e.g, e.b), u.setXYZ(10, e.r, e.g, e.b), u.setXYZ(11, e.r, e.g, e.b), u.setXYZ(12, e.r, e.g, e.b), u.setXYZ(13, e.r, e.g, e.b), u.setXYZ(14, e.r, e.g, e.b), u.setXYZ(15, e.r, e.g, e.b), u.setXYZ(16, e.r, e.g, e.b), u.setXYZ(17, e.r, e.g, e.b), u.setXYZ(18, e.r, e.g, e.b), u.setXYZ(19, e.r, e.g, e.b), u.setXYZ(20, e.r, e.g, e.b), u.setXYZ(21, e.r, e.g, e.b), u.setXYZ(22, e.r, e.g, e.b), u.setXYZ(23, e.r, e.g, e.b), u.setXYZ(24, t.r, t.g, t.b), u.setXYZ(25, t.r, t.g, t.b), u.setXYZ(26, t.r, t.g, t.b), u.setXYZ(27, t.r, t.g, t.b), u.setXYZ(28, t.r, t.g, t.b), u.setXYZ(29, t.r, t.g, t.b), u.setXYZ(30, t.r, t.g, t.b), u.setXYZ(31, t.r, t.g, t.b), u.setXYZ(32, n.r, n.g, n.b), u.setXYZ(33, n.r, n.g, n.b), u.setXYZ(34, n.r, n.g, n.b), u.setXYZ(35, n.r, n.g, n.b), u.setXYZ(36, n.r, n.g, n.b), u.setXYZ(37, n.r, n.g, n.b), u.setXYZ(38, i.r, i.g, i.b), u.setXYZ(39, i.r, i.g, i.b), u.setXYZ(40, o.r, o.g, o.b), u.setXYZ(41, o.r, o.g, o.b), u.setXYZ(42, o.r, o.g, o.b), u.setXYZ(43, o.r, o.g, o.b), u.setXYZ(44, o.r, o.g, o.b), u.setXYZ(45, o.r, o.g, o.b), u.setXYZ(46, o.r, o.g, o.b), u.setXYZ(47, o.r, o.g, o.b), u.setXYZ(48, o.r, o.g, o.b), u.setXYZ(49, o.r, o.g, o.b), u.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, i = 1;
    $s.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), yl("c", t, e, $s, 0, 0, -1), yl("t", t, e, $s, 0, 0, 1), yl("n1", t, e, $s, -n, -i, -1), yl("n2", t, e, $s, n, -i, -1), yl("n3", t, e, $s, -n, i, -1), yl("n4", t, e, $s, n, i, -1), yl("f1", t, e, $s, -n, -i, 1), yl("f2", t, e, $s, n, -i, 1), yl("f3", t, e, $s, -n, i, 1), yl("f4", t, e, $s, n, i, 1), yl("u1", t, e, $s, n * 0.7, i * 1.1, -1), yl("u2", t, e, $s, -n * 0.7, i * 1.1, -1), yl("u3", t, e, $s, 0, i * 2, -1), yl("cf1", t, e, $s, -n, 0, 1), yl("cf2", t, e, $s, n, 0, 1), yl("cf3", t, e, $s, 0, -i, 1), yl("cf4", t, e, $s, 0, i, 1), yl("cn1", t, e, $s, -n, 0, -1), yl("cn2", t, e, $s, n, 0, -1), yl("cn3", t, e, $s, 0, -i, -1), yl("cn4", t, e, $s, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function yl(a, e, t, n, i, o, l) {
  V1.set(i, o, l).unproject(n);
  const u = e[a];
  if (u !== void 0) {
    const I = t.getAttribute("position");
    for (let f = 0, h = u.length; f < h; f++)
      I.setXYZ(u[f], V1.x, V1.y, V1.z);
  }
}
const N1 = /* @__PURE__ */ new Ug();
class q6 extends Cp {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), o = new _r();
    o.setIndex(new Zo(n, 1)), o.setAttribute("position", new Zo(i, 3)), super(o, new Jg({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && N1.setFromObject(this.object), N1.isEmpty()) return;
    const t = N1.min, n = N1.max, i = this.geometry.attributes.position, o = i.array;
    o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = t.x, o[4] = n.y, o[5] = n.z, o[6] = t.x, o[7] = t.y, o[8] = n.z, o[9] = n.x, o[10] = t.y, o[11] = n.z, o[12] = n.x, o[13] = n.y, o[14] = t.z, o[15] = t.x, o[16] = n.y, o[17] = t.z, o[18] = t.x, o[19] = t.y, o[20] = t.z, o[21] = n.x, o[22] = t.y, o[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class $6 extends Cp {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], o = new _r();
    o.setIndex(new Zo(n, 1)), o.setAttribute("position", new Mi(i, 3)), super(o, new Jg({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class e$ extends ev {
  constructor(e, t = 1, n = 16776960) {
    const i = n, o = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], l = new _r();
    l.setAttribute("position", new Mi(o, 3)), l.computeBoundingSphere(), super(l, new Jg({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], I = new _r();
    I.setAttribute("position", new Mi(u, 3)), I.computeBoundingSphere(), this.add(new Fl(I, new rv({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const M_ = /* @__PURE__ */ new Ze();
let M1, YM;
class t$ extends Aa {
  // dir is assumed to be normalized
  constructor(e = new Ze(0, 0, 1), t = new Ze(0, 0, 0), n = 1, i = 16776960, o = n * 0.2, l = o * 0.2) {
    super(), this.type = "ArrowHelper", M1 === void 0 && (M1 = new _r(), M1.setAttribute("position", new Mi([0, 0, 0, 0, 1, 0], 3)), YM = new CB(0, 0.5, 1, 5, 1), YM.translate(0, -0.5, 0)), this.position.copy(t), this.line = new ev(M1, new Jg({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Fl(YM, new rv({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, o, l);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      M_.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(M_, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class n$ extends Cp {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new _r();
    i.setAttribute("position", new Mi(t, 3)), i.setAttribute("color", new Mi(n, 3));
    const o = new Jg({ vertexColors: !0, toneMapped: !1 });
    super(i, o), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const i = new hi(), o = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(o, 0), i.toArray(o, 3), i.set(t), i.toArray(o, 6), i.toArray(o, 9), i.set(n), i.toArray(o, 12), i.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class i$ {
  constructor() {
    this.type = "ShapePath", this.color = new hi(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new yw(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, o, l) {
    return this.currentPath.bezierCurveTo(e, t, n, i, o, l), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(M) {
      const T = [];
      for (let E = 0, _ = M.length; E < _; E++) {
        const P = M[E], U = new Ib();
        U.curves = P.curves, T.push(U);
      }
      return T;
    }
    function n(M, T) {
      const E = T.length;
      let _ = !1;
      for (let P = E - 1, U = 0; U < E; P = U++) {
        let q = T[P], k = T[U], O = k.x - q.x, J = k.y - q.y;
        if (Math.abs(J) > Number.EPSILON) {
          if (J < 0 && (q = T[U], O = -O, k = T[P], J = -J), M.y < q.y || M.y > k.y) continue;
          if (M.y === q.y) {
            if (M.x === q.x) return !0;
          } else {
            const te = J * (M.x - q.x) - O * (M.y - q.y);
            if (te === 0) return !0;
            if (te < 0) continue;
            _ = !_;
          }
        } else {
          if (M.y !== q.y) continue;
          if (k.x <= M.x && M.x <= q.x || q.x <= M.x && M.x <= k.x) return !0;
        }
      }
      return _;
    }
    const i = up.isClockWise, o = this.subPaths;
    if (o.length === 0) return [];
    let l, u, I;
    const f = [];
    if (o.length === 1)
      return u = o[0], I = new Ib(), I.curves = u.curves, f.push(I), f;
    let h = !i(o[0].getPoints());
    h = e ? !h : h;
    const v = [], b = [];
    let S = [], R = 0, W;
    b[R] = void 0, S[R] = [];
    for (let M = 0, T = o.length; M < T; M++)
      u = o[M], W = u.getPoints(), l = i(W), l = e ? !l : l, l ? (!h && b[R] && R++, b[R] = { s: new Ib(), p: W }, b[R].s.curves = u.curves, h && R++, S[R] = []) : S[R].push({ h: u, p: W[0] });
    if (!b[0]) return t(o);
    if (b.length > 1) {
      let M = !1, T = 0;
      for (let E = 0, _ = b.length; E < _; E++)
        v[E] = [];
      for (let E = 0, _ = b.length; E < _; E++) {
        const P = S[E];
        for (let U = 0; U < P.length; U++) {
          const q = P[U];
          let k = !0;
          for (let O = 0; O < b.length; O++)
            n(q.p, b[O].p) && (E !== O && T++, k ? (k = !1, v[O].push(q)) : M = !0);
          k && v[E].push(q);
        }
      }
      T > 0 && M === !1 && (S = v);
    }
    let x;
    for (let M = 0, T = b.length; M < T; M++) {
      I = b[M].s, f.push(I), x = S[M];
      for (let E = 0, _ = x.length; E < _; E++)
        I.holes.push(x[E].h);
    }
    return f;
  }
}
class r$ extends EC {
  // @deprecated, r162
  constructor(e = 1, t = 1, n = 1, i = {}) {
    console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, { ...i, count: n }), this.isWebGLMultipleRenderTargets = !0;
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: lW
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = lW);
const a$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: vX,
  AddEquation: kA,
  AddOperation: lz,
  AdditiveAnimationBlendMode: VX,
  AdditiveBlending: bH,
  AgXToneMapping: Iz,
  AlphaFormat: SX,
  AlwaysCompare: Rz,
  AlwaysDepth: tz,
  AlwaysStencilFunc: ZH,
  AmbientLight: xK,
  AnimationAction: FK,
  AnimationClip: ww,
  AnimationLoader: o6,
  AnimationMixer: X6,
  AnimationObjectGroup: M6,
  AnimationUtils: n6,
  ArcCurve: eK,
  ArrayCamera: Dz,
  ArrowHelper: t$,
  AttachedBindMode: SH,
  Audio: XK,
  AudioAnalyser: G6,
  AudioContext: tY,
  AudioListener: v6,
  AudioLoader: p6,
  AxesHelper: n$,
  BackSide: Dg,
  BasicDepthPacking: Az,
  BasicShadowMap: X5,
  BatchedMesh: jz,
  Bone: zX,
  BooleanKeyframeTrack: xb,
  Box2: z6,
  Box3: Ug,
  Box3Helper: $6,
  BoxGeometry: Rb,
  BoxHelper: q6,
  BufferAttribute: Zo,
  BufferGeometry: _r,
  BufferGeometryLoader: HK,
  ByteType: bX,
  Cache: Rm,
  Camera: kw,
  CameraHelper: j6,
  CanvasTexture: Zq,
  CapsuleGeometry: RW,
  CatmullRomCurve3: tK,
  CineonToneMapping: gz,
  CircleGeometry: xW,
  ClampToEdgeWrapping: XC,
  Clock: nY,
  Color: hi,
  ColorKeyframeTrack: qX,
  ColorManagement: Ta,
  CompressedArrayTexture: Bq,
  CompressedCubeTexture: Sq,
  CompressedTexture: ZW,
  CompressedTextureLoader: s6,
  ConeGeometry: WW,
  ConstantAlphaFactor: q5,
  ConstantColorFactor: Q5,
  CubeCamera: Fz,
  CubeReflectionMapping: Mm,
  CubeRefractionMapping: $A,
  CubeTexture: Dw,
  CubeTextureLoader: l6,
  CubeUVReflectionMapping: gB,
  CubicBezierCurve: kX,
  CubicBezierCurve3: nK,
  CubicInterpolant: yK,
  CullFaceBack: yH,
  CullFaceFront: H5,
  CullFaceFrontBack: nJ,
  CullFaceNone: M5,
  Curve: Kh,
  CurvePath: rK,
  CustomBlending: Y5,
  CustomToneMapping: dz,
  CylinderGeometry: CB,
  Cylindrical: _6,
  Data3DTexture: HX,
  DataArrayTexture: AW,
  DataTexture: lp,
  DataTextureLoader: u6,
  DataUtils: CQ,
  DecrementStencilOp: fJ,
  DecrementWrapStencilOp: mJ,
  DefaultLoadingManager: BK,
  DepthFormat: cb,
  DepthStencilFormat: vb,
  DepthTexture: vW,
  DetachedBindMode: hz,
  DirectionalLight: RK,
  DirectionalLightHelper: Q6,
  DiscreteInterpolant: bK,
  DisplayP3ColorSpace: mW,
  DodecahedronGeometry: VW,
  DoubleSide: ep,
  DstAlphaFactor: D5,
  DstColorFactor: O5,
  DynamicCopyUsage: NJ,
  DynamicDrawUsage: xz,
  DynamicReadUsage: xJ,
  EdgesGeometry: aK,
  EllipseCurve: wW,
  EqualCompare: Bz,
  EqualDepth: iz,
  EqualStencilFunc: bJ,
  EquirectangularReflectionMapping: uw,
  EquirectangularRefractionMapping: cw,
  Euler: Kd,
  EventDispatcher: Ip,
  ExtrudeGeometry: MW,
  FileLoader: Xm,
  Float16BufferAttribute: vQ,
  Float32BufferAttribute: Mi,
  FloatType: kg,
  Fog: GW,
  FogExp2: bW,
  FramebufferTexture: Gq,
  FrontSide: Nm,
  Frustum: Uw,
  GLBufferAttribute: T6,
  GLSL1: HJ,
  GLSL3: wH,
  GreaterCompare: Sz,
  GreaterDepth: az,
  GreaterEqualCompare: wz,
  GreaterEqualDepth: rz,
  GreaterEqualStencilFunc: ZJ,
  GreaterStencilFunc: BJ,
  GridHelper: P6,
  Group: _G,
  HalfFloatType: Zb,
  HemisphereLight: SK,
  HemisphereLightHelper: O6,
  IcosahedronGeometry: HW,
  ImageBitmapLoader: f6,
  ImageLoader: Rw,
  ImageUtils: Nz,
  IncrementStencilOp: hJ,
  IncrementWrapStencilOp: pJ,
  InstancedBufferAttribute: tB,
  InstancedBufferGeometry: MK,
  InstancedInterleavedBuffer: E6,
  InstancedMesh: OG,
  Int16BufferAttribute: mQ,
  Int32BufferAttribute: AQ,
  Int8BufferAttribute: hQ,
  IntType: gW,
  InterleavedBuffer: BW,
  InterleavedBufferAttribute: yb,
  Interpolant: Qw,
  InterpolateDiscrete: Iw,
  InterpolateLinear: X2,
  InterpolateSmooth: J1,
  InvertStencilOp: AJ,
  KeepStencilOp: Jy,
  KeyframeTrack: Lh,
  LOD: Jz,
  LatheGeometry: Ow,
  Layers: db,
  LessCompare: Gz,
  LessDepth: nz,
  LessEqualCompare: NX,
  LessEqualDepth: lw,
  LessEqualStencilFunc: GJ,
  LessStencilFunc: yJ,
  Light: ov,
  LightProbe: NK,
  Line: ev,
  Line3: K6,
  LineBasicMaterial: Jg,
  LineCurve: DX,
  LineCurve3: iK,
  LineDashedMaterial: mK,
  LineLoop: qz,
  LineSegments: Cp,
  LinearDisplayP3ColorSpace: Lw,
  LinearFilter: nl,
  LinearInterpolant: jX,
  LinearMipMapLinearFilter: oJ,
  LinearMipMapNearestFilter: aJ,
  LinearMipmapLinearFilter: np,
  LinearMipmapNearestFilter: kZ,
  LinearSRGBColorSpace: Tm,
  LinearToneMapping: uz,
  LinearTransfer: hw,
  Loader: kd,
  LoaderUtils: XH,
  LoadingManager: $X,
  LoopOnce: fz,
  LoopPingPong: mz,
  LoopRepeat: pz,
  LuminanceAlphaFormat: RX,
  LuminanceFormat: wX,
  MOUSE: Oy,
  Material: Gc,
  MaterialLoader: zW,
  MathUtils: jJ,
  Matrix2: sY,
  Matrix3: Nr,
  Matrix4: tr,
  MaxEquation: _5,
  Mesh: Fl,
  MeshBasicMaterial: rv,
  MeshDepthMaterial: EX,
  MeshDistanceMaterial: TX,
  MeshLambertMaterial: fK,
  MeshMatcapMaterial: pK,
  MeshNormalMaterial: hK,
  MeshPhongMaterial: IK,
  MeshPhysicalMaterial: dK,
  MeshStandardMaterial: JX,
  MeshToonMaterial: CK,
  MinEquation: T5,
  MirroredRepeatWrapping: dw,
  MixOperation: sz,
  MultiplyBlending: BH,
  MultiplyOperation: zw,
  NearestFilter: _u,
  NearestMipMapLinearFilter: rJ,
  NearestMipMapNearestFilter: iJ,
  NearestMipmapLinearFilter: FG,
  NearestMipmapNearestFilter: yX,
  NeutralToneMapping: Cz,
  NeverCompare: bz,
  NeverDepth: ez,
  NeverStencilFunc: vJ,
  NoBlending: Vm,
  NoColorSpace: Sm,
  NoToneMapping: sp,
  NormalAnimationBlendMode: pW,
  NormalBlending: ub,
  NotEqualCompare: Zz,
  NotEqualDepth: oz,
  NotEqualStencilFunc: SJ,
  NumberKeyframeTrack: Sw,
  Object3D: Aa,
  ObjectLoader: C6,
  ObjectSpaceNormalMap: yz,
  OctahedronGeometry: Pw,
  OneFactor: K5,
  OneMinusConstantAlphaFactor: $5,
  OneMinusConstantColorFactor: j5,
  OneMinusDstAlphaFactor: U5,
  OneMinusDstColorFactor: P5,
  OneMinusSrcAlphaFactor: l2,
  OneMinusSrcColorFactor: k5,
  OrthographicCamera: wm,
  P3Primaries: pw,
  PCFShadowMap: uW,
  PCFSoftShadowMap: LZ,
  PMREMGenerator: RH,
  Path: yw,
  PerspectiveCamera: tl,
  Plane: Gm,
  PlaneGeometry: dB,
  PlaneHelper: e$,
  PointLight: wK,
  PointLightHelper: D6,
  Points: $z,
  PointsMaterial: KX,
  PolarGridHelper: J6,
  PolyhedronGeometry: av,
  PositionalAudio: b6,
  PropertyBinding: Na,
  PropertyMixer: YK,
  QuadraticBezierCurve: UX,
  QuadraticBezierCurve3: OX,
  Quaternion: zu,
  QuaternionKeyframeTrack: jw,
  QuaternionLinearInterpolant: GK,
  RED_GREEN_RGTC2_Format: M2,
  RED_RGTC1_Format: WX,
  REVISION: lW,
  RGBADepthPacking: vz,
  RGBAFormat: rg,
  RGBAIntegerFormat: fW,
  RGBA_ASTC_10x10_Format: w2,
  RGBA_ASTC_10x5_Format: B2,
  RGBA_ASTC_10x6_Format: S2,
  RGBA_ASTC_10x8_Format: Z2,
  RGBA_ASTC_12x10_Format: R2,
  RGBA_ASTC_12x12_Format: x2,
  RGBA_ASTC_4x4_Format: f2,
  RGBA_ASTC_5x4_Format: p2,
  RGBA_ASTC_5x5_Format: m2,
  RGBA_ASTC_6x5_Format: A2,
  RGBA_ASTC_6x6_Format: v2,
  RGBA_ASTC_8x5_Format: y2,
  RGBA_ASTC_8x6_Format: b2,
  RGBA_ASTC_8x8_Format: G2,
  RGBA_BPTC_Format: JZ,
  RGBA_ETC2_EAC_Format: h2,
  RGBA_PVRTC_2BPPV1_Format: d2,
  RGBA_PVRTC_4BPPV1_Format: g2,
  RGBA_S3TC_DXT1_Format: UZ,
  RGBA_S3TC_DXT3_Format: OZ,
  RGBA_S3TC_DXT5_Format: PZ,
  RGBDepthPacking: gJ,
  RGBFormat: ZX,
  RGBIntegerFormat: sJ,
  RGB_BPTC_SIGNED_Format: W2,
  RGB_BPTC_UNSIGNED_Format: V2,
  RGB_ETC1_Format: I2,
  RGB_ETC2_Format: C2,
  RGB_PVRTC_2BPPV1_Format: c2,
  RGB_PVRTC_4BPPV1_Format: u2,
  RGB_S3TC_DXT1_Format: DZ,
  RGDepthPacking: dJ,
  RGFormat: xX,
  RGIntegerFormat: hW,
  RawShaderMaterial: gK,
  Ray: wb,
  Raycaster: oY,
  Rec709Primaries: fw,
  RectAreaLight: WK,
  RedFormat: CW,
  RedIntegerFormat: Kw,
  ReinhardToneMapping: cz,
  RenderTarget: Mz,
  RepeatWrapping: gw,
  ReplaceStencilOp: CJ,
  ReverseSubtractEquation: E5,
  RingGeometry: XW,
  SIGNED_RED_GREEN_RGTC2_Format: H2,
  SIGNED_RED_RGTC1_Format: N2,
  SRGBColorSpace: HC,
  SRGBTransfer: Po,
  Scene: Y2,
  ShaderChunk: Tr,
  ShaderLib: Eh,
  ShaderMaterial: zh,
  ShadowMaterial: cK,
  Shape: Ib,
  ShapeGeometry: YW,
  ShapePath: i$,
  ShapeUtils: up,
  ShortType: GX,
  Skeleton: SW,
  SkeletonHelper: k6,
  SkinnedMesh: Qz,
  Source: ob,
  Sphere: og,
  SphereGeometry: Jw,
  Spherical: FH,
  SphericalHarmonics3: VK,
  SplineCurve: PX,
  SpotLight: ZK,
  SpotLightHelper: L6,
  Sprite: Pz,
  SpriteMaterial: _X,
  SrcAlphaFactor: s2,
  SrcAlphaSaturateFactor: J5,
  SrcColorFactor: L5,
  StaticCopyUsage: VJ,
  StaticDrawUsage: mw,
  StaticReadUsage: RJ,
  StereoCamera: m6,
  StreamCopyUsage: MJ,
  StreamDrawUsage: wJ,
  StreamReadUsage: WJ,
  StringKeyframeTrack: Wb,
  SubtractEquation: F5,
  SubtractiveBlending: GH,
  TOUCH: Py,
  TangentSpaceNormalMap: iv,
  TetrahedronGeometry: FW,
  Texture: Fs,
  TextureLoader: c6,
  TextureUtils: nq,
  TorusGeometry: EW,
  TorusKnotGeometry: TW,
  Triangle: EI,
  TriangleFanDrawMode: cJ,
  TriangleStripDrawMode: uJ,
  TrianglesDrawMode: lJ,
  TubeGeometry: _W,
  UVMapping: cW,
  Uint16BufferAttribute: XX,
  Uint32BufferAttribute: YX,
  Uint8BufferAttribute: fQ,
  Uint8ClampedBufferAttribute: pQ,
  Uniform: aY,
  UniformsGroup: F6,
  UniformsLib: ai,
  UniformsUtils: Yz,
  UnsignedByteType: _h,
  UnsignedInt248Type: Ab,
  UnsignedInt5999Type: BX,
  UnsignedIntType: Hm,
  UnsignedShort4444Type: dW,
  UnsignedShort5551Type: IW,
  UnsignedShortType: qG,
  VSMShadowMap: Yh,
  Vector2: sn,
  Vector3: Ze,
  Vector4: ro,
  VectorKeyframeTrack: Zw,
  VideoTexture: bq,
  WebGL3DRenderTarget: rQ,
  WebGLArrayRenderTarget: iQ,
  WebGLCoordinateSystem: ip,
  WebGLCubeRenderTarget: Ez,
  WebGLMultipleRenderTargets: r$,
  WebGLRenderTarget: EC,
  WebGLRenderer: Uz,
  WebGLUtils: kz,
  WebGPUCoordinateSystem: Aw,
  WireframeGeometry: uK,
  WrapAroundEnding: Cw,
  ZeroCurvatureEnding: rb,
  ZeroFactor: z5,
  ZeroSlopeEnding: ab,
  ZeroStencilOp: IJ,
  createCanvasElement: Vz
}, Symbol.toStringTag, { value: "Module" }));
var EH = { exports: {} }, zA = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var H_;
function o$() {
  return H_ || (H_ = 1, zA.ConcurrentRoot = 1, zA.ContinuousEventPriority = 4, zA.DefaultEventPriority = 16, zA.DiscreteEventPriority = 1, zA.IdleEventPriority = 536870912, zA.LegacyRoot = 0), zA;
}
var KA = {}, X_;
function s$() {
  if (X_) return KA;
  X_ = 1;
  var a = {};
  /**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return a.NODE_ENV !== "production" && function() {
    var e = (
      /*                        */
      1
    ), t = (
      /*            */
      4
    ), n = (
      /*                    */
      16
    ), i = (
      /*                       */
      536870912
    ), o = e, l = t, u = n, I = i, f = 0, h = 1;
    KA.ConcurrentRoot = h, KA.ContinuousEventPriority = l, KA.DefaultEventPriority = u, KA.DiscreteEventPriority = o, KA.IdleEventPriority = I, KA.LegacyRoot = f;
  }(), KA;
}
var l$ = {};
l$.NODE_ENV === "production" ? EH.exports = o$() : EH.exports = s$();
var KG = EH.exports;
function u$(a) {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (f, h) => {
    const v = typeof f == "function" ? f(e) : f;
    if (v !== e) {
      const b = e;
      e = h ? v : Object.assign({}, e, v), t.forEach((S) => S(e, b));
    }
  }, i = () => e, o = (f, h = i, v = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let b = h(e);
    function S() {
      const R = h(e);
      if (!v(b, R)) {
        const W = b;
        f(b = R, W);
      }
    }
    return t.add(S), () => t.delete(S);
  }, I = { setState: n, getState: i, subscribe: (f, h, v) => h || v ? o(f, h, v) : (t.add(f), () => t.delete(f)), destroy: () => t.clear() };
  return e = a(n, i, I), I;
}
const c$ = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), Y_ = c$ ? xe.useEffect : xe.useLayoutEffect;
function g$(a) {
  const e = typeof a == "function" ? u$(a) : a, t = (n = e.getState, i = Object.is) => {
    const [, o] = xe.useReducer((x) => x + 1, 0), l = e.getState(), u = xe.useRef(l), I = xe.useRef(n), f = xe.useRef(i), h = xe.useRef(!1), v = xe.useRef();
    v.current === void 0 && (v.current = n(l));
    let b, S = !1;
    (u.current !== l || I.current !== n || f.current !== i || h.current) && (b = n(l), S = !i(v.current, b)), Y_(() => {
      S && (v.current = b), u.current = l, I.current = n, f.current = i, h.current = !1;
    });
    const R = xe.useRef(l);
    Y_(() => {
      const x = () => {
        try {
          const T = e.getState(), E = I.current(T);
          f.current(v.current, E) || (u.current = T, v.current = E, o());
        } catch {
          h.current = !0, o();
        }
      }, M = e.subscribe(x);
      return e.getState() !== R.current && x(), M;
    }, []);
    const W = S ? b : v.current;
    return xe.useDebugValue(W), W;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const n = [t, e];
    return {
      next() {
        const i = n.length <= 0;
        return { value: n.shift(), done: i };
      }
    };
  }, t;
}
var TH = { exports: {} }, H1 = { exports: {} }, FM = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var F_;
function d$() {
  return F_ || (F_ = 1, function(a) {
    function e(ee, Ce) {
      var be = ee.length;
      ee.push(Ce);
      e: for (; 0 < be; ) {
        var le = be - 1 >>> 1, Ye = ee[le];
        if (0 < i(Ye, Ce)) ee[le] = Ce, ee[be] = Ye, be = le;
        else break e;
      }
    }
    function t(ee) {
      return ee.length === 0 ? null : ee[0];
    }
    function n(ee) {
      if (ee.length === 0) return null;
      var Ce = ee[0], be = ee.pop();
      if (be !== Ce) {
        ee[0] = be;
        e: for (var le = 0, Ye = ee.length, $e = Ye >>> 1; le < $e; ) {
          var ke = 2 * (le + 1) - 1, ot = ee[ke], wt = ke + 1, St = ee[wt];
          if (0 > i(ot, be)) wt < Ye && 0 > i(St, ot) ? (ee[le] = St, ee[wt] = be, le = wt) : (ee[le] = ot, ee[ke] = be, le = ke);
          else if (wt < Ye && 0 > i(St, be)) ee[le] = St, ee[wt] = be, le = wt;
          else break e;
        }
      }
      return Ce;
    }
    function i(ee, Ce) {
      var be = ee.sortIndex - Ce.sortIndex;
      return be !== 0 ? be : ee.id - Ce.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      a.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, u = l.now();
      a.unstable_now = function() {
        return l.now() - u;
      };
    }
    var I = [], f = [], h = 1, v = null, b = 3, S = !1, R = !1, W = !1, x = typeof setTimeout == "function" ? setTimeout : null, M = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function E(ee) {
      for (var Ce = t(f); Ce !== null; ) {
        if (Ce.callback === null) n(f);
        else if (Ce.startTime <= ee) n(f), Ce.sortIndex = Ce.expirationTime, e(I, Ce);
        else break;
        Ce = t(f);
      }
    }
    function _(ee) {
      if (W = !1, E(ee), !R) if (t(I) !== null) R = !0, Ke(P);
      else {
        var Ce = t(f);
        Ce !== null && je(_, Ce.startTime - ee);
      }
    }
    function P(ee, Ce) {
      R = !1, W && (W = !1, M(k), k = -1), S = !0;
      var be = b;
      try {
        for (E(Ce), v = t(I); v !== null && (!(v.expirationTime > Ce) || ee && !te()); ) {
          var le = v.callback;
          if (typeof le == "function") {
            v.callback = null, b = v.priorityLevel;
            var Ye = le(v.expirationTime <= Ce);
            Ce = a.unstable_now(), typeof Ye == "function" ? v.callback = Ye : v === t(I) && n(I), E(Ce);
          } else n(I);
          v = t(I);
        }
        if (v !== null) var $e = !0;
        else {
          var ke = t(f);
          ke !== null && je(_, ke.startTime - Ce), $e = !1;
        }
        return $e;
      } finally {
        v = null, b = be, S = !1;
      }
    }
    var U = !1, q = null, k = -1, O = 5, J = -1;
    function te() {
      return !(a.unstable_now() - J < O);
    }
    function fe() {
      if (q !== null) {
        var ee = a.unstable_now();
        J = ee;
        var Ce = !0;
        try {
          Ce = q(!0, ee);
        } finally {
          Ce ? pe() : (U = !1, q = null);
        }
      } else U = !1;
    }
    var pe;
    if (typeof T == "function") pe = function() {
      T(fe);
    };
    else if (typeof MessageChannel < "u") {
      var Ae = new MessageChannel(), Te = Ae.port2;
      Ae.port1.onmessage = fe, pe = function() {
        Te.postMessage(null);
      };
    } else pe = function() {
      x(fe, 0);
    };
    function Ke(ee) {
      q = ee, U || (U = !0, pe());
    }
    function je(ee, Ce) {
      k = x(function() {
        ee(a.unstable_now());
      }, Ce);
    }
    a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(ee) {
      ee.callback = null;
    }, a.unstable_continueExecution = function() {
      R || S || (R = !0, Ke(P));
    }, a.unstable_forceFrameRate = function(ee) {
      0 > ee || 125 < ee ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < ee ? Math.floor(1e3 / ee) : 5;
    }, a.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, a.unstable_getFirstCallbackNode = function() {
      return t(I);
    }, a.unstable_next = function(ee) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var Ce = 3;
          break;
        default:
          Ce = b;
      }
      var be = b;
      b = Ce;
      try {
        return ee();
      } finally {
        b = be;
      }
    }, a.unstable_pauseExecution = function() {
    }, a.unstable_requestPaint = function() {
    }, a.unstable_runWithPriority = function(ee, Ce) {
      switch (ee) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ee = 3;
      }
      var be = b;
      b = ee;
      try {
        return Ce();
      } finally {
        b = be;
      }
    }, a.unstable_scheduleCallback = function(ee, Ce, be) {
      var le = a.unstable_now();
      switch (typeof be == "object" && be !== null ? (be = be.delay, be = typeof be == "number" && 0 < be ? le + be : le) : be = le, ee) {
        case 1:
          var Ye = -1;
          break;
        case 2:
          Ye = 250;
          break;
        case 5:
          Ye = 1073741823;
          break;
        case 4:
          Ye = 1e4;
          break;
        default:
          Ye = 5e3;
      }
      return Ye = be + Ye, ee = { id: h++, callback: Ce, priorityLevel: ee, startTime: be, expirationTime: Ye, sortIndex: -1 }, be > le ? (ee.sortIndex = be, e(f, ee), t(I) === null && ee === t(f) && (W ? (M(k), k = -1) : W = !0, je(_, be - le))) : (ee.sortIndex = Ye, e(I, ee), R || S || (R = !0, Ke(P))), ee;
    }, a.unstable_shouldYield = te, a.unstable_wrapCallback = function(ee) {
      var Ce = b;
      return function() {
        var be = b;
        b = Ce;
        try {
          return ee.apply(this, arguments);
        } finally {
          b = be;
        }
      };
    };
  }(FM)), FM;
}
var EM = {}, E_;
function I$() {
  return E_ || (E_ = 1, function(a) {
    var e = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    e.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = !1, i = 5;
      function o(Fe, Ie) {
        var at = Fe.length;
        Fe.push(Ie), I(Fe, Ie, at);
      }
      function l(Fe) {
        return Fe.length === 0 ? null : Fe[0];
      }
      function u(Fe) {
        if (Fe.length === 0)
          return null;
        var Ie = Fe[0], at = Fe.pop();
        return at !== Ie && (Fe[0] = at, f(Fe, at, 0)), Ie;
      }
      function I(Fe, Ie, at) {
        for (var ye = at; ye > 0; ) {
          var Pe = ye - 1 >>> 1, Ot = Fe[Pe];
          if (h(Ot, Ie) > 0)
            Fe[Pe] = Ie, Fe[ye] = Ot, ye = Pe;
          else
            return;
        }
      }
      function f(Fe, Ie, at) {
        for (var ye = at, Pe = Fe.length, Ot = Pe >>> 1; ye < Ot; ) {
          var Re = (ye + 1) * 2 - 1, lt = Fe[Re], _e = Re + 1, ht = Fe[_e];
          if (h(lt, Ie) < 0)
            _e < Pe && h(ht, lt) < 0 ? (Fe[ye] = ht, Fe[_e] = Ie, ye = _e) : (Fe[ye] = lt, Fe[Re] = Ie, ye = Re);
          else if (_e < Pe && h(ht, Ie) < 0)
            Fe[ye] = ht, Fe[_e] = Ie, ye = _e;
          else
            return;
        }
      }
      function h(Fe, Ie) {
        var at = Fe.sortIndex - Ie.sortIndex;
        return at !== 0 ? at : Fe.id - Ie.id;
      }
      var v = 1, b = 2, S = 3, R = 4, W = 5;
      function x(Fe, Ie) {
      }
      var M = typeof performance == "object" && typeof performance.now == "function";
      if (M) {
        var T = performance;
        a.unstable_now = function() {
          return T.now();
        };
      } else {
        var E = Date, _ = E.now();
        a.unstable_now = function() {
          return E.now() - _;
        };
      }
      var P = 1073741823, U = -1, q = 250, k = 5e3, O = 1e4, J = P, te = [], fe = [], pe = 1, Ae = null, Te = S, Ke = !1, je = !1, ee = !1, Ce = typeof setTimeout == "function" ? setTimeout : null, be = typeof clearTimeout == "function" ? clearTimeout : null, le = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Ye(Fe) {
        for (var Ie = l(fe); Ie !== null; ) {
          if (Ie.callback === null)
            u(fe);
          else if (Ie.startTime <= Fe)
            u(fe), Ie.sortIndex = Ie.expirationTime, o(te, Ie);
          else
            return;
          Ie = l(fe);
        }
      }
      function $e(Fe) {
        if (ee = !1, Ye(Fe), !je)
          if (l(te) !== null)
            je = !0, rn(ke);
          else {
            var Ie = l(fe);
            Ie !== null && gn($e, Ie.startTime - Fe);
          }
      }
      function ke(Fe, Ie) {
        je = !1, ee && (ee = !1, qn()), Ke = !0;
        var at = Te;
        try {
          var ye;
          if (!n) return ot(Fe, Ie);
        } finally {
          Ae = null, Te = at, Ke = !1;
        }
      }
      function ot(Fe, Ie) {
        var at = Ie;
        for (Ye(at), Ae = l(te); Ae !== null && !t && !(Ae.expirationTime > at && (!Fe || Se())); ) {
          var ye = Ae.callback;
          if (typeof ye == "function") {
            Ae.callback = null, Te = Ae.priorityLevel;
            var Pe = Ae.expirationTime <= at, Ot = ye(Pe);
            at = a.unstable_now(), typeof Ot == "function" ? Ae.callback = Ot : Ae === l(te) && u(te), Ye(at);
          } else
            u(te);
          Ae = l(te);
        }
        if (Ae !== null)
          return !0;
        var Re = l(fe);
        return Re !== null && gn($e, Re.startTime - at), !1;
      }
      function wt(Fe, Ie) {
        switch (Fe) {
          case v:
          case b:
          case S:
          case R:
          case W:
            break;
          default:
            Fe = S;
        }
        var at = Te;
        Te = Fe;
        try {
          return Ie();
        } finally {
          Te = at;
        }
      }
      function St(Fe) {
        var Ie;
        switch (Te) {
          case v:
          case b:
          case S:
            Ie = S;
            break;
          default:
            Ie = Te;
            break;
        }
        var at = Te;
        Te = Ie;
        try {
          return Fe();
        } finally {
          Te = at;
        }
      }
      function ln(Fe) {
        var Ie = Te;
        return function() {
          var at = Te;
          Te = Ie;
          try {
            return Fe.apply(this, arguments);
          } finally {
            Te = at;
          }
        };
      }
      function hn(Fe, Ie, at) {
        var ye = a.unstable_now(), Pe;
        if (typeof at == "object" && at !== null) {
          var Ot = at.delay;
          typeof Ot == "number" && Ot > 0 ? Pe = ye + Ot : Pe = ye;
        } else
          Pe = ye;
        var Re;
        switch (Fe) {
          case v:
            Re = U;
            break;
          case b:
            Re = q;
            break;
          case W:
            Re = J;
            break;
          case R:
            Re = O;
            break;
          case S:
          default:
            Re = k;
            break;
        }
        var lt = Pe + Re, _e = {
          id: pe++,
          callback: Ie,
          priorityLevel: Fe,
          startTime: Pe,
          expirationTime: lt,
          sortIndex: -1
        };
        return Pe > ye ? (_e.sortIndex = Pe, o(fe, _e), l(te) === null && _e === l(fe) && (ee ? qn() : ee = !0, gn($e, Pe - ye))) : (_e.sortIndex = lt, o(te, _e), !je && !Ke && (je = !0, rn(ke))), _e;
      }
      function mn() {
      }
      function Pn() {
        !je && !Ke && (je = !0, rn(ke));
      }
      function he() {
        return l(te);
      }
      function Lt(Fe) {
        Fe.callback = null;
      }
      function Wt() {
        return Te;
      }
      var tn = !1, Gt = null, Rn = -1, nn = i, Bn = -1;
      function Se() {
        var Fe = a.unstable_now() - Bn;
        return !(Fe < nn);
      }
      function oe() {
      }
      function ct(Fe) {
        if (Fe < 0 || Fe > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Fe > 0 ? nn = Math.floor(1e3 / Fe) : nn = i;
      }
      var Ft = function() {
        if (Gt !== null) {
          var Fe = a.unstable_now();
          Bn = Fe;
          var Ie = !0, at = !0;
          try {
            at = Gt(Ie, Fe);
          } finally {
            at ? pt() : (tn = !1, Gt = null);
          }
        } else
          tn = !1;
      }, pt;
      if (typeof le == "function")
        pt = function() {
          le(Ft);
        };
      else if (typeof MessageChannel < "u") {
        var zt = new MessageChannel(), Sn = zt.port2;
        zt.port1.onmessage = Ft, pt = function() {
          Sn.postMessage(null);
        };
      } else
        pt = function() {
          Ce(Ft, 0);
        };
      function rn(Fe) {
        Gt = Fe, tn || (tn = !0, pt());
      }
      function gn(Fe, Ie) {
        Rn = Ce(function() {
          Fe(a.unstable_now());
        }, Ie);
      }
      function qn() {
        be(Rn), Rn = -1;
      }
      var qt = oe, An = null;
      a.unstable_IdlePriority = W, a.unstable_ImmediatePriority = v, a.unstable_LowPriority = R, a.unstable_NormalPriority = S, a.unstable_Profiling = An, a.unstable_UserBlockingPriority = b, a.unstable_cancelCallback = Lt, a.unstable_continueExecution = Pn, a.unstable_forceFrameRate = ct, a.unstable_getCurrentPriorityLevel = Wt, a.unstable_getFirstCallbackNode = he, a.unstable_next = St, a.unstable_pauseExecution = mn, a.unstable_requestPaint = qt, a.unstable_runWithPriority = wt, a.unstable_scheduleCallback = hn, a.unstable_shouldYield = Se, a.unstable_wrapCallback = ln, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(EM)), EM;
}
var T_;
function TK() {
  if (T_) return H1.exports;
  T_ = 1;
  var a = {};
  return a.NODE_ENV === "production" ? H1.exports = d$() : H1.exports = I$(), H1.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TM, __;
function C$() {
  return __ || (__ = 1, TM = function(e) {
    var t = {}, n = xe, i = TK(), o = Object.assign;
    function l(m) {
      for (var A = "https://reactjs.org/docs/error-decoder.html?invariant=" + m, V = 1; V < arguments.length; V++) A += "&args[]=" + encodeURIComponent(arguments[V]);
      return "Minified React error #" + m + "; visit " + A + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var u = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, I = Symbol.for("react.element"), f = Symbol.for("react.portal"), h = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), b = Symbol.for("react.profiler"), S = Symbol.for("react.provider"), R = Symbol.for("react.context"), W = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), M = Symbol.for("react.suspense_list"), T = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), _ = Symbol.for("react.offscreen"), P = Symbol.iterator;
    function U(m) {
      return m === null || typeof m != "object" ? null : (m = P && m[P] || m["@@iterator"], typeof m == "function" ? m : null);
    }
    function q(m) {
      if (m == null) return null;
      if (typeof m == "function") return m.displayName || m.name || null;
      if (typeof m == "string") return m;
      switch (m) {
        case h:
          return "Fragment";
        case f:
          return "Portal";
        case b:
          return "Profiler";
        case v:
          return "StrictMode";
        case x:
          return "Suspense";
        case M:
          return "SuspenseList";
      }
      if (typeof m == "object") switch (m.$$typeof) {
        case R:
          return (m.displayName || "Context") + ".Consumer";
        case S:
          return (m._context.displayName || "Context") + ".Provider";
        case W:
          var A = m.render;
          return m = m.displayName, m || (m = A.displayName || A.name || "", m = m !== "" ? "ForwardRef(" + m + ")" : "ForwardRef"), m;
        case T:
          return A = m.displayName || null, A !== null ? A : q(m.type) || "Memo";
        case E:
          A = m._payload, m = m._init;
          try {
            return q(m(A));
          } catch {
          }
      }
      return null;
    }
    function k(m) {
      var A = m.type;
      switch (m.tag) {
        case 24:
          return "Cache";
        case 9:
          return (A.displayName || "Context") + ".Consumer";
        case 10:
          return (A._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return m = A.render, m = m.displayName || m.name || "", A.displayName || (m !== "" ? "ForwardRef(" + m + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return A;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return q(A);
        case 8:
          return A === v ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof A == "function") return A.displayName || A.name || null;
          if (typeof A == "string") return A;
      }
      return null;
    }
    function O(m) {
      var A = m, V = m;
      if (m.alternate) for (; A.return; ) A = A.return;
      else {
        m = A;
        do
          A = m, A.flags & 4098 && (V = A.return), m = A.return;
        while (m);
      }
      return A.tag === 3 ? V : null;
    }
    function J(m) {
      if (O(m) !== m) throw Error(l(188));
    }
    function te(m) {
      var A = m.alternate;
      if (!A) {
        if (A = O(m), A === null) throw Error(l(188));
        return A !== m ? null : m;
      }
      for (var V = m, Y = A; ; ) {
        var L = V.return;
        if (L === null) break;
        var $ = L.alternate;
        if ($ === null) {
          if (Y = L.return, Y !== null) {
            V = Y;
            continue;
          }
          break;
        }
        if (L.child === $.child) {
          for ($ = L.child; $; ) {
            if ($ === V) return J(L), m;
            if ($ === Y) return J(L), A;
            $ = $.sibling;
          }
          throw Error(l(188));
        }
        if (V.return !== Y.return) V = L, Y = $;
        else {
          for (var Ve = !1, nt = L.child; nt; ) {
            if (nt === V) {
              Ve = !0, V = L, Y = $;
              break;
            }
            if (nt === Y) {
              Ve = !0, Y = L, V = $;
              break;
            }
            nt = nt.sibling;
          }
          if (!Ve) {
            for (nt = $.child; nt; ) {
              if (nt === V) {
                Ve = !0, V = $, Y = L;
                break;
              }
              if (nt === Y) {
                Ve = !0, Y = $, V = L;
                break;
              }
              nt = nt.sibling;
            }
            if (!Ve) throw Error(l(189));
          }
        }
        if (V.alternate !== Y) throw Error(l(190));
      }
      if (V.tag !== 3) throw Error(l(188));
      return V.stateNode.current === V ? m : A;
    }
    function fe(m) {
      return m = te(m), m !== null ? pe(m) : null;
    }
    function pe(m) {
      if (m.tag === 5 || m.tag === 6) return m;
      for (m = m.child; m !== null; ) {
        var A = pe(m);
        if (A !== null) return A;
        m = m.sibling;
      }
      return null;
    }
    function Ae(m) {
      if (m.tag === 5 || m.tag === 6) return m;
      for (m = m.child; m !== null; ) {
        if (m.tag !== 4) {
          var A = Ae(m);
          if (A !== null) return A;
        }
        m = m.sibling;
      }
      return null;
    }
    var Te = Array.isArray, Ke = e.getPublicInstance, je = e.getRootHostContext, ee = e.getChildHostContext, Ce = e.prepareForCommit, be = e.resetAfterCommit, le = e.createInstance, Ye = e.appendInitialChild, $e = e.finalizeInitialChildren, ke = e.prepareUpdate, ot = e.shouldSetTextContent, wt = e.createTextInstance, St = e.scheduleTimeout, ln = e.cancelTimeout, hn = e.noTimeout, mn = e.isPrimaryRenderer, Pn = e.supportsMutation, he = e.supportsPersistence, Lt = e.supportsHydration, Wt = e.getInstanceFromNode, tn = e.preparePortalMount, Gt = e.getCurrentEventPriority, Rn = e.detachDeletedInstance, nn = e.supportsMicrotasks, Bn = e.scheduleMicrotask, Se = e.supportsTestSelectors, oe = e.findFiberRoot, ct = e.getBoundingRect, Ft = e.getTextContent, pt = e.isHiddenSubtree, zt = e.matchAccessibilityRole, Sn = e.setFocusIfFocusable, rn = e.setupIntersectionObserver, gn = e.appendChild, qn = e.appendChildToContainer, qt = e.commitTextUpdate, An = e.commitMount, Fe = e.commitUpdate, Ie = e.insertBefore, at = e.insertInContainerBefore, ye = e.removeChild, Pe = e.removeChildFromContainer, Ot = e.resetTextContent, Re = e.hideInstance, lt = e.hideTextInstance, _e = e.unhideInstance, ht = e.unhideTextInstance, Ht = e.clearContainer, an = e.cloneInstance, fi = e.createContainerChildSet, xi = e.appendChildToContainerChildSet, Ir = e.finalizeContainerChildren, Xi = e.replaceContainerChildren, pi = e.cloneHiddenInstance, Cr = e.cloneHiddenTextInstance, Sa = e.canHydrateInstance, zr = e.canHydrateTextInstance, na = e.canHydrateSuspenseInstance, la = e.isSuspenseInstancePending, Oa = e.isSuspenseInstanceFallback, Le = e.registerSuspenseInstanceRetry, qe = e.getNextHydratableSibling, gt = e.getFirstHydratableChild, Pt = e.getFirstHydratableChildWithinContainer, me = e.getFirstHydratableChildWithinSuspenseInstance, ut = e.hydrateInstance, Bt = e.hydrateTextInstance, Tt = e.hydrateSuspenseInstance, ae = e.getNextHydratableInstanceAfterSuspenseInstance, we = e.commitHydratedContainer, Ee = e.commitHydratedSuspenseInstance, Ue = e.clearSuspenseBoundary, Oe = e.clearSuspenseBoundaryFromContainer, Nt = e.shouldDeleteUnhydratedTailInstances, Kt = e.didNotMatchHydratedContainerTextInstance, vn = e.didNotMatchHydratedTextInstance, Yt;
    function Yn(m) {
      if (Yt === void 0) try {
        throw Error();
      } catch (V) {
        var A = V.stack.trim().match(/\n( *(at )?)/);
        Yt = A && A[1] || "";
      }
      return `
` + Yt + m;
    }
    var Fn = !1;
    function _n(m, A) {
      if (!m || Fn) return "";
      Fn = !0;
      var V = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (A) if (A = function() {
          throw Error();
        }, Object.defineProperty(A.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(A, []);
          } catch (Wn) {
            var Y = Wn;
          }
          Reflect.construct(m, [], A);
        } else {
          try {
            A.call();
          } catch (Wn) {
            Y = Wn;
          }
          m.call(A.prototype);
        }
        else {
          try {
            throw Error();
          } catch (Wn) {
            Y = Wn;
          }
          m();
        }
      } catch (Wn) {
        if (Wn && Y && typeof Wn.stack == "string") {
          for (var L = Wn.stack.split(`
`), $ = Y.stack.split(`
`), Ve = L.length - 1, nt = $.length - 1; 1 <= Ve && 0 <= nt && L[Ve] !== $[nt]; ) nt--;
          for (; 1 <= Ve && 0 <= nt; Ve--, nt--) if (L[Ve] !== $[nt]) {
            if (Ve !== 1 || nt !== 1)
              do
                if (Ve--, nt--, 0 > nt || L[Ve] !== $[nt]) {
                  var kt = `
` + L[Ve].replace(" at new ", " at ");
                  return m.displayName && kt.includes("<anonymous>") && (kt = kt.replace("<anonymous>", m.displayName)), kt;
                }
              while (1 <= Ve && 0 <= nt);
            break;
          }
        }
      } finally {
        Fn = !1, Error.prepareStackTrace = V;
      }
      return (m = m ? m.displayName || m.name : "") ? Yn(m) : "";
    }
    var Xn = Object.prototype.hasOwnProperty, or = [], Ei = -1;
    function pr(m) {
      return { current: m };
    }
    function Ln(m) {
      0 > Ei || (m.current = or[Ei], or[Ei] = null, Ei--);
    }
    function ge(m, A) {
      Ei++, or[Ei] = m.current, m.current = A;
    }
    var ue = {}, We = pr(ue), et = pr(!1), Mt = ue;
    function bn(m, A) {
      var V = m.type.contextTypes;
      if (!V) return ue;
      var Y = m.stateNode;
      if (Y && Y.__reactInternalMemoizedUnmaskedChildContext === A) return Y.__reactInternalMemoizedMaskedChildContext;
      var L = {}, $;
      for ($ in V) L[$] = A[$];
      return Y && (m = m.stateNode, m.__reactInternalMemoizedUnmaskedChildContext = A, m.__reactInternalMemoizedMaskedChildContext = L), L;
    }
    function Ai(m) {
      return m = m.childContextTypes, m != null;
    }
    function ve() {
      Ln(et), Ln(We);
    }
    function Be(m, A, V) {
      if (We.current !== ue) throw Error(l(168));
      ge(We, A), ge(et, V);
    }
    function mt(m, A, V) {
      var Y = m.stateNode;
      if (A = A.childContextTypes, typeof Y.getChildContext != "function") return V;
      Y = Y.getChildContext();
      for (var L in Y) if (!(L in A)) throw Error(l(108, k(m) || "Unknown", L));
      return o({}, V, Y);
    }
    function $t(m) {
      return m = (m = m.stateNode) && m.__reactInternalMemoizedMergedChildContext || ue, Mt = We.current, ge(We, m), ge(et, et.current), !0;
    }
    function In(m, A, V) {
      var Y = m.stateNode;
      if (!Y) throw Error(l(169));
      V ? (m = mt(m, A, Mt), Y.__reactInternalMemoizedMergedChildContext = m, Ln(et), Ln(We), ge(We, m)) : Ln(et), ge(et, V);
    }
    var un = Math.clz32 ? Math.clz32 : Ji, Bi = Math.log, Si = Math.LN2;
    function Ji(m) {
      return m >>>= 0, m === 0 ? 32 : 31 - (Bi(m) / Si | 0) | 0;
    }
    var En = 64, cn = 4194304;
    function kn(m) {
      switch (m & -m) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return m & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return m & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return m;
      }
    }
    function ti(m, A) {
      var V = m.pendingLanes;
      if (V === 0) return 0;
      var Y = 0, L = m.suspendedLanes, $ = m.pingedLanes, Ve = V & 268435455;
      if (Ve !== 0) {
        var nt = Ve & ~L;
        nt !== 0 ? Y = kn(nt) : ($ &= Ve, $ !== 0 && (Y = kn($)));
      } else Ve = V & ~L, Ve !== 0 ? Y = kn(Ve) : $ !== 0 && (Y = kn($));
      if (Y === 0) return 0;
      if (A !== 0 && A !== Y && !(A & L) && (L = Y & -Y, $ = A & -A, L >= $ || L === 16 && ($ & 4194240) !== 0)) return A;
      if (Y & 4 && (Y |= V & 16), A = m.entangledLanes, A !== 0) for (m = m.entanglements, A &= Y; 0 < A; ) V = 31 - un(A), L = 1 << V, Y |= m[V], A &= ~L;
      return Y;
    }
    function Di(m, A) {
      switch (m) {
        case 1:
        case 2:
        case 4:
          return A + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return A + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function qi(m, A) {
      for (var V = m.suspendedLanes, Y = m.pingedLanes, L = m.expirationTimes, $ = m.pendingLanes; 0 < $; ) {
        var Ve = 31 - un($), nt = 1 << Ve, kt = L[Ve];
        kt === -1 ? (!(nt & V) || nt & Y) && (L[Ve] = Di(nt, A)) : kt <= A && (m.expiredLanes |= nt), $ &= ~nt;
      }
    }
    function ci(m) {
      return m = m.pendingLanes & -1073741825, m !== 0 ? m : m & 1073741824 ? 1073741824 : 0;
    }
    function Hr(m) {
      for (var A = [], V = 0; 31 > V; V++) A.push(m);
      return A;
    }
    function Za(m, A, V) {
      m.pendingLanes |= A, A !== 536870912 && (m.suspendedLanes = 0, m.pingedLanes = 0), m = m.eventTimes, A = 31 - un(A), m[A] = V;
    }
    function gi(m, A) {
      var V = m.pendingLanes & ~A;
      m.pendingLanes = A, m.suspendedLanes = 0, m.pingedLanes = 0, m.expiredLanes &= A, m.mutableReadLanes &= A, m.entangledLanes &= A, A = m.entanglements;
      var Y = m.eventTimes;
      for (m = m.expirationTimes; 0 < V; ) {
        var L = 31 - un(V), $ = 1 << L;
        A[L] = 0, Y[L] = -1, m[L] = -1, V &= ~$;
      }
    }
    function yr(m, A) {
      var V = m.entangledLanes |= A;
      for (m = m.entanglements; V; ) {
        var Y = 31 - un(V), L = 1 << Y;
        L & A | m[Y] & A && (m[Y] |= A), V &= ~L;
      }
    }
    var Hn = 0;
    function Pa(m) {
      return m &= -m, 1 < m ? 4 < m ? m & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var zo = i.unstable_scheduleCallback, Ko = i.unstable_cancelCallback, Xr = i.unstable_shouldYield, ia = i.unstable_requestPaint, kr = i.unstable_now, ua = i.unstable_ImmediatePriority, Lo = i.unstable_UserBlockingPriority, ko = i.unstable_NormalPriority, cu = i.unstable_IdlePriority, Ja = null, is = null;
    function Qg(m) {
      if (is && typeof is.onCommitFiberRoot == "function") try {
        is.onCommitFiberRoot(Ja, m, void 0, (m.current.flags & 128) === 128);
      } catch {
      }
    }
    function gu(m, A) {
      return m === A && (m !== 0 || 1 / m === 1 / A) || m !== m && A !== A;
    }
    var rs = typeof Object.is == "function" ? Object.is : gu, rl = null, du = !1, jg = !1;
    function ku(m) {
      rl === null ? rl = [m] : rl.push(m);
    }
    function Bc(m) {
      du = !0, ku(m);
    }
    function al() {
      if (!jg && rl !== null) {
        jg = !0;
        var m = 0, A = Hn;
        try {
          var V = rl;
          for (Hn = 1; m < V.length; m++) {
            var Y = V[m];
            do
              Y = Y(!0);
            while (Y !== null);
          }
          rl = null, du = !1;
        } catch (L) {
          throw rl !== null && (rl = rl.slice(m + 1)), zo(ua, al), L;
        } finally {
          Hn = A, jg = !1;
        }
      }
      return null;
    }
    var kC = u.ReactCurrentBatchConfig;
    function Bl(m, A) {
      if (rs(m, A)) return !0;
      if (typeof m != "object" || m === null || typeof A != "object" || A === null) return !1;
      var V = Object.keys(m), Y = Object.keys(A);
      if (V.length !== Y.length) return !1;
      for (Y = 0; Y < V.length; Y++) {
        var L = V[Y];
        if (!Xn.call(A, L) || !rs(m[L], A[L])) return !1;
      }
      return !0;
    }
    function kI(m) {
      switch (m.tag) {
        case 5:
          return Yn(m.type);
        case 16:
          return Yn("Lazy");
        case 13:
          return Yn("Suspense");
        case 19:
          return Yn("SuspenseList");
        case 0:
        case 2:
        case 15:
          return m = _n(m.type, !1), m;
        case 11:
          return m = _n(m.type.render, !1), m;
        case 1:
          return m = _n(m.type, !0), m;
        default:
          return "";
      }
    }
    function ie(m, A) {
      if (m && m.defaultProps) {
        A = o({}, A), m = m.defaultProps;
        for (var V in m) A[V] === void 0 && (A[V] = m[V]);
        return A;
      }
      return A;
    }
    var De = pr(null), bt = null, Et = null, wn = null;
    function ui() {
      wn = Et = bt = null;
    }
    function ni(m, A, V) {
      mn ? (ge(De, A._currentValue), A._currentValue = V) : (ge(De, A._currentValue2), A._currentValue2 = V);
    }
    function Yi(m) {
      var A = De.current;
      Ln(De), mn ? m._currentValue = A : m._currentValue2 = A;
    }
    function rr(m, A, V) {
      for (; m !== null; ) {
        var Y = m.alternate;
        if ((m.childLanes & A) !== A ? (m.childLanes |= A, Y !== null && (Y.childLanes |= A)) : Y !== null && (Y.childLanes & A) !== A && (Y.childLanes |= A), m === V) break;
        m = m.return;
      }
    }
    function Yr(m, A) {
      bt = m, wn = Et = null, m = m.dependencies, m !== null && m.firstContext !== null && (m.lanes & A && (Pi = !0), m.firstContext = null);
    }
    function hr(m) {
      var A = mn ? m._currentValue : m._currentValue2;
      if (wn !== m) if (m = { context: m, memoizedValue: A, next: null }, Et === null) {
        if (bt === null) throw Error(l(308));
        Et = m, bt.dependencies = { lanes: 0, firstContext: m };
      } else Et = Et.next = m;
      return A;
    }
    var vr = null, br = !1;
    function Ia(m) {
      m.updateQueue = { baseState: m.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Fr(m, A) {
      m = m.updateQueue, A.updateQueue === m && (A.updateQueue = { baseState: m.baseState, firstBaseUpdate: m.firstBaseUpdate, lastBaseUpdate: m.lastBaseUpdate, shared: m.shared, effects: m.effects });
    }
    function Qo(m, A) {
      return { eventTime: m, lane: A, tag: 0, payload: null, callback: null, next: null };
    }
    function Tl(m, A) {
      var V = m.updateQueue;
      V !== null && (V = V.shared, po !== null && m.mode & 1 && !(ur & 2) ? (m = V.interleaved, m === null ? (A.next = A, vr === null ? vr = [V] : vr.push(V)) : (A.next = m.next, m.next = A), V.interleaved = A) : (m = V.pending, m === null ? A.next = A : (A.next = m.next, m.next = A), V.pending = A));
    }
    function qg(m, A, V) {
      if (A = A.updateQueue, A !== null && (A = A.shared, (V & 4194240) !== 0)) {
        var Y = A.lanes;
        Y &= m.pendingLanes, V |= Y, A.lanes = V, yr(m, V);
      }
    }
    function DI(m, A) {
      var V = m.updateQueue, Y = m.alternate;
      if (Y !== null && (Y = Y.updateQueue, V === Y)) {
        var L = null, $ = null;
        if (V = V.firstBaseUpdate, V !== null) {
          do {
            var Ve = { eventTime: V.eventTime, lane: V.lane, tag: V.tag, payload: V.payload, callback: V.callback, next: null };
            $ === null ? L = $ = Ve : $ = $.next = Ve, V = V.next;
          } while (V !== null);
          $ === null ? L = $ = A : $ = $.next = A;
        } else L = $ = A;
        V = { baseState: Y.baseState, firstBaseUpdate: L, lastBaseUpdate: $, shared: Y.shared, effects: Y.effects }, m.updateQueue = V;
        return;
      }
      m = V.lastBaseUpdate, m === null ? V.firstBaseUpdate = A : m.next = A, V.lastBaseUpdate = A;
    }
    function Iu(m, A, V, Y) {
      var L = m.updateQueue;
      br = !1;
      var $ = L.firstBaseUpdate, Ve = L.lastBaseUpdate, nt = L.shared.pending;
      if (nt !== null) {
        L.shared.pending = null;
        var kt = nt, Wn = kt.next;
        kt.next = null, Ve === null ? $ = Wn : Ve.next = Wn, Ve = kt;
        var Jn = m.alternate;
        Jn !== null && (Jn = Jn.updateQueue, nt = Jn.lastBaseUpdate, nt !== Ve && (nt === null ? Jn.firstBaseUpdate = Wn : nt.next = Wn, Jn.lastBaseUpdate = kt));
      }
      if ($ !== null) {
        var mi = L.baseState;
        Ve = 0, Jn = Wn = kt = null, nt = $;
        do {
          var wi = nt.lane, lr = nt.eventTime;
          if ((Y & wi) === wi) {
            Jn !== null && (Jn = Jn.next = {
              eventTime: lr,
              lane: 0,
              tag: nt.tag,
              payload: nt.payload,
              callback: nt.callback,
              next: null
            });
            e: {
              var $n = m, to = nt;
              switch (wi = A, lr = V, to.tag) {
                case 1:
                  if ($n = to.payload, typeof $n == "function") {
                    mi = $n.call(lr, mi, wi);
                    break e;
                  }
                  mi = $n;
                  break e;
                case 3:
                  $n.flags = $n.flags & -65537 | 128;
                case 0:
                  if ($n = to.payload, wi = typeof $n == "function" ? $n.call(lr, mi, wi) : $n, wi == null) break e;
                  mi = o({}, mi, wi);
                  break e;
                case 2:
                  br = !0;
              }
            }
            nt.callback !== null && nt.lane !== 0 && (m.flags |= 64, wi = L.effects, wi === null ? L.effects = [nt] : wi.push(nt));
          } else lr = { eventTime: lr, lane: wi, tag: nt.tag, payload: nt.payload, callback: nt.callback, next: null }, Jn === null ? (Wn = Jn = lr, kt = mi) : Jn = Jn.next = lr, Ve |= wi;
          if (nt = nt.next, nt === null) {
            if (nt = L.shared.pending, nt === null) break;
            wi = nt, nt = wi.next, wi.next = null, L.lastBaseUpdate = wi, L.shared.pending = null;
          }
        } while (!0);
        if (Jn === null && (kt = mi), L.baseState = kt, L.firstBaseUpdate = Wn, L.lastBaseUpdate = Jn, A = L.shared.interleaved, A !== null) {
          L = A;
          do
            Ve |= L.lane, L = L.next;
          while (L !== A);
        } else $ === null && (L.shared.lanes = 0);
        $u |= Ve, m.lanes = Ve, m.memoizedState = mi;
      }
    }
    function UI(m, A, V) {
      if (m = A.effects, A.effects = null, m !== null) for (A = 0; A < m.length; A++) {
        var Y = m[A], L = Y.callback;
        if (L !== null) {
          if (Y.callback = null, Y = V, typeof L != "function") throw Error(l(191, L));
          L.call(Y);
        }
      }
    }
    var OI = new n.Component().refs;
    function DC(m, A, V, Y) {
      A = m.memoizedState, V = V(Y, A), V = V == null ? A : o({}, A, V), m.memoizedState = V, m.lanes === 0 && (m.updateQueue.baseState = V);
    }
    var UC = { isMounted: function(m) {
      return (m = m._reactInternals) ? O(m) === m : !1;
    }, enqueueSetState: function(m, A, V) {
      m = m._reactInternals;
      var Y = vi(), L = Or(m), $ = Qo(Y, L);
      $.payload = A, V != null && ($.callback = V), Tl(m, $), A = La(m, L, Y), A !== null && qg(A, m, L);
    }, enqueueReplaceState: function(m, A, V) {
      m = m._reactInternals;
      var Y = vi(), L = Or(m), $ = Qo(Y, L);
      $.tag = 1, $.payload = A, V != null && ($.callback = V), Tl(m, $), A = La(m, L, Y), A !== null && qg(A, m, L);
    }, enqueueForceUpdate: function(m, A) {
      m = m._reactInternals;
      var V = vi(), Y = Or(m), L = Qo(
        V,
        Y
      );
      L.tag = 2, A != null && (L.callback = A), Tl(m, L), A = La(m, Y, V), A !== null && qg(A, m, Y);
    } };
    function fp(m, A, V, Y, L, $, Ve) {
      return m = m.stateNode, typeof m.shouldComponentUpdate == "function" ? m.shouldComponentUpdate(Y, $, Ve) : A.prototype && A.prototype.isPureReactComponent ? !Bl(V, Y) || !Bl(L, $) : !0;
    }
    function pp(m, A, V) {
      var Y = !1, L = ue, $ = A.contextType;
      return typeof $ == "object" && $ !== null ? $ = hr($) : (L = Ai(A) ? Mt : We.current, Y = A.contextTypes, $ = (Y = Y != null) ? bn(m, L) : ue), A = new A(V, $), m.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null, A.updater = UC, m.stateNode = A, A._reactInternals = m, Y && (m = m.stateNode, m.__reactInternalMemoizedUnmaskedChildContext = L, m.__reactInternalMemoizedMaskedChildContext = $), A;
    }
    function kh(m, A, V, Y) {
      m = A.state, typeof A.componentWillReceiveProps == "function" && A.componentWillReceiveProps(V, Y), typeof A.UNSAFE_componentWillReceiveProps == "function" && A.UNSAFE_componentWillReceiveProps(V, Y), A.state !== m && UC.enqueueReplaceState(A, A.state, null);
    }
    function Dh(m, A, V, Y) {
      var L = m.stateNode;
      L.props = V, L.state = m.memoizedState, L.refs = OI, Ia(m);
      var $ = A.contextType;
      typeof $ == "object" && $ !== null ? L.context = hr($) : ($ = Ai(A) ? Mt : We.current, L.context = bn(m, $)), L.state = m.memoizedState, $ = A.getDerivedStateFromProps, typeof $ == "function" && (DC(m, A, $, V), L.state = m.memoizedState), typeof A.getDerivedStateFromProps == "function" || typeof L.getSnapshotBeforeUpdate == "function" || typeof L.UNSAFE_componentWillMount != "function" && typeof L.componentWillMount != "function" || (A = L.state, typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount(), A !== L.state && UC.enqueueReplaceState(L, L.state, null), Iu(m, V, L, Y), L.state = m.memoizedState), typeof L.componentDidMount == "function" && (m.flags |= 4194308);
    }
    var Dd = [], ug = 0, Uh = null, Cu = 0, hu = [], ol = 0, cg = null, Du = 1, gg = "";
    function Sc(m, A) {
      Dd[ug++] = Cu, Dd[ug++] = Uh, Uh = m, Cu = A;
    }
    function mp(m, A, V) {
      hu[ol++] = Du, hu[ol++] = gg, hu[ol++] = cg, cg = m;
      var Y = Du;
      m = gg;
      var L = 32 - un(Y) - 1;
      Y &= ~(1 << L), V += 1;
      var $ = 32 - un(A) + L;
      if (30 < $) {
        var Ve = L - L % 5;
        $ = (Y & (1 << Ve) - 1).toString(32), Y >>= Ve, L -= Ve, Du = 1 << 32 - un(A) + L | V << L | Y, gg = $ + m;
      } else Du = 1 << $ | V << L | Y, gg = m;
    }
    function Es(m) {
      m.return !== null && (Sc(m, 1), mp(m, 1, 0));
    }
    function Uu(m) {
      for (; m === Uh; ) Uh = Dd[--ug], Dd[ug] = null, Cu = Dd[--ug], Dd[ug] = null;
      for (; m === cg; ) cg = hu[--ol], hu[ol] = null, gg = hu[--ol], hu[ol] = null, Du = hu[--ol], hu[ol] = null;
    }
    var Kr = null, _a = null, ca = !1, Zc = !1, _l = null;
    function $g(m, A) {
      var V = vo(5, null, null, 0);
      V.elementType = "DELETED", V.stateNode = A, V.return = m, A = m.deletions, A === null ? (m.deletions = [V], m.flags |= 16) : A.push(V);
    }
    function Oh(m, A) {
      switch (m.tag) {
        case 5:
          return A = Sa(A, m.type, m.pendingProps), A !== null ? (m.stateNode = A, Kr = m, _a = gt(A), !0) : !1;
        case 6:
          return A = zr(A, m.pendingProps), A !== null ? (m.stateNode = A, Kr = m, _a = null, !0) : !1;
        case 13:
          if (A = na(A), A !== null) {
            var V = cg !== null ? { id: Du, overflow: gg } : null;
            return m.memoizedState = { dehydrated: A, treeContext: V, retryLane: 1073741824 }, V = vo(18, null, null, 0), V.stateNode = A, V.return = m, m.child = V, Kr = m, _a = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function OC(m) {
      return (m.mode & 1) !== 0 && (m.flags & 128) === 0;
    }
    function Ou(m) {
      if (ca) {
        var A = _a;
        if (A) {
          var V = A;
          if (!Oh(m, A)) {
            if (OC(m)) throw Error(l(418));
            A = qe(V);
            var Y = Kr;
            A && Oh(m, A) ? $g(Y, V) : (m.flags = m.flags & -4097 | 2, ca = !1, Kr = m);
          }
        } else {
          if (OC(m)) throw Error(l(418));
          m.flags = m.flags & -4097 | 2, ca = !1, Kr = m;
        }
      }
    }
    function Ap(m) {
      for (m = m.return; m !== null && m.tag !== 5 && m.tag !== 3 && m.tag !== 13; ) m = m.return;
      Kr = m;
    }
    function PI(m) {
      if (!Lt || m !== Kr) return !1;
      if (!ca) return Ap(m), ca = !0, !1;
      if (m.tag !== 3 && (m.tag !== 5 || Nt(m.type) && !ot(m.type, m.memoizedProps))) {
        var A = _a;
        if (A) {
          if (OC(m)) {
            for (m = _a; m; ) m = qe(m);
            throw Error(l(418));
          }
          for (; A; ) $g(m, A), A = qe(A);
        }
      }
      if (Ap(m), m.tag === 13) {
        if (!Lt) throw Error(l(316));
        if (m = m.memoizedState, m = m !== null ? m.dehydrated : null, !m) throw Error(l(317));
        _a = ae(m);
      } else _a = Kr ? qe(m.stateNode) : null;
      return !0;
    }
    function JI() {
      Lt && (_a = Kr = null, Zc = ca = !1);
    }
    function PC(m) {
      _l === null ? _l = [m] : _l.push(m);
    }
    function ed(m, A, V) {
      if (m = V.ref, m !== null && typeof m != "function" && typeof m != "object") {
        if (V._owner) {
          if (V = V._owner, V) {
            if (V.tag !== 1) throw Error(l(309));
            var Y = V.stateNode;
          }
          if (!Y) throw Error(l(147, m));
          var L = Y, $ = "" + m;
          return A !== null && A.ref !== null && typeof A.ref == "function" && A.ref._stringRef === $ ? A.ref : (A = function(Ve) {
            var nt = L.refs;
            nt === OI && (nt = L.refs = {}), Ve === null ? delete nt[$] : nt[$] = Ve;
          }, A._stringRef = $, A);
        }
        if (typeof m != "string") throw Error(l(284));
        if (!V._owner) throw Error(l(290, m));
      }
      return m;
    }
    function wc(m, A) {
      throw m = Object.prototype.toString.call(A), Error(l(31, m === "[object Object]" ? "object with keys {" + Object.keys(A).join(", ") + "}" : m));
    }
    function zl(m) {
      var A = m._init;
      return A(m._payload);
    }
    function JC(m) {
      function A(It, st) {
        if (m) {
          var Zt = It.deletions;
          Zt === null ? (It.deletions = [st], It.flags |= 16) : Zt.push(st);
        }
      }
      function V(It, st) {
        if (!m) return null;
        for (; st !== null; ) A(It, st), st = st.sibling;
        return null;
      }
      function Y(It, st) {
        for (It = /* @__PURE__ */ new Map(); st !== null; ) st.key !== null ? It.set(st.key, st) : It.set(st.index, st), st = st.sibling;
        return It;
      }
      function L(It, st) {
        return It = Il(It, st), It.index = 0, It.sibling = null, It;
      }
      function $(It, st, Zt) {
        return It.index = Zt, m ? (Zt = It.alternate, Zt !== null ? (Zt = Zt.index, Zt < st ? (It.flags |= 2, st) : Zt) : (It.flags |= 2, st)) : (It.flags |= 1048576, st);
      }
      function Ve(It) {
        return m && It.alternate === null && (It.flags |= 2), It;
      }
      function nt(It, st, Zt, Tn) {
        return st === null || st.tag !== 6 ? (st = sC(Zt, It.mode, Tn), st.return = It, st) : (st = L(st, Zt), st.return = It, st);
      }
      function kt(It, st, Zt, Tn) {
        var fn = Zt.type;
        return fn === h ? Jn(It, st, Zt.props.children, Tn, Zt.key) : st !== null && (st.elementType === fn || typeof fn == "object" && fn !== null && fn.$$typeof === E && zl(fn) === st.type) ? (Tn = L(st, Zt.props), Tn.ref = ed(It, st, Zt), Tn.return = It, Tn) : (Tn = Su(Zt.type, Zt.key, Zt.props, null, It.mode, Tn), Tn.ref = ed(It, st, Zt), Tn.return = It, Tn);
      }
      function Wn(It, st, Zt, Tn) {
        return st === null || st.tag !== 4 || st.stateNode.containerInfo !== Zt.containerInfo || st.stateNode.implementation !== Zt.implementation ? (st = Sg(Zt, It.mode, Tn), st.return = It, st) : (st = L(st, Zt.children || []), st.return = It, st);
      }
      function Jn(It, st, Zt, Tn, fn) {
        return st === null || st.tag !== 7 ? (st = rc(Zt, It.mode, Tn, fn), st.return = It, st) : (st = L(st, Zt), st.return = It, st);
      }
      function mi(It, st, Zt) {
        if (typeof st == "string" && st !== "" || typeof st == "number") return st = sC("" + st, It.mode, Zt), st.return = It, st;
        if (typeof st == "object" && st !== null) {
          switch (st.$$typeof) {
            case I:
              return Zt = Su(st.type, st.key, st.props, null, It.mode, Zt), Zt.ref = ed(It, null, st), Zt.return = It, Zt;
            case f:
              return st = Sg(st, It.mode, Zt), st.return = It, st;
            case E:
              var Tn = st._init;
              return mi(It, Tn(st._payload), Zt);
          }
          if (Te(st) || U(st)) return st = rc(st, It.mode, Zt, null), st.return = It, st;
          wc(It, st);
        }
        return null;
      }
      function wi(It, st, Zt, Tn) {
        var fn = st !== null ? st.key : null;
        if (typeof Zt == "string" && Zt !== "" || typeof Zt == "number") return fn !== null ? null : nt(It, st, "" + Zt, Tn);
        if (typeof Zt == "object" && Zt !== null) {
          switch (Zt.$$typeof) {
            case I:
              return Zt.key === fn ? kt(It, st, Zt, Tn) : null;
            case f:
              return Zt.key === fn ? Wn(It, st, Zt, Tn) : null;
            case E:
              return fn = Zt._init, wi(
                It,
                st,
                fn(Zt._payload),
                Tn
              );
          }
          if (Te(Zt) || U(Zt)) return fn !== null ? null : Jn(It, st, Zt, Tn, null);
          wc(It, Zt);
        }
        return null;
      }
      function lr(It, st, Zt, Tn, fn) {
        if (typeof Tn == "string" && Tn !== "" || typeof Tn == "number") return It = It.get(Zt) || null, nt(st, It, "" + Tn, fn);
        if (typeof Tn == "object" && Tn !== null) {
          switch (Tn.$$typeof) {
            case I:
              return It = It.get(Tn.key === null ? Zt : Tn.key) || null, kt(st, It, Tn, fn);
            case f:
              return It = It.get(Tn.key === null ? Zt : Tn.key) || null, Wn(st, It, Tn, fn);
            case E:
              var ji = Tn._init;
              return lr(It, st, Zt, ji(Tn._payload), fn);
          }
          if (Te(Tn) || U(Tn)) return It = It.get(Zt) || null, Jn(st, It, Tn, fn, null);
          wc(st, Tn);
        }
        return null;
      }
      function $n(It, st, Zt, Tn) {
        for (var fn = null, ji = null, $i = st, fr = st = 0, xa = null; $i !== null && fr < Zt.length; fr++) {
          $i.index > fr ? (xa = $i, $i = null) : xa = $i.sibling;
          var mr = wi(It, $i, Zt[fr], Tn);
          if (mr === null) {
            $i === null && ($i = xa);
            break;
          }
          m && $i && mr.alternate === null && A(It, $i), st = $(mr, st, fr), ji === null ? fn = mr : ji.sibling = mr, ji = mr, $i = xa;
        }
        if (fr === Zt.length) return V(It, $i), ca && Sc(It, fr), fn;
        if ($i === null) {
          for (; fr < Zt.length; fr++) $i = mi(It, Zt[fr], Tn), $i !== null && (st = $($i, st, fr), ji === null ? fn = $i : ji.sibling = $i, ji = $i);
          return ca && Sc(It, fr), fn;
        }
        for ($i = Y(It, $i); fr < Zt.length; fr++) xa = lr($i, It, fr, Zt[fr], Tn), xa !== null && (m && xa.alternate !== null && $i.delete(xa.key === null ? fr : xa.key), st = $(xa, st, fr), ji === null ? fn = xa : ji.sibling = xa, ji = xa);
        return m && $i.forEach(function(Cl) {
          return A(It, Cl);
        }), ca && Sc(It, fr), fn;
      }
      function to(It, st, Zt, Tn) {
        var fn = U(Zt);
        if (typeof fn != "function") throw Error(l(150));
        if (Zt = fn.call(Zt), Zt == null) throw Error(l(151));
        for (var ji = fn = null, $i = st, fr = st = 0, xa = null, mr = Zt.next(); $i !== null && !mr.done; fr++, mr = Zt.next()) {
          $i.index > fr ? (xa = $i, $i = null) : xa = $i.sibling;
          var Cl = wi(It, $i, mr.value, Tn);
          if (Cl === null) {
            $i === null && ($i = xa);
            break;
          }
          m && $i && Cl.alternate === null && A(It, $i), st = $(Cl, st, fr), ji === null ? fn = Cl : ji.sibling = Cl, ji = Cl, $i = xa;
        }
        if (mr.done) return V(
          It,
          $i
        ), ca && Sc(It, fr), fn;
        if ($i === null) {
          for (; !mr.done; fr++, mr = Zt.next()) mr = mi(It, mr.value, Tn), mr !== null && (st = $(mr, st, fr), ji === null ? fn = mr : ji.sibling = mr, ji = mr);
          return ca && Sc(It, fr), fn;
        }
        for ($i = Y(It, $i); !mr.done; fr++, mr = Zt.next()) mr = lr($i, It, fr, mr.value, Tn), mr !== null && (m && mr.alternate !== null && $i.delete(mr.key === null ? fr : mr.key), st = $(mr, st, fr), ji === null ? fn = mr : ji.sibling = mr, ji = mr);
        return m && $i.forEach(function(Gp) {
          return A(It, Gp);
        }), ca && Sc(It, fr), fn;
      }
      function gs(It, st, Zt, Tn) {
        if (typeof Zt == "object" && Zt !== null && Zt.type === h && Zt.key === null && (Zt = Zt.props.children), typeof Zt == "object" && Zt !== null) {
          switch (Zt.$$typeof) {
            case I:
              e: {
                for (var fn = Zt.key, ji = st; ji !== null; ) {
                  if (ji.key === fn) {
                    if (fn = Zt.type, fn === h) {
                      if (ji.tag === 7) {
                        V(It, ji.sibling), st = L(ji, Zt.props.children), st.return = It, It = st;
                        break e;
                      }
                    } else if (ji.elementType === fn || typeof fn == "object" && fn !== null && fn.$$typeof === E && zl(fn) === ji.type) {
                      V(It, ji.sibling), st = L(ji, Zt.props), st.ref = ed(It, ji, Zt), st.return = It, It = st;
                      break e;
                    }
                    V(It, ji);
                    break;
                  } else A(It, ji);
                  ji = ji.sibling;
                }
                Zt.type === h ? (st = rc(Zt.props.children, It.mode, Tn, Zt.key), st.return = It, It = st) : (Tn = Su(Zt.type, Zt.key, Zt.props, null, It.mode, Tn), Tn.ref = ed(It, st, Zt), Tn.return = It, It = Tn);
              }
              return Ve(It);
            case f:
              e: {
                for (ji = Zt.key; st !== null; ) {
                  if (st.key === ji) if (st.tag === 4 && st.stateNode.containerInfo === Zt.containerInfo && st.stateNode.implementation === Zt.implementation) {
                    V(It, st.sibling), st = L(st, Zt.children || []), st.return = It, It = st;
                    break e;
                  } else {
                    V(It, st);
                    break;
                  }
                  else A(It, st);
                  st = st.sibling;
                }
                st = Sg(Zt, It.mode, Tn), st.return = It, It = st;
              }
              return Ve(It);
            case E:
              return ji = Zt._init, gs(It, st, ji(Zt._payload), Tn);
          }
          if (Te(Zt)) return $n(It, st, Zt, Tn);
          if (U(Zt)) return to(It, st, Zt, Tn);
          wc(It, Zt);
        }
        return typeof Zt == "string" && Zt !== "" || typeof Zt == "number" ? (Zt = "" + Zt, st !== null && st.tag === 6 ? (V(It, st.sibling), st = L(st, Zt), st.return = It, It = st) : (V(It, st), st = sC(Zt, It.mode, Tn), st.return = It, It = st), Ve(It)) : V(It, st);
      }
      return gs;
    }
    var fs = JC(!0), Ph = JC(!1), dg = {}, sl = pr(dg), Ig = pr(dg), Ud = pr(dg);
    function Kl(m) {
      if (m === dg) throw Error(l(174));
      return m;
    }
    function QC(m, A) {
      ge(Ud, A), ge(Ig, m), ge(sl, dg), m = je(A), Ln(sl), ge(sl, m);
    }
    function Od() {
      Ln(sl), Ln(Ig), Ln(Ud);
    }
    function vp(m) {
      var A = Kl(Ud.current), V = Kl(sl.current);
      A = ee(V, m.type, A), V !== A && (ge(Ig, m), ge(sl, A));
    }
    function QI(m) {
      Ig.current === m && (Ln(sl), Ln(Ig));
    }
    var Dr = pr(0);
    function Pd(m) {
      for (var A = m; A !== null; ) {
        if (A.tag === 13) {
          var V = A.memoizedState;
          if (V !== null && (V = V.dehydrated, V === null || la(V) || Oa(V))) return A;
        } else if (A.tag === 19 && A.memoizedProps.revealOrder !== void 0) {
          if (A.flags & 128) return A;
        } else if (A.child !== null) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === m) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === m) return null;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      }
      return null;
    }
    var Ts = [];
    function _s() {
      for (var m = 0; m < Ts.length; m++) {
        var A = Ts[m];
        mn ? A._workInProgressVersionPrimary = null : A._workInProgressVersionSecondary = null;
      }
      Ts.length = 0;
    }
    var fu = u.ReactCurrentDispatcher, va = u.ReactCurrentBatchConfig, ao = 0, za = null, Qr = null, jr = null, zs = !1, Ll = !1, ps = 0, jI = 0;
    function oo() {
      throw Error(l(321));
    }
    function Jd(m, A) {
      if (A === null) return !1;
      for (var V = 0; V < A.length && V < m.length; V++) if (!rs(m[V], A[V])) return !1;
      return !0;
    }
    function ll(m, A, V, Y, L, $) {
      if (ao = $, za = A, A.memoizedState = null, A.updateQueue = null, A.lanes = 0, fu.current = m === null || m.memoizedState === null ? qC : Cg, m = V(Y, L), Ll) {
        $ = 0;
        do {
          if (Ll = !1, ps = 0, 25 <= $) throw Error(l(301));
          $ += 1, jr = Qr = null, A.updateQueue = null, fu.current = $d, m = V(Y, L);
        } while (Ll);
      }
      if (fu.current = ad, A = Qr !== null && Qr.next !== null, ao = 0, jr = Qr = za = null, zs = !1, A) throw Error(l(300));
      return m;
    }
    function Pu() {
      var m = ps !== 0;
      return ps = 0, m;
    }
    function Sl() {
      var m = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return jr === null ? za.memoizedState = jr = m : jr = jr.next = m, jr;
    }
    function pu() {
      if (Qr === null) {
        var m = za.alternate;
        m = m !== null ? m.memoizedState : null;
      } else m = Qr.next;
      var A = jr === null ? za.memoizedState : jr.next;
      if (A !== null) jr = A, Qr = m;
      else {
        if (m === null) throw Error(l(310));
        Qr = m, m = { memoizedState: Qr.memoizedState, baseState: Qr.baseState, baseQueue: Qr.baseQueue, queue: Qr.queue, next: null }, jr === null ? za.memoizedState = jr = m : jr = jr.next = m;
      }
      return jr;
    }
    function mu(m, A) {
      return typeof A == "function" ? A(m) : A;
    }
    function fo(m) {
      var A = pu(), V = A.queue;
      if (V === null) throw Error(l(311));
      V.lastRenderedReducer = m;
      var Y = Qr, L = Y.baseQueue, $ = V.pending;
      if ($ !== null) {
        if (L !== null) {
          var Ve = L.next;
          L.next = $.next, $.next = Ve;
        }
        Y.baseQueue = L = $, V.pending = null;
      }
      if (L !== null) {
        $ = L.next, Y = Y.baseState;
        var nt = Ve = null, kt = null, Wn = $;
        do {
          var Jn = Wn.lane;
          if ((ao & Jn) === Jn) kt !== null && (kt = kt.next = { lane: 0, action: Wn.action, hasEagerState: Wn.hasEagerState, eagerState: Wn.eagerState, next: null }), Y = Wn.hasEagerState ? Wn.eagerState : m(Y, Wn.action);
          else {
            var mi = {
              lane: Jn,
              action: Wn.action,
              hasEagerState: Wn.hasEagerState,
              eagerState: Wn.eagerState,
              next: null
            };
            kt === null ? (nt = kt = mi, Ve = Y) : kt = kt.next = mi, za.lanes |= Jn, $u |= Jn;
          }
          Wn = Wn.next;
        } while (Wn !== null && Wn !== $);
        kt === null ? Ve = Y : kt.next = nt, rs(Y, A.memoizedState) || (Pi = !0), A.memoizedState = Y, A.baseState = Ve, A.baseQueue = kt, V.lastRenderedState = Y;
      }
      if (m = V.interleaved, m !== null) {
        L = m;
        do
          $ = L.lane, za.lanes |= $, $u |= $, L = L.next;
        while (L !== m);
      } else L === null && (V.lanes = 0);
      return [A.memoizedState, V.dispatch];
    }
    function Qd(m) {
      var A = pu(), V = A.queue;
      if (V === null) throw Error(l(311));
      V.lastRenderedReducer = m;
      var Y = V.dispatch, L = V.pending, $ = A.memoizedState;
      if (L !== null) {
        V.pending = null;
        var Ve = L = L.next;
        do
          $ = m($, Ve.action), Ve = Ve.next;
        while (Ve !== L);
        rs($, A.memoizedState) || (Pi = !0), A.memoizedState = $, A.baseQueue === null && (A.baseState = $), V.lastRenderedState = $;
      }
      return [$, Y];
    }
    function yp() {
    }
    function td(m, A) {
      var V = za, Y = pu(), L = A(), $ = !rs(Y.memoizedState, L);
      if ($ && (Y.memoizedState = L, Pi = !0), Y = Y.queue, nd(Rr.bind(null, V, Y, m), [m]), Y.getSnapshot !== A || $ || jr !== null && jr.memoizedState.tag & 1) {
        if (V.flags |= 2048, as(9, Oi.bind(null, V, Y, L, A), void 0, null), po === null) throw Error(l(349));
        ao & 30 || Jh(V, A, L);
      }
      return L;
    }
    function Jh(m, A, V) {
      m.flags |= 16384, m = { getSnapshot: A, value: V }, A = za.updateQueue, A === null ? (A = { lastEffect: null, stores: null }, za.updateQueue = A, A.stores = [m]) : (V = A.stores, V === null ? A.stores = [m] : V.push(m));
    }
    function Oi(m, A, V, Y) {
      A.value = V, A.getSnapshot = Y, xr(A) && La(m, 1, -1);
    }
    function Rr(m, A, V) {
      return V(function() {
        xr(A) && La(m, 1, -1);
      });
    }
    function xr(m) {
      var A = m.getSnapshot;
      m = m.value;
      try {
        var V = A();
        return !rs(m, V);
      } catch {
        return !0;
      }
    }
    function Ma(m) {
      var A = Sl();
      return typeof m == "function" && (m = m()), A.memoizedState = A.baseState = m, m = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: mu, lastRenderedState: m }, A.queue = m, m = m.dispatch = qh.bind(null, za, m), [A.memoizedState, m];
    }
    function as(m, A, V, Y) {
      return m = { tag: m, create: A, destroy: V, deps: Y, next: null }, A = za.updateQueue, A === null ? (A = { lastEffect: null, stores: null }, za.updateQueue = A, A.lastEffect = m.next = m) : (V = A.lastEffect, V === null ? A.lastEffect = m.next = m : (Y = V.next, V.next = m, m.next = Y, A.lastEffect = m)), m;
    }
    function bp() {
      return pu().memoizedState;
    }
    function Au(m, A, V, Y) {
      var L = Sl();
      za.flags |= m, L.memoizedState = as(1 | A, V, void 0, Y === void 0 ? null : Y);
    }
    function Qh(m, A, V, Y) {
      var L = pu();
      Y = Y === void 0 ? null : Y;
      var $ = void 0;
      if (Qr !== null) {
        var Ve = Qr.memoizedState;
        if ($ = Ve.destroy, Y !== null && Jd(Y, Ve.deps)) {
          L.memoizedState = as(A, V, $, Y);
          return;
        }
      }
      za.flags |= m, L.memoizedState = as(1 | A, V, $, Y);
    }
    function jh(m, A) {
      return Au(8390656, 8, m, A);
    }
    function nd(m, A) {
      return Qh(2048, 8, m, A);
    }
    function Dt(m, A) {
      return Qh(4, 2, m, A);
    }
    function so(m, A) {
      return Qh(4, 4, m, A);
    }
    function nr(m, A) {
      if (typeof A == "function") return m = m(), A(m), function() {
        A(null);
      };
      if (A != null) return m = m(), A.current = m, function() {
        A.current = null;
      };
    }
    function Ks(m, A, V) {
      return V = V != null ? V.concat([m]) : null, Qh(4, 4, nr.bind(null, A, m), V);
    }
    function vu() {
    }
    function Rc(m, A) {
      var V = pu();
      A = A === void 0 ? null : A;
      var Y = V.memoizedState;
      return Y !== null && A !== null && Jd(A, Y[1]) ? Y[0] : (V.memoizedState = [m, A], m);
    }
    function ul(m, A) {
      var V = pu();
      A = A === void 0 ? null : A;
      var Y = V.memoizedState;
      return Y !== null && A !== null && Jd(A, Y[1]) ? Y[0] : (m = m(), V.memoizedState = [m, A], m);
    }
    function id(m, A) {
      var V = Hn;
      Hn = V !== 0 && 4 > V ? V : 4, m(!0);
      var Y = va.transition;
      va.transition = {};
      try {
        m(!1), A();
      } finally {
        Hn = V, va.transition = Y;
      }
    }
    function kl() {
      return pu().memoizedState;
    }
    function jd(m, A, V) {
      var Y = Or(m);
      V = { lane: Y, action: V, hasEagerState: !1, eagerState: null, next: null }, qI(m) ? jC(A, V) : (rd(m, A, V), V = vi(), m = La(m, Y, V), m !== null && qd(m, A, Y));
    }
    function qh(m, A, V) {
      var Y = Or(m), L = { lane: Y, action: V, hasEagerState: !1, eagerState: null, next: null };
      if (qI(m)) jC(A, L);
      else {
        rd(m, A, L);
        var $ = m.alternate;
        if (m.lanes === 0 && ($ === null || $.lanes === 0) && ($ = A.lastRenderedReducer, $ !== null)) try {
          var Ve = A.lastRenderedState, nt = $(Ve, V);
          if (L.hasEagerState = !0, L.eagerState = nt, rs(nt, Ve)) return;
        } catch {
        } finally {
        }
        V = vi(), m = La(m, Y, V), m !== null && qd(m, A, Y);
      }
    }
    function qI(m) {
      var A = m.alternate;
      return m === za || A !== null && A === za;
    }
    function jC(m, A) {
      Ll = zs = !0;
      var V = m.pending;
      V === null ? A.next = A : (A.next = V.next, V.next = A), m.pending = A;
    }
    function rd(m, A, V) {
      po !== null && m.mode & 1 && !(ur & 2) ? (m = A.interleaved, m === null ? (V.next = V, vr === null ? vr = [A] : vr.push(A)) : (V.next = m.next, m.next = V), A.interleaved = V) : (m = A.pending, m === null ? V.next = V : (V.next = m.next, m.next = V), A.pending = V);
    }
    function qd(m, A, V) {
      if (V & 4194240) {
        var Y = A.lanes;
        Y &= m.pendingLanes, V |= Y, A.lanes = V, yr(m, V);
      }
    }
    var ad = { readContext: hr, useCallback: oo, useContext: oo, useEffect: oo, useImperativeHandle: oo, useInsertionEffect: oo, useLayoutEffect: oo, useMemo: oo, useReducer: oo, useRef: oo, useState: oo, useDebugValue: oo, useDeferredValue: oo, useTransition: oo, useMutableSource: oo, useSyncExternalStore: oo, useId: oo, unstable_isNewReconciler: !1 }, qC = { readContext: hr, useCallback: function(m, A) {
      return Sl().memoizedState = [m, A === void 0 ? null : A], m;
    }, useContext: hr, useEffect: jh, useImperativeHandle: function(m, A, V) {
      return V = V != null ? V.concat([m]) : null, Au(
        4194308,
        4,
        nr.bind(null, A, m),
        V
      );
    }, useLayoutEffect: function(m, A) {
      return Au(4194308, 4, m, A);
    }, useInsertionEffect: function(m, A) {
      return Au(4, 2, m, A);
    }, useMemo: function(m, A) {
      var V = Sl();
      return A = A === void 0 ? null : A, m = m(), V.memoizedState = [m, A], m;
    }, useReducer: function(m, A, V) {
      var Y = Sl();
      return A = V !== void 0 ? V(A) : A, Y.memoizedState = Y.baseState = A, m = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: m, lastRenderedState: A }, Y.queue = m, m = m.dispatch = jd.bind(null, za, m), [Y.memoizedState, m];
    }, useRef: function(m) {
      var A = Sl();
      return m = { current: m }, A.memoizedState = m;
    }, useState: Ma, useDebugValue: vu, useDeferredValue: function(m) {
      var A = Ma(m), V = A[0], Y = A[1];
      return jh(function() {
        var L = va.transition;
        va.transition = {};
        try {
          Y(m);
        } finally {
          va.transition = L;
        }
      }, [m]), V;
    }, useTransition: function() {
      var m = Ma(!1), A = m[0];
      return m = id.bind(null, m[1]), Sl().memoizedState = m, [A, m];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(m, A, V) {
      var Y = za, L = Sl();
      if (ca) {
        if (V === void 0) throw Error(l(407));
        V = V();
      } else {
        if (V = A(), po === null) throw Error(l(349));
        ao & 30 || Jh(Y, A, V);
      }
      L.memoizedState = V;
      var $ = { value: V, getSnapshot: A };
      return L.queue = $, jh(Rr.bind(null, Y, $, m), [m]), Y.flags |= 2048, as(9, Oi.bind(null, Y, $, V, A), void 0, null), V;
    }, useId: function() {
      var m = Sl(), A = po.identifierPrefix;
      if (ca) {
        var V = gg, Y = Du;
        V = (Y & ~(1 << 32 - un(Y) - 1)).toString(32) + V, A = ":" + A + "R" + V, V = ps++, 0 < V && (A += "H" + V.toString(32)), A += ":";
      } else V = jI++, A = ":" + A + "r" + V.toString(32) + ":";
      return m.memoizedState = A;
    }, unstable_isNewReconciler: !1 }, Cg = {
      readContext: hr,
      useCallback: Rc,
      useContext: hr,
      useEffect: nd,
      useImperativeHandle: Ks,
      useInsertionEffect: Dt,
      useLayoutEffect: so,
      useMemo: ul,
      useReducer: fo,
      useRef: bp,
      useState: function() {
        return fo(mu);
      },
      useDebugValue: vu,
      useDeferredValue: function(m) {
        var A = fo(mu), V = A[0], Y = A[1];
        return nd(function() {
          var L = va.transition;
          va.transition = {};
          try {
            Y(m);
          } finally {
            va.transition = L;
          }
        }, [m]), V;
      },
      useTransition: function() {
        var m = fo(mu)[0], A = pu().memoizedState;
        return [m, A];
      },
      useMutableSource: yp,
      useSyncExternalStore: td,
      useId: kl,
      unstable_isNewReconciler: !1
    }, $d = {
      readContext: hr,
      useCallback: Rc,
      useContext: hr,
      useEffect: nd,
      useImperativeHandle: Ks,
      useInsertionEffect: Dt,
      useLayoutEffect: so,
      useMemo: ul,
      useReducer: Qd,
      useRef: bp,
      useState: function() {
        return Qd(mu);
      },
      useDebugValue: vu,
      useDeferredValue: function(m) {
        var A = Qd(mu), V = A[0], Y = A[1];
        return nd(function() {
          var L = va.transition;
          va.transition = {};
          try {
            Y(m);
          } finally {
            va.transition = L;
          }
        }, [m]), V;
      },
      useTransition: function() {
        var m = Qd(mu)[0], A = pu().memoizedState;
        return [m, A];
      },
      useMutableSource: yp,
      useSyncExternalStore: td,
      useId: kl,
      unstable_isNewReconciler: !1
    };
    function hg(m, A) {
      try {
        var V = "", Y = A;
        do
          V += kI(Y), Y = Y.return;
        while (Y);
        var L = V;
      } catch ($) {
        L = `
Error generating stack: ` + $.message + `
` + $.stack;
      }
      return { value: m, source: A, stack: L };
    }
    function eI(m, A) {
      try {
        console.error(A.value);
      } catch (V) {
        setTimeout(function() {
          throw V;
        });
      }
    }
    var $h = typeof WeakMap == "function" ? WeakMap : Map;
    function $I(m, A, V) {
      V = Qo(-1, V), V.tag = 3, V.payload = { element: null };
      var Y = A.value;
      return V.callback = function() {
        iC || (iC = !0, Xa = Y), eI(m, A);
      }, V;
    }
    function eC(m, A, V) {
      V = Qo(-1, V), V.tag = 3;
      var Y = m.type.getDerivedStateFromError;
      if (typeof Y == "function") {
        var L = A.value;
        V.payload = function() {
          return Y(L);
        }, V.callback = function() {
          eI(m, A);
        };
      }
      var $ = m.stateNode;
      return $ !== null && typeof $.componentDidCatch == "function" && (V.callback = function() {
        eI(m, A), typeof Y != "function" && (Ql === null ? Ql = /* @__PURE__ */ new Set([this]) : Ql.add(this));
        var Ve = A.stack;
        this.componentDidCatch(A.value, { componentStack: Ve !== null ? Ve : "" });
      }), V;
    }
    function Ls(m, A, V) {
      var Y = m.pingCache;
      if (Y === null) {
        Y = m.pingCache = new $h();
        var L = /* @__PURE__ */ new Set();
        Y.set(A, L);
      } else L = Y.get(A), L === void 0 && (L = /* @__PURE__ */ new Set(), Y.set(A, L));
      L.has(V) || (L.add(V), m = Ao.bind(null, m, A, V), A.then(m, m));
    }
    function fg(m) {
      do {
        var A;
        if ((A = m.tag === 13) && (A = m.memoizedState, A = A !== null ? A.dehydrated !== null : !0), A) return m;
        m = m.return;
      } while (m !== null);
      return null;
    }
    function cl(m, A, V, Y, L) {
      return m.mode & 1 ? (m.flags |= 65536, m.lanes = L, m) : (m === A ? m.flags |= 65536 : (m.flags |= 128, V.flags |= 131072, V.flags &= -52805, V.tag === 1 && (V.alternate === null ? V.tag = 17 : (A = Qo(-1, 1), A.tag = 2, Tl(V, A))), V.lanes |= 1), m);
    }
    function lo(m) {
      m.flags |= 4;
    }
    function od(m, A) {
      if (m !== null && m.child === A.child) return !0;
      if (A.flags & 16) return !1;
      for (m = A.child; m !== null; ) {
        if (m.flags & 12854 || m.subtreeFlags & 12854) return !1;
        m = m.sibling;
      }
      return !0;
    }
    var ms, pg, $C, sd;
    if (Pn) ms = function(m, A) {
      for (var V = A.child; V !== null; ) {
        if (V.tag === 5 || V.tag === 6) Ye(m, V.stateNode);
        else if (V.tag !== 4 && V.child !== null) {
          V.child.return = V, V = V.child;
          continue;
        }
        if (V === A) break;
        for (; V.sibling === null; ) {
          if (V.return === null || V.return === A) return;
          V = V.return;
        }
        V.sibling.return = V.return, V = V.sibling;
      }
    }, pg = function() {
    }, $C = function(m, A, V, Y, L) {
      if (m = m.memoizedProps, m !== Y) {
        var $ = A.stateNode, Ve = Kl(sl.current);
        V = ke($, V, m, Y, L, Ve), (A.updateQueue = V) && lo(A);
      }
    }, sd = function(m, A, V, Y) {
      V !== Y && lo(A);
    };
    else if (he) {
      ms = function(m, A, V, Y) {
        for (var L = A.child; L !== null; ) {
          if (L.tag === 5) {
            var $ = L.stateNode;
            V && Y && ($ = pi($, L.type, L.memoizedProps, L)), Ye(m, $);
          } else if (L.tag === 6) $ = L.stateNode, V && Y && ($ = Cr($, L.memoizedProps, L)), Ye(m, $);
          else if (L.tag !== 4) {
            if (L.tag === 22 && L.memoizedState !== null) $ = L.child, $ !== null && ($.return = L), ms(m, L, !0, !0);
            else if (L.child !== null) {
              L.child.return = L, L = L.child;
              continue;
            }
          }
          if (L === A) break;
          for (; L.sibling === null; ) {
            if (L.return === null || L.return === A) return;
            L = L.return;
          }
          L.sibling.return = L.return, L = L.sibling;
        }
      };
      var Ju = function(m, A, V, Y) {
        for (var L = A.child; L !== null; ) {
          if (L.tag === 5) {
            var $ = L.stateNode;
            V && Y && ($ = pi($, L.type, L.memoizedProps, L)), xi(m, $);
          } else if (L.tag === 6) $ = L.stateNode, V && Y && ($ = Cr($, L.memoizedProps, L)), xi(m, $);
          else if (L.tag !== 4) {
            if (L.tag === 22 && L.memoizedState !== null) $ = L.child, $ !== null && ($.return = L), Ju(m, L, !0, !0);
            else if (L.child !== null) {
              L.child.return = L, L = L.child;
              continue;
            }
          }
          if (L === A) break;
          for (; L.sibling === null; ) {
            if (L.return === null || L.return === A) return;
            L = L.return;
          }
          L.sibling.return = L.return, L = L.sibling;
        }
      };
      pg = function(m, A) {
        var V = A.stateNode;
        if (!od(m, A)) {
          m = V.containerInfo;
          var Y = fi(m);
          Ju(Y, A, !1, !1), V.pendingChildren = Y, lo(A), Ir(m, Y);
        }
      }, $C = function(m, A, V, Y, L) {
        var $ = m.stateNode, Ve = m.memoizedProps;
        if ((m = od(m, A)) && Ve === Y) A.stateNode = $;
        else {
          var nt = A.stateNode, kt = Kl(sl.current), Wn = null;
          Ve !== Y && (Wn = ke(nt, V, Ve, Y, L, kt)), m && Wn === null ? A.stateNode = $ : ($ = an($, Wn, V, Ve, Y, A, m, nt), $e($, V, Y, L, kt) && lo(A), A.stateNode = $, m ? lo(A) : ms($, A, !1, !1));
        }
      }, sd = function(m, A, V, Y) {
        V !== Y ? (m = Kl(Ud.current), V = Kl(sl.current), A.stateNode = wt(Y, m, V, A), lo(A)) : A.stateNode = m.stateNode;
      };
    } else pg = function() {
    }, $C = function() {
    }, sd = function() {
    };
    function os(m, A) {
      if (!ca) switch (m.tailMode) {
        case "hidden":
          A = m.tail;
          for (var V = null; A !== null; ) A.alternate !== null && (V = A), A = A.sibling;
          V === null ? m.tail = null : V.sibling = null;
          break;
        case "collapsed":
          V = m.tail;
          for (var Y = null; V !== null; ) V.alternate !== null && (Y = V), V = V.sibling;
          Y === null ? A || m.tail === null ? m.tail = null : m.tail.sibling = null : Y.sibling = null;
      }
    }
    function wa(m) {
      var A = m.alternate !== null && m.alternate.child === m.child, V = 0, Y = 0;
      if (A) for (var L = m.child; L !== null; ) V |= L.lanes | L.childLanes, Y |= L.subtreeFlags & 14680064, Y |= L.flags & 14680064, L.return = m, L = L.sibling;
      else for (L = m.child; L !== null; ) V |= L.lanes | L.childLanes, Y |= L.subtreeFlags, Y |= L.flags, L.return = m, L = L.sibling;
      return m.subtreeFlags |= Y, m.childLanes = V, A;
    }
    function ks(m, A, V) {
      var Y = A.pendingProps;
      switch (Uu(A), A.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return wa(A), null;
        case 1:
          return Ai(A.type) && ve(), wa(A), null;
        case 3:
          return Y = A.stateNode, Od(), Ln(et), Ln(We), _s(), Y.pendingContext && (Y.context = Y.pendingContext, Y.pendingContext = null), (m === null || m.child === null) && (PI(A) ? lo(A) : m === null || m.memoizedState.isDehydrated && !(A.flags & 256) || (A.flags |= 1024, _l !== null && (dl(_l), _l = null))), pg(m, A), wa(A), null;
        case 5:
          QI(A), V = Kl(Ud.current);
          var L = A.type;
          if (m !== null && A.stateNode != null) $C(m, A, L, Y, V), m.ref !== A.ref && (A.flags |= 512, A.flags |= 2097152);
          else {
            if (!Y) {
              if (A.stateNode === null) throw Error(l(166));
              return wa(A), null;
            }
            if (m = Kl(sl.current), PI(A)) {
              if (!Lt) throw Error(l(175));
              m = ut(A.stateNode, A.type, A.memoizedProps, V, m, A, !Zc), A.updateQueue = m, m !== null && lo(A);
            } else {
              var $ = le(L, Y, V, m, A);
              ms($, A, !1, !1), A.stateNode = $, $e($, L, Y, V, m) && lo(A);
            }
            A.ref !== null && (A.flags |= 512, A.flags |= 2097152);
          }
          return wa(A), null;
        case 6:
          if (m && A.stateNode != null) sd(m, A, m.memoizedProps, Y);
          else {
            if (typeof Y != "string" && A.stateNode === null) throw Error(l(166));
            if (m = Kl(Ud.current), V = Kl(sl.current), PI(A)) {
              if (!Lt) throw Error(l(176));
              if (m = A.stateNode, Y = A.memoizedProps, (V = Bt(m, Y, A, !Zc)) && (L = Kr, L !== null)) switch ($ = (L.mode & 1) !== 0, L.tag) {
                case 3:
                  Kt(L.stateNode.containerInfo, m, Y, $);
                  break;
                case 5:
                  vn(L.type, L.memoizedProps, L.stateNode, m, Y, $);
              }
              V && lo(A);
            } else A.stateNode = wt(Y, m, V, A);
          }
          return wa(A), null;
        case 13:
          if (Ln(Dr), Y = A.memoizedState, ca && _a !== null && A.mode & 1 && !(A.flags & 128)) {
            for (m = _a; m; ) m = qe(m);
            return JI(), A.flags |= 98560, A;
          }
          if (Y !== null && Y.dehydrated !== null) {
            if (Y = PI(A), m === null) {
              if (!Y) throw Error(l(318));
              if (!Lt) throw Error(l(344));
              if (m = A.memoizedState, m = m !== null ? m.dehydrated : null, !m) throw Error(l(317));
              Tt(m, A);
            } else JI(), !(A.flags & 128) && (A.memoizedState = null), A.flags |= 4;
            return wa(A), null;
          }
          return _l !== null && (dl(_l), _l = null), A.flags & 128 ? (A.lanes = V, A) : (Y = Y !== null, V = !1, m === null ? PI(A) : V = m.memoizedState !== null, Y && !V && (A.child.flags |= 8192, A.mode & 1 && (m === null || Dr.current & 1 ? mo === 0 && (mo = 3) : bg())), A.updateQueue !== null && (A.flags |= 4), wa(A), null);
        case 4:
          return Od(), pg(m, A), m === null && tn(A.stateNode.containerInfo), wa(A), null;
        case 10:
          return Yi(A.type._context), wa(A), null;
        case 17:
          return Ai(A.type) && ve(), wa(A), null;
        case 19:
          if (Ln(Dr), L = A.memoizedState, L === null) return wa(A), null;
          if (Y = (A.flags & 128) !== 0, $ = L.rendering, $ === null) if (Y) os(L, !1);
          else {
            if (mo !== 0 || m !== null && m.flags & 128) for (m = A.child; m !== null; ) {
              if ($ = Pd(m), $ !== null) {
                for (A.flags |= 128, os(L, !1), m = $.updateQueue, m !== null && (A.updateQueue = m, A.flags |= 4), A.subtreeFlags = 0, m = V, Y = A.child; Y !== null; ) V = Y, L = m, V.flags &= 14680066, $ = V.alternate, $ === null ? (V.childLanes = 0, V.lanes = L, V.child = null, V.subtreeFlags = 0, V.memoizedProps = null, V.memoizedState = null, V.updateQueue = null, V.dependencies = null, V.stateNode = null) : (V.childLanes = $.childLanes, V.lanes = $.lanes, V.child = $.child, V.subtreeFlags = 0, V.deletions = null, V.memoizedProps = $.memoizedProps, V.memoizedState = $.memoizedState, V.updateQueue = $.updateQueue, V.type = $.type, L = $.dependencies, V.dependencies = L === null ? null : { lanes: L.lanes, firstContext: L.firstContext }), Y = Y.sibling;
                return ge(Dr, Dr.current & 1 | 2), A.child;
              }
              m = m.sibling;
            }
            L.tail !== null && kr() > dd && (A.flags |= 128, Y = !0, os(L, !1), A.lanes = 4194304);
          }
          else {
            if (!Y) if (m = Pd($), m !== null) {
              if (A.flags |= 128, Y = !0, m = m.updateQueue, m !== null && (A.updateQueue = m, A.flags |= 4), os(L, !0), L.tail === null && L.tailMode === "hidden" && !$.alternate && !ca) return wa(A), null;
            } else 2 * kr() - L.renderingStartTime > dd && V !== 1073741824 && (A.flags |= 128, Y = !0, os(L, !1), A.lanes = 4194304);
            L.isBackwards ? ($.sibling = A.child, A.child = $) : (m = L.last, m !== null ? m.sibling = $ : A.child = $, L.last = $);
          }
          return L.tail !== null ? (A = L.tail, L.rendering = A, L.tail = A.sibling, L.renderingStartTime = kr(), A.sibling = null, m = Dr.current, ge(Dr, Y ? m & 1 | 2 : m & 1), A) : (wa(A), null);
        case 22:
        case 23:
          return Rl(), Y = A.memoizedState !== null, m !== null && m.memoizedState !== null !== Y && (A.flags |= 8192), Y && A.mode & 1 ? Ur & 1073741824 && (wa(A), Pn && A.subtreeFlags & 6 && (A.flags |= 8192)) : wa(A), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(l(156, A.tag));
    }
    var Hi = u.ReactCurrentOwner, Pi = !1;
    function ar(m, A, V, Y) {
      A.child = m === null ? Ph(A, null, V, Y) : fs(A, m.child, V, Y);
    }
    function Ci(m, A, V, Y, L) {
      V = V.render;
      var $ = A.ref;
      return Yr(A, L), Y = ll(m, A, V, Y, $, L), V = Pu(), m !== null && !Pi ? (A.updateQueue = m.updateQueue, A.flags &= -2053, m.lanes &= ~L, ls(m, A, L)) : (ca && V && Es(A), A.flags |= 1, ar(m, A, Y, L), A.child);
    }
    function Gr(m, A, V, Y, L) {
      if (m === null) {
        var $ = V.type;
        return typeof $ == "function" && !Xc($) && $.defaultProps === void 0 && V.compare === null && V.defaultProps === void 0 ? (A.tag = 15, A.type = $, Ds(m, A, $, Y, L)) : (m = Su(V.type, null, Y, A, A.mode, L), m.ref = A.ref, m.return = A, A.child = m);
      }
      if ($ = m.child, !(m.lanes & L)) {
        var Ve = $.memoizedProps;
        if (V = V.compare, V = V !== null ? V : Bl, V(Ve, Y) && m.ref === A.ref) return ls(m, A, L);
      }
      return A.flags |= 1, m = Il($, Y), m.ref = A.ref, m.return = A, A.child = m;
    }
    function Ds(m, A, V, Y, L) {
      if (m !== null && Bl(m.memoizedProps, Y) && m.ref === A.ref) if (Pi = !1, (m.lanes & L) !== 0) m.flags & 131072 && (Pi = !0);
      else return A.lanes = m.lanes, ls(m, A, L);
      return As(m, A, V, Y, L);
    }
    function jo(m, A, V) {
      var Y = A.pendingProps, L = Y.children, $ = m !== null ? m.memoizedState : null;
      if (Y.mode === "hidden") if (!(A.mode & 1)) A.memoizedState = { baseLanes: 0, cachePool: null }, ge(rI, Ur), Ur |= V;
      else if (V & 1073741824) A.memoizedState = { baseLanes: 0, cachePool: null }, Y = $ !== null ? $.baseLanes : V, ge(rI, Ur), Ur |= Y;
      else return m = $ !== null ? $.baseLanes | V : V, A.lanes = A.childLanes = 1073741824, A.memoizedState = { baseLanes: m, cachePool: null }, A.updateQueue = null, ge(rI, Ur), Ur |= m, null;
      else $ !== null ? (Y = $.baseLanes | V, A.memoizedState = null) : Y = V, ge(rI, Ur), Ur |= Y;
      return ar(m, A, L, V), A.child;
    }
    function Qi(m, A) {
      var V = A.ref;
      (m === null && V !== null || m !== null && m.ref !== V) && (A.flags |= 512, A.flags |= 2097152);
    }
    function As(m, A, V, Y, L) {
      var $ = Ai(V) ? Mt : We.current;
      return $ = bn(A, $), Yr(A, L), V = ll(m, A, V, Y, $, L), Y = Pu(), m !== null && !Pi ? (A.updateQueue = m.updateQueue, A.flags &= -2053, m.lanes &= ~L, ls(m, A, L)) : (ca && Y && Es(A), A.flags |= 1, ar(m, A, V, L), A.child);
    }
    function Zl(m, A, V, Y, L) {
      if (Ai(V)) {
        var $ = !0;
        $t(A);
      } else $ = !1;
      if (Yr(A, L), A.stateNode === null) m !== null && (m.alternate = null, A.alternate = null, A.flags |= 2), pp(A, V, Y), Dh(A, V, Y, L), Y = !0;
      else if (m === null) {
        var Ve = A.stateNode, nt = A.memoizedProps;
        Ve.props = nt;
        var kt = Ve.context, Wn = V.contextType;
        typeof Wn == "object" && Wn !== null ? Wn = hr(Wn) : (Wn = Ai(V) ? Mt : We.current, Wn = bn(A, Wn));
        var Jn = V.getDerivedStateFromProps, mi = typeof Jn == "function" || typeof Ve.getSnapshotBeforeUpdate == "function";
        mi || typeof Ve.UNSAFE_componentWillReceiveProps != "function" && typeof Ve.componentWillReceiveProps != "function" || (nt !== Y || kt !== Wn) && kh(A, Ve, Y, Wn), br = !1;
        var wi = A.memoizedState;
        Ve.state = wi, Iu(A, Y, Ve, L), kt = A.memoizedState, nt !== Y || wi !== kt || et.current || br ? (typeof Jn == "function" && (DC(A, V, Jn, Y), kt = A.memoizedState), (nt = br || fp(A, V, nt, Y, wi, kt, Wn)) ? (mi || typeof Ve.UNSAFE_componentWillMount != "function" && typeof Ve.componentWillMount != "function" || (typeof Ve.componentWillMount == "function" && Ve.componentWillMount(), typeof Ve.UNSAFE_componentWillMount == "function" && Ve.UNSAFE_componentWillMount()), typeof Ve.componentDidMount == "function" && (A.flags |= 4194308)) : (typeof Ve.componentDidMount == "function" && (A.flags |= 4194308), A.memoizedProps = Y, A.memoizedState = kt), Ve.props = Y, Ve.state = kt, Ve.context = Wn, Y = nt) : (typeof Ve.componentDidMount == "function" && (A.flags |= 4194308), Y = !1);
      } else {
        Ve = A.stateNode, Fr(m, A), nt = A.memoizedProps, Wn = A.type === A.elementType ? nt : ie(A.type, nt), Ve.props = Wn, mi = A.pendingProps, wi = Ve.context, kt = V.contextType, typeof kt == "object" && kt !== null ? kt = hr(kt) : (kt = Ai(V) ? Mt : We.current, kt = bn(A, kt));
        var lr = V.getDerivedStateFromProps;
        (Jn = typeof lr == "function" || typeof Ve.getSnapshotBeforeUpdate == "function") || typeof Ve.UNSAFE_componentWillReceiveProps != "function" && typeof Ve.componentWillReceiveProps != "function" || (nt !== mi || wi !== kt) && kh(A, Ve, Y, kt), br = !1, wi = A.memoizedState, Ve.state = wi, Iu(A, Y, Ve, L);
        var $n = A.memoizedState;
        nt !== mi || wi !== $n || et.current || br ? (typeof lr == "function" && (DC(A, V, lr, Y), $n = A.memoizedState), (Wn = br || fp(A, V, Wn, Y, wi, $n, kt) || !1) ? (Jn || typeof Ve.UNSAFE_componentWillUpdate != "function" && typeof Ve.componentWillUpdate != "function" || (typeof Ve.componentWillUpdate == "function" && Ve.componentWillUpdate(
          Y,
          $n,
          kt
        ), typeof Ve.UNSAFE_componentWillUpdate == "function" && Ve.UNSAFE_componentWillUpdate(Y, $n, kt)), typeof Ve.componentDidUpdate == "function" && (A.flags |= 4), typeof Ve.getSnapshotBeforeUpdate == "function" && (A.flags |= 1024)) : (typeof Ve.componentDidUpdate != "function" || nt === m.memoizedProps && wi === m.memoizedState || (A.flags |= 4), typeof Ve.getSnapshotBeforeUpdate != "function" || nt === m.memoizedProps && wi === m.memoizedState || (A.flags |= 1024), A.memoizedProps = Y, A.memoizedState = $n), Ve.props = Y, Ve.state = $n, Ve.context = kt, Y = Wn) : (typeof Ve.componentDidUpdate != "function" || nt === m.memoizedProps && wi === m.memoizedState || (A.flags |= 4), typeof Ve.getSnapshotBeforeUpdate != "function" || nt === m.memoizedProps && wi === m.memoizedState || (A.flags |= 1024), Y = !1);
      }
      return Qa(m, A, V, Y, $, L);
    }
    function Qa(m, A, V, Y, L, $) {
      Qi(m, A);
      var Ve = (A.flags & 128) !== 0;
      if (!Y && !Ve) return L && In(A, V, !1), ls(m, A, $);
      Y = A.stateNode, Hi.current = A;
      var nt = Ve && typeof V.getDerivedStateFromError != "function" ? null : Y.render();
      return A.flags |= 1, m !== null && Ve ? (A.child = fs(A, m.child, null, $), A.child = fs(A, null, nt, $)) : ar(m, A, nt, $), A.memoizedState = Y.state, L && In(A, V, !0), A.child;
    }
    function gl(m) {
      var A = m.stateNode;
      A.pendingContext ? Be(m, A.pendingContext, A.pendingContext !== A.context) : A.context && Be(m, A.context, !1), QC(m, A.containerInfo);
    }
    function Dl(m, A, V, Y, L) {
      return JI(), PC(L), A.flags |= 256, ar(m, A, V, Y), A.child;
    }
    var yu = { dehydrated: null, treeContext: null, retryLane: 0 };
    function xc(m) {
      return { baseLanes: m, cachePool: null };
    }
    function tC(m, A, V) {
      var Y = A.pendingProps, L = Dr.current, $ = !1, Ve = (A.flags & 128) !== 0, nt;
      if ((nt = Ve) || (nt = m !== null && m.memoizedState === null ? !1 : (L & 2) !== 0), nt ? ($ = !0, A.flags &= -129) : (m === null || m.memoizedState !== null) && (L |= 1), ge(Dr, L & 1), m === null)
        return Ou(A), m = A.memoizedState, m !== null && (m = m.dehydrated, m !== null) ? (A.mode & 1 ? Oa(m) ? A.lanes = 8 : A.lanes = 1073741824 : A.lanes = 1, null) : (L = Y.children, m = Y.fallback, $ ? (Y = A.mode, $ = A.child, L = { mode: "hidden", children: L }, !(Y & 1) && $ !== null ? ($.childLanes = 0, $.pendingProps = L) : $ = Yc(L, Y, 0, null), m = rc(m, Y, V, null), $.return = A, m.return = A, $.sibling = m, A.child = $, A.child.memoizedState = xc(V), A.memoizedState = yu, m) : Qu(A, L));
      if (L = m.memoizedState, L !== null) {
        if (nt = L.dehydrated, nt !== null) {
          if (Ve)
            return A.flags & 256 ? (A.flags &= -257, tI(m, A, V, Error(l(422)))) : A.memoizedState !== null ? (A.child = m.child, A.flags |= 128, null) : ($ = Y.fallback, L = A.mode, Y = Yc({ mode: "visible", children: Y.children }, L, 0, null), $ = rc($, L, V, null), $.flags |= 2, Y.return = A, $.return = A, Y.sibling = $, A.child = Y, A.mode & 1 && fs(
              A,
              m.child,
              null,
              V
            ), A.child.memoizedState = xc(V), A.memoizedState = yu, $);
          if (!(A.mode & 1)) A = tI(m, A, V, null);
          else if (Oa(nt)) A = tI(m, A, V, Error(l(419)));
          else if (Y = (V & m.childLanes) !== 0, Pi || Y) {
            if (Y = po, Y !== null) {
              switch (V & -V) {
                case 4:
                  $ = 2;
                  break;
                case 16:
                  $ = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  $ = 32;
                  break;
                case 536870912:
                  $ = 268435456;
                  break;
                default:
                  $ = 0;
              }
              Y = $ & (Y.suspendedLanes | V) ? 0 : $, Y !== 0 && Y !== L.retryLane && (L.retryLane = Y, La(m, Y, -1));
            }
            bg(), A = tI(m, A, V, Error(l(421)));
          } else la(nt) ? (A.flags |= 128, A.child = m.child, A = Wl.bind(null, m), Le(nt, A), A = null) : (V = L.treeContext, Lt && (_a = me(nt), Kr = A, ca = !0, _l = null, Zc = !1, V !== null && (hu[ol++] = Du, hu[ol++] = gg, hu[ol++] = cg, Du = V.id, gg = V.overflow, cg = A)), A = Qu(A, A.pendingProps.children), A.flags |= 4096);
          return A;
        }
        return $ ? (Y = ss(m, A, Y.children, Y.fallback, V), $ = A.child, L = m.child.memoizedState, $.memoizedState = L === null ? xc(V) : { baseLanes: L.baseLanes | V, cachePool: null }, $.childLanes = m.childLanes & ~V, A.memoizedState = yu, Y) : (V = Wc(m, A, Y.children, V), A.memoizedState = null, V);
      }
      return $ ? (Y = ss(m, A, Y.children, Y.fallback, V), $ = A.child, L = m.child.memoizedState, $.memoizedState = L === null ? xc(V) : { baseLanes: L.baseLanes | V, cachePool: null }, $.childLanes = m.childLanes & ~V, A.memoizedState = yu, Y) : (V = Wc(m, A, Y.children, V), A.memoizedState = null, V);
    }
    function Qu(m, A) {
      return A = Yc({ mode: "visible", children: A }, m.mode, 0, null), A.return = m, m.child = A;
    }
    function Wc(m, A, V, Y) {
      var L = m.child;
      return m = L.sibling, V = Il(L, { mode: "visible", children: V }), !(A.mode & 1) && (V.lanes = Y), V.return = A, V.sibling = null, m !== null && (Y = A.deletions, Y === null ? (A.deletions = [m], A.flags |= 16) : Y.push(m)), A.child = V;
    }
    function ss(m, A, V, Y, L) {
      var $ = A.mode;
      m = m.child;
      var Ve = m.sibling, nt = { mode: "hidden", children: V };
      return !($ & 1) && A.child !== m ? (V = A.child, V.childLanes = 0, V.pendingProps = nt, A.deletions = null) : (V = Il(m, nt), V.subtreeFlags = m.subtreeFlags & 14680064), Ve !== null ? Y = Il(Ve, Y) : (Y = rc(Y, $, L, null), Y.flags |= 2), Y.return = A, V.return = A, V.sibling = Y, A.child = V, Y;
    }
    function tI(m, A, V, Y) {
      return Y !== null && PC(Y), fs(A, m.child, null, V), m = Qu(A, A.pendingProps.children), m.flags |= 2, A.memoizedState = null, m;
    }
    function mg(m, A, V) {
      m.lanes |= A;
      var Y = m.alternate;
      Y !== null && (Y.lanes |= A), rr(m.return, A, V);
    }
    function Us(m, A, V, Y, L) {
      var $ = m.memoizedState;
      $ === null ? m.memoizedState = { isBackwards: A, rendering: null, renderingStartTime: 0, last: Y, tail: V, tailMode: L } : ($.isBackwards = A, $.rendering = null, $.renderingStartTime = 0, $.last = Y, $.tail = V, $.tailMode = L);
    }
    function qo(m, A, V) {
      var Y = A.pendingProps, L = Y.revealOrder, $ = Y.tail;
      if (ar(m, A, Y.children, V), Y = Dr.current, Y & 2) Y = Y & 1 | 2, A.flags |= 128;
      else {
        if (m !== null && m.flags & 128) e: for (m = A.child; m !== null; ) {
          if (m.tag === 13) m.memoizedState !== null && mg(m, V, A);
          else if (m.tag === 19) mg(m, V, A);
          else if (m.child !== null) {
            m.child.return = m, m = m.child;
            continue;
          }
          if (m === A) break e;
          for (; m.sibling === null; ) {
            if (m.return === null || m.return === A) break e;
            m = m.return;
          }
          m.sibling.return = m.return, m = m.sibling;
        }
        Y &= 1;
      }
      if (ge(Dr, Y), !(A.mode & 1)) A.memoizedState = null;
      else switch (L) {
        case "forwards":
          for (V = A.child, L = null; V !== null; ) m = V.alternate, m !== null && Pd(m) === null && (L = V), V = V.sibling;
          V = L, V === null ? (L = A.child, A.child = null) : (L = V.sibling, V.sibling = null), Us(A, !1, L, V, $);
          break;
        case "backwards":
          for (V = null, L = A.child, A.child = null; L !== null; ) {
            if (m = L.alternate, m !== null && Pd(m) === null) {
              A.child = L;
              break;
            }
            m = L.sibling, L.sibling = V, V = L, L = m;
          }
          Us(A, !0, V, null, $);
          break;
        case "together":
          Us(A, !1, null, null, void 0);
          break;
        default:
          A.memoizedState = null;
      }
      return A.child;
    }
    function ls(m, A, V) {
      if (m !== null && (A.dependencies = m.dependencies), $u |= A.lanes, !(V & A.childLanes)) return null;
      if (m !== null && A.child !== m.child) throw Error(l(153));
      if (A.child !== null) {
        for (m = A.child, V = Il(m, m.pendingProps), A.child = V, V.return = A; m.sibling !== null; ) m = m.sibling, V = V.sibling = Il(m, m.pendingProps), V.return = A;
        V.sibling = null;
      }
      return A.child;
    }
    function ja(m, A, V) {
      switch (A.tag) {
        case 3:
          gl(A), JI();
          break;
        case 5:
          vp(A);
          break;
        case 1:
          Ai(A.type) && $t(A);
          break;
        case 4:
          QC(A, A.stateNode.containerInfo);
          break;
        case 10:
          ni(A, A.type._context, A.memoizedProps.value);
          break;
        case 13:
          var Y = A.memoizedState;
          if (Y !== null)
            return Y.dehydrated !== null ? (ge(Dr, Dr.current & 1), A.flags |= 128, null) : V & A.child.childLanes ? tC(m, A, V) : (ge(Dr, Dr.current & 1), m = ls(m, A, V), m !== null ? m.sibling : null);
          ge(Dr, Dr.current & 1);
          break;
        case 19:
          if (Y = (V & A.childLanes) !== 0, m.flags & 128) {
            if (Y) return qo(
              m,
              A,
              V
            );
            A.flags |= 128;
          }
          var L = A.memoizedState;
          if (L !== null && (L.rendering = null, L.tail = null, L.lastEffect = null), ge(Dr, Dr.current), Y) break;
          return null;
        case 22:
        case 23:
          return A.lanes = 0, jo(m, A, V);
      }
      return ls(m, A, V);
    }
    function bu(m, A) {
      switch (Uu(A), A.tag) {
        case 1:
          return Ai(A.type) && ve(), m = A.flags, m & 65536 ? (A.flags = m & -65537 | 128, A) : null;
        case 3:
          return Od(), Ln(et), Ln(We), _s(), m = A.flags, m & 65536 && !(m & 128) ? (A.flags = m & -65537 | 128, A) : null;
        case 5:
          return QI(A), null;
        case 13:
          if (Ln(Dr), m = A.memoizedState, m !== null && m.dehydrated !== null) {
            if (A.alternate === null) throw Error(l(340));
            JI();
          }
          return m = A.flags, m & 65536 ? (A.flags = m & -65537 | 128, A) : null;
        case 19:
          return Ln(Dr), null;
        case 4:
          return Od(), null;
        case 10:
          return Yi(A.type._context), null;
        case 22:
        case 23:
          return Rl(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Wi = !1, uo = !1, Gu = typeof WeakSet == "function" ? WeakSet : Set, Nn = null;
    function Do(m, A) {
      var V = m.ref;
      if (V !== null) if (typeof V == "function") try {
        V(null);
      } catch (Y) {
        $r(m, A, Y);
      }
      else V.current = null;
    }
    function ju(m, A, V) {
      try {
        V();
      } catch (Y) {
        $r(m, A, Y);
      }
    }
    var Ul = !1;
    function ef(m, A) {
      for (Ce(m.containerInfo), Nn = A; Nn !== null; ) if (m = Nn, A = m.child, (m.subtreeFlags & 1028) !== 0 && A !== null) A.return = m, Nn = A;
      else for (; Nn !== null; ) {
        m = Nn;
        try {
          var V = m.alternate;
          if (m.flags & 1024) switch (m.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (V !== null) {
                var Y = V.memoizedProps, L = V.memoizedState, $ = m.stateNode, Ve = $.getSnapshotBeforeUpdate(m.elementType === m.type ? Y : ie(m.type, Y), L);
                $.__reactInternalSnapshotBeforeUpdate = Ve;
              }
              break;
            case 3:
              Pn && Ht(m.stateNode.containerInfo);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(l(163));
          }
        } catch (nt) {
          $r(m, m.return, nt);
        }
        if (A = m.sibling, A !== null) {
          A.return = m.return, Nn = A;
          break;
        }
        Nn = m.return;
      }
      return V = Ul, Ul = !1, V;
    }
    function qu(m, A, V) {
      var Y = A.updateQueue;
      if (Y = Y !== null ? Y.lastEffect : null, Y !== null) {
        var L = Y = Y.next;
        do {
          if ((L.tag & m) === m) {
            var $ = L.destroy;
            L.destroy = void 0, $ !== void 0 && ju(A, V, $);
          }
          L = L.next;
        } while (L !== Y);
      }
    }
    function vs(m, A) {
      if (A = A.updateQueue, A = A !== null ? A.lastEffect : null, A !== null) {
        var V = A = A.next;
        do {
          if ((V.tag & m) === m) {
            var Y = V.create;
            V.destroy = Y();
          }
          V = V.next;
        } while (V !== A);
      }
    }
    function ys(m) {
      var A = m.ref;
      if (A !== null) {
        var V = m.stateNode;
        switch (m.tag) {
          case 5:
            m = Ke(V);
            break;
          default:
            m = V;
        }
        typeof A == "function" ? A(m) : A.current = m;
      }
    }
    function Ha(m, A, V) {
      if (is && typeof is.onCommitFiberUnmount == "function") try {
        is.onCommitFiberUnmount(Ja, A);
      } catch {
      }
      switch (A.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (m = A.updateQueue, m !== null && (m = m.lastEffect, m !== null)) {
            var Y = m = m.next;
            do {
              var L = Y, $ = L.destroy;
              L = L.tag, $ !== void 0 && (L & 2 || L & 4) && ju(A, V, $), Y = Y.next;
            } while (Y !== m);
          }
          break;
        case 1:
          if (Do(A, V), m = A.stateNode, typeof m.componentWillUnmount == "function") try {
            m.props = A.memoizedProps, m.state = A.memoizedState, m.componentWillUnmount();
          } catch (Ve) {
            $r(
              A,
              V,
              Ve
            );
          }
          break;
        case 5:
          Do(A, V);
          break;
        case 4:
          Pn ? Pl(m, A, V) : he && he && (A = A.stateNode.containerInfo, V = fi(A), Xi(A, V));
      }
    }
    function wl(m, A, V) {
      for (var Y = A; ; ) if (Ha(m, Y, V), Y.child === null || Pn && Y.tag === 4) {
        if (Y === A) break;
        for (; Y.sibling === null; ) {
          if (Y.return === null || Y.return === A) return;
          Y = Y.return;
        }
        Y.sibling.return = Y.return, Y = Y.sibling;
      } else Y.child.return = Y, Y = Y.child;
    }
    function eh(m) {
      var A = m.alternate;
      A !== null && (m.alternate = null, eh(A)), m.child = null, m.deletions = null, m.sibling = null, m.tag === 5 && (A = m.stateNode, A !== null && Rn(A)), m.stateNode = null, m.return = null, m.dependencies = null, m.memoizedProps = null, m.memoizedState = null, m.pendingProps = null, m.stateNode = null, m.updateQueue = null;
    }
    function Ol(m) {
      return m.tag === 5 || m.tag === 3 || m.tag === 4;
    }
    function ld(m) {
      e: for (; ; ) {
        for (; m.sibling === null; ) {
          if (m.return === null || Ol(m.return)) return null;
          m = m.return;
        }
        for (m.sibling.return = m.return, m = m.sibling; m.tag !== 5 && m.tag !== 6 && m.tag !== 18; ) {
          if (m.flags & 2 || m.child === null || m.tag === 4) continue e;
          m.child.return = m, m = m.child;
        }
        if (!(m.flags & 2)) return m.stateNode;
      }
    }
    function Ag(m) {
      if (Pn) {
        e: {
          for (var A = m.return; A !== null; ) {
            if (Ol(A)) break e;
            A = A.return;
          }
          throw Error(l(160));
        }
        var V = A;
        switch (V.tag) {
          case 5:
            A = V.stateNode, V.flags & 32 && (Ot(A), V.flags &= -33), V = ld(m), Vc(m, V, A);
            break;
          case 3:
          case 4:
            A = V.stateNode.containerInfo, V = ld(m), nI(m, V, A);
            break;
          default:
            throw Error(l(161));
        }
      }
    }
    function nI(m, A, V) {
      var Y = m.tag;
      if (Y === 5 || Y === 6) m = m.stateNode, A ? at(V, m, A) : qn(V, m);
      else if (Y !== 4 && (m = m.child, m !== null)) for (nI(m, A, V), m = m.sibling; m !== null; ) nI(m, A, V), m = m.sibling;
    }
    function Vc(m, A, V) {
      var Y = m.tag;
      if (Y === 5 || Y === 6) m = m.stateNode, A ? Ie(V, m, A) : gn(V, m);
      else if (Y !== 4 && (m = m.child, m !== null)) for (Vc(m, A, V), m = m.sibling; m !== null; ) Vc(m, A, V), m = m.sibling;
    }
    function Pl(m, A, V) {
      for (var Y = A, L = !1, $, Ve; ; ) {
        if (!L) {
          L = Y.return;
          e: for (; ; ) {
            if (L === null) throw Error(l(160));
            switch ($ = L.stateNode, L.tag) {
              case 5:
                Ve = !1;
                break e;
              case 3:
                $ = $.containerInfo, Ve = !0;
                break e;
              case 4:
                $ = $.containerInfo, Ve = !0;
                break e;
            }
            L = L.return;
          }
          L = !0;
        }
        if (Y.tag === 5 || Y.tag === 6) wl(m, Y, V), Ve ? Pe($, Y.stateNode) : ye($, Y.stateNode);
        else if (Y.tag === 18) Ve ? Oe($, Y.stateNode) : Ue($, Y.stateNode);
        else if (Y.tag === 4) {
          if (Y.child !== null) {
            $ = Y.stateNode.containerInfo, Ve = !0, Y.child.return = Y, Y = Y.child;
            continue;
          }
        } else if (Ha(m, Y, V), Y.child !== null) {
          Y.child.return = Y, Y = Y.child;
          continue;
        }
        if (Y === A) break;
        for (; Y.sibling === null; ) {
          if (Y.return === null || Y.return === A) return;
          Y = Y.return, Y.tag === 4 && (L = !1);
        }
        Y.sibling.return = Y.return, Y = Y.sibling;
      }
    }
    function Ka(m, A) {
      if (Pn) {
        switch (A.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            qu(3, A, A.return), vs(3, A), qu(5, A, A.return);
            return;
          case 1:
            return;
          case 5:
            var V = A.stateNode;
            if (V != null) {
              var Y = A.memoizedProps;
              m = m !== null ? m.memoizedProps : Y;
              var L = A.type, $ = A.updateQueue;
              A.updateQueue = null, $ !== null && Fe(V, $, L, m, Y, A);
            }
            return;
          case 6:
            if (A.stateNode === null) throw Error(l(162));
            V = A.memoizedProps, qt(A.stateNode, m !== null ? m.memoizedProps : V, V);
            return;
          case 3:
            Lt && m !== null && m.memoizedState.isDehydrated && we(A.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            co(A);
            return;
          case 19:
            co(A);
            return;
          case 17:
            return;
        }
        throw Error(l(163));
      }
      switch (A.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          qu(3, A, A.return), vs(3, A), qu(5, A, A.return);
          return;
        case 12:
          return;
        case 13:
          co(A);
          return;
        case 19:
          co(A);
          return;
        case 3:
          Lt && m !== null && m.memoizedState.isDehydrated && we(A.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e: if (he) {
        switch (A.tag) {
          case 1:
          case 5:
          case 6:
            break e;
          case 3:
          case 4:
            A = A.stateNode, Xi(A.containerInfo, A.pendingChildren);
            break e;
        }
        throw Error(l(163));
      }
    }
    function co(m) {
      var A = m.updateQueue;
      if (A !== null) {
        m.updateQueue = null;
        var V = m.stateNode;
        V === null && (V = m.stateNode = new Gu()), A.forEach(function(Y) {
          var L = rf.bind(null, m, Y);
          V.has(Y) || (V.add(Y), Y.then(L, L));
        });
      }
    }
    function lv(m, A) {
      for (Nn = A; Nn !== null; ) {
        A = Nn;
        var V = A.deletions;
        if (V !== null) for (var Y = 0; Y < V.length; Y++) {
          var L = V[Y];
          try {
            var $ = m;
            Pn ? Pl($, L, A) : wl($, L, A);
            var Ve = L.alternate;
            Ve !== null && (Ve.return = null), L.return = null;
          } catch (fn) {
            $r(L, A, fn);
          }
        }
        if (V = A.child, A.subtreeFlags & 12854 && V !== null) V.return = A, Nn = V;
        else for (; Nn !== null; ) {
          A = Nn;
          try {
            var nt = A.flags;
            if (nt & 32 && Pn && Ot(A.stateNode), nt & 512) {
              var kt = A.alternate;
              if (kt !== null) {
                var Wn = kt.ref;
                Wn !== null && (typeof Wn == "function" ? Wn(null) : Wn.current = null);
              }
            }
            if (nt & 8192) switch (A.tag) {
              case 13:
                if (A.memoizedState !== null) {
                  var Jn = A.alternate;
                  (Jn === null || Jn.memoizedState === null) && (ih = kr());
                }
                break;
              case 22:
                var mi = A.memoizedState !== null, wi = A.alternate, lr = wi !== null && wi.memoizedState !== null;
                if (V = A, Pn) {
                  e: if (Y = V, L = mi, $ = null, Pn) for (var $n = Y; ; ) {
                    if ($n.tag === 5) {
                      if ($ === null) {
                        $ = $n;
                        var to = $n.stateNode;
                        L ? Re(to) : _e($n.stateNode, $n.memoizedProps);
                      }
                    } else if ($n.tag === 6) {
                      if ($ === null) {
                        var gs = $n.stateNode;
                        L ? lt(gs) : ht(gs, $n.memoizedProps);
                      }
                    } else if (($n.tag !== 22 && $n.tag !== 23 || $n.memoizedState === null || $n === Y) && $n.child !== null) {
                      $n.child.return = $n, $n = $n.child;
                      continue;
                    }
                    if ($n === Y) break;
                    for (; $n.sibling === null; ) {
                      if ($n.return === null || $n.return === Y) break e;
                      $ === $n && ($ = null), $n = $n.return;
                    }
                    $ === $n && ($ = null), $n.sibling.return = $n.return, $n = $n.sibling;
                  }
                }
                if (mi && !lr && V.mode & 1) {
                  Nn = V;
                  for (var It = V.child; It !== null; ) {
                    for (V = Nn = It; Nn !== null; ) {
                      Y = Nn;
                      var st = Y.child;
                      switch (Y.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          qu(4, Y, Y.return);
                          break;
                        case 1:
                          Do(Y, Y.return);
                          var Zt = Y.stateNode;
                          if (typeof Zt.componentWillUnmount == "function") {
                            var Tn = Y.return;
                            try {
                              Zt.props = Y.memoizedProps, Zt.state = Y.memoizedState, Zt.componentWillUnmount();
                            } catch (fn) {
                              $r(
                                Y,
                                Tn,
                                fn
                              );
                            }
                          }
                          break;
                        case 5:
                          Do(Y, Y.return);
                          break;
                        case 22:
                          if (Y.memoizedState !== null) {
                            tf(V);
                            continue;
                          }
                      }
                      st !== null ? (st.return = Y, Nn = st) : tf(V);
                    }
                    It = It.sibling;
                  }
                }
            }
            switch (nt & 4102) {
              case 2:
                Ag(A), A.flags &= -3;
                break;
              case 6:
                Ag(A), A.flags &= -3, Ka(A.alternate, A);
                break;
              case 4096:
                A.flags &= -4097;
                break;
              case 4100:
                A.flags &= -4097, Ka(A.alternate, A);
                break;
              case 4:
                Ka(A.alternate, A);
            }
          } catch (fn) {
            $r(A, A.return, fn);
          }
          if (V = A.sibling, V !== null) {
            V.return = A.return, Nn = V;
            break;
          }
          Nn = A.return;
        }
      }
    }
    function ud(m, A, V) {
      Nn = m, cd(m);
    }
    function cd(m, A, V) {
      for (var Y = (m.mode & 1) !== 0; Nn !== null; ) {
        var L = Nn, $ = L.child;
        if (L.tag === 22 && Y) {
          var Ve = L.memoizedState !== null || Wi;
          if (!Ve) {
            var nt = L.alternate, kt = nt !== null && nt.memoizedState !== null || uo;
            nt = Wi;
            var Wn = uo;
            if (Wi = Ve, (uo = kt) && !Wn) for (Nn = L; Nn !== null; ) Ve = Nn, kt = Ve.child, Ve.tag === 22 && Ve.memoizedState !== null ? vg(L) : kt !== null ? (kt.return = Ve, Nn = kt) : vg(L);
            for (; $ !== null; ) Nn = $, cd($), $ = $.sibling;
            Nn = L, Wi = nt, uo = Wn;
          }
          Nc(m);
        } else L.subtreeFlags & 8772 && $ !== null ? ($.return = L, Nn = $) : Nc(m);
      }
    }
    function Nc(m) {
      for (; Nn !== null; ) {
        var A = Nn;
        if (A.flags & 8772) {
          var V = A.alternate;
          try {
            if (A.flags & 8772) switch (A.tag) {
              case 0:
              case 11:
              case 15:
                uo || vs(5, A);
                break;
              case 1:
                var Y = A.stateNode;
                if (A.flags & 4 && !uo) if (V === null) Y.componentDidMount();
                else {
                  var L = A.elementType === A.type ? V.memoizedProps : ie(A.type, V.memoizedProps);
                  Y.componentDidUpdate(L, V.memoizedState, Y.__reactInternalSnapshotBeforeUpdate);
                }
                var $ = A.updateQueue;
                $ !== null && UI(A, $, Y);
                break;
              case 3:
                var Ve = A.updateQueue;
                if (Ve !== null) {
                  if (V = null, A.child !== null) switch (A.child.tag) {
                    case 5:
                      V = Ke(A.child.stateNode);
                      break;
                    case 1:
                      V = A.child.stateNode;
                  }
                  UI(A, Ve, V);
                }
                break;
              case 5:
                var nt = A.stateNode;
                V === null && A.flags & 4 && An(nt, A.type, A.memoizedProps, A);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (Lt && A.memoizedState === null) {
                  var kt = A.alternate;
                  if (kt !== null) {
                    var Wn = kt.memoizedState;
                    if (Wn !== null) {
                      var Jn = Wn.dehydrated;
                      Jn !== null && Ee(Jn);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(l(163));
            }
            uo || A.flags & 512 && ys(A);
          } catch (mi) {
            $r(A, A.return, mi);
          }
        }
        if (A === m) {
          Nn = null;
          break;
        }
        if (V = A.sibling, V !== null) {
          V.return = A.return, Nn = V;
          break;
        }
        Nn = A.return;
      }
    }
    function tf(m) {
      for (; Nn !== null; ) {
        var A = Nn;
        if (A === m) {
          Nn = null;
          break;
        }
        var V = A.sibling;
        if (V !== null) {
          V.return = A.return, Nn = V;
          break;
        }
        Nn = A.return;
      }
    }
    function vg(m) {
      for (; Nn !== null; ) {
        var A = Nn;
        try {
          switch (A.tag) {
            case 0:
            case 11:
            case 15:
              var V = A.return;
              try {
                vs(4, A);
              } catch (kt) {
                $r(A, V, kt);
              }
              break;
            case 1:
              var Y = A.stateNode;
              if (typeof Y.componentDidMount == "function") {
                var L = A.return;
                try {
                  Y.componentDidMount();
                } catch (kt) {
                  $r(A, L, kt);
                }
              }
              var $ = A.return;
              try {
                ys(A);
              } catch (kt) {
                $r(A, $, kt);
              }
              break;
            case 5:
              var Ve = A.return;
              try {
                ys(A);
              } catch (kt) {
                $r(A, Ve, kt);
              }
          }
        } catch (kt) {
          $r(A, A.return, kt);
        }
        if (A === m) {
          Nn = null;
          break;
        }
        var nt = A.sibling;
        if (nt !== null) {
          nt.return = A.return, Nn = nt;
          break;
        }
        Nn = A.return;
      }
    }
    var th = 0, iI = 1, Ca = 2, Ra = 3, zn = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Ro = Symbol.for;
      th = Ro("selector.component"), iI = Ro("selector.has_pseudo_class"), Ca = Ro("selector.role"), Ra = Ro("selector.test_id"), zn = Ro("selector.text");
    }
    function Os(m) {
      var A = Wt(m);
      if (A != null) {
        if (typeof A.memoizedProps["data-testname"] != "string") throw Error(l(364));
        return A;
      }
      if (m = oe(m), m === null) throw Error(l(362));
      return m.stateNode.current;
    }
    function nh(m, A) {
      switch (A.$$typeof) {
        case th:
          if (m.type === A.value) return !0;
          break;
        case iI:
          e: {
            A = A.value, m = [m, 0];
            for (var V = 0; V < m.length; ) {
              var Y = m[V++], L = m[V++], $ = A[L];
              if (Y.tag !== 5 || !pt(Y)) {
                for (; $ != null && nh(Y, $); ) L++, $ = A[L];
                if (L === A.length) {
                  A = !0;
                  break e;
                } else for (Y = Y.child; Y !== null; ) m.push(Y, L), Y = Y.sibling;
              }
            }
            A = !1;
          }
          return A;
        case Ca:
          if (m.tag === 5 && zt(m.stateNode, A.value)) return !0;
          break;
        case zn:
          if ((m.tag === 5 || m.tag === 6) && (m = Ft(m), m !== null && 0 <= m.indexOf(A.value))) return !0;
          break;
        case Ra:
          if (m.tag === 5 && (m = m.memoizedProps["data-testname"], typeof m == "string" && m.toLowerCase() === A.value.toLowerCase())) return !0;
          break;
        default:
          throw Error(l(365));
      }
      return !1;
    }
    function gd(m) {
      switch (m.$$typeof) {
        case th:
          return "<" + (q(m.value) || "Unknown") + ">";
        case iI:
          return ":has(" + (gd(m) || "") + ")";
        case Ca:
          return '[role="' + m.value + '"]';
        case zn:
          return '"' + m.value + '"';
        case Ra:
          return '[data-testname="' + m.value + '"]';
        default:
          throw Error(l(365));
      }
    }
    function us(m, A) {
      var V = [];
      m = [m, 0];
      for (var Y = 0; Y < m.length; ) {
        var L = m[Y++], $ = m[Y++], Ve = A[$];
        if (L.tag !== 5 || !pt(L)) {
          for (; Ve != null && nh(L, Ve); ) $++, Ve = A[$];
          if ($ === A.length) V.push(L);
          else for (L = L.child; L !== null; ) m.push(L, $), L = L.sibling;
        }
      }
      return V;
    }
    function qa(m, A) {
      if (!Se) throw Error(l(363));
      m = Os(m), m = us(m, A), A = [], m = Array.from(m);
      for (var V = 0; V < m.length; ) {
        var Y = m[V++];
        if (Y.tag === 5) pt(Y) || A.push(Y.stateNode);
        else for (Y = Y.child; Y !== null; ) m.push(Y), Y = Y.sibling;
      }
      return A;
    }
    var On = Math.ceil, ra = u.ReactCurrentDispatcher, xo = u.ReactCurrentOwner, ya = u.ReactCurrentBatchConfig, ur = 0, po = null, qr = null, ha = 0, Ur = 0, rI = pr(0), mo = 0, nC = null, $u = 0, bs = 0, Jl = 0, Mc = null, Uo = null, ih = 0, dd = 1 / 0;
    function aI() {
      dd = kr() + 500;
    }
    var iC = !1, Xa = null, Ql = null, rC = !1, ec = null, oI = 0, sI = 0, tc = null, Kn = -1, Zi = 0;
    function vi() {
      return ur & 6 ? kr() : Kn !== -1 ? Kn : Kn = kr();
    }
    function Or(m) {
      return m.mode & 1 ? ur & 2 && ha !== 0 ? ha & -ha : kC.transition !== null ? (Zi === 0 && (m = En, En <<= 1, !(En & 4194240) && (En = 64), Zi = m), Zi) : (m = Hn, m !== 0 ? m : Gt()) : 1;
    }
    function La(m, A, V) {
      if (50 < sI) throw sI = 0, tc = null, Error(l(185));
      var Y = yg(m, A);
      return Y === null ? null : (Za(Y, A, V), (!(ur & 2) || Y !== po) && (Y === po && (!(ur & 2) && (bs |= A), mo === 4 && Wr(Y, ha)), Ps(Y, V), A === 1 && ur === 0 && !(m.mode & 1) && (aI(), du && al())), Y);
    }
    function yg(m, A) {
      m.lanes |= A;
      var V = m.alternate;
      for (V !== null && (V.lanes |= A), V = m, m = m.return; m !== null; ) m.childLanes |= A, V = m.alternate, V !== null && (V.childLanes |= A), V = m, m = m.return;
      return V.tag === 3 ? V.stateNode : null;
    }
    function Ps(m, A) {
      var V = m.callbackNode;
      qi(m, A);
      var Y = ti(m, m === po ? ha : 0);
      if (Y === 0) V !== null && Ko(V), m.callbackNode = null, m.callbackPriority = 0;
      else if (A = Y & -Y, m.callbackPriority !== A) {
        if (V != null && Ko(V), A === 1) m.tag === 0 ? Bc(yi.bind(null, m)) : ku(yi.bind(null, m)), nn ? Bn(function() {
          ur === 0 && al();
        }) : zo(ua, al), V = null;
        else {
          switch (Pa(Y)) {
            case 1:
              V = ua;
              break;
            case 4:
              V = Lo;
              break;
            case 16:
              V = ko;
              break;
            case 536870912:
              V = cu;
              break;
            default:
              V = ko;
          }
          V = Hc(V, Gs.bind(null, m));
        }
        m.callbackPriority = A, m.callbackNode = V;
      }
    }
    function Gs(m, A) {
      if (Kn = -1, Zi = 0, ur & 6) throw Error(l(327));
      var V = m.callbackNode;
      if (Bu() && m.callbackNode !== V) return null;
      var Y = ti(m, m === po ? ha : 0);
      if (Y === 0) return null;
      if (Y & 30 || Y & m.expiredLanes || A) A = Gg(m, Y);
      else {
        A = Y;
        var L = ur;
        ur |= 2;
        var $ = lI();
        (po !== m || ha !== A) && (aI(), $a(m, A));
        do
          try {
            nf();
            break;
          } catch (nt) {
            jl(m, nt);
          }
        while (!0);
        ui(), ra.current = $, ur = L, qr !== null ? A = 0 : (po = null, ha = 0, A = mo);
      }
      if (A !== 0) {
        if (A === 2 && (L = ci(m), L !== 0 && (Y = L, A = Js(m, L))), A === 1) throw V = nC, $a(m, 0), Wr(m, Y), Ps(m, kr()), V;
        if (A === 6) Wr(m, Y);
        else {
          if (L = m.current.alternate, !(Y & 30) && !dn(L) && (A = Gg(m, Y), A === 2 && ($ = ci(m), $ !== 0 && (Y = $, A = Js(m, $))), A === 1)) throw V = nC, $a(m, 0), Wr(m, Y), Ps(m, kr()), V;
          switch (m.finishedWork = L, m.finishedLanes = Y, A) {
            case 0:
            case 1:
              throw Error(l(345));
            case 2:
              eo(m, Uo);
              break;
            case 3:
              if (Wr(m, Y), (Y & 130023424) === Y && (A = ih + 500 - kr(), 10 < A)) {
                if (ti(m, 0) !== 0) break;
                if (L = m.suspendedLanes, (L & Y) !== Y) {
                  vi(), m.pingedLanes |= m.suspendedLanes & L;
                  break;
                }
                m.timeoutHandle = St(eo.bind(null, m, Uo), A);
                break;
              }
              eo(m, Uo);
              break;
            case 4:
              if (Wr(m, Y), (Y & 4194240) === Y) break;
              for (A = m.eventTimes, L = -1; 0 < Y; ) {
                var Ve = 31 - un(Y);
                $ = 1 << Ve, Ve = A[Ve], Ve > L && (L = Ve), Y &= ~$;
              }
              if (Y = L, Y = kr() - Y, Y = (120 > Y ? 120 : 480 > Y ? 480 : 1080 > Y ? 1080 : 1920 > Y ? 1920 : 3e3 > Y ? 3e3 : 4320 > Y ? 4320 : 1960 * On(Y / 1960)) - Y, 10 < Y) {
                m.timeoutHandle = St(eo.bind(null, m, Uo), Y);
                break;
              }
              eo(m, Uo);
              break;
            case 5:
              eo(m, Uo);
              break;
            default:
              throw Error(l(329));
          }
        }
      }
      return Ps(m, kr()), m.callbackNode === V ? Gs.bind(null, m) : null;
    }
    function Js(m, A) {
      var V = Mc;
      return m.current.memoizedState.isDehydrated && ($a(m, A).flags |= 256), m = Gg(m, A), m !== 2 && (A = Uo, Uo = V, A !== null && dl(A)), m;
    }
    function dl(m) {
      Uo === null ? Uo = m : Uo.push.apply(Uo, m);
    }
    function dn(m) {
      for (var A = m; ; ) {
        if (A.flags & 16384) {
          var V = A.updateQueue;
          if (V !== null && (V = V.stores, V !== null)) for (var Y = 0; Y < V.length; Y++) {
            var L = V[Y], $ = L.getSnapshot;
            L = L.value;
            try {
              if (!rs($(), L)) return !1;
            } catch {
              return !1;
            }
          }
        }
        if (V = A.child, A.subtreeFlags & 16384 && V !== null) V.return = A, A = V;
        else {
          if (A === m) break;
          for (; A.sibling === null; ) {
            if (A.return === null || A.return === m) return !0;
            A = A.return;
          }
          A.sibling.return = A.return, A = A.sibling;
        }
      }
      return !0;
    }
    function Wr(m, A) {
      for (A &= ~Jl, A &= ~bs, m.suspendedLanes |= A, m.pingedLanes &= ~A, m = m.expirationTimes; 0 < A; ) {
        var V = 31 - un(A), Y = 1 << V;
        m[V] = -1, A &= ~Y;
      }
    }
    function yi(m) {
      if (ur & 6) throw Error(l(327));
      Bu();
      var A = ti(m, 0);
      if (!(A & 1)) return Ps(m, kr()), null;
      var V = Gg(m, A);
      if (m.tag !== 0 && V === 2) {
        var Y = ci(m);
        Y !== 0 && (A = Y, V = Js(m, Y));
      }
      if (V === 1) throw V = nC, $a(m, 0), Wr(m, A), Ps(m, kr()), V;
      if (V === 6) throw Error(l(345));
      return m.finishedWork = m.current.alternate, m.finishedLanes = A, eo(m, Uo), Ps(m, kr()), null;
    }
    function nc(m) {
      ec !== null && ec.tag === 0 && !(ur & 6) && Bu();
      var A = ur;
      ur |= 1;
      var V = ya.transition, Y = Hn;
      try {
        if (ya.transition = null, Hn = 1, m) return m();
      } finally {
        Hn = Y, ya.transition = V, ur = A, !(ur & 6) && al();
      }
    }
    function Rl() {
      Ur = rI.current, Ln(rI);
    }
    function $a(m, A) {
      m.finishedWork = null, m.finishedLanes = 0;
      var V = m.timeoutHandle;
      if (V !== hn && (m.timeoutHandle = hn, ln(V)), qr !== null) for (V = qr.return; V !== null; ) {
        var Y = V;
        switch (Uu(Y), Y.tag) {
          case 1:
            Y = Y.type.childContextTypes, Y != null && ve();
            break;
          case 3:
            Od(), Ln(et), Ln(We), _s();
            break;
          case 5:
            QI(Y);
            break;
          case 4:
            Od();
            break;
          case 13:
            Ln(Dr);
            break;
          case 19:
            Ln(Dr);
            break;
          case 10:
            Yi(Y.type._context);
            break;
          case 22:
          case 23:
            Rl();
        }
        V = V.return;
      }
      if (po = m, qr = m = Il(m.current, null), ha = Ur = A, mo = 0, nC = null, Jl = bs = $u = 0, Uo = Mc = null, vr !== null) {
        for (A = 0; A < vr.length; A++) if (V = vr[A], Y = V.interleaved, Y !== null) {
          V.interleaved = null;
          var L = Y.next, $ = V.pending;
          if ($ !== null) {
            var Ve = $.next;
            $.next = L, Y.next = Ve;
          }
          V.pending = Y;
        }
        vr = null;
      }
      return m;
    }
    function jl(m, A) {
      do {
        var V = qr;
        try {
          if (ui(), fu.current = ad, zs) {
            for (var Y = za.memoizedState; Y !== null; ) {
              var L = Y.queue;
              L !== null && (L.pending = null), Y = Y.next;
            }
            zs = !1;
          }
          if (ao = 0, jr = Qr = za = null, Ll = !1, ps = 0, xo.current = null, V === null || V.return === null) {
            mo = 1, nC = A, qr = null;
            break;
          }
          e: {
            var $ = m, Ve = V.return, nt = V, kt = A;
            if (A = ha, nt.flags |= 32768, kt !== null && typeof kt == "object" && typeof kt.then == "function") {
              var Wn = kt, Jn = nt, mi = Jn.tag;
              if (!(Jn.mode & 1) && (mi === 0 || mi === 11 || mi === 15)) {
                var wi = Jn.alternate;
                wi ? (Jn.updateQueue = wi.updateQueue, Jn.memoizedState = wi.memoizedState, Jn.lanes = wi.lanes) : (Jn.updateQueue = null, Jn.memoizedState = null);
              }
              var lr = fg(Ve);
              if (lr !== null) {
                lr.flags &= -257, cl(lr, Ve, nt, $, A), lr.mode & 1 && Ls($, Wn, A), A = lr, kt = Wn;
                var $n = A.updateQueue;
                if ($n === null) {
                  var to = /* @__PURE__ */ new Set();
                  to.add(kt), A.updateQueue = to;
                } else $n.add(kt);
                break e;
              } else {
                if (!(A & 1)) {
                  Ls($, Wn, A), bg();
                  break e;
                }
                kt = Error(l(426));
              }
            } else if (ca && nt.mode & 1) {
              var gs = fg(Ve);
              if (gs !== null) {
                !(gs.flags & 65536) && (gs.flags |= 256), cl(gs, Ve, nt, $, A), PC(kt);
                break e;
              }
            }
            $ = kt, mo !== 4 && (mo = 2), Mc === null ? Mc = [$] : Mc.push($), kt = hg(kt, nt), nt = Ve;
            do {
              switch (nt.tag) {
                case 3:
                  nt.flags |= 65536, A &= -A, nt.lanes |= A;
                  var It = $I(nt, kt, A);
                  DI(nt, It);
                  break e;
                case 1:
                  $ = kt;
                  var st = nt.type, Zt = nt.stateNode;
                  if (!(nt.flags & 128) && (typeof st.getDerivedStateFromError == "function" || Zt !== null && typeof Zt.componentDidCatch == "function" && (Ql === null || !Ql.has(Zt)))) {
                    nt.flags |= 65536, A &= -A, nt.lanes |= A;
                    var Tn = eC(nt, $, A);
                    DI(nt, Tn);
                    break e;
                  }
              }
              nt = nt.return;
            } while (nt !== null);
          }
          oC(V);
        } catch (fn) {
          A = fn, qr === V && V !== null && (qr = V = V.return);
          continue;
        }
        break;
      } while (!0);
    }
    function lI() {
      var m = ra.current;
      return ra.current = ad, m === null ? ad : m;
    }
    function bg() {
      (mo === 0 || mo === 3 || mo === 2) && (mo = 4), po === null || !($u & 268435455) && !(bs & 268435455) || Wr(po, ha);
    }
    function Gg(m, A) {
      var V = ur;
      ur |= 2;
      var Y = lI();
      po === m && ha === A || $a(m, A);
      do
        try {
          uI();
          break;
        } catch (L) {
          jl(m, L);
        }
      while (!0);
      if (ui(), ur = V, ra.current = Y, qr !== null) throw Error(l(261));
      return po = null, ha = 0, mo;
    }
    function uI() {
      for (; qr !== null; ) aC(qr);
    }
    function nf() {
      for (; qr !== null && !Xr(); ) aC(qr);
    }
    function aC(m) {
      var A = ic(m.alternate, m, Ur);
      m.memoizedProps = m.pendingProps, A === null ? oC(m) : qr = A, xo.current = null;
    }
    function oC(m) {
      var A = m;
      do {
        var V = A.alternate;
        if (m = A.return, A.flags & 32768) {
          if (V = bu(V, A), V !== null) {
            V.flags &= 32767, qr = V;
            return;
          }
          if (m !== null) m.flags |= 32768, m.subtreeFlags = 0, m.deletions = null;
          else {
            mo = 6, qr = null;
            return;
          }
        } else if (V = ks(V, A, Ur), V !== null) {
          qr = V;
          return;
        }
        if (A = A.sibling, A !== null) {
          qr = A;
          return;
        }
        qr = A = m;
      } while (A !== null);
      mo === 0 && (mo = 5);
    }
    function eo(m, A) {
      var V = Hn, Y = ya.transition;
      try {
        ya.transition = null, Hn = 1, Id(m, A, V);
      } finally {
        ya.transition = Y, Hn = V;
      }
      return null;
    }
    function Id(m, A, V) {
      do
        Bu();
      while (ec !== null);
      if (ur & 6) throw Error(l(327));
      var Y = m.finishedWork, L = m.finishedLanes;
      if (Y === null) return null;
      if (m.finishedWork = null, m.finishedLanes = 0, Y === m.current) throw Error(l(177));
      m.callbackNode = null, m.callbackPriority = 0;
      var $ = Y.lanes | Y.childLanes;
      if (gi(m, $), m === po && (qr = po = null, ha = 0), !(Y.subtreeFlags & 2064) && !(Y.flags & 2064) || rC || (rC = !0, Hc(ko, function() {
        return Bu(), null;
      })), $ = (Y.flags & 15990) !== 0, Y.subtreeFlags & 15990 || $) {
        $ = ya.transition, ya.transition = null;
        var Ve = Hn;
        Hn = 1;
        var nt = ur;
        ur |= 4, xo.current = null, ef(m, Y), lv(m, Y), be(m.containerInfo), m.current = Y, ud(Y), ia(), ur = nt, Hn = Ve, ya.transition = $;
      } else m.current = Y;
      if (rC && (rC = !1, ec = m, oI = L), $ = m.pendingLanes, $ === 0 && (Ql = null), Qg(Y.stateNode), Ps(m, kr()), A !== null) for (V = m.onRecoverableError, Y = 0; Y < A.length; Y++) V(A[Y]);
      if (iC) throw iC = !1, m = Xa, Xa = null, m;
      return oI & 1 && m.tag !== 0 && Bu(), $ = m.pendingLanes, $ & 1 ? m === tc ? sI++ : (sI = 0, tc = m) : sI = 0, al(), null;
    }
    function Bu() {
      if (ec !== null) {
        var m = Pa(oI), A = ya.transition, V = Hn;
        try {
          if (ya.transition = null, Hn = 16 > m ? 16 : m, ec === null) var Y = !1;
          else {
            if (m = ec, ec = null, oI = 0, ur & 6) throw Error(l(331));
            var L = ur;
            for (ur |= 4, Nn = m.current; Nn !== null; ) {
              var $ = Nn, Ve = $.child;
              if (Nn.flags & 16) {
                var nt = $.deletions;
                if (nt !== null) {
                  for (var kt = 0; kt < nt.length; kt++) {
                    var Wn = nt[kt];
                    for (Nn = Wn; Nn !== null; ) {
                      var Jn = Nn;
                      switch (Jn.tag) {
                        case 0:
                        case 11:
                        case 15:
                          qu(8, Jn, $);
                      }
                      var mi = Jn.child;
                      if (mi !== null) mi.return = Jn, Nn = mi;
                      else for (; Nn !== null; ) {
                        Jn = Nn;
                        var wi = Jn.sibling, lr = Jn.return;
                        if (eh(Jn), Jn === Wn) {
                          Nn = null;
                          break;
                        }
                        if (wi !== null) {
                          wi.return = lr, Nn = wi;
                          break;
                        }
                        Nn = lr;
                      }
                    }
                  }
                  var $n = $.alternate;
                  if ($n !== null) {
                    var to = $n.child;
                    if (to !== null) {
                      $n.child = null;
                      do {
                        var gs = to.sibling;
                        to.sibling = null, to = gs;
                      } while (to !== null);
                    }
                  }
                  Nn = $;
                }
              }
              if ($.subtreeFlags & 2064 && Ve !== null) Ve.return = $, Nn = Ve;
              else e: for (; Nn !== null; ) {
                if ($ = Nn, $.flags & 2048) switch ($.tag) {
                  case 0:
                  case 11:
                  case 15:
                    qu(9, $, $.return);
                }
                var It = $.sibling;
                if (It !== null) {
                  It.return = $.return, Nn = It;
                  break e;
                }
                Nn = $.return;
              }
            }
            var st = m.current;
            for (Nn = st; Nn !== null; ) {
              Ve = Nn;
              var Zt = Ve.child;
              if (Ve.subtreeFlags & 2064 && Zt !== null) Zt.return = Ve, Nn = Zt;
              else e: for (Ve = st; Nn !== null; ) {
                if (nt = Nn, nt.flags & 2048) try {
                  switch (nt.tag) {
                    case 0:
                    case 11:
                    case 15:
                      vs(9, nt);
                  }
                } catch (fn) {
                  $r(nt, nt.return, fn);
                }
                if (nt === Ve) {
                  Nn = null;
                  break e;
                }
                var Tn = nt.sibling;
                if (Tn !== null) {
                  Tn.return = nt.return, Nn = Tn;
                  break e;
                }
                Nn = nt.return;
              }
            }
            if (ur = L, al(), is && typeof is.onPostCommitFiberRoot == "function") try {
              is.onPostCommitFiberRoot(Ja, m);
            } catch {
            }
            Y = !0;
          }
          return Y;
        } finally {
          Hn = V, ya.transition = A;
        }
      }
      return !1;
    }
    function cI(m, A, V) {
      A = hg(V, A), A = $I(m, A, 1), Tl(m, A), A = vi(), m = yg(m, 1), m !== null && (Za(m, 1, A), Ps(m, A));
    }
    function $r(m, A, V) {
      if (m.tag === 3) cI(m, m, V);
      else for (; A !== null; ) {
        if (A.tag === 3) {
          cI(A, m, V);
          break;
        } else if (A.tag === 1) {
          var Y = A.stateNode;
          if (typeof A.type.getDerivedStateFromError == "function" || typeof Y.componentDidCatch == "function" && (Ql === null || !Ql.has(Y))) {
            m = hg(V, m), m = eC(A, m, 1), Tl(A, m), m = vi(), A = yg(A, 1), A !== null && (Za(A, 1, m), Ps(A, m));
            break;
          }
        }
        A = A.return;
      }
    }
    function Ao(m, A, V) {
      var Y = m.pingCache;
      Y !== null && Y.delete(A), A = vi(), m.pingedLanes |= m.suspendedLanes & V, po === m && (ha & V) === V && (mo === 4 || mo === 3 && (ha & 130023424) === ha && 500 > kr() - ih ? $a(m, 0) : Jl |= V), Ps(m, A);
    }
    function xl(m, A) {
      A === 0 && (m.mode & 1 ? (A = cn, cn <<= 1, !(cn & 130023424) && (cn = 4194304)) : A = 1);
      var V = vi();
      m = yg(m, A), m !== null && (Za(m, A, V), Ps(m, V));
    }
    function Wl(m) {
      var A = m.memoizedState, V = 0;
      A !== null && (V = A.retryLane), xl(m, V);
    }
    function rf(m, A) {
      var V = 0;
      switch (m.tag) {
        case 13:
          var Y = m.stateNode, L = m.memoizedState;
          L !== null && (V = L.retryLane);
          break;
        case 19:
          Y = m.stateNode;
          break;
        default:
          throw Error(l(314));
      }
      Y !== null && Y.delete(A), xl(m, V);
    }
    var ic;
    ic = function(m, A, V) {
      if (m !== null) if (m.memoizedProps !== A.pendingProps || et.current) Pi = !0;
      else {
        if (!(m.lanes & V) && !(A.flags & 128)) return Pi = !1, ja(m, A, V);
        Pi = !!(m.flags & 131072);
      }
      else Pi = !1, ca && A.flags & 1048576 && mp(A, Cu, A.index);
      switch (A.lanes = 0, A.tag) {
        case 2:
          var Y = A.type;
          m !== null && (m.alternate = null, A.alternate = null, A.flags |= 2), m = A.pendingProps;
          var L = bn(A, We.current);
          Yr(A, V), L = ll(null, A, Y, m, L, V);
          var $ = Pu();
          return A.flags |= 1, typeof L == "object" && L !== null && typeof L.render == "function" && L.$$typeof === void 0 ? (A.tag = 1, A.memoizedState = null, A.updateQueue = null, Ai(Y) ? ($ = !0, $t(A)) : $ = !1, A.memoizedState = L.state !== null && L.state !== void 0 ? L.state : null, Ia(A), L.updater = UC, A.stateNode = L, L._reactInternals = A, Dh(A, Y, m, V), A = Qa(null, A, Y, !0, $, V)) : (A.tag = 0, ca && $ && Es(A), ar(null, A, L, V), A = A.child), A;
        case 16:
          Y = A.elementType;
          e: {
            switch (m !== null && (m.alternate = null, A.alternate = null, A.flags |= 2), m = A.pendingProps, L = Y._init, Y = L(Y._payload), A.type = Y, L = A.tag = gI(Y), m = ie(Y, m), L) {
              case 0:
                A = As(null, A, Y, m, V);
                break e;
              case 1:
                A = Zl(
                  null,
                  A,
                  Y,
                  m,
                  V
                );
                break e;
              case 11:
                A = Ci(null, A, Y, m, V);
                break e;
              case 14:
                A = Gr(null, A, Y, ie(Y.type, m), V);
                break e;
            }
            throw Error(l(306, Y, ""));
          }
          return A;
        case 0:
          return Y = A.type, L = A.pendingProps, L = A.elementType === Y ? L : ie(Y, L), As(m, A, Y, L, V);
        case 1:
          return Y = A.type, L = A.pendingProps, L = A.elementType === Y ? L : ie(Y, L), Zl(m, A, Y, L, V);
        case 3:
          e: {
            if (gl(A), m === null) throw Error(l(387));
            Y = A.pendingProps, $ = A.memoizedState, L = $.element, Fr(m, A), Iu(A, Y, null, V);
            var Ve = A.memoizedState;
            if (Y = Ve.element, Lt && $.isDehydrated) if ($ = {
              element: Y,
              isDehydrated: !1,
              cache: Ve.cache,
              transitions: Ve.transitions
            }, A.updateQueue.baseState = $, A.memoizedState = $, A.flags & 256) {
              L = Error(l(423)), A = Dl(m, A, Y, V, L);
              break e;
            } else if (Y !== L) {
              L = Error(l(424)), A = Dl(m, A, Y, V, L);
              break e;
            } else for (Lt && (_a = Pt(A.stateNode.containerInfo), Kr = A, ca = !0, _l = null, Zc = !1), V = Ph(A, null, Y, V), A.child = V; V; ) V.flags = V.flags & -3 | 4096, V = V.sibling;
            else {
              if (JI(), Y === L) {
                A = ls(m, A, V);
                break e;
              }
              ar(m, A, Y, V);
            }
            A = A.child;
          }
          return A;
        case 5:
          return vp(A), m === null && Ou(A), Y = A.type, L = A.pendingProps, $ = m !== null ? m.memoizedProps : null, Ve = L.children, ot(Y, L) ? Ve = null : $ !== null && ot(Y, $) && (A.flags |= 32), Qi(m, A), ar(m, A, Ve, V), A.child;
        case 6:
          return m === null && Ou(A), null;
        case 13:
          return tC(m, A, V);
        case 4:
          return QC(A, A.stateNode.containerInfo), Y = A.pendingProps, m === null ? A.child = fs(A, null, Y, V) : ar(m, A, Y, V), A.child;
        case 11:
          return Y = A.type, L = A.pendingProps, L = A.elementType === Y ? L : ie(Y, L), Ci(m, A, Y, L, V);
        case 7:
          return ar(m, A, A.pendingProps, V), A.child;
        case 8:
          return ar(m, A, A.pendingProps.children, V), A.child;
        case 12:
          return ar(m, A, A.pendingProps.children, V), A.child;
        case 10:
          e: {
            if (Y = A.type._context, L = A.pendingProps, $ = A.memoizedProps, Ve = L.value, ni(A, Y, Ve), $ !== null) if (rs($.value, Ve)) {
              if ($.children === L.children && !et.current) {
                A = ls(m, A, V);
                break e;
              }
            } else for ($ = A.child, $ !== null && ($.return = A); $ !== null; ) {
              var nt = $.dependencies;
              if (nt !== null) {
                Ve = $.child;
                for (var kt = nt.firstContext; kt !== null; ) {
                  if (kt.context === Y) {
                    if ($.tag === 1) {
                      kt = Qo(-1, V & -V), kt.tag = 2;
                      var Wn = $.updateQueue;
                      if (Wn !== null) {
                        Wn = Wn.shared;
                        var Jn = Wn.pending;
                        Jn === null ? kt.next = kt : (kt.next = Jn.next, Jn.next = kt), Wn.pending = kt;
                      }
                    }
                    $.lanes |= V, kt = $.alternate, kt !== null && (kt.lanes |= V), rr($.return, V, A), nt.lanes |= V;
                    break;
                  }
                  kt = kt.next;
                }
              } else if ($.tag === 10) Ve = $.type === A.type ? null : $.child;
              else if ($.tag === 18) {
                if (Ve = $.return, Ve === null) throw Error(l(341));
                Ve.lanes |= V, nt = Ve.alternate, nt !== null && (nt.lanes |= V), rr(Ve, V, A), Ve = $.sibling;
              } else Ve = $.child;
              if (Ve !== null) Ve.return = $;
              else for (Ve = $; Ve !== null; ) {
                if (Ve === A) {
                  Ve = null;
                  break;
                }
                if ($ = Ve.sibling, $ !== null) {
                  $.return = Ve.return, Ve = $;
                  break;
                }
                Ve = Ve.return;
              }
              $ = Ve;
            }
            ar(m, A, L.children, V), A = A.child;
          }
          return A;
        case 9:
          return L = A.type, Y = A.pendingProps.children, Yr(A, V), L = hr(L), Y = Y(L), A.flags |= 1, ar(m, A, Y, V), A.child;
        case 14:
          return Y = A.type, L = ie(Y, A.pendingProps), L = ie(Y.type, L), Gr(m, A, Y, L, V);
        case 15:
          return Ds(m, A, A.type, A.pendingProps, V);
        case 17:
          return Y = A.type, L = A.pendingProps, L = A.elementType === Y ? L : ie(Y, L), m !== null && (m.alternate = null, A.alternate = null, A.flags |= 2), A.tag = 1, Ai(Y) ? (m = !0, $t(A)) : m = !1, Yr(A, V), pp(A, Y, L), Dh(A, Y, L, V), Qa(null, A, Y, !0, m, V);
        case 19:
          return qo(m, A, V);
        case 22:
          return jo(m, A, V);
      }
      throw Error(l(156, A.tag));
    };
    function Hc(m, A) {
      return zo(m, A);
    }
    function Bg(m, A, V, Y) {
      this.tag = m, this.key = V, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = A, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = Y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function vo(m, A, V, Y) {
      return new Bg(m, A, V, Y);
    }
    function Xc(m) {
      return m = m.prototype, !(!m || !m.isReactComponent);
    }
    function gI(m) {
      if (typeof m == "function") return Xc(m) ? 1 : 0;
      if (m != null) {
        if (m = m.$$typeof, m === W) return 11;
        if (m === T) return 14;
      }
      return 2;
    }
    function Il(m, A) {
      var V = m.alternate;
      return V === null ? (V = vo(m.tag, A, m.key, m.mode), V.elementType = m.elementType, V.type = m.type, V.stateNode = m.stateNode, V.alternate = m, m.alternate = V) : (V.pendingProps = A, V.type = m.type, V.flags = 0, V.subtreeFlags = 0, V.deletions = null), V.flags = m.flags & 14680064, V.childLanes = m.childLanes, V.lanes = m.lanes, V.child = m.child, V.memoizedProps = m.memoizedProps, V.memoizedState = m.memoizedState, V.updateQueue = m.updateQueue, A = m.dependencies, V.dependencies = A === null ? null : { lanes: A.lanes, firstContext: A.firstContext }, V.sibling = m.sibling, V.index = m.index, V.ref = m.ref, V;
    }
    function Su(m, A, V, Y, L, $) {
      var Ve = 2;
      if (Y = m, typeof m == "function") Xc(m) && (Ve = 1);
      else if (typeof m == "string") Ve = 5;
      else e: switch (m) {
        case h:
          return rc(V.children, L, $, A);
        case v:
          Ve = 8, L |= 8;
          break;
        case b:
          return m = vo(12, V, A, L | 2), m.elementType = b, m.lanes = $, m;
        case x:
          return m = vo(13, V, A, L), m.elementType = x, m.lanes = $, m;
        case M:
          return m = vo(19, V, A, L), m.elementType = M, m.lanes = $, m;
        case _:
          return Yc(V, L, $, A);
        default:
          if (typeof m == "object" && m !== null) switch (m.$$typeof) {
            case S:
              Ve = 10;
              break e;
            case R:
              Ve = 9;
              break e;
            case W:
              Ve = 11;
              break e;
            case T:
              Ve = 14;
              break e;
            case E:
              Ve = 16, Y = null;
              break e;
          }
          throw Error(l(130, m == null ? m : typeof m, ""));
      }
      return A = vo(Ve, V, A, L), A.elementType = m, A.type = Y, A.lanes = $, A;
    }
    function rc(m, A, V, Y) {
      return m = vo(7, m, Y, A), m.lanes = V, m;
    }
    function Yc(m, A, V, Y) {
      return m = vo(22, m, Y, A), m.elementType = _, m.lanes = V, m.stateNode = {}, m;
    }
    function sC(m, A, V) {
      return m = vo(6, m, null, A), m.lanes = V, m;
    }
    function Sg(m, A, V) {
      return A = vo(4, m.children !== null ? m.children : [], m.key, A), A.lanes = V, A.stateNode = { containerInfo: m.containerInfo, pendingChildren: null, implementation: m.implementation }, A;
    }
    function Zu(m, A, V, Y, L) {
      this.tag = A, this.containerInfo = m, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = hn, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Hr(0), this.expirationTimes = Hr(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Hr(0), this.identifierPrefix = Y, this.onRecoverableError = L, Lt && (this.mutableSourceEagerHydrationData = null);
    }
    function Vl(m, A, V, Y, L, $, Ve, nt, kt) {
      return m = new Zu(m, A, V, nt, kt), A === 1 ? (A = 1, $ === !0 && (A |= 8)) : A = 0, $ = vo(3, null, null, A), m.current = $, $.stateNode = m, $.memoizedState = { element: Y, isDehydrated: V, cache: null, transitions: null }, Ia($), m;
    }
    function _m(m) {
      if (!m) return ue;
      m = m._reactInternals;
      e: {
        if (O(m) !== m || m.tag !== 1) throw Error(l(170));
        var A = m;
        do {
          switch (A.tag) {
            case 3:
              A = A.stateNode.context;
              break e;
            case 1:
              if (Ai(A.type)) {
                A = A.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          A = A.return;
        } while (A !== null);
        throw Error(l(171));
      }
      if (m.tag === 1) {
        var V = m.type;
        if (Ai(V)) return mt(m, V, A);
      }
      return A;
    }
    function Br(m) {
      var A = m._reactInternals;
      if (A === void 0)
        throw typeof m.render == "function" ? Error(l(188)) : (m = Object.keys(m).join(","), Error(l(268, m)));
      return m = fe(A), m === null ? null : m.stateNode;
    }
    function cs(m, A) {
      if (m = m.memoizedState, m !== null && m.dehydrated !== null) {
        var V = m.retryLane;
        m.retryLane = V !== 0 && V < A ? V : A;
      }
    }
    function wu(m, A) {
      cs(m, A), (m = m.alternate) && cs(m, A);
    }
    function ac(m) {
      return m = fe(m), m === null ? null : m.stateNode;
    }
    function Fc() {
      return null;
    }
    return t.attemptContinuousHydration = function(m) {
      if (m.tag === 13) {
        var A = vi();
        La(m, 134217728, A), wu(m, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(m) {
      if (m.tag === 13) {
        var A = vi(), V = Or(m);
        La(m, V, A), wu(m, V);
      }
    }, t.attemptSynchronousHydration = function(m) {
      switch (m.tag) {
        case 3:
          var A = m.stateNode;
          if (A.current.memoizedState.isDehydrated) {
            var V = kn(A.pendingLanes);
            V !== 0 && (yr(A, V | 1), Ps(A, kr()), !(ur & 6) && (aI(), al()));
          }
          break;
        case 13:
          var Y = vi();
          nc(function() {
            return La(m, 1, Y);
          }), wu(m, 1);
      }
    }, t.batchedUpdates = function(m, A) {
      var V = ur;
      ur |= 1;
      try {
        return m(A);
      } finally {
        ur = V, ur === 0 && (aI(), du && al());
      }
    }, t.createComponentSelector = function(m) {
      return { $$typeof: th, value: m };
    }, t.createContainer = function(m, A, V, Y, L, $, Ve) {
      return Vl(m, A, !1, null, V, Y, L, $, Ve);
    }, t.createHasPseudoClassSelector = function(m) {
      return { $$typeof: iI, value: m };
    }, t.createHydrationContainer = function(m, A, V, Y, L, $, Ve, nt, kt) {
      return m = Vl(V, Y, !0, m, L, $, Ve, nt, kt), m.context = _m(null), V = m.current, Y = vi(), L = Or(V), $ = Qo(Y, L), $.callback = A ?? null, Tl(V, $), m.current.lanes = L, Za(m, L, Y), Ps(m, Y), m;
    }, t.createPortal = function(m, A, V) {
      var Y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: f, key: Y == null ? null : "" + Y, children: m, containerInfo: A, implementation: V };
    }, t.createRoleSelector = function(m) {
      return { $$typeof: Ca, value: m };
    }, t.createTestNameSelector = function(m) {
      return { $$typeof: Ra, value: m };
    }, t.createTextSelector = function(m) {
      return { $$typeof: zn, value: m };
    }, t.deferredUpdates = function(m) {
      var A = Hn, V = ya.transition;
      try {
        return ya.transition = null, Hn = 16, m();
      } finally {
        Hn = A, ya.transition = V;
      }
    }, t.discreteUpdates = function(m, A, V, Y, L) {
      var $ = Hn, Ve = ya.transition;
      try {
        return ya.transition = null, Hn = 1, m(A, V, Y, L);
      } finally {
        Hn = $, ya.transition = Ve, ur === 0 && aI();
      }
    }, t.findAllNodes = qa, t.findBoundingRects = function(m, A) {
      if (!Se) throw Error(l(363));
      A = qa(m, A), m = [];
      for (var V = 0; V < A.length; V++) m.push(ct(A[V]));
      for (A = m.length - 1; 0 < A; A--) {
        V = m[A];
        for (var Y = V.x, L = Y + V.width, $ = V.y, Ve = $ + V.height, nt = A - 1; 0 <= nt; nt--) if (A !== nt) {
          var kt = m[nt], Wn = kt.x, Jn = Wn + kt.width, mi = kt.y, wi = mi + kt.height;
          if (Y >= Wn && $ >= mi && L <= Jn && Ve <= wi) {
            m.splice(A, 1);
            break;
          } else if (Y !== Wn || V.width !== kt.width || wi < $ || mi > Ve) {
            if (!($ !== mi || V.height !== kt.height || Jn < Y || Wn > L)) {
              Wn > Y && (kt.width += Wn - Y, kt.x = Y), Jn < L && (kt.width = L - Wn), m.splice(A, 1);
              break;
            }
          } else {
            mi > $ && (kt.height += mi - $, kt.y = $), wi < Ve && (kt.height = Ve - mi), m.splice(A, 1);
            break;
          }
        }
      }
      return m;
    }, t.findHostInstance = Br, t.findHostInstanceWithNoPortals = function(m) {
      return m = te(m), m = m !== null ? Ae(m) : null, m === null ? null : m.stateNode;
    }, t.findHostInstanceWithWarning = function(m) {
      return Br(m);
    }, t.flushControlled = function(m) {
      var A = ur;
      ur |= 1;
      var V = ya.transition, Y = Hn;
      try {
        ya.transition = null, Hn = 1, m();
      } finally {
        Hn = Y, ya.transition = V, ur = A, ur === 0 && (aI(), al());
      }
    }, t.flushPassiveEffects = Bu, t.flushSync = nc, t.focusWithin = function(m, A) {
      if (!Se) throw Error(l(363));
      for (m = Os(m), A = us(m, A), A = Array.from(A), m = 0; m < A.length; ) {
        var V = A[m++];
        if (!pt(V)) {
          if (V.tag === 5 && Sn(V.stateNode)) return !0;
          for (V = V.child; V !== null; ) A.push(V), V = V.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return Hn;
    }, t.getFindAllNodesFailureDescription = function(m, A) {
      if (!Se) throw Error(l(363));
      var V = 0, Y = [];
      m = [Os(m), 0];
      for (var L = 0; L < m.length; ) {
        var $ = m[L++], Ve = m[L++], nt = A[Ve];
        if (($.tag !== 5 || !pt($)) && (nh($, nt) && (Y.push(gd(nt)), Ve++, Ve > V && (V = Ve)), Ve < A.length)) for ($ = $.child; $ !== null; ) m.push($, Ve), $ = $.sibling;
      }
      if (V < A.length) {
        for (m = []; V < A.length; V++) m.push(gd(A[V]));
        return `findAllNodes was able to match part of the selector:
  ` + (Y.join(" > ") + `

No matching component was found for:
  `) + m.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(m) {
      if (m = m.current, !m.child) return null;
      switch (m.child.tag) {
        case 5:
          return Ke(m.child.stateNode);
        default:
          return m.child.stateNode;
      }
    }, t.injectIntoDevTools = function(m) {
      if (m = { bundleType: m.bundleType, version: m.version, rendererPackageName: m.rendererPackageName, rendererConfig: m.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: u.ReactCurrentDispatcher, findHostInstanceByFiber: ac, findFiberByHostInstance: m.findFiberByHostInstance || Fc, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") m = !1;
      else {
        var A = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (A.isDisabled || !A.supportsFiber) m = !0;
        else {
          try {
            Ja = A.inject(m), is = A;
          } catch {
          }
          m = !!A.checkDCE;
        }
      }
      return m;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(m, A, V, Y) {
      if (!Se) throw Error(l(363));
      m = qa(m, A);
      var L = rn(m, V, Y).disconnect;
      return { disconnect: function() {
        L();
      } };
    }, t.registerMutableSourceForHydration = function(m, A) {
      var V = A._getVersion;
      V = V(A._source), m.mutableSourceEagerHydrationData == null ? m.mutableSourceEagerHydrationData = [A, V] : m.mutableSourceEagerHydrationData.push(A, V);
    }, t.runWithPriority = function(m, A) {
      var V = Hn;
      try {
        return Hn = m, A();
      } finally {
        Hn = V;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(m, A, V, Y) {
      var L = A.current, $ = vi(), Ve = Or(L);
      return V = _m(V), A.context === null ? A.context = V : A.pendingContext = V, A = Qo($, Ve), A.payload = { element: m }, Y = Y === void 0 ? null : Y, Y !== null && (A.callback = Y), Tl(L, A), m = La(L, Ve, $), m !== null && qg(m, L, Ve), Ve;
    }, t;
  }), TM;
}
var _M = { exports: {} }, z_;
function h$() {
  if (z_) return _M.exports;
  z_ = 1;
  var a = {};
  /**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return a.NODE_ENV !== "production" && (_M.exports = function(t) {
    var n = {}, i = xe, o = TK(), l = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, u = !1;
    function I(c) {
      u = c;
    }
    function f(c) {
      if (!u) {
        for (var d = arguments.length, G = new Array(d > 1 ? d - 1 : 0), w = 1; w < d; w++)
          G[w - 1] = arguments[w];
        v("warn", c, G);
      }
    }
    function h(c) {
      if (!u) {
        for (var d = arguments.length, G = new Array(d > 1 ? d - 1 : 0), w = 1; w < d; w++)
          G[w - 1] = arguments[w];
        v("error", c, G);
      }
    }
    function v(c, d, G) {
      {
        var w = l.ReactDebugCurrentFrame, H = w.getStackAddendum();
        H !== "" && (d += "%s", G = G.concat([H]));
        var z = G.map(function(Q) {
          return String(Q);
        });
        z.unshift("Warning: " + d), Function.prototype.apply.call(console[c], console, z);
      }
    }
    var b = Object.assign;
    function S(c) {
      return c._reactInternals;
    }
    function R(c, d) {
      c._reactInternals = d;
    }
    var W = !1, x = !1, M = !1, T = !1, E = !1, _ = !1, P = !0, U = !0, q = !0, k = 0, O = 1, J = 2, te = 3, fe = 4, pe = 5, Ae = 6, Te = 7, Ke = 8, je = 9, ee = 10, Ce = 11, be = 12, le = 13, Ye = 14, $e = 15, ke = 16, ot = 17, wt = 18, St = 19, ln = 21, hn = 22, mn = 23, Pn = 24, he = 25, Lt = Symbol.for("react.element"), Wt = Symbol.for("react.portal"), tn = Symbol.for("react.fragment"), Gt = Symbol.for("react.strict_mode"), Rn = Symbol.for("react.profiler"), nn = Symbol.for("react.provider"), Bn = Symbol.for("react.context"), Se = Symbol.for("react.forward_ref"), oe = Symbol.for("react.suspense"), ct = Symbol.for("react.suspense_list"), Ft = Symbol.for("react.memo"), pt = Symbol.for("react.lazy"), zt = Symbol.for("react.scope"), Sn = Symbol.for("react.debug_trace_mode"), rn = Symbol.for("react.offscreen"), gn = Symbol.for("react.legacy_hidden"), qn = Symbol.for("react.cache"), qt = Symbol.for("react.tracing_marker"), An = Symbol.iterator, Fe = "@@iterator";
    function Ie(c) {
      if (c === null || typeof c != "object")
        return null;
      var d = An && c[An] || c[Fe];
      return typeof d == "function" ? d : null;
    }
    function at(c, d, G) {
      var w = c.displayName;
      if (w)
        return w;
      var H = d.displayName || d.name || "";
      return H !== "" ? G + "(" + H + ")" : G;
    }
    function ye(c) {
      return c.displayName || "Context";
    }
    function Pe(c) {
      if (c == null)
        return null;
      if (typeof c.tag == "number" && h("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c == "function")
        return c.displayName || c.name || null;
      if (typeof c == "string")
        return c;
      switch (c) {
        case tn:
          return "Fragment";
        case Wt:
          return "Portal";
        case Rn:
          return "Profiler";
        case Gt:
          return "StrictMode";
        case oe:
          return "Suspense";
        case ct:
          return "SuspenseList";
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case Bn:
            var d = c;
            return ye(d) + ".Consumer";
          case nn:
            var G = c;
            return ye(G._context) + ".Provider";
          case Se:
            return at(c, c.render, "ForwardRef");
          case Ft:
            var w = c.displayName || null;
            return w !== null ? w : Pe(c.type) || "Memo";
          case pt: {
            var H = c, z = H._payload, Q = H._init;
            try {
              return Pe(Q(z));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Ot(c, d, G) {
      var w = d.displayName || d.name || "";
      return c.displayName || (w !== "" ? G + "(" + w + ")" : G);
    }
    function Re(c) {
      return c.displayName || "Context";
    }
    function lt(c) {
      var d = c.tag, G = c.type;
      switch (d) {
        case Pn:
          return "Cache";
        case je:
          var w = G;
          return Re(w) + ".Consumer";
        case ee:
          var H = G;
          return Re(H._context) + ".Provider";
        case wt:
          return "DehydratedFragment";
        case Ce:
          return Ot(G, G.render, "ForwardRef");
        case Te:
          return "Fragment";
        case pe:
          return G;
        case fe:
          return "Portal";
        case te:
          return "Root";
        case Ae:
          return "Text";
        case ke:
          return Pe(G);
        case Ke:
          return G === Gt ? "StrictMode" : "Mode";
        case hn:
          return "Offscreen";
        case be:
          return "Profiler";
        case ln:
          return "Scope";
        case le:
          return "Suspense";
        case St:
          return "SuspenseList";
        case he:
          return "TracingMarker";
        case O:
        case k:
        case ot:
        case J:
        case Ye:
        case $e:
          if (typeof G == "function")
            return G.displayName || G.name || null;
          if (typeof G == "string")
            return G;
          break;
      }
      return null;
    }
    var _e = (
      /*                      */
      0
    ), ht = (
      /*                */
      1
    ), Ht = (
      /*                    */
      2
    ), an = (
      /*                       */
      4
    ), fi = (
      /*           */
      Ht | an
    ), xi = (
      /*                */
      16
    ), Ir = (
      /*                 */
      32
    ), Xi = (
      /*                     */
      64
    ), pi = (
      /*                   */
      128
    ), Cr = (
      /*            */
      256
    ), Sa = (
      /*                          */
      512
    ), zr = (
      /*                     */
      1024
    ), na = (
      /*                      */
      2048
    ), la = (
      /*                    */
      4096
    ), Oa = (
      /*           */
      la | an
    ), Le = (
      /*                   */
      8192
    ), qe = (
      /*             */
      16384
    ), gt = na | an | Xi | Sa | zr | qe, Pt = (
      /*               */
      32767
    ), me = (
      /*                   */
      32768
    ), ut = (
      /*                */
      65536
    ), Bt = (
      /* */
      131072
    ), Tt = (
      /*                       */
      1048576
    ), ae = (
      /*                    */
      2097152
    ), we = (
      /*                 */
      4194304
    ), Ee = (
      /*                */
      8388608
    ), Ue = (
      /*               */
      16777216
    ), Oe = (
      /*              */
      33554432
    ), Nt = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      an | zr | 0
    ), Kt = Ht | an | xi | Ir | Sa | la | Le, vn = an | Xi | Sa | Le, Yt = na | xi, Yn = we | Ee | ae, Fn = l.ReactCurrentOwner;
    function _n(c) {
      var d = c, G = c;
      if (c.alternate)
        for (; d.return; )
          d = d.return;
      else {
        var w = d;
        do
          d = w, (d.flags & (Ht | la)) !== _e && (G = d.return), w = d.return;
        while (w);
      }
      return d.tag === te ? G : null;
    }
    function Xn(c) {
      return _n(c) === c;
    }
    function or(c) {
      {
        var d = Fn.current;
        if (d !== null && d.tag === O) {
          var G = d, w = G.stateNode;
          w._warnedAboutRefsInRender || h("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", lt(G) || "A component"), w._warnedAboutRefsInRender = !0;
        }
      }
      var H = S(c);
      return H ? _n(H) === H : !1;
    }
    function Ei(c) {
      if (_n(c) !== c)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function pr(c) {
      var d = c.alternate;
      if (!d) {
        var G = _n(c);
        if (G === null)
          throw new Error("Unable to find node on an unmounted component.");
        return G !== c ? null : c;
      }
      for (var w = c, H = d; ; ) {
        var z = w.return;
        if (z === null)
          break;
        var Q = z.alternate;
        if (Q === null) {
          var re = z.return;
          if (re !== null) {
            w = H = re;
            continue;
          }
          break;
        }
        if (z.child === Q.child) {
          for (var ce = z.child; ce; ) {
            if (ce === w)
              return Ei(z), c;
            if (ce === H)
              return Ei(z), d;
            ce = ce.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (w.return !== H.return)
          w = z, H = Q;
        else {
          for (var Xe = !1, Je = z.child; Je; ) {
            if (Je === w) {
              Xe = !0, w = z, H = Q;
              break;
            }
            if (Je === H) {
              Xe = !0, H = z, w = Q;
              break;
            }
            Je = Je.sibling;
          }
          if (!Xe) {
            for (Je = Q.child; Je; ) {
              if (Je === w) {
                Xe = !0, w = Q, H = z;
                break;
              }
              if (Je === H) {
                Xe = !0, H = Q, w = z;
                break;
              }
              Je = Je.sibling;
            }
            if (!Xe)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (w.alternate !== H)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (w.tag !== te)
        throw new Error("Unable to find node on an unmounted component.");
      return w.stateNode.current === w ? c : d;
    }
    function Ln(c) {
      var d = pr(c);
      return d !== null ? ge(d) : null;
    }
    function ge(c) {
      if (c.tag === pe || c.tag === Ae)
        return c;
      for (var d = c.child; d !== null; ) {
        var G = ge(d);
        if (G !== null)
          return G;
        d = d.sibling;
      }
      return null;
    }
    function ue(c) {
      var d = pr(c);
      return d !== null ? We(d) : null;
    }
    function We(c) {
      if (c.tag === pe || c.tag === Ae)
        return c;
      for (var d = c.child; d !== null; ) {
        if (d.tag !== fe) {
          var G = We(d);
          if (G !== null)
            return G;
        }
        d = d.sibling;
      }
      return null;
    }
    var et = Array.isArray;
    function Mt(c) {
      return et(c);
    }
    var bn = t.getPublicInstance, Ai = t.getRootHostContext, ve = t.getChildHostContext, Be = t.prepareForCommit, mt = t.resetAfterCommit, $t = t.createInstance, In = t.appendInitialChild, un = t.finalizeInitialChildren, Bi = t.prepareUpdate, Si = t.shouldSetTextContent, Ji = t.createTextInstance, En = t.scheduleTimeout, cn = t.cancelTimeout, kn = t.noTimeout;
    t.now;
    var ti = t.isPrimaryRenderer, Di = t.warnsIfNotActing, qi = t.supportsMutation, ci = t.supportsPersistence, Hr = t.supportsHydration, Za = t.getInstanceFromNode;
    t.beforeActiveInstanceBlur, t.afterActiveInstanceBlur;
    var gi = t.preparePortalMount;
    t.preparePortalMount, t.getInstanceFromScope;
    var yr = t.getCurrentEventPriority, Hn = t.detachDeletedInstance, Pa = t.supportsMicrotasks, zo = t.scheduleMicrotask, Ko = t.supportsTestSelectors, Xr = t.findFiberRoot, ia = t.getBoundingRect, kr = t.getTextContent, ua = t.isHiddenSubtree, Lo = t.matchAccessibilityRole, ko = t.setFocusIfFocusable, cu = t.setupIntersectionObserver, Ja = t.appendChild, is = t.appendChildToContainer, Qg = t.commitTextUpdate, gu = t.commitMount, rs = t.commitUpdate, rl = t.insertBefore, du = t.insertInContainerBefore, jg = t.removeChild, ku = t.removeChildFromContainer, Bc = t.resetTextContent, al = t.hideInstance, kC = t.hideTextInstance, Bl = t.unhideInstance, kI = t.unhideTextInstance, ie = t.clearContainer, De = t.cloneInstance, bt = t.createContainerChildSet, Et = t.appendChildToContainerChildSet, wn = t.finalizeContainerChildren, ui = t.replaceContainerChildren;
    t.getOffscreenContainerType;
    var ni = t.getOffscreenContainerProps, Yi = t.cloneHiddenInstance, rr = t.cloneHiddenTextInstance, Yr = t.canHydrateInstance, hr = t.canHydrateTextInstance, vr = t.canHydrateSuspenseInstance, br = t.isSuspenseInstancePending, Ia = t.isSuspenseInstanceFallback, Fr = t.registerSuspenseInstanceRetry, Qo = t.getNextHydratableSibling, Tl = t.getFirstHydratableChild, qg = t.getFirstHydratableChildWithinContainer, DI = t.getFirstHydratableChildWithinSuspenseInstance, Iu = t.hydrateInstance, UI = t.hydrateTextInstance, OI = t.hydrateSuspenseInstance, DC = t.getNextHydratableInstanceAfterSuspenseInstance, UC = t.commitHydratedContainer, fp = t.commitHydratedSuspenseInstance, pp = t.clearSuspenseBoundary, kh = t.clearSuspenseBoundaryFromContainer, Dh = t.shouldDeleteUnhydratedTailInstances, Dd = t.didNotMatchHydratedContainerTextInstance, ug = t.didNotMatchHydratedTextInstance, Uh = t.didNotHydrateInstanceWithinContainer, Cu = t.didNotHydrateInstanceWithinSuspenseInstance, hu = t.didNotHydrateInstance, ol = t.didNotFindHydratableInstanceWithinContainer, cg = t.didNotFindHydratableTextInstanceWithinContainer, Du = t.didNotFindHydratableSuspenseInstanceWithinContainer, gg = t.didNotFindHydratableInstanceWithinSuspenseInstance, Sc = t.didNotFindHydratableTextInstanceWithinSuspenseInstance, mp = t.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, Es = t.didNotFindHydratableInstance, Uu = t.didNotFindHydratableTextInstance, Kr = t.didNotFindHydratableSuspenseInstance, _a = t.errorHydratingContainer, ca = 0, Zc, _l, $g, Oh, OC, Ou, Ap;
    function PI() {
    }
    PI.__reactDisabledLog = !0;
    function JI() {
      {
        if (ca === 0) {
          Zc = console.log, _l = console.info, $g = console.warn, Oh = console.error, OC = console.group, Ou = console.groupCollapsed, Ap = console.groupEnd;
          var c = {
            configurable: !0,
            enumerable: !0,
            value: PI,
            writable: !0
          };
          Object.defineProperties(console, {
            info: c,
            log: c,
            warn: c,
            error: c,
            group: c,
            groupCollapsed: c,
            groupEnd: c
          });
        }
        ca++;
      }
    }
    function PC() {
      {
        if (ca--, ca === 0) {
          var c = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: b({}, c, {
              value: Zc
            }),
            info: b({}, c, {
              value: _l
            }),
            warn: b({}, c, {
              value: $g
            }),
            error: b({}, c, {
              value: Oh
            }),
            group: b({}, c, {
              value: OC
            }),
            groupCollapsed: b({}, c, {
              value: Ou
            }),
            groupEnd: b({}, c, {
              value: Ap
            })
          });
        }
        ca < 0 && h("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ed = l.ReactCurrentDispatcher, wc;
    function zl(c, d, G) {
      {
        if (wc === void 0)
          try {
            throw Error();
          } catch (H) {
            var w = H.stack.trim().match(/\n( *(at )?)/);
            wc = w && w[1] || "";
          }
        return `
` + wc + c;
      }
    }
    var JC = !1, fs;
    {
      var Ph = typeof WeakMap == "function" ? WeakMap : Map;
      fs = new Ph();
    }
    function dg(c, d) {
      if (!c || JC)
        return "";
      {
        var G = fs.get(c);
        if (G !== void 0)
          return G;
      }
      var w;
      JC = !0;
      var H = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var z;
      z = ed.current, ed.current = null, JI();
      try {
        if (d) {
          var Q = function() {
            throw Error();
          };
          if (Object.defineProperty(Q.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Q, []);
            } catch (yn) {
              w = yn;
            }
            Reflect.construct(c, [], Q);
          } else {
            try {
              Q.call();
            } catch (yn) {
              w = yn;
            }
            c.call(Q.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (yn) {
            w = yn;
          }
          c();
        }
      } catch (yn) {
        if (yn && w && typeof yn.stack == "string") {
          for (var re = yn.stack.split(`
`), ce = w.stack.split(`
`), Xe = re.length - 1, Je = ce.length - 1; Xe >= 1 && Je >= 0 && re[Xe] !== ce[Je]; )
            Je--;
          for (; Xe >= 1 && Je >= 0; Xe--, Je--)
            if (re[Xe] !== ce[Je]) {
              if (Xe !== 1 || Je !== 1)
                do
                  if (Xe--, Je--, Je < 0 || re[Xe] !== ce[Je]) {
                    var ft = `
` + re[Xe].replace(" at new ", " at ");
                    return c.displayName && ft.includes("<anonymous>") && (ft = ft.replace("<anonymous>", c.displayName)), typeof c == "function" && fs.set(c, ft), ft;
                  }
                while (Xe >= 1 && Je >= 0);
              break;
            }
        }
      } finally {
        JC = !1, ed.current = z, PC(), Error.prepareStackTrace = H;
      }
      var _t = c ? c.displayName || c.name : "", Ut = _t ? zl(_t) : "";
      return typeof c == "function" && fs.set(c, Ut), Ut;
    }
    function sl(c, d, G) {
      return dg(c, !0);
    }
    function Ig(c, d, G) {
      return dg(c, !1);
    }
    function Ud(c) {
      var d = c.prototype;
      return !!(d && d.isReactComponent);
    }
    function Kl(c, d, G) {
      if (c == null)
        return "";
      if (typeof c == "function")
        return dg(c, Ud(c));
      if (typeof c == "string")
        return zl(c);
      switch (c) {
        case oe:
          return zl("Suspense");
        case ct:
          return zl("SuspenseList");
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case Se:
            return Ig(c.render);
          case Ft:
            return Kl(c.type, d, G);
          case pt: {
            var w = c, H = w._payload, z = w._init;
            try {
              return Kl(z(H), d, G);
            } catch {
            }
          }
        }
      return "";
    }
    var QC = Object.prototype.hasOwnProperty, Od = {}, vp = l.ReactDebugCurrentFrame;
    function QI(c) {
      if (c) {
        var d = c._owner, G = Kl(c.type, c._source, d ? d.type : null);
        vp.setExtraStackFrame(G);
      } else
        vp.setExtraStackFrame(null);
    }
    function Dr(c, d, G, w, H) {
      {
        var z = Function.call.bind(QC);
        for (var Q in c)
          if (z(c, Q)) {
            var re = void 0;
            try {
              if (typeof c[Q] != "function") {
                var ce = Error((w || "React class") + ": " + G + " type `" + Q + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c[Q] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ce.name = "Invariant Violation", ce;
              }
              re = c[Q](d, Q, w, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Xe) {
              re = Xe;
            }
            re && !(re instanceof Error) && (QI(H), h("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", w || "React class", G, Q, typeof re), QI(null)), re instanceof Error && !(re.message in Od) && (Od[re.message] = !0, QI(H), h("Failed %s type: %s", G, re.message), QI(null));
          }
      }
    }
    var Pd = [], Ts;
    Ts = [];
    var _s = -1;
    function fu(c) {
      return {
        current: c
      };
    }
    function va(c, d) {
      if (_s < 0) {
        h("Unexpected pop.");
        return;
      }
      d !== Ts[_s] && h("Unexpected Fiber popped."), c.current = Pd[_s], Pd[_s] = null, Ts[_s] = null, _s--;
    }
    function ao(c, d, G) {
      _s++, Pd[_s] = c.current, Ts[_s] = G, c.current = d;
    }
    var za;
    za = {};
    var Qr = {};
    Object.freeze(Qr);
    var jr = fu(Qr), zs = fu(!1), Ll = Qr;
    function ps(c, d, G) {
      return G && ll(d) ? Ll : jr.current;
    }
    function jI(c, d, G) {
      {
        var w = c.stateNode;
        w.__reactInternalMemoizedUnmaskedChildContext = d, w.__reactInternalMemoizedMaskedChildContext = G;
      }
    }
    function oo(c, d) {
      {
        var G = c.type, w = G.contextTypes;
        if (!w)
          return Qr;
        var H = c.stateNode;
        if (H && H.__reactInternalMemoizedUnmaskedChildContext === d)
          return H.__reactInternalMemoizedMaskedChildContext;
        var z = {};
        for (var Q in w)
          z[Q] = d[Q];
        {
          var re = lt(c) || "Unknown";
          Dr(w, z, "context", re);
        }
        return H && jI(c, d, z), z;
      }
    }
    function Jd() {
      return zs.current;
    }
    function ll(c) {
      {
        var d = c.childContextTypes;
        return d != null;
      }
    }
    function Pu(c) {
      va(zs, c), va(jr, c);
    }
    function Sl(c) {
      va(zs, c), va(jr, c);
    }
    function pu(c, d, G) {
      {
        if (jr.current !== Qr)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        ao(jr, d, c), ao(zs, G, c);
      }
    }
    function mu(c, d, G) {
      {
        var w = c.stateNode, H = d.childContextTypes;
        if (typeof w.getChildContext != "function") {
          {
            var z = lt(c) || "Unknown";
            za[z] || (za[z] = !0, h("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", z, z));
          }
          return G;
        }
        var Q = w.getChildContext();
        for (var re in Q)
          if (!(re in H))
            throw new Error((lt(c) || "Unknown") + '.getChildContext(): key "' + re + '" is not defined in childContextTypes.');
        {
          var ce = lt(c) || "Unknown";
          Dr(H, Q, "child context", ce);
        }
        return b({}, G, Q);
      }
    }
    function fo(c) {
      {
        var d = c.stateNode, G = d && d.__reactInternalMemoizedMergedChildContext || Qr;
        return Ll = jr.current, ao(jr, G, c), ao(zs, zs.current, c), !0;
      }
    }
    function Qd(c, d, G) {
      {
        var w = c.stateNode;
        if (!w)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (G) {
          var H = mu(c, d, Ll);
          w.__reactInternalMemoizedMergedChildContext = H, va(zs, c), va(jr, c), ao(jr, H, c), ao(zs, G, c);
        } else
          va(zs, c), ao(zs, G, c);
      }
    }
    function yp(c) {
      {
        if (!Xn(c) || c.tag !== O)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var d = c;
        do {
          switch (d.tag) {
            case te:
              return d.stateNode.context;
            case O: {
              var G = d.type;
              if (ll(G))
                return d.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          d = d.return;
        } while (d !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var td = 0, Jh = 1, Oi = (
      /*                         */
      0
    ), Rr = (
      /*                 */
      1
    ), xr = (
      /*                    */
      2
    ), Ma = (
      /*               */
      8
    ), as = (
      /*              */
      16
    ), bp = Math.clz32 ? Math.clz32 : jh, Au = Math.log, Qh = Math.LN2;
    function jh(c) {
      var d = c >>> 0;
      return d === 0 ? 32 : 31 - (Au(d) / Qh | 0) | 0;
    }
    var nd = 31, Dt = (
      /*                        */
      0
    ), so = (
      /*                          */
      0
    ), nr = (
      /*                        */
      1
    ), Ks = (
      /*    */
      2
    ), vu = (
      /*            */
      4
    ), Rc = (
      /*            */
      8
    ), ul = (
      /*                    */
      16
    ), id = (
      /*                */
      32
    ), kl = (
      /*                       */
      4194240
    ), jd = (
      /*                        */
      64
    ), qh = (
      /*                        */
      128
    ), qI = (
      /*                        */
      256
    ), jC = (
      /*                        */
      512
    ), rd = (
      /*                        */
      1024
    ), qd = (
      /*                        */
      2048
    ), ad = (
      /*                        */
      4096
    ), qC = (
      /*                        */
      8192
    ), Cg = (
      /*                        */
      16384
    ), $d = (
      /*                       */
      32768
    ), hg = (
      /*                       */
      65536
    ), eI = (
      /*                       */
      131072
    ), $h = (
      /*                       */
      262144
    ), $I = (
      /*                       */
      524288
    ), eC = (
      /*                       */
      1048576
    ), Ls = (
      /*                       */
      2097152
    ), fg = (
      /*                            */
      130023424
    ), cl = (
      /*                             */
      4194304
    ), lo = (
      /*                             */
      8388608
    ), od = (
      /*                             */
      16777216
    ), ms = (
      /*                             */
      33554432
    ), pg = (
      /*                             */
      67108864
    ), $C = cl, sd = (
      /*          */
      134217728
    ), Ju = (
      /*                                 */
      268435455
    ), os = (
      /*               */
      268435456
    ), wa = (
      /*                       */
      536870912
    ), ks = (
      /*                   */
      1073741824
    );
    function Hi(c) {
      {
        if (c & nr)
          return "Sync";
        if (c & Ks)
          return "InputContinuousHydration";
        if (c & vu)
          return "InputContinuous";
        if (c & Rc)
          return "DefaultHydration";
        if (c & ul)
          return "Default";
        if (c & id)
          return "TransitionHydration";
        if (c & kl)
          return "Transition";
        if (c & fg)
          return "Retry";
        if (c & sd)
          return "SelectiveHydration";
        if (c & os)
          return "IdleHydration";
        if (c & wa)
          return "Idle";
        if (c & ks)
          return "Offscreen";
      }
    }
    var Pi = -1, ar = jd, Ci = cl;
    function Gr(c) {
      switch (mg(c)) {
        case nr:
          return nr;
        case Ks:
          return Ks;
        case vu:
          return vu;
        case Rc:
          return Rc;
        case ul:
          return ul;
        case id:
          return id;
        case jd:
        case qh:
        case qI:
        case jC:
        case rd:
        case qd:
        case ad:
        case qC:
        case Cg:
        case $d:
        case hg:
        case eI:
        case $h:
        case $I:
        case eC:
        case Ls:
          return c & kl;
        case cl:
        case lo:
        case od:
        case ms:
        case pg:
          return c & fg;
        case sd:
          return sd;
        case os:
          return os;
        case wa:
          return wa;
        case ks:
          return ks;
        default:
          return h("Should have found matching lanes. This is a bug in React."), c;
      }
    }
    function Ds(c, d) {
      var G = c.pendingLanes;
      if (G === Dt)
        return Dt;
      var w = Dt, H = c.suspendedLanes, z = c.pingedLanes, Q = G & Ju;
      if (Q !== Dt) {
        var re = Q & ~H;
        if (re !== Dt)
          w = Gr(re);
        else {
          var ce = Q & z;
          ce !== Dt && (w = Gr(ce));
        }
      } else {
        var Xe = G & ~H;
        Xe !== Dt ? w = Gr(Xe) : z !== Dt && (w = Gr(z));
      }
      if (w === Dt)
        return Dt;
      if (d !== Dt && d !== w && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (d & H) === Dt) {
        var Je = mg(w), ft = mg(d);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          Je >= ft || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          Je === ul && (ft & kl) !== Dt
        )
          return d;
      }
      (w & vu) !== Dt && (w |= G & ul);
      var _t = c.entangledLanes;
      if (_t !== Dt)
        for (var Ut = c.entanglements, yn = w & _t; yn > 0; ) {
          var xn = qo(yn), _i = 1 << xn;
          w |= Ut[xn], yn &= ~_i;
        }
      return w;
    }
    function jo(c, d) {
      for (var G = c.eventTimes, w = Pi; d > 0; ) {
        var H = qo(d), z = 1 << H, Q = G[H];
        Q > w && (w = Q), d &= ~z;
      }
      return w;
    }
    function Qi(c, d) {
      switch (c) {
        case nr:
        case Ks:
        case vu:
          return d + 250;
        case Rc:
        case ul:
        case id:
        case jd:
        case qh:
        case qI:
        case jC:
        case rd:
        case qd:
        case ad:
        case qC:
        case Cg:
        case $d:
        case hg:
        case eI:
        case $h:
        case $I:
        case eC:
        case Ls:
          return d + 5e3;
        case cl:
        case lo:
        case od:
        case ms:
        case pg:
          return Pi;
        case sd:
        case os:
        case wa:
        case ks:
          return Pi;
        default:
          return h("Should have found matching lanes. This is a bug in React."), Pi;
      }
    }
    function As(c, d) {
      for (var G = c.pendingLanes, w = c.suspendedLanes, H = c.pingedLanes, z = c.expirationTimes, Q = G; Q > 0; ) {
        var re = qo(Q), ce = 1 << re, Xe = z[re];
        Xe === Pi ? ((ce & w) === Dt || (ce & H) !== Dt) && (z[re] = Qi(ce, d)) : Xe <= d && (c.expiredLanes |= ce), Q &= ~ce;
      }
    }
    function Zl(c) {
      return Gr(c.pendingLanes);
    }
    function Qa(c) {
      var d = c.pendingLanes & ~ks;
      return d !== Dt ? d : d & ks ? ks : Dt;
    }
    function gl(c) {
      return (c & nr) !== Dt;
    }
    function Dl(c) {
      return (c & Ju) !== Dt;
    }
    function yu(c) {
      return (c & fg) === c;
    }
    function xc(c) {
      return (c & kl) === c;
    }
    function tC(c, d) {
      var G = Ks | vu | Rc | ul;
      return (d & G) !== Dt;
    }
    function Qu(c, d) {
      return (d & c.expiredLanes) !== Dt;
    }
    function Wc(c) {
      return (c & kl) !== 0;
    }
    function ss() {
      var c = ar;
      return ar <<= 1, ar & kl || (ar = jd), c;
    }
    function tI() {
      var c = Ci;
      return Ci <<= 1, Ci & fg || (Ci = cl), c;
    }
    function mg(c) {
      return c & -c;
    }
    function Us(c) {
      return mg(c);
    }
    function qo(c) {
      return 31 - bp(c);
    }
    function ls(c) {
      return qo(c);
    }
    function ja(c, d) {
      return (c & d) !== Dt;
    }
    function bu(c, d) {
      return (c & d) === d;
    }
    function Wi(c, d) {
      return c | d;
    }
    function uo(c, d) {
      return c & ~d;
    }
    function Gu(c, d) {
      return c & d;
    }
    function Nn(c) {
      return c;
    }
    function Do(c, d) {
      return c !== so && c < d ? c : d;
    }
    function ju(c) {
      for (var d = [], G = 0; G < nd; G++)
        d.push(c);
      return d;
    }
    function Ul(c, d, G) {
      c.pendingLanes |= d, d !== wa && (c.suspendedLanes = Dt, c.pingedLanes = Dt);
      var w = c.eventTimes, H = ls(d);
      w[H] = G;
    }
    function ef(c, d) {
      c.suspendedLanes |= d, c.pingedLanes &= ~d;
      for (var G = c.expirationTimes, w = d; w > 0; ) {
        var H = qo(w), z = 1 << H;
        G[H] = Pi, w &= ~z;
      }
    }
    function qu(c, d, G) {
      c.pingedLanes |= c.suspendedLanes & d;
    }
    function vs(c, d) {
      var G = c.pendingLanes & ~d;
      c.pendingLanes = d, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= d, c.mutableReadLanes &= d, c.entangledLanes &= d;
      for (var w = c.entanglements, H = c.eventTimes, z = c.expirationTimes, Q = G; Q > 0; ) {
        var re = qo(Q), ce = 1 << re;
        w[re] = Dt, H[re] = Pi, z[re] = Pi, Q &= ~ce;
      }
    }
    function ys(c, d) {
      for (var G = c.entangledLanes |= d, w = c.entanglements, H = G; H; ) {
        var z = qo(H), Q = 1 << z;
        // Is this one of the newly entangled lanes?
        Q & d | // Is this lane transitively entangled with the newly entangled lanes?
        w[z] & d && (w[z] |= d), H &= ~Q;
      }
    }
    function Ha(c, d) {
      var G = mg(d), w;
      switch (G) {
        case vu:
          w = Ks;
          break;
        case ul:
          w = Rc;
          break;
        case jd:
        case qh:
        case qI:
        case jC:
        case rd:
        case qd:
        case ad:
        case qC:
        case Cg:
        case $d:
        case hg:
        case eI:
        case $h:
        case $I:
        case eC:
        case Ls:
        case cl:
        case lo:
        case od:
        case ms:
        case pg:
          w = id;
          break;
        case wa:
          w = os;
          break;
        default:
          w = so;
          break;
      }
      return (w & (c.suspendedLanes | d)) !== so ? so : w;
    }
    function wl(c, d, G) {
      if (xo)
        for (var w = c.pendingUpdatersLaneMap; G > 0; ) {
          var H = ls(G), z = 1 << H, Q = w[H];
          Q.add(d), G &= ~z;
        }
    }
    function eh(c, d) {
      if (xo)
        for (var G = c.pendingUpdatersLaneMap, w = c.memoizedUpdaters; d > 0; ) {
          var H = ls(d), z = 1 << H, Q = G[H];
          Q.size > 0 && (Q.forEach(function(re) {
            var ce = re.alternate;
            (ce === null || !w.has(ce)) && w.add(re);
          }), Q.clear()), d &= ~z;
        }
    }
    var Ol = nr, ld = vu, Ag = ul, nI = wa, Vc = so;
    function Pl() {
      return Vc;
    }
    function Ka(c) {
      Vc = c;
    }
    function co(c, d) {
      var G = Vc;
      try {
        return Vc = c, d();
      } finally {
        Vc = G;
      }
    }
    function lv(c, d) {
      return c !== 0 && c < d ? c : d;
    }
    function ud(c, d) {
      return c > d ? c : d;
    }
    function cd(c, d) {
      return c !== 0 && c < d;
    }
    function Nc(c) {
      var d = mg(c);
      return cd(Ol, d) ? cd(ld, d) ? Dl(d) ? Ag : nI : ld : Ol;
    }
    var tf = o.unstable_scheduleCallback, vg = o.unstable_cancelCallback, th = o.unstable_shouldYield, iI = o.unstable_requestPaint, Ca = o.unstable_now, Ra = o.unstable_ImmediatePriority, zn = o.unstable_UserBlockingPriority, Ro = o.unstable_NormalPriority, Os = o.unstable_IdlePriority, nh = o.unstable_yieldValue, gd = o.unstable_setDisableYieldValue, us = null, qa = null, On = null, ra = !1, xo = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function ya(c) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var d = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (d.isDisabled)
        return !0;
      if (!d.supportsFiber)
        return h("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        P && (c = b({}, c, {
          getLaneLabelMap: mo,
          injectProfilingHooks: rI
        })), us = d.inject(c), qa = d;
      } catch (G) {
        h("React instrumentation encountered an error: %s.", G);
      }
      return !!d.checkDCE;
    }
    function ur(c, d) {
      if (qa && typeof qa.onScheduleFiberRoot == "function")
        try {
          qa.onScheduleFiberRoot(us, c, d);
        } catch (G) {
          ra || (ra = !0, h("React instrumentation encountered an error: %s", G));
        }
    }
    function po(c, d) {
      if (qa && typeof qa.onCommitFiberRoot == "function")
        try {
          var G = (c.current.flags & pi) === pi;
          if (U) {
            var w;
            switch (d) {
              case Ol:
                w = Ra;
                break;
              case ld:
                w = zn;
                break;
              case Ag:
                w = Ro;
                break;
              case nI:
                w = Os;
                break;
              default:
                w = Ro;
                break;
            }
            qa.onCommitFiberRoot(us, c, w, G);
          }
        } catch (H) {
          ra || (ra = !0, h("React instrumentation encountered an error: %s", H));
        }
    }
    function qr(c) {
      if (qa && typeof qa.onPostCommitFiberRoot == "function")
        try {
          qa.onPostCommitFiberRoot(us, c);
        } catch (d) {
          ra || (ra = !0, h("React instrumentation encountered an error: %s", d));
        }
    }
    function ha(c) {
      if (qa && typeof qa.onCommitFiberUnmount == "function")
        try {
          qa.onCommitFiberUnmount(us, c);
        } catch (d) {
          ra || (ra = !0, h("React instrumentation encountered an error: %s", d));
        }
    }
    function Ur(c) {
      if (typeof nh == "function" && (gd(c), I(c)), qa && typeof qa.setStrictMode == "function")
        try {
          qa.setStrictMode(us, c);
        } catch (d) {
          ra || (ra = !0, h("React instrumentation encountered an error: %s", d));
        }
    }
    function rI(c) {
      On = c;
    }
    function mo() {
      {
        for (var c = /* @__PURE__ */ new Map(), d = 1, G = 0; G < nd; G++) {
          var w = Hi(d);
          c.set(d, w), d *= 2;
        }
        return c;
      }
    }
    function nC(c) {
      On !== null && typeof On.markCommitStarted == "function" && On.markCommitStarted(c);
    }
    function $u() {
      On !== null && typeof On.markCommitStopped == "function" && On.markCommitStopped();
    }
    function bs(c) {
      On !== null && typeof On.markComponentRenderStarted == "function" && On.markComponentRenderStarted(c);
    }
    function Jl() {
      On !== null && typeof On.markComponentRenderStopped == "function" && On.markComponentRenderStopped();
    }
    function Mc(c) {
      On !== null && typeof On.markComponentPassiveEffectMountStarted == "function" && On.markComponentPassiveEffectMountStarted(c);
    }
    function Uo() {
      On !== null && typeof On.markComponentPassiveEffectMountStopped == "function" && On.markComponentPassiveEffectMountStopped();
    }
    function ih(c) {
      On !== null && typeof On.markComponentPassiveEffectUnmountStarted == "function" && On.markComponentPassiveEffectUnmountStarted(c);
    }
    function dd() {
      On !== null && typeof On.markComponentPassiveEffectUnmountStopped == "function" && On.markComponentPassiveEffectUnmountStopped();
    }
    function aI(c) {
      On !== null && typeof On.markComponentLayoutEffectMountStarted == "function" && On.markComponentLayoutEffectMountStarted(c);
    }
    function iC() {
      On !== null && typeof On.markComponentLayoutEffectMountStopped == "function" && On.markComponentLayoutEffectMountStopped();
    }
    function Xa(c) {
      On !== null && typeof On.markComponentLayoutEffectUnmountStarted == "function" && On.markComponentLayoutEffectUnmountStarted(c);
    }
    function Ql() {
      On !== null && typeof On.markComponentLayoutEffectUnmountStopped == "function" && On.markComponentLayoutEffectUnmountStopped();
    }
    function rC(c, d, G) {
      On !== null && typeof On.markComponentErrored == "function" && On.markComponentErrored(c, d, G);
    }
    function ec(c, d, G) {
      On !== null && typeof On.markComponentSuspended == "function" && On.markComponentSuspended(c, d, G);
    }
    function oI(c) {
      On !== null && typeof On.markLayoutEffectsStarted == "function" && On.markLayoutEffectsStarted(c);
    }
    function sI() {
      On !== null && typeof On.markLayoutEffectsStopped == "function" && On.markLayoutEffectsStopped();
    }
    function tc(c) {
      On !== null && typeof On.markPassiveEffectsStarted == "function" && On.markPassiveEffectsStarted(c);
    }
    function Kn() {
      On !== null && typeof On.markPassiveEffectsStopped == "function" && On.markPassiveEffectsStopped();
    }
    function Zi(c) {
      On !== null && typeof On.markRenderStarted == "function" && On.markRenderStarted(c);
    }
    function vi() {
      On !== null && typeof On.markRenderYielded == "function" && On.markRenderYielded();
    }
    function Or() {
      On !== null && typeof On.markRenderStopped == "function" && On.markRenderStopped();
    }
    function La(c) {
      On !== null && typeof On.markRenderScheduled == "function" && On.markRenderScheduled(c);
    }
    function yg(c, d) {
      On !== null && typeof On.markForceUpdateScheduled == "function" && On.markForceUpdateScheduled(c, d);
    }
    function Ps(c, d) {
      On !== null && typeof On.markStateUpdateScheduled == "function" && On.markStateUpdateScheduled(c, d);
    }
    function Gs(c, d) {
      return c === d && (c !== 0 || 1 / c === 1 / d) || c !== c && d !== d;
    }
    var Js = typeof Object.is == "function" ? Object.is : Gs, dl = null, dn = !1, Wr = !1;
    function yi(c) {
      dl === null ? dl = [c] : dl.push(c);
    }
    function nc(c) {
      dn = !0, yi(c);
    }
    function Rl() {
      dn && $a();
    }
    function $a() {
      if (!Wr && dl !== null) {
        Wr = !0;
        var c = 0, d = Pl();
        try {
          var G = !0, w = dl;
          for (Ka(Ol); c < w.length; c++) {
            var H = w[c];
            do
              H = H(G);
            while (H !== null);
          }
          dl = null, dn = !1;
        } catch (z) {
          throw dl !== null && (dl = dl.slice(c + 1)), tf(Ra, $a), z;
        } finally {
          Ka(d), Wr = !1;
        }
      }
      return null;
    }
    function jl(c) {
      var d = c.current.memoizedState;
      return d.isDehydrated;
    }
    var lI = l.ReactCurrentBatchConfig, bg = null;
    function Gg() {
      return lI.transition;
    }
    function uI(c, d) {
      if (Js(c, d))
        return !0;
      if (typeof c != "object" || c === null || typeof d != "object" || d === null)
        return !1;
      var G = Object.keys(c), w = Object.keys(d);
      if (G.length !== w.length)
        return !1;
      for (var H = 0; H < G.length; H++) {
        var z = G[H];
        if (!QC.call(d, z) || !Js(c[z], d[z]))
          return !1;
      }
      return !0;
    }
    function nf(c) {
      switch (c._debugOwner && c._debugOwner.type, c._debugSource, c.tag) {
        case pe:
          return zl(c.type);
        case ke:
          return zl("Lazy");
        case le:
          return zl("Suspense");
        case St:
          return zl("SuspenseList");
        case k:
        case J:
        case $e:
          return Ig(c.type);
        case Ce:
          return Ig(c.type.render);
        case O:
          return sl(c.type);
        default:
          return "";
      }
    }
    function aC(c) {
      try {
        var d = "", G = c;
        do
          d += nf(G), G = G.return;
        while (G);
        return d;
      } catch (w) {
        return `
Error generating stack: ` + w.message + `
` + w.stack;
      }
    }
    var oC = l.ReactDebugCurrentFrame, eo = null, Id = !1;
    function Bu() {
      {
        if (eo === null)
          return null;
        var c = eo._debugOwner;
        if (c !== null && typeof c < "u")
          return lt(c);
      }
      return null;
    }
    function cI() {
      return eo === null ? "" : aC(eo);
    }
    function $r() {
      oC.getCurrentStack = null, eo = null, Id = !1;
    }
    function Ao(c) {
      oC.getCurrentStack = cI, eo = c, Id = !1;
    }
    function xl(c) {
      Id = c;
    }
    var Wl = {
      recordUnsafeLifecycleWarnings: function(c, d) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(c, d) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var rf = function(c) {
        for (var d = null, G = c; G !== null; )
          G.mode & Ma && (d = G), G = G.return;
        return d;
      }, ic = function(c) {
        var d = [];
        return c.forEach(function(G) {
          d.push(G);
        }), d.sort().join(", ");
      }, Hc = [], Bg = [], vo = [], Xc = [], gI = [], Il = [], Su = /* @__PURE__ */ new Set();
      Wl.recordUnsafeLifecycleWarnings = function(c, d) {
        Su.has(c.type) || (typeof d.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        d.componentWillMount.__suppressDeprecationWarning !== !0 && Hc.push(c), c.mode & Ma && typeof d.UNSAFE_componentWillMount == "function" && Bg.push(c), typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && vo.push(c), c.mode & Ma && typeof d.UNSAFE_componentWillReceiveProps == "function" && Xc.push(c), typeof d.componentWillUpdate == "function" && d.componentWillUpdate.__suppressDeprecationWarning !== !0 && gI.push(c), c.mode & Ma && typeof d.UNSAFE_componentWillUpdate == "function" && Il.push(c));
      }, Wl.flushPendingUnsafeLifecycleWarnings = function() {
        var c = /* @__PURE__ */ new Set();
        Hc.length > 0 && (Hc.forEach(function(_t) {
          c.add(lt(_t) || "Component"), Su.add(_t.type);
        }), Hc = []);
        var d = /* @__PURE__ */ new Set();
        Bg.length > 0 && (Bg.forEach(function(_t) {
          d.add(lt(_t) || "Component"), Su.add(_t.type);
        }), Bg = []);
        var G = /* @__PURE__ */ new Set();
        vo.length > 0 && (vo.forEach(function(_t) {
          G.add(lt(_t) || "Component"), Su.add(_t.type);
        }), vo = []);
        var w = /* @__PURE__ */ new Set();
        Xc.length > 0 && (Xc.forEach(function(_t) {
          w.add(lt(_t) || "Component"), Su.add(_t.type);
        }), Xc = []);
        var H = /* @__PURE__ */ new Set();
        gI.length > 0 && (gI.forEach(function(_t) {
          H.add(lt(_t) || "Component"), Su.add(_t.type);
        }), gI = []);
        var z = /* @__PURE__ */ new Set();
        if (Il.length > 0 && (Il.forEach(function(_t) {
          z.add(lt(_t) || "Component"), Su.add(_t.type);
        }), Il = []), d.size > 0) {
          var Q = ic(d);
          h(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, Q);
        }
        if (w.size > 0) {
          var re = ic(w);
          h(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, re);
        }
        if (z.size > 0) {
          var ce = ic(z);
          h(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, ce);
        }
        if (c.size > 0) {
          var Xe = ic(c);
          f(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Xe);
        }
        if (G.size > 0) {
          var Je = ic(G);
          f(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Je);
        }
        if (H.size > 0) {
          var ft = ic(H);
          f(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ft);
        }
      };
      var rc = /* @__PURE__ */ new Map(), Yc = /* @__PURE__ */ new Set();
      Wl.recordLegacyContextWarning = function(c, d) {
        var G = rf(c);
        if (G === null) {
          h("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Yc.has(c.type)) {
          var w = rc.get(G);
          (c.type.contextTypes != null || c.type.childContextTypes != null || d !== null && typeof d.getChildContext == "function") && (w === void 0 && (w = [], rc.set(G, w)), w.push(c));
        }
      }, Wl.flushLegacyContextWarning = function() {
        rc.forEach(function(c, d) {
          if (c.length !== 0) {
            var G = c[0], w = /* @__PURE__ */ new Set();
            c.forEach(function(z) {
              w.add(lt(z) || "Component"), Yc.add(z.type);
            });
            var H = ic(w);
            try {
              Ao(G), h(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, H);
            } finally {
              $r();
            }
          }
        });
      }, Wl.discardPendingWarnings = function() {
        Hc = [], Bg = [], vo = [], Xc = [], gI = [], Il = [], rc = /* @__PURE__ */ new Map();
      };
    }
    function sC(c) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, G = d && c[Symbol.toStringTag] || c.constructor.name || "Object";
        return G;
      }
    }
    function Sg(c) {
      try {
        return Zu(c), !1;
      } catch {
        return !0;
      }
    }
    function Zu(c) {
      return "" + c;
    }
    function Vl(c) {
      if (Sg(c))
        return h("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", sC(c)), Zu(c);
    }
    function _m(c, d) {
      if (Sg(c))
        return h("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", d, sC(c)), Zu(c);
    }
    function Br(c, d) {
      if (c && c.defaultProps) {
        var G = b({}, d), w = c.defaultProps;
        for (var H in w)
          G[H] === void 0 && (G[H] = w[H]);
        return G;
      }
      return d;
    }
    var cs = fu(null), wu;
    wu = {};
    var ac = null, Fc = null, m = null, A = !1;
    function V() {
      ac = null, Fc = null, m = null, A = !1;
    }
    function Y() {
      A = !0;
    }
    function L() {
      A = !1;
    }
    function $(c, d, G) {
      ti ? (ao(cs, d._currentValue, c), d._currentValue = G, d._currentRenderer !== void 0 && d._currentRenderer !== null && d._currentRenderer !== wu && h("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), d._currentRenderer = wu) : (ao(cs, d._currentValue2, c), d._currentValue2 = G, d._currentRenderer2 !== void 0 && d._currentRenderer2 !== null && d._currentRenderer2 !== wu && h("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), d._currentRenderer2 = wu);
    }
    function Ve(c, d) {
      var G = cs.current;
      va(cs, d), ti ? c._currentValue = G : c._currentValue2 = G;
    }
    function nt(c, d, G) {
      for (var w = c; w !== null; ) {
        var H = w.alternate;
        if (bu(w.childLanes, d) ? H !== null && !bu(H.childLanes, d) && (H.childLanes = Wi(H.childLanes, d)) : (w.childLanes = Wi(w.childLanes, d), H !== null && (H.childLanes = Wi(H.childLanes, d))), w === G)
          break;
        w = w.return;
      }
      w !== G && h("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function kt(c, d, G) {
      Wn(c, d, G);
    }
    function Wn(c, d, G) {
      var w = c.child;
      for (w !== null && (w.return = c); w !== null; ) {
        var H = void 0, z = w.dependencies;
        if (z !== null) {
          H = w.child;
          for (var Q = z.firstContext; Q !== null; ) {
            if (Q.context === d) {
              if (w.tag === O) {
                var re = Us(G), ce = fr(Pi, re);
                ce.tag = It;
                var Xe = w.updateQueue;
                if (Xe !== null) {
                  var Je = Xe.shared, ft = Je.pending;
                  ft === null ? ce.next = ce : (ce.next = ft.next, ft.next = ce), Je.pending = ce;
                }
              }
              w.lanes = Wi(w.lanes, G);
              var _t = w.alternate;
              _t !== null && (_t.lanes = Wi(_t.lanes, G)), nt(w.return, G, c), z.lanes = Wi(z.lanes, G);
              break;
            }
            Q = Q.next;
          }
        } else if (w.tag === ee)
          H = w.type === c.type ? null : w.child;
        else if (w.tag === wt) {
          var Ut = w.return;
          if (Ut === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ut.lanes = Wi(Ut.lanes, G);
          var yn = Ut.alternate;
          yn !== null && (yn.lanes = Wi(yn.lanes, G)), nt(Ut, G, c), H = w.sibling;
        } else
          H = w.child;
        if (H !== null)
          H.return = w;
        else
          for (H = w; H !== null; ) {
            if (H === c) {
              H = null;
              break;
            }
            var xn = H.sibling;
            if (xn !== null) {
              xn.return = H.return, H = xn;
              break;
            }
            H = H.return;
          }
        w = H;
      }
    }
    function Jn(c, d) {
      ac = c, Fc = null, m = null;
      var G = c.dependencies;
      if (G !== null) {
        var w = G.firstContext;
        w !== null && (ja(G.lanes, d) && u0(), G.firstContext = null);
      }
    }
    function mi(c) {
      A && h("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var d = ti ? c._currentValue : c._currentValue2;
      if (m !== c) {
        var G = {
          context: c,
          memoizedValue: d,
          next: null
        };
        if (Fc === null) {
          if (ac === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Fc = G, ac.dependencies = {
            lanes: Dt,
            firstContext: G
          };
        } else
          Fc = Fc.next = G;
      }
      return d;
    }
    var wi = null;
    function lr(c) {
      wi === null ? wi = [c] : wi.push(c);
    }
    function $n() {
      if (wi !== null) {
        for (var c = 0; c < wi.length; c++) {
          var d = wi[c], G = d.interleaved;
          if (G !== null) {
            d.interleaved = null;
            var w = G.next, H = d.pending;
            if (H !== null) {
              var z = H.next;
              H.next = w, G.next = z;
            }
            d.pending = G;
          }
        }
        wi = null;
      }
    }
    var to = 0, gs = 1, It = 2, st = 3, Zt = !1, Tn, fn;
    Tn = !1, fn = null;
    function ji(c) {
      var d = {
        baseState: c.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Dt
        },
        effects: null
      };
      c.updateQueue = d;
    }
    function $i(c, d) {
      var G = d.updateQueue, w = c.updateQueue;
      if (G === w) {
        var H = {
          baseState: w.baseState,
          firstBaseUpdate: w.firstBaseUpdate,
          lastBaseUpdate: w.lastBaseUpdate,
          shared: w.shared,
          effects: w.effects
        };
        d.updateQueue = H;
      }
    }
    function fr(c, d) {
      var G = {
        eventTime: c,
        lane: d,
        tag: to,
        payload: null,
        callback: null,
        next: null
      };
      return G;
    }
    function xa(c, d, G) {
      var w = c.updateQueue;
      if (w !== null) {
        var H = w.shared;
        if (xs(c)) {
          var z = H.interleaved;
          z === null ? (d.next = d, lr(H)) : (d.next = z.next, z.next = d), H.interleaved = d;
        } else {
          var Q = H.pending;
          Q === null ? d.next = d : (d.next = Q.next, Q.next = d), H.pending = d;
        }
        fn === H && !Tn && (h("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), Tn = !0);
      }
    }
    function mr(c, d, G) {
      var w = d.updateQueue;
      if (w !== null) {
        var H = w.shared;
        if (Wc(G)) {
          var z = H.lanes;
          z = Gu(z, c.pendingLanes);
          var Q = Wi(z, G);
          H.lanes = Q, ys(c, Q);
        }
      }
    }
    function Cl(c, d) {
      var G = c.updateQueue, w = c.alternate;
      if (w !== null) {
        var H = w.updateQueue;
        if (G === H) {
          var z = null, Q = null, re = G.firstBaseUpdate;
          if (re !== null) {
            var ce = re;
            do {
              var Xe = {
                eventTime: ce.eventTime,
                lane: ce.lane,
                tag: ce.tag,
                payload: ce.payload,
                callback: ce.callback,
                next: null
              };
              Q === null ? z = Q = Xe : (Q.next = Xe, Q = Xe), ce = ce.next;
            } while (ce !== null);
            Q === null ? z = Q = d : (Q.next = d, Q = d);
          } else
            z = Q = d;
          G = {
            baseState: H.baseState,
            firstBaseUpdate: z,
            lastBaseUpdate: Q,
            shared: H.shared,
            effects: H.effects
          }, c.updateQueue = G;
          return;
        }
      }
      var Je = G.lastBaseUpdate;
      Je === null ? G.firstBaseUpdate = d : Je.next = d, G.lastBaseUpdate = d;
    }
    function Gp(c, d, G, w, H, z) {
      switch (G.tag) {
        case gs: {
          var Q = G.payload;
          if (typeof Q == "function") {
            Y();
            var re = Q.call(z, w, H);
            {
              if (c.mode & Ma) {
                Ur(!0);
                try {
                  Q.call(z, w, H);
                } finally {
                  Ur(!1);
                }
              }
              L();
            }
            return re;
          }
          return Q;
        }
        case st:
          c.flags = c.flags & ~ut | pi;
        case to: {
          var ce = G.payload, Xe;
          if (typeof ce == "function") {
            Y(), Xe = ce.call(z, w, H);
            {
              if (c.mode & Ma) {
                Ur(!0);
                try {
                  ce.call(z, w, H);
                } finally {
                  Ur(!1);
                }
              }
              L();
            }
          } else
            Xe = ce;
          return Xe == null ? w : b({}, w, Xe);
        }
        case It:
          return Zt = !0, w;
      }
      return w;
    }
    function lC(c, d, G, w) {
      var H = c.updateQueue;
      Zt = !1, fn = H.shared;
      var z = H.firstBaseUpdate, Q = H.lastBaseUpdate, re = H.shared.pending;
      if (re !== null) {
        H.shared.pending = null;
        var ce = re, Xe = ce.next;
        ce.next = null, Q === null ? z = Xe : Q.next = Xe, Q = ce;
        var Je = c.alternate;
        if (Je !== null) {
          var ft = Je.updateQueue, _t = ft.lastBaseUpdate;
          _t !== Q && (_t === null ? ft.firstBaseUpdate = Xe : _t.next = Xe, ft.lastBaseUpdate = ce);
        }
      }
      if (z !== null) {
        var Ut = H.baseState, yn = Dt, xn = null, _i = null, Ar = null, Ui = z;
        do {
          var Bo = Ui.lane, ho = Ui.eventTime;
          if (bu(w, Bo)) {
            if (Ar !== null) {
              var en = {
                eventTime: ho,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: so,
                tag: Ui.tag,
                payload: Ui.payload,
                callback: Ui.callback,
                next: null
              };
              Ar = Ar.next = en;
            }
            Ut = Gp(c, H, Ui, Ut, d, G);
            var Ct = Ui.callback;
            if (Ct !== null && // If the update was already committed, we should not queue its
            // callback again.
            Ui.lane !== so) {
              c.flags |= Xi;
              var Vn = H.effects;
              Vn === null ? H.effects = [Ui] : Vn.push(Ui);
            }
          } else {
            var Rt = {
              eventTime: ho,
              lane: Bo,
              tag: Ui.tag,
              payload: Ui.payload,
              callback: Ui.callback,
              next: null
            };
            Ar === null ? (_i = Ar = Rt, xn = Ut) : Ar = Ar.next = Rt, yn = Wi(yn, Bo);
          }
          if (Ui = Ui.next, Ui === null) {
            if (re = H.shared.pending, re === null)
              break;
            var di = re, si = di.next;
            di.next = null, Ui = si, H.lastBaseUpdate = di, H.shared.pending = null;
          }
        } while (!0);
        Ar === null && (xn = Ut), H.baseState = xn, H.firstBaseUpdate = _i, H.lastBaseUpdate = Ar;
        var Er = H.shared.interleaved;
        if (Er !== null) {
          var Zr = Er;
          do
            yn = Wi(yn, Zr.lane), Zr = Zr.next;
          while (Zr !== Er);
        } else z === null && (H.shared.lanes = Dt);
        W0(yn), c.lanes = yn, c.memoizedState = Ut;
      }
      fn = null;
    }
    function hB(c, d) {
      if (typeof c != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + c));
      c.call(d);
    }
    function Bp() {
      Zt = !1;
    }
    function af() {
      return Zt;
    }
    function zm(c, d, G) {
      var w = d.effects;
      if (d.effects = null, w !== null)
        for (var H = 0; H < w.length; H++) {
          var z = w[H], Q = z.callback;
          Q !== null && (z.callback = null, hB(Q, G));
        }
    }
    var rh = {}, Zg = new i.Component().refs, ql, Ec, oc, ah, uC, Nl, Lr, uv, cv, of;
    {
      ql = /* @__PURE__ */ new Set(), Ec = /* @__PURE__ */ new Set(), oc = /* @__PURE__ */ new Set(), ah = /* @__PURE__ */ new Set(), uv = /* @__PURE__ */ new Set(), uC = /* @__PURE__ */ new Set(), cv = /* @__PURE__ */ new Set(), of = /* @__PURE__ */ new Set();
      var Bs = /* @__PURE__ */ new Set();
      Lr = function(c, d) {
        if (!(c === null || typeof c == "function")) {
          var G = d + "_" + c;
          Bs.has(G) || (Bs.add(G), h("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d, c));
        }
      }, Nl = function(c, d) {
        if (d === void 0) {
          var G = Pe(c) || "Component";
          uC.has(G) || (uC.add(G), h("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", G));
        }
      }, Object.defineProperty(rh, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(rh);
    }
    function Km(c, d, G, w) {
      var H = c.memoizedState, z = G(w, H);
      {
        if (c.mode & Ma) {
          Ur(!0);
          try {
            z = G(w, H);
          } finally {
            Ur(!1);
          }
        }
        Nl(d, z);
      }
      var Q = z == null ? H : b({}, H, z);
      if (c.memoizedState = Q, c.lanes === Dt) {
        var re = c.updateQueue;
        re.baseState = Q;
      }
    }
    var oi = {
      isMounted: or,
      enqueueSetState: function(c, d, G) {
        var w = S(c), H = Yu(), z = ZC(w), Q = fr(H, z);
        Q.payload = d, G != null && (Lr(G, "setState"), Q.callback = G), xa(w, Q);
        var re = pl(w, z, H);
        re !== null && mr(re, w, z), Ps(w, z);
      },
      enqueueReplaceState: function(c, d, G) {
        var w = S(c), H = Yu(), z = ZC(w), Q = fr(H, z);
        Q.tag = gs, Q.payload = d, G != null && (Lr(G, "replaceState"), Q.callback = G), xa(w, Q);
        var re = pl(w, z, H);
        re !== null && mr(re, w, z), Ps(w, z);
      },
      enqueueForceUpdate: function(c, d) {
        var G = S(c), w = Yu(), H = ZC(G), z = fr(w, H);
        z.tag = It, d != null && (Lr(d, "forceUpdate"), z.callback = d), xa(G, z);
        var Q = pl(G, H, w);
        Q !== null && mr(Q, G, H), yg(G, H);
      }
    };
    function cC(c, d, G, w, H, z, Q) {
      var re = c.stateNode;
      if (typeof re.shouldComponentUpdate == "function") {
        var ce = re.shouldComponentUpdate(w, z, Q);
        {
          if (c.mode & Ma) {
            Ur(!0);
            try {
              ce = re.shouldComponentUpdate(w, z, Q);
            } finally {
              Ur(!1);
            }
          }
          ce === void 0 && h("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Pe(d) || "Component");
        }
        return ce;
      }
      return d.prototype && d.prototype.isPureReactComponent ? !uI(G, w) || !uI(H, z) : !0;
    }
    function gv(c, d, G) {
      var w = c.stateNode;
      {
        var H = Pe(d) || "Component", z = w.render;
        z || (d.prototype && typeof d.prototype.render == "function" ? h("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", H) : h("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", H)), w.getInitialState && !w.getInitialState.isReactClassApproved && !w.state && h("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", H), w.getDefaultProps && !w.getDefaultProps.isReactClassApproved && h("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", H), w.propTypes && h("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", H), w.contextType && h("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", H), w.contextTypes && h("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", H), d.contextType && d.contextTypes && !cv.has(d) && (cv.add(d), h("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", H)), typeof w.componentShouldUpdate == "function" && h("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", H), d.prototype && d.prototype.isPureReactComponent && typeof w.shouldComponentUpdate < "u" && h("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Pe(d) || "A pure component"), typeof w.componentDidUnmount == "function" && h("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", H), typeof w.componentDidReceiveProps == "function" && h("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", H), typeof w.componentWillRecieveProps == "function" && h("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", H), typeof w.UNSAFE_componentWillRecieveProps == "function" && h("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", H);
        var Q = w.props !== G;
        w.props !== void 0 && Q && h("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", H, H), w.defaultProps && h("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", H, H), typeof w.getSnapshotBeforeUpdate == "function" && typeof w.componentDidUpdate != "function" && !oc.has(d) && (oc.add(d), h("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Pe(d))), typeof w.getDerivedStateFromProps == "function" && h("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", H), typeof w.getDerivedStateFromError == "function" && h("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", H), typeof d.getSnapshotBeforeUpdate == "function" && h("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", H);
        var re = w.state;
        re && (typeof re != "object" || Mt(re)) && h("%s.state: must be set to an object or null", H), typeof w.getChildContext == "function" && typeof d.childContextTypes != "object" && h("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", H);
      }
    }
    function dv(c, d) {
      d.updater = oi, c.stateNode = d, R(d, c), d._reactInternalInstance = rh;
    }
    function Lm(c, d, G) {
      var w = !1, H = Qr, z = Qr, Q = d.contextType;
      if ("contextType" in d) {
        var re = (
          // Allow null for conditional declaration
          Q === null || Q !== void 0 && Q.$$typeof === Bn && Q._context === void 0
        );
        if (!re && !of.has(d)) {
          of.add(d);
          var ce = "";
          Q === void 0 ? ce = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Q != "object" ? ce = " However, it is set to a " + typeof Q + "." : Q.$$typeof === nn ? ce = " Did you accidentally pass the Context.Provider instead?" : Q._context !== void 0 ? ce = " Did you accidentally pass the Context.Consumer instead?" : ce = " However, it is set to an object with keys {" + Object.keys(Q).join(", ") + "}.", h("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Pe(d) || "Component", ce);
        }
      }
      if (typeof Q == "object" && Q !== null)
        z = mi(Q);
      else {
        H = ps(c, d, !0);
        var Xe = d.contextTypes;
        w = Xe != null, z = w ? oo(c, H) : Qr;
      }
      var Je = new d(G, z);
      if (c.mode & Ma) {
        Ur(!0);
        try {
          Je = new d(G, z);
        } finally {
          Ur(!1);
        }
      }
      var ft = c.memoizedState = Je.state !== null && Je.state !== void 0 ? Je.state : null;
      dv(c, Je);
      {
        if (typeof d.getDerivedStateFromProps == "function" && ft === null) {
          var _t = Pe(d) || "Component";
          Ec.has(_t) || (Ec.add(_t), h("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", _t, Je.state === null ? "null" : "undefined", _t));
        }
        if (typeof d.getDerivedStateFromProps == "function" || typeof Je.getSnapshotBeforeUpdate == "function") {
          var Ut = null, yn = null, xn = null;
          if (typeof Je.componentWillMount == "function" && Je.componentWillMount.__suppressDeprecationWarning !== !0 ? Ut = "componentWillMount" : typeof Je.UNSAFE_componentWillMount == "function" && (Ut = "UNSAFE_componentWillMount"), typeof Je.componentWillReceiveProps == "function" && Je.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? yn = "componentWillReceiveProps" : typeof Je.UNSAFE_componentWillReceiveProps == "function" && (yn = "UNSAFE_componentWillReceiveProps"), typeof Je.componentWillUpdate == "function" && Je.componentWillUpdate.__suppressDeprecationWarning !== !0 ? xn = "componentWillUpdate" : typeof Je.UNSAFE_componentWillUpdate == "function" && (xn = "UNSAFE_componentWillUpdate"), Ut !== null || yn !== null || xn !== null) {
            var _i = Pe(d) || "Component", Ar = typeof d.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            ah.has(_i) || (ah.add(_i), h(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, _i, Ar, Ut !== null ? `
  ` + Ut : "", yn !== null ? `
  ` + yn : "", xn !== null ? `
  ` + xn : ""));
          }
        }
      }
      return w && jI(c, H, z), Je;
    }
    function Sp(c, d) {
      var G = d.state;
      typeof d.componentWillMount == "function" && d.componentWillMount(), typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(), G !== d.state && (h("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", lt(c) || "Component"), oi.enqueueReplaceState(d, d.state, null));
    }
    function sf(c, d, G, w) {
      var H = d.state;
      if (typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(G, w), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(G, w), d.state !== H) {
        {
          var z = lt(c) || "Component";
          ql.has(z) || (ql.add(z), h("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", z));
        }
        oi.enqueueReplaceState(d, d.state, null);
      }
    }
    function Zp(c, d, G, w) {
      gv(c, d, G);
      var H = c.stateNode;
      H.props = G, H.state = c.memoizedState, H.refs = Zg, ji(c);
      var z = d.contextType;
      if (typeof z == "object" && z !== null)
        H.context = mi(z);
      else {
        var Q = ps(c, d, !0);
        H.context = oo(c, Q);
      }
      {
        if (H.state === G) {
          var re = Pe(d) || "Component";
          uv.has(re) || (uv.add(re), h("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", re));
        }
        c.mode & Ma && Wl.recordLegacyContextWarning(c, H), Wl.recordUnsafeLifecycleWarnings(c, H);
      }
      H.state = c.memoizedState;
      var ce = d.getDerivedStateFromProps;
      if (typeof ce == "function" && (Km(c, d, ce, G), H.state = c.memoizedState), typeof d.getDerivedStateFromProps != "function" && typeof H.getSnapshotBeforeUpdate != "function" && (typeof H.UNSAFE_componentWillMount == "function" || typeof H.componentWillMount == "function") && (Sp(c, H), lC(c, G, H, w), H.state = c.memoizedState), typeof H.componentDidMount == "function") {
        var Xe = an;
        Xe |= we, (c.mode & as) !== Oi && (Xe |= Ue), c.flags |= Xe;
      }
    }
    function Iv(c, d, G, w) {
      var H = c.stateNode, z = c.memoizedProps;
      H.props = z;
      var Q = H.context, re = d.contextType, ce = Qr;
      if (typeof re == "object" && re !== null)
        ce = mi(re);
      else {
        var Xe = ps(c, d, !0);
        ce = oo(c, Xe);
      }
      var Je = d.getDerivedStateFromProps, ft = typeof Je == "function" || typeof H.getSnapshotBeforeUpdate == "function";
      !ft && (typeof H.UNSAFE_componentWillReceiveProps == "function" || typeof H.componentWillReceiveProps == "function") && (z !== G || Q !== ce) && sf(c, H, G, ce), Bp();
      var _t = c.memoizedState, Ut = H.state = _t;
      if (lC(c, G, H, w), Ut = c.memoizedState, z === G && _t === Ut && !Jd() && !af()) {
        if (typeof H.componentDidMount == "function") {
          var yn = an;
          yn |= we, (c.mode & as) !== Oi && (yn |= Ue), c.flags |= yn;
        }
        return !1;
      }
      typeof Je == "function" && (Km(c, d, Je, G), Ut = c.memoizedState);
      var xn = af() || cC(c, d, z, G, _t, Ut, ce);
      if (xn) {
        if (!ft && (typeof H.UNSAFE_componentWillMount == "function" || typeof H.componentWillMount == "function") && (typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount()), typeof H.componentDidMount == "function") {
          var _i = an;
          _i |= we, (c.mode & as) !== Oi && (_i |= Ue), c.flags |= _i;
        }
      } else {
        if (typeof H.componentDidMount == "function") {
          var Ar = an;
          Ar |= we, (c.mode & as) !== Oi && (Ar |= Ue), c.flags |= Ar;
        }
        c.memoizedProps = G, c.memoizedState = Ut;
      }
      return H.props = G, H.state = Ut, H.context = ce, xn;
    }
    function Hb(c, d, G, w, H) {
      var z = d.stateNode;
      $i(c, d);
      var Q = d.memoizedProps, re = d.type === d.elementType ? Q : Br(d.type, Q);
      z.props = re;
      var ce = d.pendingProps, Xe = z.context, Je = G.contextType, ft = Qr;
      if (typeof Je == "object" && Je !== null)
        ft = mi(Je);
      else {
        var _t = ps(d, G, !0);
        ft = oo(d, _t);
      }
      var Ut = G.getDerivedStateFromProps, yn = typeof Ut == "function" || typeof z.getSnapshotBeforeUpdate == "function";
      !yn && (typeof z.UNSAFE_componentWillReceiveProps == "function" || typeof z.componentWillReceiveProps == "function") && (Q !== ce || Xe !== ft) && sf(d, z, w, ft), Bp();
      var xn = d.memoizedState, _i = z.state = xn;
      if (lC(d, w, z, H), _i = d.memoizedState, Q === ce && xn === _i && !Jd() && !af() && !M)
        return typeof z.componentDidUpdate == "function" && (Q !== c.memoizedProps || xn !== c.memoizedState) && (d.flags |= an), typeof z.getSnapshotBeforeUpdate == "function" && (Q !== c.memoizedProps || xn !== c.memoizedState) && (d.flags |= zr), !1;
      typeof Ut == "function" && (Km(d, G, Ut, w), _i = d.memoizedState);
      var Ar = af() || cC(d, G, re, w, xn, _i, ft) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      M;
      return Ar ? (!yn && (typeof z.UNSAFE_componentWillUpdate == "function" || typeof z.componentWillUpdate == "function") && (typeof z.componentWillUpdate == "function" && z.componentWillUpdate(w, _i, ft), typeof z.UNSAFE_componentWillUpdate == "function" && z.UNSAFE_componentWillUpdate(w, _i, ft)), typeof z.componentDidUpdate == "function" && (d.flags |= an), typeof z.getSnapshotBeforeUpdate == "function" && (d.flags |= zr)) : (typeof z.componentDidUpdate == "function" && (Q !== c.memoizedProps || xn !== c.memoizedState) && (d.flags |= an), typeof z.getSnapshotBeforeUpdate == "function" && (Q !== c.memoizedProps || xn !== c.memoizedState) && (d.flags |= zr), d.memoizedProps = w, d.memoizedState = _i), z.props = w, z.state = _i, z.context = ft, Ar;
    }
    var gC = [], dC = 0, IC = null, Wo = 0, Wa = [], no = 0, $l = null, Ru = 1, Vo = "";
    function dI(c) {
      return Sr(), (c.flags & Tt) !== _e;
    }
    function Cd(c) {
      return Sr(), Wo;
    }
    function fB() {
      var c = Vo, d = Ru, G = d & ~Xb(d);
      return G.toString(32) + c;
    }
    function CC(c, d) {
      Sr(), gC[dC++] = Wo, gC[dC++] = IC, IC = c, Wo = d;
    }
    function km(c, d, G) {
      Sr(), Wa[no++] = Ru, Wa[no++] = Vo, Wa[no++] = $l, $l = c;
      var w = Ru, H = Vo, z = wp(w) - 1, Q = w & ~(1 << z), re = G + 1, ce = wp(d) + z;
      if (ce > 30) {
        var Xe = z - z % 5, Je = (1 << Xe) - 1, ft = (Q & Je).toString(32), _t = Q >> Xe, Ut = z - Xe, yn = wp(d) + Ut, xn = re << Ut, _i = xn | _t, Ar = ft + H;
        Ru = 1 << yn | _i, Vo = Ar;
      } else {
        var Ui = re << z, Bo = Ui | Q, ho = H;
        Ru = 1 << ce | Bo, Vo = ho;
      }
    }
    function hC(c) {
      Sr();
      var d = c.return;
      if (d !== null) {
        var G = 1, w = 0;
        CC(c, G), km(c, G, w);
      }
    }
    function wp(c) {
      return 32 - bp(c);
    }
    function Xb(c) {
      return 1 << wp(c) - 1;
    }
    function lf(c) {
      for (; c === IC; )
        IC = gC[--dC], gC[dC] = null, Wo = gC[--dC], gC[dC] = null;
      for (; c === $l; )
        $l = Wa[--no], Wa[no] = null, Vo = Wa[--no], Wa[no] = null, Ru = Wa[--no], Wa[no] = null;
    }
    function uf() {
      return Sr(), $l !== null ? {
        id: Ru,
        overflow: Vo
      } : null;
    }
    function sc(c, d) {
      Sr(), Wa[no++] = Ru, Wa[no++] = Vo, Wa[no++] = $l, Ru = d.id, Vo = d.overflow, $l = c;
    }
    function Sr() {
      ka() || h("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Vr = null, Pr = null, ga = !1, $o = !1, xu = null;
    function Ss() {
      ga && h("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function Rp() {
      $o = !0;
    }
    function oh(c) {
      if (!Hr)
        return !1;
      var d = c.stateNode.containerInfo;
      return Pr = qg(d), Vr = c, ga = !0, xu = null, $o = !1, !0;
    }
    function Dm(c, d, G) {
      return Hr ? (Pr = DI(d), Vr = c, ga = !0, xu = null, $o = !1, G !== null && sc(c, G), !0) : !1;
    }
    function cf(c, d) {
      switch (c.tag) {
        case te:
          Uh(c.stateNode.containerInfo, d);
          break;
        case pe:
          hu(c.type, c.memoizedProps, c.stateNode, d);
          break;
        case le:
          var G = c.memoizedState;
          G.dehydrated !== null && Cu(G.dehydrated, d);
          break;
      }
    }
    function gf(c, d) {
      cf(c, d);
      var G = sx();
      G.stateNode = d, G.return = c;
      var w = c.deletions;
      w === null ? (c.deletions = [G], c.flags |= xi) : w.push(G);
    }
    function Zs(c, d) {
      {
        if ($o)
          return;
        switch (c.tag) {
          case te: {
            var G = c.stateNode.containerInfo;
            switch (d.tag) {
              case pe:
                var w = d.type, H = d.pendingProps;
                ol(G, w, H);
                break;
              case Ae:
                var z = d.pendingProps;
                cg(G, z);
                break;
              case le:
                Du(G);
                break;
            }
            break;
          }
          case pe: {
            var Q = c.type, re = c.memoizedProps, ce = c.stateNode;
            switch (d.tag) {
              case pe:
                var Xe = d.type, Je = d.pendingProps;
                Es(Q, re, ce, Xe, Je);
                break;
              case Ae:
                var ft = d.pendingProps;
                Uu(Q, re, ce, ft);
                break;
              case le:
                Kr(Q, re, ce);
                break;
            }
            break;
          }
          case le: {
            var _t = c.memoizedState, Ut = _t.dehydrated;
            if (Ut !== null) switch (d.tag) {
              case pe:
                var yn = d.type, xn = d.pendingProps;
                gg(Ut, yn, xn);
                break;
              case Ae:
                var _i = d.pendingProps;
                Sc(Ut, _i);
                break;
              case le:
                mp(Ut);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function df(c, d) {
      d.flags = d.flags & ~la | Ht, Zs(c, d);
    }
    function fC(c, d) {
      switch (c.tag) {
        case pe: {
          var G = c.type, w = c.pendingProps, H = Yr(d, G, w);
          return H !== null ? (c.stateNode = H, Vr = c, Pr = Tl(H), !0) : !1;
        }
        case Ae: {
          var z = c.pendingProps, Q = hr(d, z);
          return Q !== null ? (c.stateNode = Q, Vr = c, Pr = null, !0) : !1;
        }
        case le: {
          {
            var re = vr(d);
            if (re !== null) {
              var ce = {
                dehydrated: re,
                treeContext: uf(),
                retryLane: ks
              };
              c.memoizedState = ce;
              var Xe = lx(re);
              return Xe.return = c, c.child = Xe, Vr = c, Pr = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function wg(c) {
      return (c.mode & Rr) !== Oi && (c.flags & pi) === _e;
    }
    function If(c) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function xp(c) {
      if (ga) {
        var d = Pr;
        if (!d) {
          wg(c) && (Zs(Vr, c), If()), df(Vr, c), ga = !1, Vr = c;
          return;
        }
        var G = d;
        if (!fC(c, d)) {
          wg(c) && (Zs(Vr, c), If()), d = Qo(G);
          var w = Vr;
          if (!d || !fC(c, d)) {
            df(Vr, c), ga = !1, Vr = c;
            return;
          }
          gf(w, G);
        }
      }
    }
    function pC(c, d, G) {
      if (!Hr)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var w = c.stateNode, H = !$o, z = Iu(w, c.type, c.memoizedProps, d, G, c, H);
      return c.updateQueue = z, z !== null;
    }
    function mC(c) {
      if (!Hr)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = c.stateNode, G = c.memoizedProps, w = !$o, H = UI(d, G, c, w);
      if (H) {
        var z = Vr;
        if (z !== null) {
          var Q = (z.mode & Rr) !== Oi;
          switch (z.tag) {
            case te: {
              var re = z.stateNode.containerInfo;
              Dd(
                re,
                d,
                G,
                // TODO: Delete this argument when we remove the legacy root API.
                Q
              );
              break;
            }
            case pe: {
              var ce = z.type, Xe = z.memoizedProps, Je = z.stateNode;
              ug(
                ce,
                Xe,
                Je,
                d,
                G,
                // TODO: Delete this argument when we remove the legacy root API.
                Q
              );
              break;
            }
          }
        }
      }
      return H;
    }
    function hd(c) {
      if (!Hr)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = c.memoizedState, G = d !== null ? d.dehydrated : null;
      if (!G)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      OI(G, c);
    }
    function AC(c) {
      if (!Hr)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = c.memoizedState, G = d !== null ? d.dehydrated : null;
      if (!G)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return DC(G);
    }
    function Cf(c) {
      for (var d = c.return; d !== null && d.tag !== pe && d.tag !== te && d.tag !== le; )
        d = d.return;
      Vr = d;
    }
    function sh(c) {
      if (!Hr || c !== Vr)
        return !1;
      if (!ga)
        return Cf(c), ga = !0, !1;
      if (c.tag !== te && (c.tag !== pe || Dh(c.type) && !Si(c.type, c.memoizedProps))) {
        var d = Pr;
        if (d)
          if (wg(c))
            hf(c), If();
          else
            for (; d; )
              gf(c, d), d = Qo(d);
      }
      return Cf(c), c.tag === le ? Pr = AC(c) : Pr = Vr ? Qo(c.stateNode) : null, !0;
    }
    function Wp() {
      return ga && Pr !== null;
    }
    function hf(c) {
      for (var d = Pr; d; )
        cf(c, d), d = Qo(d);
    }
    function No() {
      Hr && (Vr = null, Pr = null, ga = !1, $o = !1);
    }
    function Tc() {
      xu !== null && (dS(xu), xu = null);
    }
    function ka() {
      return ga;
    }
    function Ya(c) {
      xu === null ? xu = [c] : xu.push(c);
    }
    var II, lh, CI, Cv, _c, Vp = function(c, d) {
    };
    II = !1, lh = !1, CI = {}, Cv = {}, _c = {}, Vp = function(c, d) {
      if (!(c === null || typeof c != "object") && !(!c._store || c._store.validated || c.key != null)) {
        if (typeof c._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        c._store.validated = !0;
        var G = lt(d) || "Component";
        Cv[G] || (Cv[G] = !0, h('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Rg(c, d, G) {
      var w = G.ref;
      if (w !== null && typeof w != "function" && typeof w != "object") {
        if ((c.mode & Ma || _) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(G._owner && G._self && G._owner.stateNode !== G._self)) {
          var H = lt(c) || "Component";
          CI[H] || (h('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', w), CI[H] = !0);
        }
        if (G._owner) {
          var z = G._owner, Q;
          if (z) {
            var re = z;
            if (re.tag !== O)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            Q = re.stateNode;
          }
          if (!Q)
            throw new Error("Missing owner for string ref " + w + ". This error is likely caused by a bug in React. Please file an issue.");
          var ce = Q;
          _m(w, "ref");
          var Xe = "" + w;
          if (d !== null && d.ref !== null && typeof d.ref == "function" && d.ref._stringRef === Xe)
            return d.ref;
          var Je = function(ft) {
            var _t = ce.refs;
            _t === Zg && (_t = ce.refs = {}), ft === null ? delete _t[Xe] : _t[Xe] = ft;
          };
          return Je._stringRef = Xe, Je;
        } else {
          if (typeof w != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!G._owner)
            throw new Error("Element ref was specified as a string (" + w + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return w;
    }
    function fd(c, d) {
      var G = Object.prototype.toString.call(d);
      throw new Error("Objects are not valid as a React child (found: " + (G === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : G) + "). If you meant to render a collection of children, use an array instead.");
    }
    function hI(c) {
      {
        var d = lt(c) || "Component";
        if (_c[d])
          return;
        _c[d] = !0, h("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function fI(c) {
      var d = c._payload, G = c._init;
      return G(d);
    }
    function hv(c) {
      function d(Rt, en) {
        if (c) {
          var Ct = Rt.deletions;
          Ct === null ? (Rt.deletions = [en], Rt.flags |= xi) : Ct.push(en);
        }
      }
      function G(Rt, en) {
        if (!c)
          return null;
        for (var Ct = en; Ct !== null; )
          d(Rt, Ct), Ct = Ct.sibling;
        return null;
      }
      function w(Rt, en) {
        for (var Ct = /* @__PURE__ */ new Map(), Vn = en; Vn !== null; )
          Vn.key !== null ? Ct.set(Vn.key, Vn) : Ct.set(Vn.index, Vn), Vn = Vn.sibling;
        return Ct;
      }
      function H(Rt, en) {
        var Ct = Lf(Rt, en);
        return Ct.index = 0, Ct.sibling = null, Ct;
      }
      function z(Rt, en, Ct) {
        if (Rt.index = Ct, !c)
          return Rt.flags |= Tt, en;
        var Vn = Rt.alternate;
        if (Vn !== null) {
          var di = Vn.index;
          return di < en ? (Rt.flags |= Ht, en) : di;
        } else
          return Rt.flags |= Ht, en;
      }
      function Q(Rt) {
        return c && Rt.alternate === null && (Rt.flags |= Ht), Rt;
      }
      function re(Rt, en, Ct, Vn) {
        if (en === null || en.tag !== Ae) {
          var di = F0(Ct, Rt.mode, Vn);
          return di.return = Rt, di;
        } else {
          var si = H(en, Ct);
          return si.return = Rt, si;
        }
      }
      function ce(Rt, en, Ct, Vn) {
        var di = Ct.type;
        if (di === tn)
          return Je(Rt, en, Ct.props.children, Vn, Ct.key);
        if (en !== null && (en.elementType === di || // Keep this check inline so it only runs on the false path:
        on(en, Ct) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof di == "object" && di !== null && di.$$typeof === pt && fI(di) === en.type)) {
          var si = H(en, Ct.props);
          return si.ref = Rg(Rt, en, Ct), si.return = Rt, si._debugSource = Ct._source, si._debugOwner = Ct._owner, si;
        }
        var Er = my(Ct, Rt.mode, Vn);
        return Er.ref = Rg(Rt, en, Ct), Er.return = Rt, Er;
      }
      function Xe(Rt, en, Ct, Vn) {
        if (en === null || en.tag !== fe || en.stateNode.containerInfo !== Ct.containerInfo || en.stateNode.implementation !== Ct.implementation) {
          var di = E0(Ct, Rt.mode, Vn);
          return di.return = Rt, di;
        } else {
          var si = H(en, Ct.children || []);
          return si.return = Rt, si;
        }
      }
      function Je(Rt, en, Ct, Vn, di) {
        if (en === null || en.tag !== Te) {
          var si = sm(Ct, Rt.mode, Vn, di);
          return si.return = Rt, si;
        } else {
          var Er = H(en, Ct);
          return Er.return = Rt, Er;
        }
      }
      function ft(Rt, en, Ct) {
        if (typeof en == "string" && en !== "" || typeof en == "number") {
          var Vn = F0("" + en, Rt.mode, Ct);
          return Vn.return = Rt, Vn;
        }
        if (typeof en == "object" && en !== null) {
          switch (en.$$typeof) {
            case Lt: {
              var di = my(en, Rt.mode, Ct);
              return di.ref = Rg(Rt, null, en), di.return = Rt, di;
            }
            case Wt: {
              var si = E0(en, Rt.mode, Ct);
              return si.return = Rt, si;
            }
            case pt: {
              var Er = en._payload, Zr = en._init;
              return ft(Rt, Zr(Er), Ct);
            }
          }
          if (Mt(en) || Ie(en)) {
            var Ua = sm(en, Rt.mode, Ct, null);
            return Ua.return = Rt, Ua;
          }
          fd(Rt, en);
        }
        return typeof en == "function" && hI(Rt), null;
      }
      function _t(Rt, en, Ct, Vn) {
        var di = en !== null ? en.key : null;
        if (typeof Ct == "string" && Ct !== "" || typeof Ct == "number")
          return di !== null ? null : re(Rt, en, "" + Ct, Vn);
        if (typeof Ct == "object" && Ct !== null) {
          switch (Ct.$$typeof) {
            case Lt:
              return Ct.key === di ? ce(Rt, en, Ct, Vn) : null;
            case Wt:
              return Ct.key === di ? Xe(Rt, en, Ct, Vn) : null;
            case pt: {
              var si = Ct._payload, Er = Ct._init;
              return _t(Rt, en, Er(si), Vn);
            }
          }
          if (Mt(Ct) || Ie(Ct))
            return di !== null ? null : Je(Rt, en, Ct, Vn, null);
          fd(Rt, Ct);
        }
        return typeof Ct == "function" && hI(Rt), null;
      }
      function Ut(Rt, en, Ct, Vn, di) {
        if (typeof Vn == "string" && Vn !== "" || typeof Vn == "number") {
          var si = Rt.get(Ct) || null;
          return re(en, si, "" + Vn, di);
        }
        if (typeof Vn == "object" && Vn !== null) {
          switch (Vn.$$typeof) {
            case Lt: {
              var Er = Rt.get(Vn.key === null ? Ct : Vn.key) || null;
              return ce(en, Er, Vn, di);
            }
            case Wt: {
              var Zr = Rt.get(Vn.key === null ? Ct : Vn.key) || null;
              return Xe(en, Zr, Vn, di);
            }
            case pt: {
              var Ua = Vn._payload, pa = Vn._init;
              return Ut(Rt, en, Ct, pa(Ua), di);
            }
          }
          if (Mt(Vn) || Ie(Vn)) {
            var Eo = Rt.get(Ct) || null;
            return Je(en, Eo, Vn, di, null);
          }
          fd(en, Vn);
        }
        return typeof Vn == "function" && hI(en), null;
      }
      function yn(Rt, en, Ct) {
        {
          if (typeof Rt != "object" || Rt === null)
            return en;
          switch (Rt.$$typeof) {
            case Lt:
            case Wt:
              Vp(Rt, Ct);
              var Vn = Rt.key;
              if (typeof Vn != "string")
                break;
              if (en === null) {
                en = /* @__PURE__ */ new Set(), en.add(Vn);
                break;
              }
              if (!en.has(Vn)) {
                en.add(Vn);
                break;
              }
              h("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Vn);
              break;
            case pt: {
              var di = Rt._payload, si = Rt._init;
              yn(si(di), en, Ct);
              break;
            }
          }
        }
        return en;
      }
      function xn(Rt, en, Ct, Vn) {
        for (var di = null, si = 0; si < Ct.length; si++) {
          var Er = Ct[si];
          di = yn(Er, di, Rt);
        }
        for (var Zr = null, Ua = null, pa = en, Eo = 0, aa = 0, wr = null; pa !== null && aa < Ct.length; aa++) {
          pa.index > aa ? (wr = pa, pa = null) : wr = pa.sibling;
          var ts = _t(Rt, pa, Ct[aa], Vn);
          if (ts === null) {
            pa === null && (pa = wr);
            break;
          }
          c && pa && ts.alternate === null && d(Rt, pa), Eo = z(ts, Eo, aa), Ua === null ? Zr = ts : Ua.sibling = ts, Ua = ts, pa = wr;
        }
        if (aa === Ct.length) {
          if (G(Rt, pa), ka()) {
            var Oo = aa;
            CC(Rt, Oo);
          }
          return Zr;
        }
        if (pa === null) {
          for (; aa < Ct.length; aa++) {
            var dc = ft(Rt, Ct[aa], Vn);
            dc !== null && (Eo = z(dc, Eo, aa), Ua === null ? Zr = dc : Ua.sibling = dc, Ua = dc);
          }
          if (ka()) {
            var Al = aa;
            CC(Rt, Al);
          }
          return Zr;
        }
        for (var Ic = w(Rt, pa); aa < Ct.length; aa++) {
          var Cc = Ut(Ic, Rt, aa, Ct[aa], Vn);
          Cc !== null && (c && Cc.alternate !== null && Ic.delete(Cc.key === null ? aa : Cc.key), Eo = z(Cc, Eo, aa), Ua === null ? Zr = Cc : Ua.sibling = Cc, Ua = Cc);
        }
        if (c && Ic.forEach(function(um) {
          return d(Rt, um);
        }), ka()) {
          var Oc = aa;
          CC(Rt, Oc);
        }
        return Zr;
      }
      function _i(Rt, en, Ct, Vn) {
        var di = Ie(Ct);
        if (typeof di != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Ct[Symbol.toStringTag] === "Generator" && (lh || h("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), lh = !0), Ct.entries === di && (II || h("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), II = !0);
          var si = di.call(Ct);
          if (si)
            for (var Er = null, Zr = si.next(); !Zr.done; Zr = si.next()) {
              var Ua = Zr.value;
              Er = yn(Ua, Er, Rt);
            }
        }
        var pa = di.call(Ct);
        if (pa == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Eo = null, aa = null, wr = en, ts = 0, Oo = 0, dc = null, Al = pa.next(); wr !== null && !Al.done; Oo++, Al = pa.next()) {
          wr.index > Oo ? (dc = wr, wr = null) : dc = wr.sibling;
          var Ic = _t(Rt, wr, Al.value, Vn);
          if (Ic === null) {
            wr === null && (wr = dc);
            break;
          }
          c && wr && Ic.alternate === null && d(Rt, wr), ts = z(Ic, ts, Oo), aa === null ? Eo = Ic : aa.sibling = Ic, aa = Ic, wr = dc;
        }
        if (Al.done) {
          if (G(Rt, wr), ka()) {
            var Cc = Oo;
            CC(Rt, Cc);
          }
          return Eo;
        }
        if (wr === null) {
          for (; !Al.done; Oo++, Al = pa.next()) {
            var Oc = ft(Rt, Al.value, Vn);
            Oc !== null && (ts = z(Oc, ts, Oo), aa === null ? Eo = Oc : aa.sibling = Oc, aa = Oc);
          }
          if (ka()) {
            var um = Oo;
            CC(Rt, um);
          }
          return Eo;
        }
        for (var kf = w(Rt, wr); !Al.done; Oo++, Al = pa.next()) {
          var hc = Ut(kf, Rt, Oo, Al.value, Vn);
          hc !== null && (c && hc.alternate !== null && kf.delete(hc.key === null ? Oo : hc.key), ts = z(hc, ts, Oo), aa === null ? Eo = hc : aa.sibling = hc, aa = hc);
        }
        if (c && kf.forEach(function(TS) {
          return d(Rt, TS);
        }), ka()) {
          var Df = Oo;
          CC(Rt, Df);
        }
        return Eo;
      }
      function Ar(Rt, en, Ct, Vn) {
        if (en !== null && en.tag === Ae) {
          G(Rt, en.sibling);
          var di = H(en, Ct);
          return di.return = Rt, di;
        }
        G(Rt, en);
        var si = F0(Ct, Rt.mode, Vn);
        return si.return = Rt, si;
      }
      function Ui(Rt, en, Ct, Vn) {
        for (var di = Ct.key, si = en; si !== null; ) {
          if (si.key === di) {
            var Er = Ct.type;
            if (Er === tn) {
              if (si.tag === Te) {
                G(Rt, si.sibling);
                var Zr = H(si, Ct.props.children);
                return Zr.return = Rt, Zr._debugSource = Ct._source, Zr._debugOwner = Ct._owner, Zr;
              }
            } else if (si.elementType === Er || // Keep this check inline so it only runs on the false path:
            on(si, Ct) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Er == "object" && Er !== null && Er.$$typeof === pt && fI(Er) === si.type) {
              G(Rt, si.sibling);
              var Ua = H(si, Ct.props);
              return Ua.ref = Rg(Rt, si, Ct), Ua.return = Rt, Ua._debugSource = Ct._source, Ua._debugOwner = Ct._owner, Ua;
            }
            G(Rt, si);
            break;
          } else
            d(Rt, si);
          si = si.sibling;
        }
        if (Ct.type === tn) {
          var pa = sm(Ct.props.children, Rt.mode, Vn, Ct.key);
          return pa.return = Rt, pa;
        } else {
          var Eo = my(Ct, Rt.mode, Vn);
          return Eo.ref = Rg(Rt, en, Ct), Eo.return = Rt, Eo;
        }
      }
      function Bo(Rt, en, Ct, Vn) {
        for (var di = Ct.key, si = en; si !== null; ) {
          if (si.key === di)
            if (si.tag === fe && si.stateNode.containerInfo === Ct.containerInfo && si.stateNode.implementation === Ct.implementation) {
              G(Rt, si.sibling);
              var Er = H(si, Ct.children || []);
              return Er.return = Rt, Er;
            } else {
              G(Rt, si);
              break;
            }
          else
            d(Rt, si);
          si = si.sibling;
        }
        var Zr = E0(Ct, Rt.mode, Vn);
        return Zr.return = Rt, Zr;
      }
      function ho(Rt, en, Ct, Vn) {
        var di = typeof Ct == "object" && Ct !== null && Ct.type === tn && Ct.key === null;
        if (di && (Ct = Ct.props.children), typeof Ct == "object" && Ct !== null) {
          switch (Ct.$$typeof) {
            case Lt:
              return Q(Ui(Rt, en, Ct, Vn));
            case Wt:
              return Q(Bo(Rt, en, Ct, Vn));
            case pt: {
              var si = Ct._payload, Er = Ct._init;
              return ho(Rt, en, Er(si), Vn);
            }
          }
          if (Mt(Ct))
            return xn(Rt, en, Ct, Vn);
          if (Ie(Ct))
            return _i(Rt, en, Ct, Vn);
          fd(Rt, Ct);
        }
        return typeof Ct == "string" && Ct !== "" || typeof Ct == "number" ? Q(Ar(Rt, en, "" + Ct, Vn)) : (typeof Ct == "function" && hI(Rt), G(Rt, en));
      }
      return ho;
    }
    var uh = hv(!0), Um = hv(!1);
    function ff(c, d) {
      if (c !== null && d.child !== c.child)
        throw new Error("Resuming work not yet implemented.");
      if (d.child !== null) {
        var G = d.child, w = Lf(G, G.pendingProps);
        for (d.child = w, w.return = d; G.sibling !== null; )
          G = G.sibling, w = w.sibling = Lf(G, G.pendingProps), w.return = d;
        w.sibling = null;
      }
    }
    function pB(c, d) {
      for (var G = c.child; G !== null; )
        GS(G, d), G = G.sibling;
    }
    var Np = {}, pI = fu(Np), pf = fu(Np), pd = fu(Np);
    function Mp(c) {
      if (c === Np)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function vC() {
      var c = Mp(pd.current);
      return c;
    }
    function Om(c, d) {
      ao(pd, d, c), ao(pf, c, c), ao(pI, Np, c);
      var G = Ai(d);
      va(pI, c), ao(pI, G, c);
    }
    function Da(c) {
      va(pI, c), va(pf, c), va(pd, c);
    }
    function Hp() {
      var c = Mp(pI.current);
      return c;
    }
    function fv(c) {
      var d = Mp(pd.current), G = Mp(pI.current), w = ve(G, c.type, d);
      G !== w && (ao(pf, c, c), ao(pI, w, c));
    }
    function pv(c) {
      pf.current === c && (va(pI, c), va(pf, c));
    }
    var mv = 0, Av = 1, vv = 1, Xp = 2, Mo = fu(mv);
    function Yp(c, d) {
      return (c & d) !== 0;
    }
    function mf(c) {
      return c & Av;
    }
    function md(c, d) {
      return c & Av | d;
    }
    function Pm(c, d) {
      return c | d;
    }
    function Wu(c, d) {
      ao(Mo, d, c);
    }
    function mI(c) {
      va(Mo, c);
    }
    function yv(c, d) {
      var G = c.memoizedState;
      return G !== null ? G.dehydrated !== null : (c.memoizedProps, !0);
    }
    function ch(c) {
      for (var d = c; d !== null; ) {
        if (d.tag === le) {
          var G = d.memoizedState;
          if (G !== null) {
            var w = G.dehydrated;
            if (w === null || br(w) || Ia(w))
              return d;
          }
        } else if (d.tag === St && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        d.memoizedProps.revealOrder !== void 0) {
          var H = (d.flags & pi) !== _e;
          if (H)
            return d;
        } else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === c)
          return null;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === c)
            return null;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return null;
    }
    var zc = (
      /*   */
      0
    ), Va = (
      /* */
      1
    ), yC = (
      /*  */
      2
    ), Ho = (
      /*    */
      4
    ), ws = (
      /*   */
      8
    ), gh = [];
    function Af() {
      for (var c = 0; c < gh.length; c++) {
        var d = gh[c];
        ti ? d._workInProgressVersionPrimary = null : d._workInProgressVersionSecondary = null;
      }
      gh.length = 0;
    }
    function bv(c, d) {
      var G = d._getVersion, w = G(d._source);
      c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [d, w] : c.mutableSourceEagerHydrationData.push(d, w);
    }
    var Qn = l.ReactCurrentDispatcher, Vu = l.ReactCurrentBatchConfig, Jm, AI;
    Jm = /* @__PURE__ */ new Set();
    var Ad = Dt, fa = null, yo = null, ds = null, Qm = !1, bC = !1, Fp = 0, Ep = 0, mB = 25, jt = null, g = null, C = -1, B = !1;
    function N() {
      {
        var c = jt;
        g === null ? g = [c] : g.push(c);
      }
    }
    function F() {
      {
        var c = jt;
        g !== null && (C++, g[C] !== c && se(c));
      }
    }
    function D(c) {
      c != null && !Mt(c) && h("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", jt, typeof c);
    }
    function se(c) {
      {
        var d = lt(fa);
        if (!Jm.has(d) && (Jm.add(d), g !== null)) {
          for (var G = "", w = 30, H = 0; H <= C; H++) {
            for (var z = g[H], Q = H === C ? c : z, re = H + 1 + ". " + z; re.length < w; )
              re += " ";
            re += Q + `
`, G += re;
          }
          h(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, d, G);
        }
      }
    }
    function He() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function Qe(c, d) {
      if (B)
        return !1;
      if (d === null)
        return h("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", jt), !1;
      c.length !== d.length && h(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, jt, "[" + d.join(", ") + "]", "[" + c.join(", ") + "]");
      for (var G = 0; G < d.length && G < c.length; G++)
        if (!Js(c[G], d[G]))
          return !1;
      return !0;
    }
    function xt(c, d, G, w, H, z) {
      Ad = z, fa = d, g = c !== null ? c._debugHookTypes : null, C = -1, B = c !== null && c.type !== d.type, d.memoizedState = null, d.updateQueue = null, d.lanes = Dt, c !== null && c.memoizedState !== null ? Qn.current = bo : g !== null ? Qn.current = oR : Qn.current = ZB;
      var Q = G(w, H);
      if (bC) {
        var re = 0;
        do {
          if (bC = !1, Fp = 0, re >= mB)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          re += 1, B = !1, yo = null, ds = null, d.updateQueue = null, C = -1, Qn.current = Jb, Q = G(w, H);
        } while (bC);
      }
      Qn.current = Pb, d._debugHookTypes = g;
      var ce = yo !== null && yo.next !== null;
      if (Ad = Dt, fa = null, yo = null, ds = null, jt = null, g = null, C = -1, c !== null && (c.flags & Yn) !== (d.flags & Yn) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (c.mode & Rr) !== Oi && h("Internal React error: Expected static flag was missing. Please notify the React team."), Qm = !1, ce)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return Q;
    }
    function Cn() {
      var c = Fp !== 0;
      return Fp = 0, c;
    }
    function Gn(c, d, G) {
      d.updateQueue = c.updateQueue, (d.mode & as) !== Oi ? d.flags &= ~(Oe | Ue | na | an) : d.flags &= ~(na | an), c.lanes = uo(c.lanes, G);
    }
    function pn() {
      if (Qn.current = Pb, Qm) {
        for (var c = fa.memoizedState; c !== null; ) {
          var d = c.queue;
          d !== null && (d.pending = null), c = c.next;
        }
        Qm = !1;
      }
      Ad = Dt, fa = null, yo = null, ds = null, g = null, C = -1, jt = null, BB = !1, bC = !1, Fp = 0;
    }
    function Dn() {
      var c = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return ds === null ? fa.memoizedState = ds = c : ds = ds.next = c, ds;
    }
    function ei() {
      var c;
      if (yo === null) {
        var d = fa.alternate;
        d !== null ? c = d.memoizedState : c = null;
      } else
        c = yo.next;
      var G;
      if (ds === null ? G = fa.memoizedState : G = ds.next, G !== null)
        ds = G, G = ds.next, yo = c;
      else {
        if (c === null)
          throw new Error("Rendered more hooks than during the previous render.");
        yo = c;
        var w = {
          memoizedState: yo.memoizedState,
          baseState: yo.baseState,
          baseQueue: yo.baseQueue,
          queue: yo.queue,
          next: null
        };
        ds === null ? fa.memoizedState = ds = w : ds = ds.next = w;
      }
      return ds;
    }
    function bi() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Xo(c, d) {
      return typeof d == "function" ? d(c) : d;
    }
    function dt(c, d, G) {
      var w = Dn(), H;
      G !== void 0 ? H = G(d) : H = d, w.memoizedState = w.baseState = H;
      var z = {
        pending: null,
        interleaved: null,
        lanes: Dt,
        dispatch: null,
        lastRenderedReducer: c,
        lastRenderedState: H
      };
      w.queue = z;
      var Q = z.dispatch = yf.bind(null, fa, z);
      return [w.memoizedState, Q];
    }
    function tt(c, d, G) {
      var w = ei(), H = w.queue;
      if (H === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      H.lastRenderedReducer = c;
      var z = yo, Q = z.baseQueue, re = H.pending;
      if (re !== null) {
        if (Q !== null) {
          var ce = Q.next, Xe = re.next;
          Q.next = Xe, re.next = ce;
        }
        z.baseQueue !== Q && h("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), z.baseQueue = Q = re, H.pending = null;
      }
      if (Q !== null) {
        var Je = Q.next, ft = z.baseState, _t = null, Ut = null, yn = null, xn = Je;
        do {
          var _i = xn.lane;
          if (bu(Ad, _i)) {
            if (yn !== null) {
              var Ui = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: so,
                action: xn.action,
                hasEagerState: xn.hasEagerState,
                eagerState: xn.eagerState,
                next: null
              };
              yn = yn.next = Ui;
            }
            if (xn.hasEagerState)
              ft = xn.eagerState;
            else {
              var Bo = xn.action;
              ft = c(ft, Bo);
            }
          } else {
            var Ar = {
              lane: _i,
              action: xn.action,
              hasEagerState: xn.hasEagerState,
              eagerState: xn.eagerState,
              next: null
            };
            yn === null ? (Ut = yn = Ar, _t = ft) : yn = yn.next = Ar, fa.lanes = Wi(fa.lanes, _i), W0(_i);
          }
          xn = xn.next;
        } while (xn !== null && xn !== Je);
        yn === null ? _t = ft : yn.next = Ut, Js(ft, w.memoizedState) || u0(), w.memoizedState = ft, w.baseState = _t, w.baseQueue = yn, H.lastRenderedState = ft;
      }
      var ho = H.interleaved;
      if (ho !== null) {
        var Rt = ho;
        do {
          var en = Rt.lane;
          fa.lanes = Wi(fa.lanes, en), W0(en), Rt = Rt.next;
        } while (Rt !== ho);
      } else Q === null && (H.lanes = Dt);
      var Ct = H.dispatch;
      return [w.memoizedState, Ct];
    }
    function yt(c, d, G) {
      var w = ei(), H = w.queue;
      if (H === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      H.lastRenderedReducer = c;
      var z = H.dispatch, Q = H.pending, re = w.memoizedState;
      if (Q !== null) {
        H.pending = null;
        var ce = Q.next, Xe = ce;
        do {
          var Je = Xe.action;
          re = c(re, Je), Xe = Xe.next;
        } while (Xe !== ce);
        Js(re, w.memoizedState) || u0(), w.memoizedState = re, w.baseQueue === null && (w.baseState = re), H.lastRenderedState = re;
      }
      return [re, z];
    }
    function Mn(c, d, G) {
    }
    function Vi(c, d, G) {
    }
    function Ti(c, d, G) {
      var w = fa, H = Dn(), z, Q = ka();
      if (Q) {
        if (G === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        z = G(), AI || z !== G() && (h("The result of getServerSnapshot should be cached to avoid an infinite loop"), AI = !0);
      } else {
        if (z = d(), !AI) {
          var re = d();
          Js(z, re) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), AI = !0);
        }
        var ce = ay();
        if (ce === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        tC(ce, Ad) || Ri(w, d, z);
      }
      H.memoizedState = z;
      var Xe = {
        value: z,
        getSnapshot: d
      };
      return H.queue = Xe, Tp(ea.bind(null, w, Xe, c), [c]), w.flags |= na, jm(Va | ws, Yo.bind(null, w, Xe, z, d), void 0, null), z;
    }
    function Fi(c, d, G) {
      var w = fa, H = ei(), z = d();
      if (!AI) {
        var Q = d();
        Js(z, Q) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), AI = !0);
      }
      var re = H.memoizedState, ce = !Js(re, z);
      ce && (H.memoizedState = z, u0());
      var Xe = H.queue;
      if (_p(ea.bind(null, w, Xe, c), [c]), Xe.getSnapshot !== d || ce || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      ds !== null && ds.memoizedState.tag & Va) {
        w.flags |= na, jm(Va | ws, Yo.bind(null, w, Xe, z, d), void 0, null);
        var Je = ay();
        if (Je === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        tC(Je, Ad) || Ri(w, d, z);
      }
      return z;
    }
    function Ri(c, d, G) {
      c.flags |= qe;
      var w = {
        getSnapshot: d,
        value: G
      }, H = fa.updateQueue;
      if (H === null)
        H = bi(), fa.updateQueue = H, H.stores = [w];
      else {
        var z = H.stores;
        z === null ? H.stores = [w] : z.push(w);
      }
    }
    function Yo(c, d, G, w) {
      d.value = G, d.getSnapshot = w, vI(d) && Gv(c);
    }
    function ea(c, d, G) {
      var w = function() {
        vI(d) && Gv(c);
      };
      return G(w);
    }
    function vI(c) {
      var d = c.getSnapshot, G = c.value;
      try {
        var w = d();
        return !Js(G, w);
      } catch {
        return !0;
      }
    }
    function Gv(c) {
      pl(c, nr, Pi);
    }
    function Bv(c) {
      var d = Dn();
      typeof c == "function" && (c = c()), d.memoizedState = d.baseState = c;
      var G = {
        pending: null,
        interleaved: null,
        lanes: Dt,
        dispatch: null,
        lastRenderedReducer: Xo,
        lastRenderedState: c
      };
      d.queue = G;
      var w = G.dispatch = QW.bind(null, fa, G);
      return [d.memoizedState, w];
    }
    function Yb(c) {
      return tt(Xo);
    }
    function Fb(c) {
      return yt(Xo);
    }
    function jm(c, d, G, w) {
      var H = {
        tag: c,
        create: d,
        destroy: G,
        deps: w,
        // Circular
        next: null
      }, z = fa.updateQueue;
      if (z === null)
        z = bi(), fa.updateQueue = z, z.lastEffect = H.next = H;
      else {
        var Q = z.lastEffect;
        if (Q === null)
          z.lastEffect = H.next = H;
        else {
          var re = Q.next;
          Q.next = H, H.next = re, z.lastEffect = H;
        }
      }
      return H;
    }
    function Eb(c) {
      var d = Dn();
      {
        var G = {
          current: c
        };
        return d.memoizedState = G, G;
      }
    }
    function Tb(c) {
      var d = ei();
      return d.memoizedState;
    }
    function Sv(c, d, G, w) {
      var H = Dn(), z = w === void 0 ? null : w;
      fa.flags |= c, H.memoizedState = jm(Va | d, G, void 0, z);
    }
    function Zv(c, d, G, w) {
      var H = ei(), z = w === void 0 ? null : w, Q = void 0;
      if (yo !== null) {
        var re = yo.memoizedState;
        if (Q = re.destroy, z !== null) {
          var ce = re.deps;
          if (Qe(z, ce)) {
            H.memoizedState = jm(d, G, Q, z);
            return;
          }
        }
      }
      fa.flags |= c, H.memoizedState = jm(Va | d, G, Q, z);
    }
    function Tp(c, d) {
      return (fa.mode & as) !== Oi ? Sv(Oe | na | Ee, ws, c, d) : Sv(na | Ee, ws, c, d);
    }
    function _p(c, d) {
      return Zv(na, ws, c, d);
    }
    function AB(c, d) {
      return Sv(an, yC, c, d);
    }
    function _b(c, d) {
      return Zv(an, yC, c, d);
    }
    function vB(c, d) {
      var G = an;
      return G |= we, (fa.mode & as) !== Oi && (G |= Ue), Sv(G, Ho, c, d);
    }
    function zb(c, d) {
      return Zv(an, Ho, c, d);
    }
    function tR(c, d) {
      if (typeof d == "function") {
        var G = d, w = c();
        return G(w), function() {
          G(null);
        };
      } else if (d != null) {
        var H = d;
        H.hasOwnProperty("current") || h("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(H).join(", ") + "}");
        var z = c();
        return H.current = z, function() {
          H.current = null;
        };
      }
    }
    function vf(c, d, G) {
      typeof d != "function" && h("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", d !== null ? typeof d : "null");
      var w = G != null ? G.concat([c]) : null, H = an;
      return H |= we, (fa.mode & as) !== Oi && (H |= Ue), Sv(H, Ho, tR.bind(null, d, c), w);
    }
    function qm(c, d, G) {
      typeof d != "function" && h("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", d !== null ? typeof d : "null");
      var w = G != null ? G.concat([c]) : null;
      return Zv(an, Ho, tR.bind(null, d, c), w);
    }
    function wv(c, d) {
    }
    var $m = wv;
    function yB(c, d) {
      var G = Dn(), w = d === void 0 ? null : d;
      return G.memoizedState = [c, w], c;
    }
    function Kb(c, d) {
      var G = ei(), w = d === void 0 ? null : d, H = G.memoizedState;
      if (H !== null && w !== null) {
        var z = H[1];
        if (Qe(w, z))
          return H[0];
      }
      return G.memoizedState = [c, w], c;
    }
    function Lb(c, d) {
      var G = Dn(), w = d === void 0 ? null : d, H = c();
      return G.memoizedState = [H, w], H;
    }
    function kb(c, d) {
      var G = ei(), w = d === void 0 ? null : d, H = G.memoizedState;
      if (H !== null && w !== null) {
        var z = H[1];
        if (Qe(w, z))
          return H[0];
      }
      var Q = c();
      return G.memoizedState = [Q, w], Q;
    }
    function eA(c) {
      var d = Bv(c), G = d[0], w = d[1];
      return Tp(function() {
        var H = Vu.transition;
        Vu.transition = {};
        try {
          w(c);
        } finally {
          Vu.transition = H;
        }
      }, [c]), G;
    }
    function zp(c) {
      var d = Yb(), G = d[0], w = d[1];
      return _p(function() {
        var H = Vu.transition;
        Vu.transition = {};
        try {
          w(c);
        } finally {
          Vu.transition = H;
        }
      }, [c]), G;
    }
    function Db(c) {
      var d = Fb(), G = d[0], w = d[1];
      return _p(function() {
        var H = Vu.transition;
        Vu.transition = {};
        try {
          w(c);
        } finally {
          Vu.transition = H;
        }
      }, [c]), G;
    }
    function nR(c, d, G) {
      var w = Pl();
      Ka(lv(w, ld)), c(!0);
      var H = Vu.transition;
      Vu.transition = {};
      var z = Vu.transition;
      Vu.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        c(!1), d();
      } finally {
        if (Ka(w), Vu.transition = H, H === null && z._updatedFibers) {
          var Q = z._updatedFibers.size;
          Q > 10 && f("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), z._updatedFibers.clear();
        }
      }
    }
    function tA() {
      var c = Bv(!1), d = c[0], G = c[1], w = nR.bind(null, G), H = Dn();
      return H.memoizedState = w, [d, w];
    }
    function bB() {
      var c = Yb(), d = c[0], G = ei(), w = G.memoizedState;
      return [d, w];
    }
    function GB() {
      var c = Fb(), d = c[0], G = ei(), w = G.memoizedState;
      return [d, w];
    }
    var BB = !1;
    function iR() {
      return BB;
    }
    function Ub() {
      var c = Dn(), d = ay(), G = d.identifierPrefix, w;
      if (ka()) {
        var H = fB();
        w = ":" + G + "R" + H;
        var z = Fp++;
        z > 0 && (w += "H" + z.toString(32)), w += ":";
      } else {
        var Q = Ep++;
        w = ":" + G + "r" + Q.toString(32) + ":";
      }
      return c.memoizedState = w, w;
    }
    function Rv() {
      var c = ei(), d = c.memoizedState;
      return d;
    }
    function yf(c, d, G) {
      typeof arguments[3] == "function" && h("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var w = ZC(c), H = {
        lane: w,
        action: G,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (rR(c))
        aR(d, H);
      else {
        nA(c, d, H);
        var z = Yu(), Q = pl(c, w, z);
        Q !== null && Ob(Q, d, w);
      }
      SB(c, w);
    }
    function QW(c, d, G) {
      typeof arguments[3] == "function" && h("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var w = ZC(c), H = {
        lane: w,
        action: G,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (rR(c))
        aR(d, H);
      else {
        nA(c, d, H);
        var z = c.alternate;
        if (c.lanes === Dt && (z === null || z.lanes === Dt)) {
          var Q = d.lastRenderedReducer;
          if (Q !== null) {
            var re;
            re = Qn.current, Qn.current = lc;
            try {
              var ce = d.lastRenderedState, Xe = Q(ce, G);
              if (H.hasEagerState = !0, H.eagerState = Xe, Js(Xe, ce))
                return;
            } catch {
            } finally {
              Qn.current = re;
            }
          }
        }
        var Je = Yu(), ft = pl(c, w, Je);
        ft !== null && Ob(ft, d, w);
      }
      SB(c, w);
    }
    function rR(c) {
      var d = c.alternate;
      return c === fa || d !== null && d === fa;
    }
    function aR(c, d) {
      bC = Qm = !0;
      var G = c.pending;
      G === null ? d.next = d : (d.next = G.next, G.next = d), c.pending = d;
    }
    function nA(c, d, G, w) {
      if (xs(c)) {
        var H = d.interleaved;
        H === null ? (G.next = G, lr(d)) : (G.next = H.next, H.next = G), d.interleaved = G;
      } else {
        var z = d.pending;
        z === null ? G.next = G : (G.next = z.next, z.next = G), d.pending = G;
      }
    }
    function Ob(c, d, G) {
      if (Wc(G)) {
        var w = d.lanes;
        w = Gu(w, c.pendingLanes);
        var H = Wi(w, G);
        d.lanes = H, ys(c, H);
      }
    }
    function SB(c, d, G) {
      Ps(c, d);
    }
    var Pb = {
      readContext: mi,
      useCallback: He,
      useContext: He,
      useEffect: He,
      useImperativeHandle: He,
      useInsertionEffect: He,
      useLayoutEffect: He,
      useMemo: He,
      useReducer: He,
      useRef: He,
      useState: He,
      useDebugValue: He,
      useDeferredValue: He,
      useTransition: He,
      useMutableSource: He,
      useSyncExternalStore: He,
      useId: He,
      unstable_isNewReconciler: x
    }, ZB = null, oR = null, bo = null, Jb = null, xg = null, lc = null, xv = null;
    {
      var Qb = function() {
        h("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, er = function() {
        h("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      ZB = {
        readContext: function(c) {
          return mi(c);
        },
        useCallback: function(c, d) {
          return jt = "useCallback", N(), D(d), yB(c, d);
        },
        useContext: function(c) {
          return jt = "useContext", N(), mi(c);
        },
        useEffect: function(c, d) {
          return jt = "useEffect", N(), D(d), Tp(c, d);
        },
        useImperativeHandle: function(c, d, G) {
          return jt = "useImperativeHandle", N(), D(G), vf(c, d, G);
        },
        useInsertionEffect: function(c, d) {
          return jt = "useInsertionEffect", N(), D(d), AB(c, d);
        },
        useLayoutEffect: function(c, d) {
          return jt = "useLayoutEffect", N(), D(d), vB(c, d);
        },
        useMemo: function(c, d) {
          jt = "useMemo", N(), D(d);
          var G = Qn.current;
          Qn.current = xg;
          try {
            return Lb(c, d);
          } finally {
            Qn.current = G;
          }
        },
        useReducer: function(c, d, G) {
          jt = "useReducer", N();
          var w = Qn.current;
          Qn.current = xg;
          try {
            return dt(c, d, G);
          } finally {
            Qn.current = w;
          }
        },
        useRef: function(c) {
          return jt = "useRef", N(), Eb(c);
        },
        useState: function(c) {
          jt = "useState", N();
          var d = Qn.current;
          Qn.current = xg;
          try {
            return Bv(c);
          } finally {
            Qn.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return jt = "useDebugValue", N(), void 0;
        },
        useDeferredValue: function(c) {
          return jt = "useDeferredValue", N(), eA(c);
        },
        useTransition: function() {
          return jt = "useTransition", N(), tA();
        },
        useMutableSource: function(c, d, G) {
          return jt = "useMutableSource", N(), void 0;
        },
        useSyncExternalStore: function(c, d, G) {
          return jt = "useSyncExternalStore", N(), Ti(c, d, G);
        },
        useId: function() {
          return jt = "useId", N(), Ub();
        },
        unstable_isNewReconciler: x
      }, oR = {
        readContext: function(c) {
          return mi(c);
        },
        useCallback: function(c, d) {
          return jt = "useCallback", F(), yB(c, d);
        },
        useContext: function(c) {
          return jt = "useContext", F(), mi(c);
        },
        useEffect: function(c, d) {
          return jt = "useEffect", F(), Tp(c, d);
        },
        useImperativeHandle: function(c, d, G) {
          return jt = "useImperativeHandle", F(), vf(c, d, G);
        },
        useInsertionEffect: function(c, d) {
          return jt = "useInsertionEffect", F(), AB(c, d);
        },
        useLayoutEffect: function(c, d) {
          return jt = "useLayoutEffect", F(), vB(c, d);
        },
        useMemo: function(c, d) {
          jt = "useMemo", F();
          var G = Qn.current;
          Qn.current = xg;
          try {
            return Lb(c, d);
          } finally {
            Qn.current = G;
          }
        },
        useReducer: function(c, d, G) {
          jt = "useReducer", F();
          var w = Qn.current;
          Qn.current = xg;
          try {
            return dt(c, d, G);
          } finally {
            Qn.current = w;
          }
        },
        useRef: function(c) {
          return jt = "useRef", F(), Eb(c);
        },
        useState: function(c) {
          jt = "useState", F();
          var d = Qn.current;
          Qn.current = xg;
          try {
            return Bv(c);
          } finally {
            Qn.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return jt = "useDebugValue", F(), void 0;
        },
        useDeferredValue: function(c) {
          return jt = "useDeferredValue", F(), eA(c);
        },
        useTransition: function() {
          return jt = "useTransition", F(), tA();
        },
        useMutableSource: function(c, d, G) {
          return jt = "useMutableSource", F(), void 0;
        },
        useSyncExternalStore: function(c, d, G) {
          return jt = "useSyncExternalStore", F(), Ti(c, d, G);
        },
        useId: function() {
          return jt = "useId", F(), Ub();
        },
        unstable_isNewReconciler: x
      }, bo = {
        readContext: function(c) {
          return mi(c);
        },
        useCallback: function(c, d) {
          return jt = "useCallback", F(), Kb(c, d);
        },
        useContext: function(c) {
          return jt = "useContext", F(), mi(c);
        },
        useEffect: function(c, d) {
          return jt = "useEffect", F(), _p(c, d);
        },
        useImperativeHandle: function(c, d, G) {
          return jt = "useImperativeHandle", F(), qm(c, d, G);
        },
        useInsertionEffect: function(c, d) {
          return jt = "useInsertionEffect", F(), _b(c, d);
        },
        useLayoutEffect: function(c, d) {
          return jt = "useLayoutEffect", F(), zb(c, d);
        },
        useMemo: function(c, d) {
          jt = "useMemo", F();
          var G = Qn.current;
          Qn.current = lc;
          try {
            return kb(c, d);
          } finally {
            Qn.current = G;
          }
        },
        useReducer: function(c, d, G) {
          jt = "useReducer", F();
          var w = Qn.current;
          Qn.current = lc;
          try {
            return tt(c, d, G);
          } finally {
            Qn.current = w;
          }
        },
        useRef: function(c) {
          return jt = "useRef", F(), Tb();
        },
        useState: function(c) {
          jt = "useState", F();
          var d = Qn.current;
          Qn.current = lc;
          try {
            return Yb(c);
          } finally {
            Qn.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return jt = "useDebugValue", F(), $m();
        },
        useDeferredValue: function(c) {
          return jt = "useDeferredValue", F(), zp(c);
        },
        useTransition: function() {
          return jt = "useTransition", F(), bB();
        },
        useMutableSource: function(c, d, G) {
          return jt = "useMutableSource", F(), void 0;
        },
        useSyncExternalStore: function(c, d, G) {
          return jt = "useSyncExternalStore", F(), Fi(c, d);
        },
        useId: function() {
          return jt = "useId", F(), Rv();
        },
        unstable_isNewReconciler: x
      }, Jb = {
        readContext: function(c) {
          return mi(c);
        },
        useCallback: function(c, d) {
          return jt = "useCallback", F(), Kb(c, d);
        },
        useContext: function(c) {
          return jt = "useContext", F(), mi(c);
        },
        useEffect: function(c, d) {
          return jt = "useEffect", F(), _p(c, d);
        },
        useImperativeHandle: function(c, d, G) {
          return jt = "useImperativeHandle", F(), qm(c, d, G);
        },
        useInsertionEffect: function(c, d) {
          return jt = "useInsertionEffect", F(), _b(c, d);
        },
        useLayoutEffect: function(c, d) {
          return jt = "useLayoutEffect", F(), zb(c, d);
        },
        useMemo: function(c, d) {
          jt = "useMemo", F();
          var G = Qn.current;
          Qn.current = xv;
          try {
            return kb(c, d);
          } finally {
            Qn.current = G;
          }
        },
        useReducer: function(c, d, G) {
          jt = "useReducer", F();
          var w = Qn.current;
          Qn.current = xv;
          try {
            return yt(c, d, G);
          } finally {
            Qn.current = w;
          }
        },
        useRef: function(c) {
          return jt = "useRef", F(), Tb();
        },
        useState: function(c) {
          jt = "useState", F();
          var d = Qn.current;
          Qn.current = xv;
          try {
            return Fb(c);
          } finally {
            Qn.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return jt = "useDebugValue", F(), $m();
        },
        useDeferredValue: function(c) {
          return jt = "useDeferredValue", F(), Db(c);
        },
        useTransition: function() {
          return jt = "useTransition", F(), GB();
        },
        useMutableSource: function(c, d, G) {
          return jt = "useMutableSource", F(), void 0;
        },
        useSyncExternalStore: function(c, d, G) {
          return jt = "useSyncExternalStore", F(), Fi(c, d);
        },
        useId: function() {
          return jt = "useId", F(), Rv();
        },
        unstable_isNewReconciler: x
      }, xg = {
        readContext: function(c) {
          return Qb(), mi(c);
        },
        useCallback: function(c, d) {
          return jt = "useCallback", er(), N(), yB(c, d);
        },
        useContext: function(c) {
          return jt = "useContext", er(), N(), mi(c);
        },
        useEffect: function(c, d) {
          return jt = "useEffect", er(), N(), Tp(c, d);
        },
        useImperativeHandle: function(c, d, G) {
          return jt = "useImperativeHandle", er(), N(), vf(c, d, G);
        },
        useInsertionEffect: function(c, d) {
          return jt = "useInsertionEffect", er(), N(), AB(c, d);
        },
        useLayoutEffect: function(c, d) {
          return jt = "useLayoutEffect", er(), N(), vB(c, d);
        },
        useMemo: function(c, d) {
          jt = "useMemo", er(), N();
          var G = Qn.current;
          Qn.current = xg;
          try {
            return Lb(c, d);
          } finally {
            Qn.current = G;
          }
        },
        useReducer: function(c, d, G) {
          jt = "useReducer", er(), N();
          var w = Qn.current;
          Qn.current = xg;
          try {
            return dt(c, d, G);
          } finally {
            Qn.current = w;
          }
        },
        useRef: function(c) {
          return jt = "useRef", er(), N(), Eb(c);
        },
        useState: function(c) {
          jt = "useState", er(), N();
          var d = Qn.current;
          Qn.current = xg;
          try {
            return Bv(c);
          } finally {
            Qn.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return jt = "useDebugValue", er(), N(), void 0;
        },
        useDeferredValue: function(c) {
          return jt = "useDeferredValue", er(), N(), eA(c);
        },
        useTransition: function() {
          return jt = "useTransition", er(), N(), tA();
        },
        useMutableSource: function(c, d, G) {
          return jt = "useMutableSource", er(), N(), void 0;
        },
        useSyncExternalStore: function(c, d, G) {
          return jt = "useSyncExternalStore", er(), N(), Ti(c, d, G);
        },
        useId: function() {
          return jt = "useId", er(), N(), Ub();
        },
        unstable_isNewReconciler: x
      }, lc = {
        readContext: function(c) {
          return Qb(), mi(c);
        },
        useCallback: function(c, d) {
          return jt = "useCallback", er(), F(), Kb(c, d);
        },
        useContext: function(c) {
          return jt = "useContext", er(), F(), mi(c);
        },
        useEffect: function(c, d) {
          return jt = "useEffect", er(), F(), _p(c, d);
        },
        useImperativeHandle: function(c, d, G) {
          return jt = "useImperativeHandle", er(), F(), qm(c, d, G);
        },
        useInsertionEffect: function(c, d) {
          return jt = "useInsertionEffect", er(), F(), _b(c, d);
        },
        useLayoutEffect: function(c, d) {
          return jt = "useLayoutEffect", er(), F(), zb(c, d);
        },
        useMemo: function(c, d) {
          jt = "useMemo", er(), F();
          var G = Qn.current;
          Qn.current = lc;
          try {
            return kb(c, d);
          } finally {
            Qn.current = G;
          }
        },
        useReducer: function(c, d, G) {
          jt = "useReducer", er(), F();
          var w = Qn.current;
          Qn.current = lc;
          try {
            return tt(c, d, G);
          } finally {
            Qn.current = w;
          }
        },
        useRef: function(c) {
          return jt = "useRef", er(), F(), Tb();
        },
        useState: function(c) {
          jt = "useState", er(), F();
          var d = Qn.current;
          Qn.current = lc;
          try {
            return Yb(c);
          } finally {
            Qn.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return jt = "useDebugValue", er(), F(), $m();
        },
        useDeferredValue: function(c) {
          return jt = "useDeferredValue", er(), F(), zp(c);
        },
        useTransition: function() {
          return jt = "useTransition", er(), F(), bB();
        },
        useMutableSource: function(c, d, G) {
          return jt = "useMutableSource", er(), F(), void 0;
        },
        useSyncExternalStore: function(c, d, G) {
          return jt = "useSyncExternalStore", er(), F(), Fi(c, d);
        },
        useId: function() {
          return jt = "useId", er(), F(), Rv();
        },
        unstable_isNewReconciler: x
      }, xv = {
        readContext: function(c) {
          return Qb(), mi(c);
        },
        useCallback: function(c, d) {
          return jt = "useCallback", er(), F(), Kb(c, d);
        },
        useContext: function(c) {
          return jt = "useContext", er(), F(), mi(c);
        },
        useEffect: function(c, d) {
          return jt = "useEffect", er(), F(), _p(c, d);
        },
        useImperativeHandle: function(c, d, G) {
          return jt = "useImperativeHandle", er(), F(), qm(c, d, G);
        },
        useInsertionEffect: function(c, d) {
          return jt = "useInsertionEffect", er(), F(), _b(c, d);
        },
        useLayoutEffect: function(c, d) {
          return jt = "useLayoutEffect", er(), F(), zb(c, d);
        },
        useMemo: function(c, d) {
          jt = "useMemo", er(), F();
          var G = Qn.current;
          Qn.current = lc;
          try {
            return kb(c, d);
          } finally {
            Qn.current = G;
          }
        },
        useReducer: function(c, d, G) {
          jt = "useReducer", er(), F();
          var w = Qn.current;
          Qn.current = lc;
          try {
            return yt(c, d, G);
          } finally {
            Qn.current = w;
          }
        },
        useRef: function(c) {
          return jt = "useRef", er(), F(), Tb();
        },
        useState: function(c) {
          jt = "useState", er(), F();
          var d = Qn.current;
          Qn.current = lc;
          try {
            return Fb(c);
          } finally {
            Qn.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return jt = "useDebugValue", er(), F(), $m();
        },
        useDeferredValue: function(c) {
          return jt = "useDeferredValue", er(), F(), Db(c);
        },
        useTransition: function() {
          return jt = "useTransition", er(), F(), GB();
        },
        useMutableSource: function(c, d, G) {
          return jt = "useMutableSource", er(), F(), void 0;
        },
        useSyncExternalStore: function(c, d, G) {
          return jt = "useSyncExternalStore", er(), F(), Fi(c, d);
        },
        useId: function() {
          return jt = "useId", er(), F(), Rv();
        },
        unstable_isNewReconciler: x
      };
    }
    var vd = o.unstable_now, sR = 0, Kp = -1, GC = -1, jb = -1, qb = !1, $b = !1;
    function lR() {
      return qb;
    }
    function Kc() {
      $b = !0;
    }
    function Wv() {
      qb = !1, $b = !1;
    }
    function e0() {
      qb = $b, $b = !1;
    }
    function dh() {
      return sR;
    }
    function wB() {
      sR = vd();
    }
    function Ih(c) {
      GC = vd(), c.actualStartTime < 0 && (c.actualStartTime = vd());
    }
    function bf(c) {
      GC = -1;
    }
    function Lp(c, d) {
      if (GC >= 0) {
        var G = vd() - GC;
        c.actualDuration += G, d && (c.selfBaseDuration = G), GC = -1;
      }
    }
    function Lc(c) {
      if (Kp >= 0) {
        var d = vd() - Kp;
        Kp = -1;
        for (var G = c.return; G !== null; ) {
          switch (G.tag) {
            case te:
              var w = G.stateNode;
              w.effectDuration += d;
              return;
            case be:
              var H = G.stateNode;
              H.effectDuration += d;
              return;
          }
          G = G.return;
        }
      }
    }
    function iA(c) {
      if (jb >= 0) {
        var d = vd() - jb;
        jb = -1;
        for (var G = c.return; G !== null; ) {
          switch (G.tag) {
            case te:
              var w = G.stateNode;
              w !== null && (w.passiveEffectDuration += d);
              return;
            case be:
              var H = G.stateNode;
              H !== null && (H.passiveEffectDuration += d);
              return;
          }
          G = G.return;
        }
      }
    }
    function Nu() {
      Kp = vd();
    }
    function t0() {
      jb = vd();
    }
    function rA(c) {
      for (var d = c.child; d; )
        c.actualDuration += d.actualDuration, d = d.sibling;
    }
    function Vv(c, d) {
      return {
        value: c,
        source: d,
        stack: aC(d)
      };
    }
    function uR(c, d) {
      return !0;
    }
    function RB(c, d) {
      try {
        var G = uR(c, d);
        if (G === !1)
          return;
        var w = d.value, H = d.source, z = d.stack, Q = z !== null ? z : "";
        if (w != null && w._suppressLogging) {
          if (c.tag === O)
            return;
          console.error(w);
        }
        var re = H ? lt(H) : null, ce = re ? "The above error occurred in the <" + re + "> component:" : "The above error occurred in one of your React components:", Xe;
        if (c.tag === te)
          Xe = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Je = lt(c) || "Anonymous";
          Xe = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Je + ".");
        }
        var ft = ce + `
` + Q + `

` + ("" + Xe);
        console.error(ft);
      } catch (_t) {
        setTimeout(function() {
          throw _t;
        });
      }
    }
    var jW = typeof WeakMap == "function" ? WeakMap : Map;
    function Nv(c, d, G) {
      var w = fr(Pi, G);
      w.tag = st, w.payload = {
        element: null
      };
      var H = d.value;
      return w.callback = function() {
        ox(H), RB(c, d);
      }, w;
    }
    function aA(c, d, G) {
      var w = fr(Pi, G);
      w.tag = st;
      var H = c.type.getDerivedStateFromError;
      if (typeof H == "function") {
        var z = d.value;
        w.payload = function() {
          return H(z);
        }, w.callback = function() {
          Wg(c), RB(c, d);
        };
      }
      var Q = c.stateNode;
      return Q !== null && typeof Q.componentDidCatch == "function" && (w.callback = function() {
        Wg(c), RB(c, d), typeof H != "function" && MV(this);
        var ce = d.value, Xe = d.stack;
        this.componentDidCatch(ce, {
          componentStack: Xe !== null ? Xe : ""
        }), typeof H != "function" && (ja(c.lanes, nr) || h("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", lt(c) || "Unknown"));
      }), w;
    }
    function xB(c, d, G) {
      var w = c.pingCache, H;
      if (w === null ? (w = c.pingCache = new jW(), H = /* @__PURE__ */ new Set(), w.set(d, H)) : (H = w.get(d), H === void 0 && (H = /* @__PURE__ */ new Set(), w.set(d, H))), !H.has(G)) {
        H.add(G);
        var z = mS.bind(null, c, d, G);
        xo && jn(c, G), d.then(z, z);
      }
    }
    function qW(c, d, G, w) {
      var H = c.updateQueue;
      if (H === null) {
        var z = /* @__PURE__ */ new Set();
        z.add(G), c.updateQueue = z;
      } else
        H.add(G);
    }
    function n0(c, d) {
      var G = c.tag;
      if ((c.mode & Rr) === Oi && (G === k || G === Ce || G === $e)) {
        var w = c.alternate;
        w ? (c.updateQueue = w.updateQueue, c.memoizedState = w.memoizedState, c.lanes = w.lanes) : (c.updateQueue = null, c.memoizedState = null);
      }
    }
    function cR(c) {
      var d = c;
      do {
        if (d.tag === le && yv(d))
          return d;
        d = d.return;
      } while (d !== null);
      return null;
    }
    function gR(c, d, G, w, H) {
      if ((c.mode & Rr) === Oi) {
        if (c === d)
          c.flags |= ut;
        else {
          if (c.flags |= pi, G.flags |= Bt, G.flags &= ~(gt | me), ci && W) {
            var z = c.alternate;
            if (z === null) {
              var Q = c.child, re = Q.child;
              if (re !== null) {
                var ce = re.memoizedProps.children, Xe = ni("hidden", ce);
                re.pendingProps = Xe, re.memoizedProps = Xe;
              }
            }
          }
          if (G.tag === O) {
            var Je = G.alternate;
            if (Je === null)
              G.tag = ot;
            else {
              var ft = fr(Pi, nr);
              ft.tag = It, xa(G, ft);
            }
          }
          G.lanes = Wi(G.lanes, nr);
        }
        return c;
      }
      return c.flags |= ut, c.lanes = H, c;
    }
    function $W(c, d, G, w, H) {
      if (G.flags |= me, xo && jn(c, H), w !== null && typeof w == "object" && typeof w.then == "function") {
        var z = w;
        n0(G);
        var Q = cR(d);
        if (Q !== null) {
          Q.flags &= ~Cr, gR(Q, d, G, c, H), Q.mode & Rr && xB(c, z, H), qW(Q, c, z);
          return;
        } else {
          if (!gl(H)) {
            xB(c, z, H), hS();
            return;
          }
          var re = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          w = re;
        }
      } else if (ka() && G.mode & Rr) {
        Rp();
        var ce = cR(d);
        if (ce !== null) {
          (ce.flags & ut) === _e && (ce.flags |= Cr), gR(ce, d, G, c, H), Ya(w);
          return;
        }
      }
      ix(w), w = Vv(w, G);
      var Xe = d;
      do {
        switch (Xe.tag) {
          case te: {
            var Je = w;
            Xe.flags |= ut;
            var ft = Us(H);
            Xe.lanes = Wi(Xe.lanes, ft);
            var _t = Nv(Xe, Je, ft);
            Cl(Xe, _t);
            return;
          }
          case O:
            var Ut = w, yn = Xe.type, xn = Xe.stateNode;
            if ((Xe.flags & pi) === _e && (typeof yn.getDerivedStateFromError == "function" || xn !== null && typeof xn.componentDidCatch == "function" && !M0(xn))) {
              Xe.flags |= ut;
              var _i = Us(H);
              Xe.lanes = Wi(Xe.lanes, _i);
              var Ar = aA(Xe, Ut, _i);
              Cl(Xe, Ar);
              return;
            }
            break;
        }
        Xe = Xe.return;
      } while (Xe !== null);
    }
    function eV() {
      return null;
    }
    function BC(c) {
      c.flags |= an;
    }
    function dR(c) {
      c.flags |= Sa, c.flags |= ae;
    }
    function IR(c, d) {
      var G = c !== null && c.child === d.child;
      if (G)
        return !0;
      if ((d.flags & xi) !== _e)
        return !1;
      for (var w = d.child; w !== null; ) {
        if ((w.flags & Kt) !== _e || (w.subtreeFlags & Kt) !== _e)
          return !1;
        w = w.sibling;
      }
      return !0;
    }
    var Mv, Hv, i0, oA;
    if (qi)
      Mv = function(c, d, G, w) {
        for (var H = d.child; H !== null; ) {
          if (H.tag === pe || H.tag === Ae)
            In(c, H.stateNode);
          else if (H.tag !== fe) {
            if (H.child !== null) {
              H.child.return = H, H = H.child;
              continue;
            }
          }
          if (H === d)
            return;
          for (; H.sibling === null; ) {
            if (H.return === null || H.return === d)
              return;
            H = H.return;
          }
          H.sibling.return = H.return, H = H.sibling;
        }
      }, Hv = function(c, d) {
      }, i0 = function(c, d, G, w, H) {
        var z = c.memoizedProps;
        if (z !== w) {
          var Q = d.stateNode, re = Hp(), ce = Bi(Q, G, z, w, H, re);
          d.updateQueue = ce, ce && BC(d);
        }
      }, oA = function(c, d, G, w) {
        G !== w && BC(d);
      };
    else if (ci) {
      Mv = function(c, d, G, w) {
        for (var H = d.child; H !== null; ) {
          if (H.tag === pe) {
            var z = H.stateNode;
            if (G && w) {
              var Q = H.memoizedProps, re = H.type;
              z = Yi(z, re, Q, H);
            }
            In(c, z);
          } else if (H.tag === Ae) {
            var ce = H.stateNode;
            if (G && w) {
              var Xe = H.memoizedProps;
              ce = rr(ce, Xe, H);
            }
            In(c, ce);
          } else if (H.tag !== fe) {
            if (H.tag === hn && H.memoizedState !== null) {
              var Je = H.child;
              Je !== null && (Je.return = H), Mv(c, H, !0, !0);
            } else if (H.child !== null) {
              H.child.return = H, H = H.child;
              continue;
            }
          }
          if (H = H, H === d)
            return;
          for (; H.sibling === null; ) {
            if (H.return === null || H.return === d)
              return;
            H = H.return;
          }
          H.sibling.return = H.return, H = H.sibling;
        }
      };
      var r0 = function(c, d, G, w) {
        for (var H = d.child; H !== null; ) {
          if (H.tag === pe) {
            var z = H.stateNode;
            if (G && w) {
              var Q = H.memoizedProps, re = H.type;
              z = Yi(z, re, Q, H);
            }
            Et(c, z);
          } else if (H.tag === Ae) {
            var ce = H.stateNode;
            if (G && w) {
              var Xe = H.memoizedProps;
              ce = rr(ce, Xe, H);
            }
            Et(c, ce);
          } else if (H.tag !== fe) {
            if (H.tag === hn && H.memoizedState !== null) {
              var Je = H.child;
              Je !== null && (Je.return = H), r0(c, H, !0, !0);
            } else if (H.child !== null) {
              H.child.return = H, H = H.child;
              continue;
            }
          }
          if (H = H, H === d)
            return;
          for (; H.sibling === null; ) {
            if (H.return === null || H.return === d)
              return;
            H = H.return;
          }
          H.sibling.return = H.return, H = H.sibling;
        }
      };
      Hv = function(c, d) {
        var G = d.stateNode, w = IR(c, d);
        if (!w) {
          var H = G.containerInfo, z = bt(H);
          r0(z, d, !1, !1), G.pendingChildren = z, BC(d), wn(H, z);
        }
      }, i0 = function(c, d, G, w, H) {
        var z = c.stateNode, Q = c.memoizedProps, re = IR(c, d);
        if (re && Q === w) {
          d.stateNode = z;
          return;
        }
        var ce = d.stateNode, Xe = Hp(), Je = null;
        if (Q !== w && (Je = Bi(ce, G, Q, w, H, Xe)), re && Je === null) {
          d.stateNode = z;
          return;
        }
        var ft = De(z, Je, G, Q, w, d, re, ce);
        un(ft, G, w, H, Xe) && BC(d), d.stateNode = ft, re ? BC(d) : Mv(ft, d, !1, !1);
      }, oA = function(c, d, G, w) {
        if (G !== w) {
          var H = vC(), z = Hp();
          d.stateNode = Ji(w, H, z, d), BC(d);
        } else
          d.stateNode = c.stateNode;
      };
    } else
      Hv = function(c, d) {
      }, i0 = function(c, d, G, w, H) {
      }, oA = function(c, d, G, w) {
      };
    function kp(c, d) {
      if (!ka())
        switch (c.tailMode) {
          case "hidden": {
            for (var G = c.tail, w = null; G !== null; )
              G.alternate !== null && (w = G), G = G.sibling;
            w === null ? c.tail = null : w.sibling = null;
            break;
          }
          case "collapsed": {
            for (var H = c.tail, z = null; H !== null; )
              H.alternate !== null && (z = H), H = H.sibling;
            z === null ? !d && c.tail !== null ? c.tail.sibling = null : c.tail = null : z.sibling = null;
            break;
          }
        }
    }
    function hl(c) {
      var d = c.alternate !== null && c.alternate.child === c.child, G = Dt, w = _e;
      if (d) {
        if ((c.mode & xr) !== Oi) {
          for (var ce = c.selfBaseDuration, Xe = c.child; Xe !== null; )
            G = Wi(G, Wi(Xe.lanes, Xe.childLanes)), w |= Xe.subtreeFlags & Yn, w |= Xe.flags & Yn, ce += Xe.treeBaseDuration, Xe = Xe.sibling;
          c.treeBaseDuration = ce;
        } else
          for (var Je = c.child; Je !== null; )
            G = Wi(G, Wi(Je.lanes, Je.childLanes)), w |= Je.subtreeFlags & Yn, w |= Je.flags & Yn, Je.return = c, Je = Je.sibling;
        c.subtreeFlags |= w;
      } else {
        if ((c.mode & xr) !== Oi) {
          for (var H = c.actualDuration, z = c.selfBaseDuration, Q = c.child; Q !== null; )
            G = Wi(G, Wi(Q.lanes, Q.childLanes)), w |= Q.subtreeFlags, w |= Q.flags, H += Q.actualDuration, z += Q.treeBaseDuration, Q = Q.sibling;
          c.actualDuration = H, c.treeBaseDuration = z;
        } else
          for (var re = c.child; re !== null; )
            G = Wi(G, Wi(re.lanes, re.childLanes)), w |= re.subtreeFlags, w |= re.flags, re.return = c, re = re.sibling;
        c.subtreeFlags |= w;
      }
      return c.childLanes = G, d;
    }
    function CR(c, d, G) {
      var w = d.pendingProps;
      switch (lf(d), d.tag) {
        case J:
        case ke:
        case $e:
        case k:
        case Ce:
        case Te:
        case Ke:
        case be:
        case je:
        case Ye:
          return hl(d), null;
        case O: {
          var H = d.type;
          return ll(H) && Pu(d), hl(d), null;
        }
        case te: {
          var z = d.stateNode;
          if (Da(d), Sl(d), Af(), z.pendingContext && (z.context = z.pendingContext, z.pendingContext = null), c === null || c.child === null) {
            var Q = sh(d);
            if (Q)
              BC(d);
            else if (c !== null) {
              var re = c.memoizedState;
              // Check if this is a client root
              (!re.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (d.flags & Cr) !== _e) && (d.flags |= zr, Tc());
            }
          }
          return Hv(c, d), hl(d), null;
        }
        case pe: {
          pv(d);
          var ce = vC(), Xe = d.type;
          if (c !== null && d.stateNode != null)
            i0(c, d, Xe, w, ce), c.ref !== d.ref && dR(d);
          else {
            if (!w) {
              if (d.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return hl(d), null;
            }
            var Je = Hp(), ft = sh(d);
            if (ft)
              pC(d, ce, Je) && BC(d);
            else {
              var _t = $t(Xe, w, ce, Je, d);
              Mv(_t, d, !1, !1), d.stateNode = _t, un(_t, Xe, w, ce, Je) && BC(d);
            }
            d.ref !== null && dR(d);
          }
          return hl(d), null;
        }
        case Ae: {
          var Ut = w;
          if (c && d.stateNode != null) {
            var yn = c.memoizedProps;
            oA(c, d, yn, Ut);
          } else {
            if (typeof Ut != "string" && d.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var xn = vC(), _i = Hp(), Ar = sh(d);
            Ar ? mC(d) && BC(d) : d.stateNode = Ji(Ut, xn, _i, d);
          }
          return hl(d), null;
        }
        case le: {
          mI(d);
          var Ui = d.memoizedState;
          {
            if (Wp() && (d.mode & Rr) !== Oi && (d.flags & pi) === _e)
              return hf(d), No(), d.flags |= Cr | me | ut, d;
            if (Ui !== null && Ui.dehydrated !== null) {
              var Bo = sh(d);
              if (c === null) {
                if (!Bo)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (hd(d), hl(d), (d.mode & xr) !== Oi) {
                  var ho = Ui !== null;
                  if (ho) {
                    var Rt = d.child;
                    Rt !== null && (d.treeBaseDuration -= Rt.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (No(), (d.flags & pi) === _e && (d.memoizedState = null), d.flags |= an, hl(d), (d.mode & xr) !== Oi) {
                  var en = Ui !== null;
                  if (en) {
                    var Ct = d.child;
                    Ct !== null && (d.treeBaseDuration -= Ct.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            Tc();
          }
          if ((d.flags & pi) !== _e)
            return d.lanes = G, (d.mode & xr) !== Oi && rA(d), d;
          var Vn = Ui !== null, di = !1;
          if (c === null)
            sh(d);
          else {
            var si = c.memoizedState;
            di = si !== null;
          }
          if (Vn && !di) {
            var Er = d.child;
            if (Er.flags |= Le, (d.mode & Rr) !== Oi) {
              var Zr = c === null && (d.memoizedProps.unstable_avoidThisFallback !== !0 || !E);
              Zr || Yp(Mo.current, vv) ? V0() : hS();
            }
          }
          var Ua = d.updateQueue;
          if (Ua !== null && (d.flags |= an), hl(d), (d.mode & xr) !== Oi && Vn) {
            var pa = d.child;
            pa !== null && (d.treeBaseDuration -= pa.treeBaseDuration);
          }
          return null;
        }
        case fe:
          return Da(d), Hv(c, d), c === null && gi(d.stateNode.containerInfo), hl(d), null;
        case ee:
          var Eo = d.type._context;
          return Ve(Eo, d), hl(d), null;
        case ot: {
          var aa = d.type;
          return ll(aa) && Pu(d), hl(d), null;
        }
        case St: {
          mI(d);
          var wr = d.memoizedState;
          if (wr === null)
            return hl(d), null;
          var ts = (d.flags & pi) !== _e, Oo = wr.rendering;
          if (Oo === null)
            if (ts)
              kp(wr, !1);
            else {
              var dc = N0() && (c === null || (c.flags & pi) === _e);
              if (!dc)
                for (var Al = d.child; Al !== null; ) {
                  var Ic = ch(Al);
                  if (Ic !== null) {
                    ts = !0, d.flags |= pi, kp(wr, !1);
                    var Cc = Ic.updateQueue;
                    return Cc !== null && (d.updateQueue = Cc, d.flags |= an), d.subtreeFlags = _e, pB(d, G), Wu(d, md(Mo.current, Xp)), d.child;
                  }
                  Al = Al.sibling;
                }
              wr.tail !== null && Ca() > ey() && (d.flags |= pi, ts = !0, kp(wr, !1), d.lanes = $C);
            }
          else {
            if (!ts) {
              var Oc = ch(Oo);
              if (Oc !== null) {
                d.flags |= pi, ts = !0;
                var um = Oc.updateQueue;
                if (um !== null && (d.updateQueue = um, d.flags |= an), kp(wr, !0), wr.tail === null && wr.tailMode === "hidden" && !Oo.alternate && !ka())
                  return hl(d), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              Ca() * 2 - wr.renderingStartTime > ey() && G !== ks && (d.flags |= pi, ts = !0, kp(wr, !1), d.lanes = $C);
            }
            if (wr.isBackwards)
              Oo.sibling = d.child, d.child = Oo;
            else {
              var kf = wr.last;
              kf !== null ? kf.sibling = Oo : d.child = Oo, wr.last = Oo;
            }
          }
          if (wr.tail !== null) {
            var hc = wr.tail;
            wr.rendering = hc, wr.tail = hc.sibling, wr.renderingStartTime = Ca(), hc.sibling = null;
            var Df = Mo.current;
            return ts ? Df = md(Df, Xp) : Df = mf(Df), Wu(d, Df), hc;
          }
          return hl(d), null;
        }
        case ln:
          break;
        case hn:
        case mn: {
          oy(d);
          var TS = d.memoizedState, _S = TS !== null;
          if (c !== null) {
            var px = c.memoizedState, TV = px !== null;
            TV !== _S && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !T && (d.flags |= Le);
          }
          return !_S || (d.mode & Rr) === Oi ? hl(d) : ja(Dc, ks) && (hl(d), qi && d.subtreeFlags & (Ht | an) && (d.flags |= Le)), null;
        }
        case Pn:
          return null;
        case he:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + d.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var Ch = l.ReactCurrentOwner, uc = !1, WB, sA, VB, NB, a0, Dp, MB, Xv;
    WB = {}, sA = {}, VB = {}, NB = {}, a0 = {}, Dp = !1, MB = {}, Xv = {};
    function Ml(c, d, G, w) {
      c === null ? d.child = Um(d, null, G, w) : d.child = uh(d, c.child, G, w);
    }
    function o0(c, d, G, w) {
      d.child = uh(d, c.child, null, w), d.child = uh(d, null, G, w);
    }
    function Yv(c, d, G, w, H) {
      if (d.type !== d.elementType) {
        var z = G.propTypes;
        z && Dr(
          z,
          w,
          // Resolved props
          "prop",
          Pe(G)
        );
      }
      var Q = G.render, re = d.ref, ce, Xe;
      Jn(d, H), bs(d);
      {
        if (Ch.current = d, xl(!0), ce = xt(c, d, Q, w, re, H), Xe = Cn(), d.mode & Ma) {
          Ur(!0);
          try {
            ce = xt(c, d, Q, w, re, H), Xe = Cn();
          } finally {
            Ur(!1);
          }
        }
        xl(!1);
      }
      return Jl(), c !== null && !uc ? (Gn(c, d, H), hh(c, d, H)) : (ka() && Xe && hC(d), d.flags |= ht, Ml(c, d, ce, H), d.child);
    }
    function lA(c, d, G, w, H) {
      if (c === null) {
        var z = G.type;
        if (xC(z) && G.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        G.defaultProps === void 0) {
          var Q = z;
          return Q = RC(z), d.tag = $e, d.type = Q, TB(d, z), uA(c, d, Q, w, H);
        }
        {
          var re = z.propTypes;
          re && Dr(
            re,
            w,
            // Resolved props
            "prop",
            Pe(z)
          );
        }
        var ce = py(G.type, null, w, d, d.mode, H);
        return ce.ref = d.ref, ce.return = d, d.child = ce, ce;
      }
      {
        var Xe = G.type, Je = Xe.propTypes;
        Je && Dr(
          Je,
          w,
          // Resolved props
          "prop",
          Pe(Xe)
        );
      }
      var ft = c.child, _t = DB(c, H);
      if (!_t) {
        var Ut = ft.memoizedProps, yn = G.compare;
        if (yn = yn !== null ? yn : uI, yn(Ut, w) && c.ref === d.ref)
          return hh(c, d, H);
      }
      d.flags |= ht;
      var xn = Lf(ft, w);
      return xn.ref = d.ref, xn.return = d, d.child = xn, xn;
    }
    function uA(c, d, G, w, H) {
      if (d.type !== d.elementType) {
        var z = d.elementType;
        if (z.$$typeof === pt) {
          var Q = z, re = Q._payload, ce = Q._init;
          try {
            z = ce(re);
          } catch {
            z = null;
          }
          var Xe = z && z.propTypes;
          Xe && Dr(
            Xe,
            w,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Pe(z)
          );
        }
      }
      if (c !== null) {
        var Je = c.memoizedProps;
        if (uI(Je, w) && c.ref === d.ref && // Prevent bailout if the implementation changed due to hot reload.
        d.type === c.type)
          if (uc = !1, DB(c, H))
            (c.flags & Bt) !== _e && (uc = !0);
          else return d.lanes = c.lanes, hh(c, d, H);
      }
      return pR(c, d, G, w, H);
    }
    function hR(c, d, G) {
      var w = d.pendingProps, H = w.children, z = c !== null ? c.memoizedState : null;
      if (w.mode === "hidden" || T)
        if ((d.mode & Rr) === Oi) {
          var Q = {
            baseLanes: Dt,
            cachePool: null
          };
          d.memoizedState = Q, nm(d, G);
        } else if (ja(G, ks)) {
          var ft = {
            baseLanes: Dt,
            cachePool: null
          };
          d.memoizedState = ft;
          var _t = z !== null ? z.baseLanes : G;
          nm(d, _t);
        } else {
          var re = null, ce;
          if (z !== null) {
            var Xe = z.baseLanes;
            ce = Wi(Xe, G);
          } else
            ce = G;
          d.lanes = d.childLanes = ks;
          var Je = {
            baseLanes: ce,
            cachePool: re
          };
          return d.memoizedState = Je, d.updateQueue = null, nm(d, ce), null;
        }
      else {
        var Ut;
        z !== null ? (Ut = Wi(z.baseLanes, G), d.memoizedState = null) : Ut = G, nm(d, Ut);
      }
      return Ml(c, d, H, G), d.child;
    }
    function HB(c, d, G) {
      var w = d.pendingProps;
      return Ml(c, d, w, G), d.child;
    }
    function XB(c, d, G) {
      var w = d.pendingProps.children;
      return Ml(c, d, w, G), d.child;
    }
    function tV(c, d, G) {
      {
        d.flags |= an;
        {
          var w = d.stateNode;
          w.effectDuration = 0, w.passiveEffectDuration = 0;
        }
      }
      var H = d.pendingProps, z = H.children;
      return Ml(c, d, z, G), d.child;
    }
    function fR(c, d) {
      var G = d.ref;
      (c === null && G !== null || c !== null && c.ref !== G) && (d.flags |= Sa, d.flags |= ae);
    }
    function pR(c, d, G, w, H) {
      if (d.type !== d.elementType) {
        var z = G.propTypes;
        z && Dr(
          z,
          w,
          // Resolved props
          "prop",
          Pe(G)
        );
      }
      var Q;
      {
        var re = ps(d, G, !0);
        Q = oo(d, re);
      }
      var ce, Xe;
      Jn(d, H), bs(d);
      {
        if (Ch.current = d, xl(!0), ce = xt(c, d, G, w, Q, H), Xe = Cn(), d.mode & Ma) {
          Ur(!0);
          try {
            ce = xt(c, d, G, w, Q, H), Xe = Cn();
          } finally {
            Ur(!1);
          }
        }
        xl(!1);
      }
      return Jl(), c !== null && !uc ? (Gn(c, d, H), hh(c, d, H)) : (ka() && Xe && hC(d), d.flags |= ht, Ml(c, d, ce, H), d.child);
    }
    function mR(c, d, G, w, H) {
      {
        switch (U0(d)) {
          case !1: {
            var z = d.stateNode, Q = d.type, re = new Q(d.memoizedProps, z.context), ce = re.state;
            z.updater.enqueueSetState(z, ce, null);
            break;
          }
          case !0: {
            d.flags |= pi, d.flags |= ut;
            var Xe = new Error("Simulated error coming from DevTools"), Je = Us(H);
            d.lanes = Wi(d.lanes, Je);
            var ft = aA(d, Vv(Xe, d), Je);
            Cl(d, ft);
            break;
          }
        }
        if (d.type !== d.elementType) {
          var _t = G.propTypes;
          _t && Dr(
            _t,
            w,
            // Resolved props
            "prop",
            Pe(G)
          );
        }
      }
      var Ut;
      ll(G) ? (Ut = !0, fo(d)) : Ut = !1, Jn(d, H);
      var yn = d.stateNode, xn;
      yn === null ? (c !== null && (c.alternate = null, d.alternate = null, d.flags |= Ht), Lm(d, G, w), Zp(d, G, w, H), xn = !0) : c === null ? xn = Iv(d, G, w, H) : xn = Hb(c, d, G, w, H);
      var _i = YB(c, d, G, xn, Ut, H);
      {
        var Ar = d.stateNode;
        xn && Ar.props !== w && (Dp || h("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", lt(d) || "a component"), Dp = !0);
      }
      return _i;
    }
    function YB(c, d, G, w, H, z) {
      fR(c, d);
      var Q = (d.flags & pi) !== _e;
      if (!w && !Q)
        return H && Qd(d, G, !1), hh(c, d, z);
      var re = d.stateNode;
      Ch.current = d;
      var ce;
      if (Q && typeof G.getDerivedStateFromError != "function")
        ce = null, bf();
      else {
        bs(d);
        {
          if (xl(!0), ce = re.render(), d.mode & Ma) {
            Ur(!0);
            try {
              re.render();
            } finally {
              Ur(!1);
            }
          }
          xl(!1);
        }
        Jl();
      }
      return d.flags |= ht, c !== null && Q ? o0(c, d, ce, z) : Ml(c, d, ce, z), d.memoizedState = re.state, H && Qd(d, G, !0), d.child;
    }
    function AR(c) {
      var d = c.stateNode;
      d.pendingContext ? pu(c, d.pendingContext, d.pendingContext !== d.context) : d.context && pu(c, d.context, !1), Om(c, d.containerInfo);
    }
    function nV(c, d, G) {
      if (AR(d), c === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var w = d.pendingProps, H = d.memoizedState, z = H.element;
      $i(c, d), lC(d, w, null, G);
      var Q = d.memoizedState;
      d.stateNode;
      var re = Q.element;
      if (Hr && H.isDehydrated) {
        var ce = {
          element: re,
          isDehydrated: !1,
          cache: Q.cache,
          transitions: Q.transitions
        }, Xe = d.updateQueue;
        if (Xe.baseState = ce, d.memoizedState = ce, d.flags & Cr) {
          var Je = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return vR(c, d, re, G, Je);
        } else if (re !== z) {
          var ft = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return vR(c, d, re, G, ft);
        } else {
          oh(d);
          var _t = Um(d, null, re, G);
          d.child = _t;
          for (var Ut = _t; Ut; )
            Ut.flags = Ut.flags & ~Ht | la, Ut = Ut.sibling;
        }
      } else {
        if (No(), re === z)
          return hh(c, d, G);
        Ml(c, d, re, G);
      }
      return d.child;
    }
    function vR(c, d, G, w, H) {
      return No(), Ya(H), d.flags |= Cr, Ml(c, d, G, w), d.child;
    }
    function iV(c, d, G) {
      fv(d), c === null && xp(d);
      var w = d.type, H = d.pendingProps, z = c !== null ? c.memoizedProps : null, Q = H.children, re = Si(w, H);
      return re ? Q = null : z !== null && Si(w, z) && (d.flags |= Ir), fR(c, d), Ml(c, d, Q, G), d.child;
    }
    function FB(c, d) {
      return c === null && xp(d), null;
    }
    function rV(c, d, G, w) {
      c !== null && (c.alternate = null, d.alternate = null, d.flags |= Ht);
      var H = d.pendingProps, z = G, Q = z._payload, re = z._init, ce = re(Q);
      d.type = ce;
      var Xe = d.tag = Zd(ce), Je = Br(ce, H), ft;
      switch (Xe) {
        case k:
          return TB(d, ce), d.type = ce = RC(ce), ft = pR(null, d, ce, Je, w), ft;
        case O:
          return d.type = ce = vS(ce), ft = mR(null, d, ce, Je, w), ft;
        case Ce:
          return d.type = ce = yS(ce), ft = Yv(null, d, ce, Je, w), ft;
        case Ye: {
          if (d.type !== d.elementType) {
            var _t = ce.propTypes;
            _t && Dr(
              _t,
              Je,
              // Resolved for outer only
              "prop",
              Pe(ce)
            );
          }
          return ft = lA(
            null,
            d,
            ce,
            Br(ce.type, Je),
            // The inner type can have defaults too
            w
          ), ft;
        }
      }
      var Ut = "";
      throw ce !== null && typeof ce == "object" && ce.$$typeof === pt && (Ut = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + ce + ". " + ("Lazy element type must resolve to a class or function." + Ut));
    }
    function aV(c, d, G, w, H) {
      c !== null && (c.alternate = null, d.alternate = null, d.flags |= Ht), d.tag = O;
      var z;
      return ll(G) ? (z = !0, fo(d)) : z = !1, Jn(d, H), Lm(d, G, w), Zp(d, G, w, H), YB(null, d, G, !0, z, H);
    }
    function EB(c, d, G, w) {
      c !== null && (c.alternate = null, d.alternate = null, d.flags |= Ht);
      var H = d.pendingProps, z;
      {
        var Q = ps(d, G, !1);
        z = oo(d, Q);
      }
      Jn(d, w);
      var re, ce;
      bs(d);
      {
        if (G.prototype && typeof G.prototype.render == "function") {
          var Xe = Pe(G) || "Unknown";
          WB[Xe] || (h("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Xe, Xe), WB[Xe] = !0);
        }
        d.mode & Ma && Wl.recordLegacyContextWarning(d, null), xl(!0), Ch.current = d, re = xt(null, d, G, H, z, w), ce = Cn(), xl(!1);
      }
      if (Jl(), d.flags |= ht, typeof re == "object" && re !== null && typeof re.render == "function" && re.$$typeof === void 0) {
        var Je = Pe(G) || "Unknown";
        sA[Je] || (h("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Je, Je, Je), sA[Je] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof re == "object" && re !== null && typeof re.render == "function" && re.$$typeof === void 0
      ) {
        {
          var ft = Pe(G) || "Unknown";
          sA[ft] || (h("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ft, ft, ft), sA[ft] = !0);
        }
        d.tag = O, d.memoizedState = null, d.updateQueue = null;
        var _t = !1;
        return ll(G) ? (_t = !0, fo(d)) : _t = !1, d.memoizedState = re.state !== null && re.state !== void 0 ? re.state : null, ji(d), dv(d, re), Zp(d, G, H, w), YB(null, d, G, !0, _t, w);
      } else {
        if (d.tag = k, d.mode & Ma) {
          Ur(!0);
          try {
            re = xt(null, d, G, H, z, w), ce = Cn();
          } finally {
            Ur(!1);
          }
        }
        return ka() && ce && hC(d), Ml(null, d, re, w), TB(d, G), d.child;
      }
    }
    function TB(c, d) {
      {
        if (d && d.childContextTypes && h("%s(...): childContextTypes cannot be defined on a function component.", d.displayName || d.name || "Component"), c.ref !== null) {
          var G = "", w = Bu();
          w && (G += `

Check the render method of \`` + w + "`.");
          var H = w || "", z = c._debugSource;
          z && (H = z.fileName + ":" + z.lineNumber), a0[H] || (a0[H] = !0, h("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", G));
        }
        if (typeof d.getDerivedStateFromProps == "function") {
          var Q = Pe(d) || "Unknown";
          NB[Q] || (h("%s: Function components do not support getDerivedStateFromProps.", Q), NB[Q] = !0);
        }
        if (typeof d.contextType == "object" && d.contextType !== null) {
          var re = Pe(d) || "Unknown";
          VB[re] || (h("%s: Function components do not support contextType.", re), VB[re] = !0);
        }
      }
    }
    var cA = {
      dehydrated: null,
      treeContext: null,
      retryLane: so
    };
    function Fv(c) {
      return {
        baseLanes: c,
        cachePool: eV()
      };
    }
    function yR(c, d) {
      var G = null;
      return {
        baseLanes: Wi(c.baseLanes, d),
        cachePool: G
      };
    }
    function oV(c, d, G, w) {
      if (d !== null) {
        var H = d.memoizedState;
        if (H === null)
          return !1;
      }
      return Yp(c, Xp);
    }
    function bR(c, d) {
      return uo(c.childLanes, d);
    }
    function GR(c, d, G) {
      var w = d.pendingProps;
      O0(d) && (d.flags |= pi);
      var H = Mo.current, z = !1, Q = (d.flags & pi) !== _e;
      if (Q || oV(H, c) ? (z = !0, d.flags &= ~pi) : (c === null || c.memoizedState !== null) && (H = Pm(H, vv)), H = mf(H), Wu(d, H), c === null) {
        xp(d);
        {
          var re = d.memoizedState;
          if (re !== null) {
            var ce = re.dehydrated;
            if (ce !== null)
              return zB(d, ce);
          }
        }
        var Xe = w.children, Je = w.fallback;
        if (z) {
          var ft = sV(d, Xe, Je, G), _t = d.child;
          return _t.memoizedState = Fv(G), d.memoizedState = cA, ft;
        } else
          return s0(d, Xe);
      } else {
        var Ut = c.memoizedState;
        if (Ut !== null) {
          {
            var yn = Ut.dehydrated;
            if (yn !== null)
              if (Q) {
                if (d.flags & Cr)
                  return d.flags &= ~Cr, l0(c, d, G, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (d.memoizedState !== null)
                  return d.child = c.child, d.flags |= pi, null;
                var xn = w.children, _i = w.fallback, Ar = lV(c, d, xn, _i, G), Ui = d.child;
                return Ui.memoizedState = Fv(G), d.memoizedState = cA, Ar;
              } else return uV(c, d, yn, Ut, G);
          }
          if (z) {
            var Bo = w.fallback, ho = w.children, Rt = ZR(c, d, ho, Bo, G), en = d.child, Ct = c.child.memoizedState;
            return en.memoizedState = Ct === null ? Fv(G) : yR(Ct, G), en.childLanes = bR(c, G), d.memoizedState = cA, Rt;
          } else {
            var Vn = w.children, di = SR(c, d, Vn, G);
            return d.memoizedState = null, di;
          }
        } else if (z) {
          var si = w.fallback, Er = w.children, Zr = ZR(c, d, Er, si, G), Ua = d.child, pa = c.child.memoizedState;
          return Ua.memoizedState = pa === null ? Fv(G) : yR(pa, G), Ua.childLanes = bR(c, G), d.memoizedState = cA, Zr;
        } else {
          var Eo = w.children, aa = SR(c, d, Eo, G);
          return d.memoizedState = null, aa;
        }
      }
    }
    function s0(c, d, G) {
      var w = c.mode, H = {
        mode: "visible",
        children: d
      }, z = _B(H, w);
      return z.return = c, c.child = z, z;
    }
    function sV(c, d, G, w) {
      var H = c.mode, z = c.child, Q = {
        mode: "hidden",
        children: d
      }, re, ce;
      return (H & Rr) === Oi && z !== null ? (re = z, re.childLanes = Dt, re.pendingProps = Q, c.mode & xr && (re.actualDuration = 0, re.actualStartTime = -1, re.selfBaseDuration = 0, re.treeBaseDuration = 0), ce = sm(G, H, w, null)) : (re = _B(Q, H), ce = sm(G, H, w, null)), re.return = c, ce.return = c, re.sibling = ce, c.child = re, ce;
    }
    function _B(c, d, G) {
      return ZS(c, d, Dt, null);
    }
    function BR(c, d) {
      return Lf(c, d);
    }
    function SR(c, d, G, w) {
      var H = c.child, z = H.sibling, Q = BR(H, {
        mode: "visible",
        children: G
      });
      if ((d.mode & Rr) === Oi && (Q.lanes = w), Q.return = d, Q.sibling = null, z !== null) {
        var re = d.deletions;
        re === null ? (d.deletions = [z], d.flags |= xi) : re.push(z);
      }
      return d.child = Q, Q;
    }
    function ZR(c, d, G, w, H) {
      var z = d.mode, Q = c.child, re = Q.sibling, ce = {
        mode: "hidden",
        children: G
      }, Xe;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (z & Rr) === Oi && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        d.child !== Q
      ) {
        var Je = d.child;
        Xe = Je, Xe.childLanes = Dt, Xe.pendingProps = ce, d.mode & xr && (Xe.actualDuration = 0, Xe.actualStartTime = -1, Xe.selfBaseDuration = Q.selfBaseDuration, Xe.treeBaseDuration = Q.treeBaseDuration), d.deletions = null;
      } else
        Xe = BR(Q, ce), Xe.subtreeFlags = Q.subtreeFlags & Yn;
      var ft;
      return re !== null ? ft = Lf(re, w) : (ft = sm(w, z, H, null), ft.flags |= Ht), ft.return = d, Xe.return = d, Xe.sibling = ft, d.child = Xe, ft;
    }
    function l0(c, d, G, w) {
      w !== null && Ya(w), uh(d, c.child, null, G);
      var H = d.pendingProps, z = H.children, Q = s0(d, z);
      return Q.flags |= Ht, d.memoizedState = null, Q;
    }
    function lV(c, d, G, w, H) {
      var z = d.mode, Q = {
        mode: "visible",
        children: G
      }, re = _B(Q, z), ce = sm(w, z, H, null);
      return ce.flags |= Ht, re.return = d, ce.return = d, re.sibling = ce, d.child = re, (d.mode & Rr) !== Oi && uh(d, c.child, null, H), ce;
    }
    function zB(c, d, G) {
      return (c.mode & Rr) === Oi ? (h("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), c.lanes = nr) : Ia(d) ? c.lanes = Rc : c.lanes = ks, null;
    }
    function uV(c, d, G, w, H) {
      if (Ss(), (d.mode & Rr) === Oi)
        return l0(
          c,
          d,
          H,
          // TODO: When we delete legacy mode, we should make this error argument
          // required — every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (Ia(G))
        return l0(
          c,
          d,
          H,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var z = ja(H, c.childLanes);
      if (uc || z) {
        var Q = ay();
        if (Q !== null) {
          var re = Ha(Q, H);
          if (re !== so && re !== w.retryLane) {
            w.retryLane = re;
            var ce = Pi;
            pl(c, re, ce);
          }
        }
        return hS(), l0(c, d, H, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (br(G)) {
        d.flags |= pi, d.child = c.child;
        var Xe = AS.bind(null, c);
        return Fr(G, Xe), null;
      } else {
        Dm(d, G, w.treeContext);
        var Je = d.pendingProps, ft = Je.children, _t = s0(d, ft);
        return _t.flags |= la, _t;
      }
    }
    function wR(c, d, G) {
      c.lanes = Wi(c.lanes, d);
      var w = c.alternate;
      w !== null && (w.lanes = Wi(w.lanes, d)), nt(c.return, d, G);
    }
    function cV(c, d, G) {
      for (var w = d; w !== null; ) {
        if (w.tag === le) {
          var H = w.memoizedState;
          H !== null && wR(w, G, c);
        } else if (w.tag === St)
          wR(w, G, c);
        else if (w.child !== null) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === c)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === c)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function gV(c) {
      for (var d = c, G = null; d !== null; ) {
        var w = d.alternate;
        w !== null && ch(w) === null && (G = d), d = d.sibling;
      }
      return G;
    }
    function dV(c) {
      if (c !== void 0 && c !== "forwards" && c !== "backwards" && c !== "together" && !MB[c])
        if (MB[c] = !0, typeof c == "string")
          switch (c.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              h('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', c, c.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              h('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', c, c.toLowerCase());
              break;
            }
            default:
              h('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', c);
              break;
          }
        else
          h('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', c);
    }
    function IV(c, d) {
      c !== void 0 && !Xv[c] && (c !== "collapsed" && c !== "hidden" ? (Xv[c] = !0, h('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', c)) : d !== "forwards" && d !== "backwards" && (Xv[c] = !0, h('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', c)));
    }
    function RR(c, d) {
      {
        var G = Mt(c), w = !G && typeof Ie(c) == "function";
        if (G || w) {
          var H = G ? "array" : "iterable";
          return h("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", H, d, H), !1;
        }
      }
      return !0;
    }
    function CV(c, d) {
      if ((d === "forwards" || d === "backwards") && c !== void 0 && c !== null && c !== !1)
        if (Mt(c)) {
          for (var G = 0; G < c.length; G++)
            if (!RR(c[G], G))
              return;
        } else {
          var w = Ie(c);
          if (typeof w == "function") {
            var H = w.call(c);
            if (H)
              for (var z = H.next(), Q = 0; !z.done; z = H.next()) {
                if (!RR(z.value, Q))
                  return;
                Q++;
              }
          } else
            h('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', d);
        }
    }
    function KB(c, d, G, w, H) {
      var z = c.memoizedState;
      z === null ? c.memoizedState = {
        isBackwards: d,
        rendering: null,
        renderingStartTime: 0,
        last: w,
        tail: G,
        tailMode: H
      } : (z.isBackwards = d, z.rendering = null, z.renderingStartTime = 0, z.last = w, z.tail = G, z.tailMode = H);
    }
    function LB(c, d, G) {
      var w = d.pendingProps, H = w.revealOrder, z = w.tail, Q = w.children;
      dV(H), IV(z, H), CV(Q, H), Ml(c, d, Q, G);
      var re = Mo.current, ce = Yp(re, Xp);
      if (ce)
        re = md(re, Xp), d.flags |= pi;
      else {
        var Xe = c !== null && (c.flags & pi) !== _e;
        Xe && cV(d, d.child, G), re = mf(re);
      }
      if (Wu(d, re), (d.mode & Rr) === Oi)
        d.memoizedState = null;
      else
        switch (H) {
          case "forwards": {
            var Je = gV(d.child), ft;
            Je === null ? (ft = d.child, d.child = null) : (ft = Je.sibling, Je.sibling = null), KB(
              d,
              !1,
              // isBackwards
              ft,
              Je,
              z
            );
            break;
          }
          case "backwards": {
            var _t = null, Ut = d.child;
            for (d.child = null; Ut !== null; ) {
              var yn = Ut.alternate;
              if (yn !== null && ch(yn) === null) {
                d.child = Ut;
                break;
              }
              var xn = Ut.sibling;
              Ut.sibling = _t, _t = Ut, Ut = xn;
            }
            KB(
              d,
              !0,
              // isBackwards
              _t,
              null,
              // last
              z
            );
            break;
          }
          case "together": {
            KB(
              d,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            d.memoizedState = null;
        }
      return d.child;
    }
    function kB(c, d, G) {
      Om(d, d.stateNode.containerInfo);
      var w = d.pendingProps;
      return c === null ? d.child = uh(d, null, w, G) : Ml(c, d, w, G), d.child;
    }
    var xR = !1;
    function hV(c, d, G) {
      var w = d.type, H = w._context, z = d.pendingProps, Q = d.memoizedProps, re = z.value;
      {
        "value" in z || xR || (xR = !0, h("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var ce = d.type.propTypes;
        ce && Dr(ce, z, "prop", "Context.Provider");
      }
      if ($(d, H, re), Q !== null) {
        var Xe = Q.value;
        if (Js(Xe, re)) {
          if (Q.children === z.children && !Jd())
            return hh(c, d, G);
        } else
          kt(d, H, G);
      }
      var Je = z.children;
      return Ml(c, d, Je, G), d.child;
    }
    var Ev = !1;
    function Tv(c, d, G) {
      var w = d.type;
      w._context === void 0 ? w !== w.Consumer && (Ev || (Ev = !0, h("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : w = w._context;
      var H = d.pendingProps, z = H.children;
      typeof z != "function" && h("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Jn(d, G);
      var Q = mi(w);
      bs(d);
      var re;
      return Ch.current = d, xl(!0), re = z(Q), xl(!1), Jl(), d.flags |= ht, Ml(c, d, re, G), d.child;
    }
    function u0() {
      uc = !0;
    }
    function hh(c, d, G) {
      return c !== null && (d.dependencies = c.dependencies), bf(), W0(d.lanes), ja(G, d.childLanes) ? (ff(c, d), d.child) : null;
    }
    function fV(c, d, G) {
      {
        var w = d.return;
        if (w === null)
          throw new Error("Cannot swap the root fiber.");
        if (c.alternate = null, d.alternate = null, G.index = d.index, G.sibling = d.sibling, G.return = d.return, G.ref = d.ref, d === w.child)
          w.child = G;
        else {
          var H = w.child;
          if (H === null)
            throw new Error("Expected parent to have a child.");
          for (; H.sibling !== d; )
            if (H = H.sibling, H === null)
              throw new Error("Expected to find the previous sibling.");
          H.sibling = G;
        }
        var z = w.deletions;
        return z === null ? (w.deletions = [c], w.flags |= xi) : z.push(c), G.flags |= Ht, G;
      }
    }
    function DB(c, d) {
      var G = c.lanes;
      return !!ja(G, d);
    }
    function pV(c, d, G) {
      switch (d.tag) {
        case te:
          AR(d), d.stateNode, No();
          break;
        case pe:
          fv(d);
          break;
        case O: {
          var w = d.type;
          ll(w) && fo(d);
          break;
        }
        case fe:
          Om(d, d.stateNode.containerInfo);
          break;
        case ee: {
          var H = d.memoizedProps.value, z = d.type._context;
          $(d, z, H);
          break;
        }
        case be:
          {
            var Q = ja(G, d.childLanes);
            Q && (d.flags |= an);
            {
              var re = d.stateNode;
              re.effectDuration = 0, re.passiveEffectDuration = 0;
            }
          }
          break;
        case le: {
          var ce = d.memoizedState;
          if (ce !== null) {
            if (ce.dehydrated !== null)
              return Wu(d, mf(Mo.current)), d.flags |= pi, null;
            var Xe = d.child, Je = Xe.childLanes;
            if (ja(G, Je))
              return GR(c, d, G);
            Wu(d, mf(Mo.current));
            var ft = hh(c, d, G);
            return ft !== null ? ft.sibling : null;
          } else
            Wu(d, mf(Mo.current));
          break;
        }
        case St: {
          var _t = (c.flags & pi) !== _e, Ut = ja(G, d.childLanes);
          if (_t) {
            if (Ut)
              return LB(c, d, G);
            d.flags |= pi;
          }
          var yn = d.memoizedState;
          if (yn !== null && (yn.rendering = null, yn.tail = null, yn.lastEffect = null), Wu(d, Mo.current), Ut)
            break;
          return null;
        }
        case hn:
        case mn:
          return d.lanes = Dt, hR(c, d, G);
      }
      return hh(c, d, G);
    }
    function WR(c, d, G) {
      if (d._debugNeedsRemount && c !== null)
        return fV(c, d, py(d.type, d.key, d.pendingProps, d._debugOwner || null, d.mode, d.lanes));
      if (c !== null) {
        var w = c.memoizedProps, H = d.pendingProps;
        if (w !== H || Jd() || // Force a re-render if the implementation changed due to hot reload:
        d.type !== c.type)
          uc = !0;
        else {
          var z = DB(c, G);
          if (!z && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (d.flags & pi) === _e)
            return uc = !1, pV(c, d, G);
          (c.flags & Bt) !== _e ? uc = !0 : uc = !1;
        }
      } else if (uc = !1, ka() && dI(d)) {
        var Q = d.index, re = Cd();
        km(d, re, Q);
      }
      switch (d.lanes = Dt, d.tag) {
        case J:
          return EB(c, d, d.type, G);
        case ke: {
          var ce = d.elementType;
          return rV(c, d, ce, G);
        }
        case k: {
          var Xe = d.type, Je = d.pendingProps, ft = d.elementType === Xe ? Je : Br(Xe, Je);
          return pR(c, d, Xe, ft, G);
        }
        case O: {
          var _t = d.type, Ut = d.pendingProps, yn = d.elementType === _t ? Ut : Br(_t, Ut);
          return mR(c, d, _t, yn, G);
        }
        case te:
          return nV(c, d, G);
        case pe:
          return iV(c, d, G);
        case Ae:
          return FB(c, d);
        case le:
          return GR(c, d, G);
        case fe:
          return kB(c, d, G);
        case Ce: {
          var xn = d.type, _i = d.pendingProps, Ar = d.elementType === xn ? _i : Br(xn, _i);
          return Yv(c, d, xn, Ar, G);
        }
        case Te:
          return HB(c, d, G);
        case Ke:
          return XB(c, d, G);
        case be:
          return tV(c, d, G);
        case ee:
          return hV(c, d, G);
        case je:
          return Tv(c, d, G);
        case Ye: {
          var Ui = d.type, Bo = d.pendingProps, ho = Br(Ui, Bo);
          if (d.type !== d.elementType) {
            var Rt = Ui.propTypes;
            Rt && Dr(
              Rt,
              ho,
              // Resolved for outer only
              "prop",
              Pe(Ui)
            );
          }
          return ho = Br(Ui.type, ho), lA(c, d, Ui, ho, G);
        }
        case $e:
          return uA(c, d, d.type, d.pendingProps, G);
        case ot: {
          var en = d.type, Ct = d.pendingProps, Vn = d.elementType === en ? Ct : Br(en, Ct);
          return aV(c, d, en, Vn, G);
        }
        case St:
          return LB(c, d, G);
        case ln:
          break;
        case hn:
          return hR(c, d, G);
      }
      throw new Error("Unknown unit of work tag (" + d.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function mV(c, d, G) {
      switch (lf(d), d.tag) {
        case O: {
          var w = d.type;
          ll(w) && Pu(d);
          var H = d.flags;
          return H & ut ? (d.flags = H & ~ut | pi, (d.mode & xr) !== Oi && rA(d), d) : null;
        }
        case te: {
          Da(d), Sl(d), Af();
          var z = d.flags;
          return (z & ut) !== _e && (z & pi) === _e ? (d.flags = z & ~ut | pi, d) : null;
        }
        case pe:
          return pv(d), null;
        case le: {
          mI(d);
          {
            var Q = d.memoizedState;
            if (Q !== null && Q.dehydrated !== null) {
              if (d.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              No();
            }
          }
          var re = d.flags;
          return re & ut ? (d.flags = re & ~ut | pi, (d.mode & xr) !== Oi && rA(d), d) : null;
        }
        case St:
          return mI(d), null;
        case fe:
          return Da(d), null;
        case ee:
          var ce = d.type._context;
          return Ve(ce, d), null;
        case hn:
        case mn:
          return oy(d), null;
        case Pn:
          return null;
        default:
          return null;
      }
    }
    function UB(c, d, G) {
      switch (lf(d), d.tag) {
        case O: {
          var w = d.type.childContextTypes;
          w != null && Pu(d);
          break;
        }
        case te: {
          Da(d), Sl(d), Af();
          break;
        }
        case pe: {
          pv(d);
          break;
        }
        case fe:
          Da(d);
          break;
        case le:
          mI(d);
          break;
        case St:
          mI(d);
          break;
        case ee:
          var H = d.type._context;
          Ve(H, d);
          break;
        case hn:
        case mn:
          oy(d);
          break;
      }
    }
    function VR(c, d, G, w, H, z, Q, re, ce) {
      var Xe = Array.prototype.slice.call(arguments, 3);
      try {
        d.apply(G, Xe);
      } catch (Je) {
        this.onError(Je);
      }
    }
    var NR = VR;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var OB = document.createElement("react");
      NR = function(d, G, w, H, z, Q, re, ce, Xe) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Je = document.createEvent("Event"), ft = !1, _t = !0, Ut = window.event, yn = Object.getOwnPropertyDescriptor(window, "event");
        function xn() {
          OB.removeEventListener(en, Ar, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ut);
        }
        var _i = Array.prototype.slice.call(arguments, 3);
        function Ar() {
          ft = !0, xn(), G.apply(w, _i), _t = !1;
        }
        var Ui, Bo = !1, ho = !1;
        function Rt(Ct) {
          if (Ui = Ct.error, Bo = !0, Ui === null && Ct.colno === 0 && Ct.lineno === 0 && (ho = !0), Ct.defaultPrevented && Ui != null && typeof Ui == "object")
            try {
              Ui._suppressLogging = !0;
            } catch {
            }
        }
        var en = "react-" + (d || "invokeguardedcallback");
        if (window.addEventListener("error", Rt), OB.addEventListener(en, Ar, !1), Je.initEvent(en, !1, !1), OB.dispatchEvent(Je), yn && Object.defineProperty(window, "event", yn), ft && _t && (Bo ? ho && (Ui = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Ui = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Ui)), window.removeEventListener("error", Rt), !ft)
          return xn(), VR.apply(this, arguments);
      };
    }
    var AV = NR, _v = !1, c0 = null, vV = {
      onError: function(c) {
        _v = !0, c0 = c;
      }
    };
    function MR(c, d, G, w, H, z, Q, re, ce) {
      _v = !1, c0 = null, AV.apply(vV, arguments);
    }
    function yV() {
      return _v;
    }
    function HR() {
      if (_v) {
        var c = c0;
        return _v = !1, c0 = null, c;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var XR = null;
    XR = /* @__PURE__ */ new Set();
    var g0 = !1, Gf = !1, bV = typeof WeakSet == "function" ? WeakSet : Set, ii = null, gA = null, yI = null;
    function Is(c) {
      MR(null, function() {
        throw c;
      }), HR();
    }
    var PB = function(c, d) {
      if (d.props = c.memoizedProps, d.state = c.memoizedState, c.mode & xr)
        try {
          Nu(), d.componentWillUnmount();
        } finally {
          Lc(c);
        }
      else
        d.componentWillUnmount();
    };
    function dA(c, d) {
      try {
        yd(Ho, c);
      } catch (G) {
        Is(G), Co(c, d, G);
      }
    }
    function zv(c, d, G) {
      try {
        PB(c, G);
      } catch (w) {
        Is(w), Co(c, d, w);
      }
    }
    function GV(c, d, G) {
      try {
        G.componentDidMount();
      } catch (w) {
        Is(w), Co(c, d, w);
      }
    }
    function YR(c, d) {
      try {
        kv(c);
      } catch (G) {
        Is(G), Co(c, d, G);
      }
    }
    function d0(c, d) {
      var G = c.ref;
      if (G !== null)
        if (typeof G == "function") {
          var w;
          try {
            if (U && q && c.mode & xr)
              try {
                Nu(), w = G(null);
              } finally {
                Lc(c);
              }
            else
              w = G(null);
          } catch (H) {
            Is(H), Co(c, d, H);
          }
          typeof w == "function" && h("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", lt(c));
        } else
          G.current = null;
    }
    function Bf(c, d, G) {
      try {
        G();
      } catch (w) {
        Is(w), Co(c, d, w);
      }
    }
    var Kv = !1;
    function FR(c, d) {
      Be(c.containerInfo), ii = d, Lv();
      var G = Kv;
      return Kv = !1, G;
    }
    function Lv() {
      for (; ii !== null; ) {
        var c = ii, d = c.child;
        (c.subtreeFlags & Nt) !== _e && d !== null ? (Bd(d, c), ii = d) : Up();
      }
    }
    function Up() {
      for (; ii !== null; ) {
        var c = ii;
        Ao(c);
        try {
          Sf(c);
        } catch (G) {
          Is(G), Co(c, c.return, G);
        }
        $r();
        var d = c.sibling;
        if (d !== null) {
          Bd(d, c.return), ii = d;
          return;
        }
        ii = c.return;
      }
    }
    function Sf(c) {
      var d = c.alternate, G = c.flags;
      if ((G & zr) !== _e) {
        switch (Ao(c), c.tag) {
          case k:
          case Ce:
          case $e:
            break;
          case O: {
            if (d !== null) {
              var w = d.memoizedProps, H = d.memoizedState, z = c.stateNode;
              c.type === c.elementType && !Dp && (z.props !== c.memoizedProps && h("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", lt(c) || "instance"), z.state !== c.memoizedState && h("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", lt(c) || "instance"));
              var Q = z.getSnapshotBeforeUpdate(c.elementType === c.type ? w : Br(c.type, w), H);
              {
                var re = XR;
                Q === void 0 && !re.has(c.type) && (re.add(c.type), h("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", lt(c)));
              }
              z.__reactInternalSnapshotBeforeUpdate = Q;
            }
            break;
          }
          case te: {
            if (qi) {
              var ce = c.stateNode;
              ie(ce.containerInfo);
            }
            break;
          }
          case pe:
          case Ae:
          case fe:
          case ot:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        $r();
      }
    }
    function fl(c, d, G) {
      var w = d.updateQueue, H = w !== null ? w.lastEffect : null;
      if (H !== null) {
        var z = H.next, Q = z;
        do {
          if ((Q.tag & c) === c) {
            var re = Q.destroy;
            Q.destroy = void 0, re !== void 0 && ((c & ws) !== zc ? ih(d) : (c & Ho) !== zc && Xa(d), Bf(d, G, re), (c & ws) !== zc ? dd() : (c & Ho) !== zc && Ql());
          }
          Q = Q.next;
        } while (Q !== z);
      }
    }
    function yd(c, d) {
      var G = d.updateQueue, w = G !== null ? G.lastEffect : null;
      if (w !== null) {
        var H = w.next, z = H;
        do {
          if ((z.tag & c) === c) {
            (c & ws) !== zc ? Mc(d) : (c & Ho) !== zc && aI(d);
            var Q = z.create;
            z.destroy = Q(), (c & ws) !== zc ? Uo() : (c & Ho) !== zc && iC();
            {
              var re = z.destroy;
              if (re !== void 0 && typeof re != "function") {
                var ce = void 0;
                (z.tag & Ho) !== _e ? ce = "useLayoutEffect" : (z.tag & yC) !== _e ? ce = "useInsertionEffect" : ce = "useEffect";
                var Xe = void 0;
                re === null ? Xe = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof re.then == "function" ? Xe = `

It looks like you wrote ` + ce + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + ce + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Xe = " You returned: " + re, h("%s must not return anything besides a function, which is used for clean-up.%s", ce, Xe);
              }
            }
          }
          z = z.next;
        } while (z !== H);
      }
    }
    function JB(c, d) {
      if ((d.flags & an) !== _e)
        switch (d.tag) {
          case be: {
            var G = d.stateNode.passiveEffectDuration, w = d.memoizedProps, H = w.id, z = w.onPostCommit, Q = dh(), re = d.alternate === null ? "mount" : "update";
            lR() && (re = "nested-update"), typeof z == "function" && z(H, re, G, Q);
            var ce = d.return;
            e: for (; ce !== null; ) {
              switch (ce.tag) {
                case te:
                  var Xe = ce.stateNode;
                  Xe.passiveEffectDuration += G;
                  break e;
                case be:
                  var Je = ce.stateNode;
                  Je.passiveEffectDuration += G;
                  break e;
              }
              ce = ce.return;
            }
            break;
          }
        }
    }
    function BV(c, d, G, w) {
      if ((G.flags & vn) !== _e)
        switch (G.tag) {
          case k:
          case Ce:
          case $e: {
            if (!Gf)
              if (G.mode & xr)
                try {
                  Nu(), yd(Ho | Va, G);
                } finally {
                  Lc(G);
                }
              else
                yd(Ho | Va, G);
            break;
          }
          case O: {
            var H = G.stateNode;
            if (G.flags & an && !Gf)
              if (d === null)
                if (G.type === G.elementType && !Dp && (H.props !== G.memoizedProps && h("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", lt(G) || "instance"), H.state !== G.memoizedState && h("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", lt(G) || "instance")), G.mode & xr)
                  try {
                    Nu(), H.componentDidMount();
                  } finally {
                    Lc(G);
                  }
                else
                  H.componentDidMount();
              else {
                var z = G.elementType === G.type ? d.memoizedProps : Br(G.type, d.memoizedProps), Q = d.memoizedState;
                if (G.type === G.elementType && !Dp && (H.props !== G.memoizedProps && h("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", lt(G) || "instance"), H.state !== G.memoizedState && h("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", lt(G) || "instance")), G.mode & xr)
                  try {
                    Nu(), H.componentDidUpdate(z, Q, H.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Lc(G);
                  }
                else
                  H.componentDidUpdate(z, Q, H.__reactInternalSnapshotBeforeUpdate);
              }
            var re = G.updateQueue;
            re !== null && (G.type === G.elementType && !Dp && (H.props !== G.memoizedProps && h("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", lt(G) || "instance"), H.state !== G.memoizedState && h("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", lt(G) || "instance")), zm(G, re, H));
            break;
          }
          case te: {
            var ce = G.updateQueue;
            if (ce !== null) {
              var Xe = null;
              if (G.child !== null)
                switch (G.child.tag) {
                  case pe:
                    Xe = bn(G.child.stateNode);
                    break;
                  case O:
                    Xe = G.child.stateNode;
                    break;
                }
              zm(G, ce, Xe);
            }
            break;
          }
          case pe: {
            var Je = G.stateNode;
            if (d === null && G.flags & an) {
              var ft = G.type, _t = G.memoizedProps;
              gu(Je, ft, _t, G);
            }
            break;
          }
          case Ae:
            break;
          case fe:
            break;
          case be: {
            {
              var Ut = G.memoizedProps, yn = Ut.onCommit, xn = Ut.onRender, _i = G.stateNode.effectDuration, Ar = dh(), Ui = d === null ? "mount" : "update";
              lR() && (Ui = "nested-update"), typeof xn == "function" && xn(G.memoizedProps.id, Ui, G.actualDuration, G.treeBaseDuration, G.actualStartTime, Ar);
              {
                typeof yn == "function" && yn(G.memoizedProps.id, Ui, _i, Ar), pS(G);
                var Bo = G.return;
                e: for (; Bo !== null; ) {
                  switch (Bo.tag) {
                    case te:
                      var ho = Bo.stateNode;
                      ho.effectDuration += _i;
                      break e;
                    case be:
                      var Rt = Bo.stateNode;
                      Rt.effectDuration += _i;
                      break e;
                  }
                  Bo = Bo.return;
                }
              }
            }
            break;
          }
          case le: {
            C0(c, G);
            break;
          }
          case St:
          case ot:
          case ln:
          case hn:
          case mn:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Gf || G.flags & Sa && kv(G);
    }
    function ER(c) {
      switch (c.tag) {
        case k:
        case Ce:
        case $e: {
          if (c.mode & xr)
            try {
              Nu(), dA(c, c.return);
            } finally {
              Lc(c);
            }
          else
            dA(c, c.return);
          break;
        }
        case O: {
          var d = c.stateNode;
          typeof d.componentDidMount == "function" && GV(c, c.return, d), YR(c, c.return);
          break;
        }
        case pe: {
          YR(c, c.return);
          break;
        }
      }
    }
    function TR(c, d) {
      var G = null;
      if (qi)
        for (var w = c; ; ) {
          if (w.tag === pe) {
            if (G === null) {
              G = w;
              var H = w.stateNode;
              d ? al(H) : Bl(w.stateNode, w.memoizedProps);
            }
          } else if (w.tag === Ae) {
            if (G === null) {
              var z = w.stateNode;
              d ? kC(z) : kI(z, w.memoizedProps);
            }
          } else if (!((w.tag === hn || w.tag === mn) && w.memoizedState !== null && w !== c)) {
            if (w.child !== null) {
              w.child.return = w, w = w.child;
              continue;
            }
          }
          if (w === c)
            return;
          for (; w.sibling === null; ) {
            if (w.return === null || w.return === c)
              return;
            G === w && (G = null), w = w.return;
          }
          G === w && (G = null), w.sibling.return = w.return, w = w.sibling;
        }
    }
    function kv(c) {
      var d = c.ref;
      if (d !== null) {
        var G = c.stateNode, w;
        switch (c.tag) {
          case pe:
            w = bn(G);
            break;
          default:
            w = G;
        }
        if (typeof d == "function") {
          var H;
          if (c.mode & xr)
            try {
              Nu(), H = d(w);
            } finally {
              Lc(c);
            }
          else
            H = d(w);
          typeof H == "function" && h("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", lt(c));
        } else
          d.hasOwnProperty("current") || h("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", lt(c)), d.current = w;
      }
    }
    function bI(c) {
      var d = c.ref;
      if (d !== null)
        if (typeof d == "function")
          if (c.mode & xr)
            try {
              Nu(), d(null);
            } finally {
              Lc(c);
            }
          else
            d(null);
        else
          d.current = null;
    }
    function I0(c, d, G) {
      switch (ha(d), d.tag) {
        case k:
        case Ce:
        case Ye:
        case $e: {
          var w = d.updateQueue;
          if (w !== null) {
            var H = w.lastEffect;
            if (H !== null) {
              var z = H.next, Q = z;
              do {
                var re = Q, ce = re.destroy, Xe = re.tag;
                ce !== void 0 && ((Xe & yC) !== zc ? Bf(d, G, ce) : (Xe & Ho) !== zc && (Xa(d), d.mode & xr ? (Nu(), Bf(d, G, ce), Lc(d)) : Bf(d, G, ce), Ql())), Q = Q.next;
              } while (Q !== z);
            }
          }
          return;
        }
        case O: {
          d0(d, G);
          var Je = d.stateNode;
          typeof Je.componentWillUnmount == "function" && zv(d, G, Je);
          return;
        }
        case pe: {
          d0(d, G);
          return;
        }
        case fe: {
          qi ? jB(c, d, G) : ci && Mu(d);
          return;
        }
        case wt:
          return;
        case ln:
          return;
      }
    }
    function Dv(c, d, G) {
      for (var w = d; ; ) {
        if (I0(c, w, G), w.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!qi || w.tag !== fe)) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === d)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === d)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function fh(c) {
      var d = c.alternate;
      d !== null && (d.return = null), c.return = null;
    }
    function ph(c) {
      var d = c.alternate;
      d !== null && (c.alternate = null, ph(d));
      {
        if (c.child = null, c.deletions = null, c.sibling = null, c.tag === pe) {
          var G = c.stateNode;
          G !== null && Hn(G);
        }
        c.stateNode = null, c._debugOwner = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
      }
    }
    function Mu(c) {
      if (ci) {
        var d = c.stateNode, G = d.containerInfo, w = bt(G);
        ui(G, w);
      }
    }
    function Hu(c) {
      if (ci) {
        switch (c.tag) {
          case O:
          case pe:
          case Ae:
            return;
          case te:
          case fe: {
            var d = c.stateNode, G = d.containerInfo, w = d.pendingChildren;
            ui(G, w);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function QB(c) {
      for (var d = c.return; d !== null; ) {
        if (kc(d))
          return d;
        d = d.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function kc(c) {
      return c.tag === pe || c.tag === te || c.tag === fe;
    }
    function SC(c) {
      var d = c;
      e: for (; ; ) {
        for (; d.sibling === null; ) {
          if (d.return === null || kc(d.return))
            return null;
          d = d.return;
        }
        for (d.sibling.return = d.return, d = d.sibling; d.tag !== pe && d.tag !== Ae && d.tag !== wt; ) {
          if (d.flags & Ht || d.child === null || d.tag === fe)
            continue e;
          d.child.return = d, d = d.child;
        }
        if (!(d.flags & Ht))
          return d.stateNode;
      }
    }
    function GI(c) {
      if (qi) {
        var d = QB(c);
        switch (d.tag) {
          case pe: {
            var G = d.stateNode;
            d.flags & Ir && (Bc(G), d.flags &= ~Ir);
            var w = SC(c);
            Zf(c, w, G);
            break;
          }
          case te:
          case fe: {
            var H = d.stateNode.containerInfo, z = SC(c);
            Uv(c, z, H);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function Uv(c, d, G) {
      var w = c.tag, H = w === pe || w === Ae;
      if (H) {
        var z = c.stateNode;
        d ? du(G, z, d) : is(G, z);
      } else if (w !== fe) {
        var Q = c.child;
        if (Q !== null) {
          Uv(Q, d, G);
          for (var re = Q.sibling; re !== null; )
            Uv(re, d, G), re = re.sibling;
        }
      }
    }
    function Zf(c, d, G) {
      var w = c.tag, H = w === pe || w === Ae;
      if (H) {
        var z = c.stateNode;
        d ? rl(G, z, d) : Ja(G, z);
      } else if (w !== fe) {
        var Q = c.child;
        if (Q !== null) {
          Zf(Q, d, G);
          for (var re = Q.sibling; re !== null; )
            Zf(re, d, G), re = re.sibling;
        }
      }
    }
    function jB(c, d, G) {
      for (var w = d, H = !1, z, Q; ; ) {
        if (!H) {
          var re = w.return;
          e: for (; ; ) {
            if (re === null)
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            var ce = re.stateNode;
            switch (re.tag) {
              case pe:
                z = ce, Q = !1;
                break e;
              case te:
                z = ce.containerInfo, Q = !0;
                break e;
              case fe:
                z = ce.containerInfo, Q = !0;
                break e;
            }
            re = re.return;
          }
          H = !0;
        }
        if (w.tag === pe || w.tag === Ae)
          Dv(c, w, G), Q ? ku(z, w.stateNode) : jg(z, w.stateNode);
        else if (w.tag === wt)
          Q ? kh(z, w.stateNode) : pp(z, w.stateNode);
        else if (w.tag === fe) {
          if (w.child !== null) {
            z = w.stateNode.containerInfo, Q = !0, w.child.return = w, w = w.child;
            continue;
          }
        } else if (I0(c, w, G), w.child !== null) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === d)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === d)
            return;
          w = w.return, w.tag === fe && (H = !1);
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function IA(c, d, G) {
      qi ? jB(c, d, G) : Dv(c, d, G), fh(d);
    }
    function CA(c, d) {
      if (!qi) {
        switch (d.tag) {
          case k:
          case Ce:
          case Ye:
          case $e: {
            if (fl(yC | Va, d, d.return), yd(yC | Va, d), d.mode & xr)
              try {
                Nu(), fl(Ho | Va, d, d.return);
              } finally {
                Lc(d);
              }
            else
              fl(Ho | Va, d, d.return);
            return;
          }
          case be:
            return;
          case le: {
            BI(d), hA(d);
            return;
          }
          case St: {
            hA(d);
            return;
          }
          case te: {
            if (Hr && c !== null) {
              var G = c.memoizedState;
              if (G.isDehydrated) {
                var w = d.stateNode;
                UC(w.containerInfo);
              }
            }
            break;
          }
          case hn:
          case mn:
            return;
        }
        Hu(d);
        return;
      }
      switch (d.tag) {
        case k:
        case Ce:
        case Ye:
        case $e: {
          if (fl(yC | Va, d, d.return), yd(yC | Va, d), d.mode & xr)
            try {
              Nu(), fl(Ho | Va, d, d.return);
            } finally {
              Lc(d);
            }
          else
            fl(Ho | Va, d, d.return);
          return;
        }
        case O:
          return;
        case pe: {
          var H = d.stateNode;
          if (H != null) {
            var z = d.memoizedProps, Q = c !== null ? c.memoizedProps : z, re = d.type, ce = d.updateQueue;
            d.updateQueue = null, ce !== null && rs(H, ce, re, Q, z, d);
          }
          return;
        }
        case Ae: {
          if (d.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var Xe = d.stateNode, Je = d.memoizedProps, ft = c !== null ? c.memoizedProps : Je;
          Qg(Xe, ft, Je);
          return;
        }
        case te: {
          if (Hr && c !== null) {
            var _t = c.memoizedState;
            if (_t.isDehydrated) {
              var Ut = d.stateNode;
              UC(Ut.containerInfo);
            }
          }
          return;
        }
        case be:
          return;
        case le: {
          BI(d), hA(d);
          return;
        }
        case St: {
          hA(d);
          return;
        }
        case ot:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function BI(c) {
      c.memoizedState;
    }
    function C0(c, d) {
      if (Hr) {
        var G = d.memoizedState;
        if (G === null) {
          var w = d.alternate;
          if (w !== null) {
            var H = w.memoizedState;
            if (H !== null) {
              var z = H.dehydrated;
              z !== null && fp(z);
            }
          }
        }
      }
    }
    function hA(c) {
      var d = c.updateQueue;
      if (d !== null) {
        c.updateQueue = null;
        var G = c.stateNode;
        G === null && (G = c.stateNode = new bV()), d.forEach(function(w) {
          var H = HV.bind(null, c, w);
          if (!G.has(w)) {
            if (G.add(w), xo)
              if (gA !== null && yI !== null)
                jn(yI, gA);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            w.then(H, H);
          }
        });
      }
    }
    function _R(c) {
      qi && Bc(c.stateNode);
    }
    function zR(c, d, G) {
      gA = G, yI = c, ii = d, h0(c, G), gA = null, yI = null;
    }
    function h0(c, d) {
      for (; ii !== null; ) {
        var G = ii, w = G.deletions;
        if (w !== null)
          for (var H = 0; H < w.length; H++) {
            var z = w[H];
            try {
              IA(c, z, G);
            } catch (re) {
              Is(re), Co(z, G, re);
            }
          }
        var Q = G.child;
        (G.subtreeFlags & Kt) !== _e && Q !== null ? (Bd(Q, G), ii = Q) : KR(c, d);
      }
    }
    function KR(c, d) {
      for (; ii !== null; ) {
        var G = ii;
        Ao(G);
        try {
          SV(G, c, d);
        } catch (H) {
          Is(H), Co(G, G.return, H);
        }
        $r();
        var w = G.sibling;
        if (w !== null) {
          Bd(w, G.return), ii = w;
          return;
        }
        ii = G.return;
      }
    }
    function SV(c, d, G) {
      var w = c.flags;
      if (w & Ir && _R(c), w & Sa) {
        var H = c.alternate;
        H !== null && bI(H);
      }
      if (w & Le)
        switch (c.tag) {
          case le: {
            var z = c.memoizedState, Q = z !== null;
            if (Q) {
              var re = c.alternate, ce = re !== null && re.memoizedState !== null;
              ce || CS();
            }
            break;
          }
          case hn: {
            var Xe = c.memoizedState, Je = Xe !== null, ft = c.alternate, _t = ft !== null && ft.memoizedState !== null, Ut = c;
            qi && TR(Ut, Je);
            {
              if (Je && !_t && (Ut.mode & Rr) !== Oi) {
                ii = Ut;
                for (var yn = Ut.child; yn !== null; )
                  ii = yn, qB(yn), yn = yn.sibling;
              }
              break;
            }
          }
        }
      var xn = w & (Ht | an | la);
      switch (xn) {
        case Ht: {
          GI(c), c.flags &= ~Ht;
          break;
        }
        case fi: {
          GI(c), c.flags &= ~Ht;
          var _i = c.alternate;
          CA(_i, c);
          break;
        }
        case la: {
          c.flags &= ~la;
          break;
        }
        case Oa: {
          c.flags &= ~la;
          var Ar = c.alternate;
          CA(Ar, c);
          break;
        }
        case an: {
          var Ui = c.alternate;
          CA(Ui, c);
          break;
        }
      }
    }
    function wf(c, d, G) {
      gA = G, yI = d, ii = c, Ov(c, d, G), gA = null, yI = null;
    }
    function Ov(c, d, G) {
      for (var w = (c.mode & Rr) !== Oi; ii !== null; ) {
        var H = ii, z = H.child;
        if (H.tag === hn && w) {
          var Q = H.memoizedState !== null, re = Q || g0;
          if (re) {
            SI(c, d, G);
            continue;
          } else {
            var ce = H.alternate, Xe = ce !== null && ce.memoizedState !== null, Je = Xe || Gf, ft = g0, _t = Gf;
            g0 = re, Gf = Je, Gf && !_t && (ii = H, LR(H));
            for (var Ut = z; Ut !== null; )
              ii = Ut, Ov(
                Ut,
                // New root; bubble back up to here and stop.
                d,
                G
              ), Ut = Ut.sibling;
            ii = H, g0 = ft, Gf = _t, SI(c, d, G);
            continue;
          }
        }
        (H.subtreeFlags & vn) !== _e && z !== null ? (Bd(z, H), ii = z) : SI(c, d, G);
      }
    }
    function SI(c, d, G) {
      for (; ii !== null; ) {
        var w = ii;
        if ((w.flags & vn) !== _e) {
          var H = w.alternate;
          Ao(w);
          try {
            BV(d, H, w, G);
          } catch (Q) {
            Is(Q), Co(w, w.return, Q);
          }
          $r();
        }
        if (w === c) {
          ii = null;
          return;
        }
        var z = w.sibling;
        if (z !== null) {
          Bd(z, w.return), ii = z;
          return;
        }
        ii = w.return;
      }
    }
    function qB(c) {
      for (; ii !== null; ) {
        var d = ii, G = d.child;
        switch (d.tag) {
          case k:
          case Ce:
          case Ye:
          case $e: {
            if (d.mode & xr)
              try {
                Nu(), fl(Ho, d, d.return);
              } finally {
                Lc(d);
              }
            else
              fl(Ho, d, d.return);
            break;
          }
          case O: {
            d0(d, d.return);
            var w = d.stateNode;
            typeof w.componentWillUnmount == "function" && zv(d, d.return, w);
            break;
          }
          case pe: {
            d0(d, d.return);
            break;
          }
          case hn: {
            var H = d.memoizedState !== null;
            if (H) {
              f0(c);
              continue;
            }
            break;
          }
        }
        G !== null ? (G.return = d, ii = G) : f0(c);
      }
    }
    function f0(c) {
      for (; ii !== null; ) {
        var d = ii;
        if (d === c) {
          ii = null;
          return;
        }
        var G = d.sibling;
        if (G !== null) {
          G.return = d.return, ii = G;
          return;
        }
        ii = d.return;
      }
    }
    function LR(c) {
      for (; ii !== null; ) {
        var d = ii, G = d.child;
        if (d.tag === hn) {
          var w = d.memoizedState !== null;
          if (w) {
            kR(c);
            continue;
          }
        }
        G !== null ? (G.return = d, ii = G) : kR(c);
      }
    }
    function kR(c) {
      for (; ii !== null; ) {
        var d = ii;
        Ao(d);
        try {
          ER(d);
        } catch (w) {
          Is(w), Co(d, d.return, w);
        }
        if ($r(), d === c) {
          ii = null;
          return;
        }
        var G = d.sibling;
        if (G !== null) {
          G.return = d.return, ii = G;
          return;
        }
        ii = d.return;
      }
    }
    function DR(c, d) {
      ii = d, Rf(d, c);
    }
    function Rf(c, d) {
      for (; ii !== null; ) {
        var G = ii, w = G.child;
        (G.subtreeFlags & Yt) !== _e && w !== null ? (Bd(w, G), ii = w) : fA(c, d);
      }
    }
    function fA(c, d) {
      for (; ii !== null; ) {
        var G = ii;
        if ((G.flags & na) !== _e) {
          Ao(G);
          try {
            pA(d, G);
          } catch (H) {
            Is(H), Co(G, G.return, H);
          }
          $r();
        }
        if (G === c) {
          ii = null;
          return;
        }
        var w = G.sibling;
        if (w !== null) {
          Bd(w, G.return), ii = w;
          return;
        }
        ii = G.return;
      }
    }
    function pA(c, d) {
      switch (d.tag) {
        case k:
        case Ce:
        case $e: {
          if (d.mode & xr) {
            t0();
            try {
              yd(ws | Va, d);
            } finally {
              iA(d);
            }
          } else
            yd(ws | Va, d);
          break;
        }
      }
    }
    function p0(c) {
      ii = c, m0();
    }
    function m0() {
      for (; ii !== null; ) {
        var c = ii, d = c.child;
        if ((ii.flags & xi) !== _e) {
          var G = c.deletions;
          if (G !== null) {
            for (var w = 0; w < G.length; w++) {
              var H = G[w];
              ii = H, Op(H, c);
            }
            {
              var z = c.alternate;
              if (z !== null) {
                var Q = z.child;
                if (Q !== null) {
                  z.child = null;
                  do {
                    var re = Q.sibling;
                    Q.sibling = null, Q = re;
                  } while (Q !== null);
                }
              }
            }
            ii = c;
          }
        }
        (c.subtreeFlags & Yt) !== _e && d !== null ? (Bd(d, c), ii = d) : bd();
      }
    }
    function bd() {
      for (; ii !== null; ) {
        var c = ii;
        (c.flags & na) !== _e && (Ao(c), Gd(c), $r());
        var d = c.sibling;
        if (d !== null) {
          Bd(d, c.return), ii = d;
          return;
        }
        ii = c.return;
      }
    }
    function Gd(c) {
      switch (c.tag) {
        case k:
        case Ce:
        case $e: {
          c.mode & xr ? (t0(), fl(ws | Va, c, c.return), iA(c)) : fl(ws | Va, c, c.return);
          break;
        }
      }
    }
    function Op(c, d) {
      for (; ii !== null; ) {
        var G = ii;
        Ao(G), Ah(G, d), $r();
        var w = G.child;
        w !== null ? (Bd(w, G), ii = w) : mh(c);
      }
    }
    function mh(c) {
      for (; ii !== null; ) {
        var d = ii, G = d.sibling, w = d.return;
        if (ph(d), d === c) {
          ii = null;
          return;
        }
        if (G !== null) {
          Bd(G, w), ii = G;
          return;
        }
        ii = w;
      }
    }
    function Ah(c, d) {
      switch (c.tag) {
        case k:
        case Ce:
        case $e: {
          c.mode & xr ? (t0(), fl(ws, c, d), iA(c)) : fl(ws, c, d);
          break;
        }
      }
    }
    var UR = !1;
    function Bd(c, d) {
      !UR && c.return !== d && (UR = !0, h("Internal React error: Return pointer is inconsistent with parent.")), c.return = d;
    }
    function ZV(c) {
      switch (c.tag) {
        case k:
        case Ce:
        case $e: {
          try {
            yd(Ho | Va, c);
          } catch (G) {
            Is(G), Co(c, c.return, G);
          }
          break;
        }
        case O: {
          var d = c.stateNode;
          try {
            d.componentDidMount();
          } catch (G) {
            Is(G), Co(c, c.return, G);
          }
          break;
        }
      }
    }
    function Pp(c) {
      switch (c.tag) {
        case k:
        case Ce:
        case $e: {
          try {
            yd(ws | Va, c);
          } catch (d) {
            Is(d), Co(c, c.return, d);
          }
          break;
        }
      }
    }
    function OR(c) {
      switch (c.tag) {
        case k:
        case Ce:
        case $e: {
          try {
            fl(Ho | Va, c, c.return);
          } catch (G) {
            Is(G), Co(c, c.return, G);
          }
          break;
        }
        case O: {
          var d = c.stateNode;
          typeof d.componentWillUnmount == "function" && zv(c, c.return, d);
          break;
        }
      }
    }
    function $B(c) {
      switch (c.tag) {
        case k:
        case Ce:
        case $e:
          try {
            fl(ws | Va, c, c.return);
          } catch (d) {
            Is(d), Co(c, c.return, d);
          }
      }
    }
    var Jp = 0, A0 = 1, mA = 2, v0 = 3, y0 = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var ZI = Symbol.for;
      Jp = ZI("selector.component"), A0 = ZI("selector.has_pseudo_class"), mA = ZI("selector.role"), v0 = ZI("selector.test_id"), y0 = ZI("selector.text");
    }
    function eu(c) {
      return {
        $$typeof: Jp,
        value: c
      };
    }
    function Sd(c) {
      return {
        $$typeof: A0,
        value: c
      };
    }
    function wI(c) {
      return {
        $$typeof: mA,
        value: c
      };
    }
    function Qp(c) {
      return {
        $$typeof: y0,
        value: c
      };
    }
    function xf(c) {
      return {
        $$typeof: v0,
        value: c
      };
    }
    function eS(c) {
      var d = Za(c);
      if (d != null) {
        if (typeof d.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return d;
      } else {
        var G = Xr(c);
        if (G === null)
          throw new Error("Could not find React container within specified host subtree.");
        return G.stateNode.current;
      }
    }
    function b0(c, d) {
      switch (d.$$typeof) {
        case Jp:
          if (c.type === d.value)
            return !0;
          break;
        case A0:
          return wV(c, d.value);
        case mA:
          if (c.tag === pe) {
            var G = c.stateNode;
            if (Lo(G, d.value))
              return !0;
          }
          break;
        case y0:
          if (c.tag === pe || c.tag === Ae) {
            var w = kr(c);
            if (w !== null && w.indexOf(d.value) >= 0)
              return !0;
          }
          break;
        case v0:
          if (c.tag === pe) {
            var H = c.memoizedProps["data-testname"];
            if (typeof H == "string" && H.toLowerCase() === d.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function tS(c) {
      switch (c.$$typeof) {
        case Jp:
          var d = Pe(c.value) || "Unknown";
          return "<" + d + ">";
        case A0:
          return ":has(" + (tS(c) || "") + ")";
        case mA:
          return '[role="' + c.value + '"]';
        case y0:
          return '"' + c.value + '"';
        case v0:
          return '[data-testname="' + c.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function PR(c, d) {
      for (var G = [], w = [c, 0], H = 0; H < w.length; ) {
        var z = w[H++], Q = w[H++], re = d[Q];
        if (!(z.tag === pe && ua(z))) {
          for (; re != null && b0(z, re); )
            Q++, re = d[Q];
          if (Q === d.length)
            G.push(z);
          else
            for (var ce = z.child; ce !== null; )
              w.push(ce, Q), ce = ce.sibling;
        }
      }
      return G;
    }
    function wV(c, d) {
      for (var G = [c, 0], w = 0; w < G.length; ) {
        var H = G[w++], z = G[w++], Q = d[z];
        if (!(H.tag === pe && ua(H))) {
          for (; Q != null && b0(H, Q); )
            z++, Q = d[z];
          if (z === d.length)
            return !0;
          for (var re = H.child; re !== null; )
            G.push(re, z), re = re.sibling;
        }
      }
      return !1;
    }
    function Pv(c, d) {
      if (!Ko)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var G = eS(c), w = PR(G, d), H = [], z = Array.from(w), Q = 0; Q < z.length; ) {
        var re = z[Q++];
        if (re.tag === pe) {
          if (ua(re))
            continue;
          H.push(re.stateNode);
        } else
          for (var ce = re.child; ce !== null; )
            z.push(ce), ce = ce.sibling;
      }
      return H;
    }
    function JR(c, d) {
      if (!Ko)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var G = eS(c), w = 0, H = [], z = [G, 0], Q = 0; Q < z.length; ) {
        var re = z[Q++], ce = z[Q++], Xe = d[ce];
        if (!(re.tag === pe && ua(re)) && (b0(re, Xe) && (H.push(tS(Xe)), ce++, ce > w && (w = ce)), ce < d.length))
          for (var Je = re.child; Je !== null; )
            z.push(Je, ce), Je = Je.sibling;
      }
      if (w < d.length) {
        for (var ft = [], _t = w; _t < d.length; _t++)
          ft.push(tS(d[_t]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + H.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + ft.join(" > "));
      }
      return null;
    }
    function nS(c, d) {
      if (!Ko)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var G = Pv(c, d), w = [], H = 0; H < G.length; H++)
        w.push(ia(G[H]));
      for (var z = w.length - 1; z > 0; z--)
        for (var Q = w[z], re = Q.x, ce = re + Q.width, Xe = Q.y, Je = Xe + Q.height, ft = z - 1; ft >= 0; ft--)
          if (z !== ft) {
            var _t = w[ft], Ut = _t.x, yn = Ut + _t.width, xn = _t.y, _i = xn + _t.height;
            if (re >= Ut && Xe >= xn && ce <= yn && Je <= _i) {
              w.splice(z, 1);
              break;
            } else if (re === Ut && Q.width === _t.width && !(_i < Xe) && !(xn > Je)) {
              xn > Xe && (_t.height += xn - Xe, _t.y = Xe), _i < Je && (_t.height = Je - xn), w.splice(z, 1);
              break;
            } else if (Xe === xn && Q.height === _t.height && !(yn < re) && !(Ut > ce)) {
              Ut > re && (_t.width += Ut - re, _t.x = re), yn < ce && (_t.width = ce - Ut), w.splice(z, 1);
              break;
            }
          }
      return w;
    }
    function QR(c, d) {
      if (!Ko)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var G = eS(c), w = PR(G, d), H = Array.from(w), z = 0; z < H.length; ) {
        var Q = H[z++];
        if (!ua(Q)) {
          if (Q.tag === pe) {
            var re = Q.stateNode;
            if (ko(re))
              return !0;
          }
          for (var ce = Q.child; ce !== null; )
            H.push(ce), ce = ce.sibling;
        }
      }
      return !1;
    }
    var Jv = [];
    function iS() {
      Ko && Jv.forEach(function(c) {
        return c();
      });
    }
    function rS(c, d, G, w) {
      if (!Ko)
        throw new Error("Test selector API is not supported by this renderer.");
      var H = Pv(c, d), z = cu(H, G, w), Q = z.disconnect, re = z.observe, ce = z.unobserve, Xe = function() {
        var Je = Pv(c, d);
        H.forEach(function(ft) {
          Je.indexOf(ft) < 0 && ce(ft);
        }), Je.forEach(function(ft) {
          H.indexOf(ft) < 0 && re(ft);
        });
      };
      return Jv.push(Xe), {
        disconnect: function() {
          var Je = Jv.indexOf(Xe);
          Je >= 0 && Jv.splice(Je, 1), Q();
        }
      };
    }
    var aS = l.ReactCurrentActQueue;
    function RV(c) {
      {
        var d = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), G = typeof jest < "u";
        return Di && G && d !== !1;
      }
    }
    function jR() {
      {
        var c = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !c && aS.current !== null && h("The current testing environment is not configured to support act(...)"), c;
      }
    }
    var xV = Math.ceil, oS = l.ReactCurrentDispatcher, G0 = l.ReactCurrentOwner, Go = l.ReactCurrentBatchConfig, RI = l.ReactCurrentActQueue, Rs = (
      /*             */
      0
    ), Wf = (
      /*               */
      1
    ), tu = (
      /*                */
      2
    ), go = (
      /*                */
      4
    ), xI = 0, Qv = 1, jp = 2, B0 = 3, cc = 4, qR = 5, vh = 6, cr = Rs, Qs = null, Io = null, es = Dt, Dc = Dt, qp = fu(Dt), Fo = xI, Vf = null, jv = Dt, $p = Dt, AA = Dt, em = null, Xu = null, qv = 0, sS = 500, $R = 1 / 0, $v = 500;
    function yh() {
      $R = Ca() + $v;
    }
    function ey() {
      return $R;
    }
    var ty = !1, S0 = null, WI = null, Nf = !1, bh = null, ny = Dt, iy = [], lS = 50, Mf = 0, Hf = null, uS = 50, tm = 0, Xf = Pi, ry = Dt;
    function ay() {
      return Qs;
    }
    function Yu() {
      return (cr & (tu | go)) !== Rs ? Ca() : (Xf !== Pi || (Xf = Ca()), Xf);
    }
    function ZC(c) {
      var d = c.mode;
      if ((d & Rr) === Oi)
        return nr;
      if ((cr & tu) !== Rs && es !== Dt)
        return Us(es);
      var G = Gg() !== bg;
      if (G) {
        if (Go.transition !== null) {
          var w = Go.transition;
          w._updatedFibers || (w._updatedFibers = /* @__PURE__ */ new Set()), w._updatedFibers.add(c);
        }
        return ry === so && (ry = ss()), ry;
      }
      var H = Pl();
      if (H !== so)
        return H;
      var z = yr();
      return z;
    }
    function cS(c) {
      var d = c.mode;
      return (d & Rr) === Oi ? nr : tI();
    }
    function pl(c, d, G) {
      bA();
      var w = Gh(c, d);
      return w === null ? null : (Ul(w, d, G), (cr & tu) !== Dt && w === Qs ? YV(c) : (xo && wl(w, c, d), Fa(c), w === Qs && ((cr & tu) === Rs && ($p = Wi($p, d)), Fo === cc && Ws(w, es)), js(w, G), d === nr && cr === Rs && (c.mode & Rr) === Oi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !RI.isBatchingLegacy && (yh(), Rl())), w);
    }
    function WV(c, d, G) {
      var w = c.current;
      w.lanes = d, Ul(c, d, G), js(c, G);
    }
    function Gh(c, d) {
      c.lanes = Wi(c.lanes, d);
      var G = c.alternate;
      G !== null && (G.lanes = Wi(G.lanes, d)), G === null && (c.flags & (Ht | la)) !== _e && VI(c);
      for (var w = c, H = c.return; H !== null; )
        H.childLanes = Wi(H.childLanes, d), G = H.alternate, G !== null ? G.childLanes = Wi(G.childLanes, d) : (H.flags & (Ht | la)) !== _e && VI(c), w = H, H = H.return;
      if (w.tag === te) {
        var z = w.stateNode;
        return z;
      } else
        return null;
    }
    function xs(c, d) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        Qs !== null && (c.mode & Rr) !== Oi && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (cr & tu) === Rs
      );
    }
    function js(c, d) {
      var G = c.callbackNode;
      As(c, d);
      var w = Ds(c, c === Qs ? es : Dt);
      if (w === Dt) {
        G !== null && am(G), c.callbackNode = null, c.callbackPriority = so;
        return;
      }
      var H = mg(w), z = c.callbackPriority;
      if (z === H && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(RI.current !== null && G !== rm)) {
        G == null && z !== nr && h("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      G != null && am(G);
      var Q;
      if (H === nr)
        c.tag === td ? (RI.isBatchingLegacy !== null && (RI.didScheduleLegacyUpdate = !0), nc(ex.bind(null, c))) : yi(ex.bind(null, c)), Pa ? RI.current !== null ? RI.current.push($a) : zo(function() {
          cr === Rs && $a();
        }) : GA(Ra, $a), Q = null;
      else {
        var re;
        switch (Nc(w)) {
          case Ol:
            re = Ra;
            break;
          case ld:
            re = zn;
            break;
          case Ag:
            re = Ro;
            break;
          case nI:
            re = Os;
            break;
          default:
            re = Ro;
            break;
        }
        Q = GA(re, Z0.bind(null, c));
      }
      c.callbackPriority = H, c.callbackNode = Q;
    }
    function Z0(c, d) {
      if (Wv(), Xf = Pi, ry = Dt, (cr & (tu | go)) !== Rs)
        throw new Error("Should not already be working.");
      var G = c.callbackNode, w = gc();
      if (w && c.callbackNode !== G)
        return null;
      var H = Ds(c, c === Qs ? es : Dt);
      if (H === Dt)
        return null;
      var z = !tC(c, H) && !Qu(c, H) && !d, Q = z ? Ff(c, H) : ly(c, H);
      if (Q !== xI) {
        if (Q === jp) {
          var re = Qa(c);
          re !== Dt && (H = re, Q = gS(c, re));
        }
        if (Q === Qv) {
          var ce = Vf;
          throw Yf(c, Dt), Ws(c, H), js(c, Ca()), ce;
        }
        if (Q === vh)
          Ws(c, H);
        else {
          var Xe = !tC(c, H), Je = c.current.alternate;
          if (Xe && !NV(Je)) {
            if (Q = ly(c, H), Q === jp) {
              var ft = Qa(c);
              ft !== Dt && (H = ft, Q = gS(c, ft));
            }
            if (Q === Qv) {
              var _t = Vf;
              throw Yf(c, Dt), Ws(c, H), js(c, Ca()), _t;
            }
          }
          c.finishedWork = Je, c.finishedLanes = H, VV(c, Q, H);
        }
      }
      return js(c, Ca()), c.callbackNode === G ? Z0.bind(null, c) : null;
    }
    function gS(c, d) {
      var G = em;
      if (jl(c)) {
        var w = Yf(c, d);
        w.flags |= Cr, _a(c.containerInfo);
      }
      var H = ly(c, d);
      if (H !== jp) {
        var z = Xu;
        Xu = G, z !== null && dS(z);
      }
      return H;
    }
    function dS(c) {
      Xu === null ? Xu = c : Xu.push.apply(Xu, c);
    }
    function VV(c, d, G) {
      switch (d) {
        case xI:
        case Qv:
          throw new Error("Root did not complete. This is a bug in React.");
        case jp: {
          Ef(c, Xu);
          break;
        }
        case B0: {
          if (Ws(c, G), yu(G) && // do not delay if we're inside an act() scope
          !_f()) {
            var w = qv + sS - Ca();
            if (w > 10) {
              var H = Ds(c, Dt);
              if (H !== Dt)
                break;
              var z = c.suspendedLanes;
              if (!bu(z, G)) {
                Yu(), qu(c, z);
                break;
              }
              c.timeoutHandle = En(Ef.bind(null, c, Xu), w);
              break;
            }
          }
          Ef(c, Xu);
          break;
        }
        case cc: {
          if (Ws(c, G), xc(G))
            break;
          if (!_f()) {
            var Q = jo(c, G), re = Q, ce = Ca() - re, Xe = Tf(ce) - ce;
            if (Xe > 10) {
              c.timeoutHandle = En(Ef.bind(null, c, Xu), Xe);
              break;
            }
          }
          Ef(c, Xu);
          break;
        }
        case qR: {
          Ef(c, Xu);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function NV(c) {
      for (var d = c; ; ) {
        if (d.flags & qe) {
          var G = d.updateQueue;
          if (G !== null) {
            var w = G.stores;
            if (w !== null)
              for (var H = 0; H < w.length; H++) {
                var z = w[H], Q = z.getSnapshot, re = z.value;
                try {
                  if (!Js(Q(), re))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var ce = d.child;
        if (d.subtreeFlags & qe && ce !== null) {
          ce.return = d, d = ce;
          continue;
        }
        if (d === c)
          return !0;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === c)
            return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !0;
    }
    function Ws(c, d) {
      d = uo(d, AA), d = uo(d, $p), ef(c, d);
    }
    function ex(c) {
      if (e0(), (cr & (tu | go)) !== Rs)
        throw new Error("Should not already be working.");
      gc();
      var d = Ds(c, Dt);
      if (!ja(d, nr))
        return js(c, Ca()), null;
      var G = ly(c, d);
      if (c.tag !== td && G === jp) {
        var w = Qa(c);
        w !== Dt && (d = w, G = gS(c, w));
      }
      if (G === Qv) {
        var H = Vf;
        throw Yf(c, Dt), Ws(c, d), js(c, Ca()), H;
      }
      if (G === vh)
        throw new Error("Root did not complete. This is a bug in React.");
      var z = c.current.alternate;
      return c.finishedWork = z, c.finishedLanes = d, Ef(c, Xu), js(c, Ca()), null;
    }
    function w0(c, d) {
      d !== Dt && (ys(c, Wi(d, nr)), js(c, Ca()), (cr & (tu | go)) === Rs && (yh(), $a()));
    }
    function tx(c) {
      var d = Pl(), G = Go.transition;
      try {
        return Go.transition = null, Ka(Ag), c();
      } finally {
        Ka(d), Go.transition = G;
      }
    }
    function nx(c, d) {
      var G = cr;
      cr |= Wf;
      try {
        return c(d);
      } finally {
        cr = G, cr === Rs && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !RI.isBatchingLegacy && (yh(), Rl());
      }
    }
    function R0(c, d, G, w, H) {
      var z = Pl(), Q = Go.transition;
      try {
        return Go.transition = null, Ka(Ol), c(d, G, w, H);
      } finally {
        Ka(z), Go.transition = Q, cr === Rs && yh();
      }
    }
    function vA(c) {
      bh !== null && bh.tag === td && (cr & (tu | go)) === Rs && gc();
      var d = cr;
      cr |= Wf;
      var G = Go.transition, w = Pl();
      try {
        return Go.transition = null, Ka(Ol), c ? c() : void 0;
      } finally {
        Ka(w), Go.transition = G, cr = d, (cr & (tu | go)) === Rs && $a();
      }
    }
    function x0() {
      return (cr & (tu | go)) !== Rs;
    }
    function IS(c) {
      var d = cr;
      cr |= Wf;
      var G = Go.transition, w = Pl();
      try {
        Go.transition = null, Ka(Ol), c();
      } finally {
        Ka(w), Go.transition = G, cr = d, cr === Rs && (yh(), $a());
      }
    }
    function nm(c, d) {
      ao(qp, Dc, c), Dc = Wi(Dc, d);
    }
    function oy(c) {
      Dc = qp.current, va(qp, c);
    }
    function Yf(c, d) {
      c.finishedWork = null, c.finishedLanes = Dt;
      var G = c.timeoutHandle;
      if (G !== kn && (c.timeoutHandle = kn, cn(G)), Io !== null)
        for (var w = Io.return; w !== null; ) {
          var H = w.alternate;
          UB(H, w), w = w.return;
        }
      Qs = c;
      var z = Lf(c.current, null);
      return Io = z, es = Dc = d, Fo = xI, Vf = null, jv = Dt, $p = Dt, AA = Dt, em = null, Xu = null, $n(), Wl.discardPendingWarnings(), z;
    }
    function wC(c, d) {
      do {
        var G = Io;
        try {
          if (V(), pn(), $r(), G0.current = null, G === null || G.return === null) {
            Fo = Qv, Vf = d, Io = null;
            return;
          }
          if (U && G.mode & xr && Lp(G, !0), P)
            if (Jl(), d !== null && typeof d == "object" && typeof d.then == "function") {
              var w = d;
              ec(G, w, es);
            } else
              rC(G, d, es);
          $W(c, G.return, G, d, es), dy(G);
        } catch (H) {
          d = H, Io === G && G !== null ? (G = G.return, Io = G) : G = Io;
          continue;
        }
        return;
      } while (!0);
    }
    function Bh() {
      var c = oS.current;
      return oS.current = Pb, c === null ? Pb : c;
    }
    function sy(c) {
      oS.current = c;
    }
    function CS() {
      qv = Ca();
    }
    function W0(c) {
      jv = Wi(c, jv);
    }
    function V0() {
      Fo === xI && (Fo = B0);
    }
    function hS() {
      (Fo === xI || Fo === B0 || Fo === jp) && (Fo = cc), Qs !== null && (Dl(jv) || Dl($p)) && Ws(Qs, es);
    }
    function ix(c) {
      Fo !== cc && (Fo = jp), em === null ? em = [c] : em.push(c);
    }
    function N0() {
      return Fo === xI;
    }
    function ly(c, d) {
      var G = cr;
      cr |= tu;
      var w = Bh();
      if (Qs !== c || es !== d) {
        if (xo) {
          var H = c.memoizedUpdaters;
          H.size > 0 && (jn(c, es), H.clear()), eh(c, d);
        }
        Yf(c, d);
      }
      Zi(d);
      do
        try {
          uy();
          break;
        } catch (z) {
          wC(c, z);
        }
      while (!0);
      if (V(), cr = G, sy(w), Io !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Or(), Qs = null, es = Dt, Fo;
    }
    function uy() {
      for (; Io !== null; )
        gy(Io);
    }
    function Ff(c, d) {
      var G = cr;
      cr |= tu;
      var w = Bh();
      if (Qs !== c || es !== d) {
        if (xo) {
          var H = c.memoizedUpdaters;
          H.size > 0 && (jn(c, es), H.clear()), eh(c, d);
        }
        yh(), Yf(c, d);
      }
      Zi(d);
      do
        try {
          cy();
          break;
        } catch (z) {
          wC(c, z);
        }
      while (!0);
      return V(), sy(w), cr = G, Io !== null ? (vi(), xI) : (Or(), Qs = null, es = Dt, Fo);
    }
    function cy() {
      for (; Io !== null && !th(); )
        gy(Io);
    }
    function gy(c) {
      var d = c.alternate;
      Ao(c);
      var G;
      (c.mode & xr) !== Oi ? (Ih(c), G = Vs(d, c, Dc), Lp(c, !0)) : G = Vs(d, c, Dc), $r(), c.memoizedProps = c.pendingProps, G === null ? dy(c) : Io = G, G0.current = null;
    }
    function dy(c) {
      var d = c;
      do {
        var G = d.alternate, w = d.return;
        if ((d.flags & me) === _e) {
          Ao(d);
          var H = void 0;
          if ((d.mode & xr) === Oi ? H = CR(G, d, Dc) : (Ih(d), H = CR(G, d, Dc), Lp(d, !1)), $r(), H !== null) {
            Io = H;
            return;
          }
        } else {
          var z = mV(G, d);
          if (z !== null) {
            z.flags &= Pt, Io = z;
            return;
          }
          if ((d.mode & xr) !== Oi) {
            Lp(d, !1);
            for (var Q = d.actualDuration, re = d.child; re !== null; )
              Q += re.actualDuration, re = re.sibling;
            d.actualDuration = Q;
          }
          if (w !== null)
            w.flags |= me, w.subtreeFlags = _e, w.deletions = null;
          else {
            Fo = vh, Io = null;
            return;
          }
        }
        var ce = d.sibling;
        if (ce !== null) {
          Io = ce;
          return;
        }
        d = w, Io = d;
      } while (d !== null);
      Fo === xI && (Fo = qR);
    }
    function Ef(c, d) {
      var G = Pl(), w = Go.transition;
      try {
        Go.transition = null, Ka(Ol), fS(c, d, G);
      } finally {
        Go.transition = w, Ka(G);
      }
      return null;
    }
    function fS(c, d, G) {
      do
        gc();
      while (bh !== null);
      if (XV(), (cr & (tu | go)) !== Rs)
        throw new Error("Should not already be working.");
      var w = c.finishedWork, H = c.finishedLanes;
      if (nC(H), w === null)
        return $u(), null;
      if (H === Dt && h("root.finishedLanes should not be empty during a commit. This is a bug in React."), c.finishedWork = null, c.finishedLanes = Dt, w === c.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      c.callbackNode = null, c.callbackPriority = so;
      var z = Wi(w.lanes, w.childLanes);
      vs(c, z), c === Qs && (Qs = null, Io = null, es = Dt), ((w.subtreeFlags & Yt) !== _e || (w.flags & Yt) !== _e) && (Nf || (Nf = !0, GA(Ro, function() {
        return gc(), null;
      })));
      var Q = (w.subtreeFlags & (Nt | Kt | vn | Yt)) !== _e, re = (w.flags & (Nt | Kt | vn | Yt)) !== _e;
      if (Q || re) {
        var ce = Go.transition;
        Go.transition = null;
        var Xe = Pl();
        Ka(Ol);
        var Je = cr;
        cr |= go, G0.current = null, FR(c, w), wB(), zR(c, w, H), mt(c.containerInfo), c.current = w, oI(H), wf(w, c, H), sI(), iI(), cr = Je, Ka(Xe), Go.transition = ce;
      } else
        c.current = w, wB();
      var ft = Nf;
      if (Nf && (Nf = !1, bh = c, ny = H), z = c.pendingLanes, z === Dt && (WI = null), ft || Iy(c.current, !1), po(w.stateNode, G), xo && c.memoizedUpdaters.clear(), iS(), js(c, Ca()), d !== null)
        for (var _t = c.onRecoverableError, Ut = 0; Ut < d.length; Ut++) {
          var yn = d[Ut];
          _t(yn);
        }
      if (ty) {
        ty = !1;
        var xn = S0;
        throw S0 = null, xn;
      }
      return ja(ny, nr) && c.tag !== td && gc(), z = c.pendingLanes, ja(z, nr) ? (Kc(), c === Hf ? Mf++ : (Mf = 0, Hf = c)) : Mf = 0, $a(), $u(), null;
    }
    function gc() {
      if (bh !== null) {
        var c = Nc(ny), d = ud(Ag, c), G = Go.transition, w = Pl();
        try {
          return Go.transition = null, Ka(d), rx();
        } finally {
          Ka(w), Go.transition = G;
        }
      }
      return !1;
    }
    function pS(c) {
      iy.push(c), Nf || (Nf = !0, GA(Ro, function() {
        return gc(), null;
      }));
    }
    function rx() {
      if (bh === null)
        return !1;
      var c = bh, d = ny;
      if (bh = null, ny = Dt, (cr & (tu | go)) !== Rs)
        throw new Error("Cannot flush passive effects while already rendering.");
      tc(d);
      var G = cr;
      cr |= go, p0(c.current), DR(c, c.current);
      {
        var w = iy;
        iy = [];
        for (var H = 0; H < w.length; H++) {
          var z = w[H];
          JB(c, z);
        }
      }
      Kn(), Iy(c.current, !0), cr = G, $a(), tm = bh === null ? 0 : tm + 1, qr(c);
      {
        var Q = c.current.stateNode;
        Q.effectDuration = 0, Q.passiveEffectDuration = 0;
      }
      return !0;
    }
    function M0(c) {
      return WI !== null && WI.has(c);
    }
    function MV(c) {
      WI === null ? WI = /* @__PURE__ */ new Set([c]) : WI.add(c);
    }
    function ax(c) {
      ty || (ty = !0, S0 = c);
    }
    var ox = ax;
    function yA(c, d, G) {
      var w = Vv(G, d), H = Nv(c, w, nr);
      xa(c, H);
      var z = Yu(), Q = Gh(c, nr);
      Q !== null && (Ul(Q, nr, z), js(Q, z));
    }
    function Co(c, d, G) {
      if (c.tag === te) {
        yA(c, c, G);
        return;
      }
      var w = null;
      for (w = d; w !== null; ) {
        if (w.tag === te) {
          yA(w, c, G);
          return;
        } else if (w.tag === O) {
          var H = w.type, z = w.stateNode;
          if (typeof H.getDerivedStateFromError == "function" || typeof z.componentDidCatch == "function" && !M0(z)) {
            var Q = Vv(G, c), re = aA(w, Q, nr);
            xa(w, re);
            var ce = Yu(), Xe = Gh(w, nr);
            Xe !== null && (Ul(Xe, nr, ce), js(Xe, ce));
            return;
          }
        }
        w = w.return;
      }
      h(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, G);
    }
    function mS(c, d, G) {
      var w = c.pingCache;
      w !== null && w.delete(d);
      var H = Yu();
      qu(c, G), ml(c), Qs === c && bu(es, G) && (Fo === cc || Fo === B0 && yu(es) && Ca() - qv < sS ? Yf(c, Dt) : AA = Wi(AA, G)), js(c, H);
    }
    function im(c, d) {
      d === so && (d = cS(c));
      var G = Yu(), w = Gh(c, d);
      w !== null && (Ul(w, d, G), js(w, G));
    }
    function AS(c) {
      var d = c.memoizedState, G = so;
      d !== null && (G = d.retryLane), im(c, G);
    }
    function HV(c, d) {
      var G = so, w;
      switch (c.tag) {
        case le:
          w = c.stateNode;
          var H = c.memoizedState;
          H !== null && (G = H.retryLane);
          break;
        case St:
          w = c.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      w !== null && w.delete(d), im(c, G);
    }
    function Tf(c) {
      return c < 120 ? 120 : c < 480 ? 480 : c < 1080 ? 1080 : c < 1920 ? 1920 : c < 3e3 ? 3e3 : c < 4320 ? 4320 : xV(c / 1960) * 1960;
    }
    function bA() {
      if (Mf > lS)
        throw Mf = 0, Hf = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      tm > uS && (tm = 0, h("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function XV() {
      Wl.flushLegacyContextWarning(), Wl.flushPendingUnsafeLifecycleWarnings();
    }
    function Iy(c, d) {
      Ao(c), nu(c, Ue, OR), d && nu(c, Oe, $B), nu(c, Ue, ZV), d && nu(c, Oe, Pp), $r();
    }
    function nu(c, d, G) {
      for (var w = c, H = null; w !== null; ) {
        var z = w.subtreeFlags & d;
        w !== H && w.child !== null && z !== _e ? w = w.child : ((w.flags & d) !== _e && G(w), w.sibling !== null ? w = w.sibling : w = H = w.return);
      }
    }
    var Cs = null;
    function VI(c) {
      {
        if ((cr & tu) !== Rs || !(c.mode & Rr))
          return;
        var d = c.tag;
        if (d !== J && d !== te && d !== O && d !== k && d !== Ce && d !== Ye && d !== $e)
          return;
        var G = lt(c) || "ReactComponent";
        if (Cs !== null) {
          if (Cs.has(G))
            return;
          Cs.add(G);
        } else
          Cs = /* @__PURE__ */ new Set([G]);
        var w = eo;
        try {
          Ao(c), h("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          w ? Ao(c) : $r();
        }
      }
    }
    var Vs;
    {
      var iu = null;
      Vs = function(c, d, G) {
        var w = Ay(iu, d);
        try {
          return WR(c, d, G);
        } catch (z) {
          if (z !== null && typeof z == "object" && typeof z.then == "function")
            throw z;
          if (V(), pn(), UB(c, d), Ay(d, w), d.mode & xr && Ih(d), MR(null, WR, null, c, d, G), yV()) {
            var H = HR();
            typeof H == "object" && H !== null && H._suppressLogging && typeof z == "object" && z !== null && !z._suppressLogging && (z._suppressLogging = !0);
          }
          throw z;
        }
      };
    }
    var H0 = !1, Cy;
    Cy = /* @__PURE__ */ new Set();
    function YV(c) {
      if (Id && !iR())
        switch (c.tag) {
          case k:
          case Ce:
          case $e: {
            var d = Io && lt(Io) || "Unknown", G = d;
            if (!Cy.has(G)) {
              Cy.add(G);
              var w = lt(c) || "Unknown";
              h("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", w, d, d);
            }
            break;
          }
          case O: {
            H0 || (h("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), H0 = !0);
            break;
          }
        }
    }
    function jn(c, d) {
      if (xo) {
        var G = c.memoizedUpdaters;
        G.forEach(function(w) {
          wl(c, w, d);
        });
      }
    }
    var rm = {};
    function GA(c, d) {
      {
        var G = RI.current;
        return G !== null ? (G.push(d), rm) : tf(c, d);
      }
    }
    function am(c) {
      if (c !== rm)
        return vg(c);
    }
    function _f() {
      return RI.current !== null;
    }
    function Fa(c) {
      {
        if (c.mode & Rr) {
          if (!jR())
            return;
        } else if (!RV() || cr !== Rs || c.tag !== k && c.tag !== Ce && c.tag !== $e)
          return;
        if (RI.current === null) {
          var d = eo;
          try {
            Ao(c), h(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, lt(c));
          } finally {
            d ? Ao(c) : $r();
          }
        }
      }
    }
    function ml(c) {
      c.tag !== td && jR() && RI.current === null && h(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var Ea = null, Sh = null, hy = function(c) {
      Ea = c;
    };
    function RC(c) {
      {
        if (Ea === null)
          return c;
        var d = Ea(c);
        return d === void 0 ? c : d.current;
      }
    }
    function vS(c) {
      return RC(c);
    }
    function yS(c) {
      {
        if (Ea === null)
          return c;
        var d = Ea(c);
        if (d === void 0) {
          if (c != null && typeof c.render == "function") {
            var G = RC(c.render);
            if (c.render !== G) {
              var w = {
                $$typeof: Se,
                render: G
              };
              return c.displayName !== void 0 && (w.displayName = c.displayName), w;
            }
          }
          return c;
        }
        return d.current;
      }
    }
    function on(c, d) {
      {
        if (Ea === null)
          return !1;
        var G = c.elementType, w = d.type, H = !1, z = typeof w == "object" && w !== null ? w.$$typeof : null;
        switch (c.tag) {
          case O: {
            typeof w == "function" && (H = !0);
            break;
          }
          case k: {
            (typeof w == "function" || z === pt) && (H = !0);
            break;
          }
          case Ce: {
            (z === Se || z === pt) && (H = !0);
            break;
          }
          case Ye:
          case $e: {
            (z === Ft || z === pt) && (H = !0);
            break;
          }
          default:
            return !1;
        }
        if (H) {
          var Q = Ea(G);
          if (Q !== void 0 && Q === Ea(w))
            return !0;
        }
        return !1;
      }
    }
    function Wg(c) {
      {
        if (Ea === null || typeof WeakSet != "function")
          return;
        Sh === null && (Sh = /* @__PURE__ */ new WeakSet()), Sh.add(c);
      }
    }
    var zf = function(c, d) {
      {
        if (Ea === null)
          return;
        var G = d.staleFamilies, w = d.updatedFamilies;
        gc(), vA(function() {
          da(c.current, w, G);
        });
      }
    }, bS = function(c, d) {
      {
        if (c.context !== Qr)
          return;
        gc(), vA(function() {
          K0(d, c, null, null);
        });
      }
    };
    function da(c, d, G) {
      {
        var w = c.alternate, H = c.child, z = c.sibling, Q = c.tag, re = c.type, ce = null;
        switch (Q) {
          case k:
          case $e:
          case O:
            ce = re;
            break;
          case Ce:
            ce = re.render;
            break;
        }
        if (Ea === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Xe = !1, Je = !1;
        if (ce !== null) {
          var ft = Ea(ce);
          ft !== void 0 && (G.has(ft) ? Je = !0 : d.has(ft) && (Q === O ? Je = !0 : Xe = !0));
        }
        Sh !== null && (Sh.has(c) || w !== null && Sh.has(w)) && (Je = !0), Je && (c._debugNeedsRemount = !0), (Je || Xe) && pl(c, nr, Pi), H !== null && !Je && da(H, d, G), z !== null && da(z, d, G);
      }
    }
    var Un = function(c, d) {
      {
        var G = /* @__PURE__ */ new Set(), w = new Set(d.map(function(H) {
          return H.current;
        }));
        return Kf(c.current, w, G), G;
      }
    };
    function Kf(c, d, G) {
      {
        var w = c.child, H = c.sibling, z = c.tag, Q = c.type, re = null;
        switch (z) {
          case k:
          case $e:
          case O:
            re = Q;
            break;
          case Ce:
            re = Q.render;
            break;
        }
        var ce = !1;
        re !== null && d.has(re) && (ce = !0), ce ? FV(c, G) : w !== null && Kf(w, d, G), H !== null && Kf(H, d, G);
      }
    }
    function FV(c, d) {
      {
        var G = Fu(c, d);
        if (G)
          return;
        for (var w = c; ; ) {
          switch (w.tag) {
            case pe:
              d.add(w.stateNode);
              return;
            case fe:
              d.add(w.stateNode.containerInfo);
              return;
            case te:
              d.add(w.stateNode.containerInfo);
              return;
          }
          if (w.return === null)
            throw new Error("Expected to reach root first.");
          w = w.return;
        }
      }
    }
    function Fu(c, d) {
      for (var G = c, w = !1; ; ) {
        if (G.tag === pe)
          w = !0, d.add(G.stateNode);
        else if (G.child !== null) {
          G.child.return = G, G = G.child;
          continue;
        }
        if (G === c)
          return w;
        for (; G.sibling === null; ) {
          if (G.return === null || G.return === c)
            return w;
          G = G.return;
        }
        G.sibling.return = G.return, G = G.sibling;
      }
      return !1;
    }
    var fy;
    {
      fy = !1;
      try {
        var om = Object.preventExtensions({});
      } catch {
        fy = !0;
      }
    }
    function BA(c, d, G, w) {
      this.tag = c, this.key = G, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = d, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = w, this.flags = _e, this.subtreeFlags = _e, this.deletions = null, this.lanes = Dt, this.childLanes = Dt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !fy && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Uc = function(c, d, G, w) {
      return new BA(c, d, G, w);
    };
    function X0(c) {
      var d = c.prototype;
      return !!(d && d.isReactComponent);
    }
    function xC(c) {
      return typeof c == "function" && !X0(c) && c.defaultProps === void 0;
    }
    function Zd(c) {
      if (typeof c == "function")
        return X0(c) ? O : k;
      if (c != null) {
        var d = c.$$typeof;
        if (d === Se)
          return Ce;
        if (d === Ft)
          return Ye;
      }
      return J;
    }
    function Lf(c, d) {
      var G = c.alternate;
      G === null ? (G = Uc(c.tag, d, c.key, c.mode), G.elementType = c.elementType, G.type = c.type, G.stateNode = c.stateNode, G._debugSource = c._debugSource, G._debugOwner = c._debugOwner, G._debugHookTypes = c._debugHookTypes, G.alternate = c, c.alternate = G) : (G.pendingProps = d, G.type = c.type, G.flags = _e, G.subtreeFlags = _e, G.deletions = null, G.actualDuration = 0, G.actualStartTime = -1), G.flags = c.flags & Yn, G.childLanes = c.childLanes, G.lanes = c.lanes, G.child = c.child, G.memoizedProps = c.memoizedProps, G.memoizedState = c.memoizedState, G.updateQueue = c.updateQueue;
      var w = c.dependencies;
      switch (G.dependencies = w === null ? null : {
        lanes: w.lanes,
        firstContext: w.firstContext
      }, G.sibling = c.sibling, G.index = c.index, G.ref = c.ref, G.selfBaseDuration = c.selfBaseDuration, G.treeBaseDuration = c.treeBaseDuration, G._debugNeedsRemount = c._debugNeedsRemount, G.tag) {
        case J:
        case k:
        case $e:
          G.type = RC(c.type);
          break;
        case O:
          G.type = vS(c.type);
          break;
        case Ce:
          G.type = yS(c.type);
          break;
      }
      return G;
    }
    function GS(c, d) {
      c.flags &= Yn | Ht;
      var G = c.alternate;
      if (G === null)
        c.childLanes = Dt, c.lanes = d, c.child = null, c.subtreeFlags = _e, c.memoizedProps = null, c.memoizedState = null, c.updateQueue = null, c.dependencies = null, c.stateNode = null, c.selfBaseDuration = 0, c.treeBaseDuration = 0;
      else {
        c.childLanes = G.childLanes, c.lanes = G.lanes, c.child = G.child, c.subtreeFlags = _e, c.deletions = null, c.memoizedProps = G.memoizedProps, c.memoizedState = G.memoizedState, c.updateQueue = G.updateQueue, c.type = G.type;
        var w = G.dependencies;
        c.dependencies = w === null ? null : {
          lanes: w.lanes,
          firstContext: w.firstContext
        }, c.selfBaseDuration = G.selfBaseDuration, c.treeBaseDuration = G.treeBaseDuration;
      }
      return c;
    }
    function BS(c, d, G) {
      var w;
      return c === Jh ? (w = Rr, d === !0 && (w |= Ma, w |= as)) : w = Oi, xo && (w |= xr), Uc(te, null, null, w);
    }
    function py(c, d, G, w, H, z) {
      var Q = J, re = c;
      if (typeof c == "function")
        X0(c) ? (Q = O, re = vS(re)) : re = RC(re);
      else if (typeof c == "string")
        Q = pe;
      else
        e: switch (c) {
          case tn:
            return sm(G.children, H, z, d);
          case Gt:
            Q = Ke, H |= Ma, (H & Rr) !== Oi && (H |= as);
            break;
          case Rn:
            return NY(G, H, z, d);
          case oe:
            return SS(G, H, z, d);
          case ct:
            return Y0(G, H, z, d);
          case rn:
            return ZS(G, H, z, d);
          case gn:
          case zt:
          case qn:
          case qt:
          case Sn:
          default: {
            if (typeof c == "object" && c !== null)
              switch (c.$$typeof) {
                case nn:
                  Q = ee;
                  break e;
                case Bn:
                  Q = je;
                  break e;
                case Se:
                  Q = Ce, re = yS(re);
                  break e;
                case Ft:
                  Q = Ye;
                  break e;
                case pt:
                  Q = ke, re = null;
                  break e;
              }
            var ce = "";
            {
              (c === void 0 || typeof c == "object" && c !== null && Object.keys(c).length === 0) && (ce += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var Xe = w ? lt(w) : null;
              Xe && (ce += `

Check the render method of \`` + Xe + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (c == null ? c : typeof c) + "." + ce));
          }
        }
      var Je = Uc(Q, G, d, H);
      return Je.elementType = c, Je.type = re, Je.lanes = z, Je._debugOwner = w, Je;
    }
    function my(c, d, G) {
      var w = null;
      w = c._owner;
      var H = c.type, z = c.key, Q = c.props, re = py(H, z, Q, w, d, G);
      return re._debugSource = c._source, re._debugOwner = c._owner, re;
    }
    function sm(c, d, G, w) {
      var H = Uc(Te, c, w, d);
      return H.lanes = G, H;
    }
    function NY(c, d, G, w) {
      typeof c.id != "string" && h('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof c.id);
      var H = Uc(be, c, w, d | xr);
      return H.elementType = Rn, H.lanes = G, H.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, H;
    }
    function SS(c, d, G, w) {
      var H = Uc(le, c, w, d);
      return H.elementType = oe, H.lanes = G, H;
    }
    function Y0(c, d, G, w) {
      var H = Uc(St, c, w, d);
      return H.elementType = ct, H.lanes = G, H;
    }
    function ZS(c, d, G, w) {
      var H = Uc(hn, c, w, d);
      H.elementType = rn, H.lanes = G;
      var z = {};
      return H.stateNode = z, H;
    }
    function F0(c, d, G) {
      var w = Uc(Ae, c, null, d);
      return w.lanes = G, w;
    }
    function sx() {
      var c = Uc(pe, null, null, Oi);
      return c.elementType = "DELETED", c;
    }
    function lx(c) {
      var d = Uc(wt, null, null, Oi);
      return d.stateNode = c, d;
    }
    function E0(c, d, G) {
      var w = c.children !== null ? c.children : [], H = Uc(fe, w, c.key, d);
      return H.lanes = G, H.stateNode = {
        containerInfo: c.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: c.implementation
      }, H;
    }
    function Ay(c, d) {
      return c === null && (c = Uc(J, null, null, Oi)), c.tag = d.tag, c.key = d.key, c.elementType = d.elementType, c.type = d.type, c.stateNode = d.stateNode, c.return = d.return, c.child = d.child, c.sibling = d.sibling, c.index = d.index, c.ref = d.ref, c.pendingProps = d.pendingProps, c.memoizedProps = d.memoizedProps, c.updateQueue = d.updateQueue, c.memoizedState = d.memoizedState, c.dependencies = d.dependencies, c.mode = d.mode, c.flags = d.flags, c.subtreeFlags = d.subtreeFlags, c.deletions = d.deletions, c.lanes = d.lanes, c.childLanes = d.childLanes, c.alternate = d.alternate, c.actualDuration = d.actualDuration, c.actualStartTime = d.actualStartTime, c.selfBaseDuration = d.selfBaseDuration, c.treeBaseDuration = d.treeBaseDuration, c._debugSource = d._debugSource, c._debugOwner = d._debugOwner, c._debugNeedsRemount = d._debugNeedsRemount, c._debugHookTypes = d._debugHookTypes, c;
    }
    function wS(c, d, G, w, H) {
      this.tag = d, this.containerInfo = c, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = kn, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = so, this.eventTimes = ju(Dt), this.expirationTimes = ju(Pi), this.pendingLanes = Dt, this.suspendedLanes = Dt, this.pingedLanes = Dt, this.expiredLanes = Dt, this.mutableReadLanes = Dt, this.finishedLanes = Dt, this.entangledLanes = Dt, this.entanglements = ju(Dt), this.identifierPrefix = w, this.onRecoverableError = H, Hr && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var z = this.pendingUpdatersLaneMap = [], Q = 0; Q < nd; Q++)
          z.push(/* @__PURE__ */ new Set());
      }
      switch (d) {
        case Jh:
          this._debugRootType = G ? "hydrateRoot()" : "createRoot()";
          break;
        case td:
          this._debugRootType = G ? "hydrate()" : "render()";
          break;
      }
    }
    function T0(c, d, G, w, H, z, Q, re, ce, Xe) {
      var Je = new wS(c, d, G, re, ce), ft = BS(d, z);
      Je.current = ft, ft.stateNode = Je;
      {
        var _t = {
          element: w,
          isDehydrated: G,
          cache: null,
          // not enabled yet
          transitions: null
        };
        ft.memoizedState = _t;
      }
      return ji(ft), Je;
    }
    var vy = "18.0.0-fc46dba67-20220329";
    function RS(c, d, G) {
      var w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Vl(w), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Wt,
        key: w == null ? null : "" + w,
        children: c,
        containerInfo: d,
        implementation: G
      };
    }
    var SA, lm;
    SA = !1, lm = {};
    function yy(c) {
      if (!c)
        return Qr;
      var d = S(c), G = yp(d);
      if (d.tag === O) {
        var w = d.type;
        if (ll(w))
          return mu(d, w, G);
      }
      return G;
    }
    function _0(c) {
      var d = S(c);
      if (d === void 0) {
        if (typeof c.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var G = Object.keys(c).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + G);
      }
      var w = Ln(d);
      return w === null ? null : w.stateNode;
    }
    function by(c, d) {
      {
        var G = S(c);
        if (G === void 0) {
          if (typeof c.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var w = Object.keys(c).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + w);
        }
        var H = Ln(G);
        if (H === null)
          return null;
        if (H.mode & Ma) {
          var z = lt(G) || "Component";
          if (!lm[z]) {
            lm[z] = !0;
            var Q = eo;
            try {
              Ao(H), G.mode & Ma ? h("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", d, d, z) : h("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", d, d, z);
            } finally {
              Q ? Ao(Q) : $r();
            }
          }
        }
        return H.stateNode;
      }
    }
    function xS(c, d, G, w, H, z, Q, re) {
      var ce = !1, Xe = null;
      return T0(c, d, ce, Xe, G, w, H, z, Q);
    }
    function z0(c, d, G, w, H, z, Q, re, ce, Xe) {
      var Je = !0, ft = T0(G, w, Je, c, H, z, Q, re, ce);
      ft.context = yy(null);
      var _t = ft.current, Ut = Yu(), yn = ZC(_t), xn = fr(Ut, yn);
      return xn.callback = d ?? null, xa(_t, xn), WV(ft, yn, Ut), ft;
    }
    function K0(c, d, G, w) {
      ur(d, c);
      var H = d.current, z = Yu(), Q = ZC(H);
      La(Q);
      var re = yy(G);
      d.context === null ? d.context = re : d.pendingContext = re, Id && eo !== null && !SA && (SA = !0, h(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, lt(eo) || "Unknown"));
      var ce = fr(z, Q);
      ce.payload = {
        element: c
      }, w = w === void 0 ? null : w, w !== null && (typeof w != "function" && h("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", w), ce.callback = w), xa(H, ce);
      var Xe = pl(H, Q, z);
      return Xe !== null && mr(Xe, H, Q), Q;
    }
    function L0(c) {
      var d = c.current;
      if (!d.child)
        return null;
      switch (d.child.tag) {
        case pe:
          return bn(d.child.stateNode);
        default:
          return d.child.stateNode;
      }
    }
    function ux(c) {
      switch (c.tag) {
        case te:
          var d = c.stateNode;
          if (jl(d)) {
            var G = Zl(d);
            w0(d, G);
          }
          break;
        case le:
          var w = Yu();
          vA(function() {
            return pl(c, nr, w);
          });
          var H = nr;
          ZA(c, H);
          break;
      }
    }
    function k0(c, d) {
      var G = c.memoizedState;
      G !== null && G.dehydrated !== null && (G.retryLane = Do(G.retryLane, d));
    }
    function ZA(c, d) {
      k0(c, d);
      var G = c.alternate;
      G && k0(G, d);
    }
    function EV(c) {
      if (c.tag === le) {
        var d = Yu(), G = sd;
        pl(c, G, d), ZA(c, G);
      }
    }
    function D0(c) {
      if (c.tag === le) {
        var d = Yu(), G = ZC(c);
        pl(c, G, d), ZA(c, G);
      }
    }
    function WS(c) {
      var d = ue(c);
      return d === null ? null : d.stateNode;
    }
    var Gy = function(c) {
      return null;
    };
    function U0(c) {
      return Gy(c);
    }
    var By = function(c) {
      return !1;
    };
    function O0(c) {
      return By(c);
    }
    var VS = null, NS = null, MS = null, cx = null, P0 = null, HS = null, XS = null, YS = null, gx = null;
    {
      var J0 = function(c, d, G) {
        var w = d[G], H = Mt(c) ? c.slice() : b({}, c);
        return G + 1 === d.length ? (Mt(H) ? H.splice(w, 1) : delete H[w], H) : (H[w] = J0(c[w], d, G + 1), H);
      }, Sy = function(c, d) {
        return J0(c, d, 0);
      }, dx = function(c, d, G, w) {
        var H = d[w], z = Mt(c) ? c.slice() : b({}, c);
        if (w + 1 === d.length) {
          var Q = G[w];
          z[Q] = z[H], Mt(z) ? z.splice(H, 1) : delete z[H];
        } else
          z[H] = dx(
            // $FlowFixMe number or string is fine here
            c[H],
            d,
            G,
            w + 1
          );
        return z;
      }, Ix = function(c, d, G) {
        if (d.length !== G.length) {
          f("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var w = 0; w < G.length - 1; w++)
            if (d[w] !== G[w]) {
              f("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return dx(c, d, G, 0);
      }, FS = function(c, d, G, w) {
        if (G >= d.length)
          return w;
        var H = d[G], z = Mt(c) ? c.slice() : b({}, c);
        return z[H] = FS(c[H], d, G + 1, w), z;
      }, ES = function(c, d, G) {
        return FS(c, d, 0, G);
      }, Q0 = function(c, d) {
        for (var G = c.memoizedState; G !== null && d > 0; )
          G = G.next, d--;
        return G;
      };
      VS = function(c, d, G, w) {
        var H = Q0(c, d);
        if (H !== null) {
          var z = ES(H.memoizedState, G, w);
          H.memoizedState = z, H.baseState = z, c.memoizedProps = b({}, c.memoizedProps), pl(c, nr, Pi);
        }
      }, NS = function(c, d, G) {
        var w = Q0(c, d);
        if (w !== null) {
          var H = Sy(w.memoizedState, G);
          w.memoizedState = H, w.baseState = H, c.memoizedProps = b({}, c.memoizedProps), pl(c, nr, Pi);
        }
      }, MS = function(c, d, G, w) {
        var H = Q0(c, d);
        if (H !== null) {
          var z = Ix(H.memoizedState, G, w);
          H.memoizedState = z, H.baseState = z, c.memoizedProps = b({}, c.memoizedProps), pl(c, nr, Pi);
        }
      }, cx = function(c, d, G) {
        c.pendingProps = ES(c.memoizedProps, d, G), c.alternate && (c.alternate.pendingProps = c.pendingProps), pl(c, nr, Pi);
      }, P0 = function(c, d) {
        c.pendingProps = Sy(c.memoizedProps, d), c.alternate && (c.alternate.pendingProps = c.pendingProps), pl(c, nr, Pi);
      }, HS = function(c, d, G) {
        c.pendingProps = Ix(c.memoizedProps, d, G), c.alternate && (c.alternate.pendingProps = c.pendingProps), pl(c, nr, Pi);
      }, XS = function(c) {
        pl(c, nr, Pi);
      }, YS = function(c) {
        Gy = c;
      }, gx = function(c) {
        By = c;
      };
    }
    function Cx(c) {
      var d = Ln(c);
      return d === null ? null : d.stateNode;
    }
    function j0(c) {
      return null;
    }
    function hx() {
      return eo;
    }
    function fx(c) {
      var d = c.findFiberByHostInstance, G = l.ReactCurrentDispatcher;
      return ya({
        bundleType: c.bundleType,
        version: c.version,
        rendererPackageName: c.rendererPackageName,
        rendererConfig: c.rendererConfig,
        overrideHookState: VS,
        overrideHookStateDeletePath: NS,
        overrideHookStateRenamePath: MS,
        overrideProps: cx,
        overridePropsDeletePath: P0,
        overridePropsRenamePath: HS,
        setErrorHandler: YS,
        setSuspenseHandler: gx,
        scheduleUpdate: XS,
        currentDispatcherRef: G,
        findHostInstanceByFiber: Cx,
        findFiberByHostInstance: d || j0,
        // React Refresh
        findHostInstancesForRefresh: Un,
        scheduleRefresh: zf,
        scheduleRoot: bS,
        setRefreshHandler: hy,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: hx,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: vy
      });
    }
    return n.attemptContinuousHydration = EV, n.attemptHydrationAtCurrentPriority = D0, n.attemptSynchronousHydration = ux, n.batchedUpdates = nx, n.createComponentSelector = eu, n.createContainer = xS, n.createHasPseudoClassSelector = Sd, n.createHydrationContainer = z0, n.createPortal = RS, n.createRoleSelector = wI, n.createTestNameSelector = xf, n.createTextSelector = Qp, n.deferredUpdates = tx, n.discreteUpdates = R0, n.findAllNodes = Pv, n.findBoundingRects = nS, n.findHostInstance = _0, n.findHostInstanceWithNoPortals = WS, n.findHostInstanceWithWarning = by, n.flushControlled = IS, n.flushPassiveEffects = gc, n.flushSync = vA, n.focusWithin = QR, n.getCurrentUpdatePriority = Pl, n.getFindAllNodesFailureDescription = JR, n.getPublicRootInstance = L0, n.injectIntoDevTools = fx, n.isAlreadyRendering = x0, n.observeVisibleRects = rS, n.registerMutableSourceForHydration = bv, n.runWithPriority = co, n.shouldError = U0, n.shouldSuspend = O0, n.updateContainer = K0, n;
  }), _M.exports;
}
var f$ = {};
f$.NODE_ENV === "production" ? TH.exports = C$() : TH.exports = h$();
var p$ = TH.exports;
const m$ = /* @__PURE__ */ Tw(p$);
var _H = { exports: {} }, zM = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var K_;
function A$() {
  return K_ || (K_ = 1, function(a) {
    function e(ee, Ce) {
      var be = ee.length;
      ee.push(Ce);
      e: for (; 0 < be; ) {
        var le = be - 1 >>> 1, Ye = ee[le];
        if (0 < i(Ye, Ce)) ee[le] = Ce, ee[be] = Ye, be = le;
        else break e;
      }
    }
    function t(ee) {
      return ee.length === 0 ? null : ee[0];
    }
    function n(ee) {
      if (ee.length === 0) return null;
      var Ce = ee[0], be = ee.pop();
      if (be !== Ce) {
        ee[0] = be;
        e: for (var le = 0, Ye = ee.length, $e = Ye >>> 1; le < $e; ) {
          var ke = 2 * (le + 1) - 1, ot = ee[ke], wt = ke + 1, St = ee[wt];
          if (0 > i(ot, be)) wt < Ye && 0 > i(St, ot) ? (ee[le] = St, ee[wt] = be, le = wt) : (ee[le] = ot, ee[ke] = be, le = ke);
          else if (wt < Ye && 0 > i(St, be)) ee[le] = St, ee[wt] = be, le = wt;
          else break e;
        }
      }
      return Ce;
    }
    function i(ee, Ce) {
      var be = ee.sortIndex - Ce.sortIndex;
      return be !== 0 ? be : ee.id - Ce.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      a.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, u = l.now();
      a.unstable_now = function() {
        return l.now() - u;
      };
    }
    var I = [], f = [], h = 1, v = null, b = 3, S = !1, R = !1, W = !1, x = typeof setTimeout == "function" ? setTimeout : null, M = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function E(ee) {
      for (var Ce = t(f); Ce !== null; ) {
        if (Ce.callback === null) n(f);
        else if (Ce.startTime <= ee) n(f), Ce.sortIndex = Ce.expirationTime, e(I, Ce);
        else break;
        Ce = t(f);
      }
    }
    function _(ee) {
      if (W = !1, E(ee), !R) if (t(I) !== null) R = !0, Ke(P);
      else {
        var Ce = t(f);
        Ce !== null && je(_, Ce.startTime - ee);
      }
    }
    function P(ee, Ce) {
      R = !1, W && (W = !1, M(k), k = -1), S = !0;
      var be = b;
      try {
        for (E(Ce), v = t(I); v !== null && (!(v.expirationTime > Ce) || ee && !te()); ) {
          var le = v.callback;
          if (typeof le == "function") {
            v.callback = null, b = v.priorityLevel;
            var Ye = le(v.expirationTime <= Ce);
            Ce = a.unstable_now(), typeof Ye == "function" ? v.callback = Ye : v === t(I) && n(I), E(Ce);
          } else n(I);
          v = t(I);
        }
        if (v !== null) var $e = !0;
        else {
          var ke = t(f);
          ke !== null && je(_, ke.startTime - Ce), $e = !1;
        }
        return $e;
      } finally {
        v = null, b = be, S = !1;
      }
    }
    var U = !1, q = null, k = -1, O = 5, J = -1;
    function te() {
      return !(a.unstable_now() - J < O);
    }
    function fe() {
      if (q !== null) {
        var ee = a.unstable_now();
        J = ee;
        var Ce = !0;
        try {
          Ce = q(!0, ee);
        } finally {
          Ce ? pe() : (U = !1, q = null);
        }
      } else U = !1;
    }
    var pe;
    if (typeof T == "function") pe = function() {
      T(fe);
    };
    else if (typeof MessageChannel < "u") {
      var Ae = new MessageChannel(), Te = Ae.port2;
      Ae.port1.onmessage = fe, pe = function() {
        Te.postMessage(null);
      };
    } else pe = function() {
      x(fe, 0);
    };
    function Ke(ee) {
      q = ee, U || (U = !0, pe());
    }
    function je(ee, Ce) {
      k = x(function() {
        ee(a.unstable_now());
      }, Ce);
    }
    a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(ee) {
      ee.callback = null;
    }, a.unstable_continueExecution = function() {
      R || S || (R = !0, Ke(P));
    }, a.unstable_forceFrameRate = function(ee) {
      0 > ee || 125 < ee ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < ee ? Math.floor(1e3 / ee) : 5;
    }, a.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, a.unstable_getFirstCallbackNode = function() {
      return t(I);
    }, a.unstable_next = function(ee) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var Ce = 3;
          break;
        default:
          Ce = b;
      }
      var be = b;
      b = Ce;
      try {
        return ee();
      } finally {
        b = be;
      }
    }, a.unstable_pauseExecution = function() {
    }, a.unstable_requestPaint = function() {
    }, a.unstable_runWithPriority = function(ee, Ce) {
      switch (ee) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ee = 3;
      }
      var be = b;
      b = ee;
      try {
        return Ce();
      } finally {
        b = be;
      }
    }, a.unstable_scheduleCallback = function(ee, Ce, be) {
      var le = a.unstable_now();
      switch (typeof be == "object" && be !== null ? (be = be.delay, be = typeof be == "number" && 0 < be ? le + be : le) : be = le, ee) {
        case 1:
          var Ye = -1;
          break;
        case 2:
          Ye = 250;
          break;
        case 5:
          Ye = 1073741823;
          break;
        case 4:
          Ye = 1e4;
          break;
        default:
          Ye = 5e3;
      }
      return Ye = be + Ye, ee = { id: h++, callback: Ce, priorityLevel: ee, startTime: be, expirationTime: Ye, sortIndex: -1 }, be > le ? (ee.sortIndex = be, e(f, ee), t(I) === null && ee === t(f) && (W ? (M(k), k = -1) : W = !0, je(_, be - le))) : (ee.sortIndex = Ye, e(I, ee), R || S || (R = !0, Ke(P))), ee;
    }, a.unstable_shouldYield = te, a.unstable_wrapCallback = function(ee) {
      var Ce = b;
      return function() {
        var be = b;
        b = Ce;
        try {
          return ee.apply(this, arguments);
        } finally {
          b = be;
        }
      };
    };
  }(zM)), zM;
}
var KM = {}, L_;
function v$() {
  return L_ || (L_ = 1, function(a) {
    var e = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    e.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = !1, i = 5;
      function o(Fe, Ie) {
        var at = Fe.length;
        Fe.push(Ie), I(Fe, Ie, at);
      }
      function l(Fe) {
        return Fe.length === 0 ? null : Fe[0];
      }
      function u(Fe) {
        if (Fe.length === 0)
          return null;
        var Ie = Fe[0], at = Fe.pop();
        return at !== Ie && (Fe[0] = at, f(Fe, at, 0)), Ie;
      }
      function I(Fe, Ie, at) {
        for (var ye = at; ye > 0; ) {
          var Pe = ye - 1 >>> 1, Ot = Fe[Pe];
          if (h(Ot, Ie) > 0)
            Fe[Pe] = Ie, Fe[ye] = Ot, ye = Pe;
          else
            return;
        }
      }
      function f(Fe, Ie, at) {
        for (var ye = at, Pe = Fe.length, Ot = Pe >>> 1; ye < Ot; ) {
          var Re = (ye + 1) * 2 - 1, lt = Fe[Re], _e = Re + 1, ht = Fe[_e];
          if (h(lt, Ie) < 0)
            _e < Pe && h(ht, lt) < 0 ? (Fe[ye] = ht, Fe[_e] = Ie, ye = _e) : (Fe[ye] = lt, Fe[Re] = Ie, ye = Re);
          else if (_e < Pe && h(ht, Ie) < 0)
            Fe[ye] = ht, Fe[_e] = Ie, ye = _e;
          else
            return;
        }
      }
      function h(Fe, Ie) {
        var at = Fe.sortIndex - Ie.sortIndex;
        return at !== 0 ? at : Fe.id - Ie.id;
      }
      var v = 1, b = 2, S = 3, R = 4, W = 5;
      function x(Fe, Ie) {
      }
      var M = typeof performance == "object" && typeof performance.now == "function";
      if (M) {
        var T = performance;
        a.unstable_now = function() {
          return T.now();
        };
      } else {
        var E = Date, _ = E.now();
        a.unstable_now = function() {
          return E.now() - _;
        };
      }
      var P = 1073741823, U = -1, q = 250, k = 5e3, O = 1e4, J = P, te = [], fe = [], pe = 1, Ae = null, Te = S, Ke = !1, je = !1, ee = !1, Ce = typeof setTimeout == "function" ? setTimeout : null, be = typeof clearTimeout == "function" ? clearTimeout : null, le = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Ye(Fe) {
        for (var Ie = l(fe); Ie !== null; ) {
          if (Ie.callback === null)
            u(fe);
          else if (Ie.startTime <= Fe)
            u(fe), Ie.sortIndex = Ie.expirationTime, o(te, Ie);
          else
            return;
          Ie = l(fe);
        }
      }
      function $e(Fe) {
        if (ee = !1, Ye(Fe), !je)
          if (l(te) !== null)
            je = !0, rn(ke);
          else {
            var Ie = l(fe);
            Ie !== null && gn($e, Ie.startTime - Fe);
          }
      }
      function ke(Fe, Ie) {
        je = !1, ee && (ee = !1, qn()), Ke = !0;
        var at = Te;
        try {
          var ye;
          if (!n) return ot(Fe, Ie);
        } finally {
          Ae = null, Te = at, Ke = !1;
        }
      }
      function ot(Fe, Ie) {
        var at = Ie;
        for (Ye(at), Ae = l(te); Ae !== null && !t && !(Ae.expirationTime > at && (!Fe || Se())); ) {
          var ye = Ae.callback;
          if (typeof ye == "function") {
            Ae.callback = null, Te = Ae.priorityLevel;
            var Pe = Ae.expirationTime <= at, Ot = ye(Pe);
            at = a.unstable_now(), typeof Ot == "function" ? Ae.callback = Ot : Ae === l(te) && u(te), Ye(at);
          } else
            u(te);
          Ae = l(te);
        }
        if (Ae !== null)
          return !0;
        var Re = l(fe);
        return Re !== null && gn($e, Re.startTime - at), !1;
      }
      function wt(Fe, Ie) {
        switch (Fe) {
          case v:
          case b:
          case S:
          case R:
          case W:
            break;
          default:
            Fe = S;
        }
        var at = Te;
        Te = Fe;
        try {
          return Ie();
        } finally {
          Te = at;
        }
      }
      function St(Fe) {
        var Ie;
        switch (Te) {
          case v:
          case b:
          case S:
            Ie = S;
            break;
          default:
            Ie = Te;
            break;
        }
        var at = Te;
        Te = Ie;
        try {
          return Fe();
        } finally {
          Te = at;
        }
      }
      function ln(Fe) {
        var Ie = Te;
        return function() {
          var at = Te;
          Te = Ie;
          try {
            return Fe.apply(this, arguments);
          } finally {
            Te = at;
          }
        };
      }
      function hn(Fe, Ie, at) {
        var ye = a.unstable_now(), Pe;
        if (typeof at == "object" && at !== null) {
          var Ot = at.delay;
          typeof Ot == "number" && Ot > 0 ? Pe = ye + Ot : Pe = ye;
        } else
          Pe = ye;
        var Re;
        switch (Fe) {
          case v:
            Re = U;
            break;
          case b:
            Re = q;
            break;
          case W:
            Re = J;
            break;
          case R:
            Re = O;
            break;
          case S:
          default:
            Re = k;
            break;
        }
        var lt = Pe + Re, _e = {
          id: pe++,
          callback: Ie,
          priorityLevel: Fe,
          startTime: Pe,
          expirationTime: lt,
          sortIndex: -1
        };
        return Pe > ye ? (_e.sortIndex = Pe, o(fe, _e), l(te) === null && _e === l(fe) && (ee ? qn() : ee = !0, gn($e, Pe - ye))) : (_e.sortIndex = lt, o(te, _e), !je && !Ke && (je = !0, rn(ke))), _e;
      }
      function mn() {
      }
      function Pn() {
        !je && !Ke && (je = !0, rn(ke));
      }
      function he() {
        return l(te);
      }
      function Lt(Fe) {
        Fe.callback = null;
      }
      function Wt() {
        return Te;
      }
      var tn = !1, Gt = null, Rn = -1, nn = i, Bn = -1;
      function Se() {
        var Fe = a.unstable_now() - Bn;
        return !(Fe < nn);
      }
      function oe() {
      }
      function ct(Fe) {
        if (Fe < 0 || Fe > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Fe > 0 ? nn = Math.floor(1e3 / Fe) : nn = i;
      }
      var Ft = function() {
        if (Gt !== null) {
          var Fe = a.unstable_now();
          Bn = Fe;
          var Ie = !0, at = !0;
          try {
            at = Gt(Ie, Fe);
          } finally {
            at ? pt() : (tn = !1, Gt = null);
          }
        } else
          tn = !1;
      }, pt;
      if (typeof le == "function")
        pt = function() {
          le(Ft);
        };
      else if (typeof MessageChannel < "u") {
        var zt = new MessageChannel(), Sn = zt.port2;
        zt.port1.onmessage = Ft, pt = function() {
          Sn.postMessage(null);
        };
      } else
        pt = function() {
          Ce(Ft, 0);
        };
      function rn(Fe) {
        Gt = Fe, tn || (tn = !0, pt());
      }
      function gn(Fe, Ie) {
        Rn = Ce(function() {
          Fe(a.unstable_now());
        }, Ie);
      }
      function qn() {
        be(Rn), Rn = -1;
      }
      var qt = oe, An = null;
      a.unstable_IdlePriority = W, a.unstable_ImmediatePriority = v, a.unstable_LowPriority = R, a.unstable_NormalPriority = S, a.unstable_Profiling = An, a.unstable_UserBlockingPriority = b, a.unstable_cancelCallback = Lt, a.unstable_continueExecution = Pn, a.unstable_forceFrameRate = ct, a.unstable_getCurrentPriorityLevel = Wt, a.unstable_getFirstCallbackNode = he, a.unstable_next = St, a.unstable_pauseExecution = mn, a.unstable_requestPaint = qt, a.unstable_runWithPriority = wt, a.unstable_scheduleCallback = hn, a.unstable_shouldYield = Se, a.unstable_wrapCallback = ln, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(KM)), KM;
}
var y$ = {};
y$.NODE_ENV === "production" ? _H.exports = A$() : _H.exports = v$();
var k_ = _H.exports, _K = {};
const lY = {}, b$ = (a) => void Object.assign(lY, a);
function G$(a, e) {
  function t(h, {
    args: v = [],
    attach: b,
    ...S
  }, R) {
    let W = `${h[0].toUpperCase()}${h.slice(1)}`, x;
    if (h === "primitive") {
      if (S.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const M = S.object;
      x = HG(M, {
        type: h,
        root: R,
        attach: b,
        primitive: !0
      });
    } else {
      const M = lY[W];
      if (!M)
        throw new Error(`R3F: ${W} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(v)) throw new Error("R3F: The args prop must be an array!");
      x = HG(new M(...v), {
        type: h,
        root: R,
        attach: b,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: v
        }
      });
    }
    return x.__r3f.attach === void 0 && (x instanceof _r ? x.__r3f.attach = "geometry" : x instanceof Gc && (x.__r3f.attach = "material")), W !== "inject" && DM(x, S), x;
  }
  function n(h, v) {
    let b = !1;
    if (v) {
      var S, R;
      (S = v.__r3f) != null && S.attach ? kM(h, v, v.__r3f.attach) : v.isObject3D && h.isObject3D && (h.add(v), b = !0), b || (R = h.__r3f) == null || R.objects.push(v), v.__r3f || HG(v, {}), v.__r3f.parent = h, KH(v), XG(v);
    }
  }
  function i(h, v, b) {
    let S = !1;
    if (v) {
      var R, W;
      if ((R = v.__r3f) != null && R.attach)
        kM(h, v, v.__r3f.attach);
      else if (v.isObject3D && h.isObject3D) {
        v.parent = h, v.dispatchEvent({
          type: "added"
        }), h.dispatchEvent({
          type: "childadded",
          child: v
        });
        const x = h.children.filter((T) => T !== v), M = x.indexOf(b);
        h.children = [...x.slice(0, M), v, ...x.slice(M)], S = !0;
      }
      S || (W = h.__r3f) == null || W.objects.push(v), v.__r3f || HG(v, {}), v.__r3f.parent = h, KH(v), XG(v);
    }
  }
  function o(h, v, b = !1) {
    h && [...h].forEach((S) => l(v, S, b));
  }
  function l(h, v, b) {
    if (v) {
      var S, R, W;
      if (v.__r3f && (v.__r3f.parent = null), (S = h.__r3f) != null && S.objects && (h.__r3f.objects = h.__r3f.objects.filter((_) => _ !== v)), (R = v.__r3f) != null && R.attach)
        J_(h, v, v.__r3f.attach);
      else if (v.isObject3D && h.isObject3D) {
        var x;
        h.remove(v), (x = v.__r3f) != null && x.root && V$(j1(v), v);
      }
      const T = (W = v.__r3f) == null ? void 0 : W.primitive, E = !T && (b === void 0 ? v.dispose !== null : b);
      if (!T) {
        var M;
        o((M = v.__r3f) == null ? void 0 : M.objects, v, E), o(v.children, v, E);
      }
      if (delete v.__r3f, E && v.dispose && v.type !== "Scene") {
        const _ = () => {
          try {
            v.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? k_.unstable_scheduleCallback(k_.unstable_IdlePriority, _) : _();
      }
      XG(h);
    }
  }
  function u(h, v, b, S) {
    var R;
    const W = (R = h.__r3f) == null ? void 0 : R.parent;
    if (!W) return;
    const x = t(v, b, h.__r3f.root);
    if (h.children) {
      for (const M of h.children)
        M.__r3f && n(x, M);
      h.children = h.children.filter((M) => !M.__r3f);
    }
    h.__r3f.objects.forEach((M) => n(x, M)), h.__r3f.objects = [], h.__r3f.autoRemovedBeforeAppend || l(W, h), x.parent && (x.__r3f.autoRemovedBeforeAppend = !0), n(W, x), x.raycast && x.__r3f.eventCount && j1(x).getState().internal.interaction.push(x), [S, S.alternate].forEach((M) => {
      M !== null && (M.stateNode = x, M.ref && (typeof M.ref == "function" ? M.ref(x) : M.ref.current = x));
    });
  }
  const I = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
  return {
    reconciler: m$({
      createInstance: t,
      removeChild: l,
      appendChild: n,
      appendInitialChild: n,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, v) => {
        if (!v) return;
        const b = h.getState().scene;
        b.__r3f && (b.__r3f.root = h, n(b, v));
      },
      removeChildFromContainer: (h, v) => {
        v && l(h.getState().scene, v);
      },
      insertInContainerBefore: (h, v, b) => {
        if (!v || !b) return;
        const S = h.getState().scene;
        S.__r3f && i(S, v, b);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var v;
        return !!((v = h?.__r3f) != null ? v : {}).handlers;
      },
      prepareUpdate(h, v, b, S) {
        var R;
        if (((R = h?.__r3f) != null ? R : {}).primitive && S.object && S.object !== h)
          return [!0];
        {
          const {
            args: x = [],
            children: M,
            ...T
          } = S, {
            args: E = [],
            children: _,
            ...P
          } = b;
          if (!Array.isArray(x)) throw new Error("R3F: the args prop must be an array!");
          if (x.some((q, k) => q !== E[k])) return [!0];
          const U = OK(h, T, P, !0);
          return U.changes.length ? [!1, U] : null;
        }
      },
      commitUpdate(h, [v, b], S, R, W, x) {
        v ? u(h, S, W, x) : DM(h, b);
      },
      commitMount(h, v, b, S) {
        var R;
        const W = (R = h.__r3f) != null ? R : {};
        h.raycast && W.handlers && W.eventCount && j1(h).getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => HG(h.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var v;
        const {
          attach: b,
          parent: S
        } = (v = h.__r3f) != null ? v : {};
        b && S && J_(S, h, b), h.isObject3D && (h.visible = !1), XG(h);
      },
      unhideInstance(h, v) {
        var b;
        const {
          attach: S,
          parent: R
        } = (b = h.__r3f) != null ? b : {};
        S && R && kM(R, h, S), (h.isObject3D && v.visible == null || v.visible) && (h.visible = !0), XG(h);
      },
      createTextInstance: I,
      hideTextInstance: I,
      unhideTextInstance: I,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-expect-error
      getCurrentEventPriority: () => e ? e() : KG.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && ns.fun(performance.now) ? performance.now : ns.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: ns.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: ns.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: DM
  };
}
var D_, U_;
const LM = (a) => "colorSpace" in a || "outputColorSpace" in a, zK = () => {
  var a;
  return (a = lY.ColorManagement) != null ? a : null;
}, KK = (a) => a && a.isOrthographicCamera, B$ = (a) => a && a.hasOwnProperty("current"), qw = typeof window < "u" && ((D_ = window.document) != null && D_.createElement || ((U_ = window.navigator) == null ? void 0 : U_.product) === "ReactNative") ? xe.useLayoutEffect : xe.useEffect;
function LK(a) {
  const e = xe.useRef(a);
  return qw(() => void (e.current = a), [a]), e;
}
function S$({
  set: a
}) {
  return qw(() => (a(new Promise(() => null)), () => a(!1)), [a]), null;
}
class kK extends xe.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
kK.getDerivedStateFromError = () => ({
  error: !0
});
const DK = "__default", O_ = /* @__PURE__ */ new Map(), Z$ = (a) => a && !!a.memoized && !!a.changes;
function UK(a) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(a) ? Math.min(Math.max(a[0], t), a[1]) : a;
}
const RZ = (a) => {
  var e;
  return (e = a.__r3f) == null ? void 0 : e.root.getState();
};
function j1(a) {
  let e = a.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const ns = {
  obj: (a) => a === Object(a) && !ns.arr(a) && typeof a != "function",
  fun: (a) => typeof a == "function",
  str: (a) => typeof a == "string",
  num: (a) => typeof a == "number",
  boo: (a) => typeof a == "boolean",
  und: (a) => a === void 0,
  arr: (a) => Array.isArray(a),
  equ(a, e, {
    arrays: t = "shallow",
    objects: n = "reference",
    strict: i = !0
  } = {}) {
    if (typeof a != typeof e || !!a != !!e) return !1;
    if (ns.str(a) || ns.num(a) || ns.boo(a)) return a === e;
    const o = ns.obj(a);
    if (o && n === "reference") return a === e;
    const l = ns.arr(a);
    if (l && t === "reference") return a === e;
    if ((l || o) && a === e) return !0;
    let u;
    for (u in a) if (!(u in e)) return !1;
    if (o && t === "shallow" && n === "shallow") {
      for (u in i ? e : a) if (!ns.equ(a[u], e[u], {
        strict: i,
        objects: "reference"
      })) return !1;
    } else
      for (u in i ? e : a) if (a[u] !== e[u]) return !1;
    if (ns.und(u)) {
      if (l && a.length === 0 && e.length === 0 || o && Object.keys(a).length === 0 && Object.keys(e).length === 0) return !0;
      if (a !== e) return !1;
    }
    return !0;
  }
};
function w$(a) {
  a.dispose && a.type !== "Scene" && a.dispose();
  for (const e in a)
    e.dispose == null || e.dispose(), delete a[e];
}
function HG(a, e) {
  const t = a;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, a;
}
function zH(a, e) {
  let t = a;
  if (e.includes("-")) {
    const n = e.split("-"), i = n.pop();
    return t = n.reduce((o, l) => o[l], a), {
      target: t,
      key: i
    };
  } else return {
    target: t,
    key: e
  };
}
const P_ = /-\d+$/;
function kM(a, e, t) {
  if (ns.str(t)) {
    if (P_.test(t)) {
      const o = t.replace(P_, ""), {
        target: l,
        key: u
      } = zH(a, o);
      Array.isArray(l[u]) || (l[u] = []);
    }
    const {
      target: n,
      key: i
    } = zH(a, t);
    e.__r3f.previousAttach = n[i], n[i] = e;
  } else e.__r3f.previousAttach = t(a, e);
}
function J_(a, e, t) {
  var n, i;
  if (ns.str(t)) {
    const {
      target: o,
      key: l
    } = zH(a, t), u = e.__r3f.previousAttach;
    u === void 0 ? delete o[l] : o[l] = u;
  } else (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(a, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function OK(a, {
  children: e,
  key: t,
  ref: n,
  ...i
}, {
  children: o,
  key: l,
  ref: u,
  ...I
} = {}, f = !1) {
  const h = a.__r3f, v = Object.entries(i), b = [];
  if (f) {
    const R = Object.keys(I);
    for (let W = 0; W < R.length; W++)
      i.hasOwnProperty(R[W]) || v.unshift([R[W], DK + "remove"]);
  }
  v.forEach(([R, W]) => {
    var x;
    if ((x = a.__r3f) != null && x.primitive && R === "object" || ns.equ(W, I[R])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(R)) return b.push([R, W, !0, []]);
    let M = [];
    R.includes("-") && (M = R.split("-")), b.push([R, W, !1, M]);
    for (const T in i) {
      const E = i[T];
      T.startsWith(`${R}-`) && b.push([T, E, !1, T.split("-")]);
    }
  });
  const S = {
    ...i
  };
  return h != null && h.memoizedProps && h != null && h.memoizedProps.args && (S.args = h.memoizedProps.args), h != null && h.memoizedProps && h != null && h.memoizedProps.attach && (S.attach = h.memoizedProps.attach), {
    memoized: S,
    changes: b
  };
}
const R$ = typeof process < "u" && _K.NODE_ENV !== "production";
function DM(a, e) {
  var t;
  const n = a.__r3f, i = n?.root, o = i == null || i.getState == null ? void 0 : i.getState(), {
    memoized: l,
    changes: u
  } = Z$(e) ? e : OK(a, e), I = n?.eventCount;
  a.__r3f && (a.__r3f.memoizedProps = l);
  for (let h = 0; h < u.length; h++) {
    let [v, b, S, R] = u[h];
    if (LM(a)) {
      const T = "srgb", E = "srgb-linear";
      v === "encoding" ? (v = "colorSpace", b = b === 3001 ? T : E) : v === "outputEncoding" && (v = "outputColorSpace", b = b === 3001 ? T : E);
    }
    let W = a, x = W[v];
    if (R.length && (x = R.reduce((M, T) => M[T], a), !(x && x.set))) {
      const [M, ...T] = R.reverse();
      W = T.reverse().reduce((E, _) => E[_], a), v = M;
    }
    if (b === DK + "remove")
      if (W.constructor) {
        let M = O_.get(W.constructor);
        M || (M = new W.constructor(), O_.set(W.constructor, M)), b = M[v];
      } else
        b = 0;
    if (S && n)
      b ? n.handlers[v] = b : delete n.handlers[v], n.eventCount = Object.keys(n.handlers).length;
    else if (x && x.set && (x.copy || x instanceof db)) {
      if (Array.isArray(b))
        x.fromArray ? x.fromArray(b) : x.set(...b);
      else if (x.copy && b && b.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (R$ ? x.constructor.name === b.constructor.name : x.constructor === b.constructor))
        x.copy(b);
      else if (b !== void 0) {
        const M = x instanceof hi;
        !M && x.setScalar ? x.setScalar(b) : x instanceof db && b instanceof db ? x.mask = b.mask : x.set(b), !zK() && o && !o.linear && M && x.convertSRGBToLinear();
      }
    } else if (W[v] = b, W[v] instanceof Fs && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
    W[v].format === rg && W[v].type === _h && o) {
      const M = W[v];
      LM(M) && LM(o.gl) ? M.colorSpace = o.gl.outputColorSpace : M.encoding = o.gl.outputEncoding;
    }
    XG(a);
  }
  if (n && n.parent && a.raycast && I !== n.eventCount) {
    const h = j1(a).getState().internal, v = h.interaction.indexOf(a);
    v > -1 && h.interaction.splice(v, 1), n.eventCount && h.interaction.push(a);
  }
  return !(u.length === 1 && u[0][0] === "onUpdate") && u.length && (t = a.__r3f) != null && t.parent && KH(a), a;
}
function XG(a) {
  var e, t;
  const n = (e = a.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  n && n.internal.frames === 0 && n.invalidate();
}
function KH(a) {
  a.onUpdate == null || a.onUpdate(a);
}
function x$(a, e) {
  a.manual || (KK(a) ? (a.left = e.width / -2, a.right = e.width / 2, a.top = e.height / 2, a.bottom = e.height / -2) : a.aspect = e.width / e.height, a.updateProjectionMatrix(), a.updateMatrixWorld());
}
function X1(a) {
  return (a.eventObject || a.object).uuid + "/" + a.index + a.instanceId;
}
function W$() {
  var a;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e) return KG.DefaultEventPriority;
  switch ((a = e.event) == null ? void 0 : a.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return KG.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return KG.ContinuousEventPriority;
    default:
      return KG.DefaultEventPriority;
  }
}
function PK(a, e, t, n) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (a.delete(n), i.target.releasePointerCapture(n)));
}
function V$(a, e) {
  const {
    internal: t
  } = a.getState();
  t.interaction = t.interaction.filter((n) => n !== e), t.initialHits = t.initialHits.filter((n) => n !== e), t.hovered.forEach((n, i) => {
    (n.eventObject === e || n.object === e) && t.hovered.delete(i);
  }), t.capturedMap.forEach((n, i) => {
    PK(t.capturedMap, e, n, i);
  });
}
function N$(a) {
  function e(I) {
    const {
      internal: f
    } = a.getState(), h = I.offsetX - f.initialClick[0], v = I.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(h * h + v * v));
  }
  function t(I) {
    return I.filter((f) => ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
      var v;
      return (v = f.__r3f) == null ? void 0 : v.handlers["onPointer" + h];
    }));
  }
  function n(I, f) {
    const h = a.getState(), v = /* @__PURE__ */ new Set(), b = [], S = f ? f(h.internal.interaction) : h.internal.interaction;
    for (let M = 0; M < S.length; M++) {
      const T = RZ(S[M]);
      T && (T.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(I, h);
    function R(M) {
      const T = RZ(M);
      if (!T || !T.events.enabled || T.raycaster.camera === null) return [];
      if (T.raycaster.camera === void 0) {
        var E;
        T.events.compute == null || T.events.compute(I, T, (E = T.previousRoot) == null ? void 0 : E.getState()), T.raycaster.camera === void 0 && (T.raycaster.camera = null);
      }
      return T.raycaster.camera ? T.raycaster.intersectObject(M, !0) : [];
    }
    let W = S.flatMap(R).sort((M, T) => {
      const E = RZ(M.object), _ = RZ(T.object);
      return !E || !_ ? M.distance - T.distance : _.events.priority - E.events.priority || M.distance - T.distance;
    }).filter((M) => {
      const T = X1(M);
      return v.has(T) ? !1 : (v.add(T), !0);
    });
    h.events.filter && (W = h.events.filter(W, h));
    for (const M of W) {
      let T = M.object;
      for (; T; ) {
        var x;
        (x = T.__r3f) != null && x.eventCount && b.push({
          ...M,
          eventObject: T
        }), T = T.parent;
      }
    }
    if ("pointerId" in I && h.internal.capturedMap.has(I.pointerId))
      for (let M of h.internal.capturedMap.get(I.pointerId).values())
        v.has(X1(M.intersection)) || b.push(M.intersection);
    return b;
  }
  function i(I, f, h, v) {
    const b = a.getState();
    if (I.length) {
      const S = {
        stopped: !1
      };
      for (const R of I) {
        const W = RZ(R.object) || b, {
          raycaster: x,
          pointer: M,
          camera: T,
          internal: E
        } = W, _ = new Ze(M.x, M.y, 0).unproject(T), P = (J) => {
          var te, fe;
          return (te = (fe = E.capturedMap.get(J)) == null ? void 0 : fe.has(R.eventObject)) != null ? te : !1;
        }, U = (J) => {
          const te = {
            intersection: R,
            target: f.target
          };
          E.capturedMap.has(J) ? E.capturedMap.get(J).set(R.eventObject, te) : E.capturedMap.set(J, /* @__PURE__ */ new Map([[R.eventObject, te]])), f.target.setPointerCapture(J);
        }, q = (J) => {
          const te = E.capturedMap.get(J);
          te && PK(E.capturedMap, R.eventObject, te, J);
        };
        let k = {};
        for (let J in f) {
          let te = f[J];
          typeof te != "function" && (k[J] = te);
        }
        let O = {
          ...R,
          ...k,
          pointer: M,
          intersections: I,
          stopped: S.stopped,
          delta: h,
          unprojectedPoint: _,
          ray: x.ray,
          camera: T,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const J = "pointerId" in f && E.capturedMap.get(f.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!J || // ... or if the hit object is capturing the pointer
              J.has(R.eventObject)) && (O.stopped = S.stopped = !0, E.hovered.size && Array.from(E.hovered.values()).find((te) => te.eventObject === R.eventObject))
            ) {
              const te = I.slice(0, I.indexOf(R));
              o([...te, R]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: P,
            setPointerCapture: U,
            releasePointerCapture: q
          },
          currentTarget: {
            hasPointerCapture: P,
            setPointerCapture: U,
            releasePointerCapture: q
          },
          nativeEvent: f
        };
        if (v(O), S.stopped === !0) break;
      }
    }
    return I;
  }
  function o(I) {
    const {
      internal: f
    } = a.getState();
    for (const h of f.hovered.values())
      if (!I.length || !I.find((v) => v.object === h.object && v.index === h.index && v.instanceId === h.instanceId)) {
        const b = h.eventObject.__r3f, S = b?.handlers;
        if (f.hovered.delete(X1(h)), b != null && b.eventCount) {
          const R = {
            ...h,
            intersections: I
          };
          S.onPointerOut == null || S.onPointerOut(R), S.onPointerLeave == null || S.onPointerLeave(R);
        }
      }
  }
  function l(I, f) {
    for (let h = 0; h < f.length; h++) {
      const v = f[h].__r3f;
      v == null || v.handlers.onPointerMissed == null || v.handlers.onPointerMissed(I);
    }
  }
  function u(I) {
    switch (I) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (f) => {
          const {
            internal: h
          } = a.getState();
          "pointerId" in f && h.capturedMap.has(f.pointerId) && requestAnimationFrame(() => {
            h.capturedMap.has(f.pointerId) && (h.capturedMap.delete(f.pointerId), o([]));
          });
        };
    }
    return function(h) {
      const {
        onPointerMissed: v,
        internal: b
      } = a.getState();
      b.lastEvent.current = h;
      const S = I === "onPointerMove", R = I === "onClick" || I === "onContextMenu" || I === "onDoubleClick", x = n(h, S ? t : void 0), M = R ? e(h) : 0;
      I === "onPointerDown" && (b.initialClick = [h.offsetX, h.offsetY], b.initialHits = x.map((E) => E.eventObject)), R && !x.length && M <= 2 && (l(h, b.interaction), v && v(h)), S && o(x);
      function T(E) {
        const _ = E.eventObject, P = _.__r3f, U = P?.handlers;
        if (P != null && P.eventCount)
          if (S) {
            if (U.onPointerOver || U.onPointerEnter || U.onPointerOut || U.onPointerLeave) {
              const q = X1(E), k = b.hovered.get(q);
              k ? k.stopped && E.stopPropagation() : (b.hovered.set(q, E), U.onPointerOver == null || U.onPointerOver(E), U.onPointerEnter == null || U.onPointerEnter(E));
            }
            U.onPointerMove == null || U.onPointerMove(E);
          } else {
            const q = U[I];
            q ? (!R || b.initialHits.includes(_)) && (l(h, b.interaction.filter((k) => !b.initialHits.includes(k))), q(E)) : R && b.initialHits.includes(_) && l(h, b.interaction.filter((k) => !b.initialHits.includes(k)));
          }
      }
      i(x, h, M, T);
    };
  }
  return {
    handlePointer: u
  };
}
const JK = (a) => !!(a != null && a.render), QK = /* @__PURE__ */ xe.createContext(null), M$ = (a, e) => {
  const t = g$((u, I) => {
    const f = new Ze(), h = new Ze(), v = new Ze();
    function b(M = I().camera, T = h, E = I().size) {
      const {
        width: _,
        height: P,
        top: U,
        left: q
      } = E, k = _ / P;
      T instanceof Ze ? v.copy(T) : v.set(...T);
      const O = M.getWorldPosition(f).distanceTo(v);
      if (KK(M))
        return {
          width: _ / M.zoom,
          height: P / M.zoom,
          top: U,
          left: q,
          factor: 1,
          distance: O,
          aspect: k
        };
      {
        const J = M.fov * Math.PI / 180, te = 2 * Math.tan(J / 2) * O, fe = te * (_ / P);
        return {
          width: fe,
          height: te,
          top: U,
          left: q,
          factor: _ / fe,
          distance: O,
          aspect: k
        };
      }
    }
    let S;
    const R = (M) => u((T) => ({
      performance: {
        ...T.performance,
        current: M
      }
    })), W = new sn();
    return {
      set: u,
      get: I,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (M = 1) => a(I(), M),
      advance: (M, T) => e(M, T, I()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new nY(),
      pointer: W,
      mouse: W,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const M = I();
          S && clearTimeout(S), M.performance.current !== M.performance.min && R(M.performance.min), S = setTimeout(() => R(I().performance.max), M.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: b
      },
      setEvents: (M) => u((T) => ({
        ...T,
        events: {
          ...T.events,
          ...M
        }
      })),
      setSize: (M, T, E, _, P) => {
        const U = I().camera, q = {
          width: M,
          height: T,
          top: _ || 0,
          left: P || 0,
          updateStyle: E
        };
        u((k) => ({
          size: q,
          viewport: {
            ...k.viewport,
            ...b(U, h, q)
          }
        }));
      },
      setDpr: (M) => u((T) => {
        const E = UK(M);
        return {
          viewport: {
            ...T.viewport,
            dpr: E,
            initialDpr: T.viewport.initialDpr || E
          }
        };
      }),
      setFrameloop: (M = "always") => {
        const T = I().clock;
        T.stop(), T.elapsedTime = 0, M !== "never" && (T.start(), T.elapsedTime = 0), u(() => ({
          frameloop: M
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ xe.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (M, T, E) => {
          const _ = I().internal;
          return _.priority = _.priority + (T > 0 ? 1 : 0), _.subscribers.push({
            ref: M,
            priority: T,
            store: E
          }), _.subscribers = _.subscribers.sort((P, U) => P.priority - U.priority), () => {
            const P = I().internal;
            P != null && P.subscribers && (P.priority = P.priority - (T > 0 ? 1 : 0), P.subscribers = P.subscribers.filter((U) => U.ref !== M));
          };
        }
      }
    };
  }), n = t.getState();
  let i = n.size, o = n.viewport.dpr, l = n.camera;
  return t.subscribe(() => {
    const {
      camera: u,
      size: I,
      viewport: f,
      gl: h,
      set: v
    } = t.getState();
    if (I.width !== i.width || I.height !== i.height || f.dpr !== o) {
      var b;
      i = I, o = f.dpr, x$(u, I), h.setPixelRatio(f.dpr);
      const S = (b = I.updateStyle) != null ? b : typeof HTMLCanvasElement < "u" && h.domElement instanceof HTMLCanvasElement;
      h.setSize(I.width, I.height, S);
    }
    u !== l && (l = u, v((S) => ({
      viewport: {
        ...S.viewport,
        ...S.viewport.getCurrentViewport(u)
      }
    })));
  }), t.subscribe((u) => a(u)), t;
};
let Y1, H$ = /* @__PURE__ */ new Set(), X$ = /* @__PURE__ */ new Set(), Y$ = /* @__PURE__ */ new Set();
function UM(a, e) {
  if (a.size)
    for (const {
      callback: t
    } of a.values())
      t(e);
}
function xZ(a, e) {
  switch (a) {
    case "before":
      return UM(H$, e);
    case "after":
      return UM(X$, e);
    case "tail":
      return UM(Y$, e);
  }
}
let OM, PM;
function JM(a, e, t) {
  let n = e.clock.getDelta();
  for (e.frameloop === "never" && typeof a == "number" && (n = a - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = a), OM = e.internal.subscribers, Y1 = 0; Y1 < OM.length; Y1++)
    PM = OM[Y1], PM.ref.current(PM.store.getState(), n, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function F$(a) {
  let e = !1, t = !1, n, i, o;
  function l(f) {
    i = requestAnimationFrame(l), e = !0, n = 0, xZ("before", f), t = !0;
    for (const v of a.values()) {
      var h;
      o = v.store.getState(), o.internal.active && (o.frameloop === "always" || o.internal.frames > 0) && !((h = o.gl.xr) != null && h.isPresenting) && (n += JM(f, o));
    }
    if (t = !1, xZ("after", f), n === 0)
      return xZ("tail", f), e = !1, cancelAnimationFrame(i);
  }
  function u(f, h = 1) {
    var v;
    if (!f) return a.forEach((b) => u(b.store.getState(), h));
    (v = f.gl.xr) != null && v.isPresenting || !f.internal.active || f.frameloop === "never" || (h > 1 ? f.internal.frames = Math.min(60, f.internal.frames + h) : t ? f.internal.frames = 2 : f.internal.frames = 1, e || (e = !0, requestAnimationFrame(l)));
  }
  function I(f, h = !0, v, b) {
    if (h && xZ("before", f), v) JM(f, v, b);
    else for (const S of a.values()) JM(f, S.store.getState());
    h && xZ("after", f);
  }
  return {
    loop: l,
    invalidate: u,
    advance: I
  };
}
function jK() {
  const a = xe.useContext(QK);
  if (!a) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return a;
}
function Tg(a = (t) => t, e) {
  return jK()(a, e);
}
function KW(a, e = 0) {
  const t = jK(), n = t.getState().internal.subscribe, i = LK(a);
  return qw(() => n(i, e, t), [e, n, t]), null;
}
const nB = /* @__PURE__ */ new Map(), {
  invalidate: Q_,
  advance: j_
} = F$(nB), {
  reconciler: _2,
  applyProps: xG
} = G$(nB, W$), WG = {
  objects: "shallow",
  strict: !1
}, E$ = (a, e) => {
  const t = typeof a == "function" ? a(e) : a;
  return JK(t) ? t : new Uz({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...a
  });
};
function T$(a, e) {
  const t = typeof HTMLCanvasElement < "u" && a instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: n,
      height: i,
      top: o,
      left: l,
      updateStyle: u = t
    } = e;
    return {
      width: n,
      height: i,
      top: o,
      left: l,
      updateStyle: u
    };
  } else if (typeof HTMLCanvasElement < "u" && a instanceof HTMLCanvasElement && a.parentElement) {
    const {
      width: n,
      height: i,
      top: o,
      left: l
    } = a.parentElement.getBoundingClientRect();
    return {
      width: n,
      height: i,
      top: o,
      left: l,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && a instanceof OffscreenCanvas)
    return {
      width: a.width,
      height: a.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function _$(a) {
  const e = nB.get(a), t = e?.fiber, n = e?.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), o = n || M$(Q_, j_), l = t || _2.createContainer(o, KG.ConcurrentRoot, null, !1, null, "", i, null);
  e || nB.set(a, {
    fiber: l,
    store: o
  });
  let u, I = !1, f;
  return {
    configure(h = {}) {
      let {
        gl: v,
        size: b,
        scene: S,
        events: R,
        onCreated: W,
        shadows: x = !1,
        linear: M = !1,
        flat: T = !1,
        legacy: E = !1,
        orthographic: _ = !1,
        frameloop: P = "always",
        dpr: U = [1, 2],
        performance: q,
        raycaster: k,
        camera: O,
        onPointerMissed: J
      } = h, te = o.getState(), fe = te.gl;
      te.gl || te.set({
        gl: fe = E$(v, a)
      });
      let pe = te.raycaster;
      pe || te.set({
        raycaster: pe = new oY()
      });
      const {
        params: Ae,
        ...Te
      } = k || {};
      if (ns.equ(Te, pe, WG) || xG(pe, {
        ...Te
      }), ns.equ(Ae, pe.params, WG) || xG(pe, {
        params: {
          ...pe.params,
          ...Ae
        }
      }), !te.camera || te.camera === f && !ns.equ(f, O, WG)) {
        f = O;
        const be = O instanceof kw, le = be ? O : _ ? new wm(0, 0, 0, 0, 0.1, 1e3) : new tl(75, 0, 0.1, 1e3);
        be || (le.position.z = 5, O && (xG(le, O), ("aspect" in O || "left" in O || "right" in O || "bottom" in O || "top" in O) && (le.manual = !0, le.updateProjectionMatrix())), !te.camera && !(O != null && O.rotation) && le.lookAt(0, 0, 0)), te.set({
          camera: le
        }), pe.camera = le;
      }
      if (!te.scene) {
        let be;
        S instanceof Y2 ? be = S : (be = new Y2(), S && xG(be, S)), te.set({
          scene: HG(be)
        });
      }
      if (!te.xr) {
        var Ke;
        const be = ($e, ke) => {
          const ot = o.getState();
          ot.frameloop !== "never" && j_($e, !0, ot, ke);
        }, le = () => {
          const $e = o.getState();
          $e.gl.xr.enabled = $e.gl.xr.isPresenting, $e.gl.xr.setAnimationLoop($e.gl.xr.isPresenting ? be : null), $e.gl.xr.isPresenting || Q_($e);
        }, Ye = {
          connect() {
            const $e = o.getState().gl;
            $e.xr.addEventListener("sessionstart", le), $e.xr.addEventListener("sessionend", le);
          },
          disconnect() {
            const $e = o.getState().gl;
            $e.xr.removeEventListener("sessionstart", le), $e.xr.removeEventListener("sessionend", le);
          }
        };
        typeof ((Ke = fe.xr) == null ? void 0 : Ke.addEventListener) == "function" && Ye.connect(), te.set({
          xr: Ye
        });
      }
      if (fe.shadowMap) {
        const be = fe.shadowMap.enabled, le = fe.shadowMap.type;
        if (fe.shadowMap.enabled = !!x, ns.boo(x))
          fe.shadowMap.type = LZ;
        else if (ns.str(x)) {
          var je;
          const Ye = {
            basic: X5,
            percentage: uW,
            soft: LZ,
            variance: Yh
          };
          fe.shadowMap.type = (je = Ye[x]) != null ? je : LZ;
        } else ns.obj(x) && Object.assign(fe.shadowMap, x);
        (be !== fe.shadowMap.enabled || le !== fe.shadowMap.type) && (fe.shadowMap.needsUpdate = !0);
      }
      const ee = zK();
      ee && ("enabled" in ee ? ee.enabled = !E : "legacyMode" in ee && (ee.legacyMode = E)), I || xG(fe, {
        outputEncoding: M ? 3e3 : 3001,
        toneMapping: T ? sp : vX
      }), te.legacy !== E && te.set(() => ({
        legacy: E
      })), te.linear !== M && te.set(() => ({
        linear: M
      })), te.flat !== T && te.set(() => ({
        flat: T
      })), v && !ns.fun(v) && !JK(v) && !ns.equ(v, fe, WG) && xG(fe, v), R && !te.events.handlers && te.set({
        events: R(o)
      });
      const Ce = T$(a, b);
      return ns.equ(Ce, te.size, WG) || te.setSize(Ce.width, Ce.height, Ce.updateStyle, Ce.top, Ce.left), U && te.viewport.dpr !== UK(U) && te.setDpr(U), te.frameloop !== P && te.setFrameloop(P), te.onPointerMissed || te.set({
        onPointerMissed: J
      }), q && !ns.equ(q, te.performance, WG) && te.set((be) => ({
        performance: {
          ...be.performance,
          ...q
        }
      })), u = W, I = !0, this;
    },
    render(h) {
      return I || this.configure(), _2.updateContainer(/* @__PURE__ */ ze.jsx(z$, {
        store: o,
        children: h,
        onCreated: u,
        rootElement: a
      }), l, null, () => {
      }), o;
    },
    unmount() {
      qK(a);
    }
  };
}
function z$({
  store: a,
  children: e,
  onCreated: t,
  rootElement: n
}) {
  return qw(() => {
    const i = a.getState();
    i.set((o) => ({
      internal: {
        ...o.internal,
        active: !0
      }
    })), t && t(i), a.getState().events.connected || i.events.connect == null || i.events.connect(n);
  }, []), /* @__PURE__ */ ze.jsx(QK.Provider, {
    value: a,
    children: e
  });
}
function qK(a, e) {
  const t = nB.get(a), n = t?.fiber;
  if (n) {
    const i = t?.store.getState();
    i && (i.internal.active = !1), _2.updateContainer(null, n, null, () => {
      i && setTimeout(() => {
        try {
          var o, l, u, I;
          i.events.disconnect == null || i.events.disconnect(), (o = i.gl) == null || (l = o.renderLists) == null || l.dispose == null || l.dispose(), (u = i.gl) == null || u.forceContextLoss == null || u.forceContextLoss(), (I = i.gl) != null && I.xr && i.xr.disconnect(), w$(i), nB.delete(a);
        } catch {
        }
      }, 500);
    });
  }
}
_2.injectIntoDevTools({
  bundleType: _K.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: xe.version
});
const QM = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function K$(a) {
  const {
    handlePointer: e
  } = N$(a);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, i) {
      n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(QM).reduce((t, n) => ({
      ...t,
      [n]: e(n)
    }), {}),
    update: () => {
      var t;
      const {
        events: n,
        internal: i
      } = a.getState();
      (t = i.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var n;
      const {
        set: i,
        events: o
      } = a.getState();
      o.disconnect == null || o.disconnect(), i((l) => ({
        events: {
          ...l.events,
          connected: t
        }
      })), Object.entries((n = o.handlers) != null ? n : []).forEach(([l, u]) => {
        const [I, f] = QM[l];
        t.addEventListener(I, u, {
          passive: f
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: n
      } = a.getState();
      if (n.connected) {
        var i;
        Object.entries((i = n.handlers) != null ? i : []).forEach(([o, l]) => {
          if (n && n.connected instanceof HTMLElement) {
            const [u] = QM[o];
            n.connected.removeEventListener(u, l);
          }
        }), t((o) => ({
          events: {
            ...o.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
function LH(a, e, t) {
  var n, i, o, l, u;
  e == null && (e = 100);
  function I() {
    var h = Date.now() - l;
    h < e && h >= 0 ? n = setTimeout(I, e - h) : (n = null, t || (u = a.apply(o, i), o = i = null));
  }
  var f = function() {
    o = this, i = arguments, l = Date.now();
    var h = t && !n;
    return n || (n = setTimeout(I, e)), h && (u = a.apply(o, i), o = i = null), u;
  };
  return f.clear = function() {
    n && (clearTimeout(n), n = null);
  }, f.flush = function() {
    n && (u = a.apply(o, i), o = i = null, clearTimeout(n), n = null);
  }, f;
}
LH.debounce = LH;
var L$ = LH;
const q_ = /* @__PURE__ */ Tw(L$);
var k$ = Object.defineProperty, D$ = Object.defineProperties, U$ = Object.getOwnPropertyDescriptors, $_ = Object.getOwnPropertySymbols, O$ = Object.prototype.hasOwnProperty, P$ = Object.prototype.propertyIsEnumerable, e3 = (a, e, t) => e in a ? k$(a, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[e] = t, t3 = (a, e) => {
  for (var t in e || (e = {}))
    O$.call(e, t) && e3(a, t, e[t]);
  if ($_)
    for (var t of $_(e))
      P$.call(e, t) && e3(a, t, e[t]);
  return a;
}, J$ = (a, e) => D$(a, U$(e)), n3, i3;
typeof window < "u" && ((n3 = window.document) != null && n3.createElement || ((i3 = window.navigator) == null ? void 0 : i3.product) === "ReactNative") ? xe.useLayoutEffect : xe.useEffect;
function $K(a, e, t) {
  if (!a)
    return;
  if (t(a) === !0)
    return a;
  let n = a.child;
  for (; n; ) {
    const i = $K(n, e, t);
    if (i)
      return i;
    n = n.sibling;
  }
}
function eL(a) {
  try {
    return Object.defineProperties(a, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return a;
  }
}
const r3 = console.error;
console.error = function() {
  const a = [...arguments].join("");
  if (a?.startsWith("Warning:") && a.includes("useContext")) {
    console.error = r3;
    return;
  }
  return r3.apply(this, arguments);
};
const uY = eL(xe.createContext(null));
class tL extends xe.Component {
  render() {
    return /* @__PURE__ */ xe.createElement(uY.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
function Q$() {
  const a = xe.useContext(uY);
  if (a === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = xe.useId();
  return xe.useMemo(() => {
    for (const n of [a, a?.alternate]) {
      if (!n)
        continue;
      const i = $K(n, !1, (o) => {
        let l = o.memoizedState;
        for (; l; ) {
          if (l.memoizedState === e)
            return !0;
          l = l.next;
        }
      });
      if (i)
        return i;
    }
  }, [a, e]);
}
function j$() {
  const a = Q$(), [e] = xe.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = a;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      i && i !== uY && !e.has(i) && e.set(i, xe.useContext(eL(i)));
    }
    t = t.return;
  }
  return e;
}
function q$() {
  const a = j$();
  return xe.useMemo(
    () => Array.from(a.keys()).reduce(
      (e, t) => (n) => /* @__PURE__ */ xe.createElement(e, null, /* @__PURE__ */ xe.createElement(t.Provider, J$(t3({}, n), {
        value: a.get(t)
      }))),
      (e) => /* @__PURE__ */ xe.createElement(tL, t3({}, e))
    ),
    [a]
  );
}
function $$({
  debounce: a,
  scroll: e,
  polyfill: t,
  offsetSize: n
} = {
  debounce: 0,
  scroll: !1,
  offsetSize: !1
}) {
  const i = t || typeof window < "u" && window.ResizeObserver, [o, l] = xe.useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  });
  if (!i)
    return o.width = 1280, o.height = 800, [() => {
    }, o, () => {
    }];
  const u = xe.useRef({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: o
  }), I = a ? typeof a == "number" ? a : a.scroll : null, f = a ? typeof a == "number" ? a : a.resize : null, h = xe.useRef(!1);
  xe.useEffect(() => (h.current = !0, () => void (h.current = !1)));
  const [v, b, S] = xe.useMemo(() => {
    const M = () => {
      if (!u.current.element) return;
      const {
        left: T,
        top: E,
        width: _,
        height: P,
        bottom: U,
        right: q,
        x: k,
        y: O
      } = u.current.element.getBoundingClientRect(), J = {
        left: T,
        top: E,
        width: _,
        height: P,
        bottom: U,
        right: q,
        x: k,
        y: O
      };
      u.current.element instanceof HTMLElement && n && (J.height = u.current.element.offsetHeight, J.width = u.current.element.offsetWidth), Object.freeze(J), h.current && !iee(u.current.lastBounds, J) && l(u.current.lastBounds = J);
    };
    return [M, f ? q_(M, f) : M, I ? q_(M, I) : M];
  }, [l, n, I, f]);
  function R() {
    u.current.scrollContainers && (u.current.scrollContainers.forEach((M) => M.removeEventListener("scroll", S, !0)), u.current.scrollContainers = null), u.current.resizeObserver && (u.current.resizeObserver.disconnect(), u.current.resizeObserver = null);
  }
  function W() {
    u.current.element && (u.current.resizeObserver = new i(S), u.current.resizeObserver.observe(u.current.element), e && u.current.scrollContainers && u.current.scrollContainers.forEach((M) => M.addEventListener("scroll", S, {
      capture: !0,
      passive: !0
    })));
  }
  const x = (M) => {
    !M || M === u.current.element || (R(), u.current.element = M, u.current.scrollContainers = nL(M), W());
  };
  return tee(S, !!e), eee(b), xe.useEffect(() => {
    R(), W();
  }, [e, S, b]), xe.useEffect(() => R, []), [x, o, v];
}
function eee(a) {
  xe.useEffect(() => {
    const e = a;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [a]);
}
function tee(a, e) {
  xe.useEffect(() => {
    if (e) {
      const t = a;
      return window.addEventListener("scroll", t, {
        capture: !0,
        passive: !0
      }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [a, e]);
}
function nL(a) {
  const e = [];
  if (!a || a === document.body) return e;
  const {
    overflow: t,
    overflowX: n,
    overflowY: i
  } = window.getComputedStyle(a);
  return [t, n, i].some((o) => o === "auto" || o === "scroll") && e.push(a), [...e, ...nL(a.parentElement)];
}
const nee = ["x", "y", "top", "bottom", "left", "right", "width", "height"], iee = (a, e) => nee.every((t) => a[t] === e[t]), ree = /* @__PURE__ */ xe.forwardRef(function({
  children: e,
  fallback: t,
  resize: n,
  style: i,
  gl: o,
  events: l = K$,
  eventSource: u,
  eventPrefix: I,
  shadows: f,
  linear: h,
  flat: v,
  legacy: b,
  orthographic: S,
  frameloop: R,
  dpr: W,
  performance: x,
  raycaster: M,
  camera: T,
  scene: E,
  onPointerMissed: _,
  onCreated: P,
  ...U
}, q) {
  xe.useMemo(() => b$(a$), []);
  const k = q$(), [O, J] = $$({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...n
  }), te = xe.useRef(null), fe = xe.useRef(null);
  xe.useImperativeHandle(q, () => te.current);
  const pe = LK(_), [Ae, Te] = xe.useState(!1), [Ke, je] = xe.useState(!1);
  if (Ae) throw Ae;
  if (Ke) throw Ke;
  const ee = xe.useRef(null);
  qw(() => {
    const be = te.current;
    J.width > 0 && J.height > 0 && be && (ee.current || (ee.current = _$(be)), ee.current.configure({
      gl: o,
      events: l,
      shadows: f,
      linear: h,
      flat: v,
      legacy: b,
      orthographic: S,
      frameloop: R,
      dpr: W,
      performance: x,
      raycaster: M,
      camera: T,
      scene: E,
      size: J,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...le) => pe.current == null ? void 0 : pe.current(...le),
      onCreated: (le) => {
        le.events.connect == null || le.events.connect(u ? B$(u) ? u.current : u : fe.current), I && le.setEvents({
          compute: (Ye, $e) => {
            const ke = Ye[I + "X"], ot = Ye[I + "Y"];
            $e.pointer.set(ke / $e.size.width * 2 - 1, -(ot / $e.size.height) * 2 + 1), $e.raycaster.setFromCamera($e.pointer, $e.camera);
          }
        }), P?.(le);
      }
    }), ee.current.render(/* @__PURE__ */ ze.jsx(k, {
      children: /* @__PURE__ */ ze.jsx(kK, {
        set: je,
        children: /* @__PURE__ */ ze.jsx(xe.Suspense, {
          fallback: /* @__PURE__ */ ze.jsx(S$, {
            set: Te
          }),
          children: e
        })
      })
    })));
  }), xe.useEffect(() => {
    const be = te.current;
    if (be) return () => qK(be);
  }, []);
  const Ce = u ? "none" : "auto";
  return /* @__PURE__ */ ze.jsx("div", {
    ref: fe,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: Ce,
      ...i
    },
    ...U,
    children: /* @__PURE__ */ ze.jsx("div", {
      ref: O,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ ze.jsx("canvas", {
        ref: te,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}), aee = /* @__PURE__ */ xe.forwardRef(function(e, t) {
  return /* @__PURE__ */ ze.jsx(tL, {
    children: /* @__PURE__ */ ze.jsx(ree, {
      ...e,
      ref: t
    })
  });
});
var oee = Object.defineProperty, see = (a, e, t) => e in a ? oee(a, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[e] = t, dr = (a, e, t) => (see(a, typeof e != "symbol" ? e + "" : e, t), t);
const F1 = new wb(), a3 = new Gm(), lee = Math.cos(70 * (Math.PI / 180)), o3 = (a, e) => (a % e + e) % e;
let uee = class extends Ip {
  constructor(e, t) {
    super(), dr(this, "object"), dr(this, "domElement"), dr(this, "enabled", !0), dr(this, "target", new Ze()), dr(this, "minDistance", 0), dr(this, "maxDistance", 1 / 0), dr(this, "minZoom", 0), dr(this, "maxZoom", 1 / 0), dr(this, "minPolarAngle", 0), dr(this, "maxPolarAngle", Math.PI), dr(this, "minAzimuthAngle", -1 / 0), dr(this, "maxAzimuthAngle", 1 / 0), dr(this, "enableDamping", !1), dr(this, "dampingFactor", 0.05), dr(this, "enableZoom", !0), dr(this, "zoomSpeed", 1), dr(this, "enableRotate", !0), dr(this, "rotateSpeed", 1), dr(this, "enablePan", !0), dr(this, "panSpeed", 1), dr(this, "screenSpacePanning", !0), dr(this, "keyPanSpeed", 7), dr(this, "zoomToCursor", !1), dr(this, "autoRotate", !1), dr(this, "autoRotateSpeed", 2), dr(this, "reverseOrbit", !1), dr(this, "reverseHorizontalOrbit", !1), dr(this, "reverseVerticalOrbit", !1), dr(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), dr(this, "mouseButtons", {
      LEFT: Oy.ROTATE,
      MIDDLE: Oy.DOLLY,
      RIGHT: Oy.PAN
    }), dr(this, "touches", { ONE: Py.ROTATE, TWO: Py.DOLLY_PAN }), dr(this, "target0"), dr(this, "position0"), dr(this, "zoom0"), dr(this, "_domElementKeyEvents", null), dr(this, "getPolarAngle"), dr(this, "getAzimuthalAngle"), dr(this, "setPolarAngle"), dr(this, "setAzimuthalAngle"), dr(this, "getDistance"), dr(this, "listenToKeyEvents"), dr(this, "stopListenToKeyEvents"), dr(this, "saveState"), dr(this, "reset"), dr(this, "update"), dr(this, "connect"), dr(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => h.phi, this.getAzimuthalAngle = () => h.theta, this.setPolarAngle = (ye) => {
      let Pe = o3(ye, 2 * Math.PI), Ot = h.phi;
      Ot < 0 && (Ot += 2 * Math.PI), Pe < 0 && (Pe += 2 * Math.PI);
      let Re = Math.abs(Pe - Ot);
      2 * Math.PI - Re < Re && (Pe < Ot ? Pe += 2 * Math.PI : Ot += 2 * Math.PI), v.phi = Pe - Ot, n.update();
    }, this.setAzimuthalAngle = (ye) => {
      let Pe = o3(ye, 2 * Math.PI), Ot = h.theta;
      Ot < 0 && (Ot += 2 * Math.PI), Pe < 0 && (Pe += 2 * Math.PI);
      let Re = Math.abs(Pe - Ot);
      2 * Math.PI - Re < Re && (Pe < Ot ? Pe += 2 * Math.PI : Ot += 2 * Math.PI), v.theta = Pe - Ot, n.update();
    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (ye) => {
      ye.addEventListener("keydown", rn), this._domElementKeyEvents = ye;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", rn), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = () => {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(i), n.update(), I = u.NONE;
    }, this.update = (() => {
      const ye = new Ze(), Pe = new Ze(0, 1, 0), Ot = new zu().setFromUnitVectors(e.up, Pe), Re = Ot.clone().invert(), lt = new Ze(), _e = new zu(), ht = 2 * Math.PI;
      return function() {
        const an = n.object.position;
        Ot.setFromUnitVectors(e.up, Pe), Re.copy(Ot).invert(), ye.copy(an).sub(n.target), ye.applyQuaternion(Ot), h.setFromVector3(ye), n.autoRotate && I === u.NONE && Ae(fe()), n.enableDamping ? (h.theta += v.theta * n.dampingFactor, h.phi += v.phi * n.dampingFactor) : (h.theta += v.theta, h.phi += v.phi);
        let fi = n.minAzimuthAngle, xi = n.maxAzimuthAngle;
        isFinite(fi) && isFinite(xi) && (fi < -Math.PI ? fi += ht : fi > Math.PI && (fi -= ht), xi < -Math.PI ? xi += ht : xi > Math.PI && (xi -= ht), fi <= xi ? h.theta = Math.max(fi, Math.min(xi, h.theta)) : h.theta = h.theta > (fi + xi) / 2 ? Math.max(fi, h.theta) : Math.min(xi, h.theta)), h.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, h.phi)), h.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(S, n.dampingFactor) : n.target.add(S), n.zoomToCursor && O || n.object.isOrthographicCamera ? h.radius = Ye(h.radius) : h.radius = Ye(h.radius * b), ye.setFromSpherical(h), ye.applyQuaternion(Re), an.copy(n.target).add(ye), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (v.theta *= 1 - n.dampingFactor, v.phi *= 1 - n.dampingFactor, S.multiplyScalar(1 - n.dampingFactor)) : (v.set(0, 0, 0), S.set(0, 0, 0));
        let Ir = !1;
        if (n.zoomToCursor && O) {
          let Xi = null;
          if (n.object instanceof tl && n.object.isPerspectiveCamera) {
            const pi = ye.length();
            Xi = Ye(pi * b);
            const Cr = pi - Xi;
            n.object.position.addScaledVector(q, Cr), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const pi = new Ze(k.x, k.y, 0);
            pi.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / b)), n.object.updateProjectionMatrix(), Ir = !0;
            const Cr = new Ze(k.x, k.y, 0);
            Cr.unproject(n.object), n.object.position.sub(Cr).add(pi), n.object.updateMatrixWorld(), Xi = ye.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          Xi !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Xi).add(n.object.position) : (F1.origin.copy(n.object.position), F1.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(F1.direction)) < lee ? e.lookAt(n.target) : (a3.setFromNormalAndCoplanarPoint(n.object.up, n.target), F1.intersectPlane(a3, n.target))));
        } else n.object instanceof wm && n.object.isOrthographicCamera && (Ir = b !== 1, Ir && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / b)), n.object.updateProjectionMatrix()));
        return b = 1, O = !1, Ir || lt.distanceToSquared(n.object.position) > f || 8 * (1 - _e.dot(n.object.quaternion)) > f ? (n.dispatchEvent(i), lt.copy(n.object.position), _e.copy(n.object.quaternion), Ir = !1, !0) : !1;
      };
    })(), this.connect = (ye) => {
      n.domElement = ye, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", qt), n.domElement.addEventListener("pointerdown", oe), n.domElement.addEventListener("pointercancel", Ft), n.domElement.addEventListener("wheel", Sn);
    }, this.dispose = () => {
      var ye, Pe, Ot, Re, lt, _e;
      n.domElement && (n.domElement.style.touchAction = "auto"), (ye = n.domElement) == null || ye.removeEventListener("contextmenu", qt), (Pe = n.domElement) == null || Pe.removeEventListener("pointerdown", oe), (Ot = n.domElement) == null || Ot.removeEventListener("pointercancel", Ft), (Re = n.domElement) == null || Re.removeEventListener("wheel", Sn), (lt = n.domElement) == null || lt.ownerDocument.removeEventListener("pointermove", ct), (_e = n.domElement) == null || _e.ownerDocument.removeEventListener("pointerup", Ft), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", rn);
    };
    const n = this, i = { type: "change" }, o = { type: "start" }, l = { type: "end" }, u = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let I = u.NONE;
    const f = 1e-6, h = new FH(), v = new FH();
    let b = 1;
    const S = new Ze(), R = new sn(), W = new sn(), x = new sn(), M = new sn(), T = new sn(), E = new sn(), _ = new sn(), P = new sn(), U = new sn(), q = new Ze(), k = new sn();
    let O = !1;
    const J = [], te = {};
    function fe() {
      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function pe() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function Ae(ye) {
      n.reverseOrbit || n.reverseHorizontalOrbit ? v.theta += ye : v.theta -= ye;
    }
    function Te(ye) {
      n.reverseOrbit || n.reverseVerticalOrbit ? v.phi += ye : v.phi -= ye;
    }
    const Ke = (() => {
      const ye = new Ze();
      return function(Ot, Re) {
        ye.setFromMatrixColumn(Re, 0), ye.multiplyScalar(-Ot), S.add(ye);
      };
    })(), je = (() => {
      const ye = new Ze();
      return function(Ot, Re) {
        n.screenSpacePanning === !0 ? ye.setFromMatrixColumn(Re, 1) : (ye.setFromMatrixColumn(Re, 0), ye.crossVectors(n.object.up, ye)), ye.multiplyScalar(Ot), S.add(ye);
      };
    })(), ee = (() => {
      const ye = new Ze();
      return function(Ot, Re) {
        const lt = n.domElement;
        if (lt && n.object instanceof tl && n.object.isPerspectiveCamera) {
          const _e = n.object.position;
          ye.copy(_e).sub(n.target);
          let ht = ye.length();
          ht *= Math.tan(n.object.fov / 2 * Math.PI / 180), Ke(2 * Ot * ht / lt.clientHeight, n.object.matrix), je(2 * Re * ht / lt.clientHeight, n.object.matrix);
        } else lt && n.object instanceof wm && n.object.isOrthographicCamera ? (Ke(
          Ot * (n.object.right - n.object.left) / n.object.zoom / lt.clientWidth,
          n.object.matrix
        ), je(
          Re * (n.object.top - n.object.bottom) / n.object.zoom / lt.clientHeight,
          n.object.matrix
        )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    })();
    function Ce(ye) {
      n.object instanceof tl && n.object.isPerspectiveCamera || n.object instanceof wm && n.object.isOrthographicCamera ? b /= ye : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function be(ye) {
      n.object instanceof tl && n.object.isPerspectiveCamera || n.object instanceof wm && n.object.isOrthographicCamera ? b *= ye : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function le(ye) {
      if (!n.zoomToCursor || !n.domElement)
        return;
      O = !0;
      const Pe = n.domElement.getBoundingClientRect(), Ot = ye.clientX - Pe.left, Re = ye.clientY - Pe.top, lt = Pe.width, _e = Pe.height;
      k.x = Ot / lt * 2 - 1, k.y = -(Re / _e) * 2 + 1, q.set(k.x, k.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function Ye(ye) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, ye));
    }
    function $e(ye) {
      R.set(ye.clientX, ye.clientY);
    }
    function ke(ye) {
      le(ye), _.set(ye.clientX, ye.clientY);
    }
    function ot(ye) {
      M.set(ye.clientX, ye.clientY);
    }
    function wt(ye) {
      W.set(ye.clientX, ye.clientY), x.subVectors(W, R).multiplyScalar(n.rotateSpeed);
      const Pe = n.domElement;
      Pe && (Ae(2 * Math.PI * x.x / Pe.clientHeight), Te(2 * Math.PI * x.y / Pe.clientHeight)), R.copy(W), n.update();
    }
    function St(ye) {
      P.set(ye.clientX, ye.clientY), U.subVectors(P, _), U.y > 0 ? Ce(pe()) : U.y < 0 && be(pe()), _.copy(P), n.update();
    }
    function ln(ye) {
      T.set(ye.clientX, ye.clientY), E.subVectors(T, M).multiplyScalar(n.panSpeed), ee(E.x, E.y), M.copy(T), n.update();
    }
    function hn(ye) {
      le(ye), ye.deltaY < 0 ? be(pe()) : ye.deltaY > 0 && Ce(pe()), n.update();
    }
    function mn(ye) {
      let Pe = !1;
      switch (ye.code) {
        case n.keys.UP:
          ee(0, n.keyPanSpeed), Pe = !0;
          break;
        case n.keys.BOTTOM:
          ee(0, -n.keyPanSpeed), Pe = !0;
          break;
        case n.keys.LEFT:
          ee(n.keyPanSpeed, 0), Pe = !0;
          break;
        case n.keys.RIGHT:
          ee(-n.keyPanSpeed, 0), Pe = !0;
          break;
      }
      Pe && (ye.preventDefault(), n.update());
    }
    function Pn() {
      if (J.length == 1)
        R.set(J[0].pageX, J[0].pageY);
      else {
        const ye = 0.5 * (J[0].pageX + J[1].pageX), Pe = 0.5 * (J[0].pageY + J[1].pageY);
        R.set(ye, Pe);
      }
    }
    function he() {
      if (J.length == 1)
        M.set(J[0].pageX, J[0].pageY);
      else {
        const ye = 0.5 * (J[0].pageX + J[1].pageX), Pe = 0.5 * (J[0].pageY + J[1].pageY);
        M.set(ye, Pe);
      }
    }
    function Lt() {
      const ye = J[0].pageX - J[1].pageX, Pe = J[0].pageY - J[1].pageY, Ot = Math.sqrt(ye * ye + Pe * Pe);
      _.set(0, Ot);
    }
    function Wt() {
      n.enableZoom && Lt(), n.enablePan && he();
    }
    function tn() {
      n.enableZoom && Lt(), n.enableRotate && Pn();
    }
    function Gt(ye) {
      if (J.length == 1)
        W.set(ye.pageX, ye.pageY);
      else {
        const Ot = at(ye), Re = 0.5 * (ye.pageX + Ot.x), lt = 0.5 * (ye.pageY + Ot.y);
        W.set(Re, lt);
      }
      x.subVectors(W, R).multiplyScalar(n.rotateSpeed);
      const Pe = n.domElement;
      Pe && (Ae(2 * Math.PI * x.x / Pe.clientHeight), Te(2 * Math.PI * x.y / Pe.clientHeight)), R.copy(W);
    }
    function Rn(ye) {
      if (J.length == 1)
        T.set(ye.pageX, ye.pageY);
      else {
        const Pe = at(ye), Ot = 0.5 * (ye.pageX + Pe.x), Re = 0.5 * (ye.pageY + Pe.y);
        T.set(Ot, Re);
      }
      E.subVectors(T, M).multiplyScalar(n.panSpeed), ee(E.x, E.y), M.copy(T);
    }
    function nn(ye) {
      const Pe = at(ye), Ot = ye.pageX - Pe.x, Re = ye.pageY - Pe.y, lt = Math.sqrt(Ot * Ot + Re * Re);
      P.set(0, lt), U.set(0, Math.pow(P.y / _.y, n.zoomSpeed)), Ce(U.y), _.copy(P);
    }
    function Bn(ye) {
      n.enableZoom && nn(ye), n.enablePan && Rn(ye);
    }
    function Se(ye) {
      n.enableZoom && nn(ye), n.enableRotate && Gt(ye);
    }
    function oe(ye) {
      var Pe, Ot;
      n.enabled !== !1 && (J.length === 0 && ((Pe = n.domElement) == null || Pe.ownerDocument.addEventListener("pointermove", ct), (Ot = n.domElement) == null || Ot.ownerDocument.addEventListener("pointerup", Ft)), An(ye), ye.pointerType === "touch" ? gn(ye) : pt(ye));
    }
    function ct(ye) {
      n.enabled !== !1 && (ye.pointerType === "touch" ? qn(ye) : zt(ye));
    }
    function Ft(ye) {
      var Pe, Ot, Re;
      Fe(ye), J.length === 0 && ((Pe = n.domElement) == null || Pe.releasePointerCapture(ye.pointerId), (Ot = n.domElement) == null || Ot.ownerDocument.removeEventListener("pointermove", ct), (Re = n.domElement) == null || Re.ownerDocument.removeEventListener("pointerup", Ft)), n.dispatchEvent(l), I = u.NONE;
    }
    function pt(ye) {
      let Pe;
      switch (ye.button) {
        case 0:
          Pe = n.mouseButtons.LEFT;
          break;
        case 1:
          Pe = n.mouseButtons.MIDDLE;
          break;
        case 2:
          Pe = n.mouseButtons.RIGHT;
          break;
        default:
          Pe = -1;
      }
      switch (Pe) {
        case Oy.DOLLY:
          if (n.enableZoom === !1)
            return;
          ke(ye), I = u.DOLLY;
          break;
        case Oy.ROTATE:
          if (ye.ctrlKey || ye.metaKey || ye.shiftKey) {
            if (n.enablePan === !1)
              return;
            ot(ye), I = u.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            $e(ye), I = u.ROTATE;
          }
          break;
        case Oy.PAN:
          if (ye.ctrlKey || ye.metaKey || ye.shiftKey) {
            if (n.enableRotate === !1)
              return;
            $e(ye), I = u.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            ot(ye), I = u.PAN;
          }
          break;
        default:
          I = u.NONE;
      }
      I !== u.NONE && n.dispatchEvent(o);
    }
    function zt(ye) {
      if (n.enabled !== !1)
        switch (I) {
          case u.ROTATE:
            if (n.enableRotate === !1)
              return;
            wt(ye);
            break;
          case u.DOLLY:
            if (n.enableZoom === !1)
              return;
            St(ye);
            break;
          case u.PAN:
            if (n.enablePan === !1)
              return;
            ln(ye);
            break;
        }
    }
    function Sn(ye) {
      n.enabled === !1 || n.enableZoom === !1 || I !== u.NONE && I !== u.ROTATE || (ye.preventDefault(), n.dispatchEvent(o), hn(ye), n.dispatchEvent(l));
    }
    function rn(ye) {
      n.enabled === !1 || n.enablePan === !1 || mn(ye);
    }
    function gn(ye) {
      switch (Ie(ye), J.length) {
        case 1:
          switch (n.touches.ONE) {
            case Py.ROTATE:
              if (n.enableRotate === !1)
                return;
              Pn(), I = u.TOUCH_ROTATE;
              break;
            case Py.PAN:
              if (n.enablePan === !1)
                return;
              he(), I = u.TOUCH_PAN;
              break;
            default:
              I = u.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Py.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              Wt(), I = u.TOUCH_DOLLY_PAN;
              break;
            case Py.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              tn(), I = u.TOUCH_DOLLY_ROTATE;
              break;
            default:
              I = u.NONE;
          }
          break;
        default:
          I = u.NONE;
      }
      I !== u.NONE && n.dispatchEvent(o);
    }
    function qn(ye) {
      switch (Ie(ye), I) {
        case u.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          Gt(ye), n.update();
          break;
        case u.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          Rn(ye), n.update();
          break;
        case u.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          Bn(ye), n.update();
          break;
        case u.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          Se(ye), n.update();
          break;
        default:
          I = u.NONE;
      }
    }
    function qt(ye) {
      n.enabled !== !1 && ye.preventDefault();
    }
    function An(ye) {
      J.push(ye);
    }
    function Fe(ye) {
      delete te[ye.pointerId];
      for (let Pe = 0; Pe < J.length; Pe++)
        if (J[Pe].pointerId == ye.pointerId) {
          J.splice(Pe, 1);
          return;
        }
    }
    function Ie(ye) {
      let Pe = te[ye.pointerId];
      Pe === void 0 && (Pe = new sn(), te[ye.pointerId] = Pe), Pe.set(ye.pageX, ye.pageY);
    }
    function at(ye) {
      const Pe = ye.pointerId === J[0].pointerId ? J[1] : J[0];
      return te[Pe.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
};
function cee(a, e, t) {
  const n = Tg((b) => b.size), i = Tg((b) => b.viewport), o = typeof a == "number" ? a : n.width * i.dpr, l = n.height * i.dpr, u = (typeof a == "number" ? t : a) || {}, {
    samples: I = 0,
    depth: f,
    ...h
  } = u, v = xe.useMemo(() => {
    const b = new EC(o, l, {
      minFilter: nl,
      magFilter: nl,
      type: Zb,
      ...h
    });
    return f && (b.depthTexture = new vW(o, l, kg)), b.samples = I, b;
  }, []);
  return xe.useLayoutEffect(() => {
    v.setSize(o, l), I && (v.samples = I);
  }, [I, v, o, l]), xe.useEffect(() => () => v.dispose(), []), v;
}
const gee = (a) => typeof a == "function", dee = /* @__PURE__ */ xe.forwardRef(({
  envMap: a,
  resolution: e = 256,
  frames: t = 1 / 0,
  makeDefault: n,
  children: i,
  ...o
}, l) => {
  const u = Tg(({
    set: x
  }) => x), I = Tg(({
    camera: x
  }) => x), f = Tg(({
    size: x
  }) => x), h = xe.useRef(null);
  xe.useImperativeHandle(l, () => h.current, []);
  const v = xe.useRef(null), b = cee(e);
  xe.useLayoutEffect(() => {
    o.manual || (h.current.aspect = f.width / f.height);
  }, [f, o]), xe.useLayoutEffect(() => {
    h.current.updateProjectionMatrix();
  });
  let S = 0, R = null;
  const W = gee(i);
  return KW((x) => {
    W && (t === 1 / 0 || S < t) && (v.current.visible = !1, x.gl.setRenderTarget(b), R = x.scene.background, a && (x.scene.background = a), x.gl.render(x.scene, h.current), x.scene.background = R, x.gl.setRenderTarget(null), v.current.visible = !0, S++);
  }), xe.useLayoutEffect(() => {
    if (n) {
      const x = I;
      return u(() => ({
        camera: h.current
      })), () => u(() => ({
        camera: x
      }));
    }
  }, [h, n, u]), /* @__PURE__ */ xe.createElement(xe.Fragment, null, /* @__PURE__ */ xe.createElement("perspectiveCamera", sw({
    ref: h
  }, o), !W && i), /* @__PURE__ */ xe.createElement("group", {
    ref: v
  }, W && i(b.texture)));
}), Iee = /* @__PURE__ */ xe.forwardRef(({
  makeDefault: a,
  camera: e,
  regress: t,
  domElement: n,
  enableDamping: i = !0,
  keyEvents: o = !1,
  onChange: l,
  onStart: u,
  onEnd: I,
  ...f
}, h) => {
  const v = Tg((U) => U.invalidate), b = Tg((U) => U.camera), S = Tg((U) => U.gl), R = Tg((U) => U.events), W = Tg((U) => U.setEvents), x = Tg((U) => U.set), M = Tg((U) => U.get), T = Tg((U) => U.performance), E = e || b, _ = n || R.connected || S.domElement, P = xe.useMemo(() => new uee(E), [E]);
  return KW(() => {
    P.enabled && P.update();
  }, -1), xe.useEffect(() => (o && P.connect(o === !0 ? _ : o), P.connect(_), () => void P.dispose()), [o, _, t, P, v]), xe.useEffect(() => {
    const U = (O) => {
      v(), t && T.regress(), l && l(O);
    }, q = (O) => {
      u && u(O);
    }, k = (O) => {
      I && I(O);
    };
    return P.addEventListener("change", U), P.addEventListener("start", q), P.addEventListener("end", k), () => {
      P.removeEventListener("start", q), P.removeEventListener("end", k), P.removeEventListener("change", U);
    };
  }, [l, u, I, P, v, W]), xe.useEffect(() => {
    if (a) {
      const U = M().controls;
      return x({
        controls: P
      }), () => x({
        controls: U
      });
    }
  }, [a, P]), /* @__PURE__ */ xe.createElement("primitive", sw({
    ref: h,
    object: P,
    enableDamping: i
  }, f));
});
function Cee(a, e) {
  const t = a + "Geometry";
  return /* @__PURE__ */ xe.forwardRef(({
    args: n,
    children: i,
    ...o
  }, l) => {
    const u = xe.useRef(null);
    return xe.useImperativeHandle(l, () => u.current), xe.useLayoutEffect(() => void e?.(u.current)), /* @__PURE__ */ xe.createElement("mesh", sw({
      ref: u
    }, o), /* @__PURE__ */ xe.createElement(t, {
      attach: "geometry",
      args: n
    }), i);
  });
}
const hee = /* @__PURE__ */ Cee("box");
var DA = /* @__PURE__ */ ((a) => (a.EN = "en", a.ZH = "zh", a))(DA || {}), Og = /* @__PURE__ */ ((a) => (a.DEFAULT = "default", a.DARK = "dark", a.LIGHT = "light", a))(Og || {}), Yd = /* @__PURE__ */ ((a) => (a.JAN = "Jan.", a.FEB = "Feb.", a.MAR = "Mar.", a.APR = "Apr.", a.MAY = "May.", a.JUN = "Jun.", a.JUL = "Jul.", a.AUG = "Aug.", a.SEP = "Sep.", a.OCT = "Oct.", a.NOV = "Nov.", a.DEC = "Dec.", a))(Yd || {}), ng = /* @__PURE__ */ ((a) => (a.HOME = "/", a.ABOUT = "/about", a.EXPERIENCE = "/experience", a.PROJECTS = "/projects", a.LINKS = "/links", a))(ng || {});
const iB = 575, xw = {
  lang: "randyweb_lang",
  theme: "randyweb_theme"
}, sr = {
  // 語言
  nativeJS: { name: "NativeJS", value: "nativejs" },
  typescript: { name: "TypeScript", value: "typescript" },
  nodeJS: { name: "Node.js", value: "nodejs" },
  python: { name: "Python", value: "python" },
  java: { name: "Java", value: "java" },
  htmlscss: { name: "HTML & SCSS", value: "htmlscss" },
  // 框架
  react: { name: "React", value: "react" },
  next: { name: "Next", value: "next" },
  express: { name: "Express.js", value: "express" },
  tailwind: { name: "TailwindCSS", value: "tailwindcss" },
  // 打包工具
  vite: { name: "Vite", value: "vite" },
  // 測試
  jest: { name: "Jest", value: "jest" },
  e2e: { name: "e2eTesting", value: "e2etesting" },
  // 其他
  webRTC: { name: "WebRTC", value: "webrtc" },
  websocket: { name: "WebSocket", value: "websocket" },
  webAudio: { name: "WebAudio", value: "webaudio" },
  canvas: { name: "Canvas", value: "canvas" },
  glsl: { name: "GLSL", value: "glsl" },
  three: { name: "Three.js", value: "three" },
  i18n: { name: "i18n", value: "i18n" }
}, cY = [
  { url: ng.ABOUT, title: "nav_about" },
  { url: ng.EXPERIENCE, title: "nav_experience" },
  { url: ng.PROJECTS, title: "nav_projects" },
  { url: ng.LINKS, title: "nav_links" }
], z2 = [Og.DEFAULT, Og.DARK, Og.LIGHT], $Z = [DA.EN, DA.ZH], gY = () => {
  const a = window.document.documentElement;
  let e = localStorage.getItem(xw.theme);
  return (!e || !z2.includes(e)) && (e = Og.DEFAULT, localStorage.setItem(xw.theme, e)), a.classList.contains(e) || a.classList.add(e), e;
}, iL = xe.createContext(gY()), rL = xe.createContext({ width: window.innerWidth }), fee = ({ className: a, children: e }) => {
  const [t, n] = xe.useState(gY()), [i, o] = xe.useState({ width: window.innerWidth });
  return xe.useEffect(() => {
    const l = () => {
      o({ width: window.innerWidth });
    };
    return window.addEventListener("resize", l), () => window.removeEventListener("resize", l);
  }, []), xe.useEffect(() => {
    const l = ({ detail: { theme: u } }) => {
      n(u);
    };
    return window.addEventListener("change-theme", l), () => window.removeEventListener("change-theme", l);
  }, []), /* @__PURE__ */ ze.jsx(iL.Provider, { value: t, children: /* @__PURE__ */ ze.jsx(rL.Provider, { value: i, children: /* @__PURE__ */ ze.jsxs("div", { className: "main-layout", children: [
    /* @__PURE__ */ ze.jsx("div", { className: "main-layout_frame" }),
    /* @__PURE__ */ ze.jsx("div", { className: a, children: e })
  ] }) }) });
}, pee = () => ag.useContext(iL), Vb = () => ag.useContext(rL);
var dY = { exports: {} }, PG = typeof Reflect == "object" ? Reflect : null, s3 = PG && typeof PG.apply == "function" ? PG.apply : function(e, t, n) {
  return Function.prototype.apply.call(e, t, n);
}, q1;
PG && typeof PG.ownKeys == "function" ? q1 = PG.ownKeys : Object.getOwnPropertySymbols ? q1 = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : q1 = function(e) {
  return Object.getOwnPropertyNames(e);
};
function mee(a) {
  console && console.warn && console.warn(a);
}
var aL = Number.isNaN || function(e) {
  return e !== e;
};
function wo() {
  wo.init.call(this);
}
dY.exports = wo;
dY.exports.once = bee;
wo.EventEmitter = wo;
wo.prototype._events = void 0;
wo.prototype._eventsCount = 0;
wo.prototype._maxListeners = void 0;
var l3 = 10;
function LW(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(wo, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return l3;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || aL(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    l3 = a;
  }
});
wo.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
wo.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || aL(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function oL(a) {
  return a._maxListeners === void 0 ? wo.defaultMaxListeners : a._maxListeners;
}
wo.prototype.getMaxListeners = function() {
  return oL(this);
};
wo.prototype.emit = function(e) {
  for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
  var i = e === "error", o = this._events;
  if (o !== void 0)
    i = i && o.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var l;
    if (t.length > 0 && (l = t[0]), l instanceof Error)
      throw l;
    var u = new Error("Unhandled error." + (l ? " (" + l.message + ")" : ""));
    throw u.context = l, u;
  }
  var I = o[e];
  if (I === void 0)
    return !1;
  if (typeof I == "function")
    s3(I, this, t);
  else
    for (var f = I.length, h = gL(I, f), n = 0; n < f; ++n)
      s3(h[n], this, t);
  return !0;
};
function sL(a, e, t, n) {
  var i, o, l;
  if (LW(t), o = a._events, o === void 0 ? (o = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (o.newListener !== void 0 && (a.emit(
    "newListener",
    e,
    t.listener ? t.listener : t
  ), o = a._events), l = o[e]), l === void 0)
    l = o[e] = t, ++a._eventsCount;
  else if (typeof l == "function" ? l = o[e] = n ? [t, l] : [l, t] : n ? l.unshift(t) : l.push(t), i = oL(a), i > 0 && l.length > i && !l.warned) {
    l.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + l.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = a, u.type = e, u.count = l.length, mee(u);
  }
  return a;
}
wo.prototype.addListener = function(e, t) {
  return sL(this, e, t, !1);
};
wo.prototype.on = wo.prototype.addListener;
wo.prototype.prependListener = function(e, t) {
  return sL(this, e, t, !0);
};
function Aee() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function lL(a, e, t) {
  var n = { fired: !1, wrapFn: void 0, target: a, type: e, listener: t }, i = Aee.bind(n);
  return i.listener = t, n.wrapFn = i, i;
}
wo.prototype.once = function(e, t) {
  return LW(t), this.on(e, lL(this, e, t)), this;
};
wo.prototype.prependOnceListener = function(e, t) {
  return LW(t), this.prependListener(e, lL(this, e, t)), this;
};
wo.prototype.removeListener = function(e, t) {
  var n, i, o, l, u;
  if (LW(t), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === t || n.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
  else if (typeof n != "function") {
    for (o = -1, l = n.length - 1; l >= 0; l--)
      if (n[l] === t || n[l].listener === t) {
        u = n[l].listener, o = l;
        break;
      }
    if (o < 0)
      return this;
    o === 0 ? n.shift() : vee(n, o), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, u || t);
  }
  return this;
};
wo.prototype.off = wo.prototype.removeListener;
wo.prototype.removeAllListeners = function(e) {
  var t, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var o = Object.keys(n), l;
    for (i = 0; i < o.length; ++i)
      l = o[i], l !== "removeListener" && this.removeAllListeners(l);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = n[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (i = t.length - 1; i >= 0; i--)
      this.removeListener(e, t[i]);
  return this;
};
function uL(a, e, t) {
  var n = a._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? yee(i) : gL(i, i.length);
}
wo.prototype.listeners = function(e) {
  return uL(this, e, !0);
};
wo.prototype.rawListeners = function(e) {
  return uL(this, e, !1);
};
wo.listenerCount = function(a, e) {
  return typeof a.listenerCount == "function" ? a.listenerCount(e) : cL.call(a, e);
};
wo.prototype.listenerCount = cL;
function cL(a) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[a];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
wo.prototype.eventNames = function() {
  return this._eventsCount > 0 ? q1(this._events) : [];
};
function gL(a, e) {
  for (var t = new Array(e), n = 0; n < e; ++n)
    t[n] = a[n];
  return t;
}
function vee(a, e) {
  for (; e + 1 < a.length; e++)
    a[e] = a[e + 1];
  a.pop();
}
function yee(a) {
  for (var e = new Array(a.length), t = 0; t < e.length; ++t)
    e[t] = a[t].listener || a[t];
  return e;
}
function bee(a, e) {
  return new Promise(function(t, n) {
    function i(l) {
      a.removeListener(e, o), n(l);
    }
    function o() {
      typeof a.removeListener == "function" && a.removeListener("error", i), t([].slice.call(arguments));
    }
    dL(a, e, o, { once: !0 }), e !== "error" && Gee(a, i, { once: !0 });
  });
}
function Gee(a, e, t) {
  typeof a.on == "function" && dL(a, "error", e, t);
}
function dL(a, e, t, n) {
  if (typeof a.on == "function")
    n.once ? a.once(e, t) : a.on(e, t);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(e, function i(o) {
      n.once && a.removeEventListener(e, i), t(o);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var Bee = dY.exports;
function See(a, e) {
  var t = atob(a);
  return t;
}
function Zee(a, e, t) {
  var n = See(a), i = n.indexOf(`
`, 10) + 1, o = n.substring(i) + "", l = new Blob([o], { type: "application/javascript" });
  return URL.createObjectURL(l);
}
function wee(a, e, t) {
  var n;
  return function(o) {
    return n = n || Zee(a), new Worker(n, o);
  };
}
var Ree = wee("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogUmVjb3JkcyB3aGF0IG9iamVjdHMgYXJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXIKICAgKi8KCiAgLyoqCiAgICogQSAzeDMgbWF0cml4LgogICAqIEF1dGhvcmVkIGJ5IHtAbGluayBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS8gc2NodGVwcGV9CiAgICovCiAgY2xhc3MgTWF0MyB7CiAgICAvKioKICAgICAqIEEgdmVjdG9yIG9mIGxlbmd0aCA5LCBjb250YWluaW5nIGFsbCBtYXRyaXggZWxlbWVudHMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEBwYXJhbSBlbGVtZW50cyBBIHZlY3RvciBvZiBsZW5ndGggOSwgY29udGFpbmluZyBhbGwgbWF0cml4IGVsZW1lbnRzLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykgewogICAgICBpZiAoZWxlbWVudHMgPT09IHZvaWQgMCkgewogICAgICAgIGVsZW1lbnRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdOwogICAgICB9CgogICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdGhlIG1hdHJpeCB0byBpZGVudGl0eQogICAgICogQHRvZG8gU2hvdWxkIHBlcmhhcHMgYmUgcmVuYW1lZCB0byBgc2V0SWRlbnRpdHkoKWAgdG8gYmUgbW9yZSBjbGVhci4KICAgICAqIEB0b2RvIENyZWF0ZSBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgaW1tZWRpYXRlbHkgY3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXggZWcuIGBleWUoKWAKICAgICAqLwoKCiAgICBpZGVudGl0eSgpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGVbMF0gPSAxOwogICAgICBlWzFdID0gMDsKICAgICAgZVsyXSA9IDA7CiAgICAgIGVbM10gPSAwOwogICAgICBlWzRdID0gMTsKICAgICAgZVs1XSA9IDA7CiAgICAgIGVbNl0gPSAwOwogICAgICBlWzddID0gMDsKICAgICAgZVs4XSA9IDE7CiAgICB9CiAgICAvKioKICAgICAqIFNldCBhbGwgZWxlbWVudHMgdG8gemVybwogICAgICovCgoKICAgIHNldFplcm8oKSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzOwogICAgICBlWzBdID0gMDsKICAgICAgZVsxXSA9IDA7CiAgICAgIGVbMl0gPSAwOwogICAgICBlWzNdID0gMDsKICAgICAgZVs0XSA9IDA7CiAgICAgIGVbNV0gPSAwOwogICAgICBlWzZdID0gMDsKICAgICAgZVs3XSA9IDA7CiAgICAgIGVbOF0gPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHMgZnJvbSBhIFZlYzMKICAgICAqLwoKCiAgICBzZXRUcmFjZSh2ZWN0b3IpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGVbMF0gPSB2ZWN0b3IueDsKICAgICAgZVs0XSA9IHZlY3Rvci55OwogICAgICBlWzhdID0gdmVjdG9yLno7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIG1hdHJpeCBkaWFnb25hbCBlbGVtZW50cwogICAgICovCgoKICAgIGdldFRyYWNlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgdGFyZ2V0LnggPSBlWzBdOwogICAgICB0YXJnZXQueSA9IGVbNF07CiAgICAgIHRhcmdldC56ID0gZVs4XTsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTWF0cml4LVZlY3RvciBtdWx0aXBsaWNhdGlvbgogICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLCB0YXJnZXQgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLgogICAgICovCgoKICAgIHZtdWx0KHYsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgY29uc3QgeCA9IHYueDsKICAgICAgY29uc3QgeSA9IHYueTsKICAgICAgY29uc3QgeiA9IHYuejsKICAgICAgdGFyZ2V0LnggPSBlWzBdICogeCArIGVbMV0gKiB5ICsgZVsyXSAqIHo7CiAgICAgIHRhcmdldC55ID0gZVszXSAqIHggKyBlWzRdICogeSArIGVbNV0gKiB6OwogICAgICB0YXJnZXQueiA9IGVbNl0gKiB4ICsgZVs3XSAqIHkgKyBlWzhdICogejsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTWF0cml4LXNjYWxhciBtdWx0aXBsaWNhdGlvbgogICAgICovCgoKICAgIHNtdWx0KHMpIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSAqPSBzOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIE1hdHJpeCBtdWx0aXBsaWNhdGlvbgogICAgICogQHBhcmFtIG1hdHJpeCBNYXRyaXggdG8gbXVsdGlwbHkgd2l0aCBmcm9tIGxlZnQgc2lkZS4KICAgICAqLwoKCiAgICBtbXVsdChtYXRyaXgsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgTWF0MygpOwogICAgICB9CgogICAgICBjb25zdCBBID0gdGhpcy5lbGVtZW50czsKICAgICAgY29uc3QgQiA9IG1hdHJpeC5lbGVtZW50czsKICAgICAgY29uc3QgVCA9IHRhcmdldC5lbGVtZW50czsKICAgICAgY29uc3QgYTExID0gQVswXSwKICAgICAgICAgICAgYTEyID0gQVsxXSwKICAgICAgICAgICAgYTEzID0gQVsyXSwKICAgICAgICAgICAgYTIxID0gQVszXSwKICAgICAgICAgICAgYTIyID0gQVs0XSwKICAgICAgICAgICAgYTIzID0gQVs1XSwKICAgICAgICAgICAgYTMxID0gQVs2XSwKICAgICAgICAgICAgYTMyID0gQVs3XSwKICAgICAgICAgICAgYTMzID0gQVs4XTsKICAgICAgY29uc3QgYjExID0gQlswXSwKICAgICAgICAgICAgYjEyID0gQlsxXSwKICAgICAgICAgICAgYjEzID0gQlsyXSwKICAgICAgICAgICAgYjIxID0gQlszXSwKICAgICAgICAgICAgYjIyID0gQls0XSwKICAgICAgICAgICAgYjIzID0gQls1XSwKICAgICAgICAgICAgYjMxID0gQls2XSwKICAgICAgICAgICAgYjMyID0gQls3XSwKICAgICAgICAgICAgYjMzID0gQls4XTsKICAgICAgVFswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTsKICAgICAgVFsxXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjsKICAgICAgVFsyXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMzsKICAgICAgVFszXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTsKICAgICAgVFs0XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMjsKICAgICAgVFs1XSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMzsKICAgICAgVFs2XSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMTsKICAgICAgVFs3XSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjsKICAgICAgVFs4XSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMzsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogU2NhbGUgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeAogICAgICovCgoKICAgIHNjYWxlKHZlY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBNYXQzKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzOwogICAgICBjb25zdCB0ID0gdGFyZ2V0LmVsZW1lbnRzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDM7IGkrKykgewogICAgICAgIHRbMyAqIGkgKyAwXSA9IHZlY3Rvci54ICogZVszICogaSArIDBdOwogICAgICAgIHRbMyAqIGkgKyAxXSA9IHZlY3Rvci55ICogZVszICogaSArIDFdOwogICAgICAgIHRbMyAqIGkgKyAyXSA9IHZlY3Rvci56ICogZVszICogaSArIDJdOwogICAgICB9CgogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTb2x2ZSBBeD1iCiAgICAgKiBAcGFyYW0gYiBUaGUgcmlnaHQgaGFuZCBzaWRlCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdmVjdG9yIHRvIHNhdmUgaW4uCiAgICAgKiBAcmV0dXJuIFRoZSBzb2x1dGlvbiB4CiAgICAgKiBAdG9kbyBzaG91bGQgcmV1c2UgYXJyYXlzCiAgICAgKi8KCgogICAgc29sdmUoYiwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnMKICAgICAgY29uc3QgbnIgPSAzOyAvLyBudW0gcm93cwoKICAgICAgY29uc3QgbmMgPSA0OyAvLyBudW0gY29scwoKICAgICAgY29uc3QgZXFucyA9IFtdOwogICAgICBsZXQgaTsKICAgICAgbGV0IGo7CgogICAgICBmb3IgKGkgPSAwOyBpIDwgbnIgKiBuYzsgaSsrKSB7CiAgICAgICAgZXFucy5wdXNoKDApOwogICAgICB9CgogICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7CiAgICAgICAgZm9yIChqID0gMDsgaiA8IDM7IGorKykgewogICAgICAgICAgZXFuc1tpICsgbmMgKiBqXSA9IHRoaXMuZWxlbWVudHNbaSArIDMgKiBqXTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGVxbnNbMyArIDQgKiAwXSA9IGIueDsKICAgICAgZXFuc1szICsgNCAqIDFdID0gYi55OwogICAgICBlcW5zWzMgKyA0ICogMl0gPSBiLno7IC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvbgoKICAgICAgbGV0IG4gPSAzOwogICAgICBjb25zdCBrID0gbjsKICAgICAgbGV0IG5wOwogICAgICBjb25zdCBrcCA9IDQ7IC8vIG51bSByb3dzCgogICAgICBsZXQgcDsKCiAgICAgIGRvIHsKICAgICAgICBpID0gayAtIG47CgogICAgICAgIGlmIChlcW5zW2kgKyBuYyAqIGldID09PSAwKSB7CiAgICAgICAgICAvLyB0aGUgcGl2b3QgaXMgbnVsbCwgc3dhcCBsaW5lcwogICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHsKICAgICAgICAgICAgaWYgKGVxbnNbaSArIG5jICogal0gIT09IDApIHsKICAgICAgICAgICAgICBucCA9IGtwOwoKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAvLyBkbyBsaWduZSggaSApID0gbGlnbmUoIGkgKSArIGxpZ25lKCBrICkKICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wOwogICAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBpXSArPSBlcW5zW3AgKyBuYyAqIGpdOwogICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApOwoKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKGVxbnNbaSArIG5jICogaV0gIT09IDApIHsKICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7CiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBlcW5zW2kgKyBuYyAqIGpdIC8gZXFuc1tpICsgbmMgKiBpXTsKICAgICAgICAgICAgbnAgPSBrcDsKCiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAvLyBkbyBsaWduZSggayApID0gbGlnbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaWduZSggaSApCiAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7CiAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3AgKyBuYyAqIGpdIC0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSB3aGlsZSAoLS1uKTsgLy8gR2V0IHRoZSBzb2x1dGlvbgoKCiAgICAgIHRhcmdldC56ID0gZXFuc1syICogbmMgKyAzXSAvIGVxbnNbMiAqIG5jICsgMl07CiAgICAgIHRhcmdldC55ID0gKGVxbnNbMSAqIG5jICsgM10gLSBlcW5zWzEgKiBuYyArIDJdICogdGFyZ2V0LnopIC8gZXFuc1sxICogbmMgKyAxXTsKICAgICAgdGFyZ2V0LnggPSAoZXFuc1swICogbmMgKyAzXSAtIGVxbnNbMCAqIG5jICsgMl0gKiB0YXJnZXQueiAtIGVxbnNbMCAqIG5jICsgMV0gKiB0YXJnZXQueSkgLyBlcW5zWzAgKiBuYyArIDBdOwoKICAgICAgaWYgKGlzTmFOKHRhcmdldC54KSB8fCBpc05hTih0YXJnZXQueSkgfHwgaXNOYU4odGFyZ2V0LnopIHx8IHRhcmdldC54ID09PSBJbmZpbml0eSB8fCB0YXJnZXQueSA9PT0gSW5maW5pdHkgfHwgdGFyZ2V0LnogPT09IEluZmluaXR5KSB7CiAgICAgICAgdGhyb3cgYENvdWxkIG5vdCBzb2x2ZSBlcXVhdGlvbiEgR290IHg9WyR7dGFyZ2V0LnRvU3RyaW5nKCl9XSwgYj1bJHtiLnRvU3RyaW5nKCl9XSwgQT1bJHt0aGlzLnRvU3RyaW5nKCl9XWA7CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBlbGVtZW50IGluIHRoZSBtYXRyaXggYnkgaW5kZXguIEluZGV4IHN0YXJ0cyBhdCAwLCBub3QgMSEhIQogICAgICogQHBhcmFtIHZhbHVlIElmIHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnQgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS4KICAgICAqLwoKCiAgICBlKHJvdywgY29sdW1uLCB2YWx1ZSkgewogICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgewogICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW2NvbHVtbiArIDMgKiByb3ddOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFNldCB2YWx1ZQogICAgICAgIHRoaXMuZWxlbWVudHNbY29sdW1uICsgMyAqIHJvd10gPSB2YWx1ZTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDb3B5IGFub3RoZXIgbWF0cml4IGludG8gdGhpcyBtYXRyaXggb2JqZWN0LgogICAgICovCgoKICAgIGNvcHkobWF0cml4KSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IG1hdHJpeC5lbGVtZW50c1tpXTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeC4KICAgICAqLwoKCiAgICB0b1N0cmluZygpIHsKICAgICAgbGV0IHIgPSAnJzsKICAgICAgY29uc3Qgc2VwID0gJywnOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHsKICAgICAgICByICs9IHRoaXMuZWxlbWVudHNbaV0gKyBzZXA7CiAgICAgIH0KCiAgICAgIHJldHVybiByOwogICAgfQogICAgLyoqCiAgICAgKiByZXZlcnNlIHRoZSBtYXRyaXgKICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IG1hdHJpeCB0byBzYXZlIGluLgogICAgICogQHJldHVybiBUaGUgc29sdXRpb24geAogICAgICovCgoKICAgIHJldmVyc2UodGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBNYXQzKCk7CiAgICAgIH0KCiAgICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnMKICAgICAgY29uc3QgbnIgPSAzOyAvLyBudW0gcm93cwoKICAgICAgY29uc3QgbmMgPSA2OyAvLyBudW0gY29scwoKICAgICAgY29uc3QgZXFucyA9IHJldmVyc2VfZXFuczsKICAgICAgbGV0IGk7CiAgICAgIGxldCBqOwoKICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykgewogICAgICAgIGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHsKICAgICAgICAgIGVxbnNbaSArIG5jICogal0gPSB0aGlzLmVsZW1lbnRzW2kgKyAzICogal07CiAgICAgICAgfQogICAgICB9CgogICAgICBlcW5zWzMgKyA2ICogMF0gPSAxOwogICAgICBlcW5zWzMgKyA2ICogMV0gPSAwOwogICAgICBlcW5zWzMgKyA2ICogMl0gPSAwOwogICAgICBlcW5zWzQgKyA2ICogMF0gPSAwOwogICAgICBlcW5zWzQgKyA2ICogMV0gPSAxOwogICAgICBlcW5zWzQgKyA2ICogMl0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMF0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMV0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMl0gPSAxOyAvLyBDb21wdXRlIHJpZ2h0IHVwcGVyIHRyaWFuZ3VsYXIgdmVyc2lvbiBvZiB0aGUgbWF0cml4IC0gR2F1c3MgZWxpbWluYXRpb24KCiAgICAgIGxldCBuID0gMzsKICAgICAgY29uc3QgayA9IG47CiAgICAgIGxldCBucDsKICAgICAgY29uc3Qga3AgPSBuYzsgLy8gbnVtIHJvd3MKCiAgICAgIGxldCBwOwoKICAgICAgZG8gewogICAgICAgIGkgPSBrIC0gbjsKCiAgICAgICAgaWYgKGVxbnNbaSArIG5jICogaV0gPT09IDApIHsKICAgICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzCiAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykgewogICAgICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBqXSAhPT0gMCkgewogICAgICAgICAgICAgIG5wID0ga3A7CgogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIC8vIGRvIGxpbmUoIGkgKSA9IGxpbmUoIGkgKSArIGxpbmUoIGsgKQogICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7CiAgICAgICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGldICs9IGVxbnNbcCArIG5jICogal07CiAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CgogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBpXSAhPT0gMCkgewogICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHsKICAgICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldOwogICAgICAgICAgICBucCA9IGtwOwoKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIC8vIGRvIGxpbmUoIGsgKSA9IGxpbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaW5lKCBpICkKICAgICAgICAgICAgICBwID0ga3AgLSBucDsKICAgICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGpdID0gcCA8PSBpID8gMCA6IGVxbnNbcCArIG5jICogal0gLSBlcW5zW3AgKyBuYyAqIGldICogbXVsdGlwbGllcjsKICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IHdoaWxlICgtLW4pOyAvLyBlbGltaW5hdGUgdGhlIHVwcGVyIGxlZnQgdHJpYW5nbGUgb2YgdGhlIG1hdHJpeAoKCiAgICAgIGkgPSAyOwoKICAgICAgZG8gewogICAgICAgIGogPSBpIC0gMTsKCiAgICAgICAgZG8gewogICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldOwogICAgICAgICAgbnAgPSBuYzsKCiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHAgPSBuYyAtIG5wOwogICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGpdID0gZXFuc1twICsgbmMgKiBqXSAtIGVxbnNbcCArIG5jICogaV0gKiBtdWx0aXBsaWVyOwogICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgICAgfSB3aGlsZSAoai0tKTsKICAgICAgfSB3aGlsZSAoLS1pKTsgLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGlhZ29uYWwKCgogICAgICBpID0gMjsKCiAgICAgIGRvIHsKICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gMSAvIGVxbnNbaSArIG5jICogaV07CiAgICAgICAgbnAgPSBuYzsKCiAgICAgICAgZG8gewogICAgICAgICAgcCA9IG5jIC0gbnA7CiAgICAgICAgICBlcW5zW3AgKyBuYyAqIGldID0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7CiAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgIH0gd2hpbGUgKGktLSk7CgogICAgICBpID0gMjsKCiAgICAgIGRvIHsKICAgICAgICBqID0gMjsKCiAgICAgICAgZG8gewogICAgICAgICAgcCA9IGVxbnNbbnIgKyBqICsgbmMgKiBpXTsKCiAgICAgICAgICBpZiAoaXNOYU4ocCkgfHwgcCA9PT0gSW5maW5pdHkpIHsKICAgICAgICAgICAgdGhyb3cgYENvdWxkIG5vdCByZXZlcnNlISBBPVske3RoaXMudG9TdHJpbmcoKX1dYDsKICAgICAgICAgIH0KCiAgICAgICAgICB0YXJnZXQuZShpLCBqLCBwKTsKICAgICAgICB9IHdoaWxlIChqLS0pOwogICAgICB9IHdoaWxlIChpLS0pOwoKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBtYXRyaXggZnJvbSBhIHF1YXRlcmlvbgogICAgICovCgoKICAgIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSkgewogICAgICBjb25zdCB4ID0gcS54OwogICAgICBjb25zdCB5ID0gcS55OwogICAgICBjb25zdCB6ID0gcS56OwogICAgICBjb25zdCB3ID0gcS53OwogICAgICBjb25zdCB4MiA9IHggKyB4OwogICAgICBjb25zdCB5MiA9IHkgKyB5OwogICAgICBjb25zdCB6MiA9IHogKyB6OwogICAgICBjb25zdCB4eCA9IHggKiB4MjsKICAgICAgY29uc3QgeHkgPSB4ICogeTI7CiAgICAgIGNvbnN0IHh6ID0geCAqIHoyOwogICAgICBjb25zdCB5eSA9IHkgKiB5MjsKICAgICAgY29uc3QgeXogPSB5ICogejI7CiAgICAgIGNvbnN0IHp6ID0geiAqIHoyOwogICAgICBjb25zdCB3eCA9IHcgKiB4MjsKICAgICAgY29uc3Qgd3kgPSB3ICogeTI7CiAgICAgIGNvbnN0IHd6ID0gdyAqIHoyOwogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgZVszICogMCArIDBdID0gMSAtICh5eSArIHp6KTsKICAgICAgZVszICogMCArIDFdID0geHkgLSB3ejsKICAgICAgZVszICogMCArIDJdID0geHogKyB3eTsKICAgICAgZVszICogMSArIDBdID0geHkgKyB3ejsKICAgICAgZVszICogMSArIDFdID0gMSAtICh4eCArIHp6KTsKICAgICAgZVszICogMSArIDJdID0geXogLSB3eDsKICAgICAgZVszICogMiArIDBdID0geHogLSB3eTsKICAgICAgZVszICogMiArIDFdID0geXogKyB3eDsKICAgICAgZVszICogMiArIDJdID0gMSAtICh4eCArIHl5KTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFRyYW5zcG9zZSB0aGUgbWF0cml4CiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLiBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0LgogICAgICogQHJldHVybiBUaGUgdGFyZ2V0IE1hdDMsIG9yIGEgbmV3IE1hdDMgaWYgdGFyZ2V0IHdhcyBvbWl0dGVkLgogICAgICovCgoKICAgIHRyYW5zcG9zZSh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IE1hdDMoKTsKICAgICAgfQoKICAgICAgY29uc3QgTSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGNvbnN0IFQgPSB0YXJnZXQuZWxlbWVudHM7CiAgICAgIGxldCB0bXA7IC8vU2V0IGRpYWdvbmFscwoKICAgICAgVFswXSA9IE1bMF07CiAgICAgIFRbNF0gPSBNWzRdOwogICAgICBUWzhdID0gTVs4XTsKICAgICAgdG1wID0gTVsxXTsKICAgICAgVFsxXSA9IE1bM107CiAgICAgIFRbM10gPSB0bXA7CiAgICAgIHRtcCA9IE1bMl07CiAgICAgIFRbMl0gPSBNWzZdOwogICAgICBUWzZdID0gdG1wOwogICAgICB0bXAgPSBNWzVdOwogICAgICBUWzVdID0gTVs3XTsKICAgICAgVFs3XSA9IHRtcDsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KCiAgfQogIGNvbnN0IHJldmVyc2VfZXFucyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTsKCiAgLyoqCiAgICogMy1kaW1lbnNpb25hbCB2ZWN0b3IKICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCB2ID0gbmV3IFZlYzMoMSwgMiwgMykKICAgKiAgICAgY29uc29sZS5sb2coJ3g9JyArIHYueCkgLy8geD0xCiAgICovCgogIGNsYXNzIFZlYzMgewogICAgY29uc3RydWN0b3IoeCwgeSwgeikgewogICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7CiAgICAgICAgeCA9IDAuMDsKICAgICAgfQoKICAgICAgaWYgKHkgPT09IHZvaWQgMCkgewogICAgICAgIHkgPSAwLjA7CiAgICAgIH0KCiAgICAgIGlmICh6ID09PSB2b2lkIDApIHsKICAgICAgICB6ID0gMC4wOwogICAgICB9CgogICAgICB0aGlzLnggPSB4OwogICAgICB0aGlzLnkgPSB5OwogICAgICB0aGlzLnogPSB6OwogICAgfQogICAgLyoqCiAgICAgKiBWZWN0b3IgY3Jvc3MgcHJvZHVjdAogICAgICogQHBhcmFtIHRhcmdldCBPcHRpb25hbCB0YXJnZXQgdG8gc2F2ZSBpbi4KICAgICAqLwoKCiAgICBjcm9zcyh2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB2eCA9IHZlY3Rvci54OwogICAgICBjb25zdCB2eSA9IHZlY3Rvci55OwogICAgICBjb25zdCB2eiA9IHZlY3Rvci56OwogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICB0YXJnZXQueCA9IHkgKiB2eiAtIHogKiB2eTsKICAgICAgdGFyZ2V0LnkgPSB6ICogdnggLSB4ICogdno7CiAgICAgIHRhcmdldC56ID0geCAqIHZ5IC0geSAqIHZ4OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHZlY3RvcnMnIDMgZWxlbWVudHMKICAgICAqLwoKCiAgICBzZXQoeCwgeSwgeikgewogICAgICB0aGlzLnggPSB4OwogICAgICB0aGlzLnkgPSB5OwogICAgICB0aGlzLnogPSB6OwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogU2V0IGFsbCBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3IgdG8gemVyby4KICAgICAqLwoKCiAgICBzZXRaZXJvKCkgewogICAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLnogPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBWZWN0b3IgYWRkaXRpb24KICAgICAqLwoKCiAgICB2YWRkKHZlY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQpIHsKICAgICAgICB0YXJnZXQueCA9IHZlY3Rvci54ICsgdGhpcy54OwogICAgICAgIHRhcmdldC55ID0gdmVjdG9yLnkgKyB0aGlzLnk7CiAgICAgICAgdGFyZ2V0LnogPSB2ZWN0b3IueiArIHRoaXMuejsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54ICsgdmVjdG9yLngsIHRoaXMueSArIHZlY3Rvci55LCB0aGlzLnogKyB2ZWN0b3Iueik7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVmVjdG9yIHN1YnRyYWN0aW9uCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluLgogICAgICovCgoKICAgIHZzdWIodmVjdG9yLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCkgewogICAgICAgIHRhcmdldC54ID0gdGhpcy54IC0gdmVjdG9yLng7CiAgICAgICAgdGFyZ2V0LnkgPSB0aGlzLnkgLSB2ZWN0b3IueTsKICAgICAgICB0YXJnZXQueiA9IHRoaXMueiAtIHZlY3Rvci56OwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggLSB2ZWN0b3IueCwgdGhpcy55IC0gdmVjdG9yLnksIHRoaXMueiAtIHZlY3Rvci56KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGNyb3NzIHByb2R1Y3QgbWF0cml4IGFfY3Jvc3MgZnJvbSBhIHZlY3Rvciwgc3VjaCB0aGF0IGEgeCBiID0gYV9jcm9zcyAqIGIgPSBjCiAgICAgKgogICAgICogU2VlIHtAbGluayBodHRwczovL3d3dzguY3MudW11LnNlL2t1cnNlci9UREJEMjQvVlQwNi9sZWN0dXJlcy9MZWN0dXJlNi5wZGYgVW1lw6UgVW5pdmVyc2l0eSBMZWN0dXJlfQogICAgICovCgoKICAgIGNyb3NzbWF0KCkgewogICAgICByZXR1cm4gbmV3IE1hdDMoWzAsIC10aGlzLnosIHRoaXMueSwgdGhpcy56LCAwLCAtdGhpcy54LCAtdGhpcy55LCB0aGlzLngsIDBdKTsKICAgIH0KICAgIC8qKgogICAgICogTm9ybWFsaXplIHRoZSB2ZWN0b3IuIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHZhbHVlcyBpbiB0aGUgdmVjdG9yLgogICAgICAqIEByZXR1cm4gUmV0dXJucyB0aGUgbm9ybSBvZiB0aGUgdmVjdG9yCiAgICAgKi8KCgogICAgbm9ybWFsaXplKCkgewogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7CgogICAgICBpZiAobiA+IDAuMCkgewogICAgICAgIGNvbnN0IGludk4gPSAxIC8gbjsKICAgICAgICB0aGlzLnggKj0gaW52TjsKICAgICAgICB0aGlzLnkgKj0gaW52TjsKICAgICAgICB0aGlzLnogKj0gaW52TjsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBNYWtlIHNvbWV0aGluZyB1cAogICAgICAgIHRoaXMueCA9IDA7CiAgICAgICAgdGhpcy55ID0gMDsKICAgICAgICB0aGlzLnogPSAwOwogICAgICB9CgogICAgICByZXR1cm4gbjsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHRoYXQgaXMgb2YgbGVuZ3RoIDEuCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluCiAgICAgKiBAcmV0dXJuIFJldHVybnMgdGhlIHVuaXQgdmVjdG9yCiAgICAgKi8KCgogICAgdW5pdCh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgY29uc3QgeCA9IHRoaXMueDsKICAgICAgY29uc3QgeSA9IHRoaXMueTsKICAgICAgY29uc3QgeiA9IHRoaXMuejsKICAgICAgbGV0IG5pbnYgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTsKCiAgICAgIGlmIChuaW52ID4gMC4wKSB7CiAgICAgICAgbmludiA9IDEuMCAvIG5pbnY7CiAgICAgICAgdGFyZ2V0LnggPSB4ICogbmludjsKICAgICAgICB0YXJnZXQueSA9IHkgKiBuaW52OwogICAgICAgIHRhcmdldC56ID0geiAqIG5pbnY7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGFyZ2V0LnggPSAxOwogICAgICAgIHRhcmdldC55ID0gMDsKICAgICAgICB0YXJnZXQueiA9IDA7CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IKICAgICAqLwoKCiAgICBsZW5ndGgoKSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGUgdmVjdG9yLgogICAgICovCgoKICAgIGxlbmd0aFNxdWFyZWQoKSB7CiAgICAgIHJldHVybiB0aGlzLmRvdCh0aGlzKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50CiAgICAgKi8KCgogICAgZGlzdGFuY2VUbyhwKSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIGNvbnN0IHB4ID0gcC54OwogICAgICBjb25zdCBweSA9IHAueTsKICAgICAgY29uc3QgcHogPSBwLno7CiAgICAgIHJldHVybiBNYXRoLnNxcnQoKHB4IC0geCkgKiAocHggLSB4KSArIChweSAtIHkpICogKHB5IC0geSkgKyAocHogLSB6KSAqIChweiAtIHopKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnQKICAgICAqLwoKCiAgICBkaXN0YW5jZVNxdWFyZWQocCkgewogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCBweCA9IHAueDsKICAgICAgY29uc3QgcHkgPSBwLnk7CiAgICAgIGNvbnN0IHB6ID0gcC56OwogICAgICByZXR1cm4gKHB4IC0geCkgKiAocHggLSB4KSArIChweSAtIHkpICogKHB5IC0geSkgKyAocHogLSB6KSAqIChweiAtIHopOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSBhbGwgdGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB3aXRoIGEgc2NhbGFyLgogICAgICogQHBhcmFtIHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBzY2FsZShzY2FsYXIsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICB0YXJnZXQueCA9IHNjYWxhciAqIHg7CiAgICAgIHRhcmdldC55ID0gc2NhbGFyICogeTsKICAgICAgdGFyZ2V0LnogPSBzY2FsYXIgKiB6OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB0aGUgdmVjdG9yIHdpdGggYW4gb3RoZXIgdmVjdG9yLCBjb21wb25lbnQtd2lzZS4KICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uCiAgICAgKi8KCgogICAgdm11bCh2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IHZlY3Rvci54ICogdGhpcy54OwogICAgICB0YXJnZXQueSA9IHZlY3Rvci55ICogdGhpcy55OwogICAgICB0YXJnZXQueiA9IHZlY3Rvci56ICogdGhpcy56OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTY2FsZSBhIHZlY3RvciBhbmQgYWRkIGl0IHRvIHRoaXMgdmVjdG9yLiBTYXZlIHRoZSByZXN1bHQgaW4gInRhcmdldCIuICh0YXJnZXQgPSB0aGlzICsgdmVjdG9yICogc2NhbGFyKQogICAgICogQHBhcmFtIHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBhZGRTY2FsZWRWZWN0b3Ioc2NhbGFyLCB2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IHRoaXMueCArIHNjYWxhciAqIHZlY3Rvci54OwogICAgICB0YXJnZXQueSA9IHRoaXMueSArIHNjYWxhciAqIHZlY3Rvci55OwogICAgICB0YXJnZXQueiA9IHRoaXMueiArIHNjYWxhciAqIHZlY3Rvci56OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBDYWxjdWxhdGUgZG90IHByb2R1Y3QKICAgICAqIEBwYXJhbSB2ZWN0b3IKICAgICAqLwoKCiAgICBkb3QodmVjdG9yKSB7CiAgICAgIHJldHVybiB0aGlzLnggKiB2ZWN0b3IueCArIHRoaXMueSAqIHZlY3Rvci55ICsgdGhpcy56ICogdmVjdG9yLno7CiAgICB9CgogICAgaXNaZXJvKCkgewogICAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMCAmJiB0aGlzLnogPT09IDA7CiAgICB9CiAgICAvKioKICAgICAqIE1ha2UgdGhlIHZlY3RvciBwb2ludCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLgogICAgICogQHBhcmFtIHRhcmdldCBPcHRpb25hbCB0YXJnZXQgdG8gc2F2ZSBpbgogICAgICovCgoKICAgIG5lZ2F0ZSh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnggPSAtdGhpcy54OwogICAgICB0YXJnZXQueSA9IC10aGlzLnk7CiAgICAgIHRhcmdldC56ID0gLXRoaXMuejsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0d28gYXJ0aWZpY2lhbCB0YW5nZW50cyB0byB0aGUgdmVjdG9yCiAgICAgKiBAcGFyYW0gdDEgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBmaXJzdCB0YW5nZW50IGluCiAgICAgKiBAcGFyYW0gdDIgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBzZWNvbmQgdGFuZ2VudCBpbgogICAgICovCgoKICAgIHRhbmdlbnRzKHQxLCB0MikgewogICAgICBjb25zdCBub3JtID0gdGhpcy5sZW5ndGgoKTsKCiAgICAgIGlmIChub3JtID4gMC4wKSB7CiAgICAgICAgY29uc3QgbiA9IFZlYzNfdGFuZ2VudHNfbjsKICAgICAgICBjb25zdCBpbm9ybSA9IDEgLyBub3JtOwogICAgICAgIG4uc2V0KHRoaXMueCAqIGlub3JtLCB0aGlzLnkgKiBpbm9ybSwgdGhpcy56ICogaW5vcm0pOwogICAgICAgIGNvbnN0IHJhbmRWZWMgPSBWZWMzX3RhbmdlbnRzX3JhbmRWZWM7CgogICAgICAgIGlmIChNYXRoLmFicyhuLngpIDwgMC45KSB7CiAgICAgICAgICByYW5kVmVjLnNldCgxLCAwLCAwKTsKICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByYW5kVmVjLnNldCgwLCAxLCAwKTsKICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpOwogICAgICAgIH0KCiAgICAgICAgbi5jcm9zcyh0MSwgdDIpOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRoZSBub3JtYWwgbGVuZ3RoIGlzIHplcm8sIG1ha2Ugc29tZXRoaW5nIHVwCiAgICAgICAgdDEuc2V0KDEsIDAsIDApOwogICAgICAgIHQyLnNldCgwLCAxLCAwKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyB0byBhIG1vcmUgcmVhZGFibGUgZm9ybWF0CiAgICAgKi8KCgogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLnh9LCR7dGhpcy55fSwke3RoaXMuen1gOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyB0byBhbiBhcnJheQogICAgICovCgoKICAgIHRvQXJyYXkoKSB7CiAgICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07CiAgICB9CiAgICAvKioKICAgICAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyB2ZWN0b3IuCiAgICAgKi8KCgogICAgY29weSh2ZWN0b3IpIHsKICAgICAgdGhpcy54ID0gdmVjdG9yLng7CiAgICAgIHRoaXMueSA9IHZlY3Rvci55OwogICAgICB0aGlzLnogPSB2ZWN0b3IuejsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9ycwogICAgICogQHBhcmFtIHQgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiAwIHdpbGwgbWFrZSB0aGlzIGZ1bmN0aW9uIHJldHVybiB1LCBhbmQgMSB3aWxsIG1ha2UgaXQgcmV0dXJuIHYuIE51bWJlcnMgaW4gYmV0d2VlbiB3aWxsIGdlbmVyYXRlIGEgdmVjdG9yIGluIGJldHdlZW4gdGhlbS4KICAgICAqLwoKCiAgICBsZXJwKHZlY3RvciwgdCwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIHRhcmdldC54ID0geCArICh2ZWN0b3IueCAtIHgpICogdDsKICAgICAgdGFyZ2V0LnkgPSB5ICsgKHZlY3Rvci55IC0geSkgKiB0OwogICAgICB0YXJnZXQueiA9IHogKyAodmVjdG9yLnogLSB6KSAqIHQ7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGEgdmVjdG9yIGVxdWFscyBpcyBhbG1vc3QgZXF1YWwgdG8gYW5vdGhlciBvbmUuCiAgICAgKi8KCgogICAgYWxtb3N0RXF1YWxzKHZlY3RvciwgcHJlY2lzaW9uKSB7CiAgICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgewogICAgICAgIHByZWNpc2lvbiA9IDFlLTY7CiAgICAgIH0KCiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSB2ZWN0b3IueCkgPiBwcmVjaXNpb24gfHwgTWF0aC5hYnModGhpcy55IC0gdmVjdG9yLnkpID4gcHJlY2lzaW9uIHx8IE1hdGguYWJzKHRoaXMueiAtIHZlY3Rvci56KSA+IHByZWNpc2lvbikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvCiAgICAgKi8KCgogICAgYWxtb3N0WmVybyhwcmVjaXNpb24pIHsKICAgICAgaWYgKHByZWNpc2lvbiA9PT0gdm9pZCAwKSB7CiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjsKICAgICAgfQoKICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCkgPiBwcmVjaXNpb24gfHwgTWF0aC5hYnModGhpcy55KSA+IHByZWNpc2lvbiB8fCBNYXRoLmFicyh0aGlzLnopID4gcHJlY2lzaW9uKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIHZlY3RvciBpcyBhbnRpLXBhcmFsbGVsIHRvIGFub3RoZXIgdmVjdG9yLgogICAgICogQHBhcmFtIHByZWNpc2lvbiBTZXQgdG8gemVybyBmb3IgZXhhY3QgY29tcGFyaXNvbnMKICAgICAqLwoKCiAgICBpc0FudGlwYXJhbGxlbFRvKHZlY3RvciwgcHJlY2lzaW9uKSB7CiAgICAgIHRoaXMubmVnYXRlKGFudGlwX25lZyk7CiAgICAgIHJldHVybiBhbnRpcF9uZWcuYWxtb3N0RXF1YWxzKHZlY3RvciwgcHJlY2lzaW9uKTsKICAgIH0KICAgIC8qKgogICAgICogQ2xvbmUgdGhlIHZlY3RvcgogICAgICovCgoKICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LCB0aGlzLnksIHRoaXMueik7CiAgICB9CgogIH0KICBWZWMzLlpFUk8gPSBuZXcgVmVjMygwLCAwLCAwKTsKICBWZWMzLlVOSVRfWCA9IG5ldyBWZWMzKDEsIDAsIDApOwogIFZlYzMuVU5JVF9ZID0gbmV3IFZlYzMoMCwgMSwgMCk7CiAgVmVjMy5VTklUX1ogPSBuZXcgVmVjMygwLCAwLCAxKTsKICBjb25zdCBWZWMzX3RhbmdlbnRzX24gPSBuZXcgVmVjMygpOwogIGNvbnN0IFZlYzNfdGFuZ2VudHNfcmFuZFZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYW50aXBfbmVnID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy4KICAgKi8KICBjbGFzcyBBQUJCIHsKICAgIC8qKgogICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3gKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3gKICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLmxvd2VyQm91bmQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnVwcGVyQm91bmQgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMubG93ZXJCb3VuZCkgewogICAgICAgIHRoaXMubG93ZXJCb3VuZC5jb3B5KG9wdGlvbnMubG93ZXJCb3VuZCk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLnVwcGVyQm91bmQpIHsKICAgICAgICB0aGlzLnVwcGVyQm91bmQuY29weShvcHRpb25zLnVwcGVyQm91bmQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgQUFCQiBib3VuZHMgZnJvbSBhIHNldCBvZiBwb2ludHMuCiAgICAgKiBAcGFyYW0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMncy4KICAgICAqIEByZXR1cm4gVGhlIHNlbGYgb2JqZWN0CiAgICAgKi8KCgogICAgc2V0RnJvbVBvaW50cyhwb2ludHMsIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBza2luU2l6ZSkgewogICAgICBjb25zdCBsID0gdGhpcy5sb3dlckJvdW5kOwogICAgICBjb25zdCB1ID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBxID0gcXVhdGVybmlvbjsgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludAoKICAgICAgbC5jb3B5KHBvaW50c1swXSk7CgogICAgICBpZiAocSkgewogICAgICAgIHEudm11bHQobCwgbCk7CiAgICAgIH0KCiAgICAgIHUuY29weShsKTsKCiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgbGV0IHAgPSBwb2ludHNbaV07CgogICAgICAgIGlmIChxKSB7CiAgICAgICAgICBxLnZtdWx0KHAsIHRtcCQxKTsKICAgICAgICAgIHAgPSB0bXAkMTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnggPiB1LngpIHsKICAgICAgICAgIHUueCA9IHAueDsKICAgICAgICB9CgogICAgICAgIGlmIChwLnggPCBsLngpIHsKICAgICAgICAgIGwueCA9IHAueDsKICAgICAgICB9CgogICAgICAgIGlmIChwLnkgPiB1LnkpIHsKICAgICAgICAgIHUueSA9IHAueTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnkgPCBsLnkpIHsKICAgICAgICAgIGwueSA9IHAueTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnogPiB1LnopIHsKICAgICAgICAgIHUueiA9IHAuejsKICAgICAgICB9CgogICAgICAgIGlmIChwLnogPCBsLnopIHsKICAgICAgICAgIGwueiA9IHAuejsKICAgICAgICB9CiAgICAgIH0gLy8gQWRkIG9mZnNldAoKCiAgICAgIGlmIChwb3NpdGlvbikgewogICAgICAgIHBvc2l0aW9uLnZhZGQobCwgbCk7CiAgICAgICAgcG9zaXRpb24udmFkZCh1LCB1KTsKICAgICAgfQoKICAgICAgaWYgKHNraW5TaXplKSB7CiAgICAgICAgbC54IC09IHNraW5TaXplOwogICAgICAgIGwueSAtPSBza2luU2l6ZTsKICAgICAgICBsLnogLT0gc2tpblNpemU7CiAgICAgICAgdS54ICs9IHNraW5TaXplOwogICAgICAgIHUueSArPSBza2luU2l6ZTsKICAgICAgICB1LnogKz0gc2tpblNpemU7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCCiAgICAgKiBAcGFyYW0gYWFiYiBTb3VyY2UgdG8gY29weSBmcm9tCiAgICAgKiBAcmV0dXJuIFRoZSB0aGlzIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eQogICAgICovCgoKICAgIGNvcHkoYWFiYikgewogICAgICB0aGlzLmxvd2VyQm91bmQuY29weShhYWJiLmxvd2VyQm91bmQpOwogICAgICB0aGlzLnVwcGVyQm91bmQuY29weShhYWJiLnVwcGVyQm91bmQpOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogQ2xvbmUgYW4gQUFCQgogICAgICovCgoKICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IEFBQkIoKS5jb3B5KHRoaXMpOwogICAgfQogICAgLyoqCiAgICAgKiBFeHRlbmQgdGhpcyBBQUJCIHNvIHRoYXQgaXQgY292ZXJzIHRoZSBnaXZlbiBBQUJCIHRvby4KICAgICAqLwoKCiAgICBleHRlbmQoYWFiYikgewogICAgICB0aGlzLmxvd2VyQm91bmQueCA9IE1hdGgubWluKHRoaXMubG93ZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueCk7CiAgICAgIHRoaXMudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC54KTsKICAgICAgdGhpcy5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueSwgYWFiYi5sb3dlckJvdW5kLnkpOwogICAgICB0aGlzLnVwcGVyQm91bmQueSA9IE1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC55LCBhYWJiLnVwcGVyQm91bmQueSk7CiAgICAgIHRoaXMubG93ZXJCb3VuZC56ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnosIGFhYmIubG93ZXJCb3VuZC56KTsKICAgICAgdGhpcy51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueiwgYWFiYi51cHBlckJvdW5kLnopOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgb3ZlcmxhcHMgdGhpcyBBQUJCLgogICAgICovCgoKICAgIG92ZXJsYXBzKGFhYmIpIHsKICAgICAgY29uc3QgbDEgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUxID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBsMiA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdTIgPSBhYWJiLnVwcGVyQm91bmQ7IC8vICAgICAgbDIgICAgICAgIHUyCiAgICAgIC8vICAgICAgfC0tLS0tLS0tLXwKICAgICAgLy8gfC0tLS0tLS0tfAogICAgICAvLyBsMSAgICAgICB1MQoKICAgICAgY29uc3Qgb3ZlcmxhcHNYID0gbDIueCA8PSB1MS54ICYmIHUxLnggPD0gdTIueCB8fCBsMS54IDw9IHUyLnggJiYgdTIueCA8PSB1MS54OwogICAgICBjb25zdCBvdmVybGFwc1kgPSBsMi55IDw9IHUxLnkgJiYgdTEueSA8PSB1Mi55IHx8IGwxLnkgPD0gdTIueSAmJiB1Mi55IDw9IHUxLnk7CiAgICAgIGNvbnN0IG92ZXJsYXBzWiA9IGwyLnogPD0gdTEueiAmJiB1MS56IDw9IHUyLnogfHwgbDEueiA8PSB1Mi56ICYmIHUyLnogPD0gdTEuejsKICAgICAgcmV0dXJuIG92ZXJsYXBzWCAmJiBvdmVybGFwc1kgJiYgb3ZlcmxhcHNaOwogICAgfSAvLyBNb3N0bHkgZm9yIGRlYnVnZ2luZwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIGNvbnN0IGwgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUgPSB0aGlzLnVwcGVyQm91bmQ7CiAgICAgIHJldHVybiAodS54IC0gbC54KSAqICh1LnkgLSBsLnkpICogKHUueiAtIGwueik7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBpcyBmdWxseSBjb250YWluZWQgaW4gdGhpcyBBQUJCLgogICAgICovCgoKICAgIGNvbnRhaW5zKGFhYmIpIHsKICAgICAgY29uc3QgbDEgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUxID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBsMiA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdTIgPSBhYWJiLnVwcGVyQm91bmQ7IC8vICAgICAgbDIgICAgICAgIHUyCiAgICAgIC8vICAgICAgfC0tLS0tLS0tLXwKICAgICAgLy8gfC0tLS0tLS0tLS0tLS0tLXwKICAgICAgLy8gbDEgICAgICAgICAgICAgIHUxCgogICAgICByZXR1cm4gbDEueCA8PSBsMi54ICYmIHUxLnggPj0gdTIueCAmJiBsMS55IDw9IGwyLnkgJiYgdTEueSA+PSB1Mi55ICYmIGwxLnogPD0gbDIueiAmJiB1MS56ID49IHUyLno7CiAgICB9CgogICAgZ2V0Q29ybmVycyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7CiAgICAgIGNvbnN0IGwgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUgPSB0aGlzLnVwcGVyQm91bmQ7CiAgICAgIGEuY29weShsKTsKICAgICAgYi5zZXQodS54LCBsLnksIGwueik7CiAgICAgIGMuc2V0KHUueCwgdS55LCBsLnopOwogICAgICBkLnNldChsLngsIHUueSwgdS56KTsKICAgICAgZS5zZXQodS54LCBsLnksIHUueik7CiAgICAgIGYuc2V0KGwueCwgdS55LCBsLnopOwogICAgICBnLnNldChsLngsIGwueSwgdS56KTsKICAgICAgaC5jb3B5KHUpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gYW5vdGhlciBmcmFtZS4KICAgICAqIEByZXR1cm4gVGhlICJ0YXJnZXQiIEFBQkIgb2JqZWN0LgogICAgICovCgoKICAgIHRvTG9jYWxGcmFtZShmcmFtZSwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVyczsKICAgICAgY29uc3QgYSA9IGNvcm5lcnNbMF07CiAgICAgIGNvbnN0IGIgPSBjb3JuZXJzWzFdOwogICAgICBjb25zdCBjID0gY29ybmVyc1syXTsKICAgICAgY29uc3QgZCA9IGNvcm5lcnNbM107CiAgICAgIGNvbnN0IGUgPSBjb3JuZXJzWzRdOwogICAgICBjb25zdCBmID0gY29ybmVyc1s1XTsKICAgICAgY29uc3QgZyA9IGNvcm5lcnNbNl07CiAgICAgIGNvbnN0IGggPSBjb3JuZXJzWzddOyAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lCgogICAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7IC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgIGNvbnN0IGNvcm5lciA9IGNvcm5lcnNbaV07CiAgICAgICAgZnJhbWUucG9pbnRUb0xvY2FsKGNvcm5lciwgY29ybmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gdGhlIGdsb2JhbCBmcmFtZS4KICAgICAqIEByZXR1cm4gVGhlICJ0YXJnZXQiIEFBQkIgb2JqZWN0LgogICAgICovCgoKICAgIHRvV29ybGRGcmFtZShmcmFtZSwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVyczsKICAgICAgY29uc3QgYSA9IGNvcm5lcnNbMF07CiAgICAgIGNvbnN0IGIgPSBjb3JuZXJzWzFdOwogICAgICBjb25zdCBjID0gY29ybmVyc1syXTsKICAgICAgY29uc3QgZCA9IGNvcm5lcnNbM107CiAgICAgIGNvbnN0IGUgPSBjb3JuZXJzWzRdOwogICAgICBjb25zdCBmID0gY29ybmVyc1s1XTsKICAgICAgY29uc3QgZyA9IGNvcm5lcnNbNl07CiAgICAgIGNvbnN0IGggPSBjb3JuZXJzWzddOyAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lCgogICAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7IC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgIGNvbnN0IGNvcm5lciA9IGNvcm5lcnNbaV07CiAgICAgICAgZnJhbWUucG9pbnRUb1dvcmxkKGNvcm5lciwgY29ybmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgQUFCQiBpcyBoaXQgYnkgYSByYXkuCiAgICAgKi8KCgogICAgb3ZlcmxhcHNSYXkocmF5KSB7CiAgICAgIGNvbnN0IHsKICAgICAgICBkaXJlY3Rpb24sCiAgICAgICAgZnJvbQogICAgICB9ID0gcmF5OyAvLyBjb25zdCB0ID0gMAogICAgICAvLyByYXkuZGlyZWN0aW9uIGlzIHVuaXQgZGlyZWN0aW9uIHZlY3RvciBvZiByYXkKCiAgICAgIGNvbnN0IGRpckZyYWNYID0gMSAvIGRpcmVjdGlvbi54OwogICAgICBjb25zdCBkaXJGcmFjWSA9IDEgLyBkaXJlY3Rpb24ueTsKICAgICAgY29uc3QgZGlyRnJhY1ogPSAxIC8gZGlyZWN0aW9uLno7IC8vIHRoaXMubG93ZXJCb3VuZCBpcyB0aGUgY29ybmVyIG9mIEFBQkIgd2l0aCBtaW5pbWFsIGNvb3JkaW5hdGVzIC0gbGVmdCBib3R0b20sIHJ0IGlzIG1heGltYWwgY29ybmVyCgogICAgICBjb25zdCB0MSA9ICh0aGlzLmxvd2VyQm91bmQueCAtIGZyb20ueCkgKiBkaXJGcmFjWDsKICAgICAgY29uc3QgdDIgPSAodGhpcy51cHBlckJvdW5kLnggLSBmcm9tLngpICogZGlyRnJhY1g7CiAgICAgIGNvbnN0IHQzID0gKHRoaXMubG93ZXJCb3VuZC55IC0gZnJvbS55KSAqIGRpckZyYWNZOwogICAgICBjb25zdCB0NCA9ICh0aGlzLnVwcGVyQm91bmQueSAtIGZyb20ueSkgKiBkaXJGcmFjWTsKICAgICAgY29uc3QgdDUgPSAodGhpcy5sb3dlckJvdW5kLnogLSBmcm9tLnopICogZGlyRnJhY1o7CiAgICAgIGNvbnN0IHQ2ID0gKHRoaXMudXBwZXJCb3VuZC56IC0gZnJvbS56KSAqIGRpckZyYWNaOyAvLyBjb25zdCB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSkpOwogICAgICAvLyBjb25zdCB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSkpOwoKICAgICAgY29uc3QgdG1pbiA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWluKHQxLCB0MiksIE1hdGgubWluKHQzLCB0NCkpLCBNYXRoLm1pbih0NSwgdDYpKTsKICAgICAgY29uc3QgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpLCBNYXRoLm1heCh0NSwgdDYpKTsgLy8gaWYgdG1heCA8IDAsIHJheSAobGluZSkgaXMgaW50ZXJzZWN0aW5nIEFBQkIsIGJ1dCB3aG9sZSBBQUJCIGlzIGJlaGluZyB1cwoKICAgICAgaWYgKHRtYXggPCAwKSB7CiAgICAgICAgLy90ID0gdG1heDsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gaWYgdG1pbiA+IHRtYXgsIHJheSBkb2Vzbid0IGludGVyc2VjdCBBQUJCCgoKICAgICAgaWYgKHRtaW4gPiB0bWF4KSB7CiAgICAgICAgLy90ID0gdG1heDsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICB9CiAgY29uc3QgdG1wJDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzID0gW25ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCldOwoKICAvKioKICAgKiBDb2xsaXNpb24gIm1hdHJpeCIuCiAgICogSXQncyBhY3R1YWxseSBhIHRyaWFuZ3VsYXItc2hhcGVkIGFycmF5IG9mIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcgdGhpcyBzdGVwLCBmb3IgcmVmZXJlbmNlIG5leHQgc3RlcAogICAqLwogIGNsYXNzIEFycmF5Q29sbGlzaW9uTWF0cml4IHsKICAgIC8qKgogICAgICogVGhlIG1hdHJpeCBzdG9yYWdlLgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy5tYXRyaXggPSBbXTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFuIGVsZW1lbnQKICAgICAqLwoKCiAgICBnZXQoYmksIGJqKSB7CiAgICAgIGxldCB7CiAgICAgICAgaW5kZXg6IGkKICAgICAgfSA9IGJpOwogICAgICBsZXQgewogICAgICAgIGluZGV4OiBqCiAgICAgIH0gPSBiajsKCiAgICAgIGlmIChqID4gaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5tYXRyaXhbKGkgKiAoaSArIDEpID4+IDEpICsgaiAtIDFdOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgYW4gZWxlbWVudAogICAgICovCgoKICAgIHNldChiaSwgYmosIHZhbHVlKSB7CiAgICAgIGxldCB7CiAgICAgICAgaW5kZXg6IGkKICAgICAgfSA9IGJpOwogICAgICBsZXQgewogICAgICAgIGluZGV4OiBqCiAgICAgIH0gPSBiajsKCiAgICAgIGlmIChqID4gaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICB0aGlzLm1hdHJpeFsoaSAqIChpICsgMSkgPj4gMSkgKyBqIC0gMV0gPSB2YWx1ZSA/IDEgOiAwOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGFsbCBlbGVtZW50cyB0byB6ZXJvCiAgICAgKi8KCgogICAgcmVzZXQoKSB7CiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5tYXRyaXgubGVuZ3RoOyBpICE9PSBsOyBpKyspIHsKICAgICAgICB0aGlzLm1hdHJpeFtpXSA9IDA7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU2V0cyB0aGUgbWF4IG51bWJlciBvZiBvYmplY3RzCiAgICAgKi8KCgogICAgc2V0TnVtT2JqZWN0cyhuKSB7CiAgICAgIHRoaXMubWF0cml4Lmxlbmd0aCA9IG4gKiAobiAtIDEpID4+IDE7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IGRpc3BhdGNoZXMgZXZlbnRzLgogICAqLwogIGNsYXNzIEV2ZW50VGFyZ2V0IHsKICAgIC8qKgogICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyCiAgICAgKiBAcmV0dXJuIFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS4KICAgICAqLwogICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwoKICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgIH0KCiAgICAgIGlmICghbGlzdGVuZXJzW3R5cGVdLmluY2x1ZGVzKGxpc3RlbmVyKSkgewogICAgICAgIGxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGxpc3RlbmVyIGlzIGFkZGVkCiAgICAgKi8KCgogICAgaGFzRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyczsKCiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbdHlwZV0uaW5jbHVkZXMobGlzdGVuZXIpKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgYW55IGV2ZW50IGxpc3RlbmVyIG9mIHRoZSBnaXZlbiB0eXBlIGlzIGFkZGVkCiAgICAgKi8KCgogICAgaGFzQW55RXZlbnRMaXN0ZW5lcih0eXBlKSB7CiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwogICAgICByZXR1cm4gbGlzdGVuZXJzW3R5cGVdICE9PSB1bmRlZmluZWQ7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lcgogICAgICogQHJldHVybiBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuCiAgICAgKi8KCgogICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwoKICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpOwoKICAgICAgaWYgKGluZGV4ICE9PSAtMSkgewogICAgICAgIGxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogRW1pdCBhbiBldmVudC4KICAgICAqIEByZXR1cm4gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LgogICAgICovCgoKICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsKICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyczsKICAgICAgY29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1tldmVudC50eXBlXTsKCiAgICAgIGlmIChsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQpIHsKICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzOwoKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICBsaXN0ZW5lckFycmF5W2ldLmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQSBRdWF0ZXJuaW9uIGRlc2NyaWJlcyBhIHJvdGF0aW9uIGluIDNEIHNwYWNlLiBUaGUgUXVhdGVybmlvbiBpcyBtYXRoZW1hdGljYWxseSBkZWZpbmVkIGFzIFEgPSB4KmkgKyB5KmogKyB6KmsgKyB3LCB3aGVyZSAoaSxqLGspIGFyZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9ycy4gKHgseSx6KSBjYW4gYmUgc2VlbiBhcyBhIHZlY3RvciByZWxhdGVkIHRvIHRoZSBheGlzIG9mIHJvdGF0aW9uLCB3aGlsZSB0aGUgcmVhbCBtdWx0aXBsaWVyLCB3LCBpcyByZWxhdGVkIHRvIHRoZSBhbW91bnQgb2Ygcm90YXRpb24uCiAgICogQHBhcmFtIHggTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBpLgogICAqIEBwYXJhbSB5IE11bHRpcGxpZXIgb2YgdGhlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3Igai4KICAgKiBAcGFyYW0geiBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGsuCiAgICogQHBhcmFtIHcgTXVsdGlwbGllciBvZiB0aGUgcmVhbCBwYXJ0LgogICAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWF0ZXJuaW9uCiAgICovCgogIGNsYXNzIFF1YXRlcm5pb24gewogICAgY29uc3RydWN0b3IoeCwgeSwgeiwgdykgewogICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7CiAgICAgICAgeCA9IDA7CiAgICAgIH0KCiAgICAgIGlmICh5ID09PSB2b2lkIDApIHsKICAgICAgICB5ID0gMDsKICAgICAgfQoKICAgICAgaWYgKHogPT09IHZvaWQgMCkgewogICAgICAgIHogPSAwOwogICAgICB9CgogICAgICBpZiAodyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdyA9IDE7CiAgICAgIH0KCiAgICAgIHRoaXMueCA9IHg7CiAgICAgIHRoaXMueSA9IHk7CiAgICAgIHRoaXMueiA9IHo7CiAgICAgIHRoaXMudyA9IHc7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHF1YXRlcm5pb24uCiAgICAgKi8KCgogICAgc2V0KHgsIHksIHosIHcpIHsKICAgICAgdGhpcy54ID0geDsKICAgICAgdGhpcy55ID0geTsKICAgICAgdGhpcy56ID0gejsKICAgICAgdGhpcy53ID0gdzsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgdG8gYSByZWFkYWJsZSBmb3JtYXQKICAgICAqIEByZXR1cm4gIngseSx6LHciCiAgICAgKi8KCgogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLnh9LCR7dGhpcy55fSwke3RoaXMuen0sJHt0aGlzLnd9YDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCB0byBhbiBBcnJheQogICAgICogQHJldHVybiBbeCwgeSwgeiwgd10KICAgICAqLwoKCiAgICB0b0FycmF5KCkgewogICAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud107CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIGFuIGF4aXMgYW5kIGFuIGFuZ2xlIGluIHJhZGlhbnMuCiAgICAgKi8KCgogICAgc2V0RnJvbUF4aXNBbmdsZSh2ZWN0b3IsIGFuZ2xlKSB7CiAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSAqIDAuNSk7CiAgICAgIHRoaXMueCA9IHZlY3Rvci54ICogczsKICAgICAgdGhpcy55ID0gdmVjdG9yLnkgKiBzOwogICAgICB0aGlzLnogPSB2ZWN0b3IueiAqIHM7CiAgICAgIHRoaXMudyA9IE1hdGguY29zKGFuZ2xlICogMC41KTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIHRoZSBxdWF0ZXJuaW9uIHRvIFsgYXhpcywgYW5nbGUgXSByZXByZXNlbnRhdGlvbi4KICAgICAqIEBwYXJhbSB0YXJnZXRBeGlzIEEgdmVjdG9yIG9iamVjdCB0byByZXVzZSBmb3Igc3RvcmluZyB0aGUgYXhpcy4KICAgICAqIEByZXR1cm4gQW4gYXJyYXksIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuCiAgICAgKi8KCgogICAgdG9BeGlzQW5nbGUodGFyZ2V0QXhpcykgewogICAgICBpZiAodGFyZ2V0QXhpcyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0QXhpcyA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMubm9ybWFsaXplKCk7IC8vIGlmIHc+MSBhY29zIGFuZCBzcXJ0IHdpbGwgcHJvZHVjZSBlcnJvcnMsIHRoaXMgY2FudCBoYXBwZW4gaWYgcXVhdGVybmlvbiBpcyBub3JtYWxpc2VkCgogICAgICBjb25zdCBhbmdsZSA9IDIgKiBNYXRoLmFjb3ModGhpcy53KTsKICAgICAgY29uc3QgcyA9IE1hdGguc3FydCgxIC0gdGhpcy53ICogdGhpcy53KTsgLy8gYXNzdW1pbmcgcXVhdGVybmlvbiBub3JtYWxpc2VkIHRoZW4gdyBpcyBsZXNzIHRoYW4gMSwgc28gdGVybSBhbHdheXMgcG9zaXRpdmUuCgogICAgICBpZiAocyA8IDAuMDAxKSB7CiAgICAgICAgLy8gdGVzdCB0byBhdm9pZCBkaXZpZGUgYnkgemVybywgcyBpcyBhbHdheXMgcG9zaXRpdmUgZHVlIHRvIHNxcnQKICAgICAgICAvLyBpZiBzIGNsb3NlIHRvIHplcm8gdGhlbiBkaXJlY3Rpb24gb2YgYXhpcyBub3QgaW1wb3J0YW50CiAgICAgICAgdGFyZ2V0QXhpcy54ID0gdGhpcy54OyAvLyBpZiBpdCBpcyBpbXBvcnRhbnQgdGhhdCBheGlzIGlzIG5vcm1hbGlzZWQgdGhlbiByZXBsYWNlIHdpdGggeD0xOyB5PXo9MDsKCiAgICAgICAgdGFyZ2V0QXhpcy55ID0gdGhpcy55OwogICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMuejsKICAgICAgfSBlbHNlIHsKICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLnggLyBzOyAvLyBub3JtYWxpc2UgYXhpcwoKICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnkgLyBzOwogICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMueiAvIHM7CiAgICAgIH0KCiAgICAgIHJldHVybiBbdGFyZ2V0QXhpcywgYW5nbGVdOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHF1YXRlcm5pb24gdmFsdWUgZ2l2ZW4gdHdvIHZlY3RvcnMuIFRoZSByZXN1bHRpbmcgcm90YXRpb24gd2lsbCBiZSB0aGUgbmVlZGVkIHJvdGF0aW9uIHRvIHJvdGF0ZSB1IHRvIHYuCiAgICAgKi8KCgogICAgc2V0RnJvbVZlY3RvcnModSwgdikgewogICAgICBpZiAodS5pc0FudGlwYXJhbGxlbFRvKHYpKSB7CiAgICAgICAgY29uc3QgdDEgPSBzZnZfdDE7CiAgICAgICAgY29uc3QgdDIgPSBzZnZfdDI7CiAgICAgICAgdS50YW5nZW50cyh0MSwgdDIpOwogICAgICAgIHRoaXMuc2V0RnJvbUF4aXNBbmdsZSh0MSwgTWF0aC5QSSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgYSA9IHUuY3Jvc3Modik7CiAgICAgICAgdGhpcy54ID0gYS54OwogICAgICAgIHRoaXMueSA9IGEueTsKICAgICAgICB0aGlzLnogPSBhLno7CiAgICAgICAgdGhpcy53ID0gTWF0aC5zcXJ0KHUubGVuZ3RoKCkgKiogMiAqIHYubGVuZ3RoKCkgKiogMikgKyB1LmRvdCh2KTsKICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogTXVsdGlwbHkgdGhlIHF1YXRlcm5pb24gd2l0aCBhbiBvdGhlciBxdWF0ZXJuaW9uLgogICAgICovCgoKICAgIG11bHQocXVhdCwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4ID0gdGhpcy54OwogICAgICBjb25zdCBheSA9IHRoaXMueTsKICAgICAgY29uc3QgYXogPSB0aGlzLno7CiAgICAgIGNvbnN0IGF3ID0gdGhpcy53OwogICAgICBjb25zdCBieCA9IHF1YXQueDsKICAgICAgY29uc3QgYnkgPSBxdWF0Lnk7CiAgICAgIGNvbnN0IGJ6ID0gcXVhdC56OwogICAgICBjb25zdCBidyA9IHF1YXQudzsKICAgICAgdGFyZ2V0LnggPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5OwogICAgICB0YXJnZXQueSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7CiAgICAgIHRhcmdldC56ID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDsKICAgICAgdGFyZ2V0LncgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGludmVyc2UgcXVhdGVybmlvbiByb3RhdGlvbi4KICAgICAqLwoKCiAgICBpbnZlcnNlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCB3ID0gdGhpcy53OwogICAgICB0aGlzLmNvbmp1Z2F0ZSh0YXJnZXQpOwogICAgICBjb25zdCBpbm9ybTIgPSAxIC8gKHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTsKICAgICAgdGFyZ2V0LnggKj0gaW5vcm0yOwogICAgICB0YXJnZXQueSAqPSBpbm9ybTI7CiAgICAgIHRhcmdldC56ICo9IGlub3JtMjsKICAgICAgdGFyZ2V0LncgKj0gaW5vcm0yOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHF1YXRlcm5pb24gY29uanVnYXRlCiAgICAgKi8KCgogICAgY29uanVnYXRlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IC10aGlzLng7CiAgICAgIHRhcmdldC55ID0gLXRoaXMueTsKICAgICAgdGFyZ2V0LnogPSAtdGhpcy56OwogICAgICB0YXJnZXQudyA9IHRoaXMudzsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIHF1YXRlcm5pb24uCiAgICAgKi8KCgogICAgbm9ybWFsaXplKCkgewogICAgICBsZXQgbCA9IE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpOwoKICAgICAgaWYgKGwgPT09IDApIHsKICAgICAgICB0aGlzLnggPSAwOwogICAgICAgIHRoaXMueSA9IDA7CiAgICAgICAgdGhpcy56ID0gMDsKICAgICAgICB0aGlzLncgPSAwOwogICAgICB9IGVsc2UgewogICAgICAgIGwgPSAxIC8gbDsKICAgICAgICB0aGlzLnggKj0gbDsKICAgICAgICB0aGlzLnkgKj0gbDsKICAgICAgICB0aGlzLnogKj0gbDsKICAgICAgICB0aGlzLncgKj0gbDsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIEFwcHJveGltYXRpb24gb2YgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uLiBXb3JrcyBiZXN0IHdoZW4gcXVhdCBpcyBhbHJlYWR5IGFsbW9zdC1ub3JtYWxpemVkLgogICAgICogQGF1dGhvciB1bnBoYXNlZCwgaHR0cHM6Ly9naXRodWIuY29tL3VucGhhc2VkCiAgICAgKi8KCgogICAgbm9ybWFsaXplRmFzdCgpIHsKICAgICAgY29uc3QgZiA9ICgzLjAgLSAodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KSkgLyAyLjA7CgogICAgICBpZiAoZiA9PT0gMCkgewogICAgICAgIHRoaXMueCA9IDA7CiAgICAgICAgdGhpcy55ID0gMDsKICAgICAgICB0aGlzLnogPSAwOwogICAgICAgIHRoaXMudyA9IDA7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy54ICo9IGY7CiAgICAgICAgdGhpcy55ICo9IGY7CiAgICAgICAgdGhpcy56ICo9IGY7CiAgICAgICAgdGhpcy53ICo9IGY7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB0aGUgcXVhdGVybmlvbiBieSBhIHZlY3RvcgogICAgICovCgoKICAgIHZtdWx0KHYsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdi54OwogICAgICBjb25zdCB5ID0gdi55OwogICAgICBjb25zdCB6ID0gdi56OwogICAgICBjb25zdCBxeCA9IHRoaXMueDsKICAgICAgY29uc3QgcXkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHF6ID0gdGhpcy56OwogICAgICBjb25zdCBxdyA9IHRoaXMudzsgLy8gcSp2CgogICAgICBjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTsKICAgICAgY29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7CiAgICAgIGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4OwogICAgICBjb25zdCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7CiAgICAgIHRhcmdldC54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTsKICAgICAgdGFyZ2V0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6OwogICAgICB0YXJnZXQueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLgogICAgICogQHJldHVybiB0aGlzCiAgICAgKi8KCgogICAgY29weShxdWF0KSB7CiAgICAgIHRoaXMueCA9IHF1YXQueDsKICAgICAgdGhpcy55ID0gcXVhdC55OwogICAgICB0aGlzLnogPSBxdWF0Lno7CiAgICAgIHRoaXMudyA9IHF1YXQudzsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgdGhlIHF1YXRlcm5pb24gdG8gZXVsZXIgYW5nbGUgcmVwcmVzZW50YXRpb24uIE9yZGVyOiBZWlgsIGFzIHRoaXMgcGFnZSBkZXNjcmliZXM6IGh0dHBzOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9zdGFuZGFyZHMvaW5kZXguaHRtCiAgICAgKiBAcGFyYW0gb3JkZXIgVGhyZWUtY2hhcmFjdGVyIHN0cmluZywgZGVmYXVsdHMgdG8gIllaWCIKICAgICAqLwoKCiAgICB0b0V1bGVyKHRhcmdldCwgb3JkZXIpIHsKICAgICAgaWYgKG9yZGVyID09PSB2b2lkIDApIHsKICAgICAgICBvcmRlciA9ICdZWlgnOwogICAgICB9CgogICAgICBsZXQgaGVhZGluZzsKICAgICAgbGV0IGF0dGl0dWRlOwogICAgICBsZXQgYmFuazsKICAgICAgY29uc3QgeCA9IHRoaXMueDsKICAgICAgY29uc3QgeSA9IHRoaXMueTsKICAgICAgY29uc3QgeiA9IHRoaXMuejsKICAgICAgY29uc3QgdyA9IHRoaXMudzsKCiAgICAgIHN3aXRjaCAob3JkZXIpIHsKICAgICAgICBjYXNlICdZWlgnOgogICAgICAgICAgY29uc3QgdGVzdCA9IHggKiB5ICsgeiAqIHc7CgogICAgICAgICAgaWYgKHRlc3QgPiAwLjQ5OSkgewogICAgICAgICAgICAvLyBzaW5ndWxhcml0eSBhdCBub3J0aCBwb2xlCiAgICAgICAgICAgIGhlYWRpbmcgPSAyICogTWF0aC5hdGFuMih4LCB3KTsKICAgICAgICAgICAgYXR0aXR1ZGUgPSBNYXRoLlBJIC8gMjsKICAgICAgICAgICAgYmFuayA9IDA7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKHRlc3QgPCAtMC40OTkpIHsKICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZQogICAgICAgICAgICBoZWFkaW5nID0gLTIgKiBNYXRoLmF0YW4yKHgsIHcpOwogICAgICAgICAgICBhdHRpdHVkZSA9IC1NYXRoLlBJIC8gMjsKICAgICAgICAgICAgYmFuayA9IDA7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGhlYWRpbmcgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBjb25zdCBzcXggPSB4ICogeDsKICAgICAgICAgICAgY29uc3Qgc3F5ID0geSAqIHk7CiAgICAgICAgICAgIGNvbnN0IHNxeiA9IHogKiB6OwogICAgICAgICAgICBoZWFkaW5nID0gTWF0aC5hdGFuMigyICogeSAqIHcgLSAyICogeCAqIHosIDEgLSAyICogc3F5IC0gMiAqIHNxeik7IC8vIEhlYWRpbmcKCiAgICAgICAgICAgIGF0dGl0dWRlID0gTWF0aC5hc2luKDIgKiB0ZXN0KTsgLy8gYXR0aXR1ZGUKCiAgICAgICAgICAgIGJhbmsgPSBNYXRoLmF0YW4yKDIgKiB4ICogdyAtIDIgKiB5ICogeiwgMSAtIDIgKiBzcXggLSAyICogc3F6KTsgLy8gYmFuawogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdWxlciBvcmRlciAke29yZGVyfSBub3Qgc3VwcG9ydGVkIHlldC5gKTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnkgPSBoZWFkaW5nOwogICAgICB0YXJnZXQueiA9IGF0dGl0dWRlOwogICAgICB0YXJnZXQueCA9IGJhbms7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIEV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uLgogICAgICoKICAgICAqIEBwYXJhbSBvcmRlciBUaGUgb3JkZXIgdG8gYXBwbHkgYW5nbGVzOiAnWFlaJyBvciAnWVhaJyBvciBhbnkgb3RoZXIgY29tYmluYXRpb24uCiAgICAgKgogICAgICogU2VlIHtAbGluayBodHRwczovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlLzIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzIE1hdGhXb3Jrc30gcmVmZXJlbmNlCiAgICAgKi8KCgogICAgc2V0RnJvbUV1bGVyKHgsIHksIHosIG9yZGVyKSB7CiAgICAgIGlmIChvcmRlciA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3JkZXIgPSAnWFlaJzsKICAgICAgfQoKICAgICAgY29uc3QgYzEgPSBNYXRoLmNvcyh4IC8gMik7CiAgICAgIGNvbnN0IGMyID0gTWF0aC5jb3MoeSAvIDIpOwogICAgICBjb25zdCBjMyA9IE1hdGguY29zKHogLyAyKTsKICAgICAgY29uc3QgczEgPSBNYXRoLnNpbih4IC8gMik7CiAgICAgIGNvbnN0IHMyID0gTWF0aC5zaW4oeSAvIDIpOwogICAgICBjb25zdCBzMyA9IE1hdGguc2luKHogLyAyKTsKCiAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHsKICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7CiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzOwogICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMzsKICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7CiAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWFonKSB7CiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzOwogICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMzsKICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7CiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzOwogICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWlhZJykgewogICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMzsKICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7CiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzOwogICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMzsKICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHsKICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7CiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzOwogICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMzsKICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7CiAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWlgnKSB7CiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzOwogICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMzsKICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7CiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzOwogICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWFpZJykgewogICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMzsKICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7CiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzOwogICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMzsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CgogICAgY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpOwogICAgfQogICAgLyoqCiAgICAgKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0CiAgICAgKgogICAgICogQHBhcmFtIHRvUXVhdCBzZWNvbmQgb3BlcmFuZAogICAgICogQHBhcmFtIHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgc2VsZiBxdWF0ZXJuaW9uIGFuZCB0b1F1YXQKICAgICAqIEBwYXJhbSB0YXJnZXQgQSBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC4KICAgICAqIEByZXR1cm5zIHtRdWF0ZXJuaW9ufSBUaGUgInRhcmdldCIgb2JqZWN0CiAgICAgKi8KCgogICAgc2xlcnAodG9RdWF0LCB0LCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgfQoKICAgICAgY29uc3QgYXggPSB0aGlzLng7CiAgICAgIGNvbnN0IGF5ID0gdGhpcy55OwogICAgICBjb25zdCBheiA9IHRoaXMuejsKICAgICAgY29uc3QgYXcgPSB0aGlzLnc7CiAgICAgIGxldCBieCA9IHRvUXVhdC54OwogICAgICBsZXQgYnkgPSB0b1F1YXQueTsKICAgICAgbGV0IGJ6ID0gdG9RdWF0Lno7CiAgICAgIGxldCBidyA9IHRvUXVhdC53OwogICAgICBsZXQgb21lZ2E7CiAgICAgIGxldCBjb3NvbTsKICAgICAgbGV0IHNpbm9tOwogICAgICBsZXQgc2NhbGUwOwogICAgICBsZXQgc2NhbGUxOyAvLyBjYWxjIGNvc2luZQoKICAgICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3OyAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSkKCiAgICAgIGlmIChjb3NvbSA8IDAuMCkgewogICAgICAgIGNvc29tID0gLWNvc29tOwogICAgICAgIGJ4ID0gLWJ4OwogICAgICAgIGJ5ID0gLWJ5OwogICAgICAgIGJ6ID0gLWJ6OwogICAgICAgIGJ3ID0gLWJ3OwogICAgICB9IC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHMKCgogICAgICBpZiAoMS4wIC0gY29zb20gPiAwLjAwMDAwMSkgewogICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKQogICAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTsKICAgICAgICBzaW5vbSA9IE1hdGguc2luKG9tZWdhKTsKICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTsKICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gImZyb20iIGFuZCAidG8iIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlCiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbgogICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7CiAgICAgICAgc2NhbGUxID0gdDsKICAgICAgfSAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzCgoKICAgICAgdGFyZ2V0LnggPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4OwogICAgICB0YXJnZXQueSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7CiAgICAgIHRhcmdldC56ID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejsKICAgICAgdGFyZ2V0LncgPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBSb3RhdGUgYW4gYWJzb2x1dGUgb3JpZW50YXRpb24gcXVhdGVybmlvbiBnaXZlbiBhbiBhbmd1bGFyIHZlbG9jaXR5IGFuZCBhIHRpbWUgc3RlcC4KICAgICAqLwoKCiAgICBpbnRlZ3JhdGUoYW5ndWxhclZlbG9jaXR5LCBkdCwgYW5ndWxhckZhY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4ID0gYW5ndWxhclZlbG9jaXR5LnggKiBhbmd1bGFyRmFjdG9yLngsCiAgICAgICAgICAgIGF5ID0gYW5ndWxhclZlbG9jaXR5LnkgKiBhbmd1bGFyRmFjdG9yLnksCiAgICAgICAgICAgIGF6ID0gYW5ndWxhclZlbG9jaXR5LnogKiBhbmd1bGFyRmFjdG9yLnosCiAgICAgICAgICAgIGJ4ID0gdGhpcy54LAogICAgICAgICAgICBieSA9IHRoaXMueSwKICAgICAgICAgICAgYnogPSB0aGlzLnosCiAgICAgICAgICAgIGJ3ID0gdGhpcy53OwogICAgICBjb25zdCBoYWxmX2R0ID0gZHQgKiAwLjU7CiAgICAgIHRhcmdldC54ICs9IGhhbGZfZHQgKiAoYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5KTsKICAgICAgdGFyZ2V0LnkgKz0gaGFsZl9kdCAqIChheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYnopOwogICAgICB0YXJnZXQueiArPSBoYWxmX2R0ICogKGF6ICogYncgKyBheCAqIGJ5IC0gYXkgKiBieCk7CiAgICAgIHRhcmdldC53ICs9IGhhbGZfZHQgKiAoLWF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBieik7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CgogIH0KICBjb25zdCBzZnZfdDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNmdl90MiA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIFRoZSBhdmFpbGFibGUgc2hhcGUgdHlwZXMuCiAgICovCiAgY29uc3QgU0hBUEVfVFlQRVMgPSB7CiAgICAvKiogU1BIRVJFICovCiAgICBTUEhFUkU6IDEsCgogICAgLyoqIFBMQU5FICovCiAgICBQTEFORTogMiwKCiAgICAvKiogQk9YICovCiAgICBCT1g6IDQsCgogICAgLyoqIENPTVBPVU5EICovCiAgICBDT01QT1VORDogOCwKCiAgICAvKiogQ09OVkVYUE9MWUhFRFJPTiAqLwogICAgQ09OVkVYUE9MWUhFRFJPTjogMTYsCgogICAgLyoqIEhFSUdIVEZJRUxEICovCiAgICBIRUlHSFRGSUVMRDogMzIsCgogICAgLyoqIFBBUlRJQ0xFICovCiAgICBQQVJUSUNMRTogNjQsCgogICAgLyoqIENZTElOREVSICovCiAgICBDWUxJTkRFUjogMTI4LAoKICAgIC8qKiBUUklNRVNIICovCiAgICBUUklNRVNIOiAyNTYKICB9OwogIC8qKgogICAqIFNoYXBlVHlwZQogICAqLwoKICAvKioKICAgKiBCYXNlIGNsYXNzIGZvciBzaGFwZXMKICAgKi8KICBjbGFzcyBTaGFwZSB7CiAgICAvKioKICAgICAqIElkZW50aWZpZXIgb2YgdGhlIFNoYXBlLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBNdXN0IGJlIHNldCB0byBhbiBpbnQgPiAwIGJ5IHN1YmNsYXNzZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBsb2NhbCBib3VuZGluZyBzcGhlcmUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4KICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogQGRlZmF1bHQgMQogICAgICovCgogICAgLyoqCiAgICAgKiBAZGVmYXVsdCAtMQogICAgICovCgogICAgLyoqCiAgICAgKiBPcHRpb25hbCBtYXRlcmlhbCBvZiB0aGUgc2hhcGUgdGhhdCByZWd1bGF0ZXMgY29udGFjdCBwcm9wZXJ0aWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgYm9keSB0byB3aGljaCB0aGUgc2hhcGUgaXMgYWRkZWQgdG8uCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFsbCB0aGUgU2hhcGUgdHlwZXMuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgdGhpcy5pZCA9IFNoYXBlLmlkQ291bnRlcisrOwogICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgMDsKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDA7CiAgICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID8gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSA6IHRydWU7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgOiAtMTsKICAgICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgPyBvcHRpb25zLm1hdGVyaWFsIDogbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMuCiAgICAgKiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiB0aGUgcHJvcGVydHkgYC5ib3VuZGluZ1NwaGVyZVJhZGl1c2AKICAgICAqLwoKCiAgICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHsKICAgICAgdGhyb3cgYGNvbXB1dGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAke3RoaXMudHlwZX1gOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHZvbHVtZSBvZiB0aGlzIHNoYXBlCiAgICAgKi8KCgogICAgdm9sdW1lKCkgewogICAgICB0aHJvdyBgdm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7CiAgICB9CiAgICAvKioKICAgICAqIENhbGN1bGF0ZXMgdGhlIGluZXJ0aWEgaW4gdGhlIGxvY2FsIGZyYW1lIGZvciB0aGlzIHNoYXBlLgogICAgICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICB0aHJvdyBgY2FsY3VsYXRlTG9jYWxJbmVydGlhKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7CiAgICB9CiAgICAvKioKICAgICAqIEB0b2RvIHVzZSBhYnN0cmFjdCBmb3IgdGhlc2Uga2luZCBvZiBtZXRob2RzCiAgICAgKi8KCgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgdGhyb3cgYGNhbGN1bGF0ZVdvcmxkQUFCQigpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAke3RoaXMudHlwZX1gOwogICAgfQoKICB9CiAgU2hhcGUuaWRDb3VudGVyID0gMDsKICBTaGFwZS50eXBlcyA9IFNIQVBFX1RZUEVTOwoKICAvKioKICAgKiBUcmFuc2Zvcm1hdGlvbiB1dGlsaXRpZXMuCiAgICovCiAgY2xhc3MgVHJhbnNmb3JtIHsKICAgIC8qKgogICAgICogcG9zaXRpb24KICAgICAqLwoKICAgIC8qKgogICAgICogcXVhdGVybmlvbgogICAgICovCiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpOwoKICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHsKICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLnF1YXRlcm5pb24pIHsKICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIGdsb2JhbCBwb2ludCBpbiBsb2NhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuCiAgICAgKi8KCgogICAgcG9pbnRUb0xvY2FsKHdvcmxkUG9pbnQsIHJlc3VsdCkgewogICAgICByZXR1cm4gVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgd29ybGRQb2ludCwgcmVzdWx0KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGEgbG9jYWwgcG9pbnQgaW4gZ2xvYmFsIHRyYW5zZm9ybSBjb29yZGluYXRlcy4KICAgICAqLwoKCiAgICBwb2ludFRvV29ybGQobG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIHJldHVybiBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCBsb2NhbFBvaW50LCByZXN1bHQpOwogICAgfQogICAgLyoqCiAgICAgKiB2ZWN0b3JUb1dvcmxkRnJhbWUKICAgICAqLwoKCiAgICB2ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHBvaW50VG9Mb2NhbEZyYW1lCiAgICAgKi8KCgogICAgc3RhdGljIHBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFBvaW50LCByZXN1bHQpIHsKICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmVzdWx0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgd29ybGRQb2ludC52c3ViKHBvc2l0aW9uLCByZXN1bHQpOwogICAgICBxdWF0ZXJuaW9uLmNvbmp1Z2F0ZSh0bXBRdWF0JDEpOwogICAgICB0bXBRdWF0JDEudm11bHQocmVzdWx0LCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBwb2ludFRvV29ybGRGcmFtZQogICAgICovCgoKICAgIHN0YXRpYyBwb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgbG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCwgcmVzdWx0KTsKICAgICAgcmVzdWx0LnZhZGQocG9zaXRpb24sIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHZlY3RvclRvV29ybGRGcmFtZQogICAgICovCgoKICAgIHN0YXRpYyB2ZWN0b3JUb1dvcmxkRnJhbWUocXVhdGVybmlvbiwgbG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBxdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiB2ZWN0b3JUb0xvY2FsRnJhbWUKICAgICAqLwoKCiAgICBzdGF0aWMgdmVjdG9yVG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFZlY3RvciwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHF1YXRlcm5pb24udyAqPSAtMTsKICAgICAgcXVhdGVybmlvbi52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTsKICAgICAgcXVhdGVybmlvbi53ICo9IC0xOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICB9CiAgY29uc3QgdG1wUXVhdCQxID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgLyoqCiAgICogQSBzZXQgb2YgcG9seWdvbnMgZGVzY3JpYmluZyBhIGNvbnZleCBzaGFwZS4KICAgKgogICAqIFRoZSBzaGFwZSBNVVNUIGJlIGNvbnZleCBmb3IgdGhlIGNvZGUgdG8gd29yayBwcm9wZXJseS4gTm8gcG9seWdvbnMgbWF5IGJlIGNvcGxhbmFyIChjb250YWluZWQKICAgKiBpbiB0aGUgc2FtZSAzRCBwbGFuZSksIGluc3RlYWQgdGhlc2Ugc2hvdWxkIGJlIG1lcmdlZCBpbnRvIG9uZSBwb2x5Z29uLgogICAqCiAgICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW8gKG9yaWdpbmFsIGF1dGhvciwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvL3RocmVlLmpzL2NvbW1pdC84NTAyNmYwYzc2OWU0MDAwMTQ4YTY3ZDQ1YTllOWI5YzUxMDg4MzZmKQogICAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUKICAgKiBAc2VlIGh0dHBzOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvCiAgICoKICAgKiBAdG9kbyBNb3ZlIHRoZSBjbGlwcGluZyBmdW5jdGlvbnMgdG8gQ29udGFjdEdlbmVyYXRvcj8KICAgKiBAdG9kbyBBdXRvbWF0aWNhbGx5IG1lcmdlIGNvcGxhbmFyIHBvbHlnb25zIGluIGNvbnN0cnVjdG9yLgogICAqIEBleGFtcGxlCiAgICogICAgIGNvbnN0IGNvbnZleFNoYXBlID0gbmV3IENBTk5PTi5Db252ZXhQb2x5aGVkcm9uKHsgdmVydGljZXMsIGZhY2VzIH0pCiAgICogICAgIGNvbnN0IGNvbnZleEJvZHkgPSBuZXcgQ0FOTk9OLkJvZHkoeyBtYXNzOiAxLCBzaGFwZTogY29udmV4U2hhcGUgfSkKICAgKiAgICAgd29ybGQuYWRkQm9keShjb252ZXhCb2R5KQogICAqLwogIGNsYXNzIENvbnZleFBvbHloZWRyb24gZXh0ZW5kcyBTaGFwZSB7CiAgICAvKiogdmVydGljZXMgKi8KCiAgICAvKioKICAgICAqIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggZmFjZSBjb25zaXN0cyBvZgogICAgICovCgogICAgLyoqIGZhY2VOb3JtYWxzICovCgogICAgLyoqIHdvcmxkVmVydGljZXMgKi8KCiAgICAvKiogd29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlICovCgogICAgLyoqIHdvcmxkRmFjZU5vcm1hbHMgKi8KCiAgICAvKiogd29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlICovCgogICAgLyoqCiAgICAgKiBJZiBnaXZlbiwgdGhlc2UgbG9jYWxseSBkZWZpbmVkLCBub3JtYWxpemVkIGF4ZXMgYXJlIHRoZSBvbmx5IG9uZXMgYmVpbmcgY2hlY2tlZCB3aGVuIGRvaW5nIHNlcGFyYXRpbmcgYXhpcyBjaGVjay4KICAgICAqLwoKICAgIC8qKiB1bmlxdWVFZGdlcyAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIHZlcnRpY2VzIEFuIGFycmF5IG9mIFZlYzMncwogICAgICogQHBhcmFtIGZhY2VzIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBkZXNjcmliaW5nIHdoaWNoIHZlcnRpY2VzIHRoYXQgaXMgaW5jbHVkZWQgaW4gZWFjaCBmYWNlLgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihwcm9wcykgewogICAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkgewogICAgICAgIHByb3BzID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IHsKICAgICAgICB2ZXJ0aWNlcyA9IFtdLAogICAgICAgIGZhY2VzID0gW10sCiAgICAgICAgbm9ybWFscyA9IFtdLAogICAgICAgIGF4ZXMsCiAgICAgICAgYm91bmRpbmdTcGhlcmVSYWRpdXMKICAgICAgfSA9IHByb3BzOwogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTgogICAgICB9KTsKICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzOwogICAgICB0aGlzLmZhY2VzID0gZmFjZXM7CiAgICAgIHRoaXMuZmFjZU5vcm1hbHMgPSBub3JtYWxzOwoKICAgICAgaWYgKHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdGhpcy5jb21wdXRlTm9ybWFscygpOwogICAgICB9CgogICAgICBpZiAoIWJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBib3VuZGluZ1NwaGVyZVJhZGl1czsKICAgICAgfQoKICAgICAgdGhpcy53b3JsZFZlcnRpY2VzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLnZlcnRpY2VzCgogICAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IHRydWU7CiAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFscyA9IFtdOyAvLyBXb3JsZCB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIC5mYWNlTm9ybWFscwoKICAgICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSB0cnVlOwogICAgICB0aGlzLnVuaXF1ZUF4ZXMgPSBheGVzID8gYXhlcy5zbGljZSgpIDogbnVsbDsKICAgICAgdGhpcy51bmlxdWVFZGdlcyA9IFtdOwogICAgICB0aGlzLmNvbXB1dGVFZGdlcygpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyB1bmlxdWVFZGdlcwogICAgICovCgoKICAgIGNvbXB1dGVFZGdlcygpIHsKICAgICAgY29uc3QgZmFjZXMgPSB0aGlzLmZhY2VzOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIGNvbnN0IGVkZ2VzID0gdGhpcy51bmlxdWVFZGdlczsKICAgICAgZWRnZXMubGVuZ3RoID0gMDsKICAgICAgY29uc3QgZWRnZSA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbaV07CiAgICAgICAgY29uc3QgbnVtVmVydGljZXMgPSBmYWNlLmxlbmd0aDsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IG51bVZlcnRpY2VzOyBqKyspIHsKICAgICAgICAgIGNvbnN0IGsgPSAoaiArIDEpICUgbnVtVmVydGljZXM7CiAgICAgICAgICB2ZXJ0aWNlc1tmYWNlW2pdXS52c3ViKHZlcnRpY2VzW2ZhY2Vba11dLCBlZGdlKTsKICAgICAgICAgIGVkZ2Uubm9ybWFsaXplKCk7CiAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTsKCiAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspIHsKICAgICAgICAgICAgaWYgKGVkZ2VzW3BdLmFsbW9zdEVxdWFscyhlZGdlKSB8fCBlZGdlc1twXS5hbG1vc3RFcXVhbHMoZWRnZSkpIHsKICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIWZvdW5kKSB7CiAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuCiAgICAgKiBXaWxsIHJldXNlIGV4aXN0aW5nIFZlYzMgb2JqZWN0cyBpbiB0aGUgYGZhY2VOb3JtYWxzYCBhcnJheSBpZiB0aGV5IGV4aXN0LgogICAgICovCgoKICAgIGNvbXB1dGVOb3JtYWxzKCkgewogICAgICB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aCA9IHRoaXMuZmFjZXMubGVuZ3RoOyAvLyBHZW5lcmF0ZSBub3JtYWxzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAvLyBDaGVjayBzbyBhbGwgdmVydGljZXMgZXhpc3RzIGZvciB0aGlzIGZhY2UKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspIHsKICAgICAgICAgIGlmICghdGhpcy52ZXJ0aWNlc1t0aGlzLmZhY2VzW2ldW2pdXSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnRleCAke3RoaXMuZmFjZXNbaV1bal19IG5vdCBmb3VuZCFgKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGNvbnN0IG4gPSB0aGlzLmZhY2VOb3JtYWxzW2ldIHx8IG5ldyBWZWMzKCk7CiAgICAgICAgdGhpcy5nZXRGYWNlTm9ybWFsKGksIG4pOwogICAgICAgIG4ubmVnYXRlKG4pOwogICAgICAgIHRoaXMuZmFjZU5vcm1hbHNbaV0gPSBuOwogICAgICAgIGNvbnN0IHZlcnRleCA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVswXV07CgogICAgICAgIGlmIChuLmRvdCh2ZXJ0ZXgpIDwgMCkgewogICAgICAgICAgY29uc29sZS5lcnJvcihgLmZhY2VOb3JtYWxzWyR7aX1dID0gVmVjMygke24udG9TdHJpbmcoKX0pIGxvb2tzIGxpa2UgaXQgcG9pbnRzIGludG8gdGhlIHNoYXBlPyBUaGUgdmVydGljZXMgZm9sbG93LiBNYWtlIHN1cmUgdGhleSBhcmUgb3JkZXJlZCBDQ1cgYXJvdW5kIHRoZSBub3JtYWwsIHVzaW5nIHRoZSByaWdodCBoYW5kIHJ1bGUuYCk7CgogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmZhY2VzW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgIGNvbnNvbGUud2FybihgLnZlcnRpY2VzWyR7dGhpcy5mYWNlc1tpXVtqXX1dID0gVmVjMygke3RoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0udG9TdHJpbmcoKX0pYCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGUgdGhlIG5vcm1hbCBvZiBhIGZhY2UgZnJvbSBpdHMgdmVydGljZXMKICAgICAqLwoKCiAgICBnZXRGYWNlTm9ybWFsKGksIHRhcmdldCkgewogICAgICBjb25zdCBmID0gdGhpcy5mYWNlc1tpXTsKICAgICAgY29uc3QgdmEgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dOwogICAgICBjb25zdCB2YiA9IHRoaXMudmVydGljZXNbZlsxXV07CiAgICAgIGNvbnN0IHZjID0gdGhpcy52ZXJ0aWNlc1tmWzJdXTsKICAgICAgQ29udmV4UG9seWhlZHJvbi5jb21wdXRlTm9ybWFsKHZhLCB2YiwgdmMsIHRhcmdldCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzCiAgICAgKi8KCgogICAgc3RhdGljIGNvbXB1dGVOb3JtYWwodmEsIHZiLCB2YywgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNiID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgYWIgPSBuZXcgVmVjMygpOwogICAgICB2Yi52c3ViKHZhLCBhYik7CiAgICAgIHZjLnZzdWIodmIsIGNiKTsKICAgICAgY2IuY3Jvc3MoYWIsIHRhcmdldCk7CgogICAgICBpZiAoIXRhcmdldC5pc1plcm8oKSkgewogICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBAcGFyYW0gbWluRGlzdCBDbGFtcCBkaXN0YW5jZQogICAgICogQHBhcmFtIHJlc3VsdCBUaGUgYW4gYXJyYXkgb2YgY29udGFjdCBwb2ludCBvYmplY3RzLCBzZWUgY2xpcEZhY2VBZ2FpbnN0SHVsbAogICAgICovCgoKICAgIGNsaXBBZ2FpbnN0SHVsbChwb3NBLCBxdWF0QSwgaHVsbEIsIHBvc0IsIHF1YXRCLCBzZXBhcmF0aW5nTm9ybWFsLCBtaW5EaXN0LCBtYXhEaXN0LCByZXN1bHQpIHsKICAgICAgY29uc3QgV29ybGROb3JtYWwgPSBuZXcgVmVjMygpOwogICAgICBsZXQgY2xvc2VzdEZhY2VCID0gLTE7CiAgICAgIGxldCBkbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7CgogICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IGh1bGxCLmZhY2VzLmxlbmd0aDsgZmFjZSsrKSB7CiAgICAgICAgV29ybGROb3JtYWwuY29weShodWxsQi5mYWNlTm9ybWFsc1tmYWNlXSk7CiAgICAgICAgcXVhdEIudm11bHQoV29ybGROb3JtYWwsIFdvcmxkTm9ybWFsKTsKICAgICAgICBjb25zdCBkID0gV29ybGROb3JtYWwuZG90KHNlcGFyYXRpbmdOb3JtYWwpOwoKICAgICAgICBpZiAoZCA+IGRtYXgpIHsKICAgICAgICAgIGRtYXggPSBkOwogICAgICAgICAgY2xvc2VzdEZhY2VCID0gZmFjZTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IHdvcmxkVmVydHNCMSA9IFtdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsQi5mYWNlc1tjbG9zZXN0RmFjZUJdLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgYiA9IGh1bGxCLnZlcnRpY2VzW2h1bGxCLmZhY2VzW2Nsb3Nlc3RGYWNlQl1baV1dOwogICAgICAgIGNvbnN0IHdvcmxkYiA9IG5ldyBWZWMzKCk7CiAgICAgICAgd29ybGRiLmNvcHkoYik7CiAgICAgICAgcXVhdEIudm11bHQod29ybGRiLCB3b3JsZGIpOwogICAgICAgIHBvc0IudmFkZCh3b3JsZGIsIHdvcmxkYik7CiAgICAgICAgd29ybGRWZXJ0c0IxLnB1c2god29ybGRiKTsKICAgICAgfQoKICAgICAgaWYgKGNsb3Nlc3RGYWNlQiA+PSAwKSB7CiAgICAgICAgdGhpcy5jbGlwRmFjZUFnYWluc3RIdWxsKHNlcGFyYXRpbmdOb3JtYWwsIHBvc0EsIHF1YXRBLCB3b3JsZFZlcnRzQjEsIG1pbkRpc3QsIG1heERpc3QsIHJlc3VsdCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogRmluZCB0aGUgc2VwYXJhdGluZyBheGlzIGJldHdlZW4gdGhpcyBodWxsIGFuZCBhbm90aGVyCiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgdmVjdG9yIHRvIHNhdmUgdGhlIGF4aXMgaW4KICAgICAqIEByZXR1cm4gUmV0dXJucyBmYWxzZSBpZiBhIHNlcGFyYXRpb24gaXMgZm91bmQsIGVsc2UgdHJ1ZQogICAgICovCgoKICAgIGZpbmRTZXBhcmF0aW5nQXhpcyhodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCLCB0YXJnZXQsIGZhY2VMaXN0QSwgZmFjZUxpc3RCKSB7CiAgICAgIGNvbnN0IGZhY2VBTm9ybWFsV1MzID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgV29ybGRub3JtYWwxID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgZGVsdGFDID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3Qgd29ybGRFZGdlMCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHdvcmxkRWRnZTEgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBDcm9zcyA9IG5ldyBWZWMzKCk7CiAgICAgIGxldCBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTsKICAgICAgY29uc3QgaHVsbEEgPSB0aGlzOwoKICAgICAgaWYgKCFodWxsQS51bmlxdWVBeGVzKSB7CiAgICAgICAgY29uc3QgbnVtRmFjZXNBID0gZmFjZUxpc3RBID8gZmFjZUxpc3RBLmxlbmd0aCA6IGh1bGxBLmZhY2VzLmxlbmd0aDsgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQQoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZhY2VzQTsgaSsrKSB7CiAgICAgICAgICBjb25zdCBmaSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QVtpXSA6IGk7IC8vIEdldCB3b3JsZCBmYWNlIG5vcm1hbAoKICAgICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTsKICAgICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MzLCBmYWNlQU5vcm1hbFdTMyk7CiAgICAgICAgICBjb25zdCBkID0gaHVsbEEudGVzdFNlcEF4aXMoZmFjZUFOb3JtYWxXUzMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpOwoKICAgICAgICAgIGlmIChkID09PSBmYWxzZSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGQgPCBkbWluKSB7CiAgICAgICAgICAgIGRtaW4gPSBkOwogICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gaHVsbEEudW5pcXVlQXhlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgLy8gR2V0IHdvcmxkIGF4aXMKICAgICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUF4ZXNbaV0sIGZhY2VBTm9ybWFsV1MzKTsKICAgICAgICAgIGNvbnN0IGQgPSBodWxsQS50ZXN0U2VwQXhpcyhmYWNlQU5vcm1hbFdTMywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KGZhY2VBTm9ybWFsV1MzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICghaHVsbEIudW5pcXVlQXhlcykgewogICAgICAgIC8vIFRlc3QgZmFjZSBub3JtYWxzIGZyb20gaHVsbEIKICAgICAgICBjb25zdCBudW1GYWNlc0IgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEIubGVuZ3RoIDogaHVsbEIuZmFjZXMubGVuZ3RoOwoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZhY2VzQjsgaSsrKSB7CiAgICAgICAgICBjb25zdCBmaSA9IGZhY2VMaXN0QiA/IGZhY2VMaXN0QltpXSA6IGk7CiAgICAgICAgICBXb3JsZG5vcm1hbDEuY29weShodWxsQi5mYWNlTm9ybWFsc1tmaV0pOwogICAgICAgICAgcXVhdEIudm11bHQoV29ybGRub3JtYWwxLCBXb3JsZG5vcm1hbDEpOwogICAgICAgICAgY29uc3QgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMgaW4gQgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBodWxsQi51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBxdWF0Qi52bXVsdChodWxsQi51bmlxdWVBeGVzW2ldLCBXb3JsZG5vcm1hbDEpOwogICAgICAgICAgY29uc3QgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIFRlc3QgZWRnZXMKCgogICAgICBmb3IgKGxldCBlMCA9IDA7IGUwICE9PSBodWxsQS51bmlxdWVFZGdlcy5sZW5ndGg7IGUwKyspIHsKICAgICAgICAvLyBHZXQgd29ybGQgZWRnZQogICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUVkZ2VzW2UwXSwgd29ybGRFZGdlMCk7CgogICAgICAgIGZvciAobGV0IGUxID0gMDsgZTEgIT09IGh1bGxCLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTErKykgewogICAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2UgMgogICAgICAgICAgcXVhdEIudm11bHQoaHVsbEIudW5pcXVlRWRnZXNbZTFdLCB3b3JsZEVkZ2UxKTsKICAgICAgICAgIHdvcmxkRWRnZTAuY3Jvc3Mod29ybGRFZGdlMSwgQ3Jvc3MpOwoKICAgICAgICAgIGlmICghQ3Jvc3MuYWxtb3N0WmVybygpKSB7CiAgICAgICAgICAgIENyb3NzLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICBjb25zdCBkaXN0ID0gaHVsbEEudGVzdFNlcEF4aXMoQ3Jvc3MsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpOwoKICAgICAgICAgICAgaWYgKGRpc3QgPT09IGZhbHNlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoZGlzdCA8IGRtaW4pIHsKICAgICAgICAgICAgICBkbWluID0gZGlzdDsKICAgICAgICAgICAgICB0YXJnZXQuY29weShDcm9zcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHBvc0IudnN1Yihwb3NBLCBkZWx0YUMpOwoKICAgICAgaWYgKGRlbHRhQy5kb3QodGFyZ2V0KSA+IDAuMCkgewogICAgICAgIHRhcmdldC5uZWdhdGUodGFyZ2V0KTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIFRlc3Qgc2VwYXJhdGluZyBheGlzIGFnYWluc3QgdHdvIGh1bGxzLiBCb3RoIGh1bGxzIGFyZSBwcm9qZWN0ZWQgb250byB0aGUgYXhpcyBhbmQgdGhlIG92ZXJsYXAgc2l6ZSBpcyByZXR1cm5lZCBpZiB0aGVyZSBpcyBvbmUuCiAgICAgKiBAcmV0dXJuIFRoZSBvdmVybGFwIGRlcHRoLCBvciBGQUxTRSBpZiBubyBwZW5ldHJhdGlvbi4KICAgICAqLwoKCiAgICB0ZXN0U2VwQXhpcyhheGlzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKSB7CiAgICAgIGNvbnN0IGh1bGxBID0gdGhpczsKICAgICAgQ29udmV4UG9seWhlZHJvbi5wcm9qZWN0KGh1bGxBLCBheGlzLCBwb3NBLCBxdWF0QSwgbWF4bWluQSk7CiAgICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQiwgYXhpcywgcG9zQiwgcXVhdEIsIG1heG1pbkIpOwogICAgICBjb25zdCBtYXhBID0gbWF4bWluQVswXTsKICAgICAgY29uc3QgbWluQSA9IG1heG1pbkFbMV07CiAgICAgIGNvbnN0IG1heEIgPSBtYXhtaW5CWzBdOwogICAgICBjb25zdCBtaW5CID0gbWF4bWluQlsxXTsKCiAgICAgIGlmIChtYXhBIDwgbWluQiB8fCBtYXhCIDwgbWluQSkgewogICAgICAgIHJldHVybiBmYWxzZTsgLy8gU2VwYXJhdGVkCiAgICAgIH0KCiAgICAgIGNvbnN0IGQwID0gbWF4QSAtIG1pbkI7CiAgICAgIGNvbnN0IGQxID0gbWF4QiAtIG1pbkE7CiAgICAgIGNvbnN0IGRlcHRoID0gZDAgPCBkMSA/IGQwIDogZDE7CiAgICAgIHJldHVybiBkZXB0aDsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlTG9jYWxJbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhCiAgICAgIC8vIEV4YWN0IGluZXJ0aWEgY2FsY3VsYXRpb24gaXMgb3ZlcmtpbGwsIGJ1dCBzZWUgaHR0cDovL2dlb21ldHJpY3Rvb2xzLmNvbS9Eb2N1bWVudGF0aW9uL1BvbHloZWRyYWxNYXNzUHJvcGVydGllcy5wZGYgZm9yIHRoZSBjb3JyZWN0IHdheSB0byBkbyBpdAogICAgICBjb25zdCBhYWJibWF4ID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgYWFiYm1pbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQihhYWJibWluLCBhYWJibWF4KTsKICAgICAgY29uc3QgeCA9IGFhYmJtYXgueCAtIGFhYmJtaW4ueDsKICAgICAgY29uc3QgeSA9IGFhYmJtYXgueSAtIGFhYmJtaW4ueTsKICAgICAgY29uc3QgeiA9IGFhYmJtYXgueiAtIGFhYmJtaW4uejsKICAgICAgdGFyZ2V0LnggPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHogKiAyICogeik7CiAgICAgIHRhcmdldC55ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIHggKiAyICogeCArIDIgKiB6ICogMiAqIHopOwogICAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB5ICogMiAqIHkgKyAyICogeCAqIDIgKiB4KTsKICAgIH0KICAgIC8qKgogICAgICogQHBhcmFtIGZhY2VfaSBJbmRleCBvZiB0aGUgZmFjZQogICAgICovCgoKICAgIGdldFBsYW5lQ29uc3RhbnRPZkZhY2UoZmFjZV9pKSB7CiAgICAgIGNvbnN0IGYgPSB0aGlzLmZhY2VzW2ZhY2VfaV07CiAgICAgIGNvbnN0IG4gPSB0aGlzLmZhY2VOb3JtYWxzW2ZhY2VfaV07CiAgICAgIGNvbnN0IHYgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dOwogICAgICBjb25zdCBjID0gLW4uZG90KHYpOwogICAgICByZXR1cm4gYzsKICAgIH0KICAgIC8qKgogICAgICogQ2xpcCBhIGZhY2UgYWdhaW5zdCBhIGh1bGwuCiAgICAgKiBAcGFyYW0gd29ybGRWZXJ0c0IxIEFuIGFycmF5IG9mIFZlYzMgd2l0aCB2ZXJ0aWNlcyBpbiB0aGUgd29ybGQgZnJhbWUuCiAgICAgKiBAcGFyYW0gbWluRGlzdCBEaXN0YW5jZSBjbGFtcGluZwogICAgICogQHBhcmFtIEFycmF5IHJlc3VsdCBBcnJheSB0byBzdG9yZSByZXN1bHRpbmcgY29udGFjdCBwb2ludHMgaW4uIFdpbGwgYmUgb2JqZWN0cyB3aXRoIHByb3BlcnRpZXM6IHBvaW50LCBkZXB0aCwgbm9ybWFsLiBUaGVzZSBhcmUgcmVwcmVzZW50ZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKi8KCgogICAgY2xpcEZhY2VBZ2FpbnN0SHVsbChzZXBhcmF0aW5nTm9ybWFsLCBwb3NBLCBxdWF0QSwgd29ybGRWZXJ0c0IxLCBtaW5EaXN0LCBtYXhEaXN0LCByZXN1bHQpIHsKICAgICAgY29uc3QgZmFjZUFOb3JtYWxXUyA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGVkZ2UwID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgV29ybGRFZGdlMCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHdvcmxkUGxhbmVBbm9ybWFsMSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHBsYW5lTm9ybWFsV1MxID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3Qgd29ybGRBMSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGxvY2FsUGxhbmVOb3JtYWwgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBwbGFuZU5vcm1hbFdTID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgaHVsbEEgPSB0aGlzOwogICAgICBjb25zdCB3b3JsZFZlcnRzQjIgPSBbXTsKICAgICAgY29uc3QgcFZ0eEluID0gd29ybGRWZXJ0c0IxOwogICAgICBjb25zdCBwVnR4T3V0ID0gd29ybGRWZXJ0c0IyOwogICAgICBsZXQgY2xvc2VzdEZhY2VBID0gLTE7CiAgICAgIGxldCBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gRmluZCB0aGUgZmFjZSB3aXRoIG5vcm1hbCBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXMKCiAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgaHVsbEEuZmFjZXMubGVuZ3RoOyBmYWNlKyspIHsKICAgICAgICBmYWNlQU5vcm1hbFdTLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmFjZV0pOwogICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MsIGZhY2VBTm9ybWFsV1MpOwogICAgICAgIGNvbnN0IGQgPSBmYWNlQU5vcm1hbFdTLmRvdChzZXBhcmF0aW5nTm9ybWFsKTsKCiAgICAgICAgaWYgKGQgPCBkbWluKSB7CiAgICAgICAgICBkbWluID0gZDsKICAgICAgICAgIGNsb3Nlc3RGYWNlQSA9IGZhY2U7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoY2xvc2VzdEZhY2VBIDwgMCkgewogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBHZXQgdGhlIGZhY2UgYW5kIGNvbnN0cnVjdCBjb25uZWN0ZWQgZmFjZXMKCgogICAgICBjb25zdCBwb2x5QSA9IGh1bGxBLmZhY2VzW2Nsb3Nlc3RGYWNlQV07CiAgICAgIHBvbHlBLmNvbm5lY3RlZEZhY2VzID0gW107CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGh1bGxBLmZhY2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBodWxsQS5mYWNlc1tpXS5sZW5ndGg7IGorKykgewogICAgICAgICAgaWYgKAogICAgICAgICAgLyogU2hhcmluZyBhIHZlcnRleCovCiAgICAgICAgICBwb2x5QS5pbmRleE9mKGh1bGxBLmZhY2VzW2ldW2pdKSAhPT0gLTEgJiYKICAgICAgICAgIC8qIE5vdCB0aGUgb25lIHdlIGFyZSBsb29raW5nIGZvciBjb25uZWN0aW9ucyBmcm9tICovCiAgICAgICAgICBpICE9PSBjbG9zZXN0RmFjZUEgJiYKICAgICAgICAgIC8qIE5vdCBhbHJlYWR5IGFkZGVkICovCiAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKGkpID09PSAtMSkgewogICAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5wdXNoKGkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyBDbGlwIHRoZSBwb2x5Z29uIHRvIHRoZSBiYWNrIG9mIHRoZSBwbGFuZXMgb2YgYWxsIGZhY2VzIG9mIGh1bGwgQSwKICAgICAgLy8gdGhhdCBhcmUgYWRqYWNlbnQgdG8gdGhlIHdpdG5lc3MgZmFjZQoKCiAgICAgIGNvbnN0IG51bVZlcnRpY2VzQSA9IHBvbHlBLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXNBOyBpKyspIHsKICAgICAgICBjb25zdCBhID0gaHVsbEEudmVydGljZXNbcG9seUFbaV1dOwogICAgICAgIGNvbnN0IGIgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVsoaSArIDEpICUgbnVtVmVydGljZXNBXV07CiAgICAgICAgYS52c3ViKGIsIGVkZ2UwKTsKICAgICAgICBXb3JsZEVkZ2UwLmNvcHkoZWRnZTApOwogICAgICAgIHF1YXRBLnZtdWx0KFdvcmxkRWRnZTAsIFdvcmxkRWRnZTApOwogICAgICAgIHBvc0EudmFkZChXb3JsZEVkZ2UwLCBXb3JsZEVkZ2UwKTsKICAgICAgICB3b3JsZFBsYW5lQW5vcm1hbDEuY29weSh0aGlzLmZhY2VOb3JtYWxzW2Nsb3Nlc3RGYWNlQV0pOwogICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkUGxhbmVBbm9ybWFsMSwgd29ybGRQbGFuZUFub3JtYWwxKTsKICAgICAgICBwb3NBLnZhZGQod29ybGRQbGFuZUFub3JtYWwxLCB3b3JsZFBsYW5lQW5vcm1hbDEpOwogICAgICAgIFdvcmxkRWRnZTAuY3Jvc3Mod29ybGRQbGFuZUFub3JtYWwxLCBwbGFuZU5vcm1hbFdTMSk7CiAgICAgICAgcGxhbmVOb3JtYWxXUzEubmVnYXRlKHBsYW5lTm9ybWFsV1MxKTsKICAgICAgICB3b3JsZEExLmNvcHkoYSk7CiAgICAgICAgcXVhdEEudm11bHQod29ybGRBMSwgd29ybGRBMSk7CiAgICAgICAgcG9zQS52YWRkKHdvcmxkQTEsIHdvcmxkQTEpOwogICAgICAgIGNvbnN0IG90aGVyRmFjZSA9IHBvbHlBLmNvbm5lY3RlZEZhY2VzW2ldOwogICAgICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW290aGVyRmFjZV0pOwogICAgICAgIGNvbnN0IGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShvdGhlckZhY2UpOwogICAgICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTsKICAgICAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLCBwbGFuZU5vcm1hbFdTKTsKICAgICAgICBjb25zdCBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTsgLy8gQ2xpcCBmYWNlIGFnYWluc3Qgb3VyIGNvbnN0cnVjdGVkIHBsYW5lCgogICAgICAgIHRoaXMuY2xpcEZhY2VBZ2FpbnN0UGxhbmUocFZ0eEluLCBwVnR4T3V0LCBwbGFuZU5vcm1hbFdTLCBwbGFuZUVxV1MpOyAvLyBUaHJvdyBhd2F5IGFsbCBjbGlwcGVkIHBvaW50cywgYnV0IHNhdmUgdGhlIHJlbWFpbmluZyB1bnRpbCBuZXh0IGNsaXAKCiAgICAgICAgd2hpbGUgKHBWdHhJbi5sZW5ndGgpIHsKICAgICAgICAgIHBWdHhJbi5zaGlmdCgpOwogICAgICAgIH0KCiAgICAgICAgd2hpbGUgKHBWdHhPdXQubGVuZ3RoKSB7CiAgICAgICAgICBwVnR4SW4ucHVzaChwVnR4T3V0LnNoaWZ0KCkpOwogICAgICAgIH0KICAgICAgfSAvLyBvbmx5IGtlZXAgY29udGFjdCBwb2ludHMgdGhhdCBhcmUgYmVoaW5kIHRoZSB3aXRuZXNzIGZhY2UKCgogICAgICBsb2NhbFBsYW5lTm9ybWFsLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tjbG9zZXN0RmFjZUFdKTsKICAgICAgY29uc3QgbG9jYWxQbGFuZUVxID0gdGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKGNsb3Nlc3RGYWNlQSk7CiAgICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTsKICAgICAgcXVhdEEudm11bHQocGxhbmVOb3JtYWxXUywgcGxhbmVOb3JtYWxXUyk7CiAgICAgIGNvbnN0IHBsYW5lRXFXUyA9IGxvY2FsUGxhbmVFcSAtIHBsYW5lTm9ybWFsV1MuZG90KHBvc0EpOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwVnR4SW4ubGVuZ3RoOyBpKyspIHsKICAgICAgICBsZXQgZGVwdGggPSBwbGFuZU5vcm1hbFdTLmRvdChwVnR4SW5baV0pICsgcGxhbmVFcVdTOyAvLyA/Pz8KCiAgICAgICAgaWYgKGRlcHRoIDw9IG1pbkRpc3QpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKGBjbGFtcGVkOiBkZXB0aD0ke2RlcHRofSB0byBtaW5EaXN0PSR7bWluRGlzdH1gKTsKICAgICAgICAgIGRlcHRoID0gbWluRGlzdDsKICAgICAgICB9CgogICAgICAgIGlmIChkZXB0aCA8PSBtYXhEaXN0KSB7CiAgICAgICAgICBjb25zdCBwb2ludCA9IHBWdHhJbltpXTsKCiAgICAgICAgICBpZiAoZGVwdGggPD0gMWUtNikgewogICAgICAgICAgICBjb25zdCBwID0gewogICAgICAgICAgICAgIHBvaW50LAogICAgICAgICAgICAgIG5vcm1hbDogcGxhbmVOb3JtYWxXUywKICAgICAgICAgICAgICBkZXB0aAogICAgICAgICAgICB9OwogICAgICAgICAgICByZXN1bHQucHVzaChwKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2xpcCBhIGZhY2UgaW4gYSBodWxsIGFnYWluc3QgdGhlIGJhY2sgb2YgYSBwbGFuZS4KICAgICAqIEBwYXJhbSBwbGFuZUNvbnN0YW50IFRoZSBjb25zdGFudCBpbiB0aGUgbWF0aGVtYXRpY2FsIHBsYW5lIGVxdWF0aW9uCiAgICAgKi8KCgogICAgY2xpcEZhY2VBZ2FpbnN0UGxhbmUoaW5WZXJ0aWNlcywgb3V0VmVydGljZXMsIHBsYW5lTm9ybWFsLCBwbGFuZUNvbnN0YW50KSB7CiAgICAgIGxldCBuX2RvdF9maXJzdDsKICAgICAgbGV0IG5fZG90X2xhc3Q7CiAgICAgIGNvbnN0IG51bVZlcnRzID0gaW5WZXJ0aWNlcy5sZW5ndGg7CgogICAgICBpZiAobnVtVmVydHMgPCAyKSB7CiAgICAgICAgcmV0dXJuIG91dFZlcnRpY2VzOwogICAgICB9CgogICAgICBsZXQgZmlyc3RWZXJ0ZXggPSBpblZlcnRpY2VzW2luVmVydGljZXMubGVuZ3RoIC0gMV07CiAgICAgIGxldCBsYXN0VmVydGV4ID0gaW5WZXJ0aWNlc1swXTsKICAgICAgbl9kb3RfZmlyc3QgPSBwbGFuZU5vcm1hbC5kb3QoZmlyc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDsKCiAgICAgIGZvciAobGV0IHZpID0gMDsgdmkgPCBudW1WZXJ0czsgdmkrKykgewogICAgICAgIGxhc3RWZXJ0ZXggPSBpblZlcnRpY2VzW3ZpXTsKICAgICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDsKCiAgICAgICAgaWYgKG5fZG90X2ZpcnN0IDwgMCkgewogICAgICAgICAgaWYgKG5fZG90X2xhc3QgPCAwKSB7CiAgICAgICAgICAgIC8vIFN0YXJ0IDwgMCwgZW5kIDwgMCwgc28gb3V0cHV0IGxhc3RWZXJ0ZXgKICAgICAgICAgICAgY29uc3QgbmV3diA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIG5ld3YuY29weShsYXN0VmVydGV4KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIFN0YXJ0IDwgMCwgZW5kID49IDAsIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24KICAgICAgICAgICAgY29uc3QgbmV3diA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCwgbl9kb3RfZmlyc3QgLyAobl9kb3RfZmlyc3QgLSBuX2RvdF9sYXN0KSwgbmV3dik7CiAgICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChuX2RvdF9sYXN0IDwgMCkgewogICAgICAgICAgICAvLyBTdGFydCA+PSAwLCBlbmQgPCAwIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24gYW5kIGVuZAogICAgICAgICAgICBjb25zdCBuZXd2ID0gbmV3IFZlYzMoKTsKICAgICAgICAgICAgZmlyc3RWZXJ0ZXgubGVycChsYXN0VmVydGV4LCBuX2RvdF9maXJzdCAvIChuX2RvdF9maXJzdCAtIG5fZG90X2xhc3QpLCBuZXd2KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChsYXN0VmVydGV4KTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZpcnN0VmVydGV4ID0gbGFzdFZlcnRleDsKICAgICAgICBuX2RvdF9maXJzdCA9IG5fZG90X2xhc3Q7CiAgICAgIH0KCiAgICAgIHJldHVybiBvdXRWZXJ0aWNlczsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyBgLndvcmxkVmVydGljZXNgIGFuZCBzZXRzIGAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlYCB0byBmYWxzZS4KICAgICAqLwoKCiAgICBjb21wdXRlV29ybGRWZXJ0aWNlcyhwb3NpdGlvbiwgcXVhdCkgewogICAgICB3aGlsZSAodGhpcy53b3JsZFZlcnRpY2VzLmxlbmd0aCA8IHRoaXMudmVydGljZXMubGVuZ3RoKSB7CiAgICAgICAgdGhpcy53b3JsZFZlcnRpY2VzLnB1c2gobmV3IFZlYzMoKSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsKICAgICAgY29uc3Qgd29ybGRWZXJ0cyA9IHRoaXMud29ybGRWZXJ0aWNlczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgcXVhdC52bXVsdCh2ZXJ0c1tpXSwgd29ybGRWZXJ0c1tpXSk7CiAgICAgICAgcG9zaXRpb24udmFkZCh3b3JsZFZlcnRzW2ldLCB3b3JsZFZlcnRzW2ldKTsKICAgICAgfQoKICAgICAgdGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgPSBmYWxzZTsKICAgIH0KCiAgICBjb21wdXRlTG9jYWxBQUJCKGFhYmJtaW4sIGFhYmJtYXgpIHsKICAgICAgY29uc3QgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBhYWJibWluLnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTsKICAgICAgYWFiYm1heC5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gdmVydGljZXNbaV07CgogICAgICAgIGlmICh2LnggPCBhYWJibWluLngpIHsKICAgICAgICAgIGFhYmJtaW4ueCA9IHYueDsKICAgICAgICB9IGVsc2UgaWYgKHYueCA+IGFhYmJtYXgueCkgewogICAgICAgICAgYWFiYm1heC54ID0gdi54OwogICAgICAgIH0KCiAgICAgICAgaWYgKHYueSA8IGFhYmJtaW4ueSkgewogICAgICAgICAgYWFiYm1pbi55ID0gdi55OwogICAgICAgIH0gZWxzZSBpZiAodi55ID4gYWFiYm1heC55KSB7CiAgICAgICAgICBhYWJibWF4LnkgPSB2Lnk7CiAgICAgICAgfQoKICAgICAgICBpZiAodi56IDwgYWFiYm1pbi56KSB7CiAgICAgICAgICBhYWJibWluLnogPSB2Lno7CiAgICAgICAgfSBlbHNlIGlmICh2LnogPiBhYWJibWF4LnopIHsKICAgICAgICAgIGFhYmJtYXgueiA9IHYuejsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyBgd29ybGRWZXJ0aWNlc2AgYW5kIHNldHMgYHdvcmxkVmVydGljZXNOZWVkc1VwZGF0ZWAgdG8gZmFsc2UuCiAgICAgKi8KCgogICAgY29tcHV0ZVdvcmxkRmFjZU5vcm1hbHMocXVhdCkgewogICAgICBjb25zdCBOID0gdGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7CgogICAgICB3aGlsZSAodGhpcy53b3JsZEZhY2VOb3JtYWxzLmxlbmd0aCA8IE4pIHsKICAgICAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMucHVzaChuZXcgVmVjMygpKTsKICAgICAgfQoKICAgICAgY29uc3Qgbm9ybWFscyA9IHRoaXMuZmFjZU5vcm1hbHM7CiAgICAgIGNvbnN0IHdvcmxkTm9ybWFscyA9IHRoaXMud29ybGRGYWNlTm9ybWFsczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBxdWF0LnZtdWx0KG5vcm1hbHNbaV0sIHdvcmxkTm9ybWFsc1tpXSk7CiAgICAgIH0KCiAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXIKICAgICAgbGV0IG1heDIgPSAwOwogICAgICBjb25zdCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBub3JtMiA9IHZlcnRzW2ldLmxlbmd0aFNxdWFyZWQoKTsKCiAgICAgICAgaWYgKG5vcm0yID4gbWF4MikgewogICAgICAgICAgbWF4MiA9IG5vcm0yOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE1hdGguc3FydChtYXgyKTsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlV29ybGRBQUJCCiAgICAgKi8KCgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgY29uc3QgdmVydHMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBsZXQgbWlueDsKICAgICAgbGV0IG1pbnk7CiAgICAgIGxldCBtaW56OwogICAgICBsZXQgbWF4eDsKICAgICAgbGV0IG1heHk7CiAgICAgIGxldCBtYXh6OwogICAgICBsZXQgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICB0ZW1wV29ybGRWZXJ0ZXguY29weSh2ZXJ0c1tpXSk7CiAgICAgICAgcXVhdC52bXVsdCh0ZW1wV29ybGRWZXJ0ZXgsIHRlbXBXb3JsZFZlcnRleCk7CiAgICAgICAgcG9zLnZhZGQodGVtcFdvcmxkVmVydGV4LCB0ZW1wV29ybGRWZXJ0ZXgpOwogICAgICAgIGNvbnN0IHYgPSB0ZW1wV29ybGRWZXJ0ZXg7CgogICAgICAgIGlmIChtaW54ID09PSB1bmRlZmluZWQgfHwgdi54IDwgbWlueCkgewogICAgICAgICAgbWlueCA9IHYueDsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh4ID09PSB1bmRlZmluZWQgfHwgdi54ID4gbWF4eCkgewogICAgICAgICAgbWF4eCA9IHYueDsKICAgICAgICB9CgogICAgICAgIGlmIChtaW55ID09PSB1bmRlZmluZWQgfHwgdi55IDwgbWlueSkgewogICAgICAgICAgbWlueSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh5ID09PSB1bmRlZmluZWQgfHwgdi55ID4gbWF4eSkgewogICAgICAgICAgbWF4eSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmIChtaW56ID09PSB1bmRlZmluZWQgfHwgdi56IDwgbWlueikgewogICAgICAgICAgbWlueiA9IHYuejsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh6ID09PSB1bmRlZmluZWQgfHwgdi56ID4gbWF4eikgewogICAgICAgICAgbWF4eiA9IHYuejsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIG1pbi5zZXQobWlueCwgbWlueSwgbWlueik7CiAgICAgIG1heC5zZXQobWF4eCwgbWF4eSwgbWF4eik7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhcHByb3hpbWF0ZSBjb252ZXggdm9sdW1lCiAgICAgKi8KCgogICAgdm9sdW1lKCkgewogICAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgLyAzLjA7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBhdmVyYWdlIG9mIGFsbCB0aGUgdmVydGljZXMgcG9zaXRpb25zCiAgICAgKi8KCgogICAgZ2V0QXZlcmFnZVBvaW50TG9jYWwodGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICB0YXJnZXQudmFkZCh2ZXJ0c1tpXSwgdGFyZ2V0KTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnNjYWxlKDEgLyB2ZXJ0cy5sZW5ndGgsIHRhcmdldCk7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIFRyYW5zZm9ybSBhbGwgbG9jYWwgcG9pbnRzLiBXaWxsIGNoYW5nZSB0aGUgLnZlcnRpY2VzCiAgICAgKi8KCgogICAgdHJhbnNmb3JtQWxsUG9pbnRzKG9mZnNldCwgcXVhdCkgewogICAgICBjb25zdCBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7CiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsgLy8gQXBwbHkgcm90YXRpb24KCiAgICAgIGlmIChxdWF0KSB7CiAgICAgICAgLy8gUm90YXRlIHZlcnRpY2VzCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHYgPSB2ZXJ0c1tpXTsKICAgICAgICAgIHF1YXQudm11bHQodiwgdik7CiAgICAgICAgfSAvLyBSb3RhdGUgZmFjZSBub3JtYWxzCgoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmZhY2VOb3JtYWxzW2ldOwogICAgICAgICAgcXVhdC52bXVsdCh2LCB2KTsKICAgICAgICB9CiAgICAgICAgLyoKICAgICAgICAgICAgICAvLyBSb3RhdGUgZWRnZXMKICAgICAgICAgICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgaSsrKXsKICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMudW5pcXVlRWRnZXNbaV07CiAgICAgICAgICAgICAgICAgIHF1YXQudm11bHQodix2KTsKICAgICAgICAgICAgICB9Ki8KCiAgICAgIH0gLy8gQXBwbHkgb2Zmc2V0CgoKICAgICAgaWYgKG9mZnNldCkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7CiAgICAgICAgICBjb25zdCB2ID0gdmVydHNbaV07CiAgICAgICAgICB2LnZhZGQob2Zmc2V0LCB2KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgcCBpcyBpbnNpZGUgdGhlIHBvbHloZWRyYS4gTXVzdCBiZSBpbiBsb2NhbCBjb29yZHMuCiAgICAgKiBUaGUgcG9pbnQgbGllcyBvdXRzaWRlIG9mIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgb3RoZXIgcG9pbnRzIGlmIGFuZCBvbmx5IGlmIHRoZSBkaXJlY3Rpb24KICAgICAqIG9mIGFsbCB0aGUgdmVjdG9ycyBmcm9tIGl0IHRvIHRob3NlIG90aGVyIHBvaW50cyBhcmUgb24gbGVzcyB0aGFuIG9uZSBoYWxmIG9mIGEgc3BoZXJlIGFyb3VuZCBpdC4KICAgICAqIEBwYXJhbSBwIEEgcG9pbnQgZ2l2ZW4gaW4gbG9jYWwgY29vcmRpbmF0ZXMKICAgICAqLwoKCiAgICBwb2ludElzSW5zaWRlKHApIHsKICAgICAgY29uc3QgdmVydHMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBjb25zdCBmYWNlcyA9IHRoaXMuZmFjZXM7CiAgICAgIGNvbnN0IG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzOwogICAgICBjb25zdCBwb3NpdGl2ZVJlc3VsdCA9IG51bGw7CiAgICAgIGNvbnN0IHBvaW50SW5zaWRlID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5nZXRBdmVyYWdlUG9pbnRMb2NhbChwb2ludEluc2lkZSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBsZXQgbiA9IG5vcm1hbHNbaV07CiAgICAgICAgY29uc3QgdiA9IHZlcnRzW2ZhY2VzW2ldWzBdXTsgLy8gV2Ugb25seSBuZWVkIG9uZSBwb2ludCBpbiB0aGUgZmFjZQogICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpcwoKICAgICAgICBjb25zdCB2VG9QID0gbmV3IFZlYzMoKTsKICAgICAgICBwLnZzdWIodiwgdlRvUCk7CiAgICAgICAgY29uc3QgcjEgPSBuLmRvdCh2VG9QKTsKICAgICAgICBjb25zdCB2VG9Qb2ludEluc2lkZSA9IG5ldyBWZWMzKCk7CiAgICAgICAgcG9pbnRJbnNpZGUudnN1Yih2LCB2VG9Qb2ludEluc2lkZSk7CiAgICAgICAgY29uc3QgcjIgPSBuLmRvdCh2VG9Qb2ludEluc2lkZSk7CgogICAgICAgIGlmIChyMSA8IDAgJiYgcjIgPiAwIHx8IHIxID4gMCAmJiByMiA8IDApIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRW5jb3VudGVyZWQgc29tZSBvdGhlciBzaWduLiBFeGl0LgogICAgICAgIH0KICAgICAgfSAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uCgoKICAgICAgcmV0dXJuIHBvc2l0aXZlUmVzdWx0ID8gMSA6IC0xOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgbWF4IGFuZCBtaW4gZG90IHByb2R1Y3Qgb2YgYSBjb252ZXggaHVsbCBhdCBwb3NpdGlvbiAocG9zLHF1YXQpIHByb2plY3RlZCBvbnRvIGFuIGF4aXMuCiAgICAgKiBSZXN1bHRzIGFyZSBzYXZlZCBpbiB0aGUgYXJyYXkgbWF4bWluLgogICAgICogQHBhcmFtIHJlc3VsdCByZXN1bHRbMF0gYW5kIHJlc3VsdFsxXSB3aWxsIGJlIHNldCB0byBtYXhpbXVtIGFuZCBtaW5pbXVtLCByZXNwZWN0aXZlbHkuCiAgICAgKi8KCgogICAgc3RhdGljIHByb2plY3Qoc2hhcGUsIGF4aXMsIHBvcywgcXVhdCwgcmVzdWx0KSB7CiAgICAgIGNvbnN0IG4gPSBzaGFwZS52ZXJ0aWNlcy5sZW5ndGg7CiAgICAgIGNvbnN0IGxvY2FsQXhpcyA9IHByb2plY3RfbG9jYWxBeGlzOwogICAgICBsZXQgbWF4ID0gMDsKICAgICAgbGV0IG1pbiA9IDA7CiAgICAgIGNvbnN0IGxvY2FsT3JpZ2luID0gcHJvamVjdF9sb2NhbE9yaWdpbjsKICAgICAgY29uc3QgdnMgPSBzaGFwZS52ZXJ0aWNlczsKICAgICAgbG9jYWxPcmlnaW4uc2V0WmVybygpOyAvLyBUcmFuc2Zvcm0gdGhlIGF4aXMgdG8gbG9jYWwKCiAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBheGlzLCBsb2NhbEF4aXMpOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBsb2NhbE9yaWdpbiwgbG9jYWxPcmlnaW4pOwogICAgICBjb25zdCBhZGQgPSBsb2NhbE9yaWdpbi5kb3QobG9jYWxBeGlzKTsKICAgICAgbWluID0gbWF4ID0gdnNbMF0uZG90KGxvY2FsQXhpcyk7CgogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykgewogICAgICAgIGNvbnN0IHZhbCA9IHZzW2ldLmRvdChsb2NhbEF4aXMpOwoKICAgICAgICBpZiAodmFsID4gbWF4KSB7CiAgICAgICAgICBtYXggPSB2YWw7CiAgICAgICAgfQoKICAgICAgICBpZiAodmFsIDwgbWluKSB7CiAgICAgICAgICBtaW4gPSB2YWw7CiAgICAgICAgfQogICAgICB9CgogICAgICBtaW4gLT0gYWRkOwogICAgICBtYXggLT0gYWRkOwoKICAgICAgaWYgKG1pbiA+IG1heCkgewogICAgICAgIC8vIEluY29uc2lzdGVudCAtIHN3YXAKICAgICAgICBjb25zdCB0ZW1wID0gbWluOwogICAgICAgIG1pbiA9IG1heDsKICAgICAgICBtYXggPSB0ZW1wOwogICAgICB9IC8vIE91dHB1dAoKCiAgICAgIHJlc3VsdFswXSA9IG1heDsKICAgICAgcmVzdWx0WzFdID0gbWluOwogICAgfQoKICB9CiAgY29uc3QgbWF4bWluQSA9IFtdOwogIGNvbnN0IG1heG1pbkIgPSBbXTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHByb2plY3RfbG9jYWxBeGlzID0gbmV3IFZlYzMoKTsKICBjb25zdCBwcm9qZWN0X2xvY2FsT3JpZ2luID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQSAzZCBib3ggc2hhcGUuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3Qgc2l6ZSA9IDEKICAgKiAgICAgY29uc3QgaGFsZkV4dGVudHMgPSBuZXcgQ0FOTk9OLlZlYzMoc2l6ZSwgc2l6ZSwgc2l6ZSkKICAgKiAgICAgY29uc3QgYm94U2hhcGUgPSBuZXcgQ0FOTk9OLkJveChoYWxmRXh0ZW50cykKICAgKiAgICAgY29uc3QgYm94Qm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBib3hTaGFwZSB9KQogICAqICAgICB3b3JsZC5hZGRCb2R5KGJveEJvZHkpCiAgICovCiAgY2xhc3MgQm94IGV4dGVuZHMgU2hhcGUgewogICAgLyoqCiAgICAgKiBUaGUgaGFsZiBleHRlbnRzIG9mIHRoZSBib3guCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZWQgYnkgdGhlIGNvbnRhY3QgZ2VuZXJhdG9yIHRvIG1ha2UgY29udGFjdHMgd2l0aCBvdGhlciBjb252ZXggcG9seWhlZHJhIGZvciBleGFtcGxlLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihoYWxmRXh0ZW50cykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuQk9YCiAgICAgIH0pOwogICAgICB0aGlzLmhhbGZFeHRlbnRzID0gaGFsZkV4dGVudHM7CiAgICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gbnVsbDsKICAgICAgdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBjb252ZXggcG9seWhlZHJvbiByZXByZXNlbnRhdGlvbiB1c2VkIGZvciBzb21lIGNvbGxpc2lvbnMuCiAgICAgKi8KCgogICAgdXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uKCkgewogICAgICBjb25zdCBzeCA9IHRoaXMuaGFsZkV4dGVudHMueDsKICAgICAgY29uc3Qgc3kgPSB0aGlzLmhhbGZFeHRlbnRzLnk7CiAgICAgIGNvbnN0IHN6ID0gdGhpcy5oYWxmRXh0ZW50cy56OwogICAgICBjb25zdCBWID0gVmVjMzsKICAgICAgY29uc3QgdmVydGljZXMgPSBbbmV3IFYoLXN4LCAtc3ksIC1zeiksIG5ldyBWKHN4LCAtc3ksIC1zeiksIG5ldyBWKHN4LCBzeSwgLXN6KSwgbmV3IFYoLXN4LCBzeSwgLXN6KSwgbmV3IFYoLXN4LCAtc3ksIHN6KSwgbmV3IFYoc3gsIC1zeSwgc3opLCBuZXcgVihzeCwgc3ksIHN6KSwgbmV3IFYoLXN4LCBzeSwgc3opXTsKICAgICAgY29uc3QgZmFjZXMgPSBbWzMsIDIsIDEsIDBdLCAvLyAtegogICAgICBbNCwgNSwgNiwgN10sIC8vICt6CiAgICAgIFs1LCA0LCAwLCAxXSwgLy8gLXkKICAgICAgWzIsIDMsIDcsIDZdLCAvLyAreQogICAgICBbMCwgNCwgNywgM10sIC8vIC14CiAgICAgIFsxLCAyLCA2LCA1XSAvLyAreAogICAgICBdOwogICAgICBjb25zdCBheGVzID0gW25ldyBWKDAsIDAsIDEpLCBuZXcgVigwLCAxLCAwKSwgbmV3IFYoMSwgMCwgMCldOwogICAgICBjb25zdCBoID0gbmV3IENvbnZleFBvbHloZWRyb24oewogICAgICAgIHZlcnRpY2VzLAogICAgICAgIGZhY2VzLAogICAgICAgIGF4ZXMKICAgICAgfSk7CiAgICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gaDsKICAgICAgaC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7CiAgICB9CiAgICAvKioKICAgICAqIENhbGN1bGF0ZSB0aGUgaW5lcnRpYSBvZiB0aGUgYm94LgogICAgICovCgoKICAgIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEodGhpcy5oYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KTsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KCiAgICBzdGF0aWMgY2FsY3VsYXRlSW5lcnRpYShoYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGUgPSBoYWxmRXh0ZW50czsKICAgICAgdGFyZ2V0LnggPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS55ICogMiAqIGUueSArIDIgKiBlLnogKiAyICogZS56KTsKICAgICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS54ICogMiAqIGUueCArIDIgKiBlLnogKiAyICogZS56KTsKICAgICAgdGFyZ2V0LnogPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS55ICogMiAqIGUueSArIDIgKiBlLnggKiAyICogZS54KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBib3ggNiBzaWRlIG5vcm1hbHMKICAgICAqIEBwYXJhbSBzaXhUYXJnZXRWZWN0b3JzIEFuIGFycmF5IG9mIDYgdmVjdG9ycywgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIG5vcm1hbHMgaW4uCiAgICAgKiBAcGFyYW0gcXVhdCBPcmllbnRhdGlvbiB0byBhcHBseSB0byB0aGUgbm9ybWFsIHZlY3RvcnMuIElmIG5vdCBwcm92aWRlZCwgdGhlIHZlY3RvcnMgd2lsbCBiZSBpbiByZXNwZWN0IHRvIHRoZSBsb2NhbCBmcmFtZS4KICAgICAqLwoKCiAgICBnZXRTaWRlTm9ybWFscyhzaXhUYXJnZXRWZWN0b3JzLCBxdWF0KSB7CiAgICAgIGNvbnN0IHNpZGVzID0gc2l4VGFyZ2V0VmVjdG9yczsKICAgICAgY29uc3QgZXggPSB0aGlzLmhhbGZFeHRlbnRzOwogICAgICBzaWRlc1swXS5zZXQoZXgueCwgMCwgMCk7CiAgICAgIHNpZGVzWzFdLnNldCgwLCBleC55LCAwKTsKICAgICAgc2lkZXNbMl0uc2V0KDAsIDAsIGV4LnopOwogICAgICBzaWRlc1szXS5zZXQoLWV4LngsIDAsIDApOwogICAgICBzaWRlc1s0XS5zZXQoMCwgLWV4LnksIDApOwogICAgICBzaWRlc1s1XS5zZXQoMCwgMCwgLWV4LnopOwoKICAgICAgaWYgKHF1YXQgIT09IHVuZGVmaW5lZCkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzaWRlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgcXVhdC52bXVsdChzaWRlc1tpXSwgc2lkZXNbaV0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHNpZGVzOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSB2b2x1bWUgb2YgdGhlIGJveC4KICAgICAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA4LjAgKiB0aGlzLmhhbGZFeHRlbnRzLnggKiB0aGlzLmhhbGZFeHRlbnRzLnkgKiB0aGlzLmhhbGZFeHRlbnRzLno7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLmhhbGZFeHRlbnRzLmxlbmd0aCgpOwogICAgfQogICAgLyoqCiAgICAgKiBmb3JFYWNoV29ybGRDb3JuZXIKICAgICAqLwoKCiAgICBmb3JFYWNoV29ybGRDb3JuZXIocG9zLCBxdWF0LCBjYWxsYmFjaykgewogICAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50czsKICAgICAgY29uc3QgY29ybmVycyA9IFtbZS54LCBlLnksIGUuel0sIFstZS54LCBlLnksIGUuel0sIFstZS54LCAtZS55LCBlLnpdLCBbLWUueCwgLWUueSwgLWUuel0sIFtlLngsIC1lLnksIC1lLnpdLCBbZS54LCBlLnksIC1lLnpdLCBbLWUueCwgZS55LCAtZS56XSwgW2UueCwgLWUueSwgZS56XV07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcm5lcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICB3b3JsZENvcm5lclRlbXBQb3Muc2V0KGNvcm5lcnNbaV1bMF0sIGNvcm5lcnNbaV1bMV0sIGNvcm5lcnNbaV1bMl0pOwogICAgICAgIHF1YXQudm11bHQod29ybGRDb3JuZXJUZW1wUG9zLCB3b3JsZENvcm5lclRlbXBQb3MpOwogICAgICAgIHBvcy52YWRkKHdvcmxkQ29ybmVyVGVtcFBvcywgd29ybGRDb3JuZXJUZW1wUG9zKTsKICAgICAgICBjYWxsYmFjayh3b3JsZENvcm5lclRlbXBQb3MueCwgd29ybGRDb3JuZXJUZW1wUG9zLnksIHdvcmxkQ29ybmVyVGVtcFBvcy56KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBjYWxjdWxhdGVXb3JsZEFBQkIKICAgICAqLwoKCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50czsKICAgICAgd29ybGRDb3JuZXJzVGVtcFswXS5zZXQoZS54LCBlLnksIGUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbMV0uc2V0KC1lLngsIGUueSwgZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFsyXS5zZXQoLWUueCwgLWUueSwgZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFszXS5zZXQoLWUueCwgLWUueSwgLWUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbNF0uc2V0KGUueCwgLWUueSwgLWUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbNV0uc2V0KGUueCwgZS55LCAtZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFs2XS5zZXQoLWUueCwgZS55LCAtZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFs3XS5zZXQoZS54LCAtZS55LCBlLnopOwogICAgICBjb25zdCB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbMF07CiAgICAgIHF1YXQudm11bHQod2MsIHdjKTsKICAgICAgcG9zLnZhZGQod2MsIHdjKTsKICAgICAgbWF4LmNvcHkod2MpOwogICAgICBtaW4uY29weSh3Yyk7CgogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykgewogICAgICAgIGNvbnN0IHdjID0gd29ybGRDb3JuZXJzVGVtcFtpXTsKICAgICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7CiAgICAgICAgcG9zLnZhZGQod2MsIHdjKTsKICAgICAgICBjb25zdCB4ID0gd2MueDsKICAgICAgICBjb25zdCB5ID0gd2MueTsKICAgICAgICBjb25zdCB6ID0gd2MuejsKCiAgICAgICAgaWYgKHggPiBtYXgueCkgewogICAgICAgICAgbWF4LnggPSB4OwogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPiBtYXgueSkgewogICAgICAgICAgbWF4LnkgPSB5OwogICAgICAgIH0KCiAgICAgICAgaWYgKHogPiBtYXgueikgewogICAgICAgICAgbWF4LnogPSB6OwogICAgICAgIH0KCiAgICAgICAgaWYgKHggPCBtaW4ueCkgewogICAgICAgICAgbWluLnggPSB4OwogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPCBtaW4ueSkgewogICAgICAgICAgbWluLnkgPSB5OwogICAgICAgIH0KCiAgICAgICAgaWYgKHogPCBtaW4ueikgewogICAgICAgICAgbWluLnogPSB6OwogICAgICAgIH0KICAgICAgfSAvLyBHZXQgZWFjaCBheGlzIG1heAogICAgICAvLyBtaW4uc2V0KEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTsKICAgICAgLy8gbWF4LnNldCgtSW5maW5pdHksLUluZmluaXR5LC1JbmZpbml0eSk7CiAgICAgIC8vIHRoaXMuZm9yRWFjaFdvcmxkQ29ybmVyKHBvcyxxdWF0LGZ1bmN0aW9uKHgseSx6KXsKICAgICAgLy8gICAgIGlmKHggPiBtYXgueCl7CiAgICAgIC8vICAgICAgICAgbWF4LnggPSB4OwogICAgICAvLyAgICAgfQogICAgICAvLyAgICAgaWYoeSA+IG1heC55KXsKICAgICAgLy8gICAgICAgICBtYXgueSA9IHk7CiAgICAgIC8vICAgICB9CiAgICAgIC8vICAgICBpZih6ID4gbWF4LnopewogICAgICAvLyAgICAgICAgIG1heC56ID0gejsKICAgICAgLy8gICAgIH0KICAgICAgLy8gICAgIGlmKHggPCBtaW4ueCl7CiAgICAgIC8vICAgICAgICAgbWluLnggPSB4OwogICAgICAvLyAgICAgfQogICAgICAvLyAgICAgaWYoeSA8IG1pbi55KXsKICAgICAgLy8gICAgICAgICBtaW4ueSA9IHk7CiAgICAgIC8vICAgICB9CiAgICAgIC8vICAgICBpZih6IDwgbWluLnopewogICAgICAvLyAgICAgICAgIG1pbi56ID0gejsKICAgICAgLy8gICAgIH0KICAgICAgLy8gfSk7CgogICAgfQoKICB9CiAgY29uc3Qgd29ybGRDb3JuZXJUZW1wUG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCB3b3JsZENvcm5lcnNUZW1wID0gW25ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCldOwoKICAvKioKICAgKiBCT0RZX1RZUEVTCiAgICovCiAgY29uc3QgQk9EWV9UWVBFUyA9IHsKICAgIC8qKiBEWU5BTUlDICovCiAgICBEWU5BTUlDOiAxLAoKICAgIC8qKiBTVEFUSUMgKi8KICAgIFNUQVRJQzogMiwKCiAgICAvKiogS0lORU1BVElDICovCiAgICBLSU5FTUFUSUM6IDQKICB9OwogIC8qKgogICAqIEJvZHlUeXBlCiAgICovCgogIC8qKgogICAqIEJPRFlfU0xFRVBfU1RBVEVTCiAgICovCiAgY29uc3QgQk9EWV9TTEVFUF9TVEFURVMgPSB7CiAgICAvKiogQVdBS0UgKi8KICAgIEFXQUtFOiAwLAoKICAgIC8qKiBTTEVFUFkgKi8KICAgIFNMRUVQWTogMSwKCiAgICAvKiogU0xFRVBJTkcgKi8KICAgIFNMRUVQSU5HOiAyCiAgfTsKICAvKioKICAgKiBCb2R5U2xlZXBTdGF0ZQogICAqLwoKICAvKioKICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgYm9keSB0eXBlcy4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBzaGFwZSA9IG5ldyBDQU5OT04uU3BoZXJlKDEpCiAgICogICAgIGNvbnN0IGJvZHkgPSBuZXcgQ0FOTk9OLkJvZHkoewogICAqICAgICAgIG1hc3M6IDEsCiAgICogICAgICAgc2hhcGUsCiAgICogICAgIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSkKICAgKi8KICBjbGFzcyBCb2R5IGV4dGVuZHMgRXZlbnRUYXJnZXQgewogICAgLyoqCiAgICAgKiBEaXNwYXRjaGVkIGFmdGVyIHR3byBib2RpZXMgY29sbGlkZS4gVGhpcyBldmVudCBpcyBkaXNwYXRjaGVkIG9uIGVhY2gKICAgICAqIG9mIHRoZSB0d28gYm9kaWVzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uCiAgICAgKiBAZXZlbnQgY29sbGlkZQogICAgICogQHBhcmFtIGJvZHkgVGhlIGJvZHkgdGhhdCB3YXMgaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvbi4KICAgICAqIEBwYXJhbSBjb250YWN0IFRoZSBkZXRhaWxzIG9mIHRoZSBjb2xsaXNpb24uCiAgICAgKi8KCiAgICAvKioKICAgICAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC4gQ2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBidXQgbm9ybWFsbHkgdGhleSBtb3ZlIGFjY29yZGluZyB0byBmb3JjZXMuIEEgZHluYW1pYyBib2R5IGNhbiBjb2xsaWRlIHdpdGggYWxsIGJvZHkgdHlwZXMuIEEgZHluYW1pYyBib2R5IGFsd2F5cyBoYXMgZmluaXRlLCBub24temVybyBtYXNzLgogICAgICovCgogICAgLyoqCiAgICAgKiBBIHN0YXRpYyBib2R5IGRvZXMgbm90IG1vdmUgZHVyaW5nIHNpbXVsYXRpb24gYW5kIGJlaGF2ZXMgYXMgaWYgaXQgaGFzIGluZmluaXRlIG1hc3MuIFN0YXRpYyBib2RpZXMgY2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHNldHRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5LiBUaGUgdmVsb2NpdHkgb2YgYSBzdGF0aWMgYm9keSBpcyBhbHdheXMgemVyby4gU3RhdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIHN0YXRpYyBvciBraW5lbWF0aWMgYm9kaWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBBIGtpbmVtYXRpYyBib2R5IG1vdmVzIHVuZGVyIHNpbXVsYXRpb24gYWNjb3JkaW5nIHRvIGl0cyB2ZWxvY2l0eS4gVGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMuIFRoZXkgY2FuIGJlIG1vdmVkIG1hbnVhbGx5LCBidXQgbm9ybWFsbHkgYSBraW5lbWF0aWMgYm9keSBpcyBtb3ZlZCBieSBzZXR0aW5nIGl0cyB2ZWxvY2l0eS4gQSBraW5lbWF0aWMgYm9keSBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFXQUtFCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNMRUVQWQogICAgICovCgogICAgLyoqCiAgICAgKiBTTEVFUElORwogICAgICovCgogICAgLyoqCiAgICAgKiBEaXNwYXRjaGVkIGFmdGVyIGEgc2xlZXBpbmcgYm9keSBoYXMgd29rZW4gdXAuCiAgICAgKiBAZXZlbnQgd2FrZXVwCiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBnb25lIGluIHRvIHRoZSBzbGVlcHkgc3RhdGUuCiAgICAgKiBAZXZlbnQgc2xlZXB5CiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBmYWxsZW4gYXNsZWVwLgogICAgICogQGV2ZW50IHNsZWVwCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pZCA9IEJvZHkuaWRDb3VudGVyKys7CiAgICAgIHRoaXMuaW5kZXggPSAtMTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMudmxhbWJkYSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Ygb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mIG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgOiAtMTsKICAgICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTsKICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmluaXRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbikgewogICAgICAgIHRoaXMucG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7CiAgICAgICAgdGhpcy5pbml0UG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgfQoKICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy52ZWxvY2l0eSkgewogICAgICAgIHRoaXMudmVsb2NpdHkuY29weShvcHRpb25zLnZlbG9jaXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmZvcmNlID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgbWFzcyA9IHR5cGVvZiBvcHRpb25zLm1hc3MgPT09ICdudW1iZXInID8gb3B0aW9ucy5tYXNzIDogMDsKICAgICAgdGhpcy5tYXNzID0gbWFzczsKICAgICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDsKICAgICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgfHwgbnVsbDsKICAgICAgdGhpcy5saW5lYXJEYW1waW5nID0gdHlwZW9mIG9wdGlvbnMubGluZWFyRGFtcGluZyA9PT0gJ251bWJlcicgPyBvcHRpb25zLmxpbmVhckRhbXBpbmcgOiAwLjAxOwogICAgICB0aGlzLnR5cGUgPSBtYXNzIDw9IDAuMCA/IEJvZHkuU1RBVElDIDogQm9keS5EWU5BTUlDOwoKICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgPT09IHR5cGVvZiBCb2R5LlNUQVRJQykgewogICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTsKICAgICAgfQoKICAgICAgdGhpcy5hbGxvd1NsZWVwID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dTbGVlcCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFsbG93U2xlZXAgOiB0cnVlOwogICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFOwogICAgICB0aGlzLnNsZWVwU3BlZWRMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCA6IDAuMTsKICAgICAgdGhpcy5zbGVlcFRpbWVMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnNsZWVwVGltZUxpbWl0ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc2xlZXBUaW1lTGltaXQgOiAxOwogICAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CiAgICAgIHRoaXMudG9ycXVlID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgdGhpcy5pbml0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgICAgIGlmIChvcHRpb25zLnF1YXRlcm5pb24pIHsKICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICAgIHRoaXMuaW5pdFF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTsKICAgICAgICB0aGlzLmludGVycG9sYXRlZFF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICB9CgogICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpIHsKICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5pbml0QW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5zaGFwZXMgPSBbXTsKICAgICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTsKICAgICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucyA9IFtdOwogICAgICB0aGlzLmluZXJ0aWEgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWEgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWFXb3JsZCA9IG5ldyBNYXQzKCk7CiAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDsKICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlID0gbmV3IE1hdDMoKTsKICAgICAgdGhpcy5maXhlZFJvdGF0aW9uID0gdHlwZW9mIG9wdGlvbnMuZml4ZWRSb3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmZpeGVkUm90YXRpb24gOiBmYWxzZTsKICAgICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZiBvcHRpb25zLmFuZ3VsYXJEYW1waW5nICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcgOiAwLjAxOwogICAgICB0aGlzLmxpbmVhckZhY3RvciA9IG5ldyBWZWMzKDEsIDEsIDEpOwoKICAgICAgaWYgKG9wdGlvbnMubGluZWFyRmFjdG9yKSB7CiAgICAgICAgdGhpcy5saW5lYXJGYWN0b3IuY29weShvcHRpb25zLmxpbmVhckZhY3Rvcik7CiAgICAgIH0KCiAgICAgIHRoaXMuYW5ndWxhckZhY3RvciA9IG5ldyBWZWMzKDEsIDEsIDEpOwoKICAgICAgaWYgKG9wdGlvbnMuYW5ndWxhckZhY3RvcikgewogICAgICAgIHRoaXMuYW5ndWxhckZhY3Rvci5jb3B5KG9wdGlvbnMuYW5ndWxhckZhY3Rvcik7CiAgICAgIH0KCiAgICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7CiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7CiAgICAgIHRoaXMud2xhbWJkYSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaXNUcmlnZ2VyID0gQm9vbGVhbihvcHRpb25zLmlzVHJpZ2dlcik7CgogICAgICBpZiAob3B0aW9ucy5zaGFwZSkgewogICAgICAgIHRoaXMuYWRkU2hhcGUob3B0aW9ucy5zaGFwZSk7CiAgICAgIH0KCiAgICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTsKICAgIH0KICAgIC8qKgogICAgICogV2FrZSB0aGUgYm9keSB1cC4KICAgICAqLwoKCiAgICB3YWtlVXAoKSB7CiAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc2xlZXBTdGF0ZTsKICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CgogICAgICBpZiAocHJldlN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSB7CiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEJvZHkud2FrZXVwRXZlbnQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEZvcmNlIGJvZHkgc2xlZXAKICAgICAqLwoKCiAgICBzbGVlcCgpIHsKICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORzsKICAgICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7CiAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnNldCgwLCAwLCAwKTsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuCiAgICAgKiBAcGFyYW0gdGltZSBUaGUgd29ybGQgdGltZSBpbiBzZWNvbmRzCiAgICAgKi8KCgogICAgc2xlZXBUaWNrKHRpbWUpIHsKICAgICAgaWYgKHRoaXMuYWxsb3dTbGVlcCkgewogICAgICAgIGNvbnN0IHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7CiAgICAgICAgY29uc3Qgc3BlZWRTcXVhcmVkID0gdGhpcy52ZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCkgKyB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCk7CiAgICAgICAgY29uc3Qgc3BlZWRMaW1pdFNxdWFyZWQgPSB0aGlzLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICBpZiAoc2xlZXBTdGF0ZSA9PT0gQm9keS5BV0FLRSAmJiBzcGVlZFNxdWFyZWQgPCBzcGVlZExpbWl0U3F1YXJlZCkgewogICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7IC8vIFNsZWVweQoKICAgICAgICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSB0aW1lOwogICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEJvZHkuc2xlZXB5RXZlbnQpOwogICAgICAgIH0gZWxzZSBpZiAoc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUFkgJiYgc3BlZWRTcXVhcmVkID4gc3BlZWRMaW1pdFNxdWFyZWQpIHsKICAgICAgICAgIHRoaXMud2FrZVVwKCk7IC8vIFdha2UgdXAKICAgICAgICB9IGVsc2UgaWYgKHNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBZICYmIHRpbWUgLSB0aGlzLnRpbWVMYXN0U2xlZXB5ID4gdGhpcy5zbGVlcFRpbWVMaW1pdCkgewogICAgICAgICAgdGhpcy5zbGVlcCgpOyAvLyBTbGVlcGluZwoKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5LnNsZWVwRXZlbnQpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBJZiB0aGUgYm9keSBpcyBzbGVlcGluZywgaXQgc2hvdWxkIGJlIGltbW92YWJsZSAvIGhhdmUgaW5maW5pdGUgbWFzcyBkdXJpbmcgc29sdmUuIFdlIHNvbHZlIGl0IGJ5IGhhdmluZyBhIHNlcGFyYXRlICJzb2x2ZSBtYXNzIi4KICAgICAqLwoKCiAgICB1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCkgewogICAgICBpZiAodGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpIHsKICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7CiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpOwogICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuc2V0WmVybygpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gdGhpcy5pbnZNYXNzOwogICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhKTsKICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLgogICAgICovCgoKICAgIHBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkUG9pbnQsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbiwgcmVzdWx0KTsKICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHJlc3VsdCwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCBhIHdvcmxkIHZlY3RvciB0byBsb2NhbCBib2R5IGZyYW1lLgogICAgICovCgoKICAgIHZlY3RvclRvTG9jYWxGcmFtZSh3b3JsZFZlY3RvciwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCBhIGxvY2FsIGJvZHkgcG9pbnQgdG8gd29ybGQgZnJhbWUuCiAgICAgKi8KCgogICAgcG9pbnRUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFBvaW50LCByZXN1bHQpOwogICAgICByZXN1bHQudmFkZCh0aGlzLnBvc2l0aW9uLCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS4KICAgICAqLwoKCiAgICB2ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5IHdpdGggYSBsb2NhbCBvZmZzZXQgYW5kIG9yaWVudGF0aW9uLgogICAgICogQHJldHVybiBUaGUgYm9keSBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuCiAgICAgKi8KCgogICAgYWRkU2hhcGUoc2hhcGUsIF9vZmZzZXQsIF9vcmllbnRhdGlvbikgewogICAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBvcmllbnRhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7CgogICAgICBpZiAoX29mZnNldCkgewogICAgICAgIG9mZnNldC5jb3B5KF9vZmZzZXQpOwogICAgICB9CgogICAgICBpZiAoX29yaWVudGF0aW9uKSB7CiAgICAgICAgb3JpZW50YXRpb24uY29weShfb3JpZW50YXRpb24pOwogICAgICB9CgogICAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlKTsKICAgICAgdGhpcy5zaGFwZU9mZnNldHMucHVzaChvZmZzZXQpOwogICAgICB0aGlzLnNoYXBlT3JpZW50YXRpb25zLnB1c2gob3JpZW50YXRpb24pOwogICAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7CiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTsKICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlOwogICAgICBzaGFwZS5ib2R5ID0gdGhpczsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZSBhIHNoYXBlIGZyb20gdGhlIGJvZHkuCiAgICAgKiBAcmV0dXJuIFRoZSBib2R5IG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS4KICAgICAqLwoKCiAgICByZW1vdmVTaGFwZShzaGFwZSkgewogICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2hhcGVzLmluZGV4T2Yoc2hhcGUpOwoKICAgICAgaWYgKGluZGV4ID09PSAtMSkgewogICAgICAgIGNvbnNvbGUud2FybignU2hhcGUgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBib2R5Jyk7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIHRoaXMuc2hhcGVzLnNwbGljZShpbmRleCwgMSk7CiAgICAgIHRoaXMuc2hhcGVPZmZzZXRzLnNwbGljZShpbmRleCwgMSk7CiAgICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpOwogICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7CiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgc2hhcGUuYm9keSA9IG51bGw7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZXMgYXJlIGNoYW5nZWQuCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdSYWRpdXMoKSB7CiAgICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc2hhcGVzOwogICAgICBjb25zdCBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0czsKICAgICAgY29uc3QgTiA9IHNoYXBlcy5sZW5ndGg7CiAgICAgIGxldCByYWRpdXMgPSAwOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldOwogICAgICAgIHNoYXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc2hhcGVPZmZzZXRzW2ldLmxlbmd0aCgpOwogICAgICAgIGNvbnN0IHIgPSBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1czsKCiAgICAgICAgaWYgKG9mZnNldCArIHIgPiByYWRpdXMpIHsKICAgICAgICAgIHJhZGl1cyA9IG9mZnNldCArIHI7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gcmFkaXVzOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGVzIHRoZSAuYWFiYgogICAgICovCgoKICAgIHVwZGF0ZUFBQkIoKSB7CiAgICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc2hhcGVzOwogICAgICBjb25zdCBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0czsKICAgICAgY29uc3Qgc2hhcGVPcmllbnRhdGlvbnMgPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zOwogICAgICBjb25zdCBOID0gc2hhcGVzLmxlbmd0aDsKICAgICAgY29uc3Qgb2Zmc2V0ID0gdG1wVmVjOwogICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRtcFF1YXQ7CiAgICAgIGNvbnN0IGJvZHlRdWF0ID0gdGhpcy5xdWF0ZXJuaW9uOwogICAgICBjb25zdCBhYWJiID0gdGhpcy5hYWJiOwogICAgICBjb25zdCBzaGFwZUFBQkIgPSB1cGRhdGVBQUJCX3NoYXBlQUFCQjsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBzaGFwZSA9IHNoYXBlc1tpXTsgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uCgogICAgICAgIGJvZHlRdWF0LnZtdWx0KHNoYXBlT2Zmc2V0c1tpXSwgb2Zmc2V0KTsKICAgICAgICBvZmZzZXQudmFkZCh0aGlzLnBvc2l0aW9uLCBvZmZzZXQpOyAvLyBHZXQgc2hhcGUgd29ybGQgcXVhdGVybmlvbgoKICAgICAgICBib2R5UXVhdC5tdWx0KHNoYXBlT3JpZW50YXRpb25zW2ldLCBvcmllbnRhdGlvbik7IC8vIEdldCBzaGFwZSBBQUJCCgogICAgICAgIHNoYXBlLmNhbGN1bGF0ZVdvcmxkQUFCQihvZmZzZXQsIG9yaWVudGF0aW9uLCBzaGFwZUFBQkIubG93ZXJCb3VuZCwgc2hhcGVBQUJCLnVwcGVyQm91bmQpOwoKICAgICAgICBpZiAoaSA9PT0gMCkgewogICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGFhYmIuZXh0ZW5kKHNoYXBlQUFCQik7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgYC5pbmVydGlhV29ybGRgIGFuZCBgLmludkluZXJ0aWFXb3JsZGAKICAgICAqLwoKCiAgICB1cGRhdGVJbmVydGlhV29ybGQoZm9yY2UpIHsKICAgICAgY29uc3QgSSA9IHRoaXMuaW52SW5lcnRpYTsKCiAgICAgIGlmIChJLnggPT09IEkueSAmJiBJLnkgPT09IEkueiAmJiAhZm9yY2UpIDsgZWxzZSB7CiAgICAgICAgY29uc3QgbTEgPSB1aXdfbTE7CiAgICAgICAgY29uc3QgbTIgPSB1aXdfbTI7CiAgICAgICAgbTEuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pOwogICAgICAgIG0xLnRyYW5zcG9zZShtMik7CiAgICAgICAgbTEuc2NhbGUoSSwgbTEpOwogICAgICAgIG0xLm1tdWx0KG0yLCB0aGlzLmludkluZXJ0aWFXb3JsZCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQXBwbHkgZm9yY2UgdG8gYSBwb2ludCBvZiB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuCiAgICAgKiBBcHBseWluZyBmb3JjZSB0aGlzIHdheSB3aWxsIGFkZCB0byBCb2R5LmZvcmNlIGFuZCBCb2R5LnRvcnF1ZS4KICAgICAqIEBwYXJhbSBmb3JjZSBUaGUgYW1vdW50IG9mIGZvcmNlIHRvIGFkZC4KICAgICAqIEBwYXJhbSByZWxhdGl2ZVBvaW50IEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIHRvIGFwcGx5IHRoZSBmb3JjZSBvbi4KICAgICAqLwoKCiAgICBhcHBseUZvcmNlKGZvcmNlLCByZWxhdGl2ZVBvaW50KSB7CiAgICAgIGlmIChyZWxhdGl2ZVBvaW50ID09PSB2b2lkIDApIHsKICAgICAgICByZWxhdGl2ZVBvaW50ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgLy8gTmVlZGVkPwogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBmb3JjZQoKCiAgICAgIGNvbnN0IHJvdEZvcmNlID0gQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlOwogICAgICByZWxhdGl2ZVBvaW50LmNyb3NzKGZvcmNlLCByb3RGb3JjZSk7IC8vIEFkZCBsaW5lYXIgZm9yY2UKCiAgICAgIHRoaXMuZm9yY2UudmFkZChmb3JjZSwgdGhpcy5mb3JjZSk7IC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlCgogICAgICB0aGlzLnRvcnF1ZS52YWRkKHJvdEZvcmNlLCB0aGlzLnRvcnF1ZSk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IGZvcmNlIHRvIGEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkuCiAgICAgKiBAcGFyYW0gZm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhcHBseSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBib2R5IGZyYW1lLgogICAgICogQHBhcmFtIGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uCiAgICAgKi8KCgogICAgYXBwbHlMb2NhbEZvcmNlKGxvY2FsRm9yY2UsIGxvY2FsUG9pbnQpIHsKICAgICAgaWYgKGxvY2FsUG9pbnQgPT09IHZvaWQgMCkgewogICAgICAgIGxvY2FsUG9pbnQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlOwogICAgICBjb25zdCByZWxhdGl2ZVBvaW50V29ybGQgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV9yZWxhdGl2ZVBvaW50V29ybGQ7IC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlCgogICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEZvcmNlLCB3b3JsZEZvcmNlKTsKICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVsYXRpdmVQb2ludFdvcmxkKTsKICAgICAgdGhpcy5hcHBseUZvcmNlKHdvcmxkRm9yY2UsIHJlbGF0aXZlUG9pbnRXb3JsZCk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IHRvcnF1ZSB0byB0aGUgYm9keS4KICAgICAqIEBwYXJhbSB0b3JxdWUgVGhlIGFtb3VudCBvZiB0b3JxdWUgdG8gYWRkLgogICAgICovCgoKICAgIGFwcGx5VG9ycXVlKHRvcnF1ZSkgewogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlCgoKICAgICAgdGhpcy50b3JxdWUudmFkZCh0b3JxdWUsIHRoaXMudG9ycXVlKTsKICAgIH0KICAgIC8qKgogICAgICogQXBwbHkgaW1wdWxzZSB0byBhIHBvaW50IG9mIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4KICAgICAqIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLgogICAgICogSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS4KICAgICAqIEBwYXJhbSBpbXB1bHNlIFRoZSBhbW91bnQgb2YgaW1wdWxzZSB0byBhZGQuCiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQb2ludCBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyB0byBhcHBseSB0aGUgZm9yY2Ugb24uCiAgICAgKi8KCgogICAgYXBwbHlJbXB1bHNlKGltcHVsc2UsIHJlbGF0aXZlUG9pbnQpIHsKICAgICAgaWYgKHJlbGF0aXZlUG9pbnQgPT09IHZvaWQgMCkgewogICAgICAgIHJlbGF0aXZlUG9pbnQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIENvbXB1dGUgcG9pbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyCgoKICAgICAgY29uc3QgciA9IHJlbGF0aXZlUG9pbnQ7IC8vIENvbXB1dGUgcHJvZHVjZWQgY2VudHJhbCBpbXB1bHNlIHZlbG9jaXR5CgogICAgICBjb25zdCB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbzsKICAgICAgdmVsby5jb3B5KGltcHVsc2UpOwogICAgICB2ZWxvLnNjYWxlKHRoaXMuaW52TWFzcywgdmVsbyk7IC8vIEFkZCBsaW5lYXIgaW1wdWxzZQoKICAgICAgdGhpcy52ZWxvY2l0eS52YWRkKHZlbG8sIHRoaXMudmVsb2NpdHkpOyAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgaW1wdWxzZSB2ZWxvY2l0eQoKICAgICAgY29uc3Qgcm90VmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG87CiAgICAgIHIuY3Jvc3MoaW1wdWxzZSwgcm90VmVsbyk7CiAgICAgIC8qCiAgICAgICByb3RWZWxvLnggKj0gdGhpcy5pbnZJbmVydGlhLng7CiAgICAgICByb3RWZWxvLnkgKj0gdGhpcy5pbnZJbmVydGlhLnk7CiAgICAgICByb3RWZWxvLnogKj0gdGhpcy5pbnZJbmVydGlhLno7CiAgICAgICAqLwoKICAgICAgdGhpcy5pbnZJbmVydGlhV29ybGQudm11bHQocm90VmVsbywgcm90VmVsbyk7IC8vIEFkZCByb3RhdGlvbmFsIEltcHVsc2UKCiAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnZhZGQocm90VmVsbywgdGhpcy5hbmd1bGFyVmVsb2NpdHkpOwogICAgfQogICAgLyoqCiAgICAgKiBBcHBseSBsb2NhbGx5LWRlZmluZWQgaW1wdWxzZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LgogICAgICogQHBhcmFtIGZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYXBwbHksIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keSBmcmFtZS4KICAgICAqIEBwYXJhbSBsb2NhbFBvaW50IEEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLgogICAgICovCgoKICAgIGFwcGx5TG9jYWxJbXB1bHNlKGxvY2FsSW1wdWxzZSwgbG9jYWxQb2ludCkgewogICAgICBpZiAobG9jYWxQb2ludCA9PT0gdm9pZCAwKSB7CiAgICAgICAgbG9jYWxQb2ludCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQykgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3Qgd29ybGRJbXB1bHNlID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2U7CiAgICAgIGNvbnN0IHJlbGF0aXZlUG9pbnRXb3JsZCA9IEJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludDsgLy8gVHJhbnNmb3JtIHRoZSBmb3JjZSB2ZWN0b3IgdG8gd29ybGQgc3BhY2UKCiAgICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGxvY2FsSW1wdWxzZSwgd29ybGRJbXB1bHNlKTsKICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVsYXRpdmVQb2ludFdvcmxkKTsKICAgICAgdGhpcy5hcHBseUltcHVsc2Uod29ybGRJbXB1bHNlLCByZWxhdGl2ZVBvaW50V29ybGQpOwogICAgfQogICAgLyoqCiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGJvZHkgc2hhcGUgb3IgbWFzcy4KICAgICAqLwoKCiAgICB1cGRhdGVNYXNzUHJvcGVydGllcygpIHsKICAgICAgY29uc3QgaGFsZkV4dGVudHMgPSBCb2R5X3VwZGF0ZU1hc3NQcm9wZXJ0aWVzX2hhbGZFeHRlbnRzOwogICAgICB0aGlzLmludk1hc3MgPSB0aGlzLm1hc3MgPiAwID8gMS4wIC8gdGhpcy5tYXNzIDogMDsKICAgICAgY29uc3QgSSA9IHRoaXMuaW5lcnRpYTsKICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZpeGVkUm90YXRpb247IC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3gKCiAgICAgIHRoaXMudXBkYXRlQUFCQigpOwogICAgICBoYWxmRXh0ZW50cy5zZXQoKHRoaXMuYWFiYi51cHBlckJvdW5kLnggLSB0aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsICh0aGlzLmFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5hYWJiLmxvd2VyQm91bmQueSkgLyAyLCAodGhpcy5hYWJiLnVwcGVyQm91bmQueiAtIHRoaXMuYWFiYi5sb3dlckJvdW5kLnopIC8gMik7CiAgICAgIEJveC5jYWxjdWxhdGVJbmVydGlhKGhhbGZFeHRlbnRzLCB0aGlzLm1hc3MsIEkpOwogICAgICB0aGlzLmludkluZXJ0aWEuc2V0KEkueCA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS54IDogMCwgSS55ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnkgOiAwLCBJLnogPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueiA6IDApOwogICAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCh0cnVlKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHdvcmxkIHZlbG9jaXR5IG9mIGEgcG9pbnQgaW4gdGhlIGJvZHkuCiAgICAgKiBAcGFyYW0gd29ybGRQb2ludAogICAgICogQHBhcmFtIHJlc3VsdAogICAgICogQHJldHVybiBUaGUgcmVzdWx0IHZlY3Rvci4KICAgICAqLwoKCiAgICBnZXRWZWxvY2l0eUF0V29ybGRQb2ludCh3b3JsZFBvaW50LCByZXN1bHQpIHsKICAgICAgY29uc3QgciA9IG5ldyBWZWMzKCk7CiAgICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLCByKTsKICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MociwgcmVzdWx0KTsKICAgICAgdGhpcy52ZWxvY2l0eS52YWRkKHJlc3VsdCwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUuCiAgICAgKiBAcGFyYW0gZHQgVGltZSBzdGVwCiAgICAgKiBAcGFyYW0gcXVhdE5vcm1hbGl6ZSBTZXQgdG8gdHJ1ZSB0byBub3JtYWxpemUgdGhlIGJvZHkgcXVhdGVybmlvbgogICAgICogQHBhcmFtIHF1YXROb3JtYWxpemVGYXN0IElmIHRoZSBxdWF0ZXJuaW9uIHNob3VsZCBiZSBub3JtYWxpemVkIHVzaW5nICJmYXN0IiBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24KICAgICAqLwoKCiAgICBpbnRlZ3JhdGUoZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KSB7CiAgICAgIC8vIFNhdmUgcHJldmlvdXMgcG9zaXRpb24KICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uLmNvcHkodGhpcy5wb3NpdGlvbik7CiAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkodGhpcy5xdWF0ZXJuaW9uKTsKCiAgICAgIGlmICghKHRoaXMudHlwZSA9PT0gQm9keS5EWU5BTUlDIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpIHx8IHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORykgewogICAgICAgIC8vIE9ubHkgZm9yIGR5bmFtaWMKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlbG8gPSB0aGlzLnZlbG9jaXR5OwogICAgICBjb25zdCBhbmd1bGFyVmVsbyA9IHRoaXMuYW5ndWxhclZlbG9jaXR5OwogICAgICBjb25zdCBwb3MgPSB0aGlzLnBvc2l0aW9uOwogICAgICBjb25zdCBmb3JjZSA9IHRoaXMuZm9yY2U7CiAgICAgIGNvbnN0IHRvcnF1ZSA9IHRoaXMudG9ycXVlOwogICAgICBjb25zdCBxdWF0ID0gdGhpcy5xdWF0ZXJuaW9uOwogICAgICBjb25zdCBpbnZNYXNzID0gdGhpcy5pbnZNYXNzOwogICAgICBjb25zdCBpbnZJbmVydGlhID0gdGhpcy5pbnZJbmVydGlhV29ybGQ7CiAgICAgIGNvbnN0IGxpbmVhckZhY3RvciA9IHRoaXMubGluZWFyRmFjdG9yOwogICAgICBjb25zdCBpTWR0ID0gaW52TWFzcyAqIGR0OwogICAgICB2ZWxvLnggKz0gZm9yY2UueCAqIGlNZHQgKiBsaW5lYXJGYWN0b3IueDsKICAgICAgdmVsby55ICs9IGZvcmNlLnkgKiBpTWR0ICogbGluZWFyRmFjdG9yLnk7CiAgICAgIHZlbG8ueiArPSBmb3JjZS56ICogaU1kdCAqIGxpbmVhckZhY3Rvci56OwogICAgICBjb25zdCBlID0gaW52SW5lcnRpYS5lbGVtZW50czsKICAgICAgY29uc3QgYW5ndWxhckZhY3RvciA9IHRoaXMuYW5ndWxhckZhY3RvcjsKICAgICAgY29uc3QgdHggPSB0b3JxdWUueCAqIGFuZ3VsYXJGYWN0b3IueDsKICAgICAgY29uc3QgdHkgPSB0b3JxdWUueSAqIGFuZ3VsYXJGYWN0b3IueTsKICAgICAgY29uc3QgdHogPSB0b3JxdWUueiAqIGFuZ3VsYXJGYWN0b3IuejsKICAgICAgYW5ndWxhclZlbG8ueCArPSBkdCAqIChlWzBdICogdHggKyBlWzFdICogdHkgKyBlWzJdICogdHopOwogICAgICBhbmd1bGFyVmVsby55ICs9IGR0ICogKGVbM10gKiB0eCArIGVbNF0gKiB0eSArIGVbNV0gKiB0eik7CiAgICAgIGFuZ3VsYXJWZWxvLnogKz0gZHQgKiAoZVs2XSAqIHR4ICsgZVs3XSAqIHR5ICsgZVs4XSAqIHR6KTsgLy8gVXNlIG5ldyB2ZWxvY2l0eSAgLSBsZWFwIGZyb2cKCiAgICAgIHBvcy54ICs9IHZlbG8ueCAqIGR0OwogICAgICBwb3MueSArPSB2ZWxvLnkgKiBkdDsKICAgICAgcG9zLnogKz0gdmVsby56ICogZHQ7CiAgICAgIHF1YXQuaW50ZWdyYXRlKHRoaXMuYW5ndWxhclZlbG9jaXR5LCBkdCwgdGhpcy5hbmd1bGFyRmFjdG9yLCBxdWF0KTsKCiAgICAgIGlmIChxdWF0Tm9ybWFsaXplKSB7CiAgICAgICAgaWYgKHF1YXROb3JtYWxpemVGYXN0KSB7CiAgICAgICAgICBxdWF0Lm5vcm1hbGl6ZUZhc3QoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcXVhdC5ub3JtYWxpemUoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gVXBkYXRlIHdvcmxkIGluZXJ0aWEKCiAgICAgIHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKCk7CiAgICB9CgogIH0KICBCb2R5LmlkQ291bnRlciA9IDA7CiAgQm9keS5DT0xMSURFX0VWRU5UX05BTUUgPSAnY29sbGlkZSc7CiAgQm9keS5EWU5BTUlDID0gQk9EWV9UWVBFUy5EWU5BTUlDOwogIEJvZHkuU1RBVElDID0gQk9EWV9UWVBFUy5TVEFUSUM7CiAgQm9keS5LSU5FTUFUSUMgPSBCT0RZX1RZUEVTLktJTkVNQVRJQzsKICBCb2R5LkFXQUtFID0gQk9EWV9TTEVFUF9TVEFURVMuQVdBS0U7CiAgQm9keS5TTEVFUFkgPSBCT0RZX1NMRUVQX1NUQVRFUy5TTEVFUFk7CiAgQm9keS5TTEVFUElORyA9IEJPRFlfU0xFRVBfU1RBVEVTLlNMRUVQSU5HOwogIEJvZHkud2FrZXVwRXZlbnQgPSB7CiAgICB0eXBlOiAnd2FrZXVwJwogIH07CiAgQm9keS5zbGVlcHlFdmVudCA9IHsKICAgIHR5cGU6ICdzbGVlcHknCiAgfTsKICBCb2R5LnNsZWVwRXZlbnQgPSB7CiAgICB0eXBlOiAnc2xlZXAnCiAgfTsKICBjb25zdCB0bXBWZWMgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpOwogIGNvbnN0IHVwZGF0ZUFBQkJfc2hhcGVBQUJCID0gbmV3IEFBQkIoKTsKICBjb25zdCB1aXdfbTEgPSBuZXcgTWF0MygpOwogIGNvbnN0IHVpd19tMiA9IG5ldyBNYXQzKCk7CiAgbmV3IE1hdDMoKTsKICBjb25zdCBCb2R5X2FwcGx5Rm9yY2Vfcm90Rm9yY2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkRm9yY2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3JlbGF0aXZlUG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cyA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zCiAgICogQGF1dGhvciBzY2h0ZXBwZQogICAqLwogIGNsYXNzIEJyb2FkcGhhc2UgewogICAgLyoqCiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb25zIGluLgogICAgICovCgogICAgLyoqCiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGJyb2FkcGhhc2UgdXNlcyBib3VuZGluZyBib3hlcyBmb3IgaW50ZXJzZWN0aW9uIHRlc3RzLCBlbHNlIGl0IHVzZXMgYm91bmRpbmcgc3BoZXJlcy4KICAgICAqLwoKICAgIC8qKgogICAgICogU2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdHMgaW4gdGhlIHdvcmxkIG1vdmVkLgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMudXNlQm91bmRpbmdCb3hlcyA9IGZhbHNlOwogICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBjb2xsaXNpb24gcGFpcnMgZnJvbSB0aGUgd29ybGQKICAgICAqIEBwYXJhbSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluCiAgICAgKiBAcGFyYW0gcDEgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzCiAgICAgKiBAcGFyYW0gcDIgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHAxLCBwMikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbGxpc2lvblBhaXJzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBCcm9hZFBoYXNlIGNsYXNzIScpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiBhIGJvZHkgcGFpciBuZWVkcyB0byBiZSBpbnRlcnNlY3Rpb24gdGVzdGVkIGF0IGFsbC4KICAgICAqLwoKCiAgICBuZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihib2R5QSwgYm9keUIpIHsKICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uIGZpbHRlciBtYXNrcwogICAgICBpZiAoKGJvZHlBLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUIuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDAgfHwgKGJvZHlCLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUEuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDApIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gQ2hlY2sgdHlwZXMKCgogICAgICBpZiAoKChib2R5QS50eXBlICYgQm9keS5TVEFUSUMpICE9PSAwIHx8IGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpICYmICgoYm9keUIudHlwZSAmIEJvZHkuU1RBVElDKSAhPT0gMCB8fCBib2R5Qi5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSkgewogICAgICAgIC8vIEJvdGggYm9kaWVzIGFyZSBzdGF0aWMgb3Igc2xlZXBpbmcuIFNraXAuCiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHZvbHVtZXMgb2YgdHdvIGJvZGllcyBpbnRlcnNlY3QuCiAgICAgKi8KCgogICAgaW50ZXJzZWN0aW9uVGVzdChib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKSB7CiAgICAgIGlmICh0aGlzLnVzZUJvdW5kaW5nQm94ZXMpIHsKICAgICAgICB0aGlzLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UoYm9keUEsIGJvZHlCLCBwYWlyczEsIHBhaXJzMik7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLgogICAgICogQHBhcmFtIHBhaXJzMSBib2R5QSBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvbgogICAgICogQHBhcmFtIHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvbgogICAgICovCgoKICAgIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpIHsKICAgICAgY29uc3QgciA9IEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcjsKICAgICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbiwgcik7CiAgICAgIGNvbnN0IGJvdW5kaW5nUmFkaXVzU3VtMiA9IChib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzKSAqKiAyOwogICAgICBjb25zdCBub3JtMiA9IHIubGVuZ3RoU3F1YXJlZCgpOwoKICAgICAgaWYgKG5vcm0yIDwgYm91bmRpbmdSYWRpdXNTdW0yKSB7CiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpOwogICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94ZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLgogICAgICovCgoKICAgIGRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpIHsKICAgICAgaWYgKGJvZHlBLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgIGJvZHlBLnVwZGF0ZUFBQkIoKTsKICAgICAgfQoKICAgICAgaWYgKGJvZHlCLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgIGJvZHlCLnVwZGF0ZUFBQkIoKTsKICAgICAgfSAvLyBDaGVjayBBQUJCIC8gQUFCQgoKCiAgICAgIGlmIChib2R5QS5hYWJiLm92ZXJsYXBzKGJvZHlCLmFhYmIpKSB7CiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpOwogICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGR1cGxpY2F0ZSBwYWlycyBmcm9tIHRoZSBwYWlyIGFycmF5cy4KICAgICAqLwoKCiAgICBtYWtlUGFpcnNVbmlxdWUocGFpcnMxLCBwYWlyczIpIHsKICAgICAgY29uc3QgdCA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXA7CiAgICAgIGNvbnN0IHAxID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDE7CiAgICAgIGNvbnN0IHAyID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDI7CiAgICAgIGNvbnN0IE4gPSBwYWlyczEubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIHAxW2ldID0gcGFpcnMxW2ldOwogICAgICAgIHAyW2ldID0gcGFpcnMyW2ldOwogICAgICB9CgogICAgICBwYWlyczEubGVuZ3RoID0gMDsKICAgICAgcGFpcnMyLmxlbmd0aCA9IDA7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgaWQxID0gcDFbaV0uaWQ7CiAgICAgICAgY29uc3QgaWQyID0gcDJbaV0uaWQ7CiAgICAgICAgY29uc3Qga2V5ID0gaWQxIDwgaWQyID8gYCR7aWQxfSwke2lkMn1gIDogYCR7aWQyfSwke2lkMX1gOwogICAgICAgIHRba2V5XSA9IGk7CiAgICAgICAgdC5rZXlzLnB1c2goa2V5KTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHQua2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGtleSA9IHQua2V5cy5wb3AoKTsKICAgICAgICBjb25zdCBwYWlySW5kZXggPSB0W2tleV07CiAgICAgICAgcGFpcnMxLnB1c2gocDFbcGFpckluZGV4XSk7CiAgICAgICAgcGFpcnMyLnB1c2gocDJbcGFpckluZGV4XSk7CiAgICAgICAgZGVsZXRlIHRba2V5XTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBieSBzdWJjYXNzZXMKICAgICAqLwoKCiAgICBzZXRXb3JsZCh3b3JsZCkge30KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLgogICAgICovCgoKICAgIHN0YXRpYyBib3VuZGluZ1NwaGVyZUNoZWNrKGJvZHlBLCBib2R5QikgewogICAgICBjb25zdCBkaXN0ID0gbmV3IFZlYzMoKTsgLy8gYnNjX2Rpc3Q7CgogICAgICBib2R5QS5wb3NpdGlvbi52c3ViKGJvZHlCLnBvc2l0aW9uLCBkaXN0KTsKICAgICAgY29uc3Qgc2EgPSBib2R5QS5zaGFwZXNbMF07CiAgICAgIGNvbnN0IHNiID0gYm9keUIuc2hhcGVzWzBdOwogICAgICByZXR1cm4gTWF0aC5wb3coc2EuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzYi5ib3VuZGluZ1NwaGVyZVJhZGl1cywgMikgPiBkaXN0Lmxlbmd0aFNxdWFyZWQoKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuCiAgICAgKi8KCgogICAgYWFiYlF1ZXJ5KHdvcmxkLCBhYWJiLCByZXN1bHQpIHsKICAgICAgY29uc29sZS53YXJuKCcuYWFiYlF1ZXJ5IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIEJyb2FkcGhhc2Ugc3ViY2xhc3MuJyk7CiAgICAgIHJldHVybiBbXTsKICAgIH0KCiAgfSAvLyBUZW1wIG9iamVjdHMKCiAgY29uc3QgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yID0gbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIG5ldyBRdWF0ZXJuaW9uKCk7CiAgbmV3IFZlYzMoKTsKICBjb25zdCBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wID0gewogICAga2V5czogW10KICB9OwogIGNvbnN0IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxID0gW107CiAgY29uc3QgQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDIgPSBbXTsKICBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbiwgdXNlZCBpbiBsYWNrIG9mIGJldHRlciBvbmVzLgogICAqCiAgICogVGhlIG5haXZlIGJyb2FkcGhhc2UgbG9va3MgYXQgYWxsIHBvc3NpYmxlIHBhaXJzIHdpdGhvdXQgcmVzdHJpY3Rpb24sIHRoZXJlZm9yZSBpdCBoYXMgY29tcGxleGl0eSBOXjIgXyh3aGljaCBpcyBiYWQpXwogICAqLwogIGNsYXNzIE5haXZlQnJvYWRwaGFzZSBleHRlbmRzIEJyb2FkcGhhc2UgewogICAgLyoqCiAgICAgKiBAdG9kbyBSZW1vdmUgdXNlbGVzcyBjb25zdHJ1Y3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHBhaXJzMSwgcGFpcnMyKSB7CiAgICAgIGNvbnN0IGJvZGllcyA9IHdvcmxkLmJvZGllczsKICAgICAgY29uc3QgbiA9IGJvZGllcy5sZW5ndGg7CiAgICAgIGxldCBiaTsKICAgICAgbGV0IGJqOyAvLyBOYWl2ZSBOXjIgZnR3IQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IG47IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBpOyBqKyspIHsKICAgICAgICAgIGJpID0gYm9kaWVzW2ldOwogICAgICAgICAgYmogPSBib2RpZXNbal07CgogICAgICAgICAgaWYgKCF0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJpLCBiaikpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLCBiaiwgcGFpcnMxLCBwYWlyczIpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLgogICAgICovCgoKICAgIGFhYmJRdWVyeSh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IFtdOwogICAgICB9CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGIgPSB3b3JsZC5ib2RpZXNbaV07CgogICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYi51cGRhdGVBQUJCKCk7CiAgICAgICAgfSAvLyBVZ2x5IGhhY2sgdW50aWwgQm9keSBnZXRzIGFhYmIKCgogICAgICAgIGlmIChiLmFhYmIub3ZlcmxhcHMoYWFiYikpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKGIpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgfQoKICAvKioKICAgKiBTdG9yYWdlIGZvciBSYXkgY2FzdGluZyBkYXRhCiAgICovCiAgY2xhc3MgUmF5Y2FzdFJlc3VsdCB7CiAgICAvKioKICAgICAqIHJheUZyb21Xb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiByYXlUb1dvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIGhpdE5vcm1hbFdvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIGhpdFBvaW50V29ybGQKICAgICAqLwoKICAgIC8qKgogICAgICogaGFzSGl0CiAgICAgKi8KCiAgICAvKioKICAgICAqIHNoYXBlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGJvZHkKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGluZGV4IG9mIHRoZSBoaXQgdHJpYW5nbGUsIGlmIHRoZSBoaXQgc2hhcGUgd2FzIGEgdHJpbWVzaAogICAgICovCgogICAgLyoqCiAgICAgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0CiAgICAgKi8KCiAgICAvKioKICAgICAqIElmIHRoZSByYXkgc2hvdWxkIHN0b3AgdHJhdmVyc2luZyB0aGUgYm9kaWVzCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLnJheUZyb21Xb3JsZCA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucmF5VG9Xb3JsZCA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaGl0Tm9ybWFsV29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmhpdFBvaW50V29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlOwogICAgICB0aGlzLnNoYXBlID0gbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgICAgdGhpcy5oaXRGYWNlSW5kZXggPSAtMTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IC0xOwogICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLgogICAgICovCgoKICAgIHJlc2V0KCkgewogICAgICB0aGlzLnJheUZyb21Xb3JsZC5zZXRaZXJvKCk7CiAgICAgIHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCk7CiAgICAgIHRoaXMuaGl0Tm9ybWFsV29ybGQuc2V0WmVybygpOwogICAgICB0aGlzLmhpdFBvaW50V29ybGQuc2V0WmVybygpOwogICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlOwogICAgICB0aGlzLnNoYXBlID0gbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgICAgdGhpcy5oaXRGYWNlSW5kZXggPSAtMTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IC0xOwogICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogYWJvcnQKICAgICAqLwoKCiAgICBhYm9ydCgpIHsKICAgICAgdGhpcy5zaG91bGRTdG9wID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHJlc3VsdCBkYXRhLgogICAgICovCgoKICAgIHNldChyYXlGcm9tV29ybGQsIHJheVRvV29ybGQsIGhpdE5vcm1hbFdvcmxkLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgZGlzdGFuY2UpIHsKICAgICAgdGhpcy5yYXlGcm9tV29ybGQuY29weShyYXlGcm9tV29ybGQpOwogICAgICB0aGlzLnJheVRvV29ybGQuY29weShyYXlUb1dvcmxkKTsKICAgICAgdGhpcy5oaXROb3JtYWxXb3JsZC5jb3B5KGhpdE5vcm1hbFdvcmxkKTsKICAgICAgdGhpcy5oaXRQb2ludFdvcmxkLmNvcHkoaGl0UG9pbnRXb3JsZCk7CiAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTsKICAgICAgdGhpcy5ib2R5ID0gYm9keTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlOwogICAgfQoKICB9CgogIGxldCBfU2hhcGUkdHlwZXMkU1BIRVJFLCBfU2hhcGUkdHlwZXMkUExBTkUsIF9TaGFwZSR0eXBlcyRCT1gsIF9TaGFwZSR0eXBlcyRDWUxJTkRFUiwgX1NoYXBlJHR5cGVzJENPTlZFWFBPLCBfU2hhcGUkdHlwZXMkSEVJR0hURkksIF9TaGFwZSR0eXBlcyRUUklNRVNIOwoKICAvKioKICAgKiBSQVlfTU9ERVMKICAgKi8KICBjb25zdCBSQVlfTU9ERVMgPSB7CiAgICAvKiogQ0xPU0VTVCAqLwogICAgQ0xPU0VTVDogMSwKCiAgICAvKiogQU5ZICovCiAgICBBTlk6IDIsCgogICAgLyoqIEFMTCAqLwogICAgQUxMOiA0CiAgfTsKICAvKioKICAgKiBSYXlNb2RlCiAgICovCgogIF9TaGFwZSR0eXBlcyRTUEhFUkUgPSBTaGFwZS50eXBlcy5TUEhFUkU7CiAgX1NoYXBlJHR5cGVzJFBMQU5FID0gU2hhcGUudHlwZXMuUExBTkU7CiAgX1NoYXBlJHR5cGVzJEJPWCA9IFNoYXBlLnR5cGVzLkJPWDsKICBfU2hhcGUkdHlwZXMkQ1lMSU5ERVIgPSBTaGFwZS50eXBlcy5DWUxJTkRFUjsKICBfU2hhcGUkdHlwZXMkQ09OVkVYUE8gPSBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OOwogIF9TaGFwZSR0eXBlcyRIRUlHSFRGSSA9IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEOwogIF9TaGFwZSR0eXBlcyRUUklNRVNIID0gU2hhcGUudHlwZXMuVFJJTUVTSDsKCiAgLyoqCiAgICogQSBsaW5lIGluIDNEIHNwYWNlIHRoYXQgaW50ZXJzZWN0cyBib2RpZXMgYW5kIHJldHVybiBwb2ludHMuCiAgICovCiAgY2xhc3MgUmF5IHsKICAgIC8qKgogICAgICogZnJvbQogICAgICovCgogICAgLyoqCiAgICAgKiB0bwogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb24KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHByZWNpc2lvbiBvZiB0aGUgcmF5LiBVc2VkIHdoZW4gY2hlY2tpbmcgcGFyYWxsZWxpdHkgZXRjLgogICAgICogQGRlZmF1bHQgMC4wMDAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNldCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBSYXkgdG8gdGFrZSBgY29sbGlzaW9uUmVzcG9uc2VgIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy4KICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuCiAgICAgKiBAZGVmYXVsdCBmYWxzZQogICAgICovCgogICAgLyoqCiAgICAgKiBjb2xsaXNpb25GaWx0ZXJNYXNrCiAgICAgKiBAZGVmYXVsdCAtMQogICAgICovCgogICAgLyoqCiAgICAgKiBjb2xsaXNpb25GaWx0ZXJHcm91cAogICAgICogQGRlZmF1bHQgLTEKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC4KICAgICAqIEBkZWZhdWx0IFJBWS5BTlkKICAgICAqLwoKICAgIC8qKgogICAgICogQ3VycmVudCByZXN1bHQgb2JqZWN0LgogICAgICovCgogICAgLyoqCiAgICAgKiBXaWxsIGJlIHNldCB0byBgdHJ1ZWAgZHVyaW5nIGludGVyc2VjdFdvcmxkKCkgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLgogICAgICovCgogICAgLyoqCiAgICAgKiBDTE9TRVNUCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFOWQogICAgICovCgogICAgLyoqCiAgICAgKiBBTEwKICAgICAqLwogICAgZ2V0IFtfU2hhcGUkdHlwZXMkU1BIRVJFXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdFNwaGVyZTsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRQTEFORV0oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RQbGFuZTsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRCT1hdKCkgewogICAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0Qm94OwogICAgfQoKICAgIGdldCBbX1NoYXBlJHR5cGVzJENZTElOREVSXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdENvbnZleDsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRDT05WRVhQT10oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RDb252ZXg7CiAgICB9CgogICAgZ2V0IFtfU2hhcGUkdHlwZXMkSEVJR0hURkldKCkgewogICAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0SGVpZ2h0ZmllbGQ7CiAgICB9CgogICAgZ2V0IFtfU2hhcGUkdHlwZXMkVFJJTUVTSF0oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RUcmltZXNoOwogICAgfQoKICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7CiAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsKICAgICAgICBmcm9tID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsKICAgICAgICB0byA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMuZnJvbSA9IGZyb20uY2xvbmUoKTsKICAgICAgdGhpcy50byA9IHRvLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5wcmVjaXNpb24gPSAwLjAwMDE7CiAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRydWU7CiAgICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9IGZhbHNlOwogICAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSAtMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IC0xOwogICAgICB0aGlzLm1vZGUgPSBSYXkuQU5ZOwogICAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7CiAgICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7CgogICAgICB0aGlzLmNhbGxiYWNrID0gcmVzdWx0ID0+IHt9OwogICAgfQogICAgLyoqCiAgICAgKiBEbyBpdGVyc2VjdGlvbiBhZ2FpbnN0IGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIFdvcmxkLgogICAgICogQHJldHVybiBUcnVlIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLCBvdGhlcndpc2UgZmFsc2UuCiAgICAgKi8KCgogICAgaW50ZXJzZWN0V29ybGQod29ybGQsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7CiAgICAgIHRoaXMucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgfHwgbmV3IFJheWNhc3RSZXN1bHQoKTsKICAgICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Ygb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogLTE7CiAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHR5cGVvZiBvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTsKCiAgICAgIGlmIChvcHRpb25zLmZyb20pIHsKICAgICAgICB0aGlzLmZyb20uY29weShvcHRpb25zLmZyb20pOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy50bykgewogICAgICAgIHRoaXMudG8uY29weShvcHRpb25zLnRvKTsKICAgICAgfQoKICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgKCgpID0+IHt9KTsKCiAgICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7CiAgICAgIHRoaXMucmVzdWx0LnJlc2V0KCk7CiAgICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7CiAgICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCJDEpOwogICAgICB0bXBBcnJheS5sZW5ndGggPSAwOwogICAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiQxLCB0bXBBcnJheSk7CiAgICAgIHRoaXMuaW50ZXJzZWN0Qm9kaWVzKHRtcEFycmF5KTsKICAgICAgcmV0dXJuIHRoaXMuaGFzSGl0OwogICAgfQogICAgLyoqCiAgICAgKiBTaG9vdCBhIHJheSBhdCBhIGJvZHksIGdldCBiYWNrIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXQuCiAgICAgKiBAZGVwcmVjYXRlZCBAcGFyYW0gcmVzdWx0IHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC4KICAgICAqLwoKCiAgICBpbnRlcnNlY3RCb2R5KGJvZHksIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7CiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTsKICAgICAgfQoKICAgICAgY29uc3QgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTsKCiAgICAgIGlmIChjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFib2R5LmNvbGxpc2lvblJlc3BvbnNlKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAoKHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5LmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAwIHx8IChib2R5LmNvbGxpc2lvbkZpbHRlckdyb3VwICYgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrKSA9PT0gMCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3QgeGkgPSBpbnRlcnNlY3RCb2R5X3hpOwogICAgICBjb25zdCBxaSA9IGludGVyc2VjdEJvZHlfcWk7CgogICAgICBmb3IgKGxldCBpID0gMCwgTiA9IGJvZHkuc2hhcGVzLmxlbmd0aDsgaSA8IE47IGkrKykgewogICAgICAgIGNvbnN0IHNoYXBlID0gYm9keS5zaGFwZXNbaV07CgogICAgICAgIGlmIChjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFzaGFwZS5jb2xsaXNpb25SZXNwb25zZSkgewogICAgICAgICAgY29udGludWU7IC8vIFNraXAKICAgICAgICB9CgogICAgICAgIGJvZHkucXVhdGVybmlvbi5tdWx0KGJvZHkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTsKICAgICAgICBib2R5LnF1YXRlcm5pb24udm11bHQoYm9keS5zaGFwZU9mZnNldHNbaV0sIHhpKTsKICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTsKICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKHNoYXBlLCBxaSwgeGksIGJvZHkpOwoKICAgICAgICBpZiAodGhpcy5yZXN1bHQuc2hvdWxkU3RvcCkgewogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNob290IGEgcmF5IGF0IGFuIGFycmF5IGJvZGllcywgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC4KICAgICAqIEBwYXJhbSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLgogICAgICogQGRlcHJlY2F0ZWQgQHBhcmFtIHJlc3VsdCBzZXQgdGhlIHJlc3VsdCBwcm9wZXJ0eSBvZiB0aGUgUmF5IGluc3RlYWQuCiAgICAgKgogICAgICovCgoKICAgIGludGVyc2VjdEJvZGllcyhib2RpZXMsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7CiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBpIDwgbDsgaSsrKSB7CiAgICAgICAgdGhpcy5pbnRlcnNlY3RCb2R5KGJvZGllc1tpXSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyB0aGUgZGlyZWN0aW9uIHZlY3Rvci4KICAgICAqLwoKCiAgICB1cGRhdGVEaXJlY3Rpb24oKSB7CiAgICAgIHRoaXMudG8udnN1Yih0aGlzLmZyb20sIHRoaXMuZGlyZWN0aW9uKTsKICAgICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7CiAgICB9CgogICAgaW50ZXJzZWN0U2hhcGUoc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5KSB7CiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207IC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlCgogICAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCB0aGlzLmRpcmVjdGlvbiwgcG9zaXRpb24pOwoKICAgICAgaWYgKGRpc3RhbmNlID4gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGludGVyc2VjdE1ldGhvZCA9IHRoaXNbc2hhcGUudHlwZV07CgogICAgICBpZiAoaW50ZXJzZWN0TWV0aG9kKSB7CiAgICAgICAgaW50ZXJzZWN0TWV0aG9kLmNhbGwodGhpcywgc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCBzaGFwZSk7CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0Qm94KGJveCwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdENvbnZleChib3guY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSk7CiAgICB9CgogICAgX2ludGVyc2VjdFBsYW5lKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSkgewogICAgICBjb25zdCBmcm9tID0gdGhpcy5mcm9tOwogICAgICBjb25zdCB0byA9IHRoaXMudG87CiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uOyAvLyBHZXQgcGxhbmUgbm9ybWFsCgogICAgICBjb25zdCB3b3JsZE5vcm1hbCA9IG5ldyBWZWMzKDAsIDAsIDEpOwogICAgICBxdWF0LnZtdWx0KHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7CiAgICAgIGNvbnN0IGxlbiA9IG5ldyBWZWMzKCk7CiAgICAgIGZyb20udnN1Yihwb3NpdGlvbiwgbGVuKTsKICAgICAgY29uc3QgcGxhbmVUb0Zyb20gPSBsZW4uZG90KHdvcmxkTm9ybWFsKTsKICAgICAgdG8udnN1Yihwb3NpdGlvbiwgbGVuKTsKICAgICAgY29uc3QgcGxhbmVUb1RvID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7CgogICAgICBpZiAocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKSB7CiAgICAgICAgLy8gImZyb20iIGFuZCAidG8iIGFyZSBvbiB0aGUgc2FtZSBzaWRlIG9mIHRoZSBwbGFuZS4uLiBiYWlsIG91dAogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKGZyb20uZGlzdGFuY2VUbyh0bykgPCBwbGFuZVRvRnJvbSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3Qgbl9kb3RfZGlyID0gd29ybGROb3JtYWwuZG90KGRpcmVjdGlvbik7CgogICAgICBpZiAoTWF0aC5hYnMobl9kb3RfZGlyKSA8IHRoaXMucHJlY2lzaW9uKSB7CiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCBwbGFuZVBvaW50VG9Gcm9tID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgZGlyX3NjYWxlZF93aXRoX3QgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBoaXRQb2ludFdvcmxkID0gbmV3IFZlYzMoKTsKICAgICAgZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTsKICAgICAgY29uc3QgdCA9IC13b3JsZE5vcm1hbC5kb3QocGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXI7CiAgICAgIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7CiAgICAgIGZyb20udmFkZChkaXJfc2NhbGVkX3dpdGhfdCwgaGl0UG9pbnRXb3JsZCk7CiAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCBoaXRQb2ludFdvcmxkLCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgd29ybGQgQUFCQiBvZiB0aGUgcmF5LgogICAgICovCgoKICAgIGdldEFBQkIoYWFiYikgewogICAgICBjb25zdCB7CiAgICAgICAgbG93ZXJCb3VuZCwKICAgICAgICB1cHBlckJvdW5kCiAgICAgIH0gPSBhYWJiOwogICAgICBjb25zdCB0byA9IHRoaXMudG87CiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207CiAgICAgIGxvd2VyQm91bmQueCA9IE1hdGgubWluKHRvLngsIGZyb20ueCk7CiAgICAgIGxvd2VyQm91bmQueSA9IE1hdGgubWluKHRvLnksIGZyb20ueSk7CiAgICAgIGxvd2VyQm91bmQueiA9IE1hdGgubWluKHRvLnosIGZyb20ueik7CiAgICAgIHVwcGVyQm91bmQueCA9IE1hdGgubWF4KHRvLngsIGZyb20ueCk7CiAgICAgIHVwcGVyQm91bmQueSA9IE1hdGgubWF4KHRvLnksIGZyb20ueSk7CiAgICAgIHVwcGVyQm91bmQueiA9IE1hdGgubWF4KHRvLnosIGZyb20ueik7CiAgICB9CgogICAgX2ludGVyc2VjdEhlaWdodGZpZWxkKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSkgewogICAgICBzaGFwZS5kYXRhOwogICAgICBzaGFwZS5lbGVtZW50U2l6ZTsgLy8gQ29udmVydCB0aGUgcmF5IHRvIGxvY2FsIGhlaWdodGZpZWxkIGNvb3JkaW5hdGVzCgogICAgICBjb25zdCBsb2NhbFJheSA9IGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsUmF5OyAvL25ldyBSYXkodGhpcy5mcm9tLCB0aGlzLnRvKTsKCiAgICAgIGxvY2FsUmF5LmZyb20uY29weSh0aGlzLmZyb20pOwogICAgICBsb2NhbFJheS50by5jb3B5KHRoaXMudG8pOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGxvY2FsUmF5LmZyb20sIGxvY2FsUmF5LmZyb20pOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGxvY2FsUmF5LnRvLCBsb2NhbFJheS50byk7CiAgICAgIGxvY2FsUmF5LnVwZGF0ZURpcmVjdGlvbigpOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3QKCiAgICAgIGNvbnN0IGluZGV4ID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXg7CiAgICAgIGxldCBpTWluWDsKICAgICAgbGV0IGlNaW5ZOwogICAgICBsZXQgaU1heFg7CiAgICAgIGxldCBpTWF4WTsgLy8gU2V0IHRvIG1heAoKICAgICAgaU1pblggPSBpTWluWSA9IDA7CiAgICAgIGlNYXhYID0gaU1heFkgPSBzaGFwZS5kYXRhLmxlbmd0aCAtIDE7CiAgICAgIGNvbnN0IGFhYmIgPSBuZXcgQUFCQigpOwogICAgICBsb2NhbFJheS5nZXRBQUJCKGFhYmIpOwogICAgICBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24oYWFiYi5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC55LCBpbmRleCwgdHJ1ZSk7CiAgICAgIGlNaW5YID0gTWF0aC5tYXgoaU1pblgsIGluZGV4WzBdKTsKICAgICAgaU1pblkgPSBNYXRoLm1heChpTWluWSwgaW5kZXhbMV0pOwogICAgICBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24oYWFiYi51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55LCBpbmRleCwgdHJ1ZSk7CiAgICAgIGlNYXhYID0gTWF0aC5taW4oaU1heFgsIGluZGV4WzBdICsgMSk7CiAgICAgIGlNYXhZID0gTWF0aC5taW4oaU1heFksIGluZGV4WzFdICsgMSk7CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKykgewogICAgICAgICAgaWYgKHRoaXMucmVzdWx0LnNob3VsZFN0b3ApIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQoKICAgICAgICAgIHNoYXBlLmdldEFhYmJBdEluZGV4KGksIGosIGFhYmIpOwoKICAgICAgICAgIGlmICghYWFiYi5vdmVybGFwc1JheShsb2NhbFJheSkpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IC8vIExvd2VyIHRyaWFuZ2xlCgoKICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgdGhpcy5faW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIHJlcG9ydGVkU2hhcGUsIGludGVyc2VjdENvbnZleE9wdGlvbnMpOwoKICAgICAgICAgIGlmICh0aGlzLnJlc3VsdC5zaG91bGRTdG9wKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0gLy8gVXBwZXIgdHJpYW5nbGUKCgogICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7CiAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIHNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIHRoaXMuX2ludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCByZXBvcnRlZFNoYXBlLCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0U3BoZXJlKHNwaGVyZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpIHsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCByID0gc3BoZXJlLnJhZGl1czsKICAgICAgY29uc3QgYSA9ICh0by54IC0gZnJvbS54KSAqKiAyICsgKHRvLnkgLSBmcm9tLnkpICoqIDIgKyAodG8ueiAtIGZyb20ueikgKiogMjsKICAgICAgY29uc3QgYiA9IDIgKiAoKHRvLnggLSBmcm9tLngpICogKGZyb20ueCAtIHBvc2l0aW9uLngpICsgKHRvLnkgLSBmcm9tLnkpICogKGZyb20ueSAtIHBvc2l0aW9uLnkpICsgKHRvLnogLSBmcm9tLnopICogKGZyb20ueiAtIHBvc2l0aW9uLnopKTsKICAgICAgY29uc3QgYyA9IChmcm9tLnggLSBwb3NpdGlvbi54KSAqKiAyICsgKGZyb20ueSAtIHBvc2l0aW9uLnkpICoqIDIgKyAoZnJvbS56IC0gcG9zaXRpb24ueikgKiogMiAtIHIgKiogMjsKICAgICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYSAqIGM7CiAgICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50ID0gUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludDsKICAgICAgY29uc3Qgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7CgogICAgICBpZiAoZGVsdGEgPCAwKSB7CiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uCiAgICAgICAgcmV0dXJuOwogICAgICB9IGVsc2UgaWYgKGRlbHRhID09PSAwKSB7CiAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludAogICAgICAgIGZyb20ubGVycCh0bywgZGVsdGEsIGludGVyc2VjdGlvblBvaW50KTsKICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpOwogICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZDEgPSAoLWIgLSBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7CiAgICAgICAgY29uc3QgZDIgPSAoLWIgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7CgogICAgICAgIGlmIChkMSA+PSAwICYmIGQxIDw9IDEpIHsKICAgICAgICAgIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTsKICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7CiAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7CiAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5yZXN1bHQuc2hvdWxkU3RvcCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgaWYgKGQyID49IDAgJiYgZDIgPD0gMSkgewogICAgICAgICAgZnJvbS5sZXJwKHRvLCBkMiwgaW50ZXJzZWN0aW9uUG9pbnQpOwogICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTsKICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHJlcG9ydGVkU2hhcGUsIGJvZHksIC0xKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0Q29udmV4KHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSwgb3B0aW9ucykgewogICAgICBjb25zdCBub3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbm9ybWFsOwogICAgICBjb25zdCB2ZWN0b3IgPSBpbnRlcnNlY3RDb252ZXhfdmVjdG9yOwogICAgICBjb25zdCBmYWNlTGlzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mYWNlTGlzdCB8fCBudWxsOyAvLyBDaGVja2luZyBmYWNlcwoKICAgICAgY29uc3QgZmFjZXMgPSBzaGFwZS5mYWNlczsKICAgICAgY29uc3QgdmVydGljZXMgPSBzaGFwZS52ZXJ0aWNlczsKICAgICAgY29uc3Qgbm9ybWFscyA9IHNoYXBlLmZhY2VOb3JtYWxzOwogICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCBmcm9tVG9EaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyh0byk7CiAgICAgIGNvbnN0IE5mYWNlcyA9IGZhY2VMaXN0ID8gZmFjZUxpc3QubGVuZ3RoIDogZmFjZXMubGVuZ3RoOwogICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdDsKCiAgICAgIGZvciAobGV0IGogPSAwOyAhcmVzdWx0LnNob3VsZFN0b3AgJiYgaiA8IE5mYWNlczsgaisrKSB7CiAgICAgICAgY29uc3QgZmkgPSBmYWNlTGlzdCA/IGZhY2VMaXN0W2pdIDogajsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbZmldOwogICAgICAgIGNvbnN0IGZhY2VOb3JtYWwgPSBub3JtYWxzW2ZpXTsKICAgICAgICBjb25zdCBxID0gcXVhdDsKICAgICAgICBjb25zdCB4ID0gcG9zaXRpb247IC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2UKICAgICAgICAvLyBub3RlOiB0aGlzIHdvcmtzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZmFjZSBub3JtYWwKICAgICAgICAvLyBHZXQgcGxhbmUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuLi4KCiAgICAgICAgdmVjdG9yLmNvcHkodmVydGljZXNbZmFjZVswXV0pOwogICAgICAgIHEudm11bHQodmVjdG9yLCB2ZWN0b3IpOwogICAgICAgIHZlY3Rvci52YWRkKHgsIHZlY3Rvcik7IC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuCgogICAgICAgIHZlY3Rvci52c3ViKGZyb20sIHZlY3Rvcik7IC8vIEdldCBwbGFuZSBub3JtYWwKCiAgICAgICAgcS52bXVsdChmYWNlTm9ybWFsLCBub3JtYWwpOyAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZwoKICAgICAgICBjb25zdCBkb3QgPSBkaXJlY3Rpb24uZG90KG5vcm1hbCk7IC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsCgogICAgICAgIGlmIChNYXRoLmFicyhkb3QpIDwgdGhpcy5wcmVjaXNpb24pIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZQoKCiAgICAgICAgY29uc3Qgc2NhbGFyID0gbm9ybWFsLmRvdCh2ZWN0b3IpIC8gZG90OyAvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5CgogICAgICAgIGlmIChzY2FsYXIgPCAwKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9IC8vIGlmIChkb3QgPCAwKSB7CiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXIKCgogICAgICAgIGRpcmVjdGlvbi5zY2FsZShzY2FsYXIsIGludGVyc2VjdFBvaW50KTsKICAgICAgICBpbnRlcnNlY3RQb2ludC52YWRkKGZyb20sIGludGVyc2VjdFBvaW50KTsgLy8gYSBpcyB0aGUgcG9pbnQgd2UgY29tcGFyZSBwb2ludHMgYiBhbmQgYyB3aXRoLgoKICAgICAgICBhLmNvcHkodmVydGljZXNbZmFjZVswXV0pOwogICAgICAgIHEudm11bHQoYSwgYSk7CiAgICAgICAgeC52YWRkKGEsIGEpOwoKICAgICAgICBmb3IgKGxldCBpID0gMTsgIXJlc3VsdC5zaG91bGRTdG9wICYmIGkgPCBmYWNlLmxlbmd0aCAtIDE7IGkrKykgewogICAgICAgICAgLy8gVHJhbnNmb3JtIDMgdmVydGljZXMgdG8gd29ybGQgY29vcmRzCiAgICAgICAgICBiLmNvcHkodmVydGljZXNbZmFjZVtpXV0pOwogICAgICAgICAgYy5jb3B5KHZlcnRpY2VzW2ZhY2VbaSArIDFdXSk7CiAgICAgICAgICBxLnZtdWx0KGIsIGIpOwogICAgICAgICAgcS52bXVsdChjLCBjKTsKICAgICAgICAgIHgudmFkZChiLCBiKTsKICAgICAgICAgIHgudmFkZChjLCBjKTsKICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhmcm9tKTsKCiAgICAgICAgICBpZiAoIShSYXkucG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSB8fCBSYXkucG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSkgfHwgZGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCBmaSk7CiAgICAgICAgfSAvLyB9CgogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEB0b2RvIE9wdGltaXplIGJ5IHRyYW5zZm9ybWluZyB0aGUgd29ybGQgdG8gbG9jYWwgc3BhY2UgZmlyc3QuCiAgICAgKiBAdG9kbyBVc2UgT2N0cmVlIGxvb2t1cAogICAgICovCgoKICAgIF9pbnRlcnNlY3RUcmltZXNoKG1lc2gsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlLCBvcHRpb25zKSB7CiAgICAgIGNvbnN0IG5vcm1hbCA9IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsOwogICAgICBjb25zdCB0cmlhbmdsZXMgPSBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlczsKICAgICAgY29uc3QgdHJlZVRyYW5zZm9ybSA9IGludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybTsKICAgICAgY29uc3QgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjsKICAgICAgY29uc3QgbG9jYWxEaXJlY3Rpb24gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uOwogICAgICBjb25zdCBsb2NhbEZyb20gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbTsKICAgICAgY29uc3QgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbzsKICAgICAgY29uc3Qgd29ybGRJbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFRyaW1lc2hfd29ybGRJbnRlcnNlY3RQb2ludDsKICAgICAgY29uc3Qgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsOyAvLyBDaGVja2luZyBmYWNlcwoKICAgICAgY29uc3QgaW5kaWNlcyA9IG1lc2guaW5kaWNlczsKICAgICAgbWVzaC52ZXJ0aWNlczsgLy8gY29uc3Qgbm9ybWFscyA9IG1lc2guZmFjZU5vcm1hbHMKCiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207CiAgICAgIGNvbnN0IHRvID0gdGhpcy50bzsKICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247CiAgICAgIHRyZWVUcmFuc2Zvcm0ucG9zaXRpb24uY29weShwb3NpdGlvbik7CiAgICAgIHRyZWVUcmFuc2Zvcm0ucXVhdGVybmlvbi5jb3B5KHF1YXQpOyAvLyBUcmFuc2Zvcm0gcmF5IHRvIGxvY2FsIHNwYWNlIQoKICAgICAgVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZGlyZWN0aW9uLCBsb2NhbERpcmVjdGlvbik7CiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZnJvbSwgbG9jYWxGcm9tKTsKICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCB0bywgbG9jYWxUbyk7CiAgICAgIGxvY2FsVG8ueCAqPSBtZXNoLnNjYWxlLng7CiAgICAgIGxvY2FsVG8ueSAqPSBtZXNoLnNjYWxlLnk7CiAgICAgIGxvY2FsVG8ueiAqPSBtZXNoLnNjYWxlLno7CiAgICAgIGxvY2FsRnJvbS54ICo9IG1lc2guc2NhbGUueDsKICAgICAgbG9jYWxGcm9tLnkgKj0gbWVzaC5zY2FsZS55OwogICAgICBsb2NhbEZyb20ueiAqPSBtZXNoLnNjYWxlLno7CiAgICAgIGxvY2FsVG8udnN1Yihsb2NhbEZyb20sIGxvY2FsRGlyZWN0aW9uKTsKICAgICAgbG9jYWxEaXJlY3Rpb24ubm9ybWFsaXplKCk7CiAgICAgIGNvbnN0IGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCA9IGxvY2FsRnJvbS5kaXN0YW5jZVNxdWFyZWQobG9jYWxUbyk7CiAgICAgIG1lc2gudHJlZS5yYXlRdWVyeSh0aGlzLCB0cmVlVHJhbnNmb3JtLCB0cmlhbmdsZXMpOwoKICAgICAgZm9yIChsZXQgaSA9IDAsIE4gPSB0cmlhbmdsZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCB0cmlhbmdsZXNJbmRleCA9IHRyaWFuZ2xlc1tpXTsKICAgICAgICBtZXNoLmdldE5vcm1hbCh0cmlhbmdsZXNJbmRleCwgbm9ybWFsKTsgLy8gZGV0ZXJtaW5lIGlmIHJheSBpbnRlcnNlY3RzIHRoZSBwbGFuZSBvZiB0aGUgZmFjZQogICAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbAogICAgICAgIC8vIEdldCBwbGFuZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy4uLgoKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogM10sIGEpOyAvLyAuLi5idXQgbWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgcmF5IGZyb20uIFdlJ2xsIGZpeCB0aGlzIGxhdGVyLgoKICAgICAgICBhLnZzdWIobG9jYWxGcm9tLCB2ZWN0b3IpOyAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZwoKICAgICAgICBjb25zdCBkb3QgPSBsb2NhbERpcmVjdGlvbi5kb3Qobm9ybWFsKTsgLy8gQmFpbCBvdXQgaWYgcmF5IGFuZCBwbGFuZSBhcmUgcGFyYWxsZWwKICAgICAgICAvLyBpZiAoTWF0aC5hYnMoIGRvdCApIDwgdGhpcy5wcmVjaXNpb24pewogICAgICAgIC8vICAgICBjb250aW51ZTsKICAgICAgICAvLyB9CiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZQoKICAgICAgICBjb25zdCBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7IC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXkKCiAgICAgICAgaWYgKHNjYWxhciA8IDApIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXIKCgogICAgICAgIGxvY2FsRGlyZWN0aW9uLnNjYWxlKHNjYWxhciwgaW50ZXJzZWN0UG9pbnQpOwogICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQobG9jYWxGcm9tLCBpbnRlcnNlY3RQb2ludCk7IC8vIEdldCB0cmlhbmdsZSB2ZXJ0aWNlcwoKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDFdLCBiKTsKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDJdLCBjKTsKICAgICAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVNxdWFyZWQobG9jYWxGcm9tKTsKCiAgICAgICAgaWYgKCEoUmF5LnBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYiwgYSwgYykgfHwgUmF5LnBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYSwgYiwgYykpIHx8IHNxdWFyZWREaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSAvLyB0cmFuc2Zvcm0gaW50ZXJzZWN0cG9pbnQgYW5kIG5vcm1hbCB0byB3b3JsZAoKCiAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZShxdWF0LCBub3JtYWwsIHdvcmxkTm9ybWFsKTsKICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIGludGVyc2VjdFBvaW50LCB3b3JsZEludGVyc2VjdFBvaW50KTsKICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbCwgd29ybGRJbnRlcnNlY3RQb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgdHJpYW5nbGVzSW5kZXgpOwogICAgICB9CgogICAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDsKICAgIH0KICAgIC8qKgogICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZQogICAgICovCgoKICAgIHJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBoaXRGYWNlSW5kZXgpIHsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTsKICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7IC8vIFNraXAgYmFjayBmYWNlcz8KCiAgICAgIGlmICh0aGlzLnNraXBCYWNrZmFjZXMgJiYgbm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbikgPiAwKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICByZXN1bHQuaGl0RmFjZUluZGV4ID0gdHlwZW9mIGhpdEZhY2VJbmRleCAhPT0gJ3VuZGVmaW5lZCcgPyBoaXRGYWNlSW5kZXggOiAtMTsKCiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7CiAgICAgICAgY2FzZSBSYXkuQUxMOgogICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlOwogICAgICAgICAgcmVzdWx0LnNldChmcm9tLCB0bywgbm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgZGlzdGFuY2UpOwogICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSBSYXkuQ0xPU0VTVDoKICAgICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdAogICAgICAgICAgaWYgKGRpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlIHx8ICFyZXN1bHQuaGFzSGl0KSB7CiAgICAgICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTsKICAgICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICAgIHJlc3VsdC5zZXQoZnJvbSwgdG8sIG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIGRpc3RhbmNlKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSBSYXkuQU5ZOgogICAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLgogICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlOwogICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICByZXN1bHQuc2V0KGZyb20sIHRvLCBub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBkaXN0YW5jZSk7CiAgICAgICAgICByZXN1bHQuc2hvdWxkU3RvcCA9IHRydWU7CiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBBcyBwZXIgIkJhcnljZW50cmljIFRlY2huaXF1ZSIgYXMgbmFtZWQKICAgICAqIHtAbGluayBodHRwczovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbCBoZXJlfSBidXQgd2l0aG91dCB0aGUgZGl2aXNpb24KICAgICAqLwoKCiAgICBzdGF0aWMgcG9pbnRJblRyaWFuZ2xlKHAsIGEsIGIsIGMpIHsKICAgICAgYy52c3ViKGEsIHYwKTsKICAgICAgYi52c3ViKGEsIHYxKTsKICAgICAgcC52c3ViKGEsIHYyKTsKICAgICAgY29uc3QgZG90MDAgPSB2MC5kb3QodjApOwogICAgICBjb25zdCBkb3QwMSA9IHYwLmRvdCh2MSk7CiAgICAgIGNvbnN0IGRvdDAyID0gdjAuZG90KHYyKTsKICAgICAgY29uc3QgZG90MTEgPSB2MS5kb3QodjEpOwogICAgICBjb25zdCBkb3QxMiA9IHYxLmRvdCh2Mik7CiAgICAgIGxldCB1OwogICAgICBsZXQgdjsKICAgICAgcmV0dXJuICh1ID0gZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpID49IDAgJiYgKHYgPSBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgPj0gMCAmJiB1ICsgdiA8IGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxOwogICAgfQoKICB9CiAgUmF5LkNMT1NFU1QgPSBSQVlfTU9ERVMuQ0xPU0VTVDsKICBSYXkuQU5ZID0gUkFZX01PREVTLkFOWTsKICBSYXkuQUxMID0gUkFZX01PREVTLkFMTDsKICBjb25zdCB0bXBBQUJCJDEgPSBuZXcgQUFCQigpOwogIGNvbnN0IHRtcEFycmF5ID0gW107CiAgY29uc3QgdjEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHYyID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RCb2R5X3hpID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RCb2R5X3FpID0gbmV3IFF1YXRlcm5pb24oKTsKICBjb25zdCBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYyA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgUmF5Y2FzdFJlc3VsdCgpOwogIGNvbnN0IGludGVyc2VjdENvbnZleE9wdGlvbnMgPSB7CiAgICBmYWNlTGlzdDogWzBdCiAgfTsKICBjb25zdCB3b3JsZFBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxSYXkgPSBuZXcgUmF5KCk7CiAgY29uc3QgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXggPSBbXTsKICBjb25zdCBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50ID0gbmV3IFZlYzMoKTsKICBjb25zdCBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0Q29udmV4X25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdENvbnZleF92ZWN0b3IgPSBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3dvcmxkSW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpOwogIG5ldyBBQUJCKCk7CiAgY29uc3QgaW50ZXJzZWN0VHJpbWVzaF90cmlhbmdsZXMgPSBbXTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7CiAgY29uc3QgdjAgPSBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdCA9IG5ldyBWZWMzKCk7CgogIGZ1bmN0aW9uIGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7CiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uCiAgICBwb3NpdGlvbi52c3ViKGZyb20sIHYwKTsKICAgIGNvbnN0IGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pOyAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24qZG90ICsgZnJvbQoKICAgIGRpcmVjdGlvbi5zY2FsZShkb3QsIGludGVyc2VjdCk7CiAgICBpbnRlcnNlY3QudmFkZChmcm9tLCBpbnRlcnNlY3QpOwogICAgY29uc3QgZGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7CiAgICByZXR1cm4gZGlzdGFuY2U7CiAgfQoKICAvKioKICAgKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy4KICAgKi8KICBjbGFzcyBTQVBCcm9hZHBoYXNlIGV4dGVuZHMgQnJvYWRwaGFzZSB7CiAgICAvKioKICAgICAqIExpc3Qgb2YgYm9kaWVzIGN1cnJlbnRseSBpbiB0aGUgYnJvYWRwaGFzZS4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi4KICAgICAqLwoKICAgIC8qKgogICAgICogQXhpcyB0byBzb3J0IHRoZSBib2RpZXMgYWxvbmcuCiAgICAgKiBTZXQgdG8gMCBmb3IgeCBheGlzLCBhbmQgMSBmb3IgeSBheGlzLgogICAgICogRm9yIGJlc3QgcGVyZm9ybWFuY2UsIHBpY2sgdGhlIGF4aXMgd2hlcmUgYm9kaWVzIGFyZSBtb3N0IGRpc3RyaWJ1dGVkLgogICAgICovCgogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgYm91bmRzIG9mIHR3byBib2RpZXMgb3ZlcmxhcCwgYWxvbmcgdGhlIGdpdmVuIFNBUCBheGlzLgogICAgICovCiAgICBzdGF0aWMgY2hlY2tCb3VuZHMoYmksIGJqLCBheGlzSW5kZXgpIHsKICAgICAgbGV0IGJpUG9zOwogICAgICBsZXQgYmpQb3M7CgogICAgICBpZiAoYXhpc0luZGV4ID09PSAwKSB7CiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi54OwogICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24ueDsKICAgICAgfSBlbHNlIGlmIChheGlzSW5kZXggPT09IDEpIHsKICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLnk7CiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi55OwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMikgewogICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24uejsKICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLno7CiAgICAgIH0KCiAgICAgIGNvbnN0IHJpID0gYmkuYm91bmRpbmdSYWRpdXMsCiAgICAgICAgICAgIHJqID0gYmouYm91bmRpbmdSYWRpdXMsCiAgICAgICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLAogICAgICAgICAgICBib3VuZEIxID0gYmpQb3MgLSByajsKICAgICAgcmV0dXJuIGJvdW5kQjEgPCBib3VuZEEyOwogICAgfSAvLyBOb3RlOiB0aGVzZSBhcmUgaWRlbnRpY2FsLCBzYXZlIGZvciB4L3kveiBsb3dlcmJvdW5kCgogICAgLyoqCiAgICAgKiBpbnNlcnRpb25Tb3J0WAogICAgICovCgoKICAgIHN0YXRpYyBpbnNlcnRpb25Tb3J0WChhKSB7CiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gYVtpXTsKICAgICAgICBsZXQgajsKCiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7CiAgICAgICAgICBpZiAoYVtqXS5hYWJiLmxvd2VyQm91bmQueCA8PSB2LmFhYmIubG93ZXJCb3VuZC54KSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGFbaiArIDFdID0gYVtqXTsKICAgICAgICB9CgogICAgICAgIGFbaiArIDFdID0gdjsKICAgICAgfQoKICAgICAgcmV0dXJuIGE7CiAgICB9CiAgICAvKioKICAgICAqIGluc2VydGlvblNvcnRZCiAgICAgKi8KCgogICAgc3RhdGljIGluc2VydGlvblNvcnRZKGEpIHsKICAgICAgZm9yIChsZXQgaSA9IDEsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgIGNvbnN0IHYgPSBhW2ldOwogICAgICAgIGxldCBqOwoKICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHsKICAgICAgICAgIGlmIChhW2pdLmFhYmIubG93ZXJCb3VuZC55IDw9IHYuYWFiYi5sb3dlckJvdW5kLnkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgYVtqICsgMV0gPSBhW2pdOwogICAgICAgIH0KCiAgICAgICAgYVtqICsgMV0gPSB2OwogICAgICB9CgogICAgICByZXR1cm4gYTsKICAgIH0KICAgIC8qKgogICAgICogaW5zZXJ0aW9uU29ydFoKICAgICAqLwoKCiAgICBzdGF0aWMgaW5zZXJ0aW9uU29ydFooYSkgewogICAgICBmb3IgKGxldCBpID0gMSwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgY29uc3QgdiA9IGFbaV07CiAgICAgICAgbGV0IGo7CgogICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkgewogICAgICAgICAgaWYgKGFbal0uYWFiYi5sb3dlckJvdW5kLnogPD0gdi5hYWJiLmxvd2VyQm91bmQueikgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBhW2ogKyAxXSA9IGFbal07CiAgICAgICAgfQoKICAgICAgICBhW2ogKyAxXSA9IHY7CiAgICAgIH0KCiAgICAgIHJldHVybiBhOwogICAgfQoKICAgIGNvbnN0cnVjdG9yKHdvcmxkKSB7CiAgICAgIHN1cGVyKCk7CiAgICAgIHRoaXMuYXhpc0xpc3QgPSBbXTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDsKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwoKICAgICAgdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBldmVudCA9PiB7CiAgICAgICAgYXhpc0xpc3QucHVzaChldmVudC5ib2R5KTsKICAgICAgfTsKCiAgICAgIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyID0gZXZlbnQgPT4gewogICAgICAgIGNvbnN0IGlkeCA9IGF4aXNMaXN0LmluZGV4T2YoZXZlbnQuYm9keSk7CgogICAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgICBheGlzTGlzdC5zcGxpY2UoaWR4LCAxKTsKICAgICAgICB9CiAgICAgIH07CgogICAgICBpZiAod29ybGQpIHsKICAgICAgICB0aGlzLnNldFdvcmxkKHdvcmxkKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDaGFuZ2UgdGhlIHdvcmxkCiAgICAgKi8KCgogICAgc2V0V29ybGQod29ybGQpIHsKICAgICAgLy8gQ2xlYXIgdGhlIG9sZCBheGlzIGFycmF5CiAgICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDsgLy8gQWRkIGFsbCBib2RpZXMgZnJvbSB0aGUgbmV3IHdvcmxkCgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKykgewogICAgICAgIHRoaXMuYXhpc0xpc3QucHVzaCh3b3JsZC5ib2RpZXNbaV0pOwogICAgICB9IC8vIFJlbW92ZSBvbGQgaGFuZGxlcnMsIGlmIGFueQoKCiAgICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZEJvZHknLCB0aGlzLl9hZGRCb2R5SGFuZGxlcik7CiAgICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZUJvZHknLCB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7IC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLgoKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcignYWRkQm9keScsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTsKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZlQm9keScsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTsKICAgICAgdGhpcy53b3JsZCA9IHdvcmxkOwogICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ29sbGVjdCBhbGwgY29sbGlzaW9uIHBhaXJzCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHAxLCBwMikgewogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmF4aXNMaXN0OwogICAgICBjb25zdCBOID0gYm9kaWVzLmxlbmd0aDsKICAgICAgY29uc3QgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7CiAgICAgIGxldCBpOwogICAgICBsZXQgajsKCiAgICAgIGlmICh0aGlzLmRpcnR5KSB7CiAgICAgICAgdGhpcy5zb3J0TGlzdCgpOwogICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTsKICAgICAgfSAvLyBMb29rIHRocm91Z2ggdGhlIGxpc3QKCgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKCiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBOOyBqKyspIHsKICAgICAgICAgIGNvbnN0IGJqID0gYm9kaWVzW2pdOwoKICAgICAgICAgIGlmICghdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSwgYmopKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyhiaSwgYmosIGF4aXNJbmRleCkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLCBiaiwgcDEsIHAyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBzb3J0TGlzdCgpIHsKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwogICAgICBjb25zdCBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDsKICAgICAgY29uc3QgTiA9IGF4aXNMaXN0Lmxlbmd0aDsgLy8gVXBkYXRlIEFBQkJzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYmkgPSBheGlzTGlzdFtpXTsKCiAgICAgICAgaWYgKGJpLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYmkudXBkYXRlQUFCQigpOwogICAgICAgIH0KICAgICAgfSAvLyBTb3J0IHRoZSBsaXN0CgoKICAgICAgaWYgKGF4aXNJbmRleCA9PT0gMCkgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFgoYXhpc0xpc3QpOwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMSkgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkoYXhpc0xpc3QpOwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMikgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFooYXhpc0xpc3QpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIHRoZSB2YXJpYW5jZSBvZiB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIGVzdGltYXRlcyB0aGUgYmVzdCBheGlzIHRvIHVzZS4KICAgICAqIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgYGF4aXNJbmRleGAuCiAgICAgKi8KCgogICAgYXV0b0RldGVjdEF4aXMoKSB7CiAgICAgIGxldCBzdW1YID0gMDsKICAgICAgbGV0IHN1bVgyID0gMDsKICAgICAgbGV0IHN1bVkgPSAwOwogICAgICBsZXQgc3VtWTIgPSAwOwogICAgICBsZXQgc3VtWiA9IDA7CiAgICAgIGxldCBzdW1aMiA9IDA7CiAgICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYXhpc0xpc3Q7CiAgICAgIGNvbnN0IE4gPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBpbnZOID0gMSAvIE47CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYiA9IGJvZGllc1tpXTsKICAgICAgICBjb25zdCBjZW50ZXJYID0gYi5wb3NpdGlvbi54OwogICAgICAgIHN1bVggKz0gY2VudGVyWDsKICAgICAgICBzdW1YMiArPSBjZW50ZXJYICogY2VudGVyWDsKICAgICAgICBjb25zdCBjZW50ZXJZID0gYi5wb3NpdGlvbi55OwogICAgICAgIHN1bVkgKz0gY2VudGVyWTsKICAgICAgICBzdW1ZMiArPSBjZW50ZXJZICogY2VudGVyWTsKICAgICAgICBjb25zdCBjZW50ZXJaID0gYi5wb3NpdGlvbi56OwogICAgICAgIHN1bVogKz0gY2VudGVyWjsKICAgICAgICBzdW1aMiArPSBjZW50ZXJaICogY2VudGVyWjsKICAgICAgfQoKICAgICAgY29uc3QgdmFyaWFuY2VYID0gc3VtWDIgLSBzdW1YICogc3VtWCAqIGludk47CiAgICAgIGNvbnN0IHZhcmlhbmNlWSA9IHN1bVkyIC0gc3VtWSAqIHN1bVkgKiBpbnZOOwogICAgICBjb25zdCB2YXJpYW5jZVogPSBzdW1aMiAtIHN1bVogKiBzdW1aICogaW52TjsKCiAgICAgIGlmICh2YXJpYW5jZVggPiB2YXJpYW5jZVkpIHsKICAgICAgICBpZiAodmFyaWFuY2VYID4gdmFyaWFuY2VaKSB7CiAgICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodmFyaWFuY2VZID4gdmFyaWFuY2VaKSB7CiAgICAgICAgdGhpcy5heGlzSW5kZXggPSAxOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLgogICAgICovCgoKICAgIGFhYmJRdWVyeSh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IFtdOwogICAgICB9CgogICAgICBpZiAodGhpcy5kaXJ0eSkgewogICAgICAgIHRoaXMuc29ydExpc3QoKTsKICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4OwogICAgICBsZXQgYXhpcyA9ICd4JzsKCiAgICAgIGlmIChheGlzSW5kZXggPT09IDEpIHsKICAgICAgICBheGlzID0gJ3knOwogICAgICB9CgogICAgICBpZiAoYXhpc0luZGV4ID09PSAyKSB7CiAgICAgICAgYXhpcyA9ICd6JzsKICAgICAgfQoKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwogICAgICBhYWJiLmxvd2VyQm91bmRbYXhpc107CiAgICAgIGFhYmIudXBwZXJCb3VuZFtheGlzXTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBiID0gYXhpc0xpc3RbaV07CgogICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYi51cGRhdGVBQUJCKCk7CiAgICAgICAgfQoKICAgICAgICBpZiAoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKSB7CiAgICAgICAgICByZXN1bHQucHVzaChiKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CgogIH0KCiAgY2xhc3MgVXRpbHMgewogICAgLyoqCiAgICAgKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy4KICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIG9iamVjdC4gTWF5IGJlIGZhbHN5OiBpbiB0aGlzIGNhc2UsIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC4KICAgICAqIEBwYXJhbSBkZWZhdWx0cyBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHZhbHVlcy4KICAgICAqIEByZXR1cm4gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LgogICAgICovCiAgICBzdGF0aWMgZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdHMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKSB7CiAgICAgICAgaWYgKCEoa2V5IGluIG9wdGlvbnMpKSB7CiAgICAgICAgICBvcHRpb25zW2tleV0gPSBkZWZhdWx0c1trZXldOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG9wdGlvbnM7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQ29uc3RyYWludCBiYXNlIGNsYXNzCiAgICovCiAgY2xhc3MgQ29uc3RyYWludCB7CiAgICAvKioKICAgICAqIEVxdWF0aW9ucyB0byBiZSBzb2x2ZWQgaW4gdGhpcyBjb25zdHJhaW50LgogICAgICovCgogICAgLyoqCiAgICAgKiBCb2R5IEEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEJvZHkgQi4KICAgICAqLwoKICAgIC8qKgogICAgICogU2V0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBib2RpZXMgdG8gY29sbGlkZSB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZC4KICAgICAqLwogICAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7CiAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdHJ1ZSwKICAgICAgICB3YWtlVXBCb2RpZXM6IHRydWUKICAgICAgfSk7CiAgICAgIHRoaXMuZXF1YXRpb25zID0gW107CiAgICAgIHRoaXMuYm9keUEgPSBib2R5QTsKICAgICAgdGhpcy5ib2R5QiA9IGJvZHlCOwogICAgICB0aGlzLmlkID0gQ29uc3RyYWludC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkOwoKICAgICAgaWYgKG9wdGlvbnMud2FrZVVwQm9kaWVzKSB7CiAgICAgICAgaWYgKGJvZHlBKSB7CiAgICAgICAgICBib2R5QS53YWtlVXAoKTsKICAgICAgICB9CgogICAgICAgIGlmIChib2R5QikgewogICAgICAgICAgYm9keUIud2FrZVVwKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFVwZGF0ZSBhbGwgdGhlIGVxdWF0aW9ucyB3aXRoIGRhdGEuCiAgICAgKi8KCgogICAgdXBkYXRlKCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyEnKTsKICAgIH0KICAgIC8qKgogICAgICogRW5hYmxlcyBhbGwgZXF1YXRpb25zIGluIHRoZSBjb25zdHJhaW50LgogICAgICovCgoKICAgIGVuYWJsZSgpIHsKICAgICAgY29uc3QgZXFzID0gdGhpcy5lcXVhdGlvbnM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVxcy5sZW5ndGg7IGkrKykgewogICAgICAgIGVxc1tpXS5lbmFibGVkID0gdHJ1ZTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBEaXNhYmxlcyBhbGwgZXF1YXRpb25zIGluIHRoZSBjb25zdHJhaW50LgogICAgICovCgoKICAgIGRpc2FibGUoKSB7CiAgICAgIGNvbnN0IGVxcyA9IHRoaXMuZXF1YXRpb25zOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBlcXNbaV0uZW5hYmxlZCA9IGZhbHNlOwogICAgICB9CiAgICB9CgogIH0KICBDb25zdHJhaW50LmlkQ291bnRlciA9IDA7CgogIC8qKgogICAqIEFuIGVsZW1lbnQgY29udGFpbmluZyA2IGVudHJpZXMsIDMgc3BhdGlhbCBhbmQgMyByb3RhdGlvbmFsIGRlZ3JlZXMgb2YgZnJlZWRvbS4KICAgKi8KCiAgY2xhc3MgSmFjb2JpYW5FbGVtZW50IHsKICAgIC8qKgogICAgICogc3BhdGlhbAogICAgICovCgogICAgLyoqCiAgICAgKiByb3RhdGlvbmFsCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLnNwYXRpYWwgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnJvdGF0aW9uYWwgPSBuZXcgVmVjMygpOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB3aXRoIG90aGVyIEphY29iaWFuRWxlbWVudAogICAgICovCgoKICAgIG11bHRpcGx5RWxlbWVudChlbGVtZW50KSB7CiAgICAgIHJldHVybiBlbGVtZW50LnNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyBlbGVtZW50LnJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7CiAgICB9CiAgICAvKioKICAgICAqIE11bHRpcGx5IHdpdGggdHdvIHZlY3RvcnMKICAgICAqLwoKCiAgICBtdWx0aXBseVZlY3RvcnMoc3BhdGlhbCwgcm90YXRpb25hbCkgewogICAgICByZXR1cm4gc3BhdGlhbC5kb3QodGhpcy5zcGF0aWFsKSArIHJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7CiAgICB9CgogIH0KCiAgLyoqCiAgICogRXF1YXRpb24gYmFzZSBjbGFzcy4KICAgKgogICAqIGBhYCwgYGJgIGFuZCBgZXBzYCBhcmUge0BsaW5rIGh0dHBzOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDE1L2xlY3R1cmVzL1NQT09LbGFibm90ZXMucGRmIFNQT09LfSBwYXJhbWV0ZXJzIHRoYXQgZGVmYXVsdCB0byBgMC4wYC4gU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzL2lzc3Vlcy8yMzgjaXNzdWVjb21tZW50LTE0NzE3MjMyNyB0aGlzIGV4Y2hhbmdlfSBmb3IgbW9yZSBkZXRhaWxzIG9uIENhbm5vbidzIHBoeXNpY3MgaW1wbGVtZW50YXRpb24uCiAgICovCiAgY2xhc3MgRXF1YXRpb24gewogICAgLyoqCiAgICAgKiBNaW5pbXVtIChyZWFkOiBuZWdhdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1heGltdW0gKHJlYWQ6IHBvc2l0aXZlIG1heCkgZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludC4KICAgICAqLwoKICAgIC8qKgogICAgICogU1BPT0sgcGFyYW1ldGVyCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNQT09LIHBhcmFtZXRlcgogICAgICovCgogICAgLyoqCiAgICAgKiBTUE9PSyBwYXJhbWV0ZXIKICAgICAqLwoKICAgIC8qKgogICAgICogQSBudW1iZXIsIHByb3BvcnRpb25hbCB0byB0aGUgZm9yY2UgYWRkZWQgdG8gdGhlIGJvZGllcy4KICAgICAqLwogICAgY29uc3RydWN0b3IoYmksIGJqLCBtaW5Gb3JjZSwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1pbkZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtaW5Gb3JjZSA9IC0xZTY7CiAgICAgIH0KCiAgICAgIGlmIChtYXhGb3JjZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7CiAgICAgIH0KCiAgICAgIHRoaXMuaWQgPSBFcXVhdGlvbi5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5taW5Gb3JjZSA9IG1pbkZvcmNlOwogICAgICB0aGlzLm1heEZvcmNlID0gbWF4Rm9yY2U7CiAgICAgIHRoaXMuYmkgPSBiaTsKICAgICAgdGhpcy5iaiA9IGJqOwogICAgICB0aGlzLmEgPSAwLjA7IC8vIFNQT09LIHBhcmFtZXRlcgoKICAgICAgdGhpcy5iID0gMC4wOyAvLyBTUE9PSyBwYXJhbWV0ZXIKCiAgICAgIHRoaXMuZXBzID0gMC4wOyAvLyBTUE9PSyBwYXJhbWV0ZXIKCiAgICAgIHRoaXMuamFjb2JpYW5FbGVtZW50QSA9IG5ldyBKYWNvYmlhbkVsZW1lbnQoKTsKICAgICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRCID0gbmV3IEphY29iaWFuRWxlbWVudCgpOwogICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlOwogICAgICB0aGlzLm11bHRpcGxpZXIgPSAwOwogICAgICB0aGlzLnNldFNwb29rUGFyYW1zKDFlNywgNCwgMSAvIDYwKTsgLy8gU2V0IHR5cGljYWwgc3Bvb2sgcGFyYW1zCiAgICB9CiAgICAvKioKICAgICAqIFJlY2FsY3VsYXRlcyBhLCBiLCBhbmQgZXBzLgogICAgICoKICAgICAqIFRoZSBFcXVhdGlvbiBjb25zdHJ1Y3RvciBzZXRzIHR5cGljYWwgU1BPT0sgcGFyYW1ldGVycyBhcyBzdWNoOgogICAgICogKiBgc3RpZmZuZXNzYCA9IDFlNwogICAgICogKiBgcmVsYXhhdGlvbmAgPSA0CiAgICAgKiAqIGB0aW1lU3RlcGA9IDEgLyA2MCwgX25vdGUgdGhlIGhhcmRjb2RlZCByZWZyZXNoIHJhdGUuXwogICAgICovCgoKICAgIHNldFNwb29rUGFyYW1zKHN0aWZmbmVzcywgcmVsYXhhdGlvbiwgdGltZVN0ZXApIHsKICAgICAgY29uc3QgZCA9IHJlbGF4YXRpb247CiAgICAgIGNvbnN0IGsgPSBzdGlmZm5lc3M7CiAgICAgIGNvbnN0IGggPSB0aW1lU3RlcDsKICAgICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7CiAgICAgIHRoaXMuYiA9IDQuMCAqIGQgLyAoMSArIDQgKiBkKTsKICAgICAgdGhpcy5lcHMgPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBTUE9PSyBlcXVhdGlvbgogICAgICovCgoKICAgIGNvbXB1dGVCKGEsIGIsIGgpIHsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHcSA9IHRoaXMuY29tcHV0ZUdxKCk7CiAgICAgIGNvbnN0IEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7CiAgICAgIHJldHVybiAtR3EgKiBhIC0gR1cgKiBiIC0gR2lNZiAqIGg7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIEcqcSwgd2hlcmUgcSBhcmUgdGhlIGdlbmVyYWxpemVkIGJvZHkgY29vcmRpbmF0ZXMKICAgICAqLwoKCiAgICBjb21wdXRlR3EoKSB7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgY29uc3QgYmkgPSB0aGlzLmJpOwogICAgICBjb25zdCBiaiA9IHRoaXMuYmo7CiAgICAgIGNvbnN0IHhpID0gYmkucG9zaXRpb247CiAgICAgIGNvbnN0IHhqID0gYmoucG9zaXRpb247CiAgICAgIHJldHVybiBHQS5zcGF0aWFsLmRvdCh4aSkgKyBHQi5zcGF0aWFsLmRvdCh4aik7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIEcqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllcwogICAgICovCgoKICAgIGNvbXB1dGVHVygpIHsKICAgICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7CiAgICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgdmkgPSBiaS52ZWxvY2l0eTsKICAgICAgY29uc3QgdmogPSBiai52ZWxvY2l0eTsKICAgICAgY29uc3Qgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHk7CiAgICAgIGNvbnN0IHdqID0gYmouYW5ndWxhclZlbG9jaXR5OwogICAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLCB3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosIHdqKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZXMgRypXbGFtYmRhLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzCiAgICAgKi8KCgogICAgY29tcHV0ZUdXbGFtYmRhKCkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCB2aSA9IGJpLnZsYW1iZGE7CiAgICAgIGNvbnN0IHZqID0gYmoudmxhbWJkYTsKICAgICAgY29uc3Qgd2kgPSBiaS53bGFtYmRhOwogICAgICBjb25zdCB3aiA9IGJqLndsYW1iZGE7CiAgICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnModmksIHdpKSArIEdCLm11bHRpcGx5VmVjdG9ycyh2aiwgd2opOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyBHKmludihNKSpmLCB3aGVyZSBNIGlzIHRoZSBtYXNzIG1hdHJpeCB3aXRoIGRpYWdvbmFsIGJsb2NrcyBmb3IgZWFjaCBib2R5LCBhbmQgZiBhcmUgdGhlIGZvcmNlcyBvbiB0aGUgYm9kaWVzLgogICAgICovCgoKICAgIGNvbXB1dGVHaU1mKCkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCBmaSA9IGJpLmZvcmNlOwogICAgICBjb25zdCB0aSA9IGJpLnRvcnF1ZTsKICAgICAgY29uc3QgZmogPSBiai5mb3JjZTsKICAgICAgY29uc3QgdGogPSBiai50b3JxdWU7CiAgICAgIGNvbnN0IGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlOwogICAgICBjb25zdCBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZTsKICAgICAgZmkuc2NhbGUoaW52TWFzc2ksIGlNZmkpOwogICAgICBmai5zY2FsZShpbnZNYXNzaiwgaU1maik7CiAgICAgIGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRpLCBpbnZJaV92bXVsdF90YXVpKTsKICAgICAgYmouaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQodGosIGludklqX3ZtdWx0X3RhdWopOwogICAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKGlNZmksIGludklpX3ZtdWx0X3RhdWkpICsgR0IubXVsdGlwbHlWZWN0b3JzKGlNZmosIGludklqX3ZtdWx0X3RhdWopOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyBHKmludihNKSpHJwogICAgICovCgoKICAgIGNvbXB1dGVHaU1HdCgpIHsKICAgICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7CiAgICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmU7CiAgICAgIGNvbnN0IGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlOwogICAgICBjb25zdCBpbnZJaSA9IGJpLmludkluZXJ0aWFXb3JsZFNvbHZlOwogICAgICBjb25zdCBpbnZJaiA9IGJqLmludkluZXJ0aWFXb3JsZFNvbHZlOwogICAgICBsZXQgcmVzdWx0ID0gaW52TWFzc2kgKyBpbnZNYXNzajsKICAgICAgaW52SWkudm11bHQoR0Eucm90YXRpb25hbCwgdG1wKTsKICAgICAgcmVzdWx0ICs9IHRtcC5kb3QoR0Eucm90YXRpb25hbCk7CiAgICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsIHRtcCk7CiAgICAgIHJlc3VsdCArPSB0bXAuZG90KEdCLnJvdGF0aW9uYWwpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLgogICAgICovCgoKICAgIGFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXA7IC8vIEFkZCB0byBsaW5lYXIgdmVsb2NpdHkKICAgICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHCgogICAgICBiaS52bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihiaS5pbnZNYXNzU29sdmUgKiBkZWx0YWxhbWJkYSwgR0Euc3BhdGlhbCwgYmkudmxhbWJkYSk7CiAgICAgIGJqLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJqLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQi5zcGF0aWFsLCBiai52bGFtYmRhKTsgLy8gQWRkIHRvIGFuZ3VsYXIgdmVsb2NpdHkKCiAgICAgIGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdBLnJvdGF0aW9uYWwsIHRlbXApOwogICAgICBiaS53bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihkZWx0YWxhbWJkYSwgdGVtcCwgYmkud2xhbWJkYSk7CiAgICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdCLnJvdGF0aW9uYWwsIHRlbXApOwogICAgICBiai53bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihkZWx0YWxhbWJkYSwgdGVtcCwgYmoud2xhbWJkYSk7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gRyppbnYoTSkqRycgKyBlcHMKICAgICAqLwoKCiAgICBjb21wdXRlQygpIHsKICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpTUd0KCkgKyB0aGlzLmVwczsKICAgIH0KCiAgfQogIEVxdWF0aW9uLmlkQ291bnRlciA9IDA7CiAgY29uc3QgaU1maSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaU1maiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW52SWlfdm11bHRfdGF1aSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW52SWpfdm11bHRfdGF1aiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wID0gbmV3IFZlYzMoKTsKICBjb25zdCBhZGRUb1dsYW1iZGFfdGVtcCA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIENvbnRhY3Qvbm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb24KICAgKi8KICBjbGFzcyBDb250YWN0RXF1YXRpb24gZXh0ZW5kcyBFcXVhdGlvbiB7CiAgICAvKioKICAgICAqICJib3VuY2luZXNzIjogdTEgPSAtZSp1MAogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBnb2VzIGZyb20gdGhlIGNlbnRlciBvZiBiaSB0byB0aGUgY29udGFjdCBwb2ludC4KICAgICAqLwoKICAgIC8qKgogICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIHRoYXQgc3RhcnRzIGluIGJvZHkgaiBwb3NpdGlvbiBhbmQgZ29lcyB0byB0aGUgY29udGFjdCBwb2ludC4KICAgICAqLwoKICAgIC8qKgogICAgICogQ29udGFjdCBub3JtYWwsIHBvaW50aW5nIG91dCBvZiBib2R5IGkuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1heEZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtYXhGb3JjZSA9IDFlNjsKICAgICAgfQoKICAgICAgc3VwZXIoYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7CiAgICAgIHRoaXMucmkgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnJqID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5uaSA9IG5ldyBWZWMzKCk7CiAgICB9CgogICAgY29tcHV0ZUIoaCkgewogICAgICBjb25zdCBhID0gdGhpcy5hOwogICAgICBjb25zdCBiID0gdGhpcy5iOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgcmkgPSB0aGlzLnJpOwogICAgICBjb25zdCByaiA9IHRoaXMucmo7CiAgICAgIGNvbnN0IHJpeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDE7CiAgICAgIGNvbnN0IHJqeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDI7CiAgICAgIGNvbnN0IHZpID0gYmkudmVsb2NpdHk7CiAgICAgIGNvbnN0IHdpID0gYmkuYW5ndWxhclZlbG9jaXR5OwogICAgICBiaS5mb3JjZTsKICAgICAgYmkudG9ycXVlOwogICAgICBjb25zdCB2aiA9IGJqLnZlbG9jaXR5OwogICAgICBjb25zdCB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTsKICAgICAgYmouZm9yY2U7CiAgICAgIGJqLnRvcnF1ZTsKICAgICAgY29uc3QgcGVuZXRyYXRpb25WZWMgPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDM7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgY29uc3QgbiA9IHRoaXMubmk7IC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0cwoKICAgICAgcmkuY3Jvc3Mobiwgcml4bik7CiAgICAgIHJqLmNyb3NzKG4sIHJqeG4pOyAvLyBnID0geGorcmogLSh4aStyaSkKICAgICAgLy8gRyA9IFsgLW5pICAtcml4biAgbmkgIHJqeG4gXQoKICAgICAgbi5uZWdhdGUoR0Euc3BhdGlhbCk7CiAgICAgIHJpeG4ubmVnYXRlKEdBLnJvdGF0aW9uYWwpOwogICAgICBHQi5zcGF0aWFsLmNvcHkobik7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShyanhuKTsgLy8gQ2FsY3VsYXRlIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3IKCiAgICAgIHBlbmV0cmF0aW9uVmVjLmNvcHkoYmoucG9zaXRpb24pOwogICAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLCBwZW5ldHJhdGlvblZlYyk7CiAgICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIoYmkucG9zaXRpb24sIHBlbmV0cmF0aW9uVmVjKTsKICAgICAgcGVuZXRyYXRpb25WZWMudnN1YihyaSwgcGVuZXRyYXRpb25WZWMpOwogICAgICBjb25zdCBnID0gbi5kb3QocGVuZXRyYXRpb25WZWMpOyAvLyBDb21wdXRlIGl0ZXJhdGlvbgoKICAgICAgY29uc3QgZVBsdXNPbmUgPSB0aGlzLnJlc3RpdHV0aW9uICsgMTsKICAgICAgY29uc3QgR1cgPSBlUGx1c09uZSAqIHZqLmRvdChuKSAtIGVQbHVzT25lICogdmkuZG90KG4pICsgd2ouZG90KHJqeG4pIC0gd2kuZG90KHJpeG4pOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLWcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7CiAgICAgIHJldHVybiBCOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcmVsYXRpdmUgdmVsb2NpdHkgaW4gdGhlIGNvbnRhY3QgcG9pbnQuCiAgICAgKi8KCgogICAgZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCgpIHsKICAgICAgY29uc3QgdmkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aTsKICAgICAgY29uc3QgdmogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92ajsKICAgICAgY29uc3QgeGkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aTsKICAgICAgY29uc3QgeGogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94ajsKICAgICAgY29uc3QgcmVsVmVsID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfcmVsVmVsOwogICAgICB0aGlzLmJpLnBvc2l0aW9uLnZhZGQodGhpcy5yaSwgeGkpOwogICAgICB0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaiwgeGopOwogICAgICB0aGlzLmJpLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHhpLCB2aSk7CiAgICAgIHRoaXMuYmouZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGosIHZqKTsKICAgICAgdmkudnN1Yih2aiwgcmVsVmVsKTsKICAgICAgcmV0dXJuIHRoaXMubmkuZG90KHJlbFZlbCk7CiAgICB9CgogIH0KICBjb25zdCBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnMKCiAgY29uc3QgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMgPSBuZXcgVmVjMygpOwogIGNvbnN0IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZpID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGkgPSBuZXcgVmVjMygpOwogIGNvbnN0IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3hqID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWwgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3QgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSkKICAgKiAgICAgY29uc3QgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSkKICAgKiAgICAgYm9keUEucG9zaXRpb24uc2V0KC0xLCAwLCAwKQogICAqICAgICBib2R5Qi5wb3NpdGlvbi5zZXQoMSwgMCwgMCkKICAgKiAgICAgYm9keUEuYWRkU2hhcGUoc2hhcGVBKQogICAqICAgICBib2R5Qi5hZGRTaGFwZShzaGFwZUIpCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUEpCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUIpCiAgICogICAgIGNvbnN0IGxvY2FsUGl2b3RBID0gbmV3IFZlYzMoMSwgMCwgMCkKICAgKiAgICAgY29uc3QgbG9jYWxQaXZvdEIgPSBuZXcgVmVjMygtMSwgMCwgMCkKICAgKiAgICAgY29uc3QgY29uc3RyYWludCA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KGJvZHlBLCBsb2NhbFBpdm90QSwgYm9keUIsIGxvY2FsUGl2b3RCKQogICAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpCiAgICovCiAgY2xhc3MgUG9pbnRUb1BvaW50Q29uc3RyYWludCBleHRlbmRzIENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLgogICAgICovCgogICAgLyoqCiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLgogICAgICovCgogICAgLyoqCiAgICAgKiBAcGFyYW0gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uCiAgICAgKiBAcGFyYW0gYm9keUIgQm9keSB0aGF0IHdpbGwgYmUgY29uc3RyYWluZWQgaW4gYSBzaW1pbGFyIHdheSB0byB0aGUgc2FtZSBwb2ludCBhcyBib2R5QS4gV2Ugd2lsbCB0aGVyZWZvcmUgZ2V0IGEgbGluayBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5Qi4gSWYgbm90IHNwZWNpZmllZCwgYm9keUEgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBhIHN0YXRpYyBwb2ludC4KICAgICAqIEBwYXJhbSBwaXZvdEIgVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiBib2R5QiB3aGljaCBib2R5QiBpcyBjb25zdHJhaW5lZCB0by4KICAgICAqIEBwYXJhbSBtYXhGb3JjZSBUaGUgbWF4aW11bSBmb3JjZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNvbnN0cmFpbiB0aGUgYm9kaWVzLgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSkgewogICAgICBpZiAocGl2b3RBID09PSB2b2lkIDApIHsKICAgICAgICBwaXZvdEEgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAocGl2b3RCID09PSB2b2lkIDApIHsKICAgICAgICBwaXZvdEIgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAobWF4Rm9yY2UgPT09IHZvaWQgMCkgewogICAgICAgIG1heEZvcmNlID0gMWU2OwogICAgICB9CgogICAgICBzdXBlcihib2R5QSwgYm9keUIpOwogICAgICB0aGlzLnBpdm90QSA9IHBpdm90QS5jbG9uZSgpOwogICAgICB0aGlzLnBpdm90QiA9IHBpdm90Qi5jbG9uZSgpOwogICAgICBjb25zdCB4ID0gdGhpcy5lcXVhdGlvblggPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7CiAgICAgIGNvbnN0IHkgPSB0aGlzLmVxdWF0aW9uWSA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKTsKICAgICAgY29uc3QgeiA9IHRoaXMuZXF1YXRpb25aID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIpOyAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXIKCiAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goeCwgeSwgeik7IC8vIE1ha2UgdGhlIGVxdWF0aW9ucyBiaWRpcmVjdGlvbmFsCgogICAgICB4Lm1pbkZvcmNlID0geS5taW5Gb3JjZSA9IHoubWluRm9yY2UgPSAtbWF4Rm9yY2U7CiAgICAgIHgubWF4Rm9yY2UgPSB5Lm1heEZvcmNlID0gei5tYXhGb3JjZSA9IG1heEZvcmNlOwogICAgICB4Lm5pLnNldCgxLCAwLCAwKTsKICAgICAgeS5uaS5zZXQoMCwgMSwgMCk7CiAgICAgIHoubmkuc2V0KDAsIDAsIDEpOwogICAgfQoKICAgIHVwZGF0ZSgpIHsKICAgICAgY29uc3QgYm9keUEgPSB0aGlzLmJvZHlBOwogICAgICBjb25zdCBib2R5QiA9IHRoaXMuYm9keUI7CiAgICAgIGNvbnN0IHggPSB0aGlzLmVxdWF0aW9uWDsKICAgICAgY29uc3QgeSA9IHRoaXMuZXF1YXRpb25ZOwogICAgICBjb25zdCB6ID0gdGhpcy5lcXVhdGlvblo7IC8vIFJvdGF0ZSB0aGUgcGl2b3RzIHRvIHdvcmxkIHNwYWNlCgogICAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLCB4LnJpKTsKICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90QiwgeC5yaik7CiAgICAgIHkucmkuY29weSh4LnJpKTsKICAgICAgeS5yai5jb3B5KHgucmopOwogICAgICB6LnJpLmNvcHkoeC5yaSk7CiAgICAgIHoucmouY29weSh4LnJqKTsKICAgIH0KCiAgfQoKICAvKioKICAgKiBDb25lIGVxdWF0aW9uLiBXb3JrcyB0byBrZWVwIHRoZSBnaXZlbiBib2R5IHdvcmxkIHZlY3RvcnMgYWxpZ25lZCwgb3IgdGlsdGVkIHdpdGhpbiBhIGdpdmVuIGFuZ2xlIGZyb20gZWFjaCBvdGhlci4KICAgKi8KICBjbGFzcyBDb25lRXF1YXRpb24gZXh0ZW5kcyBFcXVhdGlvbiB7CiAgICAvKioKICAgICAqIExvY2FsIGF4aXMgaW4gQQogICAgICovCgogICAgLyoqCiAgICAgKiBMb2NhbCBheGlzIGluIEIKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlICJjb25lIGFuZ2xlIiB0byBrZWVwCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7CiAgICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy5hbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIGNvbnN0IGEgPSB0aGlzLmE7CiAgICAgIGNvbnN0IGIgPSB0aGlzLmI7CiAgICAgIGNvbnN0IG5pID0gdGhpcy5heGlzQTsKICAgICAgY29uc3QgbmogPSB0aGlzLmF4aXNCOwogICAgICBjb25zdCBuaXhuaiA9IHRtcFZlYzEkMjsKICAgICAgY29uc3Qgbmp4bmkgPSB0bXBWZWMyJDI7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzCgogICAgICBuaS5jcm9zcyhuaiwgbml4bmopOwogICAgICBuai5jcm9zcyhuaSwgbmp4bmkpOyAvLyBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yIGlzOgogICAgICAvLyBjb3ModGhldGEpID0gYSAqIGIgLyAobGVuZ3RoKGEpICogbGVuZ3RoKGIpID0geyBsZW4oYSkgPSBsZW4oYikgPSAxIH0gPSBhICogYgogICAgICAvLyBnID0gYSAqIGIKICAgICAgLy8gZ2RvdCA9IChiIHggYSkgKiB3aSArIChhIHggYikgKiB3agogICAgICAvLyBHID0gWzAgYnhhIDAgYXhiXQogICAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXQoKICAgICAgR0Eucm90YXRpb25hbC5jb3B5KG5qeG5pKTsKICAgICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTsKICAgICAgY29uc3QgZyA9IE1hdGguY29zKHRoaXMuYW5nbGUpIC0gbmkuZG90KG5qKTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLWcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7CiAgICAgIHJldHVybiBCOwogICAgfQoKICB9CiAgY29uc3QgdG1wVmVjMSQyID0gbmV3IFZlYzMoKTsKICBjb25zdCB0bXBWZWMyJDIgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBSb3RhdGlvbmFsIGNvbnN0cmFpbnQuIFdvcmtzIHRvIGtlZXAgdGhlIGxvY2FsIHZlY3RvcnMgb3J0aG9nb25hbCB0byBlYWNoIG90aGVyIGluIHdvcmxkIHNwYWNlLgogICAqLwogIGNsYXNzIFJvdGF0aW9uYWxFcXVhdGlvbiBleHRlbmRzIEVxdWF0aW9uIHsKICAgIC8qKgogICAgICogV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzLgogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIG1heEFuZ2xlCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7CiAgICAgIHRoaXMubWF4QW5nbGUgPSBNYXRoLlBJIC8gMjsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIGNvbnN0IGEgPSB0aGlzLmE7CiAgICAgIGNvbnN0IGIgPSB0aGlzLmI7CiAgICAgIGNvbnN0IG5pID0gdGhpcy5heGlzQTsKICAgICAgY29uc3QgbmogPSB0aGlzLmF4aXNCOwogICAgICBjb25zdCBuaXhuaiA9IHRtcFZlYzEkMTsKICAgICAgY29uc3Qgbmp4bmkgPSB0bXBWZWMyJDE7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzCgogICAgICBuaS5jcm9zcyhuaiwgbml4bmopOwogICAgICBuai5jcm9zcyhuaSwgbmp4bmkpOyAvLyBnID0gbmkgKiBuagogICAgICAvLyBnZG90ID0gKG5qIHggbmkpICogd2kgKyAobmkgeCBuaikgKiB3agogICAgICAvLyBHID0gWzAgbmp4bmkgMCBuaXhual0KICAgICAgLy8gVyA9IFt2aSB3aSB2aiB3al0KCiAgICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShuaXhuaik7CiAgICAgIGNvbnN0IGcgPSBNYXRoLmNvcyh0aGlzLm1heEFuZ2xlKSAtIG5pLmRvdChuaik7CiAgICAgIGNvbnN0IEdXID0gdGhpcy5jb21wdXRlR1coKTsKICAgICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTsKICAgICAgY29uc3QgQiA9IC1nICogYSAtIEdXICogYiAtIGggKiBHaU1mOwogICAgICByZXR1cm4gQjsKICAgIH0KCiAgfQogIGNvbnN0IHRtcFZlYzEkMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMiQxID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQSBDb25lIFR3aXN0IGNvbnN0cmFpbnQsIHVzZWZ1bCBmb3IgcmFnZG9sbHMuCiAgICovCiAgY2xhc3MgQ29uZVR3aXN0Q29uc3RyYWludCBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBUaGUgYXhpcyBkaXJlY3Rpb24gZm9yIHRoZSBjb25zdHJhaW50IG9mIHRoZSBib2R5IEEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBheGlzIGRpcmVjdGlvbiBmb3IgdGhlIGNvbnN0cmFpbnQgb2YgdGhlIGJvZHkgQi4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGFwZXJ0dXJlIGFuZ2xlIG9mIHRoZSBjb25lLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgdHdpc3QgYW5nbGUgb2YgdGhlIGpvaW50LgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihib2R5QSwgYm9keUIsIG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgY29uc3QgbWF4Rm9yY2UgPSB0eXBlb2Ygb3B0aW9ucy5tYXhGb3JjZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2OyAvLyBTZXQgcGl2b3QgcG9pbnQgaW4gYmV0d2VlbgoKICAgICAgY29uc3QgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcGl2b3RCID0gb3B0aW9ucy5waXZvdEIgPyBvcHRpb25zLnBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOwogICAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gISFvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7CiAgICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy5hbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDsKICAgICAgY29uc3QgYyA9IHRoaXMuY29uZUVxdWF0aW9uID0gbmV3IENvbmVFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICBjb25zdCB0ID0gdGhpcy50d2lzdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICB0aGlzLnR3aXN0QW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy50d2lzdEFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMudHdpc3RBbmdsZSA6IDA7IC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZAoKICAgICAgYy5tYXhGb3JjZSA9IDA7CiAgICAgIGMubWluRm9yY2UgPSAtbWF4Rm9yY2U7IC8vIE1ha2UgdGhlIHR3aXN0IGVxdWF0aW9uIGFkZCB0b3JxdWUgdG93YXJkIHRoZSBpbml0aWFsIHBvc2l0aW9uCgogICAgICB0Lm1heEZvcmNlID0gMDsKICAgICAgdC5taW5Gb3JjZSA9IC1tYXhGb3JjZTsKICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChjLCB0KTsKICAgIH0KCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBjb25lID0gdGhpcy5jb25lRXF1YXRpb247CiAgICAgIGNvbnN0IHR3aXN0ID0gdGhpcy50d2lzdEVxdWF0aW9uOwogICAgICBzdXBlci51cGRhdGUoKTsgLy8gVXBkYXRlIHRoZSBheGVzIHRvIHRoZSBjb25lIGNvbnN0cmFpbnQKCiAgICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNBLCBjb25lLmF4aXNBKTsKICAgICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuYXhpc0IsIGNvbmUuYXhpc0IpOyAvLyBVcGRhdGUgdGhlIHdvcmxkIGF4ZXMgaW4gdGhlIHR3aXN0IGNvbnN0cmFpbnQKCiAgICAgIHRoaXMuYXhpc0EudGFuZ2VudHModHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTsKICAgICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKHR3aXN0LmF4aXNBLCB0d2lzdC5heGlzQSk7CiAgICAgIHRoaXMuYXhpc0IudGFuZ2VudHModHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTsKICAgICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHR3aXN0LmF4aXNCLCB0d2lzdC5heGlzQik7CiAgICAgIGNvbmUuYW5nbGUgPSB0aGlzLmFuZ2xlOwogICAgICB0d2lzdC5tYXhBbmdsZSA9IHRoaXMudHdpc3RBbmdsZTsKICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQ29uc3RyYWlucyB0d28gYm9kaWVzIHRvIGJlIGF0IGEgY29uc3RhbnQgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVycyBjZW50ZXIgb2YgbWFzcy4KICAgKi8KICBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnQgZXh0ZW5kcyBDb25zdHJhaW50IHsKICAgIC8qKgogICAgICogVGhlIGRpc3RhbmNlIHRvIGtlZXAuIElmIHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiBib2R5QSBhbmQgYm9keUIKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGRpc3RhbmNlIFRoZSBkaXN0YW5jZSB0byBrZWVwLiBJZiB1bmRlZmluZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gYm9keUEgYW5kIGJvZHlCLgogICAgICogQHBhcmFtIG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgZGlzdGFuY2UsIG1heEZvcmNlKSB7CiAgICAgIGlmIChtYXhGb3JjZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7CiAgICAgIH0KCiAgICAgIHN1cGVyKGJvZHlBLCBib2R5Qik7CgogICAgICBpZiAodHlwZW9mIGRpc3RhbmNlID09PSAndW5kZWZpbmVkJykgewogICAgICAgIGRpc3RhbmNlID0gYm9keUEucG9zaXRpb24uZGlzdGFuY2VUbyhib2R5Qi5wb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTsKICAgICAgY29uc3QgZXEgPSB0aGlzLmRpc3RhbmNlRXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7CiAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpOyAvLyBNYWtlIGl0IGJpZGlyZWN0aW9uYWwKCiAgICAgIGVxLm1pbkZvcmNlID0gLW1heEZvcmNlOwogICAgICBlcS5tYXhGb3JjZSA9IG1heEZvcmNlOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbjsKICAgICAgY29uc3QgaGFsZkRpc3QgPSB0aGlzLmRpc3RhbmNlICogMC41OwogICAgICBjb25zdCBub3JtYWwgPSBlcS5uaTsKICAgICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbiwgbm9ybWFsKTsKICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpOwogICAgICBub3JtYWwuc2NhbGUoaGFsZkRpc3QsIGVxLnJpKTsKICAgICAgbm9ybWFsLnNjYWxlKC1oYWxmRGlzdCwgZXEucmopOwogICAgfQoKICB9CgogIC8qKgogICAqIExvY2sgY29uc3RyYWludC4gV2lsbCByZW1vdmUgYWxsIGRlZ3JlZXMgb2YgZnJlZWRvbSBiZXR3ZWVuIHRoZSBib2RpZXMuCiAgICovCiAgY2xhc3MgTG9ja0NvbnN0cmFpbnQgZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50IHsKICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7IC8vIFNldCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuCgogICAgICBjb25zdCBwaXZvdEEgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBwaXZvdEIgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBoYWxmV2F5ID0gbmV3IFZlYzMoKTsKICAgICAgYm9keUEucG9zaXRpb24udmFkZChib2R5Qi5wb3NpdGlvbiwgaGFsZldheSk7CiAgICAgIGhhbGZXYXkuc2NhbGUoMC41LCBoYWxmV2F5KTsKICAgICAgYm9keUIucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RCKTsKICAgICAgYm9keUEucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RBKTsgLy8gVGhlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQgd2lsbCBrZWVwIGEgcG9pbnQgc2hhcmVkIGJldHdlZW4gdGhlIGJvZGllcwoKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOyAvLyBTdG9yZSBpbml0aWFsIHJvdGF0aW9uIG9mIHRoZSBib2RpZXMgYXMgdW5pdCB2ZWN0b3JzIGluIHRoZSBsb2NhbCBib2R5IHNwYWNlcwoKICAgICAgdGhpcy54QSA9IGJvZHlBLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWCk7CiAgICAgIHRoaXMueEIgPSBib2R5Qi52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1gpOwogICAgICB0aGlzLnlBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTsKICAgICAgdGhpcy55QiA9IGJvZHlCLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWSk7CiAgICAgIHRoaXMuekEgPSBib2R5QS52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1opOwogICAgICB0aGlzLnpCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTsgLy8gLi4uYW5kIHRoZSBmb2xsb3dpbmcgcm90YXRpb25hbCBlcXVhdGlvbnMgd2lsbCBrZWVwIGFsbCByb3RhdGlvbmFsIERPRidzIGluIHBsYWNlCgogICAgICBjb25zdCByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTsKICAgICAgY29uc3QgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7CiAgICAgIGNvbnN0IHIzID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24zID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHIxLCByMiwgcjMpOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICB0aGlzLm1vdG9yRXF1YXRpb247CiAgICAgIGNvbnN0IHIxID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xOwogICAgICBjb25zdCByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMjsKICAgICAgY29uc3QgcjMgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjM7CiAgICAgIHN1cGVyLnVwZGF0ZSgpOyAvLyBUaGVzZSB2ZWN0b3IgcGFpcnMgbXVzdCBiZSBvcnRob2dvbmFsCgogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QSwgcjEuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QiwgcjEuYXhpc0IpOwogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QSwgcjIuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QiwgcjIuYXhpc0IpOwogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QSwgcjMuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QiwgcjMuYXhpc0IpOwogICAgfQoKICB9CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwoKICAvKioKICAgKiBSb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnQuIFRyaWVzIHRvIGtlZXAgdGhlIHJlbGF0aXZlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZGllcyB0byBhIGdpdmVuIHZhbHVlLgogICAqLwogIGNsYXNzIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uIGV4dGVuZHMgRXF1YXRpb24gewogICAgLyoqCiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpcy4KICAgICAqLwoKICAgIC8qKgogICAgICogTW90b3IgdmVsb2NpdHkuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1heEZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtYXhGb3JjZSA9IDFlNjsKICAgICAgfQoKICAgICAgc3VwZXIoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKTsKICAgICAgdGhpcy5heGlzQSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuYXhpc0IgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnRhcmdldFZlbG9jaXR5ID0gMDsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIHRoaXMuYTsKICAgICAgY29uc3QgYiA9IHRoaXMuYjsKICAgICAgdGhpcy5iaTsKICAgICAgdGhpcy5iajsKICAgICAgY29uc3QgYXhpc0EgPSB0aGlzLmF4aXNBOwogICAgICBjb25zdCBheGlzQiA9IHRoaXMuYXhpc0I7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gZyA9IDAKICAgICAgLy8gZ2RvdCA9IGF4aXNBICogd2kgLSBheGlzQiAqIHdqCiAgICAgIC8vIGdkb3QgPSBHICogVyA9IEcgKiBbdmkgd2kgdmogd2pdCiAgICAgIC8vID0+CiAgICAgIC8vIEcgPSBbMCBheGlzQSAwIC1heGlzQl0KCiAgICAgIEdBLnJvdGF0aW9uYWwuY29weShheGlzQSk7CiAgICAgIGF4aXNCLm5lZ2F0ZShHQi5yb3RhdGlvbmFsKTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpIC0gdGhpcy50YXJnZXRWZWxvY2l0eTsKICAgICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTsKICAgICAgY29uc3QgQiA9IC1HVyAqIGIgLSBoICogR2lNZjsKICAgICAgcmV0dXJuIEI7CiAgICB9CgogIH0KCiAgLyoqCiAgICogSGluZ2UgY29uc3RyYWludC4gVGhpbmsgb2YgaXQgYXMgYSBkb29yIGhpbmdlLiBJdCB0cmllcyB0byBrZWVwIHRoZSBkb29yIGluIHRoZSBjb3JyZWN0IHBsYWNlIGFuZCB3aXRoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLgogICAqLwogIGNsYXNzIEhpbmdlQ29uc3RyYWludCBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBSb3RhdGlvbiBheGlzLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi4KICAgICAqLwogICAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IG1heEZvcmNlID0gdHlwZW9mIG9wdGlvbnMubWF4Rm9yY2UgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjsKICAgICAgY29uc3QgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcGl2b3RCID0gb3B0aW9ucy5waXZvdEIgPyBvcHRpb25zLnBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOwogICAgICBjb25zdCBheGlzQSA9IHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIGF4aXNBLm5vcm1hbGl6ZSgpOwogICAgICBjb25zdCBheGlzQiA9IHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIGF4aXNCLm5vcm1hbGl6ZSgpOwogICAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSAhIW9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDsKICAgICAgY29uc3Qgcm90YXRpb25hbDEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7CiAgICAgIGNvbnN0IHJvdGF0aW9uYWwyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICBjb25zdCBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbihib2R5QSwgYm9keUIsIG1heEZvcmNlKTsKICAgICAgbW90b3IuZW5hYmxlZCA9IGZhbHNlOyAvLyBOb3QgZW5hYmxlZCBieSBkZWZhdWx0CiAgICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlcgoKICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChyb3RhdGlvbmFsMSwgcm90YXRpb25hbDIsIG1vdG9yKTsKICAgIH0KICAgIC8qKgogICAgICogZW5hYmxlTW90b3IKICAgICAqLwoKCiAgICBlbmFibGVNb3RvcigpIHsKICAgICAgdGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQgPSB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBkaXNhYmxlTW90b3IKICAgICAqLwoKCiAgICBkaXNhYmxlTW90b3IoKSB7CiAgICAgIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIHNldE1vdG9yU3BlZWQKICAgICAqLwoKCiAgICBzZXRNb3RvclNwZWVkKHNwZWVkKSB7CiAgICAgIHRoaXMubW90b3JFcXVhdGlvbi50YXJnZXRWZWxvY2l0eSA9IHNwZWVkOwogICAgfQogICAgLyoqCiAgICAgKiBzZXRNb3Rvck1heEZvcmNlCiAgICAgKi8KCgogICAgc2V0TW90b3JNYXhGb3JjZShtYXhGb3JjZSkgewogICAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTsKICAgICAgdGhpcy5tb3RvckVxdWF0aW9uLm1pbkZvcmNlID0gLW1heEZvcmNlOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbjsKICAgICAgY29uc3QgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjE7CiAgICAgIGNvbnN0IHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yOwogICAgICBjb25zdCB3b3JsZEF4aXNBID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxOwogICAgICBjb25zdCB3b3JsZEF4aXNCID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyOwogICAgICBjb25zdCBheGlzQSA9IHRoaXMuYXhpc0E7CiAgICAgIGNvbnN0IGF4aXNCID0gdGhpcy5heGlzQjsKICAgICAgc3VwZXIudXBkYXRlKCk7IC8vIEdldCB3b3JsZCBheGVzCgogICAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KGF4aXNBLCB3b3JsZEF4aXNBKTsKICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdChheGlzQiwgd29ybGRBeGlzQik7CiAgICAgIHdvcmxkQXhpc0EudGFuZ2VudHMocjEuYXhpc0EsIHIyLmF4aXNBKTsKICAgICAgcjEuYXhpc0IuY29weSh3b3JsZEF4aXNCKTsKICAgICAgcjIuYXhpc0IuY29weSh3b3JsZEF4aXNCKTsKCiAgICAgIGlmICh0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCkgewogICAgICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQSwgbW90b3IuYXhpc0EpOwogICAgICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQiwgbW90b3IuYXhpc0IpOwogICAgICB9CiAgICB9CgogIH0KICBjb25zdCBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpOwogIGNvbnN0IEhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIENvbnN0cmFpbnMgdGhlIHNsaXBwaW5nIGluIGEgY29udGFjdCBhbG9uZyBhIHRhbmdlbnQKICAgKi8KICBjbGFzcyBGcmljdGlvbkVxdWF0aW9uIGV4dGVuZHMgRXF1YXRpb24gewogICAgLy8gVGFuZ2VudAoKICAgIC8qKgogICAgICogQHBhcmFtIHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKSB7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLXNsaXBGb3JjZSwgc2xpcEZvcmNlKTsKICAgICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucmogPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnQgPSBuZXcgVmVjMygpOwogICAgfQoKICAgIGNvbXB1dGVCKGgpIHsKICAgICAgdGhpcy5hOwogICAgICBjb25zdCBiID0gdGhpcy5iOwogICAgICB0aGlzLmJpOwogICAgICB0aGlzLmJqOwogICAgICBjb25zdCByaSA9IHRoaXMucmk7CiAgICAgIGNvbnN0IHJqID0gdGhpcy5yajsKICAgICAgY29uc3Qgcml4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDE7CiAgICAgIGNvbnN0IHJqeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyOwogICAgICBjb25zdCB0ID0gdGhpcy50OyAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHMKCiAgICAgIHJpLmNyb3NzKHQsIHJpeHQpOwogICAgICByai5jcm9zcyh0LCByanh0KTsgLy8gRyA9IFstdCAtcml4dCB0IHJqeHRdCiAgICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyEKCiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgdC5uZWdhdGUoR0Euc3BhdGlhbCk7CiAgICAgIHJpeHQubmVnYXRlKEdBLnJvdGF0aW9uYWwpOwogICAgICBHQi5zcGF0aWFsLmNvcHkodCk7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShyanh0KTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLUdXICogYiAtIGggKiBHaU1mOwogICAgICByZXR1cm4gQjsKICAgIH0KCiAgfQogIGNvbnN0IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldC4KICAgKiBAdG9kbyBSZWZhY3RvciBtYXRlcmlhbHMgdG8gbWF0ZXJpYWxBIGFuZCBtYXRlcmlhbEIKICAgKi8KICBjbGFzcyBDb250YWN0TWF0ZXJpYWwgewogICAgLyoqCiAgICAgKiBJZGVudGlmaWVyIG9mIHRoaXMgbWF0ZXJpYWwuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFBhcnRpY2lwYXRpbmcgbWF0ZXJpYWxzLgogICAgICovCgogICAgLyoqCiAgICAgKiBGcmljdGlvbiBjb2VmZmljaWVudC4KICAgICAqIEBkZWZhdWx0IDAuMwogICAgICovCgogICAgLyoqCiAgICAgKiBSZXN0aXR1dGlvbiBjb2VmZmljaWVudC4KICAgICAqIEBkZWZhdWx0IDAuMwogICAgICovCgogICAgLyoqCiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHByb2R1Y2VkIGNvbnRhY3QgZXF1YXRpb25zLgogICAgICogQGRlZmF1bHQgMWU3CiAgICAgKi8KCiAgICAvKioKICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnMuCiAgICAgKiBAZGVmYXVsdCAzCiAgICAgKi8KCiAgICAvKioKICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zLgogICAgICogQGRlZmF1bHQgMWU3CiAgICAgKi8KCiAgICAvKioKICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zCiAgICAgKiBAZGVmYXVsdCAzCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG0xLCBtMiwgb3B0aW9ucykgewogICAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywgewogICAgICAgIGZyaWN0aW9uOiAwLjMsCiAgICAgICAgcmVzdGl0dXRpb246IDAuMywKICAgICAgICBjb250YWN0RXF1YXRpb25TdGlmZm5lc3M6IDFlNywKICAgICAgICBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uOiAzLAogICAgICAgIGZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M6IDFlNywKICAgICAgICBmcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjogMwogICAgICB9KTsKICAgICAgdGhpcy5pZCA9IENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5tYXRlcmlhbHMgPSBbbTEsIG0yXTsKICAgICAgdGhpcy5mcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb247CiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uOwogICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOwogICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24gPSBvcHRpb25zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb247CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzczsKICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb247CiAgICB9CgogIH0KICBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDsKCiAgLyoqCiAgICogRGVmaW5lcyBhIHBoeXNpY3MgbWF0ZXJpYWwuCiAgICovCiAgY2xhc3MgTWF0ZXJpYWwgewogICAgLyoqCiAgICAgKiBNYXRlcmlhbCBuYW1lLgogICAgICogSWYgb3B0aW9ucyBpcyBhIHN0cmluZywgbmFtZSB3aWxsIGJlIHNldCB0byB0aGF0IHN0cmluZy4KICAgICAqIEB0b2RvIERlcHJlY2F0ZSB0aGlzCiAgICAgKi8KCiAgICAvKiogTWF0ZXJpYWwgaWQuICovCgogICAgLyoqCiAgICAgKiBGcmljdGlvbiBmb3IgdGhpcyBtYXRlcmlhbC4KICAgICAqIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGZyaWN0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSBgZGVmYXVsdENvbnRhY3RNYXRlcmlhbGAgaW4gdGhlIFdvcmxkIHdpbGwgYmUgdXNlZC4KICAgICAqLwoKICAgIC8qKgogICAgICogUmVzdGl0dXRpb24gZm9yIHRoaXMgbWF0ZXJpYWwuCiAgICAgKiBJZiBub24tbmVnYXRpdmUsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSByZXN0aXR1dGlvbiBnaXZlbiBieSBDb250YWN0TWF0ZXJpYWxzLiBJZiB0aGVyZSdzIG5vIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgdGhlIHZhbHVlIGZyb20gYGRlZmF1bHRDb250YWN0TWF0ZXJpYWxgIGluIHRoZSBXb3JsZCB3aWxsIGJlIHVzZWQuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgbGV0IG5hbWUgPSAnJzsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZml4CgogICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgLy9jb25zb2xlLndhcm4oYFBhc3NpbmcgYSBzdHJpbmcgdG8gTWF0ZXJpYWxPcHRpb25zIGlzIGRlcHJlY2F0ZWQsIGFuZCBoYXMgbm8gZWZmZWN0YCkKICAgICAgICBuYW1lID0gb3B0aW9uczsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgIHRoaXMuaWQgPSBNYXRlcmlhbC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5mcmljdGlvbiA9IHR5cGVvZiBvcHRpb25zLmZyaWN0aW9uICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZnJpY3Rpb24gOiAtMTsKICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IHR5cGVvZiBvcHRpb25zLnJlc3RpdHV0aW9uICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucmVzdGl0dXRpb24gOiAtMTsKICAgIH0KCiAgfQogIE1hdGVyaWFsLmlkQ291bnRlciA9IDA7CgogIC8qKgogICAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3Qgc3ByaW5nID0gbmV3IFNwcmluZyhib3hCb2R5LCBzcGhlcmVCb2R5LCB7CiAgICogICAgICAgcmVzdExlbmd0aDogMCwKICAgKiAgICAgICBzdGlmZm5lc3M6IDUwLAogICAqICAgICAgIGRhbXBpbmc6IDEsCiAgICogICAgIH0pCiAgICoKICAgKiAgICAgLy8gQ29tcHV0ZSB0aGUgZm9yY2UgYWZ0ZXIgZWFjaCBzdGVwCiAgICogICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgKGV2ZW50KSA9PiB7CiAgICogICAgICAgc3ByaW5nLmFwcGx5Rm9yY2UoKQogICAqICAgICB9KQogICAqLwogIGNsYXNzIFNwcmluZyB7CiAgICAvKioKICAgICAqIFJlc3QgbGVuZ3RoIG9mIHRoZSBzcHJpbmcuIEEgbnVtYmVyID4gMC4KICAgICAqIEBkZWZhdWx0IDEKICAgICAqLwoKICAgIC8qKgogICAgICogU3RpZmZuZXNzIG9mIHRoZSBzcHJpbmcuIEEgbnVtYmVyID49IDAuCiAgICAgKiBAZGVmYXVsdCAxMDAKICAgICAqLwoKICAgIC8qKgogICAgICogRGFtcGluZyBvZiB0aGUgc3ByaW5nLiBBIG51bWJlciA+PSAwLgogICAgICogQGRlZmF1bHQgMQogICAgICovCgogICAgLyoqCiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS4KICAgICAqLwoKICAgIC8qKgogICAgICogU2Vjb25kIGNvbm5lY3RlZCBib2R5LgogICAgICovCgogICAgLyoqCiAgICAgKiBBbmNob3IgZm9yIGJvZHlBIGluIGxvY2FsIGJvZHlBIGNvb3JkaW5hdGVzLgogICAgICogV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy4KICAgICAqIEBkZWZhdWx0IG5ldyBWZWMzKCkKICAgICAqLwoKICAgIC8qKgogICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy4KICAgICAqIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEIsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuCiAgICAgKiBAZGVmYXVsdCBuZXcgVmVjMygpCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Ygb3B0aW9ucy5yZXN0TGVuZ3RoID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7CiAgICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3MgfHwgMTAwOwogICAgICB0aGlzLmRhbXBpbmcgPSBvcHRpb25zLmRhbXBpbmcgfHwgMTsKICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBOwogICAgICB0aGlzLmJvZHlCID0gYm9keUI7CiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMubG9jYWxBbmNob3JBKSB7CiAgICAgICAgdGhpcy5sb2NhbEFuY2hvckEuY29weShvcHRpb25zLmxvY2FsQW5jaG9yQSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLmxvY2FsQW5jaG9yQikgewogICAgICAgIHRoaXMubG9jYWxBbmNob3JCLmNvcHkob3B0aW9ucy5sb2NhbEFuY2hvckIpOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy53b3JsZEFuY2hvckEpIHsKICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLndvcmxkQW5jaG9yQikgewogICAgICAgIHRoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLgogICAgICovCgoKICAgIHNldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpIHsKICAgICAgdGhpcy5ib2R5QS5wb2ludFRvTG9jYWxGcmFtZSh3b3JsZEFuY2hvckEsIHRoaXMubG9jYWxBbmNob3JBKTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy4KICAgICAqLwoKCiAgICBzZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKSB7CiAgICAgIHRoaXMuYm9keUIucG9pbnRUb0xvY2FsRnJhbWUod29ybGRBbmNob3JCLCB0aGlzLmxvY2FsQW5jaG9yQik7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBnZXRXb3JsZEFuY2hvckEocmVzdWx0KSB7CiAgICAgIHRoaXMuYm9keUEucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckEsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBnZXRXb3JsZEFuY2hvckIocmVzdWx0KSB7CiAgICAgIHRoaXMuYm9keUIucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuCiAgICAgKi8KCgogICAgYXBwbHlGb3JjZSgpIHsKICAgICAgY29uc3QgayA9IHRoaXMuc3RpZmZuZXNzOwogICAgICBjb25zdCBkID0gdGhpcy5kYW1waW5nOwogICAgICBjb25zdCBsID0gdGhpcy5yZXN0TGVuZ3RoOwogICAgICBjb25zdCBib2R5QSA9IHRoaXMuYm9keUE7CiAgICAgIGNvbnN0IGJvZHlCID0gdGhpcy5ib2R5QjsKICAgICAgY29uc3QgciA9IGFwcGx5Rm9yY2VfcjsKICAgICAgY29uc3Qgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQ7CiAgICAgIGNvbnN0IHUgPSBhcHBseUZvcmNlX3U7CiAgICAgIGNvbnN0IGYgPSBhcHBseUZvcmNlX2Y7CiAgICAgIGNvbnN0IHRtcCA9IGFwcGx5Rm9yY2VfdG1wOwogICAgICBjb25zdCB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQTsKICAgICAgY29uc3Qgd29ybGRBbmNob3JCID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckI7CiAgICAgIGNvbnN0IHJpID0gYXBwbHlGb3JjZV9yaTsKICAgICAgY29uc3QgcmogPSBhcHBseUZvcmNlX3JqOwogICAgICBjb25zdCByaV94X2YgPSBhcHBseUZvcmNlX3JpX3hfZjsKICAgICAgY29uc3QgcmpfeF9mID0gYXBwbHlGb3JjZV9yal94X2Y7IC8vIEdldCB3b3JsZCBhbmNob3JzCgogICAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpOwogICAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpOyAvLyBHZXQgb2Zmc2V0IHBvaW50cwoKICAgICAgd29ybGRBbmNob3JBLnZzdWIoYm9keUEucG9zaXRpb24sIHJpKTsKICAgICAgd29ybGRBbmNob3JCLnZzdWIoYm9keUIucG9zaXRpb24sIHJqKTsgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzCgogICAgICB3b3JsZEFuY2hvckIudnN1Yih3b3JsZEFuY2hvckEsIHIpOwogICAgICBjb25zdCBybGVuID0gci5sZW5ndGgoKTsKICAgICAgcl91bml0LmNvcHkocik7CiAgICAgIHJfdW5pdC5ub3JtYWxpemUoKTsgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdQoKICAgICAgYm9keUIudmVsb2NpdHkudnN1Yihib2R5QS52ZWxvY2l0eSwgdSk7IC8vIEFkZCByb3RhdGlvbmFsIHZlbG9jaXR5CgogICAgICBib2R5Qi5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MocmosIHRtcCk7CiAgICAgIHUudmFkZCh0bXAsIHUpOwogICAgICBib2R5QS5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MocmksIHRtcCk7CiAgICAgIHUudnN1Yih0bXAsIHUpOyAvLyBGID0gLSBrICogKCB4IC0gTCApIC0gRCAqICggdSApCgogICAgICByX3VuaXQuc2NhbGUoLWsgKiAocmxlbiAtIGwpIC0gZCAqIHUuZG90KHJfdW5pdCksIGYpOyAvLyBBZGQgZm9yY2VzIHRvIGJvZGllcwoKICAgICAgYm9keUEuZm9yY2UudnN1YihmLCBib2R5QS5mb3JjZSk7CiAgICAgIGJvZHlCLmZvcmNlLnZhZGQoZiwgYm9keUIuZm9yY2UpOyAvLyBBbmd1bGFyIGZvcmNlCgogICAgICByaS5jcm9zcyhmLCByaV94X2YpOwogICAgICByai5jcm9zcyhmLCByal94X2YpOwogICAgICBib2R5QS50b3JxdWUudnN1YihyaV94X2YsIGJvZHlBLnRvcnF1ZSk7CiAgICAgIGJvZHlCLnRvcnF1ZS52YWRkKHJqX3hfZiwgYm9keUIudG9ycXVlKTsKICAgIH0KCiAgfQogIGNvbnN0IGFwcGx5Rm9yY2VfciA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV9yX3VuaXQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfdSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV9mID0gbmV3IFZlYzMoKTsKICBjb25zdCBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV93b3JsZEFuY2hvckIgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmkgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmogPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmlfeF9mID0gbmV3IFZlYzMoKTsKICBjb25zdCBhcHBseUZvcmNlX3JqX3hfZiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV90bXAgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBXaGVlbEluZm8KICAgKi8KICBjbGFzcyBXaGVlbEluZm8gewogICAgLyoqCiAgICAgKiBNYXggdHJhdmVsIGRpc3RhbmNlIG9mIHRoZSBzdXNwZW5zaW9uLCBpbiBtZXRlcnMuCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNwZWVkIHRvIGFwcGx5IHRvIHRoZSB3aGVlbCByb3RhdGlvbiB3aGVuIHRoZSB3aGVlbCBpcyBzbGlkaW5nLgogICAgICogQGRlZmF1bHQgLTAuMQogICAgICovCgogICAgLyoqCiAgICAgKiBJZiB0aGUgY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCBzaG91bGQgYmUgdXNlZC4KICAgICAqIEBkZWZhdWx0IGZhbHNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNsaWRpbmcKICAgICAqLwoKICAgIC8qKgogICAgICogQ29ubmVjdGlvbiBwb2ludCwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBjaGFzc2lzIGJvZHkgZnJhbWUuCiAgICAgKi8KCiAgICAvKioKICAgICAqIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb25Mb2NhbAogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb25Xb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiBheGxlTG9jYWwKICAgICAqLwoKICAgIC8qKgogICAgICogYXhsZVdvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25SZXN0TGVuZ3RoCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25NYXhMZW5ndGgKICAgICAqIEBkZWZhdWx0IDIKICAgICAqLwoKICAgIC8qKgogICAgICogcmFkaXVzCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25TdGlmZm5lc3MKICAgICAqIEBkZWZhdWx0IDEwMAogICAgICovCgogICAgLyoqCiAgICAgKiBkYW1waW5nQ29tcHJlc3Npb24KICAgICAqIEBkZWZhdWx0IDEwCiAgICAgKi8KCiAgICAvKioKICAgICAqIGRhbXBpbmdSZWxheGF0aW9uCiAgICAgKiBAZGVmYXVsdCAxMAogICAgICovCgogICAgLyoqCiAgICAgKiBmcmljdGlvblNsaXAKICAgICAqIEBkZWZhdWx0IDEwLjUKICAgICAqLwoKICAgIC8qKiBmb3J3YXJkQWNjZWxlcmF0aW9uICovCgogICAgLyoqIHNpZGVBY2NlbGVyYXRpb24gKi8KCiAgICAvKioKICAgICAqIHN0ZWVyaW5nCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIFJvdGF0aW9uIHZhbHVlLCBpbiByYWRpYW5zLgogICAgICogQGRlZmF1bHQgMAogICAgICovCgogICAgLyoqCiAgICAgKiBkZWx0YVJvdGF0aW9uCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHJvbGxJbmZsdWVuY2UKICAgICAqIEBkZWZhdWx0IDAuMDEKICAgICAqLwoKICAgIC8qKgogICAgICogbWF4U3VzcGVuc2lvbkZvcmNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGVuZ2luZUZvcmNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGJyYWtlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGlzRnJvbnRXaGVlbAogICAgICogQGRlZmF1bHQgdHJ1ZQogICAgICovCgogICAgLyoqCiAgICAgKiBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24KICAgICAqIEBkZWZhdWx0IDEKICAgICAqLwoKICAgIC8qKgogICAgICogc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkKICAgICAqIEBkZWZhdWx0IDAKICAgICAqLwoKICAgIC8qKgogICAgICogc3VzcGVuc2lvbkZvcmNlCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNsaXBJbmZvCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNraWRJbmZvCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25MZW5ndGgKICAgICAqIEBkZWZhdWx0IDAKICAgICAqLwoKICAgIC8qKgogICAgICogc2lkZUltcHVsc2UKICAgICAqLwoKICAgIC8qKgogICAgICogZm9yd2FyZEltcHVsc2UKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHJlc3VsdCBmcm9tIHJheWNhc3RpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZWVsIHdvcmxkIHRyYW5zZm9ybS4KICAgICAqLwoKICAgIC8qKgogICAgICogaXNJbkNvbnRhY3QKICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywgewogICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbDogbmV3IFZlYzMoKSwKICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQ6IG5ldyBWZWMzKCksCiAgICAgICAgZGlyZWN0aW9uTG9jYWw6IG5ldyBWZWMzKCksCiAgICAgICAgZGlyZWN0aW9uV29ybGQ6IG5ldyBWZWMzKCksCiAgICAgICAgYXhsZUxvY2FsOiBuZXcgVmVjMygpLAogICAgICAgIGF4bGVXb3JsZDogbmV3IFZlYzMoKSwKICAgICAgICBzdXNwZW5zaW9uUmVzdExlbmd0aDogMSwKICAgICAgICBzdXNwZW5zaW9uTWF4TGVuZ3RoOiAyLAogICAgICAgIHJhZGl1czogMSwKICAgICAgICBzdXNwZW5zaW9uU3RpZmZuZXNzOiAxMDAsCiAgICAgICAgZGFtcGluZ0NvbXByZXNzaW9uOiAxMCwKICAgICAgICBkYW1waW5nUmVsYXhhdGlvbjogMTAsCiAgICAgICAgZnJpY3Rpb25TbGlwOiAxMC41LAogICAgICAgIGZvcndhcmRBY2NlbGVyYXRpb246IDEsCiAgICAgICAgc2lkZUFjY2VsZXJhdGlvbjogMSwKICAgICAgICBzdGVlcmluZzogMCwKICAgICAgICByb3RhdGlvbjogMCwKICAgICAgICBkZWx0YVJvdGF0aW9uOiAwLAogICAgICAgIHJvbGxJbmZsdWVuY2U6IDAuMDEsCiAgICAgICAgbWF4U3VzcGVuc2lvbkZvcmNlOiBOdW1iZXIuTUFYX1ZBTFVFLAogICAgICAgIGlzRnJvbnRXaGVlbDogdHJ1ZSwKICAgICAgICBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb246IDEsCiAgICAgICAgc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk6IDAsCiAgICAgICAgc3VzcGVuc2lvbkZvcmNlOiAwLAogICAgICAgIHNsaXBJbmZvOiAwLAogICAgICAgIHNraWRJbmZvOiAwLAogICAgICAgIHN1c3BlbnNpb25MZW5ndGg6IDAsCiAgICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSwKICAgICAgICB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiBmYWxzZSwKICAgICAgICBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiAtMC4xCiAgICAgIH0pOwogICAgICB0aGlzLm1heFN1c3BlbnNpb25UcmF2ZWwgPSBvcHRpb25zLm1heFN1c3BlbnNpb25UcmF2ZWw7CiAgICAgIHRoaXMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCA9IG9wdGlvbnMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDsKICAgICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOwogICAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTsKICAgICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbC5jbG9uZSgpOwogICAgICB0aGlzLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCA9IG9wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uTG9jYWwgPSBvcHRpb25zLmRpcmVjdGlvbkxvY2FsLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uV29ybGQgPSBvcHRpb25zLmRpcmVjdGlvbldvcmxkLmNsb25lKCk7CiAgICAgIHRoaXMuYXhsZUxvY2FsID0gb3B0aW9ucy5heGxlTG9jYWwuY2xvbmUoKTsKICAgICAgdGhpcy5heGxlV29ybGQgPSBvcHRpb25zLmF4bGVXb3JsZC5jbG9uZSgpOwogICAgICB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uUmVzdExlbmd0aDsKICAgICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoOwogICAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzOwogICAgICB0aGlzLnN1c3BlbnNpb25TdGlmZm5lc3MgPSBvcHRpb25zLnN1c3BlbnNpb25TdGlmZm5lc3M7CiAgICAgIHRoaXMuZGFtcGluZ0NvbXByZXNzaW9uID0gb3B0aW9ucy5kYW1waW5nQ29tcHJlc3Npb247CiAgICAgIHRoaXMuZGFtcGluZ1JlbGF4YXRpb24gPSBvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uOwogICAgICB0aGlzLmZyaWN0aW9uU2xpcCA9IG9wdGlvbnMuZnJpY3Rpb25TbGlwOwogICAgICB0aGlzLmZvcndhcmRBY2NlbGVyYXRpb24gPSBvcHRpb25zLmZvcndhcmRBY2NlbGVyYXRpb247CiAgICAgIHRoaXMuc2lkZUFjY2VsZXJhdGlvbiA9IG9wdGlvbnMuc2lkZUFjY2VsZXJhdGlvbjsKICAgICAgdGhpcy5zdGVlcmluZyA9IDA7CiAgICAgIHRoaXMucm90YXRpb24gPSAwOwogICAgICB0aGlzLmRlbHRhUm90YXRpb24gPSAwOwogICAgICB0aGlzLnJvbGxJbmZsdWVuY2UgPSBvcHRpb25zLnJvbGxJbmZsdWVuY2U7CiAgICAgIHRoaXMubWF4U3VzcGVuc2lvbkZvcmNlID0gb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2U7CiAgICAgIHRoaXMuZW5naW5lRm9yY2UgPSAwOwogICAgICB0aGlzLmJyYWtlID0gMDsKICAgICAgdGhpcy5pc0Zyb250V2hlZWwgPSBvcHRpb25zLmlzRnJvbnRXaGVlbDsKICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxOwogICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDsKICAgICAgdGhpcy5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICB0aGlzLnNsaXBJbmZvID0gMDsKICAgICAgdGhpcy5za2lkSW5mbyA9IDA7CiAgICAgIHRoaXMuc3VzcGVuc2lvbkxlbmd0aCA9IDA7CiAgICAgIHRoaXMuc2lkZUltcHVsc2UgPSAwOwogICAgICB0aGlzLmZvcndhcmRJbXB1bHNlID0gMDsKICAgICAgdGhpcy5yYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTsKICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTsKICAgICAgdGhpcy5pc0luQ29udGFjdCA9IGZhbHNlOwogICAgfQoKICAgIHVwZGF0ZVdoZWVsKGNoYXNzaXMpIHsKICAgICAgY29uc3QgcmF5Y2FzdFJlc3VsdCA9IHRoaXMucmF5Y2FzdFJlc3VsdDsKCiAgICAgIGlmICh0aGlzLmlzSW5Db250YWN0KSB7CiAgICAgICAgY29uc3QgcHJvamVjdCA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQpOwogICAgICAgIHJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXMucG9zaXRpb24sIHJlbHBvcyk7CiAgICAgICAgY2hhc3Npcy5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChyZWxwb3MsIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTsKICAgICAgICBjb25zdCBwcm9qVmVsID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpOwoKICAgICAgICBpZiAocHJvamVjdCA+PSAtMC4xKSB7CiAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wOwogICAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjAgLyAwLjE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGludiA9IC0xIC8gcHJvamVjdDsKICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSBwcm9qVmVsICogaW52OwogICAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIE5vdCBpbiBjb250YWN0IDogcG9zaXRpb24gd2hlZWwgaW4gYSBuaWNlIChyZXN0IGxlbmd0aCkgcG9zaXRpb24KICAgICAgICByYXljYXN0UmVzdWx0LnN1c3BlbnNpb25MZW5ndGggPSB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoOwogICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7CiAgICAgICAgcmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7CiAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjA7CiAgICAgIH0KICAgIH0KCiAgfQogIGNvbnN0IGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ID0gbmV3IFZlYzMoKTsKICBjb25zdCByZWxwb3MgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBWZWhpY2xlIGhlbHBlciBjbGFzcyB0aGF0IGNhc3RzIHJheXMgZnJvbSB0aGUgd2hlZWwgcG9zaXRpb25zIHRvd2FyZHMgdGhlIGdyb3VuZCBhbmQgYXBwbGllcyBmb3JjZXMuCiAgICovCiAgY2xhc3MgUmF5Y2FzdFZlaGljbGUgewogICAgLyoqIFRoZSBjYXIgY2hhc3NpcyBib2R5LiAqLwoKICAgIC8qKiBUaGUgd2hlZWxzLiAqLwoKICAgIC8qKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy4gKi8KCiAgICAvKiogSW5kZXggb2YgdGhlIHJpZ2h0IGF4aXMuIHg9MCwgeT0xLCB6PTIgKi8KCiAgICAvKiogSW5kZXggb2YgdGhlIGZvcndhcmQgYXhpcy4geD0wLCB5PTEsIHo9MiAqLwoKICAgIC8qKiBJbmRleCBvZiB0aGUgdXAgYXhpcy4geD0wLCB5PTEsIHo9MiAqLwoKICAgIC8qKiBUaGUgY29uc3RyYWludHMuICovCgogICAgLyoqIE9wdGlvbmFsIHByZS1zdGVwIGNhbGxiYWNrLiAqLwoKICAgIC8qKiBOdW1iZXIgb2Ygd2hlZWxzIG9uIHRoZSBncm91bmQuICovCiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7CiAgICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBvcHRpb25zLmNoYXNzaXNCb2R5OwogICAgICB0aGlzLndoZWVsSW5mb3MgPSBbXTsKICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7CiAgICAgIHRoaXMud29ybGQgPSBudWxsOwogICAgICB0aGlzLmluZGV4UmlnaHRBeGlzID0gdHlwZW9mIG9wdGlvbnMuaW5kZXhSaWdodEF4aXMgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleFJpZ2h0QXhpcyA6IDI7CiAgICAgIHRoaXMuaW5kZXhGb3J3YXJkQXhpcyA9IHR5cGVvZiBvcHRpb25zLmluZGV4Rm9yd2FyZEF4aXMgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleEZvcndhcmRBeGlzIDogMDsKICAgICAgdGhpcy5pbmRleFVwQXhpcyA9IHR5cGVvZiBvcHRpb25zLmluZGV4VXBBeGlzICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhVcEF4aXMgOiAxOwogICAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107CgogICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9ICgpID0+IHt9OwoKICAgICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyID0gMDsKICAgICAgdGhpcy5udW1XaGVlbHNPbkdyb3VuZCA9IDA7CiAgICB9CiAgICAvKioKICAgICAqIEFkZCBhIHdoZWVsLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMsIHNlZSBgV2hlZWxJbmZvYC4KICAgICAqLwoKCiAgICBhZGRXaGVlbChvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpOwogICAgICBjb25zdCBpbmRleCA9IHRoaXMud2hlZWxJbmZvcy5sZW5ndGg7CiAgICAgIHRoaXMud2hlZWxJbmZvcy5wdXNoKGluZm8pOwogICAgICByZXR1cm4gaW5kZXg7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC4KICAgICAqLwoKCiAgICBzZXRTdGVlcmluZ1ZhbHVlKHZhbHVlLCB3aGVlbEluZGV4KSB7CiAgICAgIGNvbnN0IHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdOwogICAgICB3aGVlbC5zdGVlcmluZyA9IHZhbHVlOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwCiAgICAgKi8KCgogICAgYXBwbHlFbmdpbmVGb3JjZSh2YWx1ZSwgd2hlZWxJbmRleCkgewogICAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uZW5naW5lRm9yY2UgPSB2YWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBicmFraW5nIGZvcmNlIG9mIGEgd2hlZWwKICAgICAqLwoKCiAgICBzZXRCcmFrZShicmFrZSwgd2hlZWxJbmRleCkgewogICAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uYnJha2UgPSBicmFrZTsKICAgIH0KICAgIC8qKgogICAgICogQWRkIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgdG8gdGhlIHdvcmxkLgogICAgICovCgoKICAgIGFkZFRvV29ybGQod29ybGQpIHsKICAgICAgd29ybGQuYWRkQm9keSh0aGlzLmNoYXNzaXNCb2R5KTsKICAgICAgY29uc3QgdGhhdCA9IHRoaXM7CgogICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9ICgpID0+IHsKICAgICAgICB0aGF0LnVwZGF0ZVZlaGljbGUod29ybGQuZHQpOwogICAgICB9OwoKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTsKICAgICAgdGhpcy53b3JsZCA9IHdvcmxkOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgb25lIG9mIHRoZSB3aGVlbCBheGxlcywgd29ybGQtb3JpZW50ZWQuCiAgICAgKi8KCgogICAgZ2V0VmVoaWNsZUF4aXNXb3JsZChheGlzSW5kZXgsIHJlc3VsdCkgewogICAgICByZXN1bHQuc2V0KGF4aXNJbmRleCA9PT0gMCA/IDEgOiAwLCBheGlzSW5kZXggPT09IDEgPyAxIDogMCwgYXhpc0luZGV4ID09PSAyID8gMSA6IDApOwogICAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZXN1bHQsIHJlc3VsdCk7CiAgICB9CgogICAgdXBkYXRlVmVoaWNsZSh0aW1lU3RlcCkgewogICAgICBjb25zdCB3aGVlbEluZm9zID0gdGhpcy53aGVlbEluZm9zOwogICAgICBjb25zdCBudW1XaGVlbHMgPSB3aGVlbEluZm9zLmxlbmd0aDsKICAgICAgY29uc3QgY2hhc3Npc0JvZHkgPSB0aGlzLmNoYXNzaXNCb2R5OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7CiAgICAgIH0KCiAgICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciA9IDMuNiAqIGNoYXNzaXNCb2R5LnZlbG9jaXR5Lmxlbmd0aCgpOwogICAgICBjb25zdCBmb3J3YXJkV29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmb3J3YXJkV29ybGQpOwoKICAgICAgaWYgKGZvcndhcmRXb3JsZC5kb3QoY2hhc3Npc0JvZHkudmVsb2NpdHkpIDwgMCkgewogICAgICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciAqPSAtMTsKICAgICAgfSAvLyBzaW11bGF0ZSBzdXNwZW5zaW9uCgoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIHRoaXMuY2FzdFJheSh3aGVlbEluZm9zW2ldKTsKICAgICAgfQoKICAgICAgdGhpcy51cGRhdGVTdXNwZW5zaW9uKHRpbWVTdGVwKTsKICAgICAgY29uc3QgaW1wdWxzZSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHJlbHBvcyA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7CiAgICAgICAgLy9hcHBseSBzdXNwZW5zaW9uIGZvcmNlCiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldOwogICAgICAgIGxldCBzdXNwZW5zaW9uRm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2U7CgogICAgICAgIGlmIChzdXNwZW5zaW9uRm9yY2UgPiB3aGVlbC5tYXhTdXNwZW5zaW9uRm9yY2UpIHsKICAgICAgICAgIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLm1heFN1c3BlbnNpb25Gb3JjZTsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuc2NhbGUoc3VzcGVuc2lvbkZvcmNlICogdGltZVN0ZXAsIGltcHVsc2UpOwogICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpOwogICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxwb3MpOwogICAgICB9CgogICAgICB0aGlzLnVwZGF0ZUZyaWN0aW9uKHRpbWVTdGVwKTsKICAgICAgY29uc3QgaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGZ3ZCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHZlbCA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7CiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldOyAvL2NvbnN0IHJlbHBvcyA9IG5ldyBWZWMzKCk7CiAgICAgICAgLy93aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQudnN1YihjaGFzc2lzQm9keS5wb3NpdGlvbiwgcmVscG9zKTsKCiAgICAgICAgY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCB2ZWwpOyAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uCgogICAgICAgIGxldCBtID0gMTsKCiAgICAgICAgc3dpdGNoICh0aGlzLmluZGV4VXBBeGlzKSB7CiAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgIG0gPSAtMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQoKICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHsKICAgICAgICAgIHRoaXMuZ2V0VmVoaWNsZUF4aXNXb3JsZCh0aGlzLmluZGV4Rm9yd2FyZEF4aXMsIGZ3ZCk7CiAgICAgICAgICBjb25zdCBwcm9qID0gZndkLmRvdCh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTsKICAgICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuc2NhbGUocHJvaiwgaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaik7CiAgICAgICAgICBmd2QudnN1YihoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qLCBmd2QpOwogICAgICAgICAgY29uc3QgcHJvajIgPSBmd2QuZG90KHZlbCk7CiAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gbSAqIHByb2oyICogdGltZVN0ZXAgLyB3aGVlbC5yYWRpdXM7CiAgICAgICAgfQoKICAgICAgICBpZiAoKHdoZWVsLnNsaWRpbmcgfHwgIXdoZWVsLmlzSW5Db250YWN0KSAmJiB3aGVlbC5lbmdpbmVGb3JjZSAhPT0gMCAmJiB3aGVlbC51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkKSB7CiAgICAgICAgICAvLyBBcHBseSBjdXN0b20gcm90YXRpb24gd2hlbiBhY2NlbGVyYXRpbmcgYW5kIHNsaWRpbmcKICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAod2hlZWwuZW5naW5lRm9yY2UgPiAwID8gMSA6IC0xKSAqIHdoZWVsLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgKiB0aW1lU3RlcDsKICAgICAgICB9IC8vIExvY2sgd2hlZWxzCgoKICAgICAgICBpZiAoTWF0aC5hYnMod2hlZWwuYnJha2UpID4gTWF0aC5hYnMod2hlZWwuZW5naW5lRm9yY2UpKSB7CiAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gMDsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnJvdGF0aW9uICs9IHdoZWVsLmRlbHRhUm90YXRpb247IC8vIFVzZSB0aGUgb2xkIHZhbHVlCgogICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gKj0gMC45OTsgLy8gZGFtcGluZyBvZiByb3RhdGlvbiB3aGVuIG5vdCBpbiBjb250YWN0CiAgICAgIH0KICAgIH0KCiAgICB1cGRhdGVTdXNwZW5zaW9uKGRlbHRhVGltZSkgewogICAgICBjb25zdCBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7CiAgICAgIGNvbnN0IGNoYXNzaXNNYXNzID0gY2hhc3Npc0JvZHkubWFzczsKICAgICAgY29uc3Qgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvczsKICAgICAgY29uc3QgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7CgogICAgICBmb3IgKGxldCB3X2l0ID0gMDsgd19pdCA8IG51bVdoZWVsczsgd19pdCsrKSB7CiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW3dfaXRdOwoKICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHsKICAgICAgICAgIGxldCBmb3JjZTsgLy8gU3ByaW5nCgogICAgICAgICAgY29uc3Qgc3VzcF9sZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aDsKICAgICAgICAgIGNvbnN0IGN1cnJlbnRfbGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvbkxlbmd0aDsKICAgICAgICAgIGNvbnN0IGxlbmd0aF9kaWZmID0gc3VzcF9sZW5ndGggLSBjdXJyZW50X2xlbmd0aDsKICAgICAgICAgIGZvcmNlID0gd2hlZWwuc3VzcGVuc2lvblN0aWZmbmVzcyAqIGxlbmd0aF9kaWZmICogd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOyAvLyBEYW1wZXIKCiAgICAgICAgICBjb25zdCBwcm9qZWN0ZWRfcmVsX3ZlbCA9IHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5OwogICAgICAgICAgbGV0IHN1c3BfZGFtcGluZzsKCiAgICAgICAgICBpZiAocHJvamVjdGVkX3JlbF92ZWwgPCAwKSB7CiAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdDb21wcmVzc2lvbjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdSZWxheGF0aW9uOwogICAgICAgICAgfQoKICAgICAgICAgIGZvcmNlIC09IHN1c3BfZGFtcGluZyAqIHByb2plY3RlZF9yZWxfdmVsOwogICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gZm9yY2UgKiBjaGFzc2lzTWFzczsKCiAgICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkZvcmNlIDwgMCkgewogICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmUgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyBmcm9tIHRoZSB3b3JsZC4KICAgICAqLwoKCiAgICByZW1vdmVGcm9tV29ybGQod29ybGQpIHsKICAgICAgdGhpcy5jb25zdHJhaW50czsKICAgICAgd29ybGQucmVtb3ZlQm9keSh0aGlzLmNoYXNzaXNCb2R5KTsKICAgICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICB9CgogICAgY2FzdFJheSh3aGVlbCkgewogICAgICBjb25zdCByYXl2ZWN0b3IgPSBjYXN0UmF5X3JheXZlY3RvcjsKICAgICAgY29uc3QgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7CiAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCh3aGVlbCk7CiAgICAgIGNvbnN0IGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTsKICAgICAgbGV0IGRlcHRoID0gLTE7CiAgICAgIGNvbnN0IHJheWxlbiA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwucmFkaXVzOwogICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZShyYXlsZW4sIHJheXZlY3Rvcik7CiAgICAgIGNvbnN0IHNvdXJjZSA9IHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZDsKICAgICAgc291cmNlLnZhZGQocmF5dmVjdG9yLCB0YXJnZXQpOwogICAgICBjb25zdCByYXljYXN0UmVzdWx0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdDsKICAgICAgcmF5Y2FzdFJlc3VsdC5yZXNldCgpOyAvLyBUdXJuIG9mZiByYXkgY29sbGlzaW9uIHdpdGggdGhlIGNoYXNzaXMgdGVtcG9yYXJpbHkKCiAgICAgIGNvbnN0IG9sZFN0YXRlID0gY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gZmFsc2U7IC8vIENhc3QgcmF5IGFnYWluc3Qgd29ybGQKCiAgICAgIHRoaXMud29ybGQucmF5VGVzdChzb3VyY2UsIHRhcmdldCwgcmF5Y2FzdFJlc3VsdCk7CiAgICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gb2xkU3RhdGU7CiAgICAgIGNvbnN0IG9iamVjdCA9IHJheWNhc3RSZXN1bHQuYm9keTsKICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5ncm91bmRPYmplY3QgPSAwOwoKICAgICAgaWYgKG9iamVjdCkgewogICAgICAgIGRlcHRoID0gcmF5Y2FzdFJlc3VsdC5kaXN0YW5jZTsKICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDsKICAgICAgICB3aGVlbC5pc0luQ29udGFjdCA9IHRydWU7CiAgICAgICAgY29uc3QgaGl0RGlzdGFuY2UgPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlOwogICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBoaXREaXN0YW5jZSAtIHdoZWVsLnJhZGl1czsgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsCgogICAgICAgIGNvbnN0IG1pblN1c3BlbnNpb25MZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCAtIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7CiAgICAgICAgY29uc3QgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDsKCiAgICAgICAgaWYgKHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPCBtaW5TdXNwZW5zaW9uTGVuZ3RoKSB7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWluU3VzcGVuc2lvbkxlbmd0aDsKICAgICAgICB9CgogICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID4gbWF4U3VzcGVuc2lvbkxlbmd0aCkgewogICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IG1heFN1c3BlbnNpb25MZW5ndGg7CiAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LnJlc2V0KCk7CiAgICAgICAgfQoKICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KHdoZWVsLmRpcmVjdGlvbldvcmxkKTsKICAgICAgICBjb25zdCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7CiAgICAgICAgY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7CiAgICAgICAgY29uc3QgcHJvalZlbCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTsKCiAgICAgICAgaWYgKGRlbm9taW5hdG9yID49IC0wLjEpIHsKICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDsKICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGludiA9IC0xIC8gZGVub21pbmF0b3I7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IHByb2pWZWwgKiBpbnY7CiAgICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vcHV0IHdoZWVsIGluZm8gYXMgaW4gcmVzdCBwb3NpdGlvbgogICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCArIDAgKiB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsOwogICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wOwogICAgICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKC0xLCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTsKICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjA7CiAgICAgIH0KCiAgICAgIHJldHVybiBkZXB0aDsKICAgIH0KCiAgICB1cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKSB7CiAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gZmFsc2U7CiAgICAgIGNvbnN0IGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTsKICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpOwogICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUod2hlZWwuZGlyZWN0aW9uTG9jYWwsIHdoZWVsLmRpcmVjdGlvbldvcmxkKTsKICAgICAgY2hhc3Npc0JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHdoZWVsLmF4bGVMb2NhbCwgd2hlZWwuYXhsZVdvcmxkKTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLgogICAgICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuCiAgICAgKiBAcGFyYW0gd2hlZWxJbmRleCBUaGUgd2hlZWwgaW5kZXggdG8gdXBkYXRlLgogICAgICovCgoKICAgIHVwZGF0ZVdoZWVsVHJhbnNmb3JtKHdoZWVsSW5kZXgpIHsKICAgICAgY29uc3QgdXAgPSB0bXBWZWM0OwogICAgICBjb25zdCByaWdodCA9IHRtcFZlYzU7CiAgICAgIGNvbnN0IGZ3ZCA9IHRtcFZlYzY7CiAgICAgIGNvbnN0IHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdOwogICAgICB0aGlzLnVwZGF0ZVdoZWVsVHJhbnNmb3JtV29ybGQod2hlZWwpOwogICAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApOwogICAgICByaWdodC5jb3B5KHdoZWVsLmF4bGVMb2NhbCk7CiAgICAgIHVwLmNyb3NzKHJpZ2h0LCBmd2QpOwogICAgICBmd2Qubm9ybWFsaXplKCk7CiAgICAgIHJpZ2h0Lm5vcm1hbGl6ZSgpOyAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZQoKICAgICAgY29uc3Qgc3RlZXJpbmcgPSB3aGVlbC5zdGVlcmluZzsKICAgICAgY29uc3Qgc3RlZXJpbmdPcm4gPSBuZXcgUXVhdGVybmlvbigpOwogICAgICBzdGVlcmluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHVwLCBzdGVlcmluZyk7CiAgICAgIGNvbnN0IHJvdGF0aW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgcm90YXRpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZShyaWdodCwgd2hlZWwucm90YXRpb24pOyAvLyBXb3JsZCByb3RhdGlvbiBvZiB0aGUgd2hlZWwKCiAgICAgIGNvbnN0IHEgPSB3aGVlbC53b3JsZFRyYW5zZm9ybS5xdWF0ZXJuaW9uOwogICAgICB0aGlzLmNoYXNzaXNCb2R5LnF1YXRlcm5pb24ubXVsdChzdGVlcmluZ09ybiwgcSk7CiAgICAgIHEubXVsdChyb3RhdGluZ09ybiwgcSk7CiAgICAgIHEubm9ybWFsaXplKCk7IC8vIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB3aGVlbAoKICAgICAgY29uc3QgcCA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uOwogICAgICBwLmNvcHkod2hlZWwuZGlyZWN0aW9uV29ybGQpOwogICAgICBwLnNjYWxlKHdoZWVsLnN1c3BlbnNpb25MZW5ndGgsIHApOwogICAgICBwLnZhZGQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCBwKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2Ygb25lIG9mIHRoZSB3aGVlbHMKICAgICAqLwoKCiAgICBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsSW5kZXgpIHsKICAgICAgcmV0dXJuIHRoaXMud2hlZWxJbmZvc1t3aGVlbEluZGV4XS53b3JsZFRyYW5zZm9ybTsKICAgIH0KCiAgICB1cGRhdGVGcmljdGlvbih0aW1lU3RlcCkgewogICAgICBjb25zdCBzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2o7IC8vY2FsY3VsYXRlIHRoZSBpbXB1bHNlLCBzbyB0aGF0IHRoZSB3aGVlbHMgZG9uJ3QgbW92ZSBzaWRld2FyZHMKCiAgICAgIGNvbnN0IHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7CiAgICAgIGNvbnN0IG51bVdoZWVscyA9IHdoZWVsSW5mb3MubGVuZ3RoOwogICAgICBjb25zdCBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7CiAgICAgIGNvbnN0IGZvcndhcmRXUyA9IHVwZGF0ZUZyaWN0aW9uX2ZvcndhcmRXUzsKICAgICAgY29uc3QgYXhsZSA9IHVwZGF0ZUZyaWN0aW9uX2F4bGU7CiAgICAgIHRoaXMubnVtV2hlZWxzT25Hcm91bmQgPSAwOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKICAgICAgICBjb25zdCBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7CgogICAgICAgIGlmIChncm91bmRPYmplY3QpIHsKICAgICAgICAgIHRoaXMubnVtV2hlZWxzT25Hcm91bmQrKzsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gMDsKICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7CgogICAgICAgIGlmICghZm9yd2FyZFdTW2ldKSB7CiAgICAgICAgICBmb3J3YXJkV1NbaV0gPSBuZXcgVmVjMygpOwogICAgICAgIH0KCiAgICAgICAgaWYgKCFheGxlW2ldKSB7CiAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICBjb25zdCB3aGVlbCA9IHdoZWVsSW5mb3NbaV07CiAgICAgICAgY29uc3QgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5OwoKICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7CiAgICAgICAgICBjb25zdCBheGxlaSA9IGF4bGVbaV07CiAgICAgICAgICBjb25zdCB3aGVlbFRyYW5zID0gdGhpcy5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkKGkpOyAvLyBHZXQgd29ybGQgYXhsZQoKICAgICAgICAgIHdoZWVsVHJhbnMudmVjdG9yVG9Xb3JsZEZyYW1lKGRpcmVjdGlvbnNbdGhpcy5pbmRleFJpZ2h0QXhpc10sIGF4bGVpKTsKICAgICAgICAgIGNvbnN0IHN1cmZOb3JtYWxXUyA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7CiAgICAgICAgICBjb25zdCBwcm9qID0gYXhsZWkuZG90KHN1cmZOb3JtYWxXUyk7CiAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTsKICAgICAgICAgIGF4bGVpLnZzdWIoc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qLCBheGxlaSk7CiAgICAgICAgICBheGxlaS5ub3JtYWxpemUoKTsKICAgICAgICAgIHN1cmZOb3JtYWxXUy5jcm9zcyhheGxlaSwgZm9yd2FyZFdTW2ldKTsKICAgICAgICAgIGZvcndhcmRXU1tpXS5ub3JtYWxpemUoKTsKICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChjaGFzc2lzQm9keSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLCBncm91bmRPYmplY3QsIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgYXhsZWkpOwogICAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgKj0gc2lkZUZyaWN0aW9uU3RpZmZuZXNzMjsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IHNpZGVGYWN0b3IgPSAxOwogICAgICBjb25zdCBmd2RGYWN0b3IgPSAwLjU7CiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKICAgICAgICBjb25zdCBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7CiAgICAgICAgbGV0IHJvbGxpbmdGcmljdGlvbiA9IDA7CiAgICAgICAgd2hlZWwuc2xpcEluZm8gPSAxOwoKICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7CiAgICAgICAgICBjb25zdCBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZSA9IDA7CiAgICAgICAgICBjb25zdCBtYXhJbXB1bHNlID0gd2hlZWwuYnJha2UgPyB3aGVlbC5icmFrZSA6IGRlZmF1bHRSb2xsaW5nRnJpY3Rpb25JbXB1bHNlOyAvLyBidFdoZWVsQ29udGFjdFBvaW50IGNvbnRhY3RQdChjaGFzc2lzQm9keSxncm91bmRPYmplY3Qsd2hlZWxJbmZyYXljYXN0SW5mby5oaXRQb2ludFdvcmxkLGZvcndhcmRXU1t3aGVlbF0sbWF4SW1wdWxzZSk7CiAgICAgICAgICAvLyByb2xsaW5nRnJpY3Rpb24gPSBjYWxjUm9sbGluZ0ZyaWN0aW9uKGNvbnRhY3RQdCk7CgogICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7CiAgICAgICAgICByb2xsaW5nRnJpY3Rpb24gKz0gd2hlZWwuZW5naW5lRm9yY2UgKiB0aW1lU3RlcDsgLy8gcm9sbGluZ0ZyaWN0aW9uID0gMDsKCiAgICAgICAgICBjb25zdCBmYWN0b3IgPSBtYXhJbXB1bHNlIC8gcm9sbGluZ0ZyaWN0aW9uOwogICAgICAgICAgd2hlZWwuc2xpcEluZm8gKj0gZmFjdG9yOwogICAgICAgIH0gLy9zd2l0Y2ggYmV0d2VlbiBhY3RpdmUgcm9sbGluZyAodGhyb3R0bGUpLCBicmFraW5nIGFuZCBub24tYWN0aXZlIHJvbGxpbmcgZnJpY3Rpb24gKG50aHJvdHRsZS9icmVhaykKCgogICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDsKICAgICAgICB3aGVlbC5za2lkSW5mbyA9IDE7CgogICAgICAgIGlmIChncm91bmRPYmplY3QpIHsKICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTsKICAgICAgICAgIGNvbnN0IG1heGltcCA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwICogd2hlZWwuZnJpY3Rpb25TbGlwOwogICAgICAgICAgY29uc3QgbWF4aW1wU2lkZSA9IG1heGltcDsKICAgICAgICAgIGNvbnN0IG1heGltcFNxdWFyZWQgPSBtYXhpbXAgKiBtYXhpbXBTaWRlOwogICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgPSByb2xsaW5nRnJpY3Rpb247IC8vd2hlZWxJbmZvLmVuZ2luZUZvcmNlKiB0aW1lU3RlcDsKCiAgICAgICAgICBjb25zdCB4ID0gd2hlZWwuZm9yd2FyZEltcHVsc2UgKiBmd2RGYWN0b3IgLyB3aGVlbC5mb3J3YXJkQWNjZWxlcmF0aW9uOwogICAgICAgICAgY29uc3QgeSA9IHdoZWVsLnNpZGVJbXB1bHNlICogc2lkZUZhY3RvciAvIHdoZWVsLnNpZGVBY2NlbGVyYXRpb247CiAgICAgICAgICBjb25zdCBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7CiAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gZmFsc2U7CgogICAgICAgICAgaWYgKGltcHVsc2VTcXVhcmVkID4gbWF4aW1wU3F1YXJlZCkgewogICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSB0cnVlOwogICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gdHJ1ZTsKICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gbWF4aW1wIC8gTWF0aC5zcXJ0KGltcHVsc2VTcXVhcmVkKTsKICAgICAgICAgICAgd2hlZWwuc2tpZEluZm8gKj0gZmFjdG9yOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuc2xpZGluZykgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKCiAgICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHsKICAgICAgICAgICAgaWYgKHdoZWVsLnNraWRJbmZvIDwgMSkgewogICAgICAgICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvOwogICAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIGFwcGx5IHRoZSBpbXB1bHNlcwoKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICBjb25zdCB3aGVlbCA9IHdoZWVsSW5mb3NbaV07CiAgICAgICAgY29uc3QgcmVsX3BvcyA9IG5ldyBWZWMzKCk7CiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbF9wb3MpOyAvLyBjYW5ub25zIGFwcGx5aW1wdWxzZSBpcyB1c2luZyB3b3JsZCBjb29yZCBmb3IgdGhlIHBvc2l0aW9uCiAgICAgICAgLy9yZWxfcG9zLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTsKCiAgICAgICAgaWYgKHdoZWVsLmZvcndhcmRJbXB1bHNlICE9PSAwKSB7CiAgICAgICAgICBjb25zdCBpbXB1bHNlID0gbmV3IFZlYzMoKTsKICAgICAgICAgIGZvcndhcmRXU1tpXS5zY2FsZSh3aGVlbC5mb3J3YXJkSW1wdWxzZSwgaW1wdWxzZSk7CiAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSwgcmVsX3Bvcyk7CiAgICAgICAgfQoKICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHsKICAgICAgICAgIGNvbnN0IGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTsKICAgICAgICAgIGNvbnN0IHJlbF9wb3MyID0gbmV3IFZlYzMoKTsKICAgICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGdyb3VuZE9iamVjdC5wb3NpdGlvbiwgcmVsX3BvczIpOyAvL3JlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTsKCiAgICAgICAgICBjb25zdCBzaWRlSW1wID0gbmV3IFZlYzMoKTsKICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApOyAvLyBTY2FsZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIHVwIGRpcmVjdGlvbiB3aXRoIHJvbGxJbmZsdWVuY2UuCiAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLgoKICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvTG9jYWxGcmFtZShyZWxfcG9zLCByZWxfcG9zKTsKICAgICAgICAgIHJlbF9wb3NbJ3h5eidbdGhpcy5pbmRleFVwQXhpc11dICo9IHdoZWVsLnJvbGxJbmZsdWVuY2U7CiAgICAgICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7CiAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3Bvcyk7IC8vYXBwbHkgZnJpY3Rpb24gaW1wdWxzZSBvbiB0aGUgZ3JvdW5kCgogICAgICAgICAgc2lkZUltcC5zY2FsZSgtMSwgc2lkZUltcCk7CiAgICAgICAgICBncm91bmRPYmplY3QuYXBwbHlJbXB1bHNlKHNpZGVJbXAsIHJlbF9wb3MyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzQgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzUgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzYgPSBuZXcgVmVjMygpOwogIG5ldyBSYXkoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IGNhc3RSYXlfcmF5dmVjdG9yID0gbmV3IFZlYzMoKTsKICBjb25zdCBjYXN0UmF5X3RhcmdldCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZGlyZWN0aW9ucyA9IFtuZXcgVmVjMygxLCAwLCAwKSwgbmV3IFZlYzMoMCwgMSwgMCksIG5ldyBWZWMzKDAsIDAsIDEpXTsKICBjb25zdCB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpOwogIGNvbnN0IHVwZGF0ZUZyaWN0aW9uX2F4bGUgPSBbXTsKICBjb25zdCB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTsKICBjb25zdCBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTsKICBjb25zdCBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwgPSBuZXcgVmVjMygpOwoKICBmdW5jdGlvbiBjYWxjUm9sbGluZ0ZyaWN0aW9uKGJvZHkwLCBib2R5MSwgZnJpY3Rpb25Qb3NXb3JsZCwgZnJpY3Rpb25EaXJlY3Rpb25Xb3JsZCwgbWF4SW1wdWxzZSkgewogICAgbGV0IGoxID0gMDsKICAgIGNvbnN0IGNvbnRhY3RQb3NXb3JsZCA9IGZyaWN0aW9uUG9zV29ybGQ7IC8vIGNvbnN0IHJlbF9wb3MxID0gbmV3IFZlYzMoKTsKICAgIC8vIGNvbnN0IHJlbF9wb3MyID0gbmV3IFZlYzMoKTsKCiAgICBjb25zdCB2ZWwxID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwxOwogICAgY29uc3QgdmVsMiA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMjsKICAgIGNvbnN0IHZlbCA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsOyAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MC5wb3NpdGlvbiwgcmVsX3BvczEpOwogICAgLy8gY29udGFjdFBvc1dvcmxkLnZzdWIoYm9keTEucG9zaXRpb24sIHJlbF9wb3MyKTsKCiAgICBib2R5MC5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChjb250YWN0UG9zV29ybGQsIHZlbDEpOwogICAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoY29udGFjdFBvc1dvcmxkLCB2ZWwyKTsKICAgIHZlbDEudnN1Yih2ZWwyLCB2ZWwpOwogICAgY29uc3QgdnJlbCA9IGZyaWN0aW9uRGlyZWN0aW9uV29ybGQuZG90KHZlbCk7CiAgICBjb25zdCBkZW5vbTAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yKGJvZHkwLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkKTsKICAgIGNvbnN0IGRlbm9tMSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpOwogICAgY29uc3QgcmVsYXhhdGlvbiA9IDE7CiAgICBjb25zdCBqYWNEaWFnQUJJbnYgPSByZWxheGF0aW9uIC8gKGRlbm9tMCArIGRlbm9tMSk7IC8vIGNhbGN1bGF0ZSBqIHRoYXQgbW92ZXMgdXMgdG8gemVybyByZWxhdGl2ZSB2ZWxvY2l0eQoKICAgIGoxID0gLXZyZWwgKiBqYWNEaWFnQUJJbnY7CgogICAgaWYgKG1heEltcHVsc2UgPCBqMSkgewogICAgICBqMSA9IG1heEltcHVsc2U7CiAgICB9CgogICAgaWYgKGoxIDwgLW1heEltcHVsc2UpIHsKICAgICAgajEgPSAtbWF4SW1wdWxzZTsKICAgIH0KCiAgICByZXR1cm4gajE7CiAgfQoKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tID0gbmV3IFZlYzMoKTsKCiAgZnVuY3Rpb24gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5LCBwb3MsIG5vcm1hbCkgewogICAgY29uc3QgcjAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwOwogICAgY29uc3QgYzAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwOwogICAgY29uc3QgdmVjID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWM7CiAgICBjb25zdCBtID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tOwogICAgcG9zLnZzdWIoYm9keS5wb3NpdGlvbiwgcjApOwogICAgcjAuY3Jvc3Mobm9ybWFsLCBjMCk7CiAgICBib2R5LmludkluZXJ0aWFXb3JsZC52bXVsdChjMCwgbSk7CiAgICBtLmNyb3NzKHIwLCB2ZWMpOwogICAgcmV0dXJuIGJvZHkuaW52TWFzcyArIG5vcm1hbC5kb3QodmVjKTsKICB9CgogIGNvbnN0IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyID0gbmV3IFZlYzMoKTsKICBjb25zdCByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbCA9IG5ldyBWZWMzKCk7IC8vIGJpbGF0ZXJhbCBjb25zdHJhaW50IGJldHdlZW4gdHdvIGR5bmFtaWMgb2JqZWN0cwoKICBmdW5jdGlvbiByZXNvbHZlU2luZ2xlQmlsYXRlcmFsKGJvZHkxLCBwb3MxLCBib2R5MiwgcG9zMiwgbm9ybWFsKSB7CiAgICBjb25zdCBub3JtYWxMZW5TcXIgPSBub3JtYWwubGVuZ3RoU3F1YXJlZCgpOwoKICAgIGlmIChub3JtYWxMZW5TcXIgPiAxLjEpIHsKICAgICAgcmV0dXJuIDA7IC8vIG5vIGltcHVsc2UKICAgIH0gLy8gY29uc3QgcmVsX3BvczEgPSBuZXcgVmVjMygpOwogICAgLy8gY29uc3QgcmVsX3BvczIgPSBuZXcgVmVjMygpOwogICAgLy8gcG9zMS52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMSk7CiAgICAvLyBwb3MyLnZzdWIoYm9keTIucG9zaXRpb24sIHJlbF9wb3MyKTsKCgogICAgY29uc3QgdmVsMSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMTsKICAgIGNvbnN0IHZlbDIgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDI7CiAgICBjb25zdCB2ZWwgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDsKICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHBvczEsIHZlbDEpOwogICAgYm9keTIuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMiwgdmVsMik7CiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTsKICAgIGNvbnN0IHJlbF92ZWwgPSBub3JtYWwuZG90KHZlbCk7CiAgICBjb25zdCBjb250YWN0RGFtcGluZyA9IDAuMjsKICAgIGNvbnN0IG1hc3NUZXJtID0gMSAvIChib2R5MS5pbnZNYXNzICsgYm9keTIuaW52TWFzcyk7CiAgICBjb25zdCBpbXB1bHNlID0gLWNvbnRhY3REYW1waW5nICogcmVsX3ZlbCAqIG1hc3NUZXJtOwogICAgcmV0dXJuIGltcHVsc2U7CiAgfQoKICAvKioKICAgKiBTcGhlcmljYWwgc2hhcGUKICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCByYWRpdXMgPSAxCiAgICogICAgIGNvbnN0IHNwaGVyZVNoYXBlID0gbmV3IENBTk5PTi5TcGhlcmUocmFkaXVzKQogICAqICAgICBjb25zdCBzcGhlcmVCb2R5ID0gbmV3IENBTk5PTi5Cb2R5KHsgbWFzczogMSwgc2hhcGU6IHNwaGVyZVNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoc3BoZXJlQm9keSkKICAgKi8KICBjbGFzcyBTcGhlcmUgZXh0ZW5kcyBTaGFwZSB7CiAgICAvKioKICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZS4KICAgICAqLwoKICAgIC8qKgogICAgICoKICAgICAqIEBwYXJhbSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLCBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKHJhZGl1cykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuU1BIRVJFCiAgICAgIH0pOwogICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyAhPT0gdW5kZWZpbmVkID8gcmFkaXVzIDogMS4wOwoKICAgICAgaWYgKHRoaXMucmFkaXVzIDwgMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwaGVyZSByYWRpdXMgY2Fubm90IGJlIG5lZ2F0aXZlLicpOwogICAgICB9CgogICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICB9CiAgICAvKiogY2FsY3VsYXRlTG9jYWxJbmVydGlhICovCgoKICAgIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgY29uc3QgSSA9IDIuMCAqIG1hc3MgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzIC8gNS4wOwogICAgICB0YXJnZXQueCA9IEk7CiAgICAgIHRhcmdldC55ID0gSTsKICAgICAgdGFyZ2V0LnogPSBJOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqIHZvbHVtZSAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDMpIC8gMy4wOwogICAgfQoKICAgIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkgewogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gdGhpcy5yYWRpdXM7CiAgICB9CgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgY29uc3QgciA9IHRoaXMucmFkaXVzOwogICAgICBjb25zdCBheGVzID0gWyd4JywgJ3knLCAneiddOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgYXggPSBheGVzW2ldOwogICAgICAgIG1pbltheF0gPSBwb3NbYXhdIC0gcjsKICAgICAgICBtYXhbYXhdID0gcG9zW2F4XSArIHI7CiAgICAgIH0KICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uCgogIG5ldyBWZWMzKCk7IC8vIFJlbGF0aXZlIHZlbG9jaXR5CgogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQ3lsaW5kZXIgY2xhc3MuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3QgcmFkaXVzVG9wID0gMC41CiAgICogICAgIGNvbnN0IHJhZGl1c0JvdHRvbSA9IDAuNQogICAqICAgICBjb25zdCBoZWlnaHQgPSAyCiAgICogICAgIGNvbnN0IG51bVNlZ21lbnRzID0gMTIKICAgKiAgICAgY29uc3QgY3lsaW5kZXJTaGFwZSA9IG5ldyBDQU5OT04uQ3lsaW5kZXIocmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgbnVtU2VnbWVudHMpCiAgICogICAgIGNvbnN0IGN5bGluZGVyQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBjeWxpbmRlclNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoY3lsaW5kZXJCb2R5KQogICAqLwoKICBjbGFzcyBDeWxpbmRlciBleHRlbmRzIENvbnZleFBvbHloZWRyb24gewogICAgLyoqIFRoZSByYWRpdXMgb2YgdGhlIHRvcCBvZiB0aGUgQ3lsaW5kZXIuICovCgogICAgLyoqIFRoZSByYWRpdXMgb2YgdGhlIGJvdHRvbSBvZiB0aGUgQ3lsaW5kZXIuICovCgogICAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIEN5bGluZGVyLiAqLwoKICAgIC8qKiBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGJ1aWxkIHRoZSBjeWxpbmRlciBvdXQgb2YuICovCgogICAgLyoqCiAgICAgKiBAcGFyYW0gcmFkaXVzVG9wIFRoZSByYWRpdXMgb2YgdGhlIHRvcCBvZiB0aGUgQ3lsaW5kZXIuCiAgICAgKiBAcGFyYW0gcmFkaXVzQm90dG9tIFRoZSByYWRpdXMgb2YgdGhlIGJvdHRvbSBvZiB0aGUgQ3lsaW5kZXIuCiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIEN5bGluZGVyLgogICAgICogQHBhcmFtIG51bVNlZ21lbnRzIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgdG8gYnVpbGQgdGhlIGN5bGluZGVyIG91dCBvZi4KICAgICAqLwogICAgY29uc3RydWN0b3IocmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgbnVtU2VnbWVudHMpIHsKICAgICAgaWYgKHJhZGl1c1RvcCA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmFkaXVzVG9wID0gMTsKICAgICAgfQoKICAgICAgaWYgKHJhZGl1c0JvdHRvbSA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmFkaXVzQm90dG9tID0gMTsKICAgICAgfQoKICAgICAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7CiAgICAgICAgaGVpZ2h0ID0gMTsKICAgICAgfQoKICAgICAgaWYgKG51bVNlZ21lbnRzID09PSB2b2lkIDApIHsKICAgICAgICBudW1TZWdtZW50cyA9IDg7CiAgICAgIH0KCiAgICAgIGlmIChyYWRpdXNUb3AgPCAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3lsaW5kZXIgcmFkaXVzVG9wIGNhbm5vdCBiZSBuZWdhdGl2ZS4nKTsKICAgICAgfQoKICAgICAgaWYgKHJhZGl1c0JvdHRvbSA8IDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjeWxpbmRlciByYWRpdXNCb3R0b20gY2Fubm90IGJlIG5lZ2F0aXZlLicpOwogICAgICB9CgogICAgICBjb25zdCBOID0gbnVtU2VnbWVudHM7CiAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICAgIGNvbnN0IGF4ZXMgPSBbXTsKICAgICAgY29uc3QgZmFjZXMgPSBbXTsKICAgICAgY29uc3QgYm90dG9tZmFjZSA9IFtdOwogICAgICBjb25zdCB0b3BmYWNlID0gW107CiAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zOwogICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbjsgLy8gRmlyc3QgYm90dG9tIHBvaW50CgogICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWMzKC1yYWRpdXNCb3R0b20gKiBzaW4oMCksIC1oZWlnaHQgKiAwLjUsIHJhZGl1c0JvdHRvbSAqIGNvcygwKSkpOwogICAgICBib3R0b21mYWNlLnB1c2goMCk7IC8vIEZpcnN0IHRvcCBwb2ludAoKICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjMygtcmFkaXVzVG9wICogc2luKDApLCBoZWlnaHQgKiAwLjUsIHJhZGl1c1RvcCAqIGNvcygwKSkpOwogICAgICB0b3BmYWNlLnB1c2goMSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgewogICAgICAgIGNvbnN0IHRoZXRhID0gMiAqIE1hdGguUEkgLyBOICogKGkgKyAxKTsKICAgICAgICBjb25zdCB0aGV0YU4gPSAyICogTWF0aC5QSSAvIE4gKiAoaSArIDAuNSk7CgogICAgICAgIGlmIChpIDwgTiAtIDEpIHsKICAgICAgICAgIC8vIEJvdHRvbQogICAgICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjMygtcmFkaXVzQm90dG9tICogc2luKHRoZXRhKSwgLWhlaWdodCAqIDAuNSwgcmFkaXVzQm90dG9tICogY29zKHRoZXRhKSkpOwogICAgICAgICAgYm90dG9tZmFjZS5wdXNoKDIgKiBpICsgMik7IC8vIFRvcAoKICAgICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlYzMoLXJhZGl1c1RvcCAqIHNpbih0aGV0YSksIGhlaWdodCAqIDAuNSwgcmFkaXVzVG9wICogY29zKHRoZXRhKSkpOwogICAgICAgICAgdG9wZmFjZS5wdXNoKDIgKiBpICsgMyk7IC8vIEZhY2UKCiAgICAgICAgICBmYWNlcy5wdXNoKFsyICogaSwgMiAqIGkgKyAxLCAyICogaSArIDMsIDIgKiBpICsgMl0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBmYWNlcy5wdXNoKFsyICogaSwgMiAqIGkgKyAxLCAxLCAwXSk7IC8vIENvbm5lY3QKICAgICAgICB9IC8vIEF4aXM6IHdlIGNhbiBjdXQgb2ZmIGhhbGYgb2YgdGhlbSBpZiB3ZSBoYXZlIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzCgoKICAgICAgICBpZiAoTiAlIDIgPT09IDEgfHwgaSA8IE4gLyAyKSB7CiAgICAgICAgICBheGVzLnB1c2gobmV3IFZlYzMoLXNpbih0aGV0YU4pLCAwLCBjb3ModGhldGFOKSkpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgZmFjZXMucHVzaChib3R0b21mYWNlKTsKICAgICAgYXhlcy5wdXNoKG5ldyBWZWMzKDAsIDEsIDApKTsgLy8gUmVvcmRlciB0b3AgZmFjZQoKICAgICAgY29uc3QgdGVtcCA9IFtdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BmYWNlLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGVtcC5wdXNoKHRvcGZhY2VbdG9wZmFjZS5sZW5ndGggLSBpIC0gMV0pOwogICAgICB9CgogICAgICBmYWNlcy5wdXNoKHRlbXApOwogICAgICBzdXBlcih7CiAgICAgICAgdmVydGljZXMsCiAgICAgICAgZmFjZXMsCiAgICAgICAgYXhlcwogICAgICB9KTsKICAgICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQ1lMSU5ERVI7CiAgICAgIHRoaXMucmFkaXVzVG9wID0gcmFkaXVzVG9wOwogICAgICB0aGlzLnJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbTsKICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7CiAgICAgIHRoaXMubnVtU2VnbWVudHMgPSBudW1TZWdtZW50czsKICAgIH0KCiAgfQoKICAvKioKICAgKiBQYXJ0aWNsZSBzaGFwZS4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBwYXJ0aWNsZVNoYXBlID0gbmV3IENBTk5PTi5QYXJ0aWNsZSgpCiAgICogICAgIGNvbnN0IHBhcnRpY2xlQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBwYXJ0aWNsZVNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkocGFydGljbGVCb2R5KQogICAqLwogIGNsYXNzIFBhcnRpY2xlIGV4dGVuZHMgU2hhcGUgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5QQVJUSUNMRQogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlTG9jYWxJbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQuc2V0KDAsIDAsIDApOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuIDA7CiAgICB9CgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSAwOwogICAgfQoKICAgIGNhbGN1bGF0ZVdvcmxkQUFCQihwb3MsIHF1YXQsIG1pbiwgbWF4KSB7CiAgICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4CiAgICAgIG1pbi5jb3B5KHBvcyk7CiAgICAgIG1heC5jb3B5KHBvcyk7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQSBwbGFuZSwgZmFjaW5nIGluIHRoZSBaIGRpcmVjdGlvbi4gVGhlIHBsYW5lIGhhcyBpdHMgc3VyZmFjZSBhdCB6PTAgYW5kIGV2ZXJ5dGhpbmcgYmVsb3cgej0wIGlzIGFzc3VtZWQgdG8gYmUgc29saWQgcGxhbmUuIFRvIG1ha2UgdGhlIHBsYW5lIGZhY2UgaW4gc29tZSBvdGhlciBkaXJlY3Rpb24gdGhhbiB6LCB5b3UgbXVzdCBwdXQgaXQgaW5zaWRlIGEgQm9keSBhbmQgcm90YXRlIHRoYXQgYm9keS4gU2VlIHRoZSBkZW1vcy4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBwbGFuZVNoYXBlID0gbmV3IENBTk5PTi5QbGFuZSgpCiAgICogICAgIGNvbnN0IHBsYW5lQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDAsIHNoYXBlOiAgcGxhbmVTaGFwZSB9KQogICAqICAgICBwbGFuZUJvZHkucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoLU1hdGguUEkgLyAyLCAwLCAwKSAvLyBtYWtlIGl0IGZhY2UgdXAKICAgKiAgICAgd29ybGQuYWRkQm9keShwbGFuZUJvZHkpCiAgICovCiAgY2xhc3MgUGxhbmUgZXh0ZW5kcyBTaGFwZSB7CiAgICAvKiogd29ybGROb3JtYWwgKi8KCiAgICAvKiogd29ybGROb3JtYWxOZWVkc1VwZGF0ZSAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5QTEFORQogICAgICB9KTsgLy8gV29ybGQgb3JpZW50ZWQgbm9ybWFsCgogICAgICB0aGlzLndvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7CiAgICB9CiAgICAvKiogY29tcHV0ZVdvcmxkTm9ybWFsICovCgoKICAgIGNvbXB1dGVXb3JsZE5vcm1hbChxdWF0KSB7CiAgICAgIGNvbnN0IG4gPSB0aGlzLndvcmxkTm9ybWFsOwogICAgICBuLnNldCgwLCAwLCAxKTsKICAgICAgcXVhdC52bXVsdChuLCBuKTsKICAgICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gZmFsc2U7CiAgICB9CgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuICgvLyBUaGUgcGxhbmUgaXMgaW5maW5pdGUuLi4KICAgICAgICBOdW1iZXIuTUFYX1ZBTFVFCiAgICAgICk7CiAgICB9CgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgLy8gVGhlIHBsYW5lIEFBQkIgaXMgaW5maW5pdGUsIGV4Y2VwdCBpZiB0aGUgbm9ybWFsIGlzIHBvaW50aW5nIGFsb25nIGFueSBheGlzCiAgICAgIHRlbXBOb3JtYWwuc2V0KDAsIDAsIDEpOyAvLyBEZWZhdWx0IHBsYW5lIG5vcm1hbCBpcyB6CgogICAgICBxdWF0LnZtdWx0KHRlbXBOb3JtYWwsIHRlbXBOb3JtYWwpOwogICAgICBjb25zdCBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFOwogICAgICBtaW4uc2V0KC1tYXhWYWwsIC1tYXhWYWwsIC1tYXhWYWwpOwogICAgICBtYXguc2V0KG1heFZhbCwgbWF4VmFsLCBtYXhWYWwpOwoKICAgICAgaWYgKHRlbXBOb3JtYWwueCA9PT0gMSkgewogICAgICAgIG1heC54ID0gcG9zLng7CiAgICAgIH0gZWxzZSBpZiAodGVtcE5vcm1hbC54ID09PSAtMSkgewogICAgICAgIG1pbi54ID0gcG9zLng7CiAgICAgIH0KCiAgICAgIGlmICh0ZW1wTm9ybWFsLnkgPT09IDEpIHsKICAgICAgICBtYXgueSA9IHBvcy55OwogICAgICB9IGVsc2UgaWYgKHRlbXBOb3JtYWwueSA9PT0gLTEpIHsKICAgICAgICBtaW4ueSA9IHBvcy55OwogICAgICB9CgogICAgICBpZiAodGVtcE5vcm1hbC56ID09PSAxKSB7CiAgICAgICAgbWF4LnogPSBwb3MuejsKICAgICAgfSBlbHNlIGlmICh0ZW1wTm9ybWFsLnogPT09IC0xKSB7CiAgICAgICAgbWluLnogPSBwb3MuejsKICAgICAgfQogICAgfQoKICAgIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkgewogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTsKICAgIH0KCiAgfQogIGNvbnN0IHRlbXBOb3JtYWwgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBIZWlnaHRmaWVsZCBzaGFwZSBjbGFzcy4gSGVpZ2h0IGRhdGEgaXMgZ2l2ZW4gYXMgYW4gYXJyYXkuIFRoZXNlIGRhdGEgcG9pbnRzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSB3aXRoIGEgZ2l2ZW4gZGlzdGFuY2UuCiAgICogQHRvZG8gU2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBhbG9uZyBhbGwgYXhlcywgbm90IGp1c3QgeQogICAqIEB0b2RvIHNob3VsZCBiZSBwb3NzaWJsZSB0byBzY2FsZSBhbG9uZyBhbGwgYXhlcwogICAqIEB0b2RvIFJlZmFjdG9yIGVsZW1lbnRTaXplIHRvIGVsZW1lbnRTaXplWCBhbmQgZWxlbWVudFNpemVZCiAgICoKICAgKiBAZXhhbXBsZQogICAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuCiAgICogICAgIGNvbnN0IGRhdGEgPSBbXQogICAqICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykgewogICAqICAgICAgICAgY29uc3QgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpCiAgICogICAgICAgICBkYXRhLnB1c2goeSkKICAgKiAgICAgfQogICAqCiAgICogICAgIC8vIENyZWF0ZSB0aGUgaGVpZ2h0ZmllbGQgc2hhcGUKICAgKiAgICAgY29uc3QgaGVpZ2h0ZmllbGRTaGFwZSA9IG5ldyBDQU5OT04uSGVpZ2h0ZmllbGQoZGF0YSwgewogICAqICAgICAgICAgZWxlbWVudFNpemU6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBhbmQgWSBkaXJlY3Rpb25zCiAgICogICAgIH0pCiAgICogICAgIGNvbnN0IGhlaWdodGZpZWxkQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IHNoYXBlOiBoZWlnaHRmaWVsZFNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KQogICAqLwogIGNsYXNzIEhlaWdodGZpZWxkIGV4dGVuZHMgU2hhcGUgewogICAgLyoqCiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1pbmltdW0gdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzIGluIHRoZSBkYXRhIGFycmF5LgogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZCBzcGFjaW5nIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggYW5kIFkgZGlyZWN0aW9uLgogICAgICogQHRvZG8gZWxlbWVudFNpemVYIGFuZCBZCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGRhdGEgQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7CiAgICAgICAgbWF4VmFsdWU6IG51bGwsCiAgICAgICAgbWluVmFsdWU6IG51bGwsCiAgICAgICAgZWxlbWVudFNpemU6IDEKICAgICAgfSk7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRAogICAgICB9KTsKICAgICAgdGhpcy5kYXRhID0gZGF0YTsKICAgICAgdGhpcy5tYXhWYWx1ZSA9IG9wdGlvbnMubWF4VmFsdWU7CiAgICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlOwogICAgICB0aGlzLmVsZW1lbnRTaXplID0gb3B0aW9ucy5lbGVtZW50U2l6ZTsKCiAgICAgIGlmIChvcHRpb25zLm1pblZhbHVlID09PSBudWxsKSB7CiAgICAgICAgdGhpcy51cGRhdGVNaW5WYWx1ZSgpOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCkgewogICAgICAgIHRoaXMudXBkYXRlTWF4VmFsdWUoKTsKICAgICAgfQoKICAgICAgdGhpcy5jYWNoZUVuYWJsZWQgPSB0cnVlOwogICAgICB0aGlzLnBpbGxhckNvbnZleCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAgIHRoaXMucGlsbGFyT2Zmc2V0ID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOyAvLyAiaV9qX2lzVXBwZXIiID0+IHsgY29udmV4OiAuLi4sIG9mZnNldDogLi4uIH0KICAgICAgLy8gZm9yIGV4YW1wbGU6CiAgICAgIC8vIF9jYWNoZWRQaWxsYXJzWyIwXzJfMSJdCgogICAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307CiAgICB9CiAgICAvKioKICAgICAqIENhbGwgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgZGF0YSBhcnJheS4KICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIHRoaXMuX2NhY2hlZFBpbGxhcnMgPSB7fTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIHRoZSBgbWluVmFsdWVgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlTWluVmFsdWUoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGxldCBtaW5WYWx1ZSA9IGRhdGFbMF1bMF07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCB2ID0gZGF0YVtpXVtqXTsKCiAgICAgICAgICBpZiAodiA8IG1pblZhbHVlKSB7CiAgICAgICAgICAgIG1pblZhbHVlID0gdjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIHRoZSBgbWF4VmFsdWVgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlTWF4VmFsdWUoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGxldCBtYXhWYWx1ZSA9IGRhdGFbMF1bMF07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCB2ID0gZGF0YVtpXVtqXTsKCiAgICAgICAgICBpZiAodiA+IG1heFZhbHVlKSB7CiAgICAgICAgICAgIG1heFZhbHVlID0gdjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMubWF4VmFsdWUgPSBtYXhWYWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBoZWlnaHQgdmFsdWUgYXQgYW4gaW5kZXguIERvbid0IGZvcmdldCB0byB1cGRhdGUgbWF4VmFsdWUgYW5kIG1pblZhbHVlIGFmdGVyIHlvdSdyZSBkb25lLgogICAgICovCgoKICAgIHNldEhlaWdodFZhbHVlQXRJbmRleCh4aSwgeWksIHZhbHVlKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGRhdGFbeGldW3lpXSA9IHZhbHVlOyAvLyBJbnZhbGlkYXRlIGNhY2hlCgogICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBmYWxzZSk7CgogICAgICBpZiAoeGkgPiAwKSB7CiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWksIHRydWUpOwogICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSAtIDEsIHlpLCBmYWxzZSk7CiAgICAgIH0KCiAgICAgIGlmICh5aSA+IDApIHsKICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpIC0gMSwgdHJ1ZSk7CiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSAtIDEsIGZhbHNlKTsKICAgICAgfQoKICAgICAgaWYgKHlpID4gMCAmJiB4aSA+IDApIHsKICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSAtIDEsIHRydWUpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBtYXgvbWluIGluIGEgcmVjdGFuZ2xlIGluIHRoZSBtYXRyaXggZGF0YQogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi4KICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdCBhcnJheSwgaWYgaXQgd2FzIHBhc3NlZCBpbi4gTWluaW11bSB3aWxsIGJlIGF0IHBvc2l0aW9uIDAgYW5kIG1heCBhdCAxLgogICAgICovCgoKICAgIGdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBbXTsKICAgICAgfQoKICAgICAgLy8gR2V0IG1heCBhbmQgbWluIG9mIHRoZSBkYXRhCiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7IC8vIFNldCBmaXJzdCB2YWx1ZQoKICAgICAgbGV0IG1heCA9IHRoaXMubWluVmFsdWU7CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPD0gaU1heFg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKSB7CiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBkYXRhW2ldW2pdOwoKICAgICAgICAgIGlmIChoZWlnaHQgPiBtYXgpIHsKICAgICAgICAgICAgbWF4ID0gaGVpZ2h0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmVzdWx0WzBdID0gdGhpcy5taW5WYWx1ZTsKICAgICAgcmVzdWx0WzFdID0gbWF4OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGluZGV4IG9mIGEgbG9jYWwgcG9zaXRpb24gb24gdGhlIGhlaWdodGZpZWxkLiBUaGUgaW5kZXhlcyBpbmRpY2F0ZSB0aGUgcmVjdGFuZ2xlcywgc28gaWYgeW91ciB0ZXJyYWluIGlzIG1hZGUgb2YgTiB4IE4gaGVpZ2h0IGRhdGEgcG9pbnRzLCB5b3Ugd2lsbCBoYXZlIHJlY3RhbmdsZSBpbmRleGVzIHJhbmdpbmcgZnJvbSAwIHRvIE4tMS4KICAgICAqIEBwYXJhbSByZXN1bHQgVHdvLWVsZW1lbnQgYXJyYXkKICAgICAqIEBwYXJhbSBjbGFtcCBJZiB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIGNsYW1wZWQgdG8gdGhlIGhlaWdodGZpZWxkIGVkZ2UuCiAgICAgKi8KCgogICAgZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIHJlc3VsdCwgY2xhbXApIHsKICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0CiAgICAgIGNvbnN0IHcgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBsZXQgeGkgPSBNYXRoLmZsb29yKHggLyB3KTsKICAgICAgbGV0IHlpID0gTWF0aC5mbG9vcih5IC8gdyk7CiAgICAgIHJlc3VsdFswXSA9IHhpOwogICAgICByZXN1bHRbMV0gPSB5aTsKCiAgICAgIGlmIChjbGFtcCkgewogICAgICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzCiAgICAgICAgaWYgKHhpIDwgMCkgewogICAgICAgICAgeGkgPSAwOwogICAgICAgIH0KCiAgICAgICAgaWYgKHlpIDwgMCkgewogICAgICAgICAgeWkgPSAwOwogICAgICAgIH0KCiAgICAgICAgaWYgKHhpID49IGRhdGEubGVuZ3RoIC0gMSkgewogICAgICAgICAgeGkgPSBkYXRhLmxlbmd0aCAtIDE7CiAgICAgICAgfQoKICAgICAgICBpZiAoeWkgPj0gZGF0YVswXS5sZW5ndGggLSAxKSB7CiAgICAgICAgICB5aSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsKICAgICAgICB9CiAgICAgIH0gLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpbgoKCiAgICAgIGlmICh4aSA8IDAgfHwgeWkgPCAwIHx8IHhpID49IGRhdGEubGVuZ3RoIC0gMSB8fCB5aSA+PSBkYXRhWzBdLmxlbmd0aCAtIDEpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGdldFRyaWFuZ2xlQXQoeCwgeSwgZWRnZUNsYW1wLCBhLCBiLCBjKSB7CiAgICAgIGNvbnN0IGlkeCA9IGdldEhlaWdodEF0X2lkeDsKICAgICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApOwogICAgICBsZXQgeGkgPSBpZHhbMF07CiAgICAgIGxldCB5aSA9IGlkeFsxXTsKICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTsKCiAgICAgIGlmIChlZGdlQ2xhbXApIHsKICAgICAgICB4aSA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeGkpKTsKICAgICAgICB5aSA9IE1hdGgubWluKGRhdGFbMF0ubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeWkpKTsKICAgICAgfQoKICAgICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBsb3dlckRpc3QyID0gKHggLyBlbGVtZW50U2l6ZSAtIHhpKSAqKiAyICsgKHkgLyBlbGVtZW50U2l6ZSAtIHlpKSAqKiAyOwogICAgICBjb25zdCB1cHBlckRpc3QyID0gKHggLyBlbGVtZW50U2l6ZSAtICh4aSArIDEpKSAqKiAyICsgKHkgLyBlbGVtZW50U2l6ZSAtICh5aSArIDEpKSAqKiAyOwogICAgICBjb25zdCB1cHBlciA9IGxvd2VyRGlzdDIgPiB1cHBlckRpc3QyOwogICAgICB0aGlzLmdldFRyaWFuZ2xlKHhpLCB5aSwgdXBwZXIsIGEsIGIsIGMpOwogICAgICByZXR1cm4gdXBwZXI7CiAgICB9CgogICAgZ2V0Tm9ybWFsQXQoeCwgeSwgZWRnZUNsYW1wLCByZXN1bHQpIHsKICAgICAgY29uc3QgYSA9IGdldE5vcm1hbEF0X2E7CiAgICAgIGNvbnN0IGIgPSBnZXROb3JtYWxBdF9iOwogICAgICBjb25zdCBjID0gZ2V0Tm9ybWFsQXRfYzsKICAgICAgY29uc3QgZTAgPSBnZXROb3JtYWxBdF9lMDsKICAgICAgY29uc3QgZTEgPSBnZXROb3JtYWxBdF9lMTsKICAgICAgdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7CiAgICAgIGIudnN1YihhLCBlMCk7CiAgICAgIGMudnN1YihhLCBlMSk7CiAgICAgIGUwLmNyb3NzKGUxLCByZXN1bHQpOwogICAgICByZXN1bHQubm9ybWFsaXplKCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBBQUJCIG9mIGEgc3F1YXJlIGluIHRoZSBoZWlnaHRmaWVsZAogICAgICogQHBhcmFtIHhpCiAgICAgKiBAcGFyYW0geWkKICAgICAqIEBwYXJhbSByZXN1bHQKICAgICAqLwoKCiAgICBnZXRBYWJiQXRJbmRleCh4aSwgeWksIF9yZWYpIHsKICAgICAgbGV0IHsKICAgICAgICBsb3dlckJvdW5kLAogICAgICAgIHVwcGVyQm91bmQKICAgICAgfSA9IF9yZWY7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTsKICAgICAgbG93ZXJCb3VuZC5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWldKTsKICAgICAgdXBwZXJCb3VuZC5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpICsgMV0pOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGhlaWdodCBpbiB0aGUgaGVpZ2h0ZmllbGQgYXQgYSBnaXZlbiBwb3NpdGlvbgogICAgICovCgoKICAgIGdldEhlaWdodEF0KHgsIHksIGVkZ2VDbGFtcCkgewogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBjb25zdCBhID0gZ2V0SGVpZ2h0QXRfYTsKICAgICAgY29uc3QgYiA9IGdldEhlaWdodEF0X2I7CiAgICAgIGNvbnN0IGMgPSBnZXRIZWlnaHRBdF9jOwogICAgICBjb25zdCBpZHggPSBnZXRIZWlnaHRBdF9pZHg7CiAgICAgIHRoaXMuZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIGlkeCwgZWRnZUNsYW1wKTsKICAgICAgbGV0IHhpID0gaWR4WzBdOwogICAgICBsZXQgeWkgPSBpZHhbMV07CgogICAgICBpZiAoZWRnZUNsYW1wKSB7CiAgICAgICAgeGkgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHhpKSk7CiAgICAgICAgeWkgPSBNYXRoLm1pbihkYXRhWzBdLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHlpKSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHVwcGVyID0gdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7CiAgICAgIGJhcnljZW50cmljV2VpZ2h0cyh4LCB5LCBhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBnZXRIZWlnaHRBdF93ZWlnaHRzKTsKICAgICAgY29uc3QgdyA9IGdldEhlaWdodEF0X3dlaWdodHM7CgogICAgICBpZiAodXBwZXIpIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICByZXR1cm4gZGF0YVt4aSArIDFdW3lpICsgMV0gKiB3LnggKyBkYXRhW3hpXVt5aSArIDFdICogdy55ICsgZGF0YVt4aSArIDFdW3lpXSAqIHcuejsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICByZXR1cm4gZGF0YVt4aV1beWldICogdy54ICsgZGF0YVt4aSArIDFdW3lpXSAqIHcueSArIGRhdGFbeGldW3lpICsgMV0gKiB3Lno7CiAgICAgIH0KICAgIH0KCiAgICBnZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICByZXR1cm4gYCR7eGl9XyR7eWl9XyR7Z2V0VXBwZXJUcmlhbmdsZSA/IDEgOiAwfWA7CiAgICB9CgogICAgZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKSB7CiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpXTsKICAgIH0KCiAgICBzZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUsIGNvbnZleCwgb2Zmc2V0KSB7CiAgICAgIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldID0gewogICAgICAgIGNvbnZleCwKICAgICAgICBvZmZzZXQKICAgICAgfTsKICAgIH0KCiAgICBjbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICBkZWxldGUgdGhpcy5fY2FjaGVkUGlsbGFyc1t0aGlzLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKV07CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIHRyaWFuZ2xlIGZyb20gdGhlIGhlaWdodGZpZWxkCiAgICAgKi8KCgogICAgZ2V0VHJpYW5nbGUoeGksIHlpLCB1cHBlciwgYSwgYiwgYykgewogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7CgogICAgICBpZiAodXBwZXIpIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICBhLnNldCgoeGkgKyAxKSAqIGVsZW1lbnRTaXplLCAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpICsgMV1beWkgKyAxXSk7CiAgICAgICAgYi5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWkgKyAxXSk7CiAgICAgICAgYy5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpXSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzCiAgICAgICAgYS5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWldKTsKICAgICAgICBiLnNldCgoeGkgKyAxKSAqIGVsZW1lbnRTaXplLCB5aSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpICsgMV1beWldKTsKICAgICAgICBjLnNldCh4aSAqIGVsZW1lbnRTaXplLCAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpXVt5aSArIDFdKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXQgYSB0cmlhbmdsZSBpbiB0aGUgdGVycmFpbiBpbiB0aGUgZm9ybSBvZiBhIHRyaWFuZ3VsYXIgY29udmV4IHNoYXBlLgogICAgICovCgoKICAgIGdldENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICBsZXQgcmVzdWx0ID0gdGhpcy5waWxsYXJDb252ZXg7CiAgICAgIGxldCBvZmZzZXRSZXN1bHQgPSB0aGlzLnBpbGxhck9mZnNldDsKCiAgICAgIGlmICh0aGlzLmNhY2hlRW5hYmxlZCkgewogICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSk7CgogICAgICAgIGlmIChkYXRhKSB7CiAgICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IGRhdGEuY29udmV4OwogICAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBkYXRhLm9mZnNldDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIHJlc3VsdCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAgICAgb2Zmc2V0UmVzdWx0ID0gbmV3IFZlYzMoKTsKICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IHJlc3VsdDsKICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IG9mZnNldFJlc3VsdDsKICAgICAgfQoKICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTsKICAgICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBmYWNlcyA9IHJlc3VsdC5mYWNlczsgLy8gUmV1c2UgdmVydHMgaWYgcG9zc2libGUKCiAgICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHsKICAgICAgICBpZiAoIXJlc3VsdC52ZXJ0aWNlc1tpXSkgewogICAgICAgICAgcmVzdWx0LnZlcnRpY2VzW2ldID0gbmV3IFZlYzMoKTsKICAgICAgICB9CiAgICAgIH0gLy8gUmV1c2UgZmFjZXMgaWYgcG9zc2libGUKCgogICAgICBmYWNlcy5sZW5ndGggPSA1OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHsKICAgICAgICBpZiAoIWZhY2VzW2ldKSB7CiAgICAgICAgICBmYWNlc1tpXSA9IFtdOwogICAgICAgIH0KICAgICAgfQoKICAgICAgY29uc3QgdmVydHMgPSByZXN1bHQudmVydGljZXM7CiAgICAgIGNvbnN0IGggPSAoTWF0aC5taW4oZGF0YVt4aV1beWldLCBkYXRhW3hpICsgMV1beWldLCBkYXRhW3hpXVt5aSArIDFdLCBkYXRhW3hpICsgMV1beWkgKyAxXSkgLSB0aGlzLm1pblZhbHVlKSAvIDIgKyB0aGlzLm1pblZhbHVlOwoKICAgICAgaWYgKCFnZXRVcHBlclRyaWFuZ2xlKSB7CiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lCiAgICAgICAgb2Zmc2V0UmVzdWx0LnNldCgoeGkgKyAwLjI1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlCiAgICAgICAgKHlpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSwgaCAvLyB2ZXJ0aWNhbCBjZW50ZXIKICAgICAgICApOyAvLyBUb3AgdHJpYW5nbGUgdmVydHMKCiAgICAgICAgdmVydHNbMF0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIC0wLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGldW3lpXSAtIGgpOwogICAgICAgIHZlcnRzWzFdLnNldCgwLjc1ICogZWxlbWVudFNpemUsIC0wLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aV0gLSBoKTsKICAgICAgICB2ZXJ0c1syXS5zZXQoLTAuMjUgKiBlbGVtZW50U2l6ZSwgMC43NSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpXVt5aSArIDFdIC0gaCk7IC8vIGJvdHRvbSB0cmlhbmdsZSB2ZXJ0cwoKICAgICAgICB2ZXJ0c1szXS5zZXQoLTAuMjUgKiBlbGVtZW50U2l6ZSwgLTAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNF0uc2V0KDAuNzUgKiBlbGVtZW50U2l6ZSwgLTAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNV0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIDAuNzUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7IC8vIHRvcCB0cmlhbmdsZQoKICAgICAgICBmYWNlc1swXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMF1bMV0gPSAxOwogICAgICAgIGZhY2VzWzBdWzJdID0gMjsgLy8gYm90dG9tIHRyaWFuZ2xlCgogICAgICAgIGZhY2VzWzFdWzBdID0gNTsKICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbMV1bMl0gPSAzOyAvLyAteCBmYWNpbmcgcXVhZAoKICAgICAgICBmYWNlc1syXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMl1bMV0gPSAyOwogICAgICAgIGZhY2VzWzJdWzJdID0gNTsKICAgICAgICBmYWNlc1syXVszXSA9IDM7IC8vIC15IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzNdWzBdID0gMTsKICAgICAgICBmYWNlc1szXVsxXSA9IDA7CiAgICAgICAgZmFjZXNbM11bMl0gPSAzOwogICAgICAgIGZhY2VzWzNdWzNdID0gNDsgLy8gK3h5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzRdWzBdID0gNDsKICAgICAgICBmYWNlc1s0XVsxXSA9IDU7CiAgICAgICAgZmFjZXNbNF1bMl0gPSAyOwogICAgICAgIGZhY2VzWzRdWzNdID0gMTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBDZW50ZXIgb2YgdGhlIHRyaWFuZ2xlIHBpbGxhciAtIGFsbCBwb2x5Z29ucyBhcmUgZ2l2ZW4gcmVsYXRpdmUgdG8gdGhpcyBvbmUKICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KCh4aSArIDAuNzUpICogZWxlbWVudFNpemUsIC8vIHNvcnQgb2YgY2VudGVyIG9mIGEgdHJpYW5nbGUKICAgICAgICAoeWkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCBoIC8vIHZlcnRpY2FsIGNlbnRlcgogICAgICAgICk7IC8vIFRvcCB0cmlhbmdsZSB2ZXJ0cwoKICAgICAgICB2ZXJ0c1swXS5zZXQoMC4yNSAqIGVsZW1lbnRTaXplLCAwLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aSArIDFdIC0gaCk7CiAgICAgICAgdmVydHNbMV0uc2V0KC0wLjc1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWkgKyAxXSAtIGgpOwogICAgICAgIHZlcnRzWzJdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIC0wLjc1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aV0gLSBoKTsgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzCgogICAgICAgIHZlcnRzWzNdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNF0uc2V0KC0wLjc1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNV0uc2V0KDAuMjUgKiBlbGVtZW50U2l6ZSwgLTAuNzUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7IC8vIFRvcCB0cmlhbmdsZQoKICAgICAgICBmYWNlc1swXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMF1bMV0gPSAxOwogICAgICAgIGZhY2VzWzBdWzJdID0gMjsgLy8gYm90dG9tIHRyaWFuZ2xlCgogICAgICAgIGZhY2VzWzFdWzBdID0gNTsKICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbMV1bMl0gPSAzOyAvLyAreCBmYWNpbmcgcXVhZAoKICAgICAgICBmYWNlc1syXVswXSA9IDI7CiAgICAgICAgZmFjZXNbMl1bMV0gPSA1OwogICAgICAgIGZhY2VzWzJdWzJdID0gMzsKICAgICAgICBmYWNlc1syXVszXSA9IDA7IC8vICt5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzNdWzBdID0gMzsKICAgICAgICBmYWNlc1szXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbM11bMl0gPSAxOwogICAgICAgIGZhY2VzWzNdWzNdID0gMDsgLy8gLXh5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzRdWzBdID0gMTsKICAgICAgICBmYWNlc1s0XVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbNF1bMl0gPSA1OwogICAgICAgIGZhY2VzWzRdWzNdID0gMjsKICAgICAgfQoKICAgICAgcmVzdWx0LmNvbXB1dGVOb3JtYWxzKCk7CiAgICAgIHJlc3VsdC5jb21wdXRlRWRnZXMoKTsKICAgICAgcmVzdWx0LnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICAgIHRoaXMuc2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCByZXN1bHQsIG9mZnNldFJlc3VsdCk7CiAgICB9CgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQuc2V0KDAsIDAsIDApOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuICgvLyBUaGUgdGVycmFpbiBpcyBpbmZpbml0ZQogICAgICAgIE51bWJlci5NQVhfVkFMVUUKICAgICAgKTsKICAgIH0KCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICAvKiogQFRPRE8gZG8gaXQgcHJvcGVybHkgKi8KICAgICAgbWluLnNldCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTsKICAgICAgbWF4LnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTsKICAgIH0KCiAgICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHsKICAgICAgLy8gVXNlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG1pbi9tYXggdmFsdWVzCiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IHMgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gbmV3IFZlYzMoZGF0YS5sZW5ndGggKiBzLCBkYXRhWzBdLmxlbmd0aCAqIHMsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLCBNYXRoLmFicyh0aGlzLm1pblZhbHVlKSkpLmxlbmd0aCgpOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgdmFsdWVzIGZyb20gYW4gaW1hZ2UuIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyLgogICAgICovCgoKICAgIHNldEhlaWdodHNGcm9tSW1hZ2UoaW1hZ2UsIHNjYWxlKSB7CiAgICAgIGNvbnN0IHsKICAgICAgICB4LAogICAgICAgIHosCiAgICAgICAgeQogICAgICB9ID0gc2NhbGU7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOwogICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDsKICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDsKICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7CiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpOwogICAgICBjb25zdCBtYXRyaXggPSB0aGlzLmRhdGE7CiAgICAgIG1hdHJpeC5sZW5ndGggPSAwOwogICAgICB0aGlzLmVsZW1lbnRTaXplID0gTWF0aC5hYnMoeCkgLyBpbWFnZURhdGEud2lkdGg7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlRGF0YS5oZWlnaHQ7IGkrKykgewogICAgICAgIGNvbnN0IHJvdyA9IFtdOwoKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGltYWdlRGF0YS53aWR0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCBhID0gaW1hZ2VEYXRhLmRhdGFbKGkgKiBpbWFnZURhdGEuaGVpZ2h0ICsgaikgKiA0XTsKICAgICAgICAgIGNvbnN0IGIgPSBpbWFnZURhdGEuZGF0YVsoaSAqIGltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAxXTsKICAgICAgICAgIGNvbnN0IGMgPSBpbWFnZURhdGEuZGF0YVsoaSAqIGltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAyXTsKICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChhICsgYiArIGMpIC8gNCAvIDI1NSAqIHo7CgogICAgICAgICAgaWYgKHggPCAwKSB7CiAgICAgICAgICAgIHJvdy5wdXNoKGhlaWdodCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByb3cudW5zaGlmdChoZWlnaHQpOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPCAwKSB7CiAgICAgICAgICBtYXRyaXgudW5zaGlmdChyb3cpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtYXRyaXgucHVzaChyb3cpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy51cGRhdGVNYXhWYWx1ZSgpOwogICAgICB0aGlzLnVwZGF0ZU1pblZhbHVlKCk7CiAgICAgIHRoaXMudXBkYXRlKCk7CiAgICB9CgogIH0KICBjb25zdCBnZXRIZWlnaHRBdF9pZHggPSBbXTsKICBjb25zdCBnZXRIZWlnaHRBdF93ZWlnaHRzID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9hID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9iID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9jID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9hID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9iID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9jID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9lMCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZ2V0Tm9ybWFsQXRfZTEgPSBuZXcgVmVjMygpOyAvLyBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JhcnljZW50cmljX2Nvb3JkaW5hdGVfc3lzdGVtCgogIGZ1bmN0aW9uIGJhcnljZW50cmljV2VpZ2h0cyh4LCB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCByZXN1bHQpIHsKICAgIHJlc3VsdC54ID0gKChieSAtIGN5KSAqICh4IC0gY3gpICsgKGN4IC0gYngpICogKHkgLSBjeSkpIC8gKChieSAtIGN5KSAqIChheCAtIGN4KSArIChjeCAtIGJ4KSAqIChheSAtIGN5KSk7CiAgICByZXN1bHQueSA9ICgoY3kgLSBheSkgKiAoeCAtIGN4KSArIChheCAtIGN4KSAqICh5IC0gY3kpKSAvICgoYnkgLSBjeSkgKiAoYXggLSBjeCkgKyAoY3ggLSBieCkgKiAoYXkgLSBjeSkpOwogICAgcmVzdWx0LnogPSAxIC0gcmVzdWx0LnggLSByZXN1bHQueTsKICB9CgogIC8qKgogICAqIE9jdHJlZU5vZGUKICAgKi8KICBjbGFzcyBPY3RyZWVOb2RlIHsKICAgIC8qKiBUaGUgcm9vdCBub2RlICovCgogICAgLyoqIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZSAqLwoKICAgIC8qKiBDb250YWluZWQgZGF0YSBhdCB0aGUgY3VycmVudCBub2RlIGxldmVsICovCgogICAgLyoqIENoaWxkcmVuIHRvIHRoaXMgbm9kZSAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDsKICAgICAgdGhpcy5hYWJiID0gb3B0aW9ucy5hYWJiID8gb3B0aW9ucy5hYWJiLmNsb25lKCkgOiBuZXcgQUFCQigpOwogICAgICB0aGlzLmRhdGEgPSBbXTsKICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdOwogICAgfQogICAgLyoqCiAgICAgKiByZXNldAogICAgICovCgoKICAgIHJlc2V0KCkgewogICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBJbnNlcnQgZGF0YSBpbnRvIHRoaXMgbm9kZQogICAgICogQHJldHVybiBUcnVlIGlmIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZQogICAgICovCgoKICAgIGluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwpIHsKICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsKICAgICAgICBsZXZlbCA9IDA7CiAgICAgIH0KCiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5kYXRhOyAvLyBJZ25vcmUgb2JqZWN0cyB0aGF0IGRvIG5vdCBiZWxvbmcgaW4gdGhpcyBub2RlCgogICAgICBpZiAoIXRoaXMuYWFiYi5jb250YWlucyhhYWJiKSkgewogICAgICAgIHJldHVybiBmYWxzZTsgLy8gb2JqZWN0IGNhbm5vdCBiZSBhZGRlZAogICAgICB9CgogICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47CiAgICAgIGNvbnN0IG1heERlcHRoID0gdGhpcy5tYXhEZXB0aCB8fCB0aGlzLnJvb3QubWF4RGVwdGg7CgogICAgICBpZiAobGV2ZWwgPCBtYXhEZXB0aCkgewogICAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0CiAgICAgICAgbGV0IHN1YmRpdmlkZWQgPSBmYWxzZTsKCiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKCk7CiAgICAgICAgICBzdWJkaXZpZGVkID0gdHJ1ZTsKICAgICAgICB9IC8vIGFkZCB0byB3aGljaGV2ZXIgbm9kZSB3aWxsIGFjY2VwdCBpdAoKCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwgKyAxKSkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChzdWJkaXZpZGVkKSB7CiAgICAgICAgICAvLyBObyBjaGlsZHJlbiBhY2NlcHRlZCEgTWlnaHQgYXMgd2VsbCBqdXN0IHJlbW92ZSBlbSBzaW5jZSB0aGV5IGNvbnRhaW4gbm9uZQogICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgIH0gLy8gVG9vIGRlZXAsIG9yIGNoaWxkcmVuIGRpZG50IHdhbnQgaXQuIGFkZCBpdCBpbiBjdXJyZW50IG5vZGUKCgogICAgICBub2RlRGF0YS5wdXNoKGVsZW1lbnREYXRhKTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZSA4IGVxdWFsbHkgc2l6ZWQgY2hpbGRyZW4gbm9kZXMgYW5kIHB1dCB0aGVtIGluIHRoZSBgY2hpbGRyZW5gIGFycmF5LgogICAgICovCgoKICAgIHN1YmRpdmlkZSgpIHsKICAgICAgY29uc3QgYWFiYiA9IHRoaXMuYWFiYjsKICAgICAgY29uc3QgbCA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IGFhYmIudXBwZXJCb3VuZDsKICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuOwogICAgICBjaGlsZHJlbi5wdXNoKG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygwLCAwLCAwKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMSwgMCwgMCkKICAgICAgICB9KQogICAgICB9KSwgbmV3IE9jdHJlZU5vZGUoewogICAgICAgIGFhYmI6IG5ldyBBQUJCKHsKICAgICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsIDEsIDApCiAgICAgICAgfSkKICAgICAgfSksIG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygxLCAxLCAxKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwgMSwgMSkKICAgICAgICB9KQogICAgICB9KSwgbmV3IE9jdHJlZU5vZGUoewogICAgICAgIGFhYmI6IG5ldyBBQUJCKHsKICAgICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsIDAsIDEpCiAgICAgICAgfSkKICAgICAgfSksIG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygxLCAwLCAxKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwgMSwgMCkKICAgICAgICB9KQogICAgICB9KSk7CiAgICAgIHUudnN1YihsLCBoYWxmRGlhZ29uYWwpOwogICAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpOwogICAgICBjb25zdCByb290ID0gdGhpcy5yb290IHx8IHRoaXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gODsgaSsrKSB7CiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gU2V0IGN1cnJlbnQgbm9kZSBhcyByb290CgogICAgICAgIGNoaWxkLnJvb3QgPSByb290OyAvLyBDb21wdXRlIGJvdW5kcwoKICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gY2hpbGQuYWFiYi5sb3dlckJvdW5kOwogICAgICAgIGxvd2VyQm91bmQueCAqPSBoYWxmRGlhZ29uYWwueDsKICAgICAgICBsb3dlckJvdW5kLnkgKj0gaGFsZkRpYWdvbmFsLnk7CiAgICAgICAgbG93ZXJCb3VuZC56ICo9IGhhbGZEaWFnb25hbC56OwogICAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTsgLy8gVXBwZXIgYm91bmQgaXMgYWx3YXlzIGxvd2VyIGJvdW5kICsgaGFsZkRpYWdvbmFsCgogICAgICAgIGxvd2VyQm91bmQudmFkZChoYWxmRGlhZ29uYWwsIGNoaWxkLmFhYmIudXBwZXJCb3VuZCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSB3aXRoaW4gYW4gQUFCQgogICAgICogQHJldHVybiBUaGUgInJlc3VsdCIgb2JqZWN0CiAgICAgKi8KCgogICAgYWFiYlF1ZXJ5KGFhYmIsIHJlc3VsdCkgewogICAgICB0aGlzLmRhdGE7IC8vIGFib3J0IGlmIHRoZSByYW5nZSBkb2VzIG5vdCBpbnRlcnNlY3QgdGhpcyBub2RlCiAgICAgIC8vIGlmICghdGhpcy5hYWJiLm92ZXJsYXBzKGFhYmIpKXsKICAgICAgLy8gICAgIHJldHVybiByZXN1bHQ7CiAgICAgIC8vIH0KICAgICAgLy8gQWRkIG9iamVjdHMgYXQgdGhpcyBsZXZlbAogICAgICAvLyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGVEYXRhKTsKICAgICAgLy8gQWRkIGNoaWxkIGRhdGEKICAgICAgLy8gQHRvZG8gdW53cmFwIHJlY3Vyc2lvbiBpbnRvIGEgcXVldWUgLyBsb29wLCB0aGF0J3MgZmFzdGVyIGluIEpTCgogICAgICB0aGlzLmNoaWxkcmVuOyAvLyBmb3IgKGxldCBpID0gMCwgTiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICE9PSBOOyBpKyspIHsKICAgICAgLy8gICAgIGNoaWxkcmVuW2ldLmFhYmJRdWVyeShhYWJiLCByZXN1bHQpOwogICAgICAvLyB9CgogICAgICBjb25zdCBxdWV1ZSA9IFt0aGlzXTsKCiAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHsKICAgICAgICBjb25zdCBub2RlID0gcXVldWUucG9wKCk7CgogICAgICAgIGlmIChub2RlLmFhYmIub3ZlcmxhcHMoYWFiYikpIHsKICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5kYXRhKTsKICAgICAgICB9CgogICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHF1ZXVlLCBub2RlLmNoaWxkcmVuKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSBpbnRlcnNlY3RlZCBieSBhIHJheS4KICAgICAqIEByZXR1cm4gVGhlICJyZXN1bHQiIG9iamVjdAogICAgICovCgoKICAgIHJheVF1ZXJ5KHJheSwgdHJlZVRyYW5zZm9ybSwgcmVzdWx0KSB7CiAgICAgIC8vIFVzZSBhYWJiIHF1ZXJ5IGZvciBub3cuCgogICAgICAvKiogQHRvZG8gaW1wbGVtZW50IHJlYWwgcmF5IHF1ZXJ5IHdoaWNoIG5lZWRzIGxlc3MgbG9va3VwcyAqLwogICAgICByYXkuZ2V0QUFCQih0bXBBQUJCKTsKICAgICAgdG1wQUFCQi50b0xvY2FsRnJhbWUodHJlZVRyYW5zZm9ybSwgdG1wQUFCQik7CiAgICAgIHRoaXMuYWFiYlF1ZXJ5KHRtcEFBQkIsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHJlbW92ZUVtcHR5Tm9kZXMKICAgICAqLwoKCiAgICByZW1vdmVFbXB0eU5vZGVzKCkgewogICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVtb3ZlRW1wdHlOb2RlcygpOwoKICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW5baV0uY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLmNoaWxkcmVuW2ldLmRhdGEubGVuZ3RoKSB7CiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpLCAxKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgfQogIC8qKgogICAqIE9jdHJlZQogICAqLwoKCiAgY2xhc3MgT2N0cmVlIGV4dGVuZHMgT2N0cmVlTm9kZSB7CiAgICAvKioKICAgICAqIE1heGltdW0gc3ViZGl2aXNpb24gZGVwdGgKICAgICAqIEBkZWZhdWx0IDgKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGFhYmIgVGhlIHRvdGFsIEFBQkIgb2YgdGhlIHRyZWUKICAgICAqLwogICAgY29uc3RydWN0b3IoYWFiYiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBzdXBlcih7CiAgICAgICAgcm9vdDogbnVsbCwKICAgICAgICBhYWJiCiAgICAgIH0pOwogICAgICB0aGlzLm1heERlcHRoID0gdHlwZW9mIG9wdGlvbnMubWF4RGVwdGggIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhEZXB0aCA6IDg7CiAgICB9CgogIH0KICBjb25zdCBoYWxmRGlhZ29uYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcEFBQkIgPSBuZXcgQUFCQigpOwoKICAvKioKICAgKiBUcmltZXNoLgogICAqIEBleGFtcGxlCiAgICogICAgIC8vIEhvdyB0byBtYWtlIGEgbWVzaCB3aXRoIGEgc2luZ2xlIHRyaWFuZ2xlCiAgICogICAgIGNvbnN0IHZlcnRpY2VzID0gWwogICAqICAgICAgICAgMCwgMCwgMCwgLy8gdmVydGV4IDAKICAgKiAgICAgICAgIDEsIDAsIDAsIC8vIHZlcnRleCAxCiAgICogICAgICAgICAwLCAxLCAwICAvLyB2ZXJ0ZXggMgogICAqICAgICBdCiAgICogICAgIGNvbnN0IGluZGljZXMgPSBbCiAgICogICAgICAgICAwLCAxLCAyICAvLyB0cmlhbmdsZSAwCiAgICogICAgIF0KICAgKiAgICAgY29uc3QgdHJpbWVzaFNoYXBlID0gbmV3IENBTk5PTi5UcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKQogICAqLwogIGNsYXNzIFRyaW1lc2ggZXh0ZW5kcyBTaGFwZSB7CiAgICAvKioKICAgICAqIHZlcnRpY2VzCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFycmF5IG9mIGludGVnZXJzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggdHJpYW5nbGUgY29uc2lzdHMgb2YuIFRoZSBsZW5ndGggb2YgdGhpcyBhcnJheSBpcyB0aHVzIDMgdGltZXMgdGhlIG51bWJlciBvZiB0cmlhbmdsZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBub3JtYWxzIGRhdGEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBsb2NhbCBBQUJCIG9mIHRoZSBtZXNoLgogICAgICovCgogICAgLyoqCiAgICAgKiBSZWZlcmVuY2VzIHRvIHZlcnRleCBwYWlycywgbWFraW5nIHVwIGFsbCB1bmlxdWUgZWRnZXMgaW4gdGhlIHRyaW1lc2guCiAgICAgKi8KCiAgICAvKioKICAgICAqIExvY2FsIHNjYWxpbmcgb2YgdGhlIG1lc2guIFVzZSAuc2V0U2NhbGUoKSB0byBzZXQgaXQuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBpbmRleGVkIHRyaWFuZ2xlcy4gVXNlIC51cGRhdGVUcmVlKCkgdG8gdXBkYXRlIGl0LgogICAgICovCiAgICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgaW5kaWNlcykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuVFJJTUVTSAogICAgICB9KTsKICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpOwogICAgICB0aGlzLmluZGljZXMgPSBuZXcgSW50MTZBcnJheShpbmRpY2VzKTsKICAgICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7CiAgICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7CiAgICAgIHRoaXMuZWRnZXMgPSBudWxsOwogICAgICB0aGlzLnNjYWxlID0gbmV3IFZlYzMoMSwgMSwgMSk7CiAgICAgIHRoaXMudHJlZSA9IG5ldyBPY3RyZWUoKTsKICAgICAgdGhpcy51cGRhdGVFZGdlcygpOwogICAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTsKICAgICAgdGhpcy51cGRhdGVBQUJCKCk7CiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTsKICAgICAgdGhpcy51cGRhdGVUcmVlKCk7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZVRyZWUKICAgICAqLwoKCiAgICB1cGRhdGVUcmVlKCkgewogICAgICBjb25zdCB0cmVlID0gdGhpcy50cmVlOwogICAgICB0cmVlLnJlc2V0KCk7CiAgICAgIHRyZWUuYWFiYi5jb3B5KHRoaXMuYWFiYik7CiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTsgLy8gVGhlIGxvY2FsIG1lc2ggQUFCQiBpcyBzY2FsZWQsIGJ1dCB0aGUgb2N0cmVlIEFBQkIgc2hvdWxkIGJlIHVuc2NhbGVkCgogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54OwogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55OwogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC56ICo9IDEgLyBzY2FsZS56OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC56ICo9IDEgLyBzY2FsZS56OyAvLyBJbnNlcnQgYWxsIHRyaWFuZ2xlcwoKICAgICAgY29uc3QgdHJpYW5nbGVBQUJCID0gbmV3IEFBQkIoKTsKICAgICAgY29uc3QgYSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGIgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBjID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcG9pbnRzID0gW2EsIGIsIGNdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgLy90aGlzLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgYSwgYiwgYyk7CiAgICAgICAgLy8gR2V0IHVuc2NhbGVkIHRyaWFuZ2xlIHZlcnRzCiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKCiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7CgogICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTsKCiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpOwoKICAgICAgICB0cmlhbmdsZUFBQkIuc2V0RnJvbVBvaW50cyhwb2ludHMpOwogICAgICAgIHRyZWUuaW5zZXJ0KHRyaWFuZ2xlQUFCQiwgaSk7CiAgICAgIH0KCiAgICAgIHRyZWUucmVtb3ZlRW1wdHlOb2RlcygpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdHJpYW5nbGVzIGluIGEgbG9jYWwgQUFCQiBmcm9tIHRoZSB0cmltZXNoLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSBvZiBpbnRlZ2VycywgcmVmZXJlbmNpbmcgdGhlIHF1ZXJpZWQgdHJpYW5nbGVzLgogICAgICovCgoKICAgIGdldFRyaWFuZ2xlc0luQUFCQihhYWJiLCByZXN1bHQpIHsKICAgICAgdW5zY2FsZWRBQUJCLmNvcHkoYWFiYik7IC8vIFNjYWxlIGl0IHRvIGxvY2FsCgogICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7CiAgICAgIGNvbnN0IGlzeCA9IHNjYWxlLng7CiAgICAgIGNvbnN0IGlzeSA9IHNjYWxlLnk7CiAgICAgIGNvbnN0IGlzeiA9IHNjYWxlLno7CiAgICAgIGNvbnN0IGwgPSB1bnNjYWxlZEFBQkIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IHVuc2NhbGVkQUFCQi51cHBlckJvdW5kOwogICAgICBsLnggLz0gaXN4OwogICAgICBsLnkgLz0gaXN5OwogICAgICBsLnogLz0gaXN6OwogICAgICB1LnggLz0gaXN4OwogICAgICB1LnkgLz0gaXN5OwogICAgICB1LnogLz0gaXN6OwogICAgICByZXR1cm4gdGhpcy50cmVlLmFhYmJRdWVyeSh1bnNjYWxlZEFBQkIsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIHNldFNjYWxlCiAgICAgKi8KCgogICAgc2V0U2NhbGUoc2NhbGUpIHsKICAgICAgY29uc3Qgd2FzVW5pZm9ybSA9IHRoaXMuc2NhbGUueCA9PT0gdGhpcy5zY2FsZS55ICYmIHRoaXMuc2NhbGUueSA9PT0gdGhpcy5zY2FsZS56OwogICAgICBjb25zdCBpc1VuaWZvcm0gPSBzY2FsZS54ID09PSBzY2FsZS55ICYmIHNjYWxlLnkgPT09IHNjYWxlLno7CgogICAgICBpZiAoISh3YXNVbmlmb3JtICYmIGlzVW5pZm9ybSkpIHsKICAgICAgICAvLyBOb24tdW5pZm9ybSBzY2FsaW5nLiBOZWVkIHRvIHVwZGF0ZSBub3JtYWxzLgogICAgICAgIHRoaXMudXBkYXRlTm9ybWFscygpOwogICAgICB9CgogICAgICB0aGlzLnNjYWxlLmNvcHkoc2NhbGUpOwogICAgICB0aGlzLnVwZGF0ZUFBQkIoKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlIHRoZSBub3JtYWxzIG9mIHRoZSBmYWNlcy4gV2lsbCBzYXZlIGluIHRoZSBgLm5vcm1hbHNgIGFycmF5LgogICAgICovCgoKICAgIHVwZGF0ZU5vcm1hbHMoKSB7CiAgICAgIGNvbnN0IG4gPSBjb21wdXRlTm9ybWFsc19uOyAvLyBHZW5lcmF0ZSBub3JtYWxzCgogICAgICBjb25zdCBub3JtYWxzID0gdGhpcy5ub3JtYWxzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKICAgICAgICBjb25zdCBhID0gdGhpcy5pbmRpY2VzW2kzXTsKICAgICAgICBjb25zdCBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV07CiAgICAgICAgY29uc3QgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdOwogICAgICAgIHRoaXMuZ2V0VmVydGV4KGEsIHZhKTsKICAgICAgICB0aGlzLmdldFZlcnRleChiLCB2Yik7CiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYywgdmMpOwogICAgICAgIFRyaW1lc2guY29tcHV0ZU5vcm1hbCh2YiwgdmEsIHZjLCBuKTsKICAgICAgICBub3JtYWxzW2kzXSA9IG4ueDsKICAgICAgICBub3JtYWxzW2kzICsgMV0gPSBuLnk7CiAgICAgICAgbm9ybWFsc1tpMyArIDJdID0gbi56OwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFVwZGF0ZSB0aGUgYC5lZGdlc2AgcHJvcGVydHkKICAgICAqLwoKCiAgICB1cGRhdGVFZGdlcygpIHsKICAgICAgY29uc3QgZWRnZXMgPSB7fTsKCiAgICAgIGNvbnN0IGFkZCA9IChhLCBiKSA9PiB7CiAgICAgICAgY29uc3Qga2V5ID0gYSA8IGIgPyBgJHthfV8ke2J9YCA6IGAke2J9XyR7YX1gOwogICAgICAgIGVkZ2VzW2tleV0gPSB0cnVlOwogICAgICB9OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKICAgICAgICBjb25zdCBhID0gdGhpcy5pbmRpY2VzW2kzXTsKICAgICAgICBjb25zdCBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV07CiAgICAgICAgY29uc3QgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdOwogICAgICAgIGFkZChhLCBiKTsKICAgICAgICBhZGQoYiwgYyk7CiAgICAgICAgYWRkKGMsIGEpOwogICAgICB9CgogICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZWRnZXMpOwogICAgICB0aGlzLmVkZ2VzID0gbmV3IEludDE2QXJyYXkoa2V5cy5sZW5ndGggKiAyKTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGluZGljZXMgPSBrZXlzW2ldLnNwbGl0KCdfJyk7CiAgICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7CiAgICAgICAgdGhpcy5lZGdlc1syICogaSArIDFdID0gcGFyc2VJbnQoaW5kaWNlc1sxXSwgMTApOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBlZGdlIHZlcnRleAogICAgICogQHBhcmFtIGZpcnN0T3JTZWNvbmQgMCBvciAxLCBkZXBlbmRpbmcgb24gd2hpY2ggb25lIG9mIHRoZSB2ZXJ0aWNlcyB5b3UgbmVlZC4KICAgICAqIEBwYXJhbSB2ZXJ0ZXhTdG9yZSBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0CiAgICAgKi8KCgogICAgZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKSB7CiAgICAgIGNvbnN0IHZlcnRleEluZGV4ID0gdGhpcy5lZGdlc1tlZGdlSW5kZXggKiAyICsgKGZpcnN0T3JTZWNvbmQgPyAxIDogMCldOwogICAgICB0aGlzLmdldFZlcnRleCh2ZXJ0ZXhJbmRleCwgdmVydGV4U3RvcmUpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS4KICAgICAqLwoKCiAgICBnZXRFZGdlVmVjdG9yKGVkZ2VJbmRleCwgdmVjdG9yU3RvcmUpIHsKICAgICAgY29uc3QgdmEgPSBnZXRFZGdlVmVjdG9yX3ZhOwogICAgICBjb25zdCB2YiA9IGdldEVkZ2VWZWN0b3JfdmI7CiAgICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDAsIHZhKTsKICAgICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMSwgdmIpOwogICAgICB2Yi52c3ViKHZhLCB2ZWN0b3JTdG9yZSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzCiAgICAgKi8KCgogICAgc3RhdGljIGNvbXB1dGVOb3JtYWwodmEsIHZiLCB2YywgdGFyZ2V0KSB7CiAgICAgIHZiLnZzdWIodmEsIGFiKTsKICAgICAgdmMudnN1Yih2YiwgY2IpOwogICAgICBjYi5jcm9zcyhhYiwgdGFyZ2V0KTsKCiAgICAgIGlmICghdGFyZ2V0LmlzWmVybygpKSB7CiAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCB2ZXJ0ZXggaS4KICAgICAqIEByZXR1cm4gVGhlICJvdXQiIHZlY3RvciBvYmplY3QKICAgICAqLwoKCiAgICBnZXRWZXJ0ZXgoaSwgb3V0KSB7CiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTsKCiAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCk7CgogICAgICBvdXQueCAqPSBzY2FsZS54OwogICAgICBvdXQueSAqPSBzY2FsZS55OwogICAgICBvdXQueiAqPSBzY2FsZS56OwogICAgICByZXR1cm4gb3V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgcmF3IHZlcnRleCBpCiAgICAgKiBAcmV0dXJuIFRoZSAib3V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCkgewogICAgICBjb25zdCBpMyA9IGkgKiAzOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIHJldHVybiBvdXQuc2V0KHZlcnRpY2VzW2kzXSwgdmVydGljZXNbaTMgKyAxXSwgdmVydGljZXNbaTMgKyAyXSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIHZlcnRleCBmcm9tIHRoZSB0cmltZXNoLHRyYW5zZm9ybWVkIGJ5IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgcXVhdGVybmlvbi4KICAgICAqIEByZXR1cm4gVGhlICJvdXQiIHZlY3RvciBvYmplY3QKICAgICAqLwoKCiAgICBnZXRXb3JsZFZlcnRleChpLCBwb3MsIHF1YXQsIG91dCkgewogICAgICB0aGlzLmdldFZlcnRleChpLCBvdXQpOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zLCBxdWF0LCBvdXQsIG91dCk7CiAgICAgIHJldHVybiBvdXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgdGhyZWUgdmVydGljZXMgZm9yIHRyaWFuZ2xlIGkuCiAgICAgKi8KCgogICAgZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCBhLCBiLCBjKSB7CiAgICAgIGNvbnN0IGkzID0gaSAqIDM7CiAgICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpM10sIGEpOwogICAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAxXSwgYik7CiAgICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDJdLCBjKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuCiAgICAgKiBAcmV0dXJuIFRoZSAidGFyZ2V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgZ2V0Tm9ybWFsKGksIHRhcmdldCkgewogICAgICBjb25zdCBpMyA9IGkgKiAzOwogICAgICByZXR1cm4gdGFyZ2V0LnNldCh0aGlzLm5vcm1hbHNbaTNdLCB0aGlzLm5vcm1hbHNbaTMgKyAxXSwgdGhpcy5ub3JtYWxzW2kzICsgMl0pOwogICAgfQogICAgLyoqCiAgICAgKiBAcmV0dXJuIFRoZSAidGFyZ2V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhCiAgICAgIC8vIEV4YWN0IGluZXJ0aWEgY2FsY3VsYXRpb24gaXMgb3ZlcmtpbGwsIGJ1dCBzZWUgaHR0cDovL2dlb21ldHJpY3Rvb2xzLmNvbS9Eb2N1bWVudGF0aW9uL1BvbHloZWRyYWxNYXNzUHJvcGVydGllcy5wZGYgZm9yIHRoZSBjb3JyZWN0IHdheSB0byBkbyBpdAogICAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmIpOwogICAgICBjb25zdCB4ID0gY2xpX2FhYmIudXBwZXJCb3VuZC54IC0gY2xpX2FhYmIubG93ZXJCb3VuZC54OwogICAgICBjb25zdCB5ID0gY2xpX2FhYmIudXBwZXJCb3VuZC55IC0gY2xpX2FhYmIubG93ZXJCb3VuZC55OwogICAgICBjb25zdCB6ID0gY2xpX2FhYmIudXBwZXJCb3VuZC56IC0gY2xpX2FhYmIubG93ZXJCb3VuZC56OwogICAgICByZXR1cm4gdGFyZ2V0LnNldCgxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHogKiAyICogeiksIDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB4ICogMiAqIHggKyAyICogeiAqIDIgKiB6KSwgMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIHkgKiAyICogeSArIDIgKiB4ICogMiAqIHgpKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbG9jYWwgQUFCQiBmb3IgdGhlIHRyaW1lc2gKICAgICAqLwoKCiAgICBjb21wdXRlTG9jYWxBQUJCKGFhYmIpIHsKICAgICAgY29uc3QgbCA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IGFhYmIudXBwZXJCb3VuZDsKICAgICAgY29uc3QgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoOwogICAgICB0aGlzLnZlcnRpY2VzOwogICAgICBjb25zdCB2ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7CiAgICAgIHRoaXMuZ2V0VmVydGV4KDAsIHYpOwogICAgICBsLmNvcHkodik7CiAgICAgIHUuY29weSh2KTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBuOyBpKyspIHsKICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKCiAgICAgICAgaWYgKHYueCA8IGwueCkgewogICAgICAgICAgbC54ID0gdi54OwogICAgICAgIH0gZWxzZSBpZiAodi54ID4gdS54KSB7CiAgICAgICAgICB1LnggPSB2Lng7CiAgICAgICAgfQoKICAgICAgICBpZiAodi55IDwgbC55KSB7CiAgICAgICAgICBsLnkgPSB2Lnk7CiAgICAgICAgfSBlbHNlIGlmICh2LnkgPiB1LnkpIHsKICAgICAgICAgIHUueSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmICh2LnogPCBsLnopIHsKICAgICAgICAgIGwueiA9IHYuejsKICAgICAgICB9IGVsc2UgaWYgKHYueiA+IHUueikgewogICAgICAgICAgdS56ID0gdi56OwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIGAuYWFiYmAgcHJvcGVydHkKICAgICAqLwoKCiAgICB1cGRhdGVBQUJCKCkgewogICAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIodGhpcy5hYWJiKTsKICAgIH0KICAgIC8qKgogICAgICogV2lsbCB1cGRhdGUgdGhlIGAuYm91bmRpbmdTcGhlcmVSYWRpdXNgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXIKICAgICAgbGV0IG1heDIgPSAwOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjMygpOwoKICAgICAgZm9yIChsZXQgaSA9IDAsIE4gPSB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICE9PSBOOyBpKyspIHsKICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKICAgICAgICBjb25zdCBub3JtMiA9IHYubGVuZ3RoU3F1YXJlZCgpOwoKICAgICAgICBpZiAobm9ybTIgPiBtYXgyKSB7CiAgICAgICAgICBtYXgyID0gbm9ybTI7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTWF0aC5zcXJ0KG1heDIpOwogICAgfQogICAgLyoqCiAgICAgKiBjYWxjdWxhdGVXb3JsZEFBQkIKICAgICAqLwoKCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICAvKgogICAgICAgICAgY29uc3QgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC8gMywKICAgICAgICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7CiAgICAgICAgICBjb25zdCBtaW54LG1pbnksbWlueixtYXh4LG1heHksbWF4ejsKICAgICAgICAgICBjb25zdCB2ID0gdGVtcFdvcmxkVmVydGV4OwogICAgICAgICAgZm9yKGxldCBpPTA7IGk8bjsgaSsrKXsKICAgICAgICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKICAgICAgICAgICAgICBxdWF0LnZtdWx0KHYsIHYpOwogICAgICAgICAgICAgIHBvcy52YWRkKHYsIHYpOwogICAgICAgICAgICAgIGlmICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpewogICAgICAgICAgICAgICAgICBtaW54ID0gdi54OwogICAgICAgICAgICAgIH0gZWxzZSBpZih2LnggPiBtYXh4IHx8IG1heHg9PT11bmRlZmluZWQpewogICAgICAgICAgICAgICAgICBtYXh4ID0gdi54OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgaWYgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7CiAgICAgICAgICAgICAgICAgIG1pbnkgPSB2Lnk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmKHYueSA+IG1heHkgfHwgbWF4eT09PXVuZGVmaW5lZCl7CiAgICAgICAgICAgICAgICAgIG1heHkgPSB2Lnk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICBpZiAodi56IDwgbWlueiB8fCBtaW56PT09dW5kZWZpbmVkKXsKICAgICAgICAgICAgICAgICAgbWlueiA9IHYuejsKICAgICAgICAgICAgICB9IGVsc2UgaWYodi56ID4gbWF4eiB8fCBtYXh6PT09dW5kZWZpbmVkKXsKICAgICAgICAgICAgICAgICAgbWF4eiA9IHYuejsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTsKICAgICAgICAgIG1heC5zZXQobWF4eCxtYXh5LG1heHopOwogICAgICAgICAgKi8KICAgICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQgogICAgICBjb25zdCBmcmFtZSA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZTsKICAgICAgY29uc3QgcmVzdWx0ID0gY2FsY3VsYXRlV29ybGRBQUJCX2FhYmI7CiAgICAgIGZyYW1lLnBvc2l0aW9uID0gcG9zOwogICAgICBmcmFtZS5xdWF0ZXJuaW9uID0gcXVhdDsKICAgICAgdGhpcy5hYWJiLnRvV29ybGRGcmFtZShmcmFtZSwgcmVzdWx0KTsKICAgICAgbWluLmNvcHkocmVzdWx0Lmxvd2VyQm91bmQpOwogICAgICBtYXguY29weShyZXN1bHQudXBwZXJCb3VuZCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhcHByb3hpbWF0ZSB2b2x1bWUKICAgICAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlIGEgVHJpbWVzaCBpbnN0YW5jZSwgc2hhcGVkIGFzIGEgdG9ydXMuCiAgICAgKi8KCgogICAgc3RhdGljIGNyZWF0ZVRvcnVzKHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjKSB7CiAgICAgIGlmIChyYWRpdXMgPT09IHZvaWQgMCkgewogICAgICAgIHJhZGl1cyA9IDE7CiAgICAgIH0KCiAgICAgIGlmICh0dWJlID09PSB2b2lkIDApIHsKICAgICAgICB0dWJlID0gMC41OwogICAgICB9CgogICAgICBpZiAocmFkaWFsU2VnbWVudHMgPT09IHZvaWQgMCkgewogICAgICAgIHJhZGlhbFNlZ21lbnRzID0gODsKICAgICAgfQoKICAgICAgaWYgKHR1YnVsYXJTZWdtZW50cyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdHVidWxhclNlZ21lbnRzID0gNjsKICAgICAgfQoKICAgICAgaWYgKGFyYyA9PT0gdm9pZCAwKSB7CiAgICAgICAgYXJjID0gTWF0aC5QSSAqIDI7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKykgewogICAgICAgICAgY29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7CiAgICAgICAgICBjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7CiAgICAgICAgICBjb25zdCB4ID0gKHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyh2KSkgKiBNYXRoLmNvcyh1KTsKICAgICAgICAgIGNvbnN0IHkgPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguc2luKHUpOwogICAgICAgICAgY29uc3QgeiA9IHR1YmUgKiBNYXRoLnNpbih2KTsKICAgICAgICAgIHZlcnRpY2VzLnB1c2goeCwgeSwgeik7CiAgICAgICAgfQogICAgICB9CgogICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHsKICAgICAgICAgIGNvbnN0IGEgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaSAtIDE7CiAgICAgICAgICBjb25zdCBiID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogKGogLSAxKSArIGkgLSAxOwogICAgICAgICAgY29uc3QgYyA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpOwogICAgICAgICAgY29uc3QgZCA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIGogKyBpOwogICAgICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGQpOwogICAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKTsKICAgIH0KCiAgfQogIGNvbnN0IGNvbXB1dGVOb3JtYWxzX24gPSBuZXcgVmVjMygpOwogIGNvbnN0IHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7CiAgY29uc3QgZ2V0RWRnZVZlY3Rvcl92YSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZ2V0RWRnZVZlY3Rvcl92YiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY2IgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFiID0gbmV3IFZlYzMoKTsKICBjb25zdCB2YSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdmIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHZjID0gbmV3IFZlYzMoKTsKICBjb25zdCBjbGlfYWFiYiA9IG5ldyBBQUJCKCk7CiAgY29uc3QgY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZSA9IG5ldyBUcmFuc2Zvcm0oKTsKICBjb25zdCBjYWxjdWxhdGVXb3JsZEFBQkJfYWFiYiA9IG5ldyBBQUJCKCk7CgogIC8qKgogICAqIENvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyIGJhc2UgY2xhc3MuCiAgICovCiAgY2xhc3MgU29sdmVyIHsKICAgIC8qKgogICAgICogQWxsIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWQKICAgICAqLwoKICAgIC8qKgogICAgICogQHRvZG8gcmVtb3ZlIHVzZWxlc3MgY29uc3RydWN0b3IKICAgICAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMuZXF1YXRpb25zID0gW107CiAgICB9CiAgICAvKioKICAgICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzIQogICAgICogQHRvZG8gdXNlIGFic3RyYWN0CiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBpdGVyYXRpb25zIHBlcmZvcm1lZAogICAgICovCgoKICAgIHNvbHZlKGR0LCB3b3JsZCkgewogICAgICByZXR1cm4gKC8vIFNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGRvbmUhCiAgICAgICAgMAogICAgICApOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYW4gZXF1YXRpb24KICAgICAqLwoKCiAgICBhZGRFcXVhdGlvbihlcSkgewogICAgICBpZiAoZXEuZW5hYmxlZCAmJiAhZXEuYmkuaXNUcmlnZ2VyICYmICFlcS5iai5pc1RyaWdnZXIpIHsKICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmUgYW4gZXF1YXRpb24KICAgICAqLwoKCiAgICByZW1vdmVFcXVhdGlvbihlcSkgewogICAgICBjb25zdCBlcXMgPSB0aGlzLmVxdWF0aW9uczsKICAgICAgY29uc3QgaSA9IGVxcy5pbmRleE9mKGVxKTsKCiAgICAgIGlmIChpICE9PSAtMSkgewogICAgICAgIGVxcy5zcGxpY2UoaSwgMSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQWRkIGFsbCBlcXVhdGlvbnMKICAgICAqLwoKCiAgICByZW1vdmVBbGxFcXVhdGlvbnMoKSB7CiAgICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQ29uc3RyYWludCBlcXVhdGlvbiBHYXVzcy1TZWlkZWwgc29sdmVyLgogICAqIEB0b2RvIFRoZSBzcG9vayBwYXJhbWV0ZXJzIHNob3VsZCBiZSBzcGVjaWZpZWQgZm9yIGVhY2ggY29uc3RyYWludCwgbm90IGdsb2JhbGx5LgogICAqIEBzZWUgaHR0cHM6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGYKICAgKi8KICBjbGFzcyBHU1NvbHZlciBleHRlbmRzIFNvbHZlciB7CiAgICAvKioKICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuCiAgICAgKiBUaGUgbW9yZSBpdGVyYXRpb25zLCB0aGUgbW9yZSBjb3JyZWN0IHNpbXVsYXRpb24uIE1vcmUgaXRlcmF0aW9ucyBuZWVkIG1vcmUgY29tcHV0YXRpb25zIHRob3VnaC4gSWYgeW91IGhhdmUgYSBsYXJnZSBncmF2aXR5IGZvcmNlIGluIHlvdXIgd29ybGQsIHlvdSB3aWxsIG5lZWQgbW9yZSBpdGVyYXRpb25zLgogICAgICovCgogICAgLyoqCiAgICAgKiBXaGVuIHRvbGVyYW5jZSBpcyByZWFjaGVkLCB0aGUgc3lzdGVtIGlzIGFzc3VtZWQgdG8gYmUgY29udmVyZ2VkLgogICAgICovCgogICAgLyoqCiAgICAgKiBAdG9kbyByZW1vdmUgdXNlbGVzcyBjb25zdHJ1Y3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pdGVyYXRpb25zID0gMTA7CiAgICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNzsKICAgIH0KICAgIC8qKgogICAgICogU29sdmUKICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgcGVyZm9ybWVkCiAgICAgKi8KCgogICAgc29sdmUoZHQsIHdvcmxkKSB7CiAgICAgIGxldCBpdGVyID0gMDsKICAgICAgY29uc3QgbWF4SXRlciA9IHRoaXMuaXRlcmF0aW9uczsKICAgICAgY29uc3QgdG9sU3F1YXJlZCA9IHRoaXMudG9sZXJhbmNlICogdGhpcy50b2xlcmFuY2U7CiAgICAgIGNvbnN0IGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zOwogICAgICBjb25zdCBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoOwogICAgICBjb25zdCBib2RpZXMgPSB3b3JsZC5ib2RpZXM7CiAgICAgIGNvbnN0IE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBoID0gZHQ7CiAgICAgIGxldCBCOwogICAgICBsZXQgaW52QzsKICAgICAgbGV0IGRlbHRhbGFtYmRhOwogICAgICBsZXQgZGVsdGFsYW1iZGFUb3Q7CiAgICAgIGxldCBHV2xhbWJkYTsKICAgICAgbGV0IGxhbWJkYWo7IC8vIFVwZGF0ZSBzb2x2ZSBtYXNzCgogICAgICBpZiAoTmVxICE9PSAwKSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykgewogICAgICAgICAgYm9kaWVzW2ldLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKTsKICAgICAgICB9CiAgICAgIH0gLy8gVGhpbmdzIHRoYXQgZG8gbm90IGNoYW5nZSBkdXJpbmcgaXRlcmF0aW9uIGNhbiBiZSBjb21wdXRlZCBvbmNlCgoKICAgICAgY29uc3QgaW52Q3MgPSBHU1NvbHZlcl9zb2x2ZV9pbnZDczsKICAgICAgY29uc3QgQnMgPSBHU1NvbHZlcl9zb2x2ZV9CczsKICAgICAgY29uc3QgbGFtYmRhID0gR1NTb2x2ZXJfc29sdmVfbGFtYmRhOwogICAgICBpbnZDcy5sZW5ndGggPSBOZXE7CiAgICAgIEJzLmxlbmd0aCA9IE5lcTsKICAgICAgbGFtYmRhLmxlbmd0aCA9IE5lcTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOZXE7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBlcXVhdGlvbnNbaV07CiAgICAgICAgbGFtYmRhW2ldID0gMC4wOwogICAgICAgIEJzW2ldID0gYy5jb21wdXRlQihoKTsKICAgICAgICBpbnZDc1tpXSA9IDEuMCAvIGMuY29tcHV0ZUMoKTsKICAgICAgfQoKICAgICAgaWYgKE5lcSAhPT0gMCkgewogICAgICAgIC8vIFJlc2V0IHZsYW1iZGEKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiID0gYm9kaWVzW2ldOwogICAgICAgICAgY29uc3QgdmxhbWJkYSA9IGIudmxhbWJkYTsKICAgICAgICAgIGNvbnN0IHdsYW1iZGEgPSBiLndsYW1iZGE7CiAgICAgICAgICB2bGFtYmRhLnNldCgwLCAwLCAwKTsKICAgICAgICAgIHdsYW1iZGEuc2V0KDAsIDAsIDApOwogICAgICAgIH0gLy8gSXRlcmF0ZSBvdmVyIGVxdWF0aW9ucwoKCiAgICAgICAgZm9yIChpdGVyID0gMDsgaXRlciAhPT0gbWF4SXRlcjsgaXRlcisrKSB7CiAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uCiAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDsKCiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gTmVxOyBqKyspIHsKICAgICAgICAgICAgY29uc3QgYyA9IGVxdWF0aW9uc1tqXTsgLy8gQ29tcHV0ZSBpdGVyYXRpb24KCiAgICAgICAgICAgIEIgPSBCc1tqXTsKICAgICAgICAgICAgaW52QyA9IGludkNzW2pdOwogICAgICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdOwogICAgICAgICAgICBHV2xhbWJkYSA9IGMuY29tcHV0ZUdXbGFtYmRhKCk7CiAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gaW52QyAqIChCIC0gR1dsYW1iZGEgLSBjLmVwcyAqIGxhbWJkYWopOyAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbAoKICAgICAgICAgICAgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA8IGMubWluRm9yY2UpIHsKICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGMubWluRm9yY2UgLSBsYW1iZGFqOwogICAgICAgICAgICB9IGVsc2UgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA+IGMubWF4Rm9yY2UpIHsKICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGMubWF4Rm9yY2UgLSBsYW1iZGFqOwogICAgICAgICAgICB9CgogICAgICAgICAgICBsYW1iZGFbal0gKz0gZGVsdGFsYW1iZGE7CiAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IGRlbHRhbGFtYmRhID4gMC4wID8gZGVsdGFsYW1iZGEgOiAtZGVsdGFsYW1iZGE7IC8vIGFicyhkZWx0YWxhbWJkYSkKCiAgICAgICAgICAgIGMuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTsKICAgICAgICAgIH0gLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZQoKCiAgICAgICAgICBpZiAoZGVsdGFsYW1iZGFUb3QgKiBkZWx0YWxhbWJkYVRvdCA8IHRvbFNxdWFyZWQpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5CgoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiID0gYm9kaWVzW2ldOwogICAgICAgICAgY29uc3QgdiA9IGIudmVsb2NpdHk7CiAgICAgICAgICBjb25zdCB3ID0gYi5hbmd1bGFyVmVsb2NpdHk7CiAgICAgICAgICBiLnZsYW1iZGEudm11bChiLmxpbmVhckZhY3RvciwgYi52bGFtYmRhKTsKICAgICAgICAgIHYudmFkZChiLnZsYW1iZGEsIHYpOwogICAgICAgICAgYi53bGFtYmRhLnZtdWwoYi5hbmd1bGFyRmFjdG9yLCBiLndsYW1iZGEpOwogICAgICAgICAgdy52YWRkKGIud2xhbWJkYSwgdyk7CiAgICAgICAgfSAvLyBTZXQgdGhlIGAubXVsdGlwbGllcmAgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvbgoKCiAgICAgICAgbGV0IGwgPSBlcXVhdGlvbnMubGVuZ3RoOwogICAgICAgIGNvbnN0IGludkR0ID0gMSAvIGg7CgogICAgICAgIHdoaWxlIChsLS0pIHsKICAgICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gaXRlcjsKICAgIH0KCiAgfSAvLyBKdXN0IHRlbXBvcmFyeSBudW1iZXIgaG9sZGVycyB0aGF0IHdlIHdhbnQgdG8gcmV1c2UgZWFjaCBpdGVyYXRpb24uCgogIGNvbnN0IEdTU29sdmVyX3NvbHZlX2xhbWJkYSA9IFtdOwogIGNvbnN0IEdTU29sdmVyX3NvbHZlX2ludkNzID0gW107CiAgY29uc3QgR1NTb2x2ZXJfc29sdmVfQnMgPSBbXTsKCiAgLyoqCiAgICogU3BsaXRzIHRoZSBlcXVhdGlvbnMgaW50byBpc2xhbmRzIGFuZCBzb2x2ZXMgdGhlbSBpbmRlcGVuZGVudGx5LiBDYW4gaW1wcm92ZSBwZXJmb3JtYW5jZS4KICAgKi8KICBjbGFzcyBTcGxpdFNvbHZlciBleHRlbmRzIFNvbHZlciB7CiAgICAvKioKICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuIFRoZSBtb3JlIGl0ZXJhdGlvbnMsIHRoZSBtb3JlIGNvcnJlY3Qgc2ltdWxhdGlvbi4gTW9yZSBpdGVyYXRpb25zIG5lZWQgbW9yZSBjb21wdXRhdGlvbnMgdGhvdWdoLiBJZiB5b3UgaGF2ZSBhIGxhcmdlIGdyYXZpdHkgZm9yY2UgaW4geW91ciB3b3JsZCwgeW91IHdpbGwgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZW4gdG9sZXJhbmNlIGlzIHJlYWNoZWQsIHRoZSBzeXN0ZW0gaXMgYXNzdW1lZCB0byBiZSBjb252ZXJnZWQuCiAgICAgKi8KCiAgICAvKiogc3Vic29sdmVyICovCiAgICBjb25zdHJ1Y3RvcihzdWJzb2x2ZXIpIHsKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pdGVyYXRpb25zID0gMTA7CiAgICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNzsKICAgICAgdGhpcy5zdWJzb2x2ZXIgPSBzdWJzb2x2ZXI7CiAgICAgIHRoaXMubm9kZXMgPSBbXTsKICAgICAgdGhpcy5ub2RlUG9vbCA9IFtdOyAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZQoKICAgICAgd2hpbGUgKHRoaXMubm9kZVBvb2wubGVuZ3RoIDwgMTI4KSB7CiAgICAgICAgdGhpcy5ub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBjcmVhdGVOb2RlCiAgICAgKi8KCgogICAgY3JlYXRlTm9kZSgpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBib2R5OiBudWxsLAogICAgICAgIGNoaWxkcmVuOiBbXSwKICAgICAgICBlcXM6IFtdLAogICAgICAgIHZpc2l0ZWQ6IGZhbHNlCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIFNvbHZlIHRoZSBzdWJzeXN0ZW1zCiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBpdGVyYXRpb25zIHBlcmZvcm1lZAogICAgICovCgoKICAgIHNvbHZlKGR0LCB3b3JsZCkgewogICAgICBjb25zdCBub2RlcyA9IFNwbGl0U29sdmVyX3NvbHZlX25vZGVzOwogICAgICBjb25zdCBub2RlUG9vbCA9IHRoaXMubm9kZVBvb2w7CiAgICAgIGNvbnN0IGJvZGllcyA9IHdvcmxkLmJvZGllczsKICAgICAgY29uc3QgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnM7CiAgICAgIGNvbnN0IE5lcSA9IGVxdWF0aW9ucy5sZW5ndGg7CiAgICAgIGNvbnN0IE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBzdWJzb2x2ZXIgPSB0aGlzLnN1YnNvbHZlcjsgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGUKCiAgICAgIHdoaWxlIChub2RlUG9vbC5sZW5ndGggPCBOYm9kaWVzKSB7CiAgICAgICAgbm9kZVBvb2wucHVzaCh0aGlzLmNyZWF0ZU5vZGUoKSk7CiAgICAgIH0KCiAgICAgIG5vZGVzLmxlbmd0aCA9IE5ib2RpZXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5ib2RpZXM7IGkrKykgewogICAgICAgIG5vZGVzW2ldID0gbm9kZVBvb2xbaV07CiAgICAgIH0gLy8gUmVzZXQgbm9kZSB2YWx1ZXMKCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldOwogICAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTsKICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7CiAgICAgICAgbm9kZS5lcXMubGVuZ3RoID0gMDsKICAgICAgICBub2RlLnZpc2l0ZWQgPSBmYWxzZTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgayA9IDA7IGsgIT09IE5lcTsgaysrKSB7CiAgICAgICAgY29uc3QgZXEgPSBlcXVhdGlvbnNba107CiAgICAgICAgY29uc3QgaSA9IGJvZGllcy5pbmRleE9mKGVxLmJpKTsKICAgICAgICBjb25zdCBqID0gYm9kaWVzLmluZGV4T2YoZXEuYmopOwogICAgICAgIGNvbnN0IG5pID0gbm9kZXNbaV07CiAgICAgICAgY29uc3QgbmogPSBub2Rlc1tqXTsKICAgICAgICBuaS5jaGlsZHJlbi5wdXNoKG5qKTsKICAgICAgICBuaS5lcXMucHVzaChlcSk7CiAgICAgICAgbmouY2hpbGRyZW4ucHVzaChuaSk7CiAgICAgICAgbmouZXFzLnB1c2goZXEpOwogICAgICB9CgogICAgICBsZXQgY2hpbGQ7CiAgICAgIGxldCBuID0gMDsKICAgICAgbGV0IGVxcyA9IFNwbGl0U29sdmVyX3NvbHZlX2VxczsKICAgICAgc3Vic29sdmVyLnRvbGVyYW5jZSA9IHRoaXMudG9sZXJhbmNlOwogICAgICBzdWJzb2x2ZXIuaXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9uczsKICAgICAgY29uc3QgZHVtbXlXb3JsZCA9IFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQ7CgogICAgICB3aGlsZSAoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGVzKSkgewogICAgICAgIGVxcy5sZW5ndGggPSAwOwogICAgICAgIGR1bW15V29ybGQuYm9kaWVzLmxlbmd0aCA9IDA7CiAgICAgICAgYmZzKGNoaWxkLCB2aXNpdEZ1bmMsIGR1bW15V29ybGQuYm9kaWVzLCBlcXMpOwogICAgICAgIGNvbnN0IE5lcXMgPSBlcXMubGVuZ3RoOwogICAgICAgIGVxcyA9IGVxcy5zb3J0KHNvcnRCeUlkKTsKCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5lcXM7IGkrKykgewogICAgICAgICAgc3Vic29sdmVyLmFkZEVxdWF0aW9uKGVxc1tpXSk7CiAgICAgICAgfQoKICAgICAgICBzdWJzb2x2ZXIuc29sdmUoZHQsIGR1bW15V29ybGQpOwogICAgICAgIHN1YnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTsKICAgICAgICBuKys7CiAgICAgIH0KCiAgICAgIHJldHVybiBuOwogICAgfQoKICB9IC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBzdWJzeXN0ZW1zCgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX25vZGVzID0gW107IC8vIEFsbCBhbGxvY2F0ZWQgbm9kZSBvYmplY3RzCgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX2VxcyA9IFtdOyAvLyBUZW1wIGFycmF5CgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQgPSB7CiAgICBib2RpZXM6IFtdCiAgfTsgLy8gVGVtcCBvYmplY3QKCiAgY29uc3QgU1RBVElDID0gQm9keS5TVEFUSUM7CgogIGZ1bmN0aW9uIGdldFVudmlzaXRlZE5vZGUobm9kZXMpIHsKICAgIGNvbnN0IE5ub2RlcyA9IG5vZGVzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTm5vZGVzOyBpKyspIHsKICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldOwoKICAgICAgaWYgKCFub2RlLnZpc2l0ZWQgJiYgIShub2RlLmJvZHkudHlwZSAmIFNUQVRJQykpIHsKICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBmYWxzZTsKICB9CgogIGNvbnN0IHF1ZXVlID0gW107CgogIGZ1bmN0aW9uIGJmcyhyb290LCB2aXNpdEZ1bmMsIGJkcywgZXFzKSB7CiAgICBxdWV1ZS5wdXNoKHJvb3QpOwogICAgcm9vdC52aXNpdGVkID0gdHJ1ZTsKICAgIHZpc2l0RnVuYyhyb290LCBiZHMsIGVxcyk7CgogICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkgewogICAgICBjb25zdCBub2RlID0gcXVldWUucG9wKCk7IC8vIExvb3Agb3ZlciB1bnZpc2l0ZWQgY2hpbGQgbm9kZXMKCiAgICAgIGxldCBjaGlsZDsKCiAgICAgIHdoaWxlIChjaGlsZCA9IGdldFVudmlzaXRlZE5vZGUobm9kZS5jaGlsZHJlbikpIHsKICAgICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTsKICAgICAgICB2aXNpdEZ1bmMoY2hpbGQsIGJkcywgZXFzKTsKICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTsKICAgICAgfQogICAgfQogIH0KCiAgZnVuY3Rpb24gdmlzaXRGdW5jKG5vZGUsIGJkcywgZXFzKSB7CiAgICBiZHMucHVzaChub2RlLmJvZHkpOwogICAgY29uc3QgTmVxcyA9IG5vZGUuZXFzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmVxczsgaSsrKSB7CiAgICAgIGNvbnN0IGVxID0gbm9kZS5lcXNbaV07CgogICAgICBpZiAoIWVxcy5pbmNsdWRlcyhlcSkpIHsKICAgICAgICBlcXMucHVzaChlcSk7CiAgICAgIH0KICAgIH0KICB9CgogIGZ1bmN0aW9uIHNvcnRCeUlkKGEsIGIpIHsKICAgIHJldHVybiBiLmlkIC0gYS5pZDsKICB9CgogIC8qKgogICAqIEZvciBwb29saW5nIG9iamVjdHMgdGhhdCBjYW4gYmUgcmV1c2VkLgogICAqLwogIGNsYXNzIFBvb2wgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMub2JqZWN0cyA9IFtdOwogICAgICB0aGlzLnR5cGUgPSBPYmplY3Q7CiAgICB9CgogICAgLyoqCiAgICAgKiBSZWxlYXNlIGFuIG9iamVjdCBhZnRlciB1c2UKICAgICAqLwogICAgcmVsZWFzZSgpIHsKICAgICAgY29uc3QgTmFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5hcmdzOyBpKyspIHsKICAgICAgICB0aGlzLm9iamVjdHMucHVzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFuIG9iamVjdAogICAgICovCgoKICAgIGdldCgpIHsKICAgICAgaWYgKHRoaXMub2JqZWN0cy5sZW5ndGggPT09IDApIHsKICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RPYmplY3QoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzLnBvcCgpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnN0cnVjdCBhbiBvYmplY3QuIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzLgogICAgICovCgoKICAgIGNvbnN0cnVjdE9iamVjdCgpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCEnKTsKICAgIH0KICAgIC8qKgogICAgICogQHJldHVybiBTZWxmLCBmb3IgY2hhaW5pbmcKICAgICAqLwoKCiAgICByZXNpemUoc2l6ZSkgewogICAgICBjb25zdCBvYmplY3RzID0gdGhpcy5vYmplY3RzOwoKICAgICAgd2hpbGUgKG9iamVjdHMubGVuZ3RoID4gc2l6ZSkgewogICAgICAgIG9iamVjdHMucG9wKCk7CiAgICAgIH0KCiAgICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHsKICAgICAgICBvYmplY3RzLnB1c2godGhpcy5jb25zdHJ1Y3RPYmplY3QoKSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQoKICB9CgogIC8qKgogICAqIFZlYzNQb29sCiAgICovCgogIGNsYXNzIFZlYzNQb29sIGV4dGVuZHMgUG9vbCB7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTsKICAgICAgdGhpcy50eXBlID0gVmVjMzsKICAgIH0KCiAgICAvKioKICAgICAqIENvbnN0cnVjdCBhIHZlY3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RPYmplY3QoKSB7CiAgICAgIHJldHVybiBuZXcgVmVjMygpOwogICAgfQoKICB9CgogIC8vIE5hbWluZyBydWxlOiBiYXNlZCBvZiB0aGUgb3JkZXIgaW4gU0hBUEVfVFlQRVMsCiAgLy8gdGhlIGZpcnN0IHBhcnQgb2YgdGhlIG1ldGhvZCBpcyBmb3JtZWQgYnkgdGhlCiAgLy8gc2hhcGUgdHlwZSB0aGF0IGNvbWVzIGJlZm9yZSwgaW4gdGhlIHNlY29uZCBwYXJ0CiAgLy8gdGhlcmUgaXMgdGhlIHNoYXBlIHR5cGUgdGhhdCBjb21lcyBhZnRlciBpbiB0aGUgU0hBUEVfVFlQRVMgbGlzdAogIGNvbnN0IENPTExJU0lPTl9UWVBFUyA9IHsKICAgIHNwaGVyZVNwaGVyZTogU2hhcGUudHlwZXMuU1BIRVJFLAogICAgc3BoZXJlUGxhbmU6IFNoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLlBMQU5FLAogICAgYm94Qm94OiBTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5CT1gsCiAgICBzcGhlcmVCb3g6IFNoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLkJPWCwKICAgIHBsYW5lQm94OiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkJPWCwKICAgIGNvbnZleENvbnZleDogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiwKICAgIHNwaGVyZUNvbnZleDogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiwKICAgIHBsYW5lQ29udmV4OiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBib3hDb252ZXg6IFNoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBzcGhlcmVIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTEQsCiAgICBib3hIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTEQsCiAgICBjb252ZXhIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxELAogICAgc3BoZXJlUGFydGljbGU6IFNoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFLAogICAgcGxhbmVQYXJ0aWNsZTogU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5QQVJUSUNMRSwKICAgIGJveFBhcnRpY2xlOiBTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5QQVJUSUNMRSwKICAgIGNvbnZleFBhcnRpY2xlOiBTaGFwZS50eXBlcy5QQVJUSUNMRSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBjeWxpbmRlckN5bGluZGVyOiBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHNwaGVyZUN5bGluZGVyOiBTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHBsYW5lQ3lsaW5kZXI6IFNoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBib3hDeWxpbmRlcjogU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBjb252ZXhDeWxpbmRlcjogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkNZTElOREVSLAogICAgaGVpZ2h0ZmllbGRDeWxpbmRlcjogU2hhcGUudHlwZXMuSEVJR0hURklFTEQgfCBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHBhcnRpY2xlQ3lsaW5kZXI6IFNoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBzcGhlcmVUcmltZXNoOiBTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5UUklNRVNILAogICAgcGxhbmVUcmltZXNoOiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlRSSU1FU0gKICB9OwoKICAvKioKICAgKiBIZWxwZXIgY2xhc3MgZm9yIHRoZSBXb3JsZC4gR2VuZXJhdGVzIENvbnRhY3RFcXVhdGlvbnMuCiAgICogQHRvZG8gU3BoZXJlLUNvbnZleFBvbHloZWRyb24gY29udGFjdHMKICAgKiBAdG9kbyBDb250YWN0IHJlZHVjdGlvbgogICAqIEB0b2RvIHNob3VsZCBtb3ZlIG1ldGhvZHMgdG8gcHJvdG90eXBlCiAgICovCiAgY2xhc3MgTmFycm93cGhhc2UgewogICAgLyoqCiAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy4KICAgICAqLwoKICAgIC8qKgogICAgICogUG9vbGVkIHZlY3RvcnMuCiAgICAgKi8KICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVNwaGVyZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnNwaGVyZVNwaGVyZTsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5zcGhlcmVQbGFuZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnNwaGVyZVBsYW5lOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmJveEJveF0oKSB7CiAgICAgIHJldHVybiB0aGlzLmJveEJveDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5zcGhlcmVCb3hdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVCb3g7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVCb3hdKCkgewogICAgICByZXR1cm4gdGhpcy5wbGFuZUJveDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhDb252ZXhdKCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuc3BoZXJlQ29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlQ29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBsYW5lQ29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMucGxhbmVDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94Q29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMuYm94Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZUhlaWdodGZpZWxkXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlSGVpZ2h0ZmllbGQ7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94SGVpZ2h0ZmllbGRdKCkgewogICAgICByZXR1cm4gdGhpcy5ib3hIZWlnaHRmaWVsZDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhIZWlnaHRmaWVsZF0oKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleEhlaWdodGZpZWxkOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVBhcnRpY2xlXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlUGFydGljbGU7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVQYXJ0aWNsZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lUGFydGljbGU7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94UGFydGljbGVdKCkgewogICAgICByZXR1cm4gdGhpcy5ib3hQYXJ0aWNsZTsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhQYXJ0aWNsZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleFBhcnRpY2xlOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmN5bGluZGVyQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuc3BoZXJlQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVDeWxpbmRlcl0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lQ29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmJveEN5bGluZGVyXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuYm94Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmNvbnZleEN5bGluZGVyXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuY29udmV4Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmhlaWdodGZpZWxkQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5oZWlnaHRmaWVsZEN5bGluZGVyOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBhcnRpY2xlQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5wYXJ0aWNsZUN5bGluZGVyOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVRyaW1lc2hdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVUcmltZXNoOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBsYW5lVHJpbWVzaF0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lVHJpbWVzaDsKICAgIH0gLy8gZ2V0IFtDT0xMSVNJT05fVFlQRVMuY29udmV4VHJpbWVzaF0oKSB7CiAgICAvLyAgIHJldHVybiB0aGlzLmNvbnZleFRyaW1lc2gKICAgIC8vIH0KCgogICAgY29uc3RydWN0b3Iod29ybGQpIHsKICAgICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTsKICAgICAgdGhpcy5yZXN1bHQgPSBbXTsKICAgICAgdGhpcy5mcmljdGlvblJlc3VsdCA9IFtdOwogICAgICB0aGlzLnYzcG9vbCA9IG5ldyBWZWMzUG9vbCgpOwogICAgICB0aGlzLndvcmxkID0gd29ybGQ7CiAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7CiAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogTWFrZSBhIGNvbnRhY3Qgb2JqZWN0LCBieSB1c2luZyB0aGUgaW50ZXJuYWwgcG9vbCBvciBjcmVhdGluZyBhIG5ldyBvbmUuCiAgICAgKi8KCgogICAgY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCBvdmVycmlkZVNoYXBlQSwgb3ZlcnJpZGVTaGFwZUIpIHsKICAgICAgbGV0IGM7CgogICAgICBpZiAodGhpcy5jb250YWN0UG9pbnRQb29sLmxlbmd0aCkgewogICAgICAgIGMgPSB0aGlzLmNvbnRhY3RQb2ludFBvb2wucG9wKCk7CiAgICAgICAgYy5iaSA9IGJpOwogICAgICAgIGMuYmogPSBiajsKICAgICAgfSBlbHNlIHsKICAgICAgICBjID0gbmV3IENvbnRhY3RFcXVhdGlvbihiaSwgYmopOwogICAgICB9CgogICAgICBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTsKICAgICAgY29uc3QgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7CiAgICAgIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjsKICAgICAgYy5zZXRTcG9va1BhcmFtcyhjbS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsIGNtLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sIHRoaXMud29ybGQuZHQpOwogICAgICBjb25zdCBtYXRBID0gc2kubWF0ZXJpYWwgfHwgYmkubWF0ZXJpYWw7CiAgICAgIGNvbnN0IG1hdEIgPSBzai5tYXRlcmlhbCB8fCBiai5tYXRlcmlhbDsKCiAgICAgIGlmIChtYXRBICYmIG1hdEIgJiYgbWF0QS5yZXN0aXR1dGlvbiA+PSAwICYmIG1hdEIucmVzdGl0dXRpb24gPj0gMCkgewogICAgICAgIGMucmVzdGl0dXRpb24gPSBtYXRBLnJlc3RpdHV0aW9uICogbWF0Qi5yZXN0aXR1dGlvbjsKICAgICAgfQoKICAgICAgYy5zaSA9IG92ZXJyaWRlU2hhcGVBIHx8IHNpOwogICAgICBjLnNqID0gb3ZlcnJpZGVTaGFwZUIgfHwgc2o7CiAgICAgIHJldHVybiBjOwogICAgfQoKICAgIGNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoY29udGFjdEVxdWF0aW9uLCBvdXRBcnJheSkgewogICAgICBjb25zdCBib2R5QSA9IGNvbnRhY3RFcXVhdGlvbi5iaTsKICAgICAgY29uc3QgYm9keUIgPSBjb250YWN0RXF1YXRpb24uYmo7CiAgICAgIGNvbnN0IHNoYXBlQSA9IGNvbnRhY3RFcXVhdGlvbi5zaTsKICAgICAgY29uc3Qgc2hhcGVCID0gY29udGFjdEVxdWF0aW9uLnNqOwogICAgICBjb25zdCB3b3JsZCA9IHRoaXMud29ybGQ7CiAgICAgIGNvbnN0IGNtID0gdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsOyAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtCgogICAgICBsZXQgZnJpY3Rpb24gPSBjbS5mcmljdGlvbjsKICAgICAgY29uc3QgbWF0QSA9IHNoYXBlQS5tYXRlcmlhbCB8fCBib2R5QS5tYXRlcmlhbDsKICAgICAgY29uc3QgbWF0QiA9IHNoYXBlQi5tYXRlcmlhbCB8fCBib2R5Qi5tYXRlcmlhbDsKCiAgICAgIGlmIChtYXRBICYmIG1hdEIgJiYgbWF0QS5mcmljdGlvbiA+PSAwICYmIG1hdEIuZnJpY3Rpb24gPj0gMCkgewogICAgICAgIGZyaWN0aW9uID0gbWF0QS5mcmljdGlvbiAqIG1hdEIuZnJpY3Rpb247CiAgICAgIH0KCiAgICAgIGlmIChmcmljdGlvbiA+IDApIHsKICAgICAgICAvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9ucwogICAgICAgIC8vIFVzZXJzIG1heSBwcm92aWRlIGEgZm9yY2UgZGlmZmVyZW50IGZyb20gZ2xvYmFsIGdyYXZpdHkgdG8gdXNlIHdoZW4gY29tcHV0aW5nIGNvbnRhY3QgZnJpY3Rpb24uCiAgICAgICAgY29uc3QgbXVnID0gZnJpY3Rpb24gKiAod29ybGQuZnJpY3Rpb25HcmF2aXR5IHx8IHdvcmxkLmdyYXZpdHkpLmxlbmd0aCgpOwogICAgICAgIGxldCByZWR1Y2VkTWFzcyA9IGJvZHlBLmludk1hc3MgKyBib2R5Qi5pbnZNYXNzOwoKICAgICAgICBpZiAocmVkdWNlZE1hc3MgPiAwKSB7CiAgICAgICAgICByZWR1Y2VkTWFzcyA9IDEgLyByZWR1Y2VkTWFzczsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sOwogICAgICAgIGNvbnN0IGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtdWcgKiByZWR1Y2VkTWFzcyk7CiAgICAgICAgY29uc3QgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihib2R5QSwgYm9keUIsIG11ZyAqIHJlZHVjZWRNYXNzKTsKICAgICAgICBjMS5iaSA9IGMyLmJpID0gYm9keUE7CiAgICAgICAgYzEuYmogPSBjMi5iaiA9IGJvZHlCOwogICAgICAgIGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnICogcmVkdWNlZE1hc3M7CiAgICAgICAgYzEubWF4Rm9yY2UgPSBjMi5tYXhGb3JjZSA9IG11ZyAqIHJlZHVjZWRNYXNzOyAvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnMKCiAgICAgICAgYzEucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpOwogICAgICAgIGMxLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTsKICAgICAgICBjMi5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7CiAgICAgICAgYzIucmouY29weShjb250YWN0RXF1YXRpb24ucmopOyAvLyBDb25zdHJ1Y3QgdGFuZ2VudHMKCiAgICAgICAgY29udGFjdEVxdWF0aW9uLm5pLnRhbmdlbnRzKGMxLnQsIGMyLnQpOyAvLyBTZXQgc3Bvb2sgcGFyYW1zCgogICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7CiAgICAgICAgYzIuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIHdvcmxkLmR0KTsKICAgICAgICBjMS5lbmFibGVkID0gYzIuZW5hYmxlZCA9IGNvbnRhY3RFcXVhdGlvbi5lbmFibGVkOwogICAgICAgIG91dEFycmF5LnB1c2goYzEsIGMyKTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQoKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgLyoqCiAgICAgKiBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLgogICAgICovCgoKICAgIGNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpIHsKICAgICAgLy8gVGhlIGxhc3QgY29udGFjdEVxdWF0aW9uCiAgICAgIGxldCBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMV07IC8vIENyZWF0ZSB0aGUgcmVzdWx0OiB0d28gImF2ZXJhZ2UiIGZyaWN0aW9uIGVxdWF0aW9ucwoKICAgICAgaWYgKCF0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoYywgdGhpcy5mcmljdGlvblJlc3VsdCkgfHwgbnVtQ29udGFjdHMgPT09IDEpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGYxID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdOwogICAgICBjb25zdCBmMiA9IHRoaXMuZnJpY3Rpb25SZXN1bHRbdGhpcy5mcmljdGlvblJlc3VsdC5sZW5ndGggLSAxXTsKICAgICAgYXZlcmFnZU5vcm1hbC5zZXRaZXJvKCk7CiAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNldFplcm8oKTsKICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIuc2V0WmVybygpOwogICAgICBjb25zdCBib2R5QSA9IGMuYmk7CiAgICAgIGMuYmo7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gbnVtQ29udGFjdHM7IGkrKykgewogICAgICAgIGMgPSB0aGlzLnJlc3VsdFt0aGlzLnJlc3VsdC5sZW5ndGggLSAxIC0gaV07CgogICAgICAgIGlmIChjLmJpICE9PSBib2R5QSkgewogICAgICAgICAgYXZlcmFnZU5vcm1hbC52YWRkKGMubmksIGF2ZXJhZ2VOb3JtYWwpOwogICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7CiAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYXZlcmFnZU5vcm1hbC52c3ViKGMubmksIGF2ZXJhZ2VOb3JtYWwpOwogICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJqLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7CiAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IGludk51bUNvbnRhY3RzID0gMSAvIG51bUNvbnRhY3RzOwogICAgICBhdmVyYWdlQ29udGFjdFBvaW50QS5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmkpOwogICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmopOwogICAgICBmMi5yaS5jb3B5KGYxLnJpKTsgLy8gU2hvdWxkIGJlIHRoZSBzYW1lCgogICAgICBmMi5yai5jb3B5KGYxLnJqKTsKICAgICAgYXZlcmFnZU5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgYXZlcmFnZU5vcm1hbC50YW5nZW50cyhmMS50LCBmMi50KTsgLy8gcmV0dXJuIGVxOwogICAgfQogICAgLyoqCiAgICAgKiBHZW5lcmF0ZSBhbGwgY29udGFjdHMgYmV0d2VlbiBhIGxpc3Qgb2YgYm9keSBwYWlycwogICAgICogQHBhcmFtIHAxIEFycmF5IG9mIGJvZHkgaW5kaWNlcwogICAgICogQHBhcmFtIHAyIEFycmF5IG9mIGJvZHkgaW5kaWNlcwogICAgICogQHBhcmFtIHJlc3VsdCBBcnJheSB0byBzdG9yZSBnZW5lcmF0ZWQgY29udGFjdHMKICAgICAqIEBwYXJhbSBvbGRjb250YWN0cyBPcHRpb25hbC4gQXJyYXkgb2YgcmV1c2FibGUgY29udGFjdCBvYmplY3RzCiAgICAgKi8KCgogICAgZ2V0Q29udGFjdHMocDEsIHAyLCB3b3JsZCwgcmVzdWx0LCBvbGRjb250YWN0cywgZnJpY3Rpb25SZXN1bHQsIGZyaWN0aW9uUG9vbCkgewogICAgICAvLyBTYXZlIG9sZCBjb250YWN0IG9iamVjdHMKICAgICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBmcmljdGlvblBvb2w7CiAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0OwogICAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7CiAgICAgIGNvbnN0IHFpID0gdG1wUXVhdDE7CiAgICAgIGNvbnN0IHFqID0gdG1wUXVhdDI7CiAgICAgIGNvbnN0IHhpID0gdG1wVmVjMTsKICAgICAgY29uc3QgeGogPSB0bXBWZWMyOwoKICAgICAgZm9yIChsZXQgayA9IDAsIE4gPSBwMS5sZW5ndGg7IGsgIT09IE47IGsrKykgewogICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXMKICAgICAgICBjb25zdCBiaSA9IHAxW2tdOwogICAgICAgIGNvbnN0IGJqID0gcDJba107IC8vIEdldCBjb250YWN0IG1hdGVyaWFsCgogICAgICAgIGxldCBib2R5Q29udGFjdE1hdGVyaWFsID0gbnVsbDsKCiAgICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7CiAgICAgICAgICBib2R5Q29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLCBiai5tYXRlcmlhbCkgfHwgbnVsbDsKICAgICAgICB9CgogICAgICAgIGNvbnN0IGp1c3RUZXN0ID0gYmkudHlwZSAmIEJvZHkuS0lORU1BVElDICYmIGJqLnR5cGUgJiBCb2R5LlNUQVRJQyB8fCBiaS50eXBlICYgQm9keS5TVEFUSUMgJiYgYmoudHlwZSAmIEJvZHkuS0lORU1BVElDIHx8IGJpLnR5cGUgJiBCb2R5LktJTkVNQVRJQyAmJiBiai50eXBlICYgQm9keS5LSU5FTUFUSUM7CgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmkuc2hhcGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBiaS5xdWF0ZXJuaW9uLm11bHQoYmkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTsKICAgICAgICAgIGJpLnF1YXRlcm5pb24udm11bHQoYmkuc2hhcGVPZmZzZXRzW2ldLCB4aSk7CiAgICAgICAgICB4aS52YWRkKGJpLnBvc2l0aW9uLCB4aSk7CiAgICAgICAgICBjb25zdCBzaSA9IGJpLnNoYXBlc1tpXTsKCiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJqLnNoYXBlcy5sZW5ndGg7IGorKykgewogICAgICAgICAgICAvLyBDb21wdXRlIHdvcmxkIHRyYW5zZm9ybSBvZiBzaGFwZXMKICAgICAgICAgICAgYmoucXVhdGVybmlvbi5tdWx0KGJqLnNoYXBlT3JpZW50YXRpb25zW2pdLCBxaik7CiAgICAgICAgICAgIGJqLnF1YXRlcm5pb24udm11bHQoYmouc2hhcGVPZmZzZXRzW2pdLCB4aik7CiAgICAgICAgICAgIHhqLnZhZGQoYmoucG9zaXRpb24sIHhqKTsKICAgICAgICAgICAgY29uc3Qgc2ogPSBiai5zaGFwZXNbal07CgogICAgICAgICAgICBpZiAoIShzaS5jb2xsaXNpb25GaWx0ZXJNYXNrICYgc2ouY29sbGlzaW9uRmlsdGVyR3JvdXAgJiYgc2ouY29sbGlzaW9uRmlsdGVyTWFzayAmIHNpLmNvbGxpc2lvbkZpbHRlckdyb3VwKSkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0gLy8gR2V0IGNvbGxpc2lvbiBtYXRlcmlhbAoKCiAgICAgICAgICAgIGxldCBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7CgogICAgICAgICAgICBpZiAoc2kubWF0ZXJpYWwgJiYgc2oubWF0ZXJpYWwpIHsKICAgICAgICAgICAgICBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmdldENvbnRhY3RNYXRlcmlhbChzaS5tYXRlcmlhbCwgc2oubWF0ZXJpYWwpIHx8IG51bGw7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHNoYXBlQ29udGFjdE1hdGVyaWFsIHx8IGJvZHlDb250YWN0TWF0ZXJpYWwgfHwgd29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDsgLy8gR2V0IGNvbnRhY3RzCgogICAgICAgICAgICBjb25zdCByZXNvbHZlckluZGV4ID0gc2kudHlwZSB8IHNqLnR5cGU7CiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gdGhpc1tyZXNvbHZlckluZGV4XTsKCiAgICAgICAgICAgIGlmIChyZXNvbHZlcikgewogICAgICAgICAgICAgIGxldCByZXR2YWwgPSBmYWxzZTsgLy8gVE8gRE86IGludmVzdGlnYXRlIHdoeSBzcGhlcmVQYXJ0aWNsZSBhbmQgY29udmV4UGFydGljbGUKICAgICAgICAgICAgICAvLyByZXNvbHZlcnMgZXhwZWN0IHNpIGFuZCBzaiBzaGFwZXMgdG8gYmUgaW4gcmV2ZXJzZSBvcmRlcgogICAgICAgICAgICAgIC8vIChpLmUuIGxhcmdlciBpbnRlZ2VyIHZhbHVlIHR5cGUgZmlyc3QgaW5zdGVhZCBvZiBzbWFsbGVyIGZpcnN0KQoKICAgICAgICAgICAgICBpZiAoc2kudHlwZSA8IHNqLnR5cGUpIHsKICAgICAgICAgICAgICAgIHJldHZhbCA9IHJlc29sdmVyLmNhbGwodGhpcywgc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dmFsID0gcmVzb2x2ZXIuY2FsbCh0aGlzLCBzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHNpLCBzaiwganVzdFRlc3QpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgaWYgKHJldHZhbCAmJiBqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgb3ZlcmxhcAogICAgICAgICAgICAgICAgd29ybGQuc2hhcGVPdmVybGFwS2VlcGVyLnNldChzaS5pZCwgc2ouaWQpOwogICAgICAgICAgICAgICAgd29ybGQuYm9keU92ZXJsYXBLZWVwZXIuc2V0KGJpLmlkLCBiai5pZCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgc3BoZXJlU3BoZXJlKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgIHJldHVybiB4aS5kaXN0YW5jZVNxdWFyZWQoeGopIDwgKHNpLnJhZGl1cyArIHNqLnJhZGl1cykgKiogMjsKICAgICAgfSAvLyBXZSB3aWxsIGhhdmUgb25seSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2UKCgogICAgICBjb25zdCBjb250YWN0RXEgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgeGoudnN1Yih4aSwgY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLm5pLm5vcm1hbGl6ZSgpOyAvLyBDb250YWN0IHBvaW50IGxvY2F0aW9ucwoKICAgICAgY29udGFjdEVxLnJpLmNvcHkoY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLnJqLmNvcHkoY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLnJpLnNjYWxlKHNpLnJhZGl1cywgY29udGFjdEVxLnJpKTsKICAgICAgY29udGFjdEVxLnJqLnNjYWxlKC1zai5yYWRpdXMsIGNvbnRhY3RFcS5yaik7CiAgICAgIGNvbnRhY3RFcS5yaS52YWRkKHhpLCBjb250YWN0RXEucmkpOwogICAgICBjb250YWN0RXEucmkudnN1YihiaS5wb3NpdGlvbiwgY29udGFjdEVxLnJpKTsKICAgICAgY29udGFjdEVxLnJqLnZhZGQoeGosIGNvbnRhY3RFcS5yaik7CiAgICAgIGNvbnRhY3RFcS5yai52c3ViKGJqLnBvc2l0aW9uLCBjb250YWN0RXEucmopOwogICAgICB0aGlzLnJlc3VsdC5wdXNoKGNvbnRhY3RFcSk7CiAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjb250YWN0RXEsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgfQoKICAgIHNwaGVyZVBsYW5lKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFdlIHdpbGwgaGF2ZSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2UKICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7IC8vIENvbnRhY3Qgbm9ybWFsCgogICAgICByLm5pLnNldCgwLCAwLCAxKTsKICAgICAgcWoudm11bHQoci5uaSwgci5uaSk7CiAgICAgIHIubmkubmVnYXRlKHIubmkpOyAvLyBib2R5IGkgaXMgdGhlIHNwaGVyZSwgZmxpcCBub3JtYWwKCiAgICAgIHIubmkubm9ybWFsaXplKCk7IC8vIE5lZWRlZD8KICAgICAgLy8gVmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0IHBvaW50CgogICAgICByLm5pLnNjYWxlKHNpLnJhZGl1cywgci5yaSk7IC8vIFByb2plY3QgZG93biBzcGhlcmUgb24gcGxhbmUKCiAgICAgIHhpLnZzdWIoeGosIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSk7CiAgICAgIHIubmkuc2NhbGUoci5uaS5kb3QocG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKSwgcGxhbmVfdG9fc3BoZXJlX29ydGhvKTsKICAgICAgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLnZzdWIocGxhbmVfdG9fc3BoZXJlX29ydGhvLCByLnJqKTsgLy8gVGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gcGxhbmUKCiAgICAgIGlmICgtcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLmRvdChyLm5pKSA8PSBzaS5yYWRpdXMpIHsKICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gLy8gTWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgYm9keQoKCiAgICAgICAgY29uc3QgcmkgPSByLnJpOwogICAgICAgIGNvbnN0IHJqID0gci5yajsKICAgICAgICByaS52YWRkKHhpLCByaSk7CiAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpOwogICAgICAgIHJqLnZhZGQoeGosIHJqKTsKICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7CiAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgIH0KICAgIH0KCiAgICBib3hCb3goc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsOwogICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTsKICAgICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2ouY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgc3BoZXJlQm94KHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGNvbnN0IHYzcG9vbCA9IHRoaXMudjNwb29sOyAvLyB3ZSByZWZlciB0byB0aGUgYm94IGFzIGJvZHkgagoKICAgICAgY29uc3Qgc2lkZXMgPSBzcGhlcmVCb3hfc2lkZXM7CiAgICAgIHhpLnZzdWIoeGosIGJveF90b19zcGhlcmUpOwogICAgICBzai5nZXRTaWRlTm9ybWFscyhzaWRlcywgcWopOwogICAgICBjb25zdCBSID0gc2kucmFkaXVzOwoKICAgICAgbGV0IGZvdW5kID0gZmFsc2U7IC8vIFN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBwZW5ldHJhdGlvbiBpbmZvCgogICAgICBjb25zdCBzaWRlX25zID0gc3BoZXJlQm94X3NpZGVfbnM7CiAgICAgIGNvbnN0IHNpZGVfbnMxID0gc3BoZXJlQm94X3NpZGVfbnMxOwogICAgICBjb25zdCBzaWRlX25zMiA9IHNwaGVyZUJveF9zaWRlX25zMjsKICAgICAgbGV0IHNpZGVfaCA9IG51bGw7CiAgICAgIGxldCBzaWRlX3BlbmV0cmF0aW9ucyA9IDA7CiAgICAgIGxldCBzaWRlX2RvdDEgPSAwOwogICAgICBsZXQgc2lkZV9kb3QyID0gMDsKICAgICAgbGV0IHNpZGVfZGlzdGFuY2UgPSBudWxsOwoKICAgICAgZm9yIChsZXQgaWR4ID0gMCwgbnNpZGVzID0gc2lkZXMubGVuZ3RoOyBpZHggIT09IG5zaWRlcyAmJiBmb3VuZCA9PT0gZmFsc2U7IGlkeCsrKSB7CiAgICAgICAgLy8gR2V0IHRoZSBwbGFuZSBzaWRlIG5vcm1hbCAobnMpCiAgICAgICAgY29uc3QgbnMgPSBzcGhlcmVCb3hfbnM7CiAgICAgICAgbnMuY29weShzaWRlc1tpZHhdKTsKICAgICAgICBjb25zdCBoID0gbnMubGVuZ3RoKCk7CiAgICAgICAgbnMubm9ybWFsaXplKCk7IC8vIFRoZSBub3JtYWwvZGlzdGFuY2UgZG90IHByb2R1Y3QgdGVsbHMgd2hpY2ggc2lkZSBvZiB0aGUgcGxhbmUgd2UgYXJlCgogICAgICAgIGNvbnN0IGRvdCA9IGJveF90b19zcGhlcmUuZG90KG5zKTsKCiAgICAgICAgaWYgKGRvdCA8IGggKyBSICYmIGRvdCA+IDApIHsKICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayB0aGUgb3RoZXIgdHdvIGRpbWVuc2lvbnMKICAgICAgICAgIGNvbnN0IG5zMSA9IHNwaGVyZUJveF9uczE7CiAgICAgICAgICBjb25zdCBuczIgPSBzcGhlcmVCb3hfbnMyOwogICAgICAgICAgbnMxLmNvcHkoc2lkZXNbKGlkeCArIDEpICUgM10pOwogICAgICAgICAgbnMyLmNvcHkoc2lkZXNbKGlkeCArIDIpICUgM10pOwogICAgICAgICAgY29uc3QgaDEgPSBuczEubGVuZ3RoKCk7CiAgICAgICAgICBjb25zdCBoMiA9IG5zMi5sZW5ndGgoKTsKICAgICAgICAgIG5zMS5ub3JtYWxpemUoKTsKICAgICAgICAgIG5zMi5ub3JtYWxpemUoKTsKICAgICAgICAgIGNvbnN0IGRvdDEgPSBib3hfdG9fc3BoZXJlLmRvdChuczEpOwogICAgICAgICAgY29uc3QgZG90MiA9IGJveF90b19zcGhlcmUuZG90KG5zMik7CgogICAgICAgICAgaWYgKGRvdDEgPCBoMSAmJiBkb3QxID4gLWgxICYmIGRvdDIgPCBoMiAmJiBkb3QyID4gLWgyKSB7CiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmFicyhkb3QgLSBoIC0gUik7CgogICAgICAgICAgICBpZiAoc2lkZV9kaXN0YW5jZSA9PT0gbnVsbCB8fCBkaXN0IDwgc2lkZV9kaXN0YW5jZSkgewogICAgICAgICAgICAgIHNpZGVfZGlzdGFuY2UgPSBkaXN0OwogICAgICAgICAgICAgIHNpZGVfZG90MSA9IGRvdDE7CiAgICAgICAgICAgICAgc2lkZV9kb3QyID0gZG90MjsKICAgICAgICAgICAgICBzaWRlX2ggPSBoOwogICAgICAgICAgICAgIHNpZGVfbnMuY29weShucyk7CiAgICAgICAgICAgICAgc2lkZV9uczEuY29weShuczEpOwogICAgICAgICAgICAgIHNpZGVfbnMyLmNvcHkobnMyKTsKICAgICAgICAgICAgICBzaWRlX3BlbmV0cmF0aW9ucysrOwoKICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHNpZGVfcGVuZXRyYXRpb25zKSB7CiAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgIHNpZGVfbnMuc2NhbGUoLVIsIHIucmkpOyAvLyBTcGhlcmUgcgoKICAgICAgICByLm5pLmNvcHkoc2lkZV9ucyk7CiAgICAgICAgci5uaS5uZWdhdGUoci5uaSk7IC8vIE5vcm1hbCBzaG91bGQgYmUgb3V0IG9mIHNwaGVyZQoKICAgICAgICBzaWRlX25zLnNjYWxlKHNpZGVfaCwgc2lkZV9ucyk7CiAgICAgICAgc2lkZV9uczEuc2NhbGUoc2lkZV9kb3QxLCBzaWRlX25zMSk7CiAgICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMxLCBzaWRlX25zKTsKICAgICAgICBzaWRlX25zMi5zY2FsZShzaWRlX2RvdDIsIHNpZGVfbnMyKTsKICAgICAgICBzaWRlX25zLnZhZGQoc2lkZV9uczIsIHIucmopOyAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwoKICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpOwogICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTsKICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopOwogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9IC8vIENoZWNrIGNvcm5lcnMKCgogICAgICBsZXQgcmogPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVCb3hfc3BoZXJlX3RvX2Nvcm5lcjsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSAyICYmICFmb3VuZDsgaisrKSB7CiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgIT09IDIgJiYgIWZvdW5kOyBrKyspIHsKICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsICE9PSAyICYmICFmb3VuZDsgbCsrKSB7CiAgICAgICAgICAgIHJqLnNldCgwLCAwLCAwKTsKCiAgICAgICAgICAgIGlmIChqKSB7CiAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1swXSwgcmopOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMF0sIHJqKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKGspIHsKICAgICAgICAgICAgICByai52YWRkKHNpZGVzWzFdLCByaik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmoudnN1YihzaWRlc1sxXSwgcmopOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAobCkgewogICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMl0sIHJqKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzJdLCByaik7CiAgICAgICAgICAgIH0gLy8gV29ybGQgcG9zaXRpb24gb2YgY29ybmVyCgoKICAgICAgICAgICAgeGoudmFkZChyaiwgc3BoZXJlX3RvX2Nvcm5lcik7CiAgICAgICAgICAgIHNwaGVyZV90b19jb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7CgogICAgICAgICAgICBpZiAoc3BoZXJlX3RvX2Nvcm5lci5sZW5ndGhTcXVhcmVkKCkgPCBSICogUikgewogICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICAgICAgci5yaS5jb3B5KHNwaGVyZV90b19jb3JuZXIpOwogICAgICAgICAgICAgIHIucmkubm9ybWFsaXplKCk7CiAgICAgICAgICAgICAgci5uaS5jb3B5KHIucmkpOwogICAgICAgICAgICAgIHIucmkuc2NhbGUoUiwgci5yaSk7CiAgICAgICAgICAgICAgci5yai5jb3B5KHJqKTsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXMKCiAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7CiAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsKICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdjNwb29sLnJlbGVhc2UocmopOwogICAgICByaiA9IG51bGw7IC8vIENoZWNrIGVkZ2VzCgogICAgICBjb25zdCBlZGdlVGFuZ2VudCA9IHYzcG9vbC5nZXQoKTsKICAgICAgY29uc3QgZWRnZUNlbnRlciA9IHYzcG9vbC5nZXQoKTsKICAgICAgY29uc3QgciA9IHYzcG9vbC5nZXQoKTsgLy8gciA9IGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXIKCiAgICAgIGNvbnN0IG9ydGhvZ29uYWwgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IGRpc3QgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IE5zaWRlcyA9IHNpZGVzLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBOc2lkZXMgJiYgIWZvdW5kOyBqKyspIHsKICAgICAgICBmb3IgKGxldCBrID0gMDsgayAhPT0gTnNpZGVzICYmICFmb3VuZDsgaysrKSB7CiAgICAgICAgICBpZiAoaiAlIDMgIT09IGsgJSAzKSB7CiAgICAgICAgICAgIC8vIEdldCBlZGdlIHRhbmdlbnQKICAgICAgICAgICAgc2lkZXNba10uY3Jvc3Moc2lkZXNbal0sIGVkZ2VUYW5nZW50KTsKICAgICAgICAgICAgZWRnZVRhbmdlbnQubm9ybWFsaXplKCk7CiAgICAgICAgICAgIHNpZGVzW2pdLnZhZGQoc2lkZXNba10sIGVkZ2VDZW50ZXIpOwogICAgICAgICAgICByLmNvcHkoeGkpOwogICAgICAgICAgICByLnZzdWIoZWRnZUNlbnRlciwgcik7CiAgICAgICAgICAgIHIudnN1Yih4aiwgcik7CiAgICAgICAgICAgIGNvbnN0IG9ydGhvbm9ybSA9IHIuZG90KGVkZ2VUYW5nZW50KTsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvbgoKICAgICAgICAgICAgZWRnZVRhbmdlbnQuc2NhbGUob3J0aG9ub3JtLCBvcnRob2dvbmFsKTsgLy8gVmVjdG9yIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb24KICAgICAgICAgICAgLy8gRmluZCB0aGUgdGhpcmQgc2lkZSBvcnRob2dvbmFsIHRvIHRoaXMgb25lCgogICAgICAgICAgICBsZXQgbCA9IDA7CgogICAgICAgICAgICB3aGlsZSAobCA9PT0gaiAlIDMgfHwgbCA9PT0gayAlIDMpIHsKICAgICAgICAgICAgICBsKys7CiAgICAgICAgICAgIH0gLy8gdmVjIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIHByb2plY3RlZCB0byB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byB0aGUgZWRnZSB0YW5nZW50CgoKICAgICAgICAgICAgZGlzdC5jb3B5KHhpKTsKICAgICAgICAgICAgZGlzdC52c3ViKG9ydGhvZ29uYWwsIGRpc3QpOwogICAgICAgICAgICBkaXN0LnZzdWIoZWRnZUNlbnRlciwgZGlzdCk7CiAgICAgICAgICAgIGRpc3QudnN1Yih4aiwgZGlzdCk7IC8vIERpc3RhbmNlcyBpbiB0YW5nZW50IGRpcmVjdGlvbiBhbmQgZGlzdGFuY2UgaW4gdGhlIHBsYW5lIG9ydGhvZ29uYWwgdG8gaXQKCiAgICAgICAgICAgIGNvbnN0IHRkaXN0ID0gTWF0aC5hYnMob3J0aG9ub3JtKTsKICAgICAgICAgICAgY29uc3QgbmRpc3QgPSBkaXN0Lmxlbmd0aCgpOwoKICAgICAgICAgICAgaWYgKHRkaXN0IDwgc2lkZXNbbF0ubGVuZ3RoKCkgJiYgbmRpc3QgPCBSKSB7CiAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTsKICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgICAgICAgIGVkZ2VDZW50ZXIudmFkZChvcnRob2dvbmFsLCByZXMucmopOyAvLyBib3ggcmoKCiAgICAgICAgICAgICAgcmVzLnJqLmNvcHkocmVzLnJqKTsKICAgICAgICAgICAgICBkaXN0Lm5lZ2F0ZShyZXMubmkpOwogICAgICAgICAgICAgIHJlcy5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICByZXMucmkuY29weShyZXMucmopOwogICAgICAgICAgICAgIHJlcy5yaS52YWRkKHhqLCByZXMucmkpOwogICAgICAgICAgICAgIHJlcy5yaS52c3ViKHhpLCByZXMucmkpOwogICAgICAgICAgICAgIHJlcy5yaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICByZXMucmkuc2NhbGUoUiwgcmVzLnJpKTsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXMKCiAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGksIHJlcy5yaSk7CiAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoYmkucG9zaXRpb24sIHJlcy5yaSk7CiAgICAgICAgICAgICAgcmVzLnJqLnZhZGQoeGosIHJlcy5yaik7CiAgICAgICAgICAgICAgcmVzLnJqLnZzdWIoYmoucG9zaXRpb24sIHJlcy5yaik7CiAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyZXMpOwogICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyZXMsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB2M3Bvb2wucmVsZWFzZShlZGdlVGFuZ2VudCwgZWRnZUNlbnRlciwgciwgb3J0aG9nb25hbCwgZGlzdCk7CiAgICB9CgogICAgcGxhbmVCb3goc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7CiAgICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uaWQgPSBzai5pZDsKICAgICAgcmV0dXJuIHRoaXMucGxhbmVDb252ZXgoc2ksIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgY29udmV4Q29udmV4KHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0LCBmYWNlTGlzdEEsIGZhY2VMaXN0QikgewogICAgICBjb25zdCBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7CgogICAgICBpZiAoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAoc2kuZmluZFNlcGFyYXRpbmdBeGlzKHNqLCB4aSwgcWksIHhqLCBxaiwgc2VwQXhpcywgZmFjZUxpc3RBLCBmYWNlTGlzdEIpKSB7CiAgICAgICAgY29uc3QgcmVzID0gW107CiAgICAgICAgY29uc3QgcSA9IGNvbnZleENvbnZleF9xOwogICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSwgcWksIHNqLCB4aiwgcWosIHNlcEF4aXMsIC0xMDAsIDEwMCwgcmVzKTsKICAgICAgICBsZXQgbnVtQ29udGFjdHMgPSAwOwoKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gcmVzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICBjb25zdCByaSA9IHIucmk7CiAgICAgICAgICBjb25zdCByaiA9IHIucmo7CiAgICAgICAgICBzZXBBeGlzLm5lZ2F0ZShyLm5pKTsKICAgICAgICAgIHJlc1tqXS5ub3JtYWwubmVnYXRlKHEpOwogICAgICAgICAgcS5zY2FsZShyZXNbal0uZGVwdGgsIHEpOwogICAgICAgICAgcmVzW2pdLnBvaW50LnZhZGQocSwgcmkpOwogICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpOyAvLyBDb250YWN0IHBvaW50cyBhcmUgaW4gd29ybGQgY29vcmRpbmF0ZXMuIFRyYW5zZm9ybSBiYWNrIHRvIHJlbGF0aXZlCgogICAgICAgICAgcmkudnN1Yih4aSwgcmkpOwogICAgICAgICAgcmoudnN1Yih4aiwgcmopOyAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwoKICAgICAgICAgIHJpLnZhZGQoeGksIHJpKTsKICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTsKICAgICAgICAgIHJqLnZhZGQoeGosIHJqKTsKICAgICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTsKICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICBudW1Db250YWN0cysrOwoKICAgICAgICAgIGlmICghdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikgewogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiBudW1Db250YWN0cykgewogICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBzcGhlcmVDb252ZXgoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgY29uc3QgdjNwb29sID0gdGhpcy52M3Bvb2w7CiAgICAgIHhpLnZzdWIoeGosIGNvbnZleF90b19zcGhlcmUpOwogICAgICBjb25zdCBub3JtYWxzID0gc2ouZmFjZU5vcm1hbHM7CiAgICAgIGNvbnN0IGZhY2VzID0gc2ouZmFjZXM7CiAgICAgIGNvbnN0IHZlcnRzID0gc2oudmVydGljZXM7CiAgICAgIGNvbnN0IFIgPSBzaS5yYWRpdXM7CiAgICAgIC8vICAgICByZXR1cm47CiAgICAgIC8vIH0KCiAgICAgIGxldCBmb3VuZCA9IGZhbHNlOyAvLyBDaGVjayBjb3JuZXJzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gdmVydHNbaV07IC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lcgoKICAgICAgICBjb25zdCB3b3JsZENvcm5lciA9IHNwaGVyZUNvbnZleF93b3JsZENvcm5lcjsKICAgICAgICBxai52bXVsdCh2LCB3b3JsZENvcm5lcik7CiAgICAgICAgeGoudmFkZCh3b3JsZENvcm5lciwgd29ybGRDb3JuZXIpOwogICAgICAgIGNvbnN0IHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXI7CiAgICAgICAgd29ybGRDb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7CgogICAgICAgIGlmIChzcGhlcmVfdG9fY29ybmVyLmxlbmd0aFNxdWFyZWQoKSA8IFIgKiBSKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7CiAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpOwogICAgICAgICAgci5uaS5jb3B5KHIucmkpOwogICAgICAgICAgci5yaS5zY2FsZShSLCByLnJpKTsKICAgICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGosIHIucmopOyAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuCgogICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTsKICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopOwogICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsKICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICB9IC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zCgoKICAgICAgZm9yIChsZXQgaSA9IDAsIG5mYWNlcyA9IGZhY2VzLmxlbmd0aDsgaSAhPT0gbmZhY2VzICYmIGZvdW5kID09PSBmYWxzZTsgaSsrKSB7CiAgICAgICAgY29uc3Qgbm9ybWFsID0gbm9ybWFsc1tpXTsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbaV07IC8vIEdldCB3b3JsZC10cmFuc2Zvcm1lZCBub3JtYWwgb2YgdGhlIGZhY2UKCiAgICAgICAgY29uc3Qgd29ybGROb3JtYWwgPSBzcGhlcmVDb252ZXhfd29ybGROb3JtYWw7CiAgICAgICAgcWoudm11bHQobm9ybWFsLCB3b3JsZE5vcm1hbCk7IC8vIEdldCBhIHdvcmxkIHZlcnRleCBmcm9tIHRoZSBmYWNlCgogICAgICAgIGNvbnN0IHdvcmxkUG9pbnQgPSBzcGhlcmVDb252ZXhfd29ybGRQb2ludDsKICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWzBdXSwgd29ybGRQb2ludCk7CiAgICAgICAgd29ybGRQb2ludC52YWRkKHhqLCB3b3JsZFBvaW50KTsgLy8gR2V0IGEgcG9pbnQgb24gdGhlIHNwaGVyZSwgY2xvc2VzdCB0byB0aGUgZmFjZSBub3JtYWwKCiAgICAgICAgY29uc3Qgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gc3BoZXJlQ29udmV4X3dvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZTsKICAgICAgICB3b3JsZE5vcm1hbC5zY2FsZSgtUiwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTsKICAgICAgICB4aS52YWRkKHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTsgLy8gVmVjdG9yIGZyb20gYSBmYWNlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzcGhlcmUKCiAgICAgICAgY29uc3QgcGVuZXRyYXRpb25WZWMgPSBzcGhlcmVDb252ZXhfcGVuZXRyYXRpb25WZWM7CiAgICAgICAgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lLnZzdWIod29ybGRQb2ludCwgcGVuZXRyYXRpb25WZWMpOyAvLyBUaGUgcGVuZXRyYXRpb24uIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIG92ZXJsYXAuCgogICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb25WZWMuZG90KHdvcmxkTm9ybWFsKTsKICAgICAgICBjb25zdCB3b3JsZFBvaW50VG9TcGhlcmUgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Xb3JsZFBvaW50OwogICAgICAgIHhpLnZzdWIod29ybGRQb2ludCwgd29ybGRQb2ludFRvU3BoZXJlKTsKCiAgICAgICAgaWYgKHBlbmV0cmF0aW9uIDwgMCAmJiB3b3JsZFBvaW50VG9TcGhlcmUuZG90KHdvcmxkTm9ybWFsKSA+IDApIHsKICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayBpZiB0aGUgc3BoZXJlIGlzIGluc2lkZSB0aGUgZmFjZSBwb2x5Z29uCiAgICAgICAgICBjb25zdCBmYWNlVmVydHMgPSBbXTsgLy8gRmFjZSB2ZXJ0aWNlcywgaW4gd29ybGQgY29vcmRzCgogICAgICAgICAgZm9yIChsZXQgaiA9IDAsIE52ZXJ0cyA9IGZhY2UubGVuZ3RoOyBqICE9PSBOdmVydHM7IGorKykgewogICAgICAgICAgICBjb25zdCB3b3JsZFZlcnRleCA9IHYzcG9vbC5nZXQoKTsKICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVtqXV0sIHdvcmxkVmVydGV4KTsKICAgICAgICAgICAgeGoudmFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpOwogICAgICAgICAgICBmYWNlVmVydHMucHVzaCh3b3JsZFZlcnRleCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKHBvaW50SW5Qb2x5Z29uKGZhY2VWZXJ0cywgd29ybGROb3JtYWwsIHhpKSkgewogICAgICAgICAgICAvLyBJcyB0aGUgc3BoZXJlIGNlbnRlciBpbiB0aGUgZmFjZSBwb2x5Z29uPwogICAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUoLVIsIHIucmkpOyAvLyBDb250YWN0IG9mZnNldCwgZnJvbSBzcGhlcmUgY2VudGVyIHRvIGNvbnRhY3QKCiAgICAgICAgICAgIHdvcmxkTm9ybWFsLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHBvaW50aW5nIG91dCBvZiBzcGhlcmUKCiAgICAgICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uVmVjMiA9IHYzcG9vbC5nZXQoKTsKICAgICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUoLXBlbmV0cmF0aW9uLCBwZW5ldHJhdGlvblZlYzIpOwogICAgICAgICAgICBjb25zdCBwZW5ldHJhdGlvblNwaGVyZVBvaW50ID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICB3b3JsZE5vcm1hbC5zY2FsZSgtUiwgcGVuZXRyYXRpb25TcGhlcmVQb2ludCk7IC8veGkudnN1Yih4aikudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50KS52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopOwoKICAgICAgICAgICAgeGkudnN1Yih4aiwgci5yaik7CiAgICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50LCByLnJqKTsKICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uVmVjMiwgci5yaik7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7CiAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7CiAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uVmVjMik7CiAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQpOwogICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7IC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXMKCiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBOZmFjZXZlcnRzID0gZmFjZVZlcnRzLmxlbmd0aDsgaiAhPT0gTmZhY2V2ZXJ0czsgaisrKSB7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBvbmx5IGV4cGVjdCAqb25lKiBmYWNlIGNvbnRhY3QKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIEVkZ2U/CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBmYWNlLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgICAgLy8gR2V0IHR3byB3b3JsZCB0cmFuc2Zvcm1lZCB2ZXJ0aWNlcwogICAgICAgICAgICAgIGNvbnN0IHYxID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIGNvbnN0IHYyID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbKGogKyAxKSAlIGZhY2UubGVuZ3RoXV0sIHYxKTsKICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqICsgMikgJSBmYWNlLmxlbmd0aF1dLCB2Mik7CiAgICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpOwogICAgICAgICAgICAgIHhqLnZhZGQodjIsIHYyKTsgLy8gQ29uc3RydWN0IGVkZ2UgdmVjdG9yCgogICAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBzcGhlcmVDb252ZXhfZWRnZTsKICAgICAgICAgICAgICB2Mi52c3ViKHYxLCBlZGdlKTsgLy8gQ29uc3RydWN0IHRoZSBzYW1lIHZlY3RvciwgYnV0IG5vcm1hbGl6ZWQKCiAgICAgICAgICAgICAgY29uc3QgZWRnZVVuaXQgPSBzcGhlcmVDb252ZXhfZWRnZVVuaXQ7CiAgICAgICAgICAgICAgZWRnZS51bml0KGVkZ2VVbml0KTsgLy8gcCBpcyB4aSBwcm9qZWN0ZWQgb250byB0aGUgZWRnZQoKICAgICAgICAgICAgICBjb25zdCBwID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIGNvbnN0IHYxX3RvX3hpID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIHhpLnZzdWIodjEsIHYxX3RvX3hpKTsKICAgICAgICAgICAgICBjb25zdCBkb3QgPSB2MV90b194aS5kb3QoZWRnZVVuaXQpOwogICAgICAgICAgICAgIGVkZ2VVbml0LnNjYWxlKGRvdCwgcCk7CiAgICAgICAgICAgICAgcC52YWRkKHYxLCBwKTsgLy8gQ29tcHV0ZSBhIHZlY3RvciBmcm9tIHAgdG8gdGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlCgogICAgICAgICAgICAgIGNvbnN0IHhpX3RvX3AgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTsgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1cwogICAgICAgICAgICAgIC8vIEFORCBpZiBwIGlzIGluIGJldHdlZW4gdjEgYW5kIHYyCgogICAgICAgICAgICAgIGlmIChkb3QgPiAwICYmIGRvdCAqIGRvdCA8IGVkZ2UubGVuZ3RoU3F1YXJlZCgpICYmIHhpX3RvX3AubGVuZ3RoU3F1YXJlZCgpIDwgUiAqIFIpIHsKICAgICAgICAgICAgICAgIC8vIENvbGxpc2lvbiBpZiB0aGUgZWRnZS1zcGhlcmUgZGlzdGFuY2UgaXMgbGVzcyB0aGFuIHRoZSByYWRpdXMKICAgICAgICAgICAgICAgIC8vIEVkZ2UgY29udGFjdCEKICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICAgICAgICAgIHAudnN1Yih4aiwgci5yaik7CiAgICAgICAgICAgICAgICBwLnZzdWIoeGksIHIubmkpOwogICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICAgIHIubmkuc2NhbGUoUiwgci5yaSk7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopOwogICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LgoKICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7CiAgICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlcwoKICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBOZmFjZXZlcnRzID0gZmFjZVZlcnRzLmxlbmd0aDsgaiAhPT0gTmZhY2V2ZXJ0czsgaisrKSB7CiAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpOwogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpOwogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7CiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTsKICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTsKICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2Mik7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjFfdG9feGkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXMKCgogICAgICAgICAgZm9yIChsZXQgaiA9IDAsIE5mYWNldmVydHMgPSBmYWNlVmVydHMubGVuZ3RoOyBqICE9PSBOZmFjZXZlcnRzOyBqKyspIHsKICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBwbGFuZUNvbnZleChwbGFuZVNoYXBlLCBjb252ZXhTaGFwZSwgcGxhbmVQb3NpdGlvbiwgY29udmV4UG9zaXRpb24sIHBsYW5lUXVhdCwgY29udmV4UXVhdCwgcGxhbmVCb2R5LCBjb252ZXhCb2R5LCBzaSwgc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFNpbXBseSByZXR1cm4gdGhlIHBvaW50cyBiZWhpbmQgdGhlIHBsYW5lLgogICAgICBjb25zdCB3b3JsZFZlcnRleCA9IHBsYW5lQ29udmV4X3Y7CiAgICAgIGNvbnN0IHdvcmxkTm9ybWFsID0gcGxhbmVDb252ZXhfbm9ybWFsOwogICAgICB3b3JsZE5vcm1hbC5zZXQoMCwgMCwgMSk7CiAgICAgIHBsYW5lUXVhdC52bXVsdCh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmUgb3JpZW50YXRpb24KCiAgICAgIGxldCBudW1Db250YWN0cyA9IDA7CiAgICAgIGNvbnN0IHJlbHBvcyA9IHBsYW5lQ29udmV4X3JlbHBvczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBjb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKykgewogICAgICAgIC8vIEdldCB3b3JsZCBjb252ZXggdmVydGV4CiAgICAgICAgd29ybGRWZXJ0ZXguY29weShjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXSk7CiAgICAgICAgY29udmV4UXVhdC52bXVsdCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpOwogICAgICAgIGNvbnZleFBvc2l0aW9uLnZhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTsKICAgICAgICB3b3JsZFZlcnRleC52c3ViKHBsYW5lUG9zaXRpb24sIHJlbHBvcyk7CiAgICAgICAgY29uc3QgZG90ID0gd29ybGROb3JtYWwuZG90KHJlbHBvcyk7CgogICAgICAgIGlmIChkb3QgPD0gMC4wKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSwgY29udmV4Qm9keSwgcGxhbmVTaGFwZSwgY29udmV4U2hhcGUsIHNpLCBzaik7IC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lCgogICAgICAgICAgY29uc3QgcHJvamVjdGVkID0gcGxhbmVDb252ZXhfcHJvamVjdGVkOwogICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUod29ybGROb3JtYWwuZG90KHJlbHBvcyksIHByb2plY3RlZCk7CiAgICAgICAgICB3b3JsZFZlcnRleC52c3ViKHByb2plY3RlZCwgcHJvamVjdGVkKTsKICAgICAgICAgIHByb2plY3RlZC52c3ViKHBsYW5lUG9zaXRpb24sIHIucmkpOyAvLyBGcm9tIHBsYW5lIHRvIHZlcnRleCBwcm9qZWN0ZWQgb24gcGxhbmUKCiAgICAgICAgICByLm5pLmNvcHkod29ybGROb3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsIG91dCBmcm9tIHBsYW5lCiAgICAgICAgICAvLyByaiBpcyBub3cganVzdCB0aGUgdmVjdG9yIGZyb20gdGhlIGNvbnZleCBjZW50ZXIgdG8gdGhlIHZlcnRleAoKICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIoY29udmV4UG9zaXRpb24sIHIucmopOyAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5CgogICAgICAgICAgci5yaS52YWRkKHBsYW5lUG9zaXRpb24sIHIucmkpOwogICAgICAgICAgci5yaS52c3ViKHBsYW5lQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICByLnJqLnZhZGQoY29udmV4UG9zaXRpb24sIHIucmopOwogICAgICAgICAgci5yai52c3ViKGNvbnZleEJvZHkucG9zaXRpb24sIHIucmopOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIG51bUNvbnRhY3RzKys7CgogICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7CiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIG51bUNvbnRhY3RzKSB7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTsKICAgICAgfQogICAgfQoKICAgIGJveENvbnZleChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBzcGhlcmVIZWlnaHRmaWVsZChzcGhlcmVTaGFwZSwgaGZTaGFwZSwgc3BoZXJlUG9zLCBoZlBvcywgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBkYXRhID0gaGZTaGFwZS5kYXRhOwogICAgICBjb25zdCByYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXM7CiAgICAgIGNvbnN0IHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplOwogICAgICBjb25zdCB3b3JsZFBpbGxhck9mZnNldCA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDI7IC8vIEdldCBzcGhlcmUgcG9zaXRpb24gdG8gaGVpZ2h0ZmllbGQgbG9jYWwhCgogICAgICBjb25zdCBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDE7CiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBzcGhlcmVQb3MsIGxvY2FsU3BoZXJlUG9zKTsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0CgogICAgICBsZXQgaU1pblggPSBNYXRoLmZsb29yKChsb2NhbFNwaGVyZVBvcy54IC0gcmFkaXVzKSAvIHcpIC0gMTsKICAgICAgbGV0IGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy54ICsgcmFkaXVzKSAvIHcpICsgMTsKICAgICAgbGV0IGlNaW5ZID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueSAtIHJhZGl1cykgLyB3KSAtIDE7CiAgICAgIGxldCBpTWF4WSA9IE1hdGguY2VpbCgobG9jYWxTcGhlcmVQb3MueSArIHJhZGl1cykgLyB3KSArIDE7IC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW4KCiAgICAgIGlmIChpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBDbGFtcCBpbmRleCB0byBlZGdlcwoKCiAgICAgIGlmIChpTWluWCA8IDApIHsKICAgICAgICBpTWluWCA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WCA8IDApIHsKICAgICAgICBpTWF4WCA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWSA8IDApIHsKICAgICAgICBpTWluWSA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WSA8IDApIHsKICAgICAgICBpTWF4WSA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWCA+PSBkYXRhLmxlbmd0aCkgewogICAgICAgIGlNaW5YID0gZGF0YS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBpZiAoaU1heFggPj0gZGF0YS5sZW5ndGgpIHsKICAgICAgICBpTWF4WCA9IGRhdGEubGVuZ3RoIC0gMTsKICAgICAgfQoKICAgICAgaWYgKGlNYXhZID49IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgaU1heFkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWSA+PSBkYXRhWzBdLmxlbmd0aCkgewogICAgICAgIGlNaW5ZID0gZGF0YVswXS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBjb25zdCBtaW5NYXggPSBbXTsKICAgICAgaGZTaGFwZS5nZXRSZWN0TWluTWF4KGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCBtaW5NYXgpOwogICAgICBjb25zdCBtaW4gPSBtaW5NYXhbMF07CiAgICAgIGNvbnN0IG1heCA9IG1pbk1heFsxXTsgLy8gQmFpbCBvdXQgaWYgd2UgY2FuJ3QgdG91Y2ggdGhlIGJvdW5kaW5nIGhlaWdodCBib3gKCiAgICAgIGlmIChsb2NhbFNwaGVyZVBvcy56IC0gcmFkaXVzID4gbWF4IHx8IGxvY2FsU3BoZXJlUG9zLnogKyByYWRpdXMgPCBtaW4pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0OwoKICAgICAgZm9yIChsZXQgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspIHsKICAgICAgICAgIGNvbnN0IG51bUNvbnRhY3RzQmVmb3JlID0gcmVzdWx0Lmxlbmd0aDsKICAgICAgICAgIGxldCBpbnRlcnNlY3RpbmcgPSBmYWxzZTsgLy8gTG93ZXIgdHJpYW5nbGUKCiAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBqdXN0VGVzdCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZykgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0gLy8gVXBwZXIgdHJpYW5nbGUKCgogICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBqdXN0VGVzdCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZykgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCBudW1Db250YWN0cyA9IHJlc3VsdC5sZW5ndGggLSBudW1Db250YWN0c0JlZm9yZTsKCiAgICAgICAgICBpZiAobnVtQ29udGFjdHMgPiAyKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIC8qCiAgICAgICAgICAgIC8vIFNraXAgYWxsIGJ1dCAxCiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbnVtQ29udGFjdHMgLSAxOyBrKyspIHsKICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgKi8KCiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgYm94SGVpZ2h0ZmllbGQoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICByZXR1cm4gdGhpcy5jb252ZXhIZWlnaHRmaWVsZChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBjb252ZXhIZWlnaHRmaWVsZChjb252ZXhTaGFwZSwgaGZTaGFwZSwgY29udmV4UG9zLCBoZlBvcywgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBkYXRhID0gaGZTaGFwZS5kYXRhOwogICAgICBjb25zdCB3ID0gaGZTaGFwZS5lbGVtZW50U2l6ZTsKICAgICAgY29uc3QgcmFkaXVzID0gY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXM7CiAgICAgIGNvbnN0IHdvcmxkUGlsbGFyT2Zmc2V0ID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMjsKICAgICAgY29uc3QgZmFjZUxpc3QgPSBjb252ZXhIZWlnaHRmaWVsZF9mYWNlTGlzdDsgLy8gR2V0IHNwaGVyZSBwb3NpdGlvbiB0byBoZWlnaHRmaWVsZCBsb2NhbCEKCiAgICAgIGNvbnN0IGxvY2FsQ29udmV4UG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMTsKICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKGhmUG9zLCBoZlF1YXQsIGNvbnZleFBvcywgbG9jYWxDb252ZXhQb3MpOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3QKCiAgICAgIGxldCBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnggLSByYWRpdXMpIC8gdykgLSAxOwogICAgICBsZXQgaU1heFggPSBNYXRoLmNlaWwoKGxvY2FsQ29udmV4UG9zLnggKyByYWRpdXMpIC8gdykgKyAxOwogICAgICBsZXQgaU1pblkgPSBNYXRoLmZsb29yKChsb2NhbENvbnZleFBvcy55IC0gcmFkaXVzKSAvIHcpIC0gMTsKICAgICAgbGV0IGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTsgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpbgoKICAgICAgaWYgKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWluWSA+IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzCgoKICAgICAgaWYgKGlNaW5YIDwgMCkgewogICAgICAgIGlNaW5YID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNYXhYIDwgMCkgewogICAgICAgIGlNYXhYID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNaW5ZIDwgMCkgewogICAgICAgIGlNaW5ZID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNYXhZIDwgMCkgewogICAgICAgIGlNYXhZID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNaW5YID49IGRhdGEubGVuZ3RoKSB7CiAgICAgICAgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WCA+PSBkYXRhLmxlbmd0aCkgewogICAgICAgIGlNYXhYID0gZGF0YS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBpZiAoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpIHsKICAgICAgICBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsKICAgICAgfQoKICAgICAgaWYgKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGNvbnN0IG1pbk1heCA9IFtdOwogICAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7CiAgICAgIGNvbnN0IG1pbiA9IG1pbk1heFswXTsKICAgICAgY29uc3QgbWF4ID0gbWluTWF4WzFdOyAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94CgogICAgICBpZiAobG9jYWxDb252ZXhQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbENvbnZleFBvcy56ICsgcmFkaXVzIDwgbWluKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKykgewogICAgICAgICAgbGV0IGludGVyc2VjdGluZyA9IGZhbHNlOyAvLyBMb3dlciB0cmlhbmdsZQoKICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwganVzdFRlc3QsIGZhY2VMaXN0LCBudWxsKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSAvLyBVcHBlciB0cmlhbmdsZQoKCiAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwganVzdFRlc3QsIGZhY2VMaXN0LCBudWxsKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIHNwaGVyZVBhcnRpY2xlKHNqLCBzaSwgeGosIHhpLCBxaiwgcWksIGJqLCBiaSwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFRoZSBub3JtYWwgaXMgdGhlIHVuaXQgdmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBwYXJ0aWNsZSBjZW50ZXIKICAgICAgY29uc3Qgbm9ybWFsID0gcGFydGljbGVTcGhlcmVfbm9ybWFsOwogICAgICBub3JtYWwuc2V0KDAsIDAsIDEpOwogICAgICB4aS52c3ViKHhqLCBub3JtYWwpOwogICAgICBjb25zdCBsZW5ndGhTcXVhcmVkID0gbm9ybWFsLmxlbmd0aFNxdWFyZWQoKTsKCiAgICAgIGlmIChsZW5ndGhTcXVhcmVkIDw9IHNqLnJhZGl1cyAqIHNqLnJhZGl1cykgewogICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQoKICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7CiAgICAgICAgci5yai5jb3B5KG5vcm1hbCk7CiAgICAgICAgci5yai5zY2FsZShzai5yYWRpdXMsIHIucmopOwogICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsKICAgICAgICByLnJpLnNldCgwLCAwLCAwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlCgogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9CiAgICB9CgogICAgcGxhbmVQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBub3JtYWwgPSBwYXJ0aWNsZVBsYW5lX25vcm1hbDsKICAgICAgbm9ybWFsLnNldCgwLCAwLCAxKTsKICAgICAgYmoucXVhdGVybmlvbi52bXVsdChub3JtYWwsIG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZSBvcmllbnRhdGlvbgoKICAgICAgY29uc3QgcmVscG9zID0gcGFydGljbGVQbGFuZV9yZWxwb3M7CiAgICAgIHhpLnZzdWIoYmoucG9zaXRpb24sIHJlbHBvcyk7CiAgICAgIGNvbnN0IGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTsKCiAgICAgIGlmIChkb3QgPD0gMC4wKSB7CiAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsCgogICAgICAgIHIubmkubmVnYXRlKHIubmkpOwogICAgICAgIHIucmkuc2V0KDAsIDAsIDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGUKICAgICAgICAvLyBHZXQgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lCgogICAgICAgIGNvbnN0IHByb2plY3RlZCA9IHBhcnRpY2xlUGxhbmVfcHJvamVjdGVkOwogICAgICAgIG5vcm1hbC5zY2FsZShub3JtYWwuZG90KHhpKSwgcHJvamVjdGVkKTsKICAgICAgICB4aS52c3ViKHByb2plY3RlZCwgcHJvamVjdGVkKTsgLy9wcm9qZWN0ZWQudmFkZChiai5wb3NpdGlvbixwcm9qZWN0ZWQpOwogICAgICAgIC8vIHJqIGlzIG5vdyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uCgogICAgICAgIHIucmouY29weShwcm9qZWN0ZWQpOwogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9CiAgICB9CgogICAgYm94UGFydGljbGUoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICByZXR1cm4gdGhpcy5jb252ZXhQYXJ0aWNsZShzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBjb252ZXhQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBsZXQgcGVuZXRyYXRlZEZhY2VJbmRleCA9IC0xOwogICAgICBjb25zdCBwZW5ldHJhdGVkRmFjZU5vcm1hbCA9IGNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsOwogICAgICBjb25zdCB3b3JsZFBlbmV0cmF0aW9uVmVjID0gY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYzsKICAgICAgbGV0IG1pblBlbmV0cmF0aW9uID0gbnVsbDsKCiAgICAgIGNvbnN0IGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7CiAgICAgIGxvY2FsLmNvcHkoeGkpOwogICAgICBsb2NhbC52c3ViKHhqLCBsb2NhbCk7IC8vIENvbnZlcnQgcG9zaXRpb24gdG8gcmVsYXRpdmUgdGhlIGNvbnZleCBvcmlnaW4KCiAgICAgIHFqLmNvbmp1Z2F0ZShjcWopOwogICAgICBjcWoudm11bHQobG9jYWwsIGxvY2FsKTsKCiAgICAgIGlmIChzai5wb2ludElzSW5zaWRlKGxvY2FsKSkgewogICAgICAgIGlmIChzai53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUpIHsKICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHhqLCBxaik7CiAgICAgICAgfQoKICAgICAgICBpZiAoc2oud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlKSB7CiAgICAgICAgICBzai5jb21wdXRlV29ybGRGYWNlTm9ybWFscyhxaik7CiAgICAgICAgfSAvLyBGb3IgZWFjaCB3b3JsZCBwb2x5Z29uIGluIHRoZSBwb2x5aGVkcmEKCgogICAgICAgIGZvciAobGV0IGkgPSAwLCBuZmFjZXMgPSBzai5mYWNlcy5sZW5ndGg7IGkgIT09IG5mYWNlczsgaSsrKSB7CiAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlcwogICAgICAgICAgY29uc3QgdmVydHMgPSBbc2oud29ybGRWZXJ0aWNlc1tzai5mYWNlc1tpXVswXV1dOwogICAgICAgICAgY29uc3Qgbm9ybWFsID0gc2oud29ybGRGYWNlTm9ybWFsc1tpXTsgLy8gQ2hlY2sgaG93IG11Y2ggdGhlIHBhcnRpY2xlIHBlbmV0cmF0ZXMgdGhlIHBvbHlnb24gcGxhbmUuCgogICAgICAgICAgeGkudnN1Yih2ZXJ0c1swXSwgY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7CiAgICAgICAgICBjb25zdCBwZW5ldHJhdGlvbiA9IC1ub3JtYWwuZG90KGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUpOwoKICAgICAgICAgIGlmIChtaW5QZW5ldHJhdGlvbiA9PT0gbnVsbCB8fCBNYXRoLmFicyhwZW5ldHJhdGlvbikgPCBNYXRoLmFicyhtaW5QZW5ldHJhdGlvbikpIHsKICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIG1pblBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247CiAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSBpOwogICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5jb3B5KG5vcm1hbCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAocGVuZXRyYXRlZEZhY2VJbmRleCAhPT0gLTEpIHsKICAgICAgICAgIC8vIFNldHVwIGNvbnRhY3QKICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwuc2NhbGUobWluUGVuZXRyYXRpb24sIHdvcmxkUGVuZXRyYXRpb25WZWMpOyAvLyByaiBpcyB0aGUgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIHRvIHRoZSBmYWNlCgogICAgICAgICAgd29ybGRQZW5ldHJhdGlvblZlYy52YWRkKHhpLCB3b3JsZFBlbmV0cmF0aW9uVmVjKTsKICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aiwgd29ybGRQZW5ldHJhdGlvblZlYyk7CiAgICAgICAgICByLnJqLmNvcHkod29ybGRQZW5ldHJhdGlvblZlYyk7IC8vY29uc3QgcHJvamVjdGVkVG9GYWNlID0geGkudnN1Yih4aikudmFkZCh3b3JsZFBlbmV0cmF0aW9uVmVjKTsKICAgICAgICAgIC8vcHJvamVjdGVkVG9GYWNlLmNvcHkoci5yaik7CiAgICAgICAgICAvL3FqLnZtdWx0KHIucmosci5yaik7CgogICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwubmVnYXRlKHIubmkpOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgICAgIHIucmkuc2V0KDAsIDAsIDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGUKCiAgICAgICAgICBjb25zdCByaSA9IHIucmk7CiAgICAgICAgICBjb25zdCByaiA9IHIucmo7IC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzCgogICAgICAgICAgcmkudmFkZCh4aSwgcmkpOwogICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpOwogICAgICAgICAgcmoudmFkZCh4aiwgcmopOwogICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc29sZS53YXJuKCdQb2ludCBmb3VuZCBpbnNpZGUgY29udmV4LCBidXQgZGlkIG5vdCBmaW5kIHBlbmV0cmF0aW5nIGZhY2UhJyk7CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgaGVpZ2h0ZmllbGRDeWxpbmRlcihoZlNoYXBlLCBjb252ZXhTaGFwZSwgaGZQb3MsIGNvbnZleFBvcywgaGZRdWF0LCBjb252ZXhRdWF0LCBoZkJvZHksIGNvbnZleEJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhIZWlnaHRmaWVsZChjb252ZXhTaGFwZSwgaGZTaGFwZSwgY29udmV4UG9zLCBoZlBvcywgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgcGFydGljbGVDeWxpbmRlcihzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgc3BoZXJlVHJpbWVzaChzcGhlcmVTaGFwZSwgdHJpbWVzaFNoYXBlLCBzcGhlcmVQb3MsIHRyaW1lc2hQb3MsIHNwaGVyZVF1YXQsIHRyaW1lc2hRdWF0LCBzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGNvbnN0IGVkZ2VWZXJ0ZXhBID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QTsKICAgICAgY29uc3QgZWRnZVZlcnRleEIgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCOwogICAgICBjb25zdCBlZGdlVmVjdG9yID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yOwogICAgICBjb25zdCBlZGdlVmVjdG9yVW5pdCA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQ7CiAgICAgIGNvbnN0IGxvY2FsU3BoZXJlUG9zID0gc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZVBvczsKICAgICAgY29uc3QgdG1wID0gc3BoZXJlVHJpbWVzaF90bXA7CiAgICAgIGNvbnN0IGxvY2FsU3BoZXJlQUFCQiA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVBQUJCOwogICAgICBjb25zdCB2MiA9IHNwaGVyZVRyaW1lc2hfdjI7CiAgICAgIGNvbnN0IHJlbHBvcyA9IHNwaGVyZVRyaW1lc2hfcmVscG9zOwogICAgICBjb25zdCB0cmlhbmdsZXMgPSBzcGhlcmVUcmltZXNoX3RyaWFuZ2xlczsgLy8gQ29udmVydCBzcGhlcmUgcG9zaXRpb24gdG8gbG9jYWwgaW4gdGhlIHRyaW1lc2gKCiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgc3BoZXJlUG9zLCBsb2NhbFNwaGVyZVBvcyk7IC8vIEdldCB0aGUgYWFiYiBvZiB0aGUgc3BoZXJlIGxvY2FsbHkgaW4gdGhlIHRyaW1lc2gKCiAgICAgIGNvbnN0IHNwaGVyZVJhZGl1cyA9IHNwaGVyZVNoYXBlLnJhZGl1czsKICAgICAgbG9jYWxTcGhlcmVBQUJCLmxvd2VyQm91bmQuc2V0KGxvY2FsU3BoZXJlUG9zLnggLSBzcGhlcmVSYWRpdXMsIGxvY2FsU3BoZXJlUG9zLnkgLSBzcGhlcmVSYWRpdXMsIGxvY2FsU3BoZXJlUG9zLnogLSBzcGhlcmVSYWRpdXMpOwogICAgICBsb2NhbFNwaGVyZUFBQkIudXBwZXJCb3VuZC5zZXQobG9jYWxTcGhlcmVQb3MueCArIHNwaGVyZVJhZGl1cywgbG9jYWxTcGhlcmVQb3MueSArIHNwaGVyZVJhZGl1cywgbG9jYWxTcGhlcmVQb3MueiArIHNwaGVyZVJhZGl1cyk7CiAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZXNJbkFBQkIobG9jYWxTcGhlcmVBQUJCLCB0cmlhbmdsZXMpOyAvL2ZvciAobGV0IGkgPSAwOyBpIDwgdHJpbWVzaFNoYXBlLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB0cmlhbmdsZXMucHVzaChpKTsgLy8gQWxsCiAgICAgIC8vIFZlcnRpY2VzCgogICAgICBjb25zdCB2ID0gc3BoZXJlVHJpbWVzaF92OwogICAgICBjb25zdCByYWRpdXNTcXVhcmVkID0gc3BoZXJlU2hhcGUucmFkaXVzICogc3BoZXJlU2hhcGUucmFkaXVzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykgewogICAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgal0sIHYpOyAvLyBDaGVjayB2ZXJ0ZXggb3ZlcmxhcCBpbiBzcGhlcmUKCiAgICAgICAgICB2LnZzdWIobG9jYWxTcGhlcmVQb3MsIHJlbHBvcyk7CgogICAgICAgICAgaWYgKHJlbHBvcy5sZW5ndGhTcXVhcmVkKCkgPD0gcmFkaXVzU3F1YXJlZCkgewogICAgICAgICAgICAvLyBTYWZlIHVwCiAgICAgICAgICAgIHYyLmNvcHkodik7CiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpOwogICAgICAgICAgICB2LnZzdWIoc3BoZXJlUG9zLCByZWxwb3MpOwoKICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGxldCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUsIHJzaSwgcnNqKTsKICAgICAgICAgICAgci5uaS5jb3B5KHJlbHBvcyk7CiAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7IC8vIHJpIGlzIHRoZSB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHRoZSBzcGhlcmUgc3VyZmFjZQoKICAgICAgICAgICAgci5yaS5jb3B5KHIubmkpOwogICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7CiAgICAgICAgICAgIHIucmkudmFkZChzcGhlcmVQb3MsIHIucmkpOwogICAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgIHIucmouY29weSh2KTsKICAgICAgICAgICAgci5yai52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTsgLy8gU3RvcmUgcmVzdWx0CgogICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIENoZWNrIGFsbCBlZGdlcwoKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHsKICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCBlZGdlVmVydGV4QSk7CiAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyAoaiArIDEpICUgM10sIGVkZ2VWZXJ0ZXhCKTsKICAgICAgICAgIGVkZ2VWZXJ0ZXhCLnZzdWIoZWRnZVZlcnRleEEsIGVkZ2VWZWN0b3IpOyAvLyBQcm9qZWN0IHNwaGVyZSBwb3NpdGlvbiB0byB0aGUgZWRnZQoKICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7CiAgICAgICAgICBjb25zdCBwb3NpdGlvbkFsb25nRWRnZUIgPSB0bXAuZG90KGVkZ2VWZWN0b3IpOwogICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTsKICAgICAgICAgIGxldCBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpOwoKICAgICAgICAgIGlmIChwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApIHsKICAgICAgICAgICAgLy8gTm93IGNoZWNrIHRoZSBvcnRob2dvbmFsIGRpc3RhbmNlIGZyb20gZWRnZSB0byBzcGhlcmUgY2VudGVyCiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEEsIHRtcCk7CiAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0LmNvcHkoZWRnZVZlY3Rvcik7CiAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0Lm5vcm1hbGl6ZSgpOwogICAgICAgICAgICBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3JVbml0KTsKICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQuc2NhbGUocG9zaXRpb25BbG9uZ0VkZ2VBLCB0bXApOwogICAgICAgICAgICB0bXAudmFkZChlZGdlVmVydGV4QSwgdG1wKTsgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIGNlbnRlciBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2UsIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgdHJpbWVzaCBmcmFtZQoKICAgICAgICAgICAgY29uc3QgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTsKCiAgICAgICAgICAgIGlmIChkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKSB7CiAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgcnNpLCByc2opOwogICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTsKICAgICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZhZGQoc3BoZXJlUG9zLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7CiAgICAgICAgICAgICAgdG1wLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopOwogICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIubmksIHIubmkpOwogICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpOwogICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIFRyaWFuZ2xlIGZhY2VzCgoKICAgICAgY29uc3QgdmEgPSBzcGhlcmVUcmltZXNoX3ZhOwogICAgICBjb25zdCB2YiA9IHNwaGVyZVRyaW1lc2hfdmI7CiAgICAgIGNvbnN0IHZjID0gc3BoZXJlVHJpbWVzaF92YzsKICAgICAgY29uc3Qgbm9ybWFsID0gc3BoZXJlVHJpbWVzaF9ub3JtYWw7CgogICAgICBmb3IgKGxldCBpID0gMCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgIT09IE47IGkrKykgewogICAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZVZlcnRpY2VzKHRyaWFuZ2xlc1tpXSwgdmEsIHZiLCB2Yyk7CiAgICAgICAgdHJpbWVzaFNoYXBlLmdldE5vcm1hbCh0cmlhbmdsZXNbaV0sIG5vcm1hbCk7CiAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1Yih2YSwgdG1wKTsKICAgICAgICBsZXQgZGlzdCA9IHRtcC5kb3Qobm9ybWFsKTsKICAgICAgICBub3JtYWwuc2NhbGUoZGlzdCwgdG1wKTsKICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHRtcCwgdG1wKTsgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgdHJpYW5nbGUgcGxhbmUKCiAgICAgICAgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTsKCiAgICAgICAgaWYgKFJheS5wb2ludEluVHJpYW5nbGUodG1wLCB2YSwgdmIsIHZjKSAmJiBkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgbGV0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgcnNpLCByc2opOwogICAgICAgICAgdG1wLnZzdWIobG9jYWxTcGhlcmVQb3MsIHIubmkpOwogICAgICAgICAgci5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTsKICAgICAgICAgIHIucmkudmFkZChzcGhlcmVQb3MsIHIucmkpOwogICAgICAgICAgci5yaS52c3ViKHNwaGVyZUJvZHkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7CiAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7CiAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLm5pLCByLm5pKTsKICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwOwogICAgfQoKICAgIHBsYW5lVHJpbWVzaChwbGFuZVNoYXBlLCB0cmltZXNoU2hhcGUsIHBsYW5lUG9zLCB0cmltZXNoUG9zLCBwbGFuZVF1YXQsIHRyaW1lc2hRdWF0LCBwbGFuZUJvZHksIHRyaW1lc2hCb2R5LCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgLy8gTWFrZSBjb250YWN0cyEKICAgICAgY29uc3QgdiA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IG5vcm1hbCA9IHBsYW5lVHJpbWVzaF9ub3JtYWw7CiAgICAgIG5vcm1hbC5zZXQoMCwgMCwgMSk7CiAgICAgIHBsYW5lUXVhdC52bXVsdChub3JtYWwsIG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmltZXNoU2hhcGUudmVydGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgLy8gR2V0IHdvcmxkIHZlcnRleCBmcm9tIHRyaW1lc2gKICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KGksIHYpOyAvLyBTYWZlIHVwCgogICAgICAgIGNvbnN0IHYyID0gbmV3IFZlYzMoKTsKICAgICAgICB2Mi5jb3B5KHYpOwogICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpOyAvLyBDaGVjayBwbGFuZSBzaWRlCgogICAgICAgIGNvbnN0IHJlbHBvcyA9IHBsYW5lVHJpbWVzaF9yZWxwb3M7CiAgICAgICAgdi52c3ViKHBsYW5lUG9zLCByZWxwb3MpOwogICAgICAgIGNvbnN0IGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTsKCiAgICAgICAgaWYgKGRvdCA8PSAwLjApIHsKICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCB0cmltZXNoQm9keSwgcGxhbmVTaGFwZSwgdHJpbWVzaFNoYXBlLCByc2ksIHJzaik7CiAgICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbAogICAgICAgICAgLy8gR2V0IHZlcnRleCBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmUKCiAgICAgICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwbGFuZVRyaW1lc2hfcHJvamVjdGVkOwogICAgICAgICAgbm9ybWFsLnNjYWxlKHJlbHBvcy5kb3Qobm9ybWFsKSwgcHJvamVjdGVkKTsKICAgICAgICAgIHYudnN1Yihwcm9qZWN0ZWQsIHByb2plY3RlZCk7IC8vIHJpIGlzIHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb24KCiAgICAgICAgICByLnJpLmNvcHkocHJvamVjdGVkKTsKICAgICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgci5yai5jb3B5KHYpOwogICAgICAgICAgci5yai52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTsgLy8gU3RvcmUgcmVzdWx0CgogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gLy8gY29udmV4VHJpbWVzaCgKICAgIC8vICAgc2k6IENvbnZleFBvbHloZWRyb24sIHNqOiBUcmltZXNoLCB4aTogVmVjMywgeGo6IFZlYzMsIHFpOiBRdWF0ZXJuaW9uLCBxajogUXVhdGVybmlvbiwKICAgIC8vICAgYmk6IEJvZHksIGJqOiBCb2R5LCByc2k/OiBTaGFwZSB8IG51bGwsIHJzaj86IFNoYXBlIHwgbnVsbCwKICAgIC8vICAgZmFjZUxpc3RBPzogbnVtYmVyW10gfCBudWxsLCBmYWNlTGlzdEI/OiBudW1iZXJbXSB8IG51bGwsCiAgICAvLyApIHsKICAgIC8vICAgY29uc3Qgc2VwQXhpcyA9IGNvbnZleENvbnZleF9zZXBBeGlzOwogICAgLy8gICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpewogICAgLy8gICAgICAgcmV0dXJuOwogICAgLy8gICB9CiAgICAvLyAgIC8vIENvbnN0cnVjdCBhIHRlbXAgaHVsbCBmb3IgZWFjaCB0cmlhbmdsZQogICAgLy8gICBjb25zdCBodWxsQiA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAvLyAgIGh1bGxCLmZhY2VzID0gW1swLDEsMl1dOwogICAgLy8gICBjb25zdCB2YSA9IG5ldyBWZWMzKCk7CiAgICAvLyAgIGNvbnN0IHZiID0gbmV3IFZlYzMoKTsKICAgIC8vICAgY29uc3QgdmMgPSBuZXcgVmVjMygpOwogICAgLy8gICBodWxsQi52ZXJ0aWNlcyA9IFsKICAgIC8vICAgICAgIHZhLAogICAgLy8gICAgICAgdmIsCiAgICAvLyAgICAgICB2YwogICAgLy8gICBdOwogICAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IHNqLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAvLyAgICAgICBjb25zdCB0cmlhbmdsZU5vcm1hbCA9IG5ldyBWZWMzKCk7CiAgICAvLyAgICAgICBzai5nZXROb3JtYWwoaSwgdHJpYW5nbGVOb3JtYWwpOwogICAgLy8gICAgICAgaHVsbEIuZmFjZU5vcm1hbHMgPSBbdHJpYW5nbGVOb3JtYWxdOwogICAgLy8gICAgICAgc2ouZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCB2YSwgdmIsIHZjKTsKICAgIC8vICAgICAgIGxldCBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7CiAgICAvLyAgICAgICBpZighZCl7CiAgICAvLyAgICAgICAgICAgdHJpYW5nbGVOb3JtYWwuc2NhbGUoLTEsIHRyaWFuZ2xlTm9ybWFsKTsKICAgIC8vICAgICAgICAgICBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7CiAgICAvLyAgICAgICAgICAgaWYoIWQpewogICAgLy8gICAgICAgICAgICAgICBjb250aW51ZTsKICAgIC8vICAgICAgICAgICB9CiAgICAvLyAgICAgICB9CiAgICAvLyAgICAgICBjb25zdCByZXM6IENvbnZleFBvbHloZWRyb25Db250YWN0UG9pbnRbXSA9IFtdOwogICAgLy8gICAgICAgY29uc3QgcSA9IGNvbnZleENvbnZleF9xOwogICAgLy8gICAgICAgc2kuY2xpcEFnYWluc3RIdWxsKHhpLHFpLGh1bGxCLHhqLHFqLHRyaWFuZ2xlTm9ybWFsLC0xMDAsMTAwLHJlcyk7CiAgICAvLyAgICAgICBmb3IobGV0IGogPSAwOyBqICE9PSByZXMubGVuZ3RoOyBqKyspewogICAgLy8gICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKSwKICAgIC8vICAgICAgICAgICAgICAgcmkgPSByLnJpLAogICAgLy8gICAgICAgICAgICAgICByaiA9IHIucmo7CiAgICAvLyAgICAgICAgICAgci5uaS5jb3B5KHRyaWFuZ2xlTm9ybWFsKTsKICAgIC8vICAgICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsKICAgIC8vICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTsKICAgIC8vICAgICAgICAgICBxLm11bHQocmVzW2pdLmRlcHRoLCBxKTsKICAgIC8vICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7CiAgICAvLyAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpOwogICAgLy8gICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmUKICAgIC8vICAgICAgICAgICByaS52c3ViKHhpLHJpKTsKICAgIC8vICAgICAgICAgICByai52c3ViKHhqLHJqKTsKICAgIC8vICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwogICAgLy8gICAgICAgICAgIHJpLnZhZGQoeGksIHJpKTsKICAgIC8vICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7CiAgICAvLyAgICAgICAgICAgcmoudmFkZCh4aiwgcmopOwogICAgLy8gICAgICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTsKICAgIC8vICAgICAgICAgICByZXN1bHQucHVzaChyKTsKICAgIC8vICAgICAgIH0KICAgIC8vICAgfQogICAgLy8gfQoKCiAgfQogIGNvbnN0IGF2ZXJhZ2VOb3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IGF2ZXJhZ2VDb250YWN0UG9pbnRBID0gbmV3IFZlYzMoKTsKICBjb25zdCBhdmVyYWdlQ29udGFjdFBvaW50QiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wUXVhdDEgPSBuZXcgUXVhdGVybmlvbigpOwogIGNvbnN0IHRtcFF1YXQyID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgY29uc3QgcGxhbmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVUcmltZXNoX3JlbHBvcyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfdiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92MiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3JVbml0ID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlUG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX3RtcCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YyA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZUFBQkIgPSBuZXcgQUFCQigpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfdHJpYW5nbGVzID0gW107CiAgY29uc3QgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTsKICBjb25zdCBwbGFuZV90b19zcGhlcmVfb3J0aG8gPSBuZXcgVmVjMygpOyAvLyBTZWUgaHR0cDovL2J1bGxldHBoeXNpY3MuY29tL0J1bGxldC9CdWxsZXRGdWxsL1NwaGVyZVRyaWFuZ2xlRGV0ZWN0b3JfOGNwcF9zb3VyY2UuaHRtbAoKICBjb25zdCBwb2ludEluUG9seWdvbl9lZGdlID0gbmV3IFZlYzMoKTsKICBjb25zdCBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBwb2ludEluUG9seWdvbl92dHAgPSBuZXcgVmVjMygpOwoKICBmdW5jdGlvbiBwb2ludEluUG9seWdvbih2ZXJ0cywgbm9ybWFsLCBwKSB7CiAgICBsZXQgcG9zaXRpdmVSZXN1bHQgPSBudWxsOwogICAgY29uc3QgTiA9IHZlcnRzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgIGNvbnN0IHYgPSB2ZXJ0c1tpXTsgLy8gR2V0IGVkZ2UgdG8gdGhlIG5leHQgdmVydGV4CgogICAgICBjb25zdCBlZGdlID0gcG9pbnRJblBvbHlnb25fZWRnZTsKICAgICAgdmVydHNbKGkgKyAxKSAlIE5dLnZzdWIodiwgZWRnZSk7IC8vIEdldCBjcm9zcyBwcm9kdWN0IGJldHdlZW4gcG9seWdvbiBub3JtYWwgYW5kIHRoZSBlZGdlCgogICAgICBjb25zdCBlZGdlX3hfbm9ybWFsID0gcG9pbnRJblBvbHlnb25fZWRnZV94X25vcm1hbDsgLy9jb25zdCBlZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTsKCiAgICAgIGVkZ2UuY3Jvc3Mobm9ybWFsLCBlZGdlX3hfbm9ybWFsKTsgLy8gR2V0IHZlY3RvciBiZXR3ZWVuIHBvaW50IGFuZCBjdXJyZW50IHZlcnRleAoKICAgICAgY29uc3QgdmVydGV4X3RvX3AgPSBwb2ludEluUG9seWdvbl92dHA7CiAgICAgIHAudnN1Yih2LCB2ZXJ0ZXhfdG9fcCk7IC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpcwoKICAgICAgY29uc3QgciA9IGVkZ2VfeF9ub3JtYWwuZG90KHZlcnRleF90b19wKTsgLy8gSWYgYWxsIHN1Y2ggZG90IHByb2R1Y3RzIGhhdmUgc2FtZSBzaWduLCB3ZSBhcmUgaW5zaWRlIHRoZSBwb2x5Z29uLgoKICAgICAgaWYgKHBvc2l0aXZlUmVzdWx0ID09PSBudWxsIHx8IHIgPiAwICYmIHBvc2l0aXZlUmVzdWx0ID09PSB0cnVlIHx8IHIgPD0gMCAmJiBwb3NpdGl2ZVJlc3VsdCA9PT0gZmFsc2UpIHsKICAgICAgICBpZiAocG9zaXRpdmVSZXN1bHQgPT09IG51bGwpIHsKICAgICAgICAgIHBvc2l0aXZlUmVzdWx0ID0gciA+IDA7CiAgICAgICAgfQoKICAgICAgICBjb250aW51ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC4KICAgICAgfQogICAgfSAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uCgoKICAgIHJldHVybiB0cnVlOwogIH0KCiAgY29uc3QgYm94X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQm94X25zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfbnMxID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfbnMyID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfc2lkZXMgPSBbbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKV07CiAgY29uc3Qgc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUJveF9zaWRlX25zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfc2lkZV9uczEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUJveF9zaWRlX25zMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY29udmV4X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X2VkZ2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludCA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHBsYW5lQ29udmV4X3YgPSBuZXcgVmVjMygpOwogIGNvbnN0IHBsYW5lQ29udmV4X25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVDb252ZXhfcmVscG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBwbGFuZUNvbnZleF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleENvbnZleF9zZXBBeGlzID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb252ZXhDb252ZXhfcSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGFydGljbGVQbGFuZV9ub3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHBhcnRpY2xlUGxhbmVfcmVscG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGFydGljbGVTcGhlcmVfbm9ybWFsID0gbmV3IFZlYzMoKTsgLy8gV0lQCgogIGNvbnN0IGNxaiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgY29uc3QgY29udmV4UGFydGljbGVfbG9jYWwgPSBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgY29uc3QgY29udmV4UGFydGljbGVfcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWMgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX3RtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX3RtcDIgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0ID0gWzBdOwogIGNvbnN0IHNwaGVyZUhlaWdodGZpZWxkX3RtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUhlaWdodGZpZWxkX3RtcDIgPSBuZXcgVmVjMygpOwoKICBjbGFzcyBPdmVybGFwS2VlcGVyIHsKICAgIC8qKgogICAgICogQHRvZG8gUmVtb3ZlIHVzZWxlc3MgY29uc3RydWN0b3IKICAgICAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMuY3VycmVudCA9IFtdOwogICAgICB0aGlzLnByZXZpb3VzID0gW107CiAgICB9CiAgICAvKioKICAgICAqIGdldEtleQogICAgICovCgoKICAgIGdldEtleShpLCBqKSB7CiAgICAgIGlmIChqIDwgaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICByZXR1cm4gaSA8PCAxNiB8IGo7CiAgICB9CiAgICAvKioKICAgICAqIHNldAogICAgICovCgoKICAgIHNldChpLCBqKSB7CiAgICAgIC8vIEluc2VydGlvbiBzb3J0LiBUaGlzIHdheSB0aGUgZGlmZiB3aWxsIGhhdmUgbGluZWFyIGNvbXBsZXhpdHkuCiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KGksIGopOwogICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50OwogICAgICBsZXQgaW5kZXggPSAwOwoKICAgICAgd2hpbGUgKGtleSA+IGN1cnJlbnRbaW5kZXhdKSB7CiAgICAgICAgaW5kZXgrKzsKICAgICAgfQoKICAgICAgaWYgKGtleSA9PT0gY3VycmVudFtpbmRleF0pIHsKICAgICAgICByZXR1cm47IC8vIFBhaXIgd2FzIGFscmVhZHkgYWRkZWQKICAgICAgfQoKICAgICAgZm9yIChsZXQgaiA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaiA+PSBpbmRleDsgai0tKSB7CiAgICAgICAgY3VycmVudFtqICsgMV0gPSBjdXJyZW50W2pdOwogICAgICB9CgogICAgICBjdXJyZW50W2luZGV4XSA9IGtleTsKICAgIH0KICAgIC8qKgogICAgICogdGljawogICAgICovCgoKICAgIHRpY2soKSB7CiAgICAgIGNvbnN0IHRtcCA9IHRoaXMuY3VycmVudDsKICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5wcmV2aW91czsKICAgICAgdGhpcy5wcmV2aW91cyA9IHRtcDsKICAgICAgdGhpcy5jdXJyZW50Lmxlbmd0aCA9IDA7CiAgICB9CiAgICAvKioKICAgICAqIGdldERpZmYKICAgICAqLwoKCiAgICBnZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpIHsKICAgICAgY29uc3QgYSA9IHRoaXMuY3VycmVudDsKICAgICAgY29uc3QgYiA9IHRoaXMucHJldmlvdXM7CiAgICAgIGNvbnN0IGFsID0gYS5sZW5ndGg7CiAgICAgIGNvbnN0IGJsID0gYi5sZW5ndGg7CiAgICAgIGxldCBqID0gMDsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWw7IGkrKykgewogICAgICAgIGxldCBmb3VuZCA9IGZhbHNlOwogICAgICAgIGNvbnN0IGtleUEgPSBhW2ldOwoKICAgICAgICB3aGlsZSAoa2V5QSA+IGJbal0pIHsKICAgICAgICAgIGorKzsKICAgICAgICB9CgogICAgICAgIGZvdW5kID0ga2V5QSA9PT0gYltqXTsKCiAgICAgICAgaWYgKCFmb3VuZCkgewogICAgICAgICAgdW5wYWNrQW5kUHVzaChhZGRpdGlvbnMsIGtleUEpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaiA9IDA7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsOyBpKyspIHsKICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTsKICAgICAgICBjb25zdCBrZXlCID0gYltpXTsKCiAgICAgICAgd2hpbGUgKGtleUIgPiBhW2pdKSB7CiAgICAgICAgICBqKys7CiAgICAgICAgfQoKICAgICAgICBmb3VuZCA9IGFbal0gPT09IGtleUI7CgogICAgICAgIGlmICghZm91bmQpIHsKICAgICAgICAgIHVucGFja0FuZFB1c2gocmVtb3ZhbHMsIGtleUIpOwogICAgICAgIH0KICAgICAgfQogICAgfQoKICB9CgogIGZ1bmN0aW9uIHVucGFja0FuZFB1c2goYXJyYXksIGtleSkgewogICAgYXJyYXkucHVzaCgoa2V5ICYgMHhmZmZmMDAwMCkgPj4gMTYsIGtleSAmIDB4MDAwMGZmZmYpOwogIH0KCiAgY29uc3QgZ2V0S2V5ID0gKGksIGopID0+IGkgPCBqID8gYCR7aX0tJHtqfWAgOiBgJHtqfS0ke2l9YDsKICAvKioKICAgKiBUdXBsZURpY3Rpb25hcnkKICAgKi8KCgogIGNsYXNzIFR1cGxlRGljdGlvbmFyeSB7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy5kYXRhID0gewogICAgICAgIGtleXM6IFtdCiAgICAgIH07CiAgICB9CgogICAgLyoqIGdldCAqLwogICAgZ2V0KGksIGopIHsKICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KGksIGopOwogICAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07CiAgICB9CiAgICAvKiogc2V0ICovCgoKICAgIHNldChpLCBqLCB2YWx1ZSkgewogICAgICBjb25zdCBrZXkgPSBnZXRLZXkoaSwgaik7IC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0cwoKICAgICAgaWYgKCF0aGlzLmdldChpLCBqKSkgewogICAgICAgIHRoaXMuZGF0YS5rZXlzLnB1c2goa2V5KTsKICAgICAgfQoKICAgICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTsKICAgIH0KICAgIC8qKiBkZWxldGUgKi8KCgogICAgZGVsZXRlKGksIGopIHsKICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KGksIGopOwogICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGF0YS5rZXlzLmluZGV4T2Yoa2V5KTsKCiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsKICAgICAgICB0aGlzLmRhdGEua2V5cy5zcGxpY2UoaW5kZXgsIDEpOwogICAgICB9CgogICAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07CiAgICB9CiAgICAvKiogcmVzZXQgKi8KCgogICAgcmVzZXQoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IGtleXMgPSBkYXRhLmtleXM7CgogICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7CiAgICAgICAgY29uc3Qga2V5ID0ga2V5cy5wb3AoKTsKICAgICAgICBkZWxldGUgZGF0YVtrZXldOwogICAgICB9CiAgICB9CgogIH0KCiAgLyoqCiAgICogVGhlIHBoeXNpY3Mgd29ybGQKICAgKi8KICBjbGFzcyBXb3JsZCBleHRlbmRzIEV2ZW50VGFyZ2V0IHsKICAgIC8qKgogICAgICogQ3VycmVudGx5IC8gbGFzdCB1c2VkIHRpbWVzdGVwLiBJcyBzZXQgdG8gLTEgaWYgbm90IGF2YWlsYWJsZS4gVGhpcyB2YWx1ZSBpcyB1cGRhdGVkIGJlZm9yZSBlYWNoIGludGVybmFsIHN0ZXAsIHdoaWNoIG1lYW5zIHRoYXQgaXQgaXMgImZyZXNoIiBpbnNpZGUgZXZlbnQgY2FsbGJhY2tzLgogICAgICovCgogICAgLyoqCiAgICAgKiBNYWtlcyBib2RpZXMgZ28gdG8gc2xlZXAgd2hlbiB0aGV5J3ZlIGJlZW4gaW5hY3RpdmUuCiAgICAgKiBAZGVmYXVsdCBmYWxzZQogICAgICovCgogICAgLyoqCiAgICAgKiBBbGwgdGhlIGN1cnJlbnQgY29udGFjdHMgKGluc3RhbmNlcyBvZiBDb250YWN0RXF1YXRpb24pIGluIHRoZSB3b3JsZC4KICAgICAqLwoKICAgIC8qKgogICAgICogSG93IG9mdGVuIHRvIG5vcm1hbGl6ZSBxdWF0ZXJuaW9ucy4gU2V0IHRvIDAgZm9yIGV2ZXJ5IHN0ZXAsIDEgZm9yIGV2ZXJ5IHNlY29uZCBldGMuLiBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgcGVyZm9ybWFuY2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBhIHNtYWxsZXIgdmFsdWUgKHplcm8gdG8gYmUgc3VyZSBub3RoaW5nIGNhbiBnbyB3cm9uZykuCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNldCB0byB0cnVlIHRvIHVzZSBmYXN0IHF1YXRlcm5pb24gbm9ybWFsaXphdGlvbi4gSXQgaXMgb2Z0ZW4gZW5vdWdoIGFjY3VyYXRlIHRvIHVzZS4KICAgICAqIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBmYWxzZS4KICAgICAqIEBkZWZhdWx0IGZhbHNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSB3YWxsLWNsb2NrIHRpbWUgc2luY2Ugc2ltdWxhdGlvbiBzdGFydC4KICAgICAqLwoKICAgIC8qKgogICAgICogTnVtYmVyIG9mIHRpbWVzdGVwcyB0YWtlbiBzaW5jZSBzdGFydC4KICAgICAqLwoKICAgIC8qKgogICAgICogRGVmYXVsdCBhbmQgbGFzdCB0aW1lc3RlcCBzaXplcy4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGdyYXZpdHkgb2YgdGhlIHdvcmxkLgogICAgICovCgogICAgLyoqCiAgICAgKiBHcmF2aXR5IHRvIHVzZSB3aGVuIGFwcHJveGltYXRpbmcgdGhlIGZyaWN0aW9uIG1heCBmb3JjZSAobXUqbWFzcypncmF2aXR5KS4KICAgICAqIElmIHVuZGVmaW5lZCwgZ2xvYmFsIGdyYXZpdHkgd2lsbCBiZSB1c2VkLgogICAgICogVXNlIHRvIGVuYWJsZSBmcmljdGlvbiBpbiBhIFdvcmxkIHdpdGggYSBudWxsIGdyYXZpdHkgdmVjdG9yIChubyBncmF2aXR5KS4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGJyb2FkcGhhc2UgYWxnb3JpdGhtIHRvIHVzZS4KICAgICAqIEBkZWZhdWx0IE5haXZlQnJvYWRwaGFzZQogICAgICovCgogICAgLyoqCiAgICAgKiBBbGwgYm9kaWVzIGluIHRoaXMgd29ybGQKICAgICAqLwoKICAgIC8qKgogICAgICogVHJ1ZSBpZiBhbnkgYm9kaWVzIGFyZSBub3Qgc2xlZXBpbmcsIGZhbHNlIGlmIGV2ZXJ5IGJvZHkgaXMgc2xlZXBpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBzb2x2ZXIgYWxnb3JpdGhtIHRvIHVzZS4KICAgICAqIEBkZWZhdWx0IEdTU29sdmVyCiAgICAgKi8KCiAgICAvKioKICAgICAqIGNvbGxpc2lvbk1hdHJpeAogICAgICovCgogICAgLyoqCiAgICAgKiBDb2xsaXNpb25NYXRyaXggZnJvbSB0aGUgcHJldmlvdXMgc3RlcC4KICAgICAqLwoKICAgIC8qKgogICAgICogQWxsIGFkZGVkIGNvbnRhY3RtYXRlcmlhbHMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZWQgdG8gbG9vayB1cCBhIENvbnRhY3RNYXRlcmlhbCBnaXZlbiB0d28gaW5zdGFuY2VzIG9mIE1hdGVyaWFsLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgZGVmYXVsdCBtYXRlcmlhbCBvZiB0aGUgYm9kaWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGlzIGNvbnRhY3QgbWF0ZXJpYWwgaXMgdXNlZCBpZiBubyBzdWl0YWJsZSBjb250YWN0bWF0ZXJpYWwgaXMgZm91bmQgZm9yIGEgY29udGFjdC4KICAgICAqLwoKICAgIC8qKgogICAgICogVGltZSBhY2N1bXVsYXRvciBmb3IgaW50ZXJwb2xhdGlvbi4KICAgICAqIEBzZWUgaHR0cHM6Ly9nYWZmZXJvbmdhbWVzLmNvbS9nYW1lLXBoeXNpY3MvZml4LXlvdXItdGltZXN0ZXAvCiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB3b3JsZC4KICAgICAqLwoKICAgIC8qKgogICAgICogRGlzcGF0Y2hlZCBhZnRlciBhIGJvZHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSB3b3JsZC4KICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBzdXBlcigpOwogICAgICB0aGlzLmR0ID0gLTE7CiAgICAgIHRoaXMuYWxsb3dTbGVlcCA9ICEhb3B0aW9ucy5hbGxvd1NsZWVwOwogICAgICB0aGlzLmNvbnRhY3RzID0gW107CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTsKICAgICAgdGhpcy5xdWF0Tm9ybWFsaXplU2tpcCA9IG9wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXAgOiAwOwogICAgICB0aGlzLnF1YXROb3JtYWxpemVGYXN0ID0gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCA6IGZhbHNlOwogICAgICB0aGlzLnRpbWUgPSAwLjA7CiAgICAgIHRoaXMuc3RlcG51bWJlciA9IDA7CiAgICAgIHRoaXMuZGVmYXVsdF9kdCA9IDEgLyA2MDsKICAgICAgdGhpcy5uZXh0SWQgPSAwOwogICAgICB0aGlzLmdyYXZpdHkgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMuZ3Jhdml0eSkgewogICAgICAgIHRoaXMuZ3Jhdml0eS5jb3B5KG9wdGlvbnMuZ3Jhdml0eSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLmZyaWN0aW9uR3Jhdml0eSkgewogICAgICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gbmV3IFZlYzMoKTsKICAgICAgICB0aGlzLmZyaWN0aW9uR3Jhdml0eS5jb3B5KG9wdGlvbnMuZnJpY3Rpb25HcmF2aXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5icm9hZHBoYXNlID0gb3B0aW9ucy5icm9hZHBoYXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJyb2FkcGhhc2UgOiBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7CiAgICAgIHRoaXMuYm9kaWVzID0gW107CiAgICAgIHRoaXMuaGFzQWN0aXZlQm9kaWVzID0gZmFsc2U7CiAgICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc29sdmVyIDogbmV3IEdTU29sdmVyKCk7CiAgICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTsKICAgICAgdGhpcy5uYXJyb3dwaGFzZSA9IG5ldyBOYXJyb3dwaGFzZSh0aGlzKTsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cyA9IG5ldyBBcnJheUNvbGxpc2lvbk1hdHJpeCgpOwogICAgICB0aGlzLmJvZHlPdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTsKICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIgPSBuZXcgT3ZlcmxhcEtlZXBlcigpOwogICAgICB0aGlzLmNvbnRhY3RtYXRlcmlhbHMgPSBbXTsKICAgICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTsKICAgICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoJ2RlZmF1bHQnKTsKICAgICAgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbCh0aGlzLmRlZmF1bHRNYXRlcmlhbCwgdGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHsKICAgICAgICBmcmljdGlvbjogMC4zLAogICAgICAgIHJlc3RpdHV0aW9uOiAwLjAKICAgICAgfSk7CiAgICAgIHRoaXMuZG9Qcm9maWxpbmcgPSBmYWxzZTsKICAgICAgdGhpcy5wcm9maWxlID0gewogICAgICAgIHNvbHZlOiAwLAogICAgICAgIG1ha2VDb250YWN0Q29uc3RyYWludHM6IDAsCiAgICAgICAgYnJvYWRwaGFzZTogMCwKICAgICAgICBpbnRlZ3JhdGU6IDAsCiAgICAgICAgbmFycm93cGhhc2U6IDAKICAgICAgfTsKICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7CiAgICAgIHRoaXMuc3Vic3lzdGVtcyA9IFtdOwogICAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHsKICAgICAgICB0eXBlOiAnYWRkQm9keScsCiAgICAgICAgYm9keTogbnVsbAogICAgICB9OwogICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHsKICAgICAgICB0eXBlOiAncmVtb3ZlQm9keScsCiAgICAgICAgYm9keTogbnVsbAogICAgICB9OwogICAgICB0aGlzLmlkVG9Cb2R5TWFwID0ge307CiAgICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBjb250YWN0IG1hdGVyaWFsIGJldHdlZW4gbWF0ZXJpYWxzIG0xIGFuZCBtMgogICAgICogQHJldHVybiBUaGUgY29udGFjdCBtYXRlcmlhbCBpZiBpdCB3YXMgZm91bmQuCiAgICAgKi8KCgogICAgZ2V0Q29udGFjdE1hdGVyaWFsKG0xLCBtMikgewogICAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQobTEuaWQsIG0yLmlkKTsKICAgIH0KICAgIC8qKgogICAgICogU3RvcmUgb2xkIGNvbGxpc2lvbiBzdGF0ZSBpbmZvCiAgICAgKi8KCgogICAgY29sbGlzaW9uTWF0cml4VGljaygpIHsKICAgICAgY29uc3QgdGVtcCA9IHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXM7CiAgICAgIHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXMgPSB0aGlzLmNvbGxpc2lvbk1hdHJpeDsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSB0ZW1wOwogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5yZXNldCgpOwogICAgICB0aGlzLmJvZHlPdmVybGFwS2VlcGVyLnRpY2soKTsKICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIudGljaygpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBzaW11bGF0aW9uLgogICAgICovCgoKICAgIGFkZENvbnN0cmFpbnQoYykgewogICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYSBjb25zdHJhaW50CiAgICAgKi8KCgogICAgcmVtb3ZlQ29uc3RyYWludChjKSB7CiAgICAgIGNvbnN0IGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTsKCiAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgdGhpcy5jb25zdHJhaW50cy5zcGxpY2UoaWR4LCAxKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSYXljYXN0IHRlc3QKICAgICAqIEBkZXByZWNhdGVkIFVzZSAucmF5Y2FzdEFsbCwgLnJheWNhc3RDbG9zZXN0IG9yIC5yYXljYXN0QW55IGluc3RlYWQuCiAgICAgKi8KCgogICAgcmF5VGVzdChmcm9tLCB0bywgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSYXljYXN0UmVzdWx0KSB7CiAgICAgICAgLy8gRG8gcmF5Y2FzdENsb3Nlc3QKICAgICAgICB0aGlzLnJheWNhc3RDbG9zZXN0KGZyb20sIHRvLCB7CiAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlCiAgICAgICAgfSwgcmVzdWx0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBEbyByYXljYXN0QWxsCiAgICAgICAgdGhpcy5yYXljYXN0QWxsKGZyb20sIHRvLCB7CiAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlCiAgICAgICAgfSwgcmVzdWx0KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuCiAgICAgKiBAcmV0dXJuIFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC4KICAgICAqLwoKCiAgICByYXljYXN0QWxsKGZyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zLm1vZGUgPSBSYXkuQUxMOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBjYWxsYmFjazsKICAgICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogUmF5IGNhc3QsIGFuZCBzdG9wIGF0IHRoZSBmaXJzdCByZXN1bHQuIE5vdGUgdGhhdCB0aGUgb3JkZXIgaXMgcmFuZG9tIC0gYnV0IHRoZSBtZXRob2QgaXMgZmFzdC4KICAgICAqIEByZXR1cm4gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LgogICAgICovCgoKICAgIHJheWNhc3RBbnkoZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCkgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zLm1vZGUgPSBSYXkuQU5ZOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0OwogICAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBSYXkgY2FzdCwgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBvZiB0aGUgY2xvc2VzdCBoaXQuCiAgICAgKiBAcmV0dXJuIFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC4KICAgICAqLwoKCiAgICByYXljYXN0Q2xvc2VzdChmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMubW9kZSA9IFJheS5DTE9TRVNUOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0OwogICAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYSByaWdpZCBib2R5IHRvIHRoZSBzaW11bGF0aW9uLgogICAgICogQHRvZG8gSWYgdGhlIHNpbXVsYXRpb24gaGFzIG5vdCB5ZXQgc3RhcnRlZCwgd2h5IHJlY3JldGUgYW5kIGNvcHkgYXJyYXlzIGZvciBlYWNoIGJvZHk/IEFjY3VtdWxhdGUgaW4gZHluYW1pYyBhcnJheXMgaW4gdGhpcyBjYXNlLgogICAgICogQHRvZG8gQWRkaW5nIGFuIGFycmF5IG9mIGJvZGllcyBzaG91bGQgYmUgcG9zc2libGUuIFRoaXMgd291bGQgc2F2ZSBzb21lIGxvb3BzIHRvbwogICAgICovCgoKICAgIGFkZEJvZHkoYm9keSkgewogICAgICBpZiAodGhpcy5ib2RpZXMuaW5jbHVkZXMoYm9keSkpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGJvZHkuaW5kZXggPSB0aGlzLmJvZGllcy5sZW5ndGg7CiAgICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7CiAgICAgIGJvZHkud29ybGQgPSB0aGlzOwogICAgICBib2R5LmluaXRQb3NpdGlvbi5jb3B5KGJvZHkucG9zaXRpb24pOwogICAgICBib2R5LmluaXRWZWxvY2l0eS5jb3B5KGJvZHkudmVsb2NpdHkpOwogICAgICBib2R5LnRpbWVMYXN0U2xlZXB5ID0gdGhpcy50aW1lOwoKICAgICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBCb2R5KSB7CiAgICAgICAgYm9keS5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkoYm9keS5hbmd1bGFyVmVsb2NpdHkpOwogICAgICAgIGJvZHkuaW5pdFF1YXRlcm5pb24uY29weShib2R5LnF1YXRlcm5pb24pOwogICAgICB9CgogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXROdW1PYmplY3RzKHRoaXMuYm9kaWVzLmxlbmd0aCk7CiAgICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5OwogICAgICB0aGlzLmlkVG9Cb2R5TWFwW2JvZHkuaWRdID0gYm9keTsKICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuYWRkQm9keUV2ZW50KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLgogICAgICovCgoKICAgIHJlbW92ZUJvZHkoYm9keSkgewogICAgICBib2R5LndvcmxkID0gbnVsbDsKICAgICAgY29uc3QgbiA9IHRoaXMuYm9kaWVzLmxlbmd0aCAtIDE7CiAgICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYm9kaWVzOwogICAgICBjb25zdCBpZHggPSBib2RpZXMuaW5kZXhPZihib2R5KTsKCiAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgYm9kaWVzLnNwbGljZShpZHgsIDEpOyAvLyBUb2RvOiBzaG91bGQgdXNlIGEgZ2FyYmFnZSBmcmVlIG1ldGhvZAogICAgICAgIC8vIFJlY29tcHV0ZSBpbmRleAoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gYm9kaWVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBib2RpZXNbaV0uaW5kZXggPSBpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhuKTsKICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTsKICAgICAgICBkZWxldGUgdGhpcy5pZFRvQm9keU1hcFtib2R5LmlkXTsKICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5yZW1vdmVCb2R5RXZlbnQpOwogICAgICB9CiAgICB9CgogICAgZ2V0Qm9keUJ5SWQoaWQpIHsKICAgICAgcmV0dXJuIHRoaXMuaWRUb0JvZHlNYXBbaWRdOwogICAgfQogICAgLyoqCiAgICAgKiBAdG9kbyBNYWtlIGEgZmFzdGVyIG1hcAogICAgICovCgoKICAgIGdldFNoYXBlQnlJZChpZCkgewogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmJvZGllczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3Qgc2hhcGVzID0gYm9kaWVzW2ldLnNoYXBlczsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGFwZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2pdOwoKICAgICAgICAgIGlmIChzaGFwZS5pZCA9PT0gaWQpIHsKICAgICAgICAgICAgcmV0dXJuIHNoYXBlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgYSBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBXb3JsZAogICAgICovCgoKICAgIGFkZENvbnRhY3RNYXRlcmlhbChjbWF0KSB7CiAgICAgIC8vIEFkZCBjb250YWN0IG1hdGVyaWFsCiAgICAgIHRoaXMuY29udGFjdG1hdGVyaWFscy5wdXNoKGNtYXQpOyAvLyBBZGQgY3VycmVudCBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBtYXRlcmlhbCB0YWJsZQoKICAgICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5zZXQoY21hdC5tYXRlcmlhbHNbMF0uaWQsIGNtYXQubWF0ZXJpYWxzWzFdLmlkLCBjbWF0KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhIGNvbnRhY3QgbWF0ZXJpYWwgZnJvbSB0aGUgV29ybGQuCiAgICAgKi8KCgogICAgcmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtYXQpIHsKICAgICAgY29uc3QgaWR4ID0gdGhpcy5jb250YWN0bWF0ZXJpYWxzLmluZGV4T2YoY21hdCk7CgogICAgICBpZiAoaWR4ID09PSAtMSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzLnNwbGljZShpZHgsIDEpOwogICAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLmRlbGV0ZShjbWF0Lm1hdGVyaWFsc1swXS5pZCwgY21hdC5tYXRlcmlhbHNbMV0uaWQpOwogICAgfQogICAgLyoqCiAgICAgKiBTdGVwIHRoZSBzaW11bGF0aW9uIGZvcndhcmQga2VlcGluZyB0cmFjayBvZiBsYXN0IGNhbGxlZCB0aW1lCiAgICAgKiB0byBiZSBhYmxlIHRvIHN0ZXAgdGhlIHdvcmxkIGF0IGEgZml4ZWQgcmF0ZSwgaW5kZXBlbmRlbnRseSBvZiBmcmFtZXJhdGUuCiAgICAgKgogICAgICogQHBhcmFtIGR0IFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UgKGRlZmF1bHQ6IDEgLyA2MCkuCiAgICAgKiBAcGFyYW0gbWF4U3ViU3RlcHMgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbCAoZGVmYXVsdDogMTApLgogICAgICogQHNlZSBodHRwczovL2dhZmZlcm9uZ2FtZXMuY29tL3Bvc3QvZml4X3lvdXJfdGltZXN0ZXAvCiAgICAgKiBAZXhhbXBsZQogICAgICogICAgIC8vIFJ1biB0aGUgc2ltdWxhdGlvbiBpbmRlcGVuZGVudGx5IG9mIGZyYW1lcmF0ZSBldmVyeSAxIC8gNjAgbXMKICAgICAqICAgICB3b3JsZC5maXhlZFN0ZXAoKQogICAgICovCgoKICAgIGZpeGVkU3RlcChkdCwgbWF4U3ViU3RlcHMpIHsKICAgICAgaWYgKGR0ID09PSB2b2lkIDApIHsKICAgICAgICBkdCA9IDEgLyA2MDsKICAgICAgfQoKICAgICAgaWYgKG1heFN1YlN0ZXBzID09PSB2b2lkIDApIHsKICAgICAgICBtYXhTdWJTdGVwcyA9IDEwOwogICAgICB9CgogICAgICBjb25zdCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwOyAvLyBzZWNvbmRzCgogICAgICBpZiAoIXRoaXMubGFzdENhbGxUaW1lKSB7CiAgICAgICAgdGhpcy5zdGVwKGR0LCB1bmRlZmluZWQsIG1heFN1YlN0ZXBzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZSAtIHRoaXMubGFzdENhbGxUaW1lOwogICAgICAgIHRoaXMuc3RlcChkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpOwogICAgICB9CgogICAgICB0aGlzLmxhc3RDYWxsVGltZSA9IHRpbWU7CiAgICB9CiAgICAvKioKICAgICAqIFN0ZXAgdGhlIHBoeXNpY3Mgd29ybGQgZm9yd2FyZCBpbiB0aW1lLgogICAgICoKICAgICAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLgogICAgICoKICAgICAqIEBwYXJhbSBkdCBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLgogICAgICogQHBhcmFtIHRpbWVTaW5jZUxhc3RDYWxsZWQgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgY2FsbGVkLgogICAgICogQHBhcmFtIG1heFN1YlN0ZXBzIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwgKGRlZmF1bHQ6IDEwKS4KICAgICAqIEBzZWUgaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTgwNDI2MTU0NTMxL2h0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZCNXaGF0X2RvX3RoZV9wYXJhbWV0ZXJzX3RvX2J0RHluYW1pY3NXb3JsZDo6c3RlcFNpbXVsYXRpb25fbWVhbi4zRgogICAgICogQGV4YW1wbGUKICAgICAqICAgICAvLyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uCiAgICAgKiAgICAgd29ybGQuc3RlcCgxIC8gNjApCiAgICAgKi8KCgogICAgc3RlcChkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpIHsKICAgICAgaWYgKG1heFN1YlN0ZXBzID09PSB2b2lkIDApIHsKICAgICAgICBtYXhTdWJTdGVwcyA9IDEwOwogICAgICB9CgogICAgICBpZiAodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgLy8gRml4ZWQsIHNpbXBsZSBzdGVwcGluZwogICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTsgLy8gSW5jcmVtZW50IHRpbWUKCiAgICAgICAgdGhpcy50aW1lICs9IGR0OwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYWNjdW11bGF0b3IgKz0gdGltZVNpbmNlTGFzdENhbGxlZDsKICAgICAgICBjb25zdCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICAgIGxldCBzdWJzdGVwcyA9IDA7CgogICAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHN1YnN0ZXBzIDwgbWF4U3ViU3RlcHMpIHsKICAgICAgICAgIC8vIERvIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwCiAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7CiAgICAgICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IGR0OwogICAgICAgICAgc3Vic3RlcHMrKzsKCiAgICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSB0MCA+IGR0ICogMTAwMCkgewogICAgICAgICAgICAvLyBUaGUgZnJhbWVyYXRlIGlzIG5vdCBpbnRlcmFjdGl2ZSBhbnltb3JlLgogICAgICAgICAgICAvLyBXZSBhcmUgYmVsb3cgdGhlIHRhcmdldCBmcmFtZXJhdGUuCiAgICAgICAgICAgIC8vIEJldHRlciBiYWlsIG91dC4KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBSZW1vdmUgdGhlIGV4Y2VzcyBhY2N1bXVsYXRvciwgc2luY2Ugd2UgbWF5IG5vdAogICAgICAgIC8vIGhhdmUgaGFkIGVub3VnaCBzdWJzdGVwcyBhdmFpbGFibGUgdG8gY2F0Y2ggdXAKCgogICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSB0aGlzLmFjY3VtdWxhdG9yICUgZHQ7CiAgICAgICAgY29uc3QgdCA9IHRoaXMuYWNjdW11bGF0b3IgLyBkdDsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IHRoaXMuYm9kaWVzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCBiID0gdGhpcy5ib2RpZXNbal07CiAgICAgICAgICBiLnByZXZpb3VzUG9zaXRpb24ubGVycChiLnBvc2l0aW9uLCB0LCBiLmludGVycG9sYXRlZFBvc2l0aW9uKTsKICAgICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLnNsZXJwKGIucXVhdGVybmlvbiwgdCwgYi5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uKTsKICAgICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLm5vcm1hbGl6ZSgpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy50aW1lICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7CiAgICAgIH0KICAgIH0KCiAgICBpbnRlcm5hbFN0ZXAoZHQpIHsKICAgICAgdGhpcy5kdCA9IGR0OwogICAgICBjb25zdCBjb250YWN0cyA9IHRoaXMuY29udGFjdHM7CiAgICAgIGNvbnN0IHAxID0gV29ybGRfc3RlcF9wMTsKICAgICAgY29uc3QgcDIgPSBXb3JsZF9zdGVwX3AyOwogICAgICBjb25zdCBOID0gdGhpcy5ib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmJvZGllczsKICAgICAgY29uc3Qgc29sdmVyID0gdGhpcy5zb2x2ZXI7CiAgICAgIGNvbnN0IGdyYXZpdHkgPSB0aGlzLmdyYXZpdHk7CiAgICAgIGNvbnN0IGRvUHJvZmlsaW5nID0gdGhpcy5kb1Byb2ZpbGluZzsKICAgICAgY29uc3QgcHJvZmlsZSA9IHRoaXMucHJvZmlsZTsKICAgICAgY29uc3QgRFlOQU1JQyA9IEJvZHkuRFlOQU1JQzsKICAgICAgbGV0IHByb2ZpbGluZ1N0YXJ0ID0gLUluZmluaXR5OwogICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7CiAgICAgIGNvbnN0IGZyaWN0aW9uRXF1YXRpb25Qb29sID0gV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbDsKICAgICAgZ3Jhdml0eS5sZW5ndGgoKTsKICAgICAgY29uc3QgZ3ggPSBncmF2aXR5Lng7CiAgICAgIGNvbnN0IGd5ID0gZ3Jhdml0eS55OwogICAgICBjb25zdCBneiA9IGdyYXZpdHkuejsKICAgICAgbGV0IGkgPSAwOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgfSAvLyBBZGQgZ3Jhdml0eSB0byBhbGwgb2JqZWN0cwoKCiAgICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IGJpID0gYm9kaWVzW2ldOwoKICAgICAgICBpZiAoYmkudHlwZSA9PT0gRFlOQU1JQykgewogICAgICAgICAgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXMKICAgICAgICAgIGNvbnN0IGYgPSBiaS5mb3JjZTsKICAgICAgICAgIGNvbnN0IG0gPSBiaS5tYXNzOwogICAgICAgICAgZi54ICs9IG0gKiBneDsKICAgICAgICAgIGYueSArPSBtICogZ3k7CiAgICAgICAgICBmLnogKz0gbSAqIGd6OwogICAgICAgIH0KICAgICAgfSAvLyBVcGRhdGUgc3Vic3lzdGVtcwoKCiAgICAgIGZvciAobGV0IGkgPSAwLCBOc3Vic3lzdGVtcyA9IHRoaXMuc3Vic3lzdGVtcy5sZW5ndGg7IGkgIT09IE5zdWJzeXN0ZW1zOyBpKyspIHsKICAgICAgICB0aGlzLnN1YnN5c3RlbXNbaV0udXBkYXRlKCk7CiAgICAgIH0gLy8gQ29sbGlzaW9uIGRldGVjdGlvbgoKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICAgIH0KCiAgICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwCgogICAgICBwMi5sZW5ndGggPSAwOwogICAgICB0aGlzLmJyb2FkcGhhc2UuY29sbGlzaW9uUGFpcnModGhpcywgcDEsIHAyKTsKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGUuYnJvYWRwaGFzZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7CiAgICAgIH0gLy8gUmVtb3ZlIGNvbnN0cmFpbmVkIHBhaXJzIHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZQoKCiAgICAgIGxldCBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBjb25zdHJhaW50c1tpXTsKCiAgICAgICAgaWYgKCFjLmNvbGxpZGVDb25uZWN0ZWQpIHsKICAgICAgICAgIGZvciAobGV0IGogPSBwMS5sZW5ndGggLSAxOyBqID49IDA7IGogLT0gMSkgewogICAgICAgICAgICBpZiAoYy5ib2R5QSA9PT0gcDFbal0gJiYgYy5ib2R5QiA9PT0gcDJbal0gfHwgYy5ib2R5QiA9PT0gcDFbal0gJiYgYy5ib2R5QSA9PT0gcDJbal0pIHsKICAgICAgICAgICAgICBwMS5zcGxpY2UoaiwgMSk7CiAgICAgICAgICAgICAgcDIuc3BsaWNlKGosIDEpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFRpY2soKTsgLy8gR2VuZXJhdGUgY29udGFjdHMKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IG9sZGNvbnRhY3RzID0gV29ybGRfc3RlcF9vbGRDb250YWN0czsKICAgICAgY29uc3QgTm9sZENvbnRhY3RzID0gY29udGFjdHMubGVuZ3RoOwoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTm9sZENvbnRhY3RzOyBpKyspIHsKICAgICAgICBvbGRjb250YWN0cy5wdXNoKGNvbnRhY3RzW2ldKTsKICAgICAgfQoKICAgICAgY29udGFjdHMubGVuZ3RoID0gMDsgLy8gVHJhbnNmZXIgRnJpY3Rpb25FcXVhdGlvbiBmcm9tIGN1cnJlbnQgbGlzdCB0byB0aGUgcG9vbCBmb3IgcmV1c2UKCiAgICAgIGNvbnN0IE5vbGRGcmljdGlvbkVxdWF0aW9ucyA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOwoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTm9sZEZyaWN0aW9uRXF1YXRpb25zOyBpKyspIHsKICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbC5wdXNoKHRoaXMuZnJpY3Rpb25FcXVhdGlvbnNbaV0pOwogICAgICB9CgogICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA9IDA7CiAgICAgIHRoaXMubmFycm93cGhhc2UuZ2V0Q29udGFjdHMocDEsIHAyLCB0aGlzLCBjb250YWN0cywgb2xkY29udGFjdHMsIC8vIFRvIGJlIHJldXNlZAogICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLCBmcmljdGlvbkVxdWF0aW9uUG9vbCk7CgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxlLm5hcnJvd3BoYXNlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDsKICAgICAgfSAvLyBMb29wIG92ZXIgYWxsIGNvbGxpc2lvbnMKCgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9IC8vIEFkZCBhbGwgZnJpY3Rpb24gZXFzCgoKICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24odGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IG5jb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGsgPSAwOyBrICE9PSBuY29udGFjdHM7IGsrKykgewogICAgICAgIC8vIEN1cnJlbnQgY29udGFjdAogICAgICAgIGNvbnN0IGMgPSBjb250YWN0c1trXTsgLy8gR2V0IGN1cnJlbnQgY29sbGlzaW9uIGluZGVjZXMKCiAgICAgICAgY29uc3QgYmkgPSBjLmJpOwogICAgICAgIGNvbnN0IGJqID0gYy5iajsKICAgICAgICBjb25zdCBzaSA9IGMuc2k7CiAgICAgICAgY29uc3Qgc2ogPSBjLnNqOyAvLyBHZXQgY29sbGlzaW9uIHByb3BlcnRpZXMKCiAgICAgICAgbGV0IGNtOwoKICAgICAgICBpZiAoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpIHsKICAgICAgICAgIGNtID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoYmkubWF0ZXJpYWwsIGJqLm1hdGVyaWFsKSB8fCB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsOwogICAgICAgIH0gLy8gYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7CgoKICAgICAgICBjbS5mcmljdGlvbjsgLy8gYy5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uOwogICAgICAgIC8vIElmIGZyaWN0aW9uIG9yIHJlc3RpdHV0aW9uIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBtYXRlcmlhbCwgdXNlIHRoZW0KCiAgICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7CiAgICAgICAgICBpZiAoYmkubWF0ZXJpYWwuZnJpY3Rpb24gPj0gMCAmJiBiai5tYXRlcmlhbC5mcmljdGlvbiA+PSAwKSB7CiAgICAgICAgICAgIGJpLm1hdGVyaWFsLmZyaWN0aW9uICogYmoubWF0ZXJpYWwuZnJpY3Rpb247CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGJpLm1hdGVyaWFsLnJlc3RpdHV0aW9uID49IDAgJiYgYmoubWF0ZXJpYWwucmVzdGl0dXRpb24gPj0gMCkgewogICAgICAgICAgICBjLnJlc3RpdHV0aW9uID0gYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gKiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbjsKICAgICAgICAgIH0KICAgICAgICB9IC8vIGMuc2V0U3Bvb2tQYXJhbXMoCiAgICAgICAgLy8gICAgICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcywKICAgICAgICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiwKICAgICAgICAvLyAgICAgICAgICAgZHQKICAgICAgICAvLyAgICAgICApOwoKCiAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKGMpOyAvLyAvLyBBZGQgZnJpY3Rpb24gY29uc3RyYWludCBlcXVhdGlvbgogICAgICAgIC8vIGlmKG11ID4gMCl7CiAgICAgICAgLy8gCS8vIENyZWF0ZSAyIHRhbmdlbnQgZXF1YXRpb25zCiAgICAgICAgLy8gCWNvbnN0IG11ZyA9IG11ICogZ25vcm07CiAgICAgICAgLy8gCWNvbnN0IHJlZHVjZWRNYXNzID0gKGJpLmludk1hc3MgKyBiai5pbnZNYXNzKTsKICAgICAgICAvLyAJaWYocmVkdWNlZE1hc3MgPiAwKXsKICAgICAgICAvLyAJCXJlZHVjZWRNYXNzID0gMS9yZWR1Y2VkTWFzczsKICAgICAgICAvLyAJfQogICAgICAgIC8vIAljb25zdCBwb29sID0gZnJpY3Rpb25FcXVhdGlvblBvb2w7CiAgICAgICAgLy8gCWNvbnN0IGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYmksYmosbXVnKnJlZHVjZWRNYXNzKTsKICAgICAgICAvLyAJY29uc3QgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihiaSxiaixtdWcqcmVkdWNlZE1hc3MpOwogICAgICAgIC8vIAl0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goYzEsIGMyKTsKICAgICAgICAvLyAJYzEuYmkgPSBjMi5iaSA9IGJpOwogICAgICAgIC8vIAljMS5iaiA9IGMyLmJqID0gYmo7CiAgICAgICAgLy8gCWMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzOwogICAgICAgIC8vIAljMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzOwogICAgICAgIC8vIAkvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnMKICAgICAgICAvLyAJYzEucmkuY29weShjLnJpKTsKICAgICAgICAvLyAJYzEucmouY29weShjLnJqKTsKICAgICAgICAvLyAJYzIucmkuY29weShjLnJpKTsKICAgICAgICAvLyAJYzIucmouY29weShjLnJqKTsKICAgICAgICAvLyAJLy8gQ29uc3RydWN0IHRhbmdlbnRzCiAgICAgICAgLy8gCWMubmkudGFuZ2VudHMoYzEudCwgYzIudCk7CiAgICAgICAgLy8gICAgICAgICAgIC8vIFNldCBzcG9vayBwYXJhbXMKICAgICAgICAvLyAgICAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTsKICAgICAgICAvLyAgICAgICAgICAgYzIuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTsKICAgICAgICAvLyAgICAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjLmVuYWJsZWQ7CiAgICAgICAgLy8gCS8vIEFkZCBlcXVhdGlvbnMgdG8gc29sdmVyCiAgICAgICAgLy8gCXNvbHZlci5hZGRFcXVhdGlvbihjMSk7CiAgICAgICAgLy8gCXNvbHZlci5hZGRFcXVhdGlvbihjMik7CiAgICAgICAgLy8gfQoKICAgICAgICBpZiAoYmkuYWxsb3dTbGVlcCAmJiBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgYmkuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBiai5zbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmIGJqLnR5cGUgIT09IEJvZHkuU1RBVElDKSB7CiAgICAgICAgICBjb25zdCBzcGVlZFNxdWFyZWRCID0gYmoudmVsb2NpdHkubGVuZ3RoU3F1YXJlZCgpICsgYmouYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKTsKICAgICAgICAgIGNvbnN0IHNwZWVkTGltaXRTcXVhcmVkQiA9IGJqLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRCID49IHNwZWVkTGltaXRTcXVhcmVkQiAqIDIpIHsKICAgICAgICAgICAgYmkud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoYmouYWxsb3dTbGVlcCAmJiBiai50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgYmouc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBiaS5zbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmIGJpLnR5cGUgIT09IEJvZHkuU1RBVElDKSB7CiAgICAgICAgICBjb25zdCBzcGVlZFNxdWFyZWRBID0gYmkudmVsb2NpdHkubGVuZ3RoU3F1YXJlZCgpICsgYmkuYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKTsKICAgICAgICAgIGNvbnN0IHNwZWVkTGltaXRTcXVhcmVkQSA9IGJpLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSAqIDIpIHsKICAgICAgICAgICAgYmoud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBOb3cgd2Uga25vdyB0aGF0IGkgYW5kIGogYXJlIGluIGNvbnRhY3QuIFNldCBjb2xsaXNpb24gbWF0cml4IHN0YXRlCgoKICAgICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoYmksIGJqLCB0cnVlKTsKCiAgICAgICAgaWYgKCF0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzLmdldChiaSwgYmopKSB7CiAgICAgICAgICAvLyBGaXJzdCBjb250YWN0IQogICAgICAgICAgLy8gV2UgcmV1c2UgdGhlIGNvbGxpZGVFdmVudCBvYmplY3QsIG90aGVyd2lzZSB3ZSB3aWxsIGVuZCB1cCBjcmVhdGluZyBuZXcgb2JqZWN0cyBmb3IgZWFjaCBuZXcgY29udGFjdCwgZXZlbiBpZiB0aGVyZSdzIG5vIGV2ZW50IGxpc3RlbmVyIGF0dGFjaGVkLgogICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJqOwogICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuY29udGFjdCA9IGM7CiAgICAgICAgICBiaS5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTsKICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJvZHkgPSBiaTsKICAgICAgICAgIGJqLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5zZXQoYmkuaWQsIGJqLmlkKTsKICAgICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQoc2kuaWQsIHNqLmlkKTsKICAgICAgfQoKICAgICAgdGhpcy5lbWl0Q29udGFjdEV2ZW50cygpOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5tYWtlQ29udGFjdENvbnN0cmFpbnRzID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9IC8vIFdha2UgdXAgYm9kaWVzCgoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYmkgPSBib2RpZXNbaV07CgogICAgICAgIGlmIChiaS53YWtlVXBBZnRlck5hcnJvd3BoYXNlKSB7CiAgICAgICAgICBiaS53YWtlVXAoKTsKICAgICAgICAgIGJpLndha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTsKICAgICAgICB9CiAgICAgIH0gLy8gQWRkIHVzZXItYWRkZWQgY29uc3RyYWludHMKCgogICAgICBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBjb25zdHJhaW50c1tpXTsKICAgICAgICBjLnVwZGF0ZSgpOwoKICAgICAgICBmb3IgKGxldCBqID0gMCwgTmVxID0gYy5lcXVhdGlvbnMubGVuZ3RoOyBqICE9PSBOZXE7IGorKykgewogICAgICAgICAgY29uc3QgZXEgPSBjLmVxdWF0aW9uc1tqXTsKICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcSk7CiAgICAgICAgfQogICAgICB9IC8vIFNvbHZlIHRoZSBjb25zdHJhaW5lZCBzeXN0ZW0KCgogICAgICBzb2x2ZXIuc29sdmUoZHQsIHRoaXMpOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5zb2x2ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7CiAgICAgIH0gLy8gUmVtb3ZlIGFsbCBjb250YWN0cyBmcm9tIHNvbHZlcgoKCiAgICAgIHNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTsgLy8gQXBwbHkgZGFtcGluZywgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NCBmb3IgZGV0YWlscwoKICAgICAgY29uc3QgcG93ID0gTWF0aC5wb3c7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKCiAgICAgICAgaWYgKGJpLnR5cGUgJiBEWU5BTUlDKSB7CiAgICAgICAgICAvLyBPbmx5IGZvciBkeW5hbWljIGJvZGllcwogICAgICAgICAgY29uc3QgbGQgPSBwb3coMS4wIC0gYmkubGluZWFyRGFtcGluZywgZHQpOwogICAgICAgICAgY29uc3QgdiA9IGJpLnZlbG9jaXR5OwogICAgICAgICAgdi5zY2FsZShsZCwgdik7CiAgICAgICAgICBjb25zdCBhdiA9IGJpLmFuZ3VsYXJWZWxvY2l0eTsKCiAgICAgICAgICBpZiAoYXYpIHsKICAgICAgICAgICAgY29uc3QgYWQgPSBwb3coMS4wIC0gYmkuYW5ndWxhckRhbXBpbmcsIGR0KTsKICAgICAgICAgICAgYXYuc2NhbGUoYWQsIGF2KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX3ByZVN0ZXBFdmVudCk7IC8vIExlYXAgZnJvZwogICAgICAvLyB2bmV3ID0gdiArIGgqZi9tCiAgICAgIC8vIHhuZXcgPSB4ICsgaCp2bmV3CgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9CgogICAgICBjb25zdCBzdGVwbnVtYmVyID0gdGhpcy5zdGVwbnVtYmVyOwogICAgICBjb25zdCBxdWF0Tm9ybWFsaXplID0gc3RlcG51bWJlciAlICh0aGlzLnF1YXROb3JtYWxpemVTa2lwICsgMSkgPT09IDA7CiAgICAgIGNvbnN0IHF1YXROb3JtYWxpemVGYXN0ID0gdGhpcy5xdWF0Tm9ybWFsaXplRmFzdDsKCiAgICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGJvZGllc1tpXS5pbnRlZ3JhdGUoZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KTsKICAgICAgfQoKICAgICAgdGhpcy5jbGVhckZvcmNlcygpOwogICAgICB0aGlzLmJyb2FkcGhhc2UuZGlydHkgPSB0cnVlOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5pbnRlZ3JhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0OwogICAgICB9IC8vIFVwZGF0ZSBzdGVwIG51bWJlcgoKCiAgICAgIHRoaXMuc3RlcG51bWJlciArPSAxOwogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50KTsgLy8gU2xlZXBpbmcgdXBkYXRlCgogICAgICBsZXQgaGFzQWN0aXZlQm9kaWVzID0gdHJ1ZTsKCiAgICAgIGlmICh0aGlzLmFsbG93U2xlZXApIHsKICAgICAgICBoYXNBY3RpdmVCb2RpZXMgPSBmYWxzZTsKCiAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKICAgICAgICAgIGJpLnNsZWVwVGljayh0aGlzLnRpbWUpOwoKICAgICAgICAgIGlmIChiaS5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQSU5HKSB7CiAgICAgICAgICAgIGhhc0FjdGl2ZUJvZGllcyA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmhhc0FjdGl2ZUJvZGllcyA9IGhhc0FjdGl2ZUJvZGllczsKICAgIH0KCiAgICBlbWl0Q29udGFjdEV2ZW50cygpIHsKICAgICAgY29uc3QgaGFzQmVnaW5Db250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdiZWdpbkNvbnRhY3QnKTsKICAgICAgY29uc3QgaGFzRW5kQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignZW5kQ29udGFjdCcpOwoKICAgICAgaWYgKGhhc0JlZ2luQ29udGFjdCB8fCBoYXNFbmRDb250YWN0KSB7CiAgICAgICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpOwogICAgICB9CgogICAgICBpZiAoaGFzQmVnaW5Db250YWN0KSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhZGRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7CiAgICAgICAgICBiZWdpbkNvbnRhY3RFdmVudC5ib2R5QSA9IHRoaXMuZ2V0Qm9keUJ5SWQoYWRkaXRpb25zW2ldKTsKICAgICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gdGhpcy5nZXRCb2R5QnlJZChhZGRpdGlvbnNbaSArIDFdKTsKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChiZWdpbkNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBiZWdpbkNvbnRhY3RFdmVudC5ib2R5QSA9IGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gbnVsbDsKICAgICAgfQoKICAgICAgaWYgKGhhc0VuZENvbnRhY3QpIHsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHJlbW92YWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikgewogICAgICAgICAgZW5kQ29udGFjdEV2ZW50LmJvZHlBID0gdGhpcy5nZXRCb2R5QnlJZChyZW1vdmFsc1tpXSk7CiAgICAgICAgICBlbmRDb250YWN0RXZlbnQuYm9keUIgPSB0aGlzLmdldEJvZHlCeUlkKHJlbW92YWxzW2kgKyAxXSk7CiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZW5kQ29udGFjdEV2ZW50KTsKICAgICAgICB9CgogICAgICAgIGVuZENvbnRhY3RFdmVudC5ib2R5QSA9IGVuZENvbnRhY3RFdmVudC5ib2R5QiA9IG51bGw7CiAgICAgIH0KCiAgICAgIGFkZGl0aW9ucy5sZW5ndGggPSByZW1vdmFscy5sZW5ndGggPSAwOwogICAgICBjb25zdCBoYXNCZWdpblNoYXBlQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignYmVnaW5TaGFwZUNvbnRhY3QnKTsKICAgICAgY29uc3QgaGFzRW5kU2hhcGVDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdlbmRTaGFwZUNvbnRhY3QnKTsKCiAgICAgIGlmIChoYXNCZWdpblNoYXBlQ29udGFjdCB8fCBoYXNFbmRTaGFwZUNvbnRhY3QpIHsKICAgICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpOwogICAgICB9CgogICAgICBpZiAoaGFzQmVnaW5TaGFwZUNvbnRhY3QpIHsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFkZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHsKICAgICAgICAgIGNvbnN0IHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKGFkZGl0aW9uc1tpXSk7CiAgICAgICAgICBjb25zdCBzaGFwZUIgPSB0aGlzLmdldFNoYXBlQnlJZChhZGRpdGlvbnNbaSArIDFdKTsKICAgICAgICAgIGJlZ2luU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gc2hhcGVBOwogICAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBzaGFwZUI7CiAgICAgICAgICBpZiAoc2hhcGVBKSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gc2hhcGVBLmJvZHk7CiAgICAgICAgICBpZiAoc2hhcGVCKSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gc2hhcGVCLmJvZHk7CiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoYmVnaW5TaGFwZUNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5ib2R5QiA9IGJlZ2luU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBudWxsOwogICAgICB9CgogICAgICBpZiAoaGFzRW5kU2hhcGVDb250YWN0KSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSByZW1vdmFscy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHsKICAgICAgICAgIGNvbnN0IHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2ldKTsKICAgICAgICAgIGNvbnN0IHNoYXBlQiA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2kgKyAxXSk7CiAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUEgPSBzaGFwZUE7CiAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBzaGFwZUI7CiAgICAgICAgICBpZiAoc2hhcGVBKSBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IHNoYXBlQS5ib2R5OwogICAgICAgICAgaWYgKHNoYXBlQikgZW5kU2hhcGVDb250YWN0RXZlbnQuYm9keUIgPSBzaGFwZUIuYm9keTsKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlbmRTaGFwZUNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IGVuZFNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVCID0gbnVsbDsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGFsbCBib2R5IGZvcmNlcyBpbiB0aGUgd29ybGQgdG8gemVyby4KICAgICAqLwoKCiAgICBjbGVhckZvcmNlcygpIHsKICAgICAgY29uc3QgYm9kaWVzID0gdGhpcy5ib2RpZXM7CiAgICAgIGNvbnN0IE4gPSBib2RpZXMubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IGIgPSBib2RpZXNbaV07CiAgICAgICAgYi5mb3JjZTsKICAgICAgICBiLnRvcnF1ZTsKICAgICAgICBiLmZvcmNlLnNldCgwLCAwLCAwKTsKICAgICAgICBiLnRvcnF1ZS5zZXQoMCwgMCwgMCk7CiAgICAgIH0KICAgIH0KCiAgfSAvLyBUZW1wIHN0dWZmCgogIG5ldyBBQUJCKCk7CiAgY29uc3QgdG1wUmF5ID0gbmV3IFJheSgpOyAvLyBwZXJmb3JtYW5jZS5ub3coKSBmYWxsYmFjayBvbiBEYXRlLm5vdygpCgogIGNvbnN0IHBlcmZvcm1hbmNlID0gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSB8fCB7fTsKCiAgaWYgKCFwZXJmb3JtYW5jZS5ub3cpIHsKICAgIGxldCBub3dPZmZzZXQgPSBEYXRlLm5vdygpOwoKICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCkgewogICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0OwogICAgfQoKICAgIHBlcmZvcm1hbmNlLm5vdyA9ICgpID0+IERhdGUubm93KCkgLSBub3dPZmZzZXQ7CiAgfQoKICBuZXcgVmVjMygpOyAvLyBEaXNwYXRjaGVkIGFmdGVyIHRoZSB3b3JsZCBoYXMgc3RlcHBlZCBmb3J3YXJkIGluIHRpbWUuCiAgLy8gUmV1c2FibGUgZXZlbnQgb2JqZWN0cyB0byBzYXZlIG1lbW9yeS4KCiAgY29uc3QgV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50ID0gewogICAgdHlwZTogJ3Bvc3RTdGVwJwogIH07IC8vIERpc3BhdGNoZWQgYmVmb3JlIHRoZSB3b3JsZCBzdGVwcyBmb3J3YXJkIGluIHRpbWUuCgogIGNvbnN0IFdvcmxkX3N0ZXBfcHJlU3RlcEV2ZW50ID0gewogICAgdHlwZTogJ3ByZVN0ZXAnCiAgfTsKICBjb25zdCBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCA9IHsKICAgIHR5cGU6IEJvZHkuQ09MTElERV9FVkVOVF9OQU1FLAogICAgYm9keTogbnVsbCwKICAgIGNvbnRhY3Q6IG51bGwKICB9OyAvLyBQb29scyBmb3IgdW51c2VkIG9iamVjdHMKCiAgY29uc3QgV29ybGRfc3RlcF9vbGRDb250YWN0cyA9IFtdOwogIGNvbnN0IFdvcmxkX3N0ZXBfZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTsgLy8gUmV1c2FibGUgYXJyYXlzIGZvciBjb2xsaXNpb24gcGFpcnMKCiAgY29uc3QgV29ybGRfc3RlcF9wMSA9IFtdOwogIGNvbnN0IFdvcmxkX3N0ZXBfcDIgPSBbXTsgLy8gU3R1ZmYgZm9yIGVtaXRDb250YWN0RXZlbnRzCgogIGNvbnN0IGFkZGl0aW9ucyA9IFtdOwogIGNvbnN0IHJlbW92YWxzID0gW107CiAgY29uc3QgYmVnaW5Db250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnYmVnaW5Db250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwKICB9OwogIGNvbnN0IGVuZENvbnRhY3RFdmVudCA9IHsKICAgIHR5cGU6ICdlbmRDb250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwKICB9OwogIGNvbnN0IGJlZ2luU2hhcGVDb250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnYmVnaW5TaGFwZUNvbnRhY3QnLAogICAgYm9keUE6IG51bGwsCiAgICBib2R5QjogbnVsbCwKICAgIHNoYXBlQTogbnVsbCwKICAgIHNoYXBlQjogbnVsbAogIH07CiAgY29uc3QgZW5kU2hhcGVDb250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnZW5kU2hhcGVDb250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwsCiAgICBzaGFwZUE6IG51bGwsCiAgICBzaGFwZUI6IG51bGwKICB9OwoKICBjb25zdCBhZGRDb250YWN0TWF0ZXJpYWwgPSAod29ybGQsIGNyZWF0ZU1hdGVyaWFsLCBfcmVmLCB1dWlkKSA9PiB7CiAgICBsZXQgW21hdGVyaWFsQSwgbWF0ZXJpYWxCLCBvcHRpb25zXSA9IF9yZWY7CiAgICBjb25zdCBtYXRBID0gY3JlYXRlTWF0ZXJpYWwobWF0ZXJpYWxBKTsKICAgIGNvbnN0IG1hdEIgPSBjcmVhdGVNYXRlcmlhbChtYXRlcmlhbEIpOwogICAgY29uc3QgY29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbChtYXRBLCBtYXRCLCBvcHRpb25zKTsKICAgIGNvbnRhY3RNYXRlcmlhbC51dWlkID0gdXVpZDsKICAgIHdvcmxkLmFkZENvbnRhY3RNYXRlcmlhbChjb250YWN0TWF0ZXJpYWwpOwogIH07CiAgY29uc3QgcmVtb3ZlQ29udGFjdE1hdGVyaWFsID0gKHdvcmxkLCBjbVVVSUQpID0+IHsKICAgIGNvbnN0IGluZGV4ID0gd29ybGQuY29udGFjdG1hdGVyaWFscy5maW5kSW5kZXgoX3JlZjIgPT4gewogICAgICBsZXQgewogICAgICAgIHV1aWQKICAgICAgfSA9IF9yZWYyOwogICAgICByZXR1cm4gdXVpZCA9PT0gY21VVUlEOwogICAgfSk7CiAgICBjb25zdCBbewogICAgICBpZDogaQogICAgfSwgewogICAgICBpZDogagogICAgfV0gPSB3b3JsZC5jb250YWN0bWF0ZXJpYWxzW2luZGV4XS5tYXRlcmlhbHM7CiAgICB3b3JsZC5jb250YWN0bWF0ZXJpYWxzLnNwbGljZShpbmRleCwgMSk7CiAgICBkZWxldGUgd29ybGQuY29udGFjdE1hdGVyaWFsVGFibGUuZGF0YVtpIDwgaiA/IGAke2l9LSR7an1gIDogYCR7an0tJHtpfWBdOwogIH07CgogIGxldCBtYXRlcmlhbElkID0gMDsKICBjb25zdCBjcmVhdGVNYXRlcmlhbEZhY3RvcnkgPSBtYXRlcmlhbHMgPT4gZnVuY3Rpb24gKG5hbWVPck9wdGlvbnMpIHsKICAgIGlmIChuYW1lT3JPcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgbmFtZU9yT3B0aW9ucyA9IHt9OwogICAgfQogICAgY29uc3QgbWF0ZXJpYWxPcHRpb25zID0gdHlwZW9mIG5hbWVPck9wdGlvbnMgPT09ICdzdHJpbmcnID8gewogICAgICBuYW1lOiBuYW1lT3JPcHRpb25zCiAgICB9IDogewogICAgICBuYW1lOiBTeW1ib2wuZm9yKGBNYXRlcmlhbCR7bWF0ZXJpYWxJZCsrfWApLAogICAgICAuLi5uYW1lT3JPcHRpb25zCiAgICB9OwogICAgY29uc3QgewogICAgICBuYW1lCiAgICB9ID0gbWF0ZXJpYWxPcHRpb25zOwogICAgbWF0ZXJpYWxzW25hbWVdID0gbWF0ZXJpYWxzW25hbWVdIHx8IG5ldyBNYXRlcmlhbChtYXRlcmlhbE9wdGlvbnMpOwogICAgcmV0dXJuIG1hdGVyaWFsc1tuYW1lXTsKICB9OwoKICAvKioKICAgKiBAdHlwZWRlZiB7IGltcG9ydCgnY2Fubm9uLWVzJykuTWF0ZXJpYWxPcHRpb25zIH0gTWF0ZXJpYWxPcHRpb25zCiAgICovCgogIGNvbnN0IG1ha2VWZWMzID0gX3JlZiA9PiB7CiAgICBsZXQgW3gsIHksIHpdID0gX3JlZjsKICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTsKICB9OwogIGNvbnN0IHByZXBhcmVTcGhlcmUgPSBhcmdzID0+IEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdOwogIGNvbnN0IHByZXBhcmVDb252ZXhQb2x5aGVkcm9uID0gX3JlZjIgPT4gewogICAgbGV0IFt2LCBmYWNlcywgbiwgYSwgYm91bmRpbmdTcGhlcmVSYWRpdXNdID0gX3JlZjI7CiAgICByZXR1cm4gW3sKICAgICAgYXhlczogYSA/IGEubWFwKG1ha2VWZWMzKSA6IHVuZGVmaW5lZCwKICAgICAgYm91bmRpbmdTcGhlcmVSYWRpdXMsCiAgICAgIGZhY2VzLAogICAgICBub3JtYWxzOiBuID8gbi5tYXAobWFrZVZlYzMpIDogdW5kZWZpbmVkLAogICAgICB2ZXJ0aWNlczogdiA/IHYubWFwKG1ha2VWZWMzKSA6IHVuZGVmaW5lZAogICAgfV07CiAgfTsKICBmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBhcmdzKSB7CiAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgY2FzZSAnQm94JzoKICAgICAgICByZXR1cm4gbmV3IEJveChuZXcgVmVjMyguLi5hcmdzLm1hcCh2ID0+IHYgLyAyKSkpOwogICAgICAvLyBleHRlbnRzID0+IGhhbGZFeHRlbnRzCiAgICAgIGNhc2UgJ0NvbnZleFBvbHloZWRyb24nOgogICAgICAgIHJldHVybiBuZXcgQ29udmV4UG9seWhlZHJvbiguLi5wcmVwYXJlQ29udmV4UG9seWhlZHJvbihhcmdzKSk7CiAgICAgIGNhc2UgJ0N5bGluZGVyJzoKICAgICAgICByZXR1cm4gbmV3IEN5bGluZGVyKC4uLmFyZ3MpOwogICAgICAvLyBbIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIG51bVNlZ21lbnRzIF0gPSBhcmdzCiAgICAgIGNhc2UgJ0hlaWdodGZpZWxkJzoKICAgICAgICByZXR1cm4gbmV3IEhlaWdodGZpZWxkKC4uLmFyZ3MpOwogICAgICAvLyBbIEFycmF5IGRhdGEsIG9wdGlvbnM6IHttaW5WYWx1ZSwgbWF4VmFsdWUsIGVsZW1lbnRTaXplfSAgXSA9IGFyZ3MKICAgICAgY2FzZSAnUGFydGljbGUnOgogICAgICAgIHJldHVybiBuZXcgUGFydGljbGUoKTsKICAgICAgLy8gbm8gYXJncwogICAgICBjYXNlICdQbGFuZSc6CiAgICAgICAgcmV0dXJuIG5ldyBQbGFuZSgpOwogICAgICAvLyBubyBhcmdzLCBpbmZpbml0ZSB4IGFuZCB5CiAgICAgIGNhc2UgJ1NwaGVyZSc6CiAgICAgICAgcmV0dXJuIG5ldyBTcGhlcmUoLi4ucHJlcGFyZVNwaGVyZShhcmdzKSk7CiAgICAgIC8vIHJhZGl1cyA9IGFyZ3MKICAgICAgY2FzZSAnVHJpbWVzaCc6CiAgICAgICAgcmV0dXJuIG5ldyBUcmltZXNoKC4uLmFyZ3MpOwogICAgICAvLyBbdmVydGljZXMsIGluZGljZXNdID0gYXJncwogICAgfQogIH0KCiAgLyoqCiAgICogQHBhcmFtIHtUSFJFRS5RdWF0ZXJuaW9ufSB0YXJnZXQKICAgKiBAcGFyYW0ge3sgcm90YXRpb24/OiBUSFJFRS5WZWN0b3IzVHVwbGUgcXVhdGVybmlvbj86IFRIUkVFLlZlY3RvcjRUdXBsZSB9fSBwcm9wcwogICAqIEByZXR1cm5zIHtUSFJFRS5RdWF0ZXJuaW9ufQogICAqLwogIGNvbnN0IHNldFF1YXRlcm5pb24gPSAodGFyZ2V0LCBfcmVmMykgPT4gewogICAgbGV0IHsKICAgICAgcXVhdGVybmlvbiwKICAgICAgcm90YXRpb24KICAgIH0gPSBfcmVmMzsKICAgIGlmIChxdWF0ZXJuaW9uKSB7CiAgICAgIHRhcmdldC5zZXQoLi4ucXVhdGVybmlvbik7CiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uKSB7CiAgICAgIHRhcmdldC5zZXRGcm9tRXVsZXIoLi4ucm90YXRpb24pOwogICAgfQogICAgcmV0dXJuIHRhcmdldDsKICB9OwoKICAvKioKICAgKiBAZnVuY3Rpb24KICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucwogICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnV1aWQKICAgKiBAcGFyYW0ge0JvZHlQcm9wc30gb3B0aW9ucy5wcm9wcwogICAqIEBwYXJhbSB7Qm9keVNoYXBlVHlwZX0gb3B0aW9ucy50eXBlCiAgICogQHBhcmFtIHsobWF0ZXJpYWxPcHRpb25zOiBNYXRlcmlhbE9wdGlvbnMpID0+IE1hdGVyaWFsID19IG9wdGlvbnMuY3JlYXRlTWF0ZXJpYWwKICAgKiBAcmV0dXJucyB7Qm9keX0KICAgKi8KICBjb25zdCBwcm9wc1RvQm9keSA9IG9wdGlvbnMgPT4gewogICAgY29uc3QgewogICAgICB1dWlkLAogICAgICBwcm9wcywKICAgICAgdHlwZSwKICAgICAgY3JlYXRlTWF0ZXJpYWwgPSBtYXRlcmlhbE9wdGlvbnMgPT4gbmV3IE1hdGVyaWFsKG1hdGVyaWFsT3B0aW9ucykKICAgIH0gPSBvcHRpb25zOwogICAgY29uc3QgewogICAgICBhbmd1bGFyRmFjdG9yID0gWzEsIDEsIDFdLAogICAgICBhbmd1bGFyVmVsb2NpdHkgPSBbMCwgMCwgMF0sCiAgICAgIGFyZ3MgPSBbXSwKICAgICAgY29sbGlzaW9uUmVzcG9uc2UsCiAgICAgIGxpbmVhckZhY3RvciA9IFsxLCAxLCAxXSwKICAgICAgbWFzcywKICAgICAgbWF0ZXJpYWwsCiAgICAgIG9uQ29sbGlkZSwKICAgICAgcG9zaXRpb24gPSBbMCwgMCwgMF0sCiAgICAgIHJvdGF0aW9uLAogICAgICBxdWF0ZXJuaW9uLAogICAgICBzaGFwZXMsCiAgICAgIHR5cGU6IGJvZHlUeXBlLAogICAgICB2ZWxvY2l0eSA9IFswLCAwLCAwXSwKICAgICAgLi4uZXh0cmEKICAgIH0gPSBwcm9wczsKICAgIGNvbnN0IGJvZHkgPSBuZXcgQm9keSh7CiAgICAgIC4uLmV4dHJhLAogICAgICBtYXNzOiBib2R5VHlwZSA9PT0gJ1N0YXRpYycgPyAwIDogbWFzcywKICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsID8gY3JlYXRlTWF0ZXJpYWwobWF0ZXJpYWwpIDogdW5kZWZpbmVkLAogICAgICB0eXBlOiBib2R5VHlwZSA/IEJvZHlbYm9keVR5cGUudG9VcHBlckNhc2UoKV0gOiB1bmRlZmluZWQKICAgIH0pOwogICAgYm9keS51dWlkID0gdXVpZDsKICAgIGlmIChjb2xsaXNpb25SZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgIGJvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSBjb2xsaXNpb25SZXNwb25zZTsKICAgIH0KICAgIGlmICh0eXBlID09PSAnQ29tcG91bmQnKSB7CiAgICAgIHNoYXBlcy5mb3JFYWNoKF9yZWY0ID0+IHsKICAgICAgICBsZXQgewogICAgICAgICAgdHlwZSwKICAgICAgICAgIGFyZ3MsCiAgICAgICAgICBwb3NpdGlvbiwKICAgICAgICAgIHJvdGF0aW9uLAogICAgICAgICAgcXVhdGVybmlvbiwKICAgICAgICAgIG1hdGVyaWFsLAogICAgICAgICAgLi4uZXh0cmEKICAgICAgICB9ID0gX3JlZjQ7CiAgICAgICAgY29uc3Qgc2hhcGVCb2R5ID0gYm9keS5hZGRTaGFwZShjcmVhdGVTaGFwZSh0eXBlLCBhcmdzKSwgcG9zaXRpb24gPyBuZXcgVmVjMyguLi5wb3NpdGlvbikgOiB1bmRlZmluZWQsIHNldFF1YXRlcm5pb24obmV3IFF1YXRlcm5pb24oMCwgMCwgMCwgMSksIHsKICAgICAgICAgIHF1YXRlcm5pb24sCiAgICAgICAgICByb3RhdGlvbgogICAgICAgIH0pKTsKICAgICAgICBpZiAobWF0ZXJpYWwpIHNoYXBlQm9keS5tYXRlcmlhbCA9IGNyZWF0ZU1hdGVyaWFsKG1hdGVyaWFsKTsKICAgICAgICBPYmplY3QuYXNzaWduKHNoYXBlQm9keSwgZXh0cmEpOwogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIGJvZHkuYWRkU2hhcGUoY3JlYXRlU2hhcGUodHlwZSwgYXJncykpOwogICAgfQogICAgYm9keS5wb3NpdGlvbi5zZXQocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCBwb3NpdGlvblsyXSk7CiAgICBib2R5LnZlbG9jaXR5LnNldCh2ZWxvY2l0eVswXSwgdmVsb2NpdHlbMV0sIHZlbG9jaXR5WzJdKTsKICAgIGJvZHkuYW5ndWxhclZlbG9jaXR5LnNldChhbmd1bGFyVmVsb2NpdHlbMF0sIGFuZ3VsYXJWZWxvY2l0eVsxXSwgYW5ndWxhclZlbG9jaXR5WzJdKTsKICAgIGJvZHkubGluZWFyRmFjdG9yLnNldChsaW5lYXJGYWN0b3JbMF0sIGxpbmVhckZhY3RvclsxXSwgbGluZWFyRmFjdG9yWzJdKTsKICAgIGJvZHkuYW5ndWxhckZhY3Rvci5zZXQoYW5ndWxhckZhY3RvclswXSwgYW5ndWxhckZhY3RvclsxXSwgYW5ndWxhckZhY3RvclsyXSk7CiAgICBzZXRRdWF0ZXJuaW9uKGJvZHkucXVhdGVybmlvbiwgewogICAgICBxdWF0ZXJuaW9uLAogICAgICByb3RhdGlvbgogICAgfSk7CiAgICByZXR1cm4gYm9keTsKICB9OwoKICBjb25zdCBhZGRCb2RpZXMgPSAoc3RhdGUsIGNyZWF0ZU1hdGVyaWFsLCBfcmVmKSA9PiB7CiAgICBsZXQgewogICAgICBwcm9wcywKICAgICAgdHlwZSwKICAgICAgdXVpZAogICAgfSA9IF9yZWY7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV1aWQubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgYm9keSA9IHByb3BzVG9Cb2R5KHsKICAgICAgICBjcmVhdGVNYXRlcmlhbCwKICAgICAgICBwcm9wczogcHJvcHNbaV0sCiAgICAgICAgdHlwZSwKICAgICAgICB1dWlkOiB1dWlkW2ldCiAgICAgIH0pOwogICAgICBzdGF0ZS53b3JsZC5hZGRCb2R5KGJvZHkpOwogICAgICBpZiAocHJvcHNbaV0ub25Db2xsaWRlKSBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbGxpZGUnLCBfcmVmMiA9PiB7CiAgICAgICAgbGV0IHsKICAgICAgICAgIHR5cGUsCiAgICAgICAgICBib2R5LAogICAgICAgICAgdGFyZ2V0LAogICAgICAgICAgY29udGFjdAogICAgICAgIH0gPSBfcmVmMjsKICAgICAgICBpZiAoIWJvZHkudXVpZCB8fCAhdGFyZ2V0LnV1aWQpIHJldHVybjsKICAgICAgICBjb25zdCB7CiAgICAgICAgICBuaSwKICAgICAgICAgIHJpLAogICAgICAgICAgcmosCiAgICAgICAgICBiaSwKICAgICAgICAgIGJqLAogICAgICAgICAgaWQKICAgICAgICB9ID0gY29udGFjdDsKICAgICAgICBjb25zdCBjb250YWN0UG9pbnQgPSBiaS5wb3NpdGlvbi52YWRkKHJpKTsKICAgICAgICBjb25zdCBjb250YWN0Tm9ybWFsID0gYmkgPT09IGJvZHkgPyBuaSA6IG5pLnNjYWxlKC0xKTsKICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgICAgIGJvZHk6IGJvZHkudXVpZCwKICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcnM6IHsKICAgICAgICAgICAgYm9keUZpbHRlckdyb3VwOiBib2R5LmNvbGxpc2lvbkZpbHRlckdyb3VwLAogICAgICAgICAgICBib2R5RmlsdGVyTWFzazogYm9keS5jb2xsaXNpb25GaWx0ZXJNYXNrLAogICAgICAgICAgICB0YXJnZXRGaWx0ZXJHcm91cDogdGFyZ2V0LmNvbGxpc2lvbkZpbHRlckdyb3VwLAogICAgICAgICAgICB0YXJnZXRGaWx0ZXJNYXNrOiB0YXJnZXQuY29sbGlzaW9uRmlsdGVyTWFzawogICAgICAgICAgfSwKICAgICAgICAgIGNvbnRhY3Q6IHsKICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiB1c2UgaWQgaW5zdGVhZCBvZiB1dWlkCiAgICAgICAgICAgIGJpOiBiaS51dWlkLAogICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IHVzZSBpZCBpbnN0ZWFkIG9mIHV1aWQKICAgICAgICAgICAgYmo6IGJqLnV1aWQsCiAgICAgICAgICAgIC8vIE5vcm1hbCBvZiB0aGUgY29udGFjdCwgcmVsYXRpdmUgdG8gdGhlIGNvbGxpZGluZyBib2R5CiAgICAgICAgICAgIGNvbnRhY3ROb3JtYWw6IGNvbnRhY3ROb3JtYWwudG9BcnJheSgpLAogICAgICAgICAgICAvLyBXb3JsZCBwb3NpdGlvbiBvZiB0aGUgY29udGFjdAogICAgICAgICAgICBjb250YWN0UG9pbnQ6IGNvbnRhY3RQb2ludC50b0FycmF5KCksCiAgICAgICAgICAgIGlkLAogICAgICAgICAgICBpbXBhY3RWZWxvY2l0eTogY29udGFjdC5nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsKCksCiAgICAgICAgICAgIG5pOiBuaS50b0FycmF5KCksCiAgICAgICAgICAgIHJpOiByaS50b0FycmF5KCksCiAgICAgICAgICAgIHJqOiByai50b0FycmF5KCkKICAgICAgICAgIH0sCiAgICAgICAgICBvcDogJ2V2ZW50JywKICAgICAgICAgIHRhcmdldDogdGFyZ2V0LnV1aWQsCiAgICAgICAgICB0eXBlCiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgfQogIH07CgogIGNvbnN0IHRyaXBsZXRUb1ZlYzMgPSB0ID0+IHQgPyBuZXcgVmVjMyguLi50KSA6IHVuZGVmaW5lZDsKCiAgY29uc3QgYWRkQ29uc3RyYWludCA9IChzdGF0ZSwgX3JlZikgPT4gewogICAgbGV0IHsKICAgICAgcHJvcHM6IFtib2R5QSwgYm9keUIsIHsKICAgICAgICBhbmdsZSwKICAgICAgICBheGlzQSwKICAgICAgICBheGlzQiwKICAgICAgICBjb2xsaWRlQ29ubmVjdGVkLAogICAgICAgIGRpc3RhbmNlLAogICAgICAgIG1heEZvcmNlLAogICAgICAgIG1heE11bHRpcGxpZXIsCiAgICAgICAgcGl2b3RBLAogICAgICAgIHBpdm90QiwKICAgICAgICB0d2lzdEFuZ2xlLAogICAgICAgIHdha2VVcEJvZGllcwogICAgICB9XSwKICAgICAgdHlwZSwKICAgICAgdXVpZAogICAgfSA9IF9yZWY7CiAgICBsZXQgY29uc3RyYWludDsKICAgIHN3aXRjaCAodHlwZSkgewogICAgICBjYXNlICdQb2ludFRvUG9pbnQnOgogICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCB0cmlwbGV0VG9WZWMzKHBpdm90QSksIHN0YXRlLmJvZGllc1tib2R5Ql0sIHRyaXBsZXRUb1ZlYzMocGl2b3RCKSwgbWF4Rm9yY2UpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdDb25lVHdpc3QnOgogICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQ29uZVR3aXN0Q29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCB7CiAgICAgICAgICBhbmdsZSwKICAgICAgICAgIGF4aXNBOiB0cmlwbGV0VG9WZWMzKGF4aXNBKSwKICAgICAgICAgIGF4aXNCOiB0cmlwbGV0VG9WZWMzKGF4aXNCKSwKICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQsCiAgICAgICAgICBtYXhGb3JjZSwKICAgICAgICAgIHBpdm90QTogdHJpcGxldFRvVmVjMyhwaXZvdEEpLAogICAgICAgICAgcGl2b3RCOiB0cmlwbGV0VG9WZWMzKHBpdm90QiksCiAgICAgICAgICB0d2lzdEFuZ2xlCiAgICAgICAgfSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ0hpbmdlJzoKICAgICAgICBjb25zdHJhaW50ID0gbmV3IEhpbmdlQ29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCB7CiAgICAgICAgICBheGlzQTogdHJpcGxldFRvVmVjMyhheGlzQSksCiAgICAgICAgICBheGlzQjogdHJpcGxldFRvVmVjMyhheGlzQiksCiAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkLAogICAgICAgICAgbWF4Rm9yY2UsCiAgICAgICAgICBwaXZvdEE6IHRyaXBsZXRUb1ZlYzMocGl2b3RBKSwKICAgICAgICAgIHBpdm90QjogdHJpcGxldFRvVmVjMyhwaXZvdEIpCiAgICAgICAgfSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ0Rpc3RhbmNlJzoKICAgICAgICBjb25zdHJhaW50ID0gbmV3IERpc3RhbmNlQ29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCBkaXN0YW5jZSwgbWF4Rm9yY2UpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdMb2NrJzoKICAgICAgICBjb25zdHJhaW50ID0gbmV3IExvY2tDb25zdHJhaW50KHN0YXRlLmJvZGllc1tib2R5QV0sIHN0YXRlLmJvZGllc1tib2R5Ql0sIHsKICAgICAgICAgIG1heEZvcmNlCiAgICAgICAgfSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgY29uc3RyYWludCA9IG5ldyBDb25zdHJhaW50KHN0YXRlLmJvZGllc1tib2R5QV0sIHN0YXRlLmJvZGllc1tib2R5Ql0sIHsKICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQsCiAgICAgICAgICB3YWtlVXBCb2RpZXMKICAgICAgICB9KTsKICAgICAgICBicmVhazsKICAgIH0KICAgIGNvbnN0cmFpbnQudXVpZCA9IHV1aWQ7CiAgICBzdGF0ZS53b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpOwogICAgaWYgKG1heE11bHRpcGxpZXIgIT09IHVuZGVmaW5lZCkgewogICAgICBjb25zdCBwb3N0U3RlcENvbnN0cmFpbnQgPSAoKSA9PiB7CiAgICAgICAgLy8gVGhlIG11bHRpcGxpZXIgaXMgcHJvcG9ydGlvbmFsIHRvIGhvdyBtdWNoIGZvcmNlIGlzIGFkZGVkIHRvIHRoZSBib2RpZXMgYnkgdGhlIGNvbnN0cmFpbnQuCiAgICAgICAgLy8gSWYgdGhpcyBleGNlZWRzIGEgbGltaXQgdGhlIGNvbnN0cmFpbnQgaXMgZGlzYWJsZWQuCiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IE1hdGguYWJzKGNvbnN0cmFpbnQuZXF1YXRpb25zWzBdLm11bHRpcGxpZXIpOwogICAgICAgIGlmIChtdWx0aXBsaWVyID4gbWF4TXVsdGlwbGllcikgewogICAgICAgICAgY29uc3RyYWludC5kaXNhYmxlKCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBzdGF0ZS5jb25zdHJhaW50c1t1dWlkXSA9IHBvc3RTdGVwQ29uc3RyYWludDsKICAgICAgc3RhdGUud29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncG9zdFN0ZXAnLCBzdGF0ZS5jb25zdHJhaW50c1t1dWlkXSk7CiAgICB9CiAgfTsKCiAgZnVuY3Rpb24gdG9VcHBlcmNhc2Uoc3RyKSB7CiAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7CiAgfQogIGNvbnN0IGFkZFJheSA9IChzdGF0ZSwgX3JlZikgPT4gewogICAgbGV0IHsKICAgICAgcHJvcHM6IHsKICAgICAgICBmcm9tLAogICAgICAgIG1vZGUsCiAgICAgICAgdG8sCiAgICAgICAgLi4ucmF5T3B0aW9ucwogICAgICB9LAogICAgICB1dWlkCiAgICB9ID0gX3JlZjsKICAgIGNvbnN0IHJheSA9IG5ldyBSYXkodHJpcGxldFRvVmVjMyhmcm9tKSwgdHJpcGxldFRvVmVjMyh0bykpOwogICAgY29uc3Qgb3B0aW9ucyA9IHsKICAgICAgbW9kZTogUkFZX01PREVTW3RvVXBwZXJjYXNlKG1vZGUpXSwKICAgICAgcmVzdWx0OiBuZXcgUmF5Y2FzdFJlc3VsdCgpLAogICAgICAuLi5yYXlPcHRpb25zCiAgICB9OwogICAgc3RhdGUucmF5c1t1dWlkXSA9ICgpID0+IHsKICAgICAgcmF5LmludGVyc2VjdFdvcmxkKHN0YXRlLndvcmxkLCBvcHRpb25zKTsKICAgICAgaWYgKCFvcHRpb25zLnJlc3VsdCB8fCAhb3B0aW9ucy5yZXN1bHQuYm9keSkgcmV0dXJuOwogICAgICBjb25zdCB7CiAgICAgICAgYm9keSwKICAgICAgICBzaGFwZSwKICAgICAgICByYXlGcm9tV29ybGQsCiAgICAgICAgcmF5VG9Xb3JsZCwKICAgICAgICBoaXROb3JtYWxXb3JsZCwKICAgICAgICBoaXRQb2ludFdvcmxkLAogICAgICAgIC4uLnJlc3QKICAgICAgfSA9IG9wdGlvbnMucmVzdWx0OwogICAgICBjb25zdCBib2R5VVVJRCA9IGJvZHkudXVpZDsKICAgICAgaWYgKCFib2R5VVVJRCkgcmV0dXJuOwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgICBib2R5OiBib2R5VVVJRCwKICAgICAgICBoaXROb3JtYWxXb3JsZDogaGl0Tm9ybWFsV29ybGQudG9BcnJheSgpLAogICAgICAgIGhpdFBvaW50V29ybGQ6IGhpdFBvaW50V29ybGQudG9BcnJheSgpLAogICAgICAgIG9wOiAnZXZlbnQnLAogICAgICAgIHJheTogewogICAgICAgICAgY29sbGlzaW9uRmlsdGVyR3JvdXA6IHJheS5jb2xsaXNpb25GaWx0ZXJHcm91cCwKICAgICAgICAgIGNvbGxpc2lvbkZpbHRlck1hc2s6IHJheS5jb2xsaXNpb25GaWx0ZXJNYXNrLAogICAgICAgICAgZGlyZWN0aW9uOiByYXkuZGlyZWN0aW9uLnRvQXJyYXkoKSwKICAgICAgICAgIGZyb20sCiAgICAgICAgICB0bywKICAgICAgICAgIHV1aWQKICAgICAgICB9LAogICAgICAgIHJheUZyb21Xb3JsZDogcmF5RnJvbVdvcmxkLnRvQXJyYXkoKSwKICAgICAgICByYXlUb1dvcmxkOiByYXlUb1dvcmxkLnRvQXJyYXkoKSwKICAgICAgICBzaGFwZTogc2hhcGUgPyB7CiAgICAgICAgICAuLi5zaGFwZSwKICAgICAgICAgIGJvZHk6IGJvZHlVVUlECiAgICAgICAgfSA6IG51bGwsCiAgICAgICAgdHlwZTogJ3JheWhpdCcsCiAgICAgICAgLi4ucmVzdAogICAgICB9KTsKICAgIH07CiAgICBzdGF0ZS53b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgc3RhdGUucmF5c1t1dWlkXSk7CiAgfTsKCiAgY29uc3QgYWRkUmF5Y2FzdFZlaGljbGUgPSAoc3RhdGUsIGRhdGEpID0+IHsKICAgIGNvbnN0IFtjaGFzc2lzQm9keSwgd2hlZWxzLCB3aGVlbEluZm9zLCBpbmRleEZvcndhcmRBeGlzLCBpbmRleFJpZ2h0QXhpcywgaW5kZXhVcEF4aXNdID0gZGF0YS5wcm9wczsKICAgIGNvbnN0IHZlaGljbGUgPSBuZXcgUmF5Y2FzdFZlaGljbGUoewogICAgICBjaGFzc2lzQm9keTogc3RhdGUuYm9kaWVzW2NoYXNzaXNCb2R5XSwKICAgICAgaW5kZXhGb3J3YXJkQXhpcywKICAgICAgaW5kZXhSaWdodEF4aXMsCiAgICAgIGluZGV4VXBBeGlzCiAgICB9KTsKICAgIHZlaGljbGUud29ybGQgPSBzdGF0ZS53b3JsZDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2hlZWxJbmZvcy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCB7CiAgICAgICAgYXhsZUxvY2FsLAogICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbCwKICAgICAgICBkaXJlY3Rpb25Mb2NhbCwKICAgICAgICAuLi5yZXN0CiAgICAgIH0gPSB3aGVlbEluZm9zW2ldOwogICAgICB2ZWhpY2xlLmFkZFdoZWVsKHsKICAgICAgICBheGxlTG9jYWw6IHRyaXBsZXRUb1ZlYzMoYXhsZUxvY2FsKSwKICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWw6IHRyaXBsZXRUb1ZlYzMoY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsKSwKICAgICAgICBkaXJlY3Rpb25Mb2NhbDogdHJpcGxldFRvVmVjMyhkaXJlY3Rpb25Mb2NhbCksCiAgICAgICAgLi4ucmVzdAogICAgICB9KTsKICAgIH0KICAgIGNvbnN0IHByZVN0ZXAgPSAoKSA9PiB7CiAgICAgIHZlaGljbGUudXBkYXRlVmVoaWNsZShzdGF0ZS53b3JsZC5kdCk7CiAgICB9OwogICAgY29uc3QgcG9zdFN0ZXAgPSAoKSA9PiB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVoaWNsZS53aGVlbEluZm9zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmVoaWNsZS51cGRhdGVXaGVlbFRyYW5zZm9ybShpKTsKICAgICAgICBjb25zdCB0ID0gdmVoaWNsZS53aGVlbEluZm9zW2ldLndvcmxkVHJhbnNmb3JtOwogICAgICAgIGNvbnN0IHdoZWVsQm9keSA9IHN0YXRlLmJvZGllc1t3aGVlbHNbaV1dOwogICAgICAgIHdoZWVsQm9keS5wb3NpdGlvbi5jb3B5KHQucG9zaXRpb24pOwogICAgICAgIHdoZWVsQm9keS5xdWF0ZXJuaW9uLmNvcHkodC5xdWF0ZXJuaW9uKTsKICAgICAgfQogICAgfTsKICAgIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF0gPSB7CiAgICAgIHBvc3RTdGVwLAogICAgICBwcmVTdGVwLAogICAgICB2ZWhpY2xlCiAgICB9OwogICAgc3RhdGUud29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHByZVN0ZXApOwogICAgc3RhdGUud29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncG9zdFN0ZXAnLCBwb3N0U3RlcCk7CiAgfTsKCiAgY29uc3QgYWRkU3ByaW5nID0gKHN0YXRlLCBfcmVmKSA9PiB7CiAgICBsZXQgewogICAgICBwcm9wczogW2JvZHlBLCBib2R5QiwgewogICAgICAgIGRhbXBpbmcsCiAgICAgICAgbG9jYWxBbmNob3JBLAogICAgICAgIGxvY2FsQW5jaG9yQiwKICAgICAgICByZXN0TGVuZ3RoLAogICAgICAgIHN0aWZmbmVzcywKICAgICAgICB3b3JsZEFuY2hvckEsCiAgICAgICAgd29ybGRBbmNob3JCCiAgICAgIH1dLAogICAgICB1dWlkCiAgICB9ID0gX3JlZjsKICAgIGNvbnN0IHNwcmluZyA9IG5ldyBTcHJpbmcoc3RhdGUuYm9kaWVzW2JvZHlBXSwgc3RhdGUuYm9kaWVzW2JvZHlCXSwgewogICAgICBkYW1waW5nLAogICAgICBsb2NhbEFuY2hvckE6IHRyaXBsZXRUb1ZlYzMobG9jYWxBbmNob3JBKSwKICAgICAgbG9jYWxBbmNob3JCOiB0cmlwbGV0VG9WZWMzKGxvY2FsQW5jaG9yQiksCiAgICAgIHJlc3RMZW5ndGgsCiAgICAgIHN0aWZmbmVzcywKICAgICAgd29ybGRBbmNob3JBOiB0cmlwbGV0VG9WZWMzKHdvcmxkQW5jaG9yQSksCiAgICAgIHdvcmxkQW5jaG9yQjogdHJpcGxldFRvVmVjMyh3b3JsZEFuY2hvckIpCiAgICB9KTsKICAgIHNwcmluZy51dWlkID0gdXVpZDsKICAgIGNvbnN0IHBvc3RTdGVwU3ByaW5nID0gKCkgPT4gc3ByaW5nLmFwcGx5Rm9yY2UoKTsKICAgIHN0YXRlLnNwcmluZ3NbdXVpZF0gPSBwb3N0U3RlcFNwcmluZzsKICAgIHN0YXRlLnNwcmluZ0luc3RhbmNlc1t1dWlkXSA9IHNwcmluZzsKCiAgICAvLyBDb21wdXRlIHRoZSBmb3JjZSBhZnRlciBlYWNoIHN0ZXAKICAgIHN0YXRlLndvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgc3RhdGUuc3ByaW5nc1t1dWlkXSk7CiAgfTsKCiAgZnVuY3Rpb24gZW1pdEJlZ2luQ29udGFjdChfcmVmKSB7CiAgICBsZXQgewogICAgICBib2R5QSwKICAgICAgYm9keUIKICAgIH0gPSBfcmVmOwogICAgaWYgKCEoYm9keUEgIT0gbnVsbCAmJiBib2R5QS51dWlkKSB8fCAhKGJvZHlCICE9IG51bGwgJiYgYm9keUIudXVpZCkpIHJldHVybjsKICAgIHNlbGYucG9zdE1lc3NhZ2UoewogICAgICBib2R5QTogYm9keUEudXVpZCwKICAgICAgYm9keUI6IGJvZHlCLnV1aWQsCiAgICAgIG9wOiAnZXZlbnQnLAogICAgICB0eXBlOiAnY29sbGlkZUJlZ2luJwogICAgfSk7CiAgfQogIGZ1bmN0aW9uIGVtaXRFbmRDb250YWN0KF9yZWYyKSB7CiAgICBsZXQgewogICAgICBib2R5QSwKICAgICAgYm9keUIKICAgIH0gPSBfcmVmMjsKICAgIGlmICghKGJvZHlBICE9IG51bGwgJiYgYm9keUEudXVpZCkgfHwgIShib2R5QiAhPSBudWxsICYmIGJvZHlCLnV1aWQpKSByZXR1cm47CiAgICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgYm9keUE6IGJvZHlBLnV1aWQsCiAgICAgIGJvZHlCOiBib2R5Qi51dWlkLAogICAgICBvcDogJ2V2ZW50JywKICAgICAgdHlwZTogJ2NvbGxpZGVFbmQnCiAgICB9KTsKICB9CiAgY29uc3QgaW5pdCA9ICh3b3JsZCwgX3JlZjMpID0+IHsKICAgIGxldCB7CiAgICAgIGFsbG93U2xlZXAsCiAgICAgIGF4aXNJbmRleCA9IDAsCiAgICAgIGJyb2FkcGhhc2UsCiAgICAgIGRlZmF1bHRDb250YWN0TWF0ZXJpYWwsCiAgICAgIGZyaWN0aW9uR3Jhdml0eSwKICAgICAgZ3Jhdml0eSwKICAgICAgaXRlcmF0aW9ucywKICAgICAgcXVhdE5vcm1hbGl6ZUZhc3QsCiAgICAgIHF1YXROb3JtYWxpemVTa2lwLAogICAgICBzb2x2ZXIsCiAgICAgIHRvbGVyYW5jZQogICAgfSA9IF9yZWYzOwogICAgd29ybGQuYWxsb3dTbGVlcCA9IGFsbG93U2xlZXA7CiAgICB3b3JsZC5ncmF2aXR5LnNldCguLi5ncmF2aXR5KTsKICAgIHdvcmxkLmZyaWN0aW9uR3Jhdml0eSA9IGZyaWN0aW9uR3Jhdml0eSA/IG5ldyBWZWMzKC4uLmZyaWN0aW9uR3Jhdml0eSkgOiB1bmRlZmluZWQ7CiAgICB3b3JsZC5xdWF0Tm9ybWFsaXplRmFzdCA9IHF1YXROb3JtYWxpemVGYXN0OwogICAgd29ybGQucXVhdE5vcm1hbGl6ZVNraXAgPSBxdWF0Tm9ybWFsaXplU2tpcDsKICAgIGlmIChzb2x2ZXIgPT09ICdTcGxpdCcpIHsKICAgICAgd29ybGQuc29sdmVyID0gbmV3IFNwbGl0U29sdmVyKG5ldyBHU1NvbHZlcigpKTsKICAgIH0KICAgIGlmICh3b3JsZC5zb2x2ZXIgaW5zdGFuY2VvZiBHU1NvbHZlcikgewogICAgICB3b3JsZC5zb2x2ZXIudG9sZXJhbmNlID0gdG9sZXJhbmNlOwogICAgICB3b3JsZC5zb2x2ZXIuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7CiAgICB9CiAgICB3b3JsZC5icm9hZHBoYXNlID0gYnJvYWRwaGFzZSA9PT0gJ1NBUCcgPyBuZXcgU0FQQnJvYWRwaGFzZSh3b3JsZCkgOiBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7CiAgICBpZiAod29ybGQuYnJvYWRwaGFzZSBpbnN0YW5jZW9mIFNBUEJyb2FkcGhhc2UpIHsKICAgICAgd29ybGQuYnJvYWRwaGFzZS5heGlzSW5kZXggPSBheGlzSW5kZXg7CiAgICB9CiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdiZWdpbkNvbnRhY3QnLCBlbWl0QmVnaW5Db250YWN0KTsKICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZENvbnRhY3QnLCBlbWl0RW5kQ29udGFjdCk7CiAgICBPYmplY3QuYXNzaWduKHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwsIGRlZmF1bHRDb250YWN0TWF0ZXJpYWwpOwogIH07CgogIGNvbnN0IGlzUW9yViA9IHYgPT4gdiBpbnN0YW5jZW9mIFF1YXRlcm5pb24gfHwgdiBpbnN0YW5jZW9mIFZlYzM7CiAgY29uc3Qgc3RlcCA9IChzdGF0ZSwgX3JlZikgPT4gewogICAgbGV0IHsKICAgICAgcG9zaXRpb25zLAogICAgICBwcm9wczogewogICAgICAgIG1heFN1YlN0ZXBzLAogICAgICAgIHN0ZXBTaXplLAogICAgICAgIHRpbWVTaW5jZUxhc3RDYWxsZWQKICAgICAgfSwKICAgICAgcXVhdGVybmlvbnMKICAgIH0gPSBfcmVmOwogICAgc3RhdGUud29ybGQuc3RlcChzdGVwU2l6ZSwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS53b3JsZC5ib2RpZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgY29uc3QgcCA9IHN0YXRlLndvcmxkLmJvZGllc1tpXS5wb3NpdGlvbjsKICAgICAgY29uc3QgcSA9IHN0YXRlLndvcmxkLmJvZGllc1tpXS5xdWF0ZXJuaW9uOwogICAgICBwb3NpdGlvbnNbMyAqIGkgKyAwXSA9IHAueDsKICAgICAgcG9zaXRpb25zWzMgKiBpICsgMV0gPSBwLnk7CiAgICAgIHBvc2l0aW9uc1szICogaSArIDJdID0gcC56OwogICAgICBxdWF0ZXJuaW9uc1s0ICogaSArIDBdID0gcS54OwogICAgICBxdWF0ZXJuaW9uc1s0ICogaSArIDFdID0gcS55OwogICAgICBxdWF0ZXJuaW9uc1s0ICogaSArIDJdID0gcS56OwogICAgICBxdWF0ZXJuaW9uc1s0ICogaSArIDNdID0gcS53OwogICAgfQogICAgY29uc3Qgb2JzZXJ2YXRpb25zID0gW107CiAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHN0YXRlLnN1YnNjcmlwdGlvbnMpKSB7CiAgICAgIGNvbnN0IFt1dWlkLCB0eXBlLCB0YXJnZXQgPSAnYm9kaWVzJ10gPSBzdGF0ZS5zdWJzY3JpcHRpb25zW2lkXTsKICAgICAgY29uc3QgewogICAgICAgIGJvZGllcywKICAgICAgICB2ZWhpY2xlcwogICAgICB9ID0gc3RhdGU7CiAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0ID09PSAndmVoaWNsZXMnID8KICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBEaWZmZXJlbnRpYXRlIHRoZXNlICJ0eXBlcyIKICAgICAgdmVoaWNsZXNbdXVpZF0udmVoaWNsZVt0eXBlXSA6CiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogRGlmZmVyZW50aWF0ZSB0aGVzZSAidHlwZXMiCiAgICAgIGJvZGllc1t1dWlkXVt0eXBlXTsKICAgICAgY29uc3Qgc2VyaWFsaXphYmxlVmFsdWUgPSBpc1FvclYodmFsdWUpID8gdmFsdWUudG9BcnJheSgpIDogdmFsdWU7CiAgICAgIG9ic2VydmF0aW9ucy5wdXNoKFtOdW1iZXIoaWQpLCBzZXJpYWxpemFibGVWYWx1ZSwKICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBEaWZmZXJlbnRpYXRlIHRoZXNlICJ0eXBlcyIKICAgICAgdHlwZV0pOwogICAgfQogICAgY29uc3QgbWVzc2FnZSA9IHsKICAgICAgYWN0aXZlOiBzdGF0ZS53b3JsZC5oYXNBY3RpdmVCb2RpZXMsCiAgICAgIG9ic2VydmF0aW9ucywKICAgICAgb3A6ICdmcmFtZScsCiAgICAgIHBvc2l0aW9ucywKICAgICAgcXVhdGVybmlvbnMKICAgIH07CiAgICBpZiAoc3RhdGUuYm9kaWVzTmVlZFN5bmNpbmcpIHsKICAgICAgbWVzc2FnZS5ib2RpZXMgPSBzdGF0ZS53b3JsZC5ib2RpZXMucmVkdWNlKChib2RpZXMsIGJvZHkpID0+IHsKICAgICAgICBpZiAoYm9keS51dWlkKSBib2RpZXMucHVzaChib2R5LnV1aWQpOwogICAgICAgIHJldHVybiBib2RpZXM7CiAgICAgIH0sIFtdKTsKICAgICAgc3RhdGUuYm9kaWVzTmVlZFN5bmNpbmcgPSBmYWxzZTsKICAgIH0KICAgIHNlbGYucG9zdE1lc3NhZ2UobWVzc2FnZSwgW3Bvc2l0aW9ucy5idWZmZXIsIHF1YXRlcm5pb25zLmJ1ZmZlcl0pOwogIH07CgogIGNvbnN0IHN0YXRlID0gewogICAgYm9kaWVzOiB7fSwKICAgIGJvZGllc05lZWRTeW5jaW5nOiBmYWxzZSwKICAgIGNvbnN0cmFpbnRzOiB7fSwKICAgIG1hdGVyaWFsczoge30sCiAgICByYXlzOiB7fSwKICAgIHNwcmluZ0luc3RhbmNlczoge30sCiAgICBzcHJpbmdzOiB7fSwKICAgIHN1YnNjcmlwdGlvbnM6IHt9LAogICAgdmVoaWNsZXM6IHt9LAogICAgd29ybGQ6IG5ldyBXb3JsZCgpCiAgfTsKCiAgLy8vIDxyZWZlcmVuY2Ugbm8tZGVmYXVsdC1saWI9InRydWUiLz4KICBjb25zdCBpc0hpbmdlQ29uc3RyYWludCA9IGMgPT4gYyBpbnN0YW5jZW9mIEhpbmdlQ29uc3RyYWludDsKICBmdW5jdGlvbiBzeW5jQm9kaWVzKCkgewogICAgc3RhdGUuYm9kaWVzTmVlZFN5bmNpbmcgPSB0cnVlOwogICAgc3RhdGUuYm9kaWVzID0gc3RhdGUud29ybGQuYm9kaWVzLnJlZHVjZSgoYm9kaWVzLCBib2R5KSA9PiBib2R5LnV1aWQgPyB7CiAgICAgIC4uLmJvZGllcywKICAgICAgW2JvZHkudXVpZF06IGJvZHkKICAgIH0gOiBib2RpZXMsIHt9KTsKICB9CiAgY29uc3QgYnJvYWRwaGFzZXMgPSB7CiAgICBOYWl2ZUJyb2FkcGhhc2UsCiAgICBTQVBCcm9hZHBoYXNlCiAgfTsKICBjb25zdCBjcmVhdGVNYXRlcmlhbCA9IGNyZWF0ZU1hdGVyaWFsRmFjdG9yeShzdGF0ZS5tYXRlcmlhbHMpOwogIHNlbGYub25tZXNzYWdlID0gX3JlZiA9PiB7CiAgICBsZXQgewogICAgICBkYXRhCiAgICB9ID0gX3JlZjsKICAgIHN3aXRjaCAoZGF0YS5vcCkgewogICAgICBjYXNlICdpbml0JzoKICAgICAgICB7CiAgICAgICAgICBpbml0KHN0YXRlLndvcmxkLCBkYXRhLnByb3BzKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc3RlcCc6CiAgICAgICAgewogICAgICAgICAgc3RlcChzdGF0ZSwgZGF0YSk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ2FkZEJvZGllcyc6CiAgICAgICAgewogICAgICAgICAgYWRkQm9kaWVzKHN0YXRlLCBjcmVhdGVNYXRlcmlhbCwgZGF0YSk7CiAgICAgICAgICBzeW5jQm9kaWVzKCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3JlbW92ZUJvZGllcyc6CiAgICAgICAgewogICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLnV1aWQubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgc3RhdGUud29ybGQucmVtb3ZlQm9keShzdGF0ZS5ib2RpZXNbZGF0YS51dWlkW2ldXSk7CiAgICAgICAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKHN0YXRlLnN1YnNjcmlwdGlvbnMpLmZpbmQoayA9PiBzdGF0ZS5zdWJzY3JpcHRpb25zW2tdWzBdID09PSBkYXRhLnV1aWRbaV0pOwogICAgICAgICAgICBpZiAoa2V5KSB7CiAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnN1YnNjcmlwdGlvbnNba2V5XTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgc3luY0JvZGllcygpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzdWJzY3JpYmUnOgogICAgICAgIHsKICAgICAgICAgIGNvbnN0IHsKICAgICAgICAgICAgaWQsCiAgICAgICAgICAgIHRhcmdldCwKICAgICAgICAgICAgdHlwZQogICAgICAgICAgfSA9IGRhdGEucHJvcHM7CiAgICAgICAgICBzdGF0ZS5zdWJzY3JpcHRpb25zW2lkXSA9IFtkYXRhLnV1aWQsIHR5cGUsIHRhcmdldF07CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlJzoKICAgICAgICB7CiAgICAgICAgICBkZWxldGUgc3RhdGUuc3Vic2NyaXB0aW9uc1tkYXRhLnByb3BzXTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc2V0UG9zaXRpb24nOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLnBvc2l0aW9uLnNldChkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0UXVhdGVybmlvbic6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ucXVhdGVybmlvbi5zZXQoZGF0YS5wcm9wc1swXSwgZGF0YS5wcm9wc1sxXSwgZGF0YS5wcm9wc1syXSwgZGF0YS5wcm9wc1szXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldFJvdGF0aW9uJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0VmVsb2NpdHknOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLnZlbG9jaXR5LnNldChkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QW5ndWxhclZlbG9jaXR5JzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hbmd1bGFyVmVsb2NpdHkuc2V0KGRhdGEucHJvcHNbMF0sIGRhdGEucHJvcHNbMV0sIGRhdGEucHJvcHNbMl0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRMaW5lYXJGYWN0b3InOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmxpbmVhckZhY3Rvci5zZXQoZGF0YS5wcm9wc1swXSwgZGF0YS5wcm9wc1sxXSwgZGF0YS5wcm9wc1syXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEFuZ3VsYXJGYWN0b3InOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFuZ3VsYXJGYWN0b3Iuc2V0KGRhdGEucHJvcHNbMF0sIGRhdGEucHJvcHNbMV0sIGRhdGEucHJvcHNbMl0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRNYXNzJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5tYXNzID0gZGF0YS5wcm9wczsKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS51cGRhdGVNYXNzUHJvcGVydGllcygpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRNYXRlcmlhbCc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ubWF0ZXJpYWwgPSBkYXRhLnByb3BzID8gY3JlYXRlTWF0ZXJpYWwoZGF0YS5wcm9wcykgOiBudWxsOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRMaW5lYXJEYW1waW5nJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5saW5lYXJEYW1waW5nID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QW5ndWxhckRhbXBpbmcnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFuZ3VsYXJEYW1waW5nID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QWxsb3dTbGVlcCc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uYWxsb3dTbGVlcCA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldFNsZWVwU3BlZWRMaW1pdCc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uc2xlZXBTcGVlZExpbWl0ID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0U2xlZXBUaW1lTGltaXQnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLnNsZWVwVGltZUxpbWl0ID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0Q29sbGlzaW9uRmlsdGVyR3JvdXAnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0Q29sbGlzaW9uRmlsdGVyTWFzayc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uY29sbGlzaW9uRmlsdGVyTWFzayA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldENvbGxpc2lvblJlc3BvbnNlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5jb2xsaXNpb25SZXNwb25zZSA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEZpeGVkUm90YXRpb24nOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmZpeGVkUm90YXRpb24gPSBkYXRhLnByb3BzOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRGcmljdGlvbkdyYXZpdHknOgogICAgICAgIHN0YXRlLndvcmxkLmZyaWN0aW9uR3Jhdml0eSA9IGRhdGEucHJvcHMgPyBuZXcgVmVjMyguLi5kYXRhLnByb3BzKSA6IHVuZGVmaW5lZDsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0SXNUcmlnZ2VyJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5pc1RyaWdnZXIgPSBkYXRhLnByb3BzOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRHcmF2aXR5JzoKICAgICAgICBzdGF0ZS53b3JsZC5ncmF2aXR5LnNldChkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0VG9sZXJhbmNlJzoKICAgICAgICBpZiAoc3RhdGUud29ybGQuc29sdmVyIGluc3RhbmNlb2YgR1NTb2x2ZXIpIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnNvbHZlci50b2xlcmFuY2UgPSBkYXRhLnByb3BzOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0SXRlcmF0aW9ucyc6CiAgICAgICAgaWYgKHN0YXRlLndvcmxkLnNvbHZlciBpbnN0YW5jZW9mIEdTU29sdmVyKSB7CiAgICAgICAgICBzdGF0ZS53b3JsZC5zb2x2ZXIuaXRlcmF0aW9ucyA9IGRhdGEucHJvcHM7CiAgICAgICAgfQogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRCcm9hZHBoYXNlJzoKICAgICAgICBzdGF0ZS53b3JsZC5icm9hZHBoYXNlID0gbmV3IChicm9hZHBoYXNlc1tgJHtkYXRhLnByb3BzfUJyb2FkcGhhc2VgXSB8fCBOYWl2ZUJyb2FkcGhhc2UpKHN0YXRlLndvcmxkKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QXhpc0luZGV4JzoKICAgICAgICBpZiAoc3RhdGUud29ybGQuYnJvYWRwaGFzZSBpbnN0YW5jZW9mIFNBUEJyb2FkcGhhc2UpIHsKICAgICAgICAgIHN0YXRlLndvcmxkLmJyb2FkcGhhc2UuYXhpc0luZGV4ID0gZGF0YS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8IGRhdGEucHJvcHMgPT09IG51bGwgPyAwIDogZGF0YS5wcm9wczsKICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FwcGx5Rm9yY2UnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFwcGx5Rm9yY2UobmV3IFZlYzMoLi4uZGF0YS5wcm9wc1swXSksIG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMV0pKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnYXBwbHlJbXB1bHNlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hcHBseUltcHVsc2UobmV3IFZlYzMoLi4uZGF0YS5wcm9wc1swXSksIG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMV0pKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnYXBwbHlMb2NhbEZvcmNlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hcHBseUxvY2FsRm9yY2UobmV3IFZlYzMoLi4uZGF0YS5wcm9wc1swXSksIG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMV0pKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnYXBwbHlMb2NhbEltcHVsc2UnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFwcGx5TG9jYWxJbXB1bHNlKG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMF0pLCBuZXcgVmVjMyguLi5kYXRhLnByb3BzWzFdKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FwcGx5VG9ycXVlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hcHBseVRvcnF1ZShuZXcgVmVjMyguLi5kYXRhLnByb3BzWzBdKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FkZENvbnN0cmFpbnQnOgogICAgICAgIHsKICAgICAgICAgIGFkZENvbnN0cmFpbnQoc3RhdGUsIGRhdGEpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdyZW1vdmVDb25zdHJhaW50JzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoX3JlZjIgPT4gewogICAgICAgICAgbGV0IHsKICAgICAgICAgICAgdXVpZAogICAgICAgICAgfSA9IF9yZWYyOwogICAgICAgICAgcmV0dXJuIHV1aWQgPT09IGRhdGEudXVpZDsKICAgICAgICB9KS5tYXAoYyA9PiBzdGF0ZS53b3JsZC5yZW1vdmVDb25zdHJhaW50KGMpKTsKICAgICAgICBpZiAoc3RhdGUuY29uc3RyYWludHNbZGF0YS51dWlkXSkgewogICAgICAgICAgc3RhdGUud29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9zdFN0ZXAnLCBzdGF0ZS5jb25zdHJhaW50c1tkYXRhLnV1aWRdKTsKICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jb25zdHJhaW50c1tkYXRhLnV1aWRdOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgY2FzZSAnZW5hYmxlQ29uc3RyYWludCc6CiAgICAgICAgc3RhdGUud29ybGQuY29uc3RyYWludHMuZmlsdGVyKGMgPT4gYy51dWlkID09PSBkYXRhLnV1aWQpLm1hcChjID0+IGMuZW5hYmxlKCkpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdkaXNhYmxlQ29uc3RyYWludCc6CiAgICAgICAgc3RhdGUud29ybGQuY29uc3RyYWludHMuZmlsdGVyKGMgPT4gYy51dWlkID09PSBkYXRhLnV1aWQpLm1hcChjID0+IGMuZGlzYWJsZSgpKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnZW5hYmxlQ29uc3RyYWludE1vdG9yJzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoYyA9PiBjLnV1aWQgPT09IGRhdGEudXVpZCkuZmlsdGVyKGlzSGluZ2VDb25zdHJhaW50KS5tYXAoYyA9PiBjLmVuYWJsZU1vdG9yKCkpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdkaXNhYmxlQ29uc3RyYWludE1vdG9yJzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoYyA9PiBjLnV1aWQgPT09IGRhdGEudXVpZCkuZmlsdGVyKGlzSGluZ2VDb25zdHJhaW50KS5tYXAoYyA9PiBjLmRpc2FibGVNb3RvcigpKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0Q29uc3RyYWludE1vdG9yU3BlZWQnOgogICAgICAgIHN0YXRlLndvcmxkLmNvbnN0cmFpbnRzLmZpbHRlcihjID0+IGMudXVpZCA9PT0gZGF0YS51dWlkKS5maWx0ZXIoaXNIaW5nZUNvbnN0cmFpbnQpLm1hcChjID0+IGMuc2V0TW90b3JTcGVlZChkYXRhLnByb3BzKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldENvbnN0cmFpbnRNb3Rvck1heEZvcmNlJzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoYyA9PiBjLnV1aWQgPT09IGRhdGEudXVpZCkuZmlsdGVyKGlzSGluZ2VDb25zdHJhaW50KS5tYXAoYyA9PiBjLnNldE1vdG9yTWF4Rm9yY2UoZGF0YS5wcm9wcykpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdhZGRTcHJpbmcnOgogICAgICAgIHsKICAgICAgICAgIGFkZFNwcmluZyhzdGF0ZSwgZGF0YSk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3NldFNwcmluZ1N0aWZmbmVzcyc6CiAgICAgICAgewogICAgICAgICAgc3RhdGUuc3ByaW5nSW5zdGFuY2VzW2RhdGEudXVpZF0uc3RpZmZuZXNzID0gZGF0YS5wcm9wczsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc2V0U3ByaW5nUmVzdExlbmd0aCc6CiAgICAgICAgewogICAgICAgICAgc3RhdGUuc3ByaW5nSW5zdGFuY2VzW2RhdGEudXVpZF0ucmVzdExlbmd0aCA9IGRhdGEucHJvcHM7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3NldFNwcmluZ0RhbXBpbmcnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLnNwcmluZ0luc3RhbmNlc1tkYXRhLnV1aWRdLmRhbXBpbmcgPSBkYXRhLnByb3BzOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdyZW1vdmVTcHJpbmcnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgc3RhdGUuc3ByaW5nc1tkYXRhLnV1aWRdKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnYWRkUmF5JzoKICAgICAgICB7CiAgICAgICAgICBhZGRSYXkoc3RhdGUsIGRhdGEpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdyZW1vdmVSYXknOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCBzdGF0ZS5yYXlzW2RhdGEudXVpZF0pOwogICAgICAgICAgZGVsZXRlIHN0YXRlLnJheXNbZGF0YS51dWlkXTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnYWRkUmF5Y2FzdFZlaGljbGUnOgogICAgICAgIHsKICAgICAgICAgIGFkZFJheWNhc3RWZWhpY2xlKHN0YXRlLCBkYXRhKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAncmVtb3ZlUmF5Y2FzdFZlaGljbGUnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCBzdGF0ZS52ZWhpY2xlc1tkYXRhLnV1aWRdLnByZVN0ZXApOwogICAgICAgICAgc3RhdGUud29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9zdFN0ZXAnLCBzdGF0ZS52ZWhpY2xlc1tkYXRhLnV1aWRdLnBvc3RTdGVwKTsKICAgICAgICAgIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF0udmVoaWNsZS53b3JsZCA9IG51bGw7CiAgICAgICAgICBkZWxldGUgc3RhdGUudmVoaWNsZXNbZGF0YS51dWlkXTsKICAgICAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKHN0YXRlLnN1YnNjcmlwdGlvbnMpLmZpbmQoayA9PiBzdGF0ZS5zdWJzY3JpcHRpb25zW2tdWzBdID09PSBkYXRhLnV1aWQpOwogICAgICAgICAgaWYgKGtleSkgewogICAgICAgICAgICBkZWxldGUgc3RhdGUuc3Vic2NyaXB0aW9uc1trZXldOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzZXRSYXljYXN0VmVoaWNsZVN0ZWVyaW5nVmFsdWUnOgogICAgICAgIHsKICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgd2hlZWxJbmRleF0gPSBkYXRhLnByb3BzOwogICAgICAgICAgc3RhdGUudmVoaWNsZXNbZGF0YS51dWlkXS52ZWhpY2xlLnNldFN0ZWVyaW5nVmFsdWUodmFsdWUsIHdoZWVsSW5kZXgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdhcHBseVJheWNhc3RWZWhpY2xlRW5naW5lRm9yY2UnOgogICAgICAgIHsKICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgd2hlZWxJbmRleF0gPSBkYXRhLnByb3BzOwogICAgICAgICAgc3RhdGUudmVoaWNsZXNbZGF0YS51dWlkXS52ZWhpY2xlLmFwcGx5RW5naW5lRm9yY2UodmFsdWUsIHdoZWVsSW5kZXgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzZXRSYXljYXN0VmVoaWNsZUJyYWtlJzoKICAgICAgICB7CiAgICAgICAgICBjb25zdCBbYnJha2UsIHdoZWVsSW5kZXhdID0gZGF0YS5wcm9wczsKICAgICAgICAgIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF0udmVoaWNsZS5zZXRCcmFrZShicmFrZSwgd2hlZWxJbmRleCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ2FkZENvbnRhY3RNYXRlcmlhbCc6CiAgICAgICAgewogICAgICAgICAgYWRkQ29udGFjdE1hdGVyaWFsKHN0YXRlLndvcmxkLCBjcmVhdGVNYXRlcmlhbCwgZGF0YS5wcm9wcywgZGF0YS51dWlkKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAncmVtb3ZlQ29udGFjdE1hdGVyaWFsJzoKICAgICAgICB7CiAgICAgICAgICByZW1vdmVDb250YWN0TWF0ZXJpYWwoc3RhdGUud29ybGQsIGRhdGEudXVpZCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3dha2VVcCc6CiAgICAgICAgewogICAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ud2FrZVVwKCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3NsZWVwJzoKICAgICAgICB7CiAgICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5zbGVlcCgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgfQogIH07Cgp9KSgpOwoK");
class xee extends Bee {
  get axisIndex() {
    return this.config.axisIndex;
  }
  set axisIndex(e) {
    this.config.axisIndex = e, this.postMessage({
      op: "setAxisIndex",
      props: e
    });
  }
  get broadphase() {
    return this.config.broadphase;
  }
  set broadphase(e) {
    this.config.broadphase = e, this.postMessage({
      op: "setBroadphase",
      props: e
    });
  }
  get frictionGravity() {
    return this.config.frictionGravity;
  }
  set frictionGravity(e) {
    this.config.frictionGravity = e, this.postMessage({
      op: "setFrictionGravity",
      props: e
    });
  }
  get gravity() {
    return this.config.gravity;
  }
  set gravity(e) {
    this.config.gravity = e, this.postMessage({
      op: "setGravity",
      props: e
    });
  }
  get iterations() {
    return this.config.iterations;
  }
  set iterations(e) {
    this.config.iterations = e, this.postMessage({
      op: "setIterations",
      props: e
    });
  }
  get tolerance() {
    return this.config.tolerance;
  }
  set tolerance(e) {
    this.config.tolerance = e, this.postMessage({
      op: "setTolerance",
      props: e
    });
  }
  messageQueue = [];
  worker = null;
  constructor(e) {
    let {
      allowSleep: t = !1,
      axisIndex: n = 0,
      broadphase: i = "Naive",
      defaultContactMaterial: o = {
        contactEquationStiffness: 1e6
      },
      frictionGravity: l = null,
      gravity: u = [0, -9.81, 0],
      iterations: I = 5,
      quatNormalizeFast: f = !1,
      quatNormalizeSkip: h = 0,
      size: v = 1e3,
      solver: b = "GS",
      tolerance: S = 1e-3
    } = e;
    super(), this.config = {
      allowSleep: t,
      axisIndex: n,
      broadphase: i,
      defaultContactMaterial: o,
      frictionGravity: l,
      gravity: u,
      iterations: I,
      quatNormalizeFast: f,
      quatNormalizeSkip: h,
      size: v,
      solver: b,
      tolerance: S
    }, this.buffers = {
      positions: new Float32Array(v * 3),
      quaternions: new Float32Array(v * 4)
    };
  }
  addBodies(e) {
    let {
      props: t,
      type: n,
      uuid: i
    } = e;
    this.postMessage({
      op: "addBodies",
      props: t,
      type: n,
      uuid: i
    });
  }
  addConstraint(e) {
    let {
      props: [t, n, i],
      type: o,
      uuid: l
    } = e;
    this.postMessage({
      op: "addConstraint",
      props: [t, n, i],
      type: o,
      uuid: l
    });
  }
  addContactMaterial(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "addContactMaterial",
      props: t,
      uuid: n
    });
  }
  addRay(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "addRay",
      props: t,
      uuid: n
    });
  }
  addRaycastVehicle(e) {
    let {
      props: [t, n, i, o, l, u],
      uuid: I
    } = e;
    this.postMessage({
      op: "addRaycastVehicle",
      props: [t, n, i, o, l, u],
      uuid: I
    });
  }
  addSpring(e) {
    let {
      props: [t, n, i],
      uuid: o
    } = e;
    this.postMessage({
      op: "addSpring",
      props: [t, n, i],
      uuid: o
    });
  }
  applyForce(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyForce",
      props: t,
      uuid: n
    });
  }
  applyImpulse(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyImpulse",
      props: t,
      uuid: n
    });
  }
  applyLocalForce(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyLocalForce",
      props: t,
      uuid: n
    });
  }
  applyLocalImpulse(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyLocalImpulse",
      props: t,
      uuid: n
    });
  }
  applyRaycastVehicleEngineForce(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyRaycastVehicleEngineForce",
      props: t,
      uuid: n
    });
  }
  applyTorque(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "applyTorque",
      props: t,
      uuid: n
    });
  }
  connect() {
    this.worker = new Ree(), this.worker.onmessage = (e) => {
      if (e.data.op === "frame") {
        this.buffers.positions = e.data.positions, this.buffers.quaternions = e.data.quaternions, this.emit(e.data.op, e.data);
        return;
      }
      this.emit(e.data.type, e.data);
    };
    for (const e of this.messageQueue)
      this.worker.postMessage(e);
    this.messageQueue.length = 0;
  }
  disableConstraint(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "disableConstraint",
      uuid: t
    });
  }
  disableConstraintMotor(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "disableConstraintMotor",
      uuid: t
    });
  }
  disconnect() {
    this.worker && (this.worker.onmessage = null);
  }
  enableConstraint(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "enableConstraint",
      uuid: t
    });
  }
  enableConstraintMotor(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "enableConstraintMotor",
      uuid: t
    });
  }
  init() {
    const {
      allowSleep: e,
      axisIndex: t,
      broadphase: n,
      defaultContactMaterial: i,
      frictionGravity: o,
      gravity: l,
      iterations: u,
      quatNormalizeFast: I,
      quatNormalizeSkip: f,
      solver: h,
      tolerance: v
    } = this.config;
    this.postMessage({
      op: "init",
      props: {
        allowSleep: e,
        axisIndex: t,
        broadphase: n,
        defaultContactMaterial: i,
        frictionGravity: o,
        gravity: l,
        iterations: u,
        quatNormalizeFast: I,
        quatNormalizeSkip: f,
        solver: h,
        tolerance: v
      }
    });
  }
  removeBodies(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeBodies",
      uuid: t
    });
  }
  removeConstraint(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeConstraint",
      uuid: t
    });
  }
  removeContactMaterial(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeContactMaterial",
      uuid: t
    });
  }
  removeRay(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeRay",
      uuid: t
    });
  }
  removeRaycastVehicle(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeRaycastVehicle",
      uuid: t
    });
  }
  removeSpring(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "removeSpring",
      uuid: t
    });
  }
  setAllowSleep(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setAllowSleep",
      props: t,
      uuid: n
    });
  }
  setAngularDamping(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setAngularDamping",
      props: t,
      uuid: n
    });
  }
  setAngularFactor(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setAngularFactor",
      props: t,
      uuid: n
    });
  }
  setAngularVelocity(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setAngularVelocity",
      props: t,
      uuid: n
    });
  }
  setCollisionFilterGroup(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setCollisionFilterGroup",
      props: t,
      uuid: n
    });
  }
  setCollisionFilterMask(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setCollisionFilterMask",
      props: t,
      uuid: n
    });
  }
  setCollisionResponse(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setCollisionResponse",
      props: t,
      uuid: n
    });
  }
  setConstraintMotorMaxForce(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setConstraintMotorMaxForce",
      props: t,
      uuid: n
    });
  }
  setConstraintMotorSpeed(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setConstraintMotorSpeed",
      props: t,
      uuid: n
    });
  }
  setFixedRotation(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setFixedRotation",
      props: t,
      uuid: n
    });
  }
  setIsTrigger(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setIsTrigger",
      props: t,
      uuid: n
    });
  }
  setLinearDamping(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setLinearDamping",
      props: t,
      uuid: n
    });
  }
  setLinearFactor(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setLinearFactor",
      props: t,
      uuid: n
    });
  }
  setMass(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setMass",
      props: t,
      uuid: n
    });
  }
  setMaterial(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setMaterial",
      props: t,
      uuid: n
    });
  }
  setPosition(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setPosition",
      props: t,
      uuid: n
    });
  }
  setQuaternion(e) {
    let {
      props: [t, n, i, o],
      uuid: l
    } = e;
    this.postMessage({
      op: "setQuaternion",
      props: [t, n, i, o],
      uuid: l
    });
  }
  setRaycastVehicleBrake(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setRaycastVehicleBrake",
      props: t,
      uuid: n
    });
  }
  setRaycastVehicleSteeringValue(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setRaycastVehicleSteeringValue",
      props: t,
      uuid: n
    });
  }
  setRotation(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setRotation",
      props: t,
      uuid: n
    });
  }
  setSleepSpeedLimit(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSleepSpeedLimit",
      props: t,
      uuid: n
    });
  }
  setSleepTimeLimit(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSleepTimeLimit",
      props: t,
      uuid: n
    });
  }
  setSpringDamping(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSpringDamping",
      props: t,
      uuid: n
    });
  }
  setSpringRestLength(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSpringRestLength",
      props: t,
      uuid: n
    });
  }
  setSpringStiffness(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setSpringStiffness",
      props: t,
      uuid: n
    });
  }
  setUserData(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setUserData",
      props: t,
      uuid: n
    });
  }
  setVelocity(e) {
    let {
      props: t,
      uuid: n
    } = e;
    this.postMessage({
      op: "setVelocity",
      props: t,
      uuid: n
    });
  }
  sleep(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "sleep",
      uuid: t
    });
  }
  step(e) {
    var t;
    const {
      buffers: {
        positions: n,
        quaternions: i
      }
    } = this;
    !n.byteLength && !i.byteLength || (t = this.worker) == null || t.postMessage({
      op: "step",
      positions: n,
      props: e,
      quaternions: i
    }, [n.buffer, i.buffer]);
  }
  subscribe(e) {
    let {
      props: {
        id: t,
        target: n,
        type: i
      },
      uuid: o
    } = e;
    this.postMessage({
      op: "subscribe",
      props: {
        id: t,
        target: n,
        type: i
      },
      uuid: o
    });
  }
  terminate() {
    var e;
    (e = this.worker) == null || e.terminate(), this.worker = null;
  }
  unsubscribe(e) {
    let {
      props: t
    } = e;
    this.postMessage({
      op: "unsubscribe",
      props: t
    });
  }
  wakeUp(e) {
    let {
      uuid: t
    } = e;
    this.postMessage({
      op: "wakeUp",
      uuid: t
    });
  }
  postMessage(e) {
    if (this.worker) return this.worker.postMessage(e);
    this.messageQueue.push(e);
  }
}
class xm {
  /**
   * A vector of length 9, containing all matrix elements.
   */
  /**
   * @param elements A vector of length 9, containing all matrix elements.
   */
  constructor(e) {
    e === void 0 && (e = [0, 0, 0, 0, 0, 0, 0, 0, 0]), this.elements = e;
  }
  /**
   * Sets the matrix to identity
   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
   * @todo Create another function that immediately creates an identity matrix eg. `eye()`
   */
  identity() {
    const e = this.elements;
    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1;
  }
  /**
   * Set all elements to zero
   */
  setZero() {
    const e = this.elements;
    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 0;
  }
  /**
   * Sets the matrix diagonal elements from a Vec3
   */
  setTrace(e) {
    const t = this.elements;
    t[0] = e.x, t[4] = e.y, t[8] = e.z;
  }
  /**
   * Gets the matrix diagonal elements
   */
  getTrace(e) {
    e === void 0 && (e = new Ne());
    const t = this.elements;
    return e.x = t[0], e.y = t[4], e.z = t[8], e;
  }
  /**
   * Matrix-Vector multiplication
   * @param v The vector to multiply with
   * @param target Optional, target to save the result in.
   */
  vmult(e, t) {
    t === void 0 && (t = new Ne());
    const n = this.elements, i = e.x, o = e.y, l = e.z;
    return t.x = n[0] * i + n[1] * o + n[2] * l, t.y = n[3] * i + n[4] * o + n[5] * l, t.z = n[6] * i + n[7] * o + n[8] * l, t;
  }
  /**
   * Matrix-scalar multiplication
   */
  smult(e) {
    for (let t = 0; t < this.elements.length; t++)
      this.elements[t] *= e;
  }
  /**
   * Matrix multiplication
   * @param matrix Matrix to multiply with from left side.
   */
  mmult(e, t) {
    t === void 0 && (t = new xm());
    const n = this.elements, i = e.elements, o = t.elements, l = n[0], u = n[1], I = n[2], f = n[3], h = n[4], v = n[5], b = n[6], S = n[7], R = n[8], W = i[0], x = i[1], M = i[2], T = i[3], E = i[4], _ = i[5], P = i[6], U = i[7], q = i[8];
    return o[0] = l * W + u * T + I * P, o[1] = l * x + u * E + I * U, o[2] = l * M + u * _ + I * q, o[3] = f * W + h * T + v * P, o[4] = f * x + h * E + v * U, o[5] = f * M + h * _ + v * q, o[6] = b * W + S * T + R * P, o[7] = b * x + S * E + R * U, o[8] = b * M + S * _ + R * q, t;
  }
  /**
   * Scale each column of the matrix
   */
  scale(e, t) {
    t === void 0 && (t = new xm());
    const n = this.elements, i = t.elements;
    for (let o = 0; o !== 3; o++)
      i[3 * o + 0] = e.x * n[3 * o + 0], i[3 * o + 1] = e.y * n[3 * o + 1], i[3 * o + 2] = e.z * n[3 * o + 2];
    return t;
  }
  /**
   * Solve Ax=b
   * @param b The right hand side
   * @param target Optional. Target vector to save in.
   * @return The solution x
   * @todo should reuse arrays
   */
  solve(e, t) {
    t === void 0 && (t = new Ne());
    const n = 3, i = 4, o = [];
    let l, u;
    for (l = 0; l < n * i; l++)
      o.push(0);
    for (l = 0; l < 3; l++)
      for (u = 0; u < 3; u++)
        o[l + i * u] = this.elements[l + 3 * u];
    o[3 + 4 * 0] = e.x, o[3 + 4 * 1] = e.y, o[3 + 4 * 2] = e.z;
    let I = 3;
    const f = I;
    let h;
    const v = 4;
    let b;
    do {
      if (l = f - I, o[l + i * l] === 0) {
        for (u = l + 1; u < f; u++)
          if (o[l + i * u] !== 0) {
            h = v;
            do
              b = v - h, o[b + i * l] += o[b + i * u];
            while (--h);
            break;
          }
      }
      if (o[l + i * l] !== 0)
        for (u = l + 1; u < f; u++) {
          const S = o[l + i * u] / o[l + i * l];
          h = v;
          do
            b = v - h, o[b + i * u] = b <= l ? 0 : o[b + i * u] - o[b + i * l] * S;
          while (--h);
        }
    } while (--I);
    if (t.z = o[2 * i + 3] / o[2 * i + 2], t.y = (o[1 * i + 3] - o[1 * i + 2] * t.z) / o[1 * i + 1], t.x = (o[0 * i + 3] - o[0 * i + 2] * t.z - o[0 * i + 1] * t.y) / o[0 * i + 0], isNaN(t.x) || isNaN(t.y) || isNaN(t.z) || t.x === 1 / 0 || t.y === 1 / 0 || t.z === 1 / 0)
      throw `Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;
    return t;
  }
  /**
   * Get an element in the matrix by index. Index starts at 0, not 1!!!
   * @param value If provided, the matrix element will be set to this value.
   */
  e(e, t, n) {
    if (n === void 0)
      return this.elements[t + 3 * e];
    this.elements[t + 3 * e] = n;
  }
  /**
   * Copy another matrix into this matrix object.
   */
  copy(e) {
    for (let t = 0; t < e.elements.length; t++)
      this.elements[t] = e.elements[t];
    return this;
  }
  /**
   * Returns a string representation of the matrix.
   */
  toString() {
    let e = "";
    const t = ",";
    for (let n = 0; n < 9; n++)
      e += this.elements[n] + t;
    return e;
  }
  /**
   * reverse the matrix
   * @param target Target matrix to save in.
   * @return The solution x
   */
  reverse(e) {
    e === void 0 && (e = new xm());
    const t = 3, n = 6, i = Wee;
    let o, l;
    for (o = 0; o < 3; o++)
      for (l = 0; l < 3; l++)
        i[o + n * l] = this.elements[o + 3 * l];
    i[3 + 6 * 0] = 1, i[3 + 6 * 1] = 0, i[3 + 6 * 2] = 0, i[4 + 6 * 0] = 0, i[4 + 6 * 1] = 1, i[4 + 6 * 2] = 0, i[5 + 6 * 0] = 0, i[5 + 6 * 1] = 0, i[5 + 6 * 2] = 1;
    let u = 3;
    const I = u;
    let f;
    const h = n;
    let v;
    do {
      if (o = I - u, i[o + n * o] === 0) {
        for (l = o + 1; l < I; l++)
          if (i[o + n * l] !== 0) {
            f = h;
            do
              v = h - f, i[v + n * o] += i[v + n * l];
            while (--f);
            break;
          }
      }
      if (i[o + n * o] !== 0)
        for (l = o + 1; l < I; l++) {
          const b = i[o + n * l] / i[o + n * o];
          f = h;
          do
            v = h - f, i[v + n * l] = v <= o ? 0 : i[v + n * l] - i[v + n * o] * b;
          while (--f);
        }
    } while (--u);
    o = 2;
    do {
      l = o - 1;
      do {
        const b = i[o + n * l] / i[o + n * o];
        f = n;
        do
          v = n - f, i[v + n * l] = i[v + n * l] - i[v + n * o] * b;
        while (--f);
      } while (l--);
    } while (--o);
    o = 2;
    do {
      const b = 1 / i[o + n * o];
      f = n;
      do
        v = n - f, i[v + n * o] = i[v + n * o] * b;
      while (--f);
    } while (o--);
    o = 2;
    do {
      l = 2;
      do {
        if (v = i[t + l + n * o], isNaN(v) || v === 1 / 0)
          throw `Could not reverse! A=[${this.toString()}]`;
        e.e(o, l, v);
      } while (l--);
    } while (o--);
    return e;
  }
  /**
   * Set the matrix from a quaterion
   */
  setRotationFromQuaternion(e) {
    const t = e.x, n = e.y, i = e.z, o = e.w, l = t + t, u = n + n, I = i + i, f = t * l, h = t * u, v = t * I, b = n * u, S = n * I, R = i * I, W = o * l, x = o * u, M = o * I, T = this.elements;
    return T[3 * 0 + 0] = 1 - (b + R), T[3 * 0 + 1] = h - M, T[3 * 0 + 2] = v + x, T[3 * 1 + 0] = h + M, T[3 * 1 + 1] = 1 - (f + R), T[3 * 1 + 2] = S - W, T[3 * 2 + 0] = v - x, T[3 * 2 + 1] = S + W, T[3 * 2 + 2] = 1 - (f + b), this;
  }
  /**
   * Transpose the matrix
   * @param target Optional. Where to store the result.
   * @return The target Mat3, or a new Mat3 if target was omitted.
   */
  transpose(e) {
    e === void 0 && (e = new xm());
    const t = this.elements, n = e.elements;
    let i;
    return n[0] = t[0], n[4] = t[4], n[8] = t[8], i = t[1], n[1] = t[3], n[3] = i, i = t[2], n[2] = t[6], n[6] = i, i = t[5], n[5] = t[7], n[7] = i, e;
  }
}
const Wee = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
class Ne {
  constructor(e, t, n) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), this.x = e, this.y = t, this.z = n;
  }
  /**
   * Vector cross product
   * @param target Optional target to save in.
   */
  cross(e, t) {
    t === void 0 && (t = new Ne());
    const n = e.x, i = e.y, o = e.z, l = this.x, u = this.y, I = this.z;
    return t.x = u * o - I * i, t.y = I * n - l * o, t.z = l * i - u * n, t;
  }
  /**
   * Set the vectors' 3 elements
   */
  set(e, t, n) {
    return this.x = e, this.y = t, this.z = n, this;
  }
  /**
   * Set all components of the vector to zero.
   */
  setZero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Vector addition
   */
  vadd(e, t) {
    if (t)
      t.x = e.x + this.x, t.y = e.y + this.y, t.z = e.z + this.z;
    else
      return new Ne(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  /**
   * Vector subtraction
   * @param target Optional target to save in.
   */
  vsub(e, t) {
    if (t)
      t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z;
    else
      return new Ne(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  /**
   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
   *
   * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Umeå University Lecture}
   */
  crossmat() {
    return new xm([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  /**
   * Normalize the vector. Note that this changes the values in the vector.
    * @return Returns the norm of the vector
   */
  normalize() {
    const e = this.x, t = this.y, n = this.z, i = Math.sqrt(e * e + t * t + n * n);
    if (i > 0) {
      const o = 1 / i;
      this.x *= o, this.y *= o, this.z *= o;
    } else
      this.x = 0, this.y = 0, this.z = 0;
    return i;
  }
  /**
   * Get the version of this vector that is of length 1.
   * @param target Optional target to save in
   * @return Returns the unit vector
   */
  unit(e) {
    e === void 0 && (e = new Ne());
    const t = this.x, n = this.y, i = this.z;
    let o = Math.sqrt(t * t + n * n + i * i);
    return o > 0 ? (o = 1 / o, e.x = t * o, e.y = n * o, e.z = i * o) : (e.x = 1, e.y = 0, e.z = 0), e;
  }
  /**
   * Get the length of the vector
   */
  length() {
    const e = this.x, t = this.y, n = this.z;
    return Math.sqrt(e * e + t * t + n * n);
  }
  /**
   * Get the squared length of the vector.
   */
  lengthSquared() {
    return this.dot(this);
  }
  /**
   * Get distance from this point to another point
   */
  distanceTo(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z;
    return Math.sqrt((o - t) * (o - t) + (l - n) * (l - n) + (u - i) * (u - i));
  }
  /**
   * Get squared distance from this point to another point
   */
  distanceSquared(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z;
    return (o - t) * (o - t) + (l - n) * (l - n) + (u - i) * (u - i);
  }
  /**
   * Multiply all the components of the vector with a scalar.
   * @param target The vector to save the result in.
   */
  scale(e, t) {
    t === void 0 && (t = new Ne());
    const n = this.x, i = this.y, o = this.z;
    return t.x = e * n, t.y = e * i, t.z = e * o, t;
  }
  /**
   * Multiply the vector with an other vector, component-wise.
   * @param target The vector to save the result in.
   */
  vmul(e, t) {
    return t === void 0 && (t = new Ne()), t.x = e.x * this.x, t.y = e.y * this.y, t.z = e.z * this.z, t;
  }
  /**
   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
   * @param target The vector to save the result in.
   */
  addScaledVector(e, t, n) {
    return n === void 0 && (n = new Ne()), n.x = this.x + e * t.x, n.y = this.y + e * t.y, n.z = this.z + e * t.z, n;
  }
  /**
   * Calculate dot product
   * @param vector
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  /**
   * Make the vector point in the opposite direction.
   * @param target Optional target to save in
   */
  negate(e) {
    return e === void 0 && (e = new Ne()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e;
  }
  /**
   * Compute two artificial tangents to the vector
   * @param t1 Vector object to save the first tangent in
   * @param t2 Vector object to save the second tangent in
   */
  tangents(e, t) {
    const n = this.length();
    if (n > 0) {
      const i = Vee, o = 1 / n;
      i.set(this.x * o, this.y * o, this.z * o);
      const l = Nee;
      Math.abs(i.x) < 0.9 ? (l.set(1, 0, 0), i.cross(l, e)) : (l.set(0, 1, 0), i.cross(l, e)), i.cross(e, t);
    } else
      e.set(1, 0, 0), t.set(0, 1, 0);
  }
  /**
   * Converts to a more readable format
   */
  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  /**
   * Converts to an array
   */
  toArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * Copies value of source to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Do a linear interpolation between two vectors
   * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
   */
  lerp(e, t, n) {
    const i = this.x, o = this.y, l = this.z;
    n.x = i + (e.x - i) * t, n.y = o + (e.y - o) * t, n.z = l + (e.z - l) * t;
  }
  /**
   * Check if a vector equals is almost equal to another one.
   */
  almostEquals(e, t) {
    return t === void 0 && (t = 1e-6), !(Math.abs(this.x - e.x) > t || Math.abs(this.y - e.y) > t || Math.abs(this.z - e.z) > t);
  }
  /**
   * Check if a vector is almost zero
   */
  almostZero(e) {
    return e === void 0 && (e = 1e-6), !(Math.abs(this.x) > e || Math.abs(this.y) > e || Math.abs(this.z) > e);
  }
  /**
   * Check if the vector is anti-parallel to another vector.
   * @param precision Set to zero for exact comparisons
   */
  isAntiparallelTo(e, t) {
    return this.negate(u3), u3.almostEquals(e, t);
  }
  /**
   * Clone the vector
   */
  clone() {
    return new Ne(this.x, this.y, this.z);
  }
}
Ne.ZERO = new Ne(0, 0, 0);
Ne.UNIT_X = new Ne(1, 0, 0);
Ne.UNIT_Y = new Ne(0, 1, 0);
Ne.UNIT_Z = new Ne(0, 0, 1);
const Vee = new Ne(), Nee = new Ne(), u3 = new Ne();
class KC {
  /**
   * The lower bound of the bounding box
   */
  /**
   * The upper bound of the bounding box
   */
  constructor(e) {
    e === void 0 && (e = {}), this.lowerBound = new Ne(), this.upperBound = new Ne(), e.lowerBound && this.lowerBound.copy(e.lowerBound), e.upperBound && this.upperBound.copy(e.upperBound);
  }
  /**
   * Set the AABB bounds from a set of points.
   * @param points An array of Vec3's.
   * @return The self object
   */
  setFromPoints(e, t, n, i) {
    const o = this.lowerBound, l = this.upperBound, u = n;
    o.copy(e[0]), u && u.vmult(o, o), l.copy(o);
    for (let I = 1; I < e.length; I++) {
      let f = e[I];
      u && (u.vmult(f, c3), f = c3), f.x > l.x && (l.x = f.x), f.x < o.x && (o.x = f.x), f.y > l.y && (l.y = f.y), f.y < o.y && (o.y = f.y), f.z > l.z && (l.z = f.z), f.z < o.z && (o.z = f.z);
    }
    return t && (t.vadd(o, o), t.vadd(l, l)), i && (o.x -= i, o.y -= i, o.z -= i, l.x += i, l.y += i, l.z += i), this;
  }
  /**
   * Copy bounds from an AABB to this AABB
   * @param aabb Source to copy from
   * @return The this object, for chainability
   */
  copy(e) {
    return this.lowerBound.copy(e.lowerBound), this.upperBound.copy(e.upperBound), this;
  }
  /**
   * Clone an AABB
   */
  clone() {
    return new KC().copy(this);
  }
  /**
   * Extend this AABB so that it covers the given AABB too.
   */
  extend(e) {
    this.lowerBound.x = Math.min(this.lowerBound.x, e.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, e.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, e.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, e.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, e.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, e.upperBound.z);
  }
  /**
   * Returns true if the given AABB overlaps this AABB.
   */
  overlaps(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, o = e.upperBound, l = i.x <= n.x && n.x <= o.x || t.x <= o.x && o.x <= n.x, u = i.y <= n.y && n.y <= o.y || t.y <= o.y && o.y <= n.y, I = i.z <= n.z && n.z <= o.z || t.z <= o.z && o.z <= n.z;
    return l && u && I;
  }
  // Mostly for debugging
  volume() {
    const e = this.lowerBound, t = this.upperBound;
    return (t.x - e.x) * (t.y - e.y) * (t.z - e.z);
  }
  /**
   * Returns true if the given AABB is fully contained in this AABB.
   */
  contains(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, o = e.upperBound;
    return t.x <= i.x && n.x >= o.x && t.y <= i.y && n.y >= o.y && t.z <= i.z && n.z >= o.z;
  }
  getCorners(e, t, n, i, o, l, u, I) {
    const f = this.lowerBound, h = this.upperBound;
    e.copy(f), t.set(h.x, f.y, f.z), n.set(h.x, h.y, f.z), i.set(f.x, h.y, h.z), o.set(h.x, f.y, h.z), l.set(f.x, h.y, f.z), u.set(f.x, f.y, h.z), I.copy(h);
  }
  /**
   * Get the representation of an AABB in another frame.
   * @return The "target" AABB object.
   */
  toLocalFrame(e, t) {
    const n = g3, i = n[0], o = n[1], l = n[2], u = n[3], I = n[4], f = n[5], h = n[6], v = n[7];
    this.getCorners(i, o, l, u, I, f, h, v);
    for (let b = 0; b !== 8; b++) {
      const S = n[b];
      e.pointToLocal(S, S);
    }
    return t.setFromPoints(n);
  }
  /**
   * Get the representation of an AABB in the global frame.
   * @return The "target" AABB object.
   */
  toWorldFrame(e, t) {
    const n = g3, i = n[0], o = n[1], l = n[2], u = n[3], I = n[4], f = n[5], h = n[6], v = n[7];
    this.getCorners(i, o, l, u, I, f, h, v);
    for (let b = 0; b !== 8; b++) {
      const S = n[b];
      e.pointToWorld(S, S);
    }
    return t.setFromPoints(n);
  }
  /**
   * Check if the AABB is hit by a ray.
   */
  overlapsRay(e) {
    const {
      direction: t,
      from: n
    } = e, i = 1 / t.x, o = 1 / t.y, l = 1 / t.z, u = (this.lowerBound.x - n.x) * i, I = (this.upperBound.x - n.x) * i, f = (this.lowerBound.y - n.y) * o, h = (this.upperBound.y - n.y) * o, v = (this.lowerBound.z - n.z) * l, b = (this.upperBound.z - n.z) * l, S = Math.max(Math.max(Math.min(u, I), Math.min(f, h)), Math.min(v, b)), R = Math.min(Math.min(Math.max(u, I), Math.max(f, h)), Math.max(v, b));
    return !(R < 0 || S > R);
  }
}
const c3 = new Ne(), g3 = [new Ne(), new Ne(), new Ne(), new Ne(), new Ne(), new Ne(), new Ne(), new Ne()];
class _g {
  constructor(e, t, n, i) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), i === void 0 && (i = 1), this.x = e, this.y = t, this.z = n, this.w = i;
  }
  /**
   * Set the value of the quaternion.
   */
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  /**
   * Convert to a readable format
   * @return "x,y,z,w"
   */
  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  /**
   * Convert to an Array
   * @return [x, y, z, w]
   */
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * Set the quaternion components given an axis and an angle in radians.
   */
  setFromAxisAngle(e, t) {
    const n = Math.sin(t * 0.5);
    return this.x = e.x * n, this.y = e.y * n, this.z = e.z * n, this.w = Math.cos(t * 0.5), this;
  }
  /**
   * Converts the quaternion to [ axis, angle ] representation.
   * @param targetAxis A vector object to reuse for storing the axis.
   * @return An array, first element is the axis and the second is the angle in radians.
   */
  toAxisAngle(e) {
    e === void 0 && (e = new Ne()), this.normalize();
    const t = 2 * Math.acos(this.w), n = Math.sqrt(1 - this.w * this.w);
    return n < 1e-3 ? (e.x = this.x, e.y = this.y, e.z = this.z) : (e.x = this.x / n, e.y = this.y / n, e.z = this.z / n), [e, t];
  }
  /**
   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
   */
  setFromVectors(e, t) {
    if (e.isAntiparallelTo(t)) {
      const n = Mee, i = Hee;
      e.tangents(n, i), this.setFromAxisAngle(n, Math.PI);
    } else {
      const n = e.cross(t);
      this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(e.length() ** 2 * t.length() ** 2) + e.dot(t), this.normalize();
    }
    return this;
  }
  /**
   * Multiply the quaternion with an other quaternion.
   */
  mult(e, t) {
    t === void 0 && (t = new _g());
    const n = this.x, i = this.y, o = this.z, l = this.w, u = e.x, I = e.y, f = e.z, h = e.w;
    return t.x = n * h + l * u + i * f - o * I, t.y = i * h + l * I + o * u - n * f, t.z = o * h + l * f + n * I - i * u, t.w = l * h - n * u - i * I - o * f, t;
  }
  /**
   * Get the inverse quaternion rotation.
   */
  inverse(e) {
    e === void 0 && (e = new _g());
    const t = this.x, n = this.y, i = this.z, o = this.w;
    this.conjugate(e);
    const l = 1 / (t * t + n * n + i * i + o * o);
    return e.x *= l, e.y *= l, e.z *= l, e.w *= l, e;
  }
  /**
   * Get the quaternion conjugate
   */
  conjugate(e) {
    return e === void 0 && (e = new _g()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e.w = this.w, e;
  }
  /**
   * Normalize the quaternion. Note that this changes the values of the quaternion.
   */
  normalize() {
    let e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  /**
   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
   * @author unphased, https://github.com/unphased
   */
  normalizeFast() {
    const e = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  /**
   * Multiply the quaternion by a vector
   */
  vmult(e, t) {
    t === void 0 && (t = new Ne());
    const n = e.x, i = e.y, o = e.z, l = this.x, u = this.y, I = this.z, f = this.w, h = f * n + u * o - I * i, v = f * i + I * n - l * o, b = f * o + l * i - u * n, S = -l * n - u * i - I * o;
    return t.x = h * f + S * -l + v * -I - b * -u, t.y = v * f + S * -u + b * -l - h * -I, t.z = b * f + S * -I + h * -u - v * -l, t;
  }
  /**
   * Copies value of source to this quaternion.
   * @return this
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  /**
   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
   * @param order Three-character string, defaults to "YZX"
   */
  toEuler(e, t) {
    t === void 0 && (t = "YZX");
    let n, i, o;
    const l = this.x, u = this.y, I = this.z, f = this.w;
    switch (t) {
      case "YZX":
        const h = l * u + I * f;
        if (h > 0.499 && (n = 2 * Math.atan2(l, f), i = Math.PI / 2, o = 0), h < -0.499 && (n = -2 * Math.atan2(l, f), i = -Math.PI / 2, o = 0), n === void 0) {
          const v = l * l, b = u * u, S = I * I;
          n = Math.atan2(2 * u * f - 2 * l * I, 1 - 2 * b - 2 * S), i = Math.asin(2 * h), o = Math.atan2(2 * l * f - 2 * u * I, 1 - 2 * v - 2 * S);
        }
        break;
      default:
        throw new Error(`Euler order ${t} not supported yet.`);
    }
    e.y = n, e.z = i, e.x = o;
  }
  /**
   * Set the quaternion components given Euler angle representation.
   *
   * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
   *
   * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
   */
  setFromEuler(e, t, n, i) {
    i === void 0 && (i = "XYZ");
    const o = Math.cos(e / 2), l = Math.cos(t / 2), u = Math.cos(n / 2), I = Math.sin(e / 2), f = Math.sin(t / 2), h = Math.sin(n / 2);
    return i === "XYZ" ? (this.x = I * l * u + o * f * h, this.y = o * f * u - I * l * h, this.z = o * l * h + I * f * u, this.w = o * l * u - I * f * h) : i === "YXZ" ? (this.x = I * l * u + o * f * h, this.y = o * f * u - I * l * h, this.z = o * l * h - I * f * u, this.w = o * l * u + I * f * h) : i === "ZXY" ? (this.x = I * l * u - o * f * h, this.y = o * f * u + I * l * h, this.z = o * l * h + I * f * u, this.w = o * l * u - I * f * h) : i === "ZYX" ? (this.x = I * l * u - o * f * h, this.y = o * f * u + I * l * h, this.z = o * l * h - I * f * u, this.w = o * l * u + I * f * h) : i === "YZX" ? (this.x = I * l * u + o * f * h, this.y = o * f * u + I * l * h, this.z = o * l * h - I * f * u, this.w = o * l * u - I * f * h) : i === "XZY" && (this.x = I * l * u - o * f * h, this.y = o * f * u - I * l * h, this.z = o * l * h + I * f * u, this.w = o * l * u + I * f * h), this;
  }
  clone() {
    return new _g(this.x, this.y, this.z, this.w);
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param toQuat second operand
   * @param t interpolation amount between the self quaternion and toQuat
   * @param target A quaternion to store the result in. If not provided, a new one will be created.
   * @returns {Quaternion} The "target" object
   */
  slerp(e, t, n) {
    n === void 0 && (n = new _g());
    const i = this.x, o = this.y, l = this.z, u = this.w;
    let I = e.x, f = e.y, h = e.z, v = e.w, b, S, R, W, x;
    return S = i * I + o * f + l * h + u * v, S < 0 && (S = -S, I = -I, f = -f, h = -h, v = -v), 1 - S > 1e-6 ? (b = Math.acos(S), R = Math.sin(b), W = Math.sin((1 - t) * b) / R, x = Math.sin(t * b) / R) : (W = 1 - t, x = t), n.x = W * i + x * I, n.y = W * o + x * f, n.z = W * l + x * h, n.w = W * u + x * v, n;
  }
  /**
   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
   */
  integrate(e, t, n, i) {
    i === void 0 && (i = new _g());
    const o = e.x * n.x, l = e.y * n.y, u = e.z * n.z, I = this.x, f = this.y, h = this.z, v = this.w, b = t * 0.5;
    return i.x += b * (o * v + l * h - u * f), i.y += b * (l * v + u * I - o * h), i.z += b * (u * v + o * f - l * I), i.w += b * (-o * I - l * f - u * h), i;
  }
}
const Mee = new Ne(), Hee = new Ne(), Xee = {
  /** SPHERE */
  SPHERE: 1,
  /** PLANE */
  PLANE: 2,
  /** BOX */
  BOX: 4,
  /** COMPOUND */
  COMPOUND: 8,
  /** CONVEXPOLYHEDRON */
  CONVEXPOLYHEDRON: 16,
  /** HEIGHTFIELD */
  HEIGHTFIELD: 32,
  /** PARTICLE */
  PARTICLE: 64,
  /** CYLINDER */
  CYLINDER: 128,
  /** TRIMESH */
  TRIMESH: 256
};
class zi {
  /**
   * Identifier of the Shape.
   */
  /**
   * The type of this shape. Must be set to an int > 0 by subclasses.
   */
  /**
   * The local bounding sphere radius of this shape.
   */
  /**
   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
   * @default true
   */
  /**
   * @default 1
   */
  /**
   * @default -1
   */
  /**
   * Optional material of the shape that regulates contact properties.
   */
  /**
   * The body to which the shape is added to.
   */
  /**
   * All the Shape types.
   */
  constructor(e) {
    e === void 0 && (e = {}), this.id = zi.idCounter++, this.type = e.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = e.collisionResponse ? e.collisionResponse : !0, this.collisionFilterGroup = e.collisionFilterGroup !== void 0 ? e.collisionFilterGroup : 1, this.collisionFilterMask = e.collisionFilterMask !== void 0 ? e.collisionFilterMask : -1, this.material = e.material ? e.material : null, this.body = null;
  }
  /**
   * Computes the bounding sphere radius.
   * The result is stored in the property `.boundingSphereRadius`
   */
  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  /**
   * Get the volume of this shape
   */
  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  /**
   * Calculates the inertia in the local frame for this shape.
   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  calculateLocalInertia(e, t) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  /**
   * @todo use abstract for these kind of methods
   */
  calculateWorldAABB(e, t, n, i) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }
}
zi.idCounter = 0;
zi.types = Xee;
class Hd {
  /**
   * position
   */
  /**
   * quaternion
   */
  constructor(e) {
    e === void 0 && (e = {}), this.position = new Ne(), this.quaternion = new _g(), e.position && this.position.copy(e.position), e.quaternion && this.quaternion.copy(e.quaternion);
  }
  /**
   * Get a global point in local transform coordinates.
   */
  pointToLocal(e, t) {
    return Hd.pointToLocalFrame(this.position, this.quaternion, e, t);
  }
  /**
   * Get a local point in global transform coordinates.
   */
  pointToWorld(e, t) {
    return Hd.pointToWorldFrame(this.position, this.quaternion, e, t);
  }
  /**
   * vectorToWorldFrame
   */
  vectorToWorldFrame(e, t) {
    return t === void 0 && (t = new Ne()), this.quaternion.vmult(e, t), t;
  }
  /**
   * pointToLocalFrame
   */
  static pointToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new Ne()), n.vsub(e, i), t.conjugate(d3), d3.vmult(i, i), i;
  }
  /**
   * pointToWorldFrame
   */
  static pointToWorldFrame(e, t, n, i) {
    return i === void 0 && (i = new Ne()), t.vmult(n, i), i.vadd(e, i), i;
  }
  /**
   * vectorToWorldFrame
   */
  static vectorToWorldFrame(e, t, n) {
    return n === void 0 && (n = new Ne()), e.vmult(t, n), n;
  }
  /**
   * vectorToLocalFrame
   */
  static vectorToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new Ne()), t.w *= -1, t.vmult(n, i), t.w *= -1, i;
  }
}
const d3 = new _g();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne(), new Ne(), new Ne(), new Ne(), new Ne(), new Ne(), new Ne(), new Ne();
new Ne();
new _g();
new KC();
new xm();
new xm();
new xm();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new _g();
new Ne();
new Ne();
new Ne();
new Ne();
class kH {
  /**
   * rayFromWorld
   */
  /**
   * rayToWorld
   */
  /**
   * hitNormalWorld
   */
  /**
   * hitPointWorld
   */
  /**
   * hasHit
   */
  /**
   * shape
   */
  /**
   * body
   */
  /**
   * The index of the hit triangle, if the hit shape was a trimesh
   */
  /**
   * Distance to the hit. Will be set to -1 if there was no hit
   */
  /**
   * If the ray should stop traversing the bodies
   */
  constructor() {
    this.rayFromWorld = new Ne(), this.rayToWorld = new Ne(), this.hitNormalWorld = new Ne(), this.hitPointWorld = new Ne(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  /**
   * Reset all result data.
   */
  reset() {
    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  /**
   * abort
   */
  abort() {
    this.shouldStop = !0;
  }
  /**
   * Set result data.
   */
  set(e, t, n, i, o, l, u) {
    this.rayFromWorld.copy(e), this.rayToWorld.copy(t), this.hitNormalWorld.copy(n), this.hitPointWorld.copy(i), this.shape = o, this.body = l, this.distance = u;
  }
}
let IL, CL, hL, fL, pL, mL, AL;
const IY = {
  /** CLOSEST */
  CLOSEST: 1,
  /** ANY */
  ANY: 2,
  /** ALL */
  ALL: 4
};
IL = zi.types.SPHERE;
CL = zi.types.PLANE;
hL = zi.types.BOX;
fL = zi.types.CYLINDER;
pL = zi.types.CONVEXPOLYHEDRON;
mL = zi.types.HEIGHTFIELD;
AL = zi.types.TRIMESH;
class eg {
  /**
   * from
   */
  /**
   * to
   */
  /**
   * direction
   */
  /**
   * The precision of the ray. Used when checking parallelity etc.
   * @default 0.0001
   */
  /**
   * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
   * @default true
   */
  /**
   * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
   * @default false
   */
  /**
   * collisionFilterMask
   * @default -1
   */
  /**
   * collisionFilterGroup
   * @default -1
   */
  /**
   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
   * @default RAY.ANY
   */
  /**
   * Current result object.
   */
  /**
   * Will be set to `true` during intersectWorld() if the ray hit anything.
   */
  /**
   * User-provided result callback. Will be used if mode is Ray.ALL.
   */
  /**
   * CLOSEST
   */
  /**
   * ANY
   */
  /**
   * ALL
   */
  get [IL]() {
    return this._intersectSphere;
  }
  get [CL]() {
    return this._intersectPlane;
  }
  get [hL]() {
    return this._intersectBox;
  }
  get [fL]() {
    return this._intersectConvex;
  }
  get [pL]() {
    return this._intersectConvex;
  }
  get [mL]() {
    return this._intersectHeightfield;
  }
  get [AL]() {
    return this._intersectTrimesh;
  }
  constructor(e, t) {
    e === void 0 && (e = new Ne()), t === void 0 && (t = new Ne()), this.from = e.clone(), this.to = t.clone(), this.direction = new Ne(), this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = eg.ANY, this.result = new kH(), this.hasHit = !1, this.callback = (n) => {
    };
  }
  /**
   * Do itersection against all bodies in the given World.
   * @return True if the ray hit anything, otherwise false.
   */
  intersectWorld(e, t) {
    return this.mode = t.mode || eg.ANY, this.result = t.result || new kH(), this.skipBackfaces = !!t.skipBackfaces, this.collisionFilterMask = typeof t.collisionFilterMask < "u" ? t.collisionFilterMask : -1, this.collisionFilterGroup = typeof t.collisionFilterGroup < "u" ? t.collisionFilterGroup : -1, this.checkCollisionResponse = typeof t.checkCollisionResponse < "u" ? t.checkCollisionResponse : !0, t.from && this.from.copy(t.from), t.to && this.to.copy(t.to), this.callback = t.callback || (() => {
    }), this.hasHit = !1, this.result.reset(), this.updateDirection(), this.getAABB(I3), jM.length = 0, e.broadphase.aabbQuery(e, I3, jM), this.intersectBodies(jM), this.hasHit;
  }
  /**
   * Shoot a ray at a body, get back information about the hit.
   * @deprecated @param result set the result property of the Ray instead.
   */
  intersectBody(e, t) {
    t && (this.result = t, this.updateDirection());
    const n = this.checkCollisionResponse;
    if (n && !e.collisionResponse || !(this.collisionFilterGroup & e.collisionFilterMask) || !(e.collisionFilterGroup & this.collisionFilterMask))
      return;
    const i = Yee, o = Fee;
    for (let l = 0, u = e.shapes.length; l < u; l++) {
      const I = e.shapes[l];
      if (!(n && !I.collisionResponse) && (e.quaternion.mult(e.shapeOrientations[l], o), e.quaternion.vmult(e.shapeOffsets[l], i), i.vadd(e.position, i), this.intersectShape(I, o, i, e), this.result.shouldStop))
        break;
    }
  }
  /**
   * Shoot a ray at an array bodies, get back information about the hit.
   * @param bodies An array of Body objects.
   * @deprecated @param result set the result property of the Ray instead.
   *
   */
  intersectBodies(e, t) {
    t && (this.result = t, this.updateDirection());
    for (let n = 0, i = e.length; !this.result.shouldStop && n < i; n++)
      this.intersectBody(e[n]);
  }
  /**
   * Updates the direction vector.
   */
  updateDirection() {
    this.to.vsub(this.from, this.direction), this.direction.normalize();
  }
  intersectShape(e, t, n, i) {
    const o = this.from;
    if (jee(o, this.direction, n) > e.boundingSphereRadius)
      return;
    const u = this[e.type];
    u && u.call(this, e, t, n, i, e);
  }
  _intersectBox(e, t, n, i, o) {
    return this._intersectConvex(e.convexPolyhedronRepresentation, t, n, i, o);
  }
  _intersectPlane(e, t, n, i, o) {
    const l = this.from, u = this.to, I = this.direction, f = new Ne(0, 0, 1);
    t.vmult(f, f);
    const h = new Ne();
    l.vsub(n, h);
    const v = h.dot(f);
    u.vsub(n, h);
    const b = h.dot(f);
    if (v * b > 0 || l.distanceTo(u) < v)
      return;
    const S = f.dot(I);
    if (Math.abs(S) < this.precision)
      return;
    const R = new Ne(), W = new Ne(), x = new Ne();
    l.vsub(n, R);
    const M = -f.dot(R) / S;
    I.scale(M, W), l.vadd(W, x), this.reportIntersection(f, x, o, i, -1);
  }
  /**
   * Get the world AABB of the ray.
   */
  getAABB(e) {
    const {
      lowerBound: t,
      upperBound: n
    } = e, i = this.to, o = this.from;
    t.x = Math.min(i.x, o.x), t.y = Math.min(i.y, o.y), t.z = Math.min(i.z, o.z), n.x = Math.max(i.x, o.x), n.y = Math.max(i.y, o.y), n.z = Math.max(i.z, o.z);
  }
  _intersectHeightfield(e, t, n, i, o) {
    e.data, e.elementSize;
    const l = Eee;
    l.from.copy(this.from), l.to.copy(this.to), Hd.pointToLocalFrame(n, t, l.from, l.from), Hd.pointToLocalFrame(n, t, l.to, l.to), l.updateDirection();
    const u = Tee;
    let I, f, h, v;
    I = f = 0, h = v = e.data.length - 1;
    const b = new KC();
    l.getAABB(b), e.getIndexOfPosition(b.lowerBound.x, b.lowerBound.y, u, !0), I = Math.max(I, u[0]), f = Math.max(f, u[1]), e.getIndexOfPosition(b.upperBound.x, b.upperBound.y, u, !0), h = Math.min(h, u[0] + 1), v = Math.min(v, u[1] + 1);
    for (let S = I; S < h; S++)
      for (let R = f; R < v; R++) {
        if (this.result.shouldStop)
          return;
        if (e.getAabbAtIndex(S, R, b), !!b.overlapsRay(l)) {
          if (e.getConvexTrianglePillar(S, R, !1), Hd.pointToWorldFrame(n, t, e.pillarOffset, E1), this._intersectConvex(e.pillarConvex, t, E1, i, o, C3), this.result.shouldStop)
            return;
          e.getConvexTrianglePillar(S, R, !0), Hd.pointToWorldFrame(n, t, e.pillarOffset, E1), this._intersectConvex(e.pillarConvex, t, E1, i, o, C3);
        }
      }
  }
  _intersectSphere(e, t, n, i, o) {
    const l = this.from, u = this.to, I = e.radius, f = (u.x - l.x) ** 2 + (u.y - l.y) ** 2 + (u.z - l.z) ** 2, h = 2 * ((u.x - l.x) * (l.x - n.x) + (u.y - l.y) * (l.y - n.y) + (u.z - l.z) * (l.z - n.z)), v = (l.x - n.x) ** 2 + (l.y - n.y) ** 2 + (l.z - n.z) ** 2 - I ** 2, b = h ** 2 - 4 * f * v, S = _ee, R = zee;
    if (!(b < 0))
      if (b === 0)
        l.lerp(u, b, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1);
      else {
        const W = (-h - Math.sqrt(b)) / (2 * f), x = (-h + Math.sqrt(b)) / (2 * f);
        if (W >= 0 && W <= 1 && (l.lerp(u, W, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1)), this.result.shouldStop)
          return;
        x >= 0 && x <= 1 && (l.lerp(u, x, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1));
      }
  }
  _intersectConvex(e, t, n, i, o, l) {
    const u = Kee, I = h3, f = l && l.faceList || null, h = e.faces, v = e.vertices, b = e.faceNormals, S = this.direction, R = this.from, W = this.to, x = R.distanceTo(W), M = f ? f.length : h.length, T = this.result;
    for (let E = 0; !T.shouldStop && E < M; E++) {
      const _ = f ? f[E] : E, P = h[_], U = b[_], q = t, k = n;
      I.copy(v[P[0]]), q.vmult(I, I), I.vadd(k, I), I.vsub(R, I), q.vmult(U, u);
      const O = S.dot(u);
      if (Math.abs(O) < this.precision)
        continue;
      const J = u.dot(I) / O;
      if (!(J < 0)) {
        S.scale(J, Vd), Vd.vadd(R, Vd), Hh.copy(v[P[0]]), q.vmult(Hh, Hh), k.vadd(Hh, Hh);
        for (let te = 1; !T.shouldStop && te < P.length - 1; te++) {
          Jf.copy(v[P[te]]), Qf.copy(v[P[te + 1]]), q.vmult(Jf, Jf), q.vmult(Qf, Qf), k.vadd(Jf, Jf), k.vadd(Qf, Qf);
          const fe = Vd.distanceTo(R);
          !(eg.pointInTriangle(Vd, Hh, Jf, Qf) || eg.pointInTriangle(Vd, Jf, Hh, Qf)) || fe > x || this.reportIntersection(u, Vd, o, i, _);
        }
      }
    }
  }
  /**
   * @todo Optimize by transforming the world to local space first.
   * @todo Use Octree lookup
   */
  _intersectTrimesh(e, t, n, i, o, l) {
    const u = Lee, I = Jee, f = Qee, h = h3, v = kee, b = Dee, S = Uee, R = Pee, W = Oee, x = e.indices;
    e.vertices;
    const M = this.from, T = this.to, E = this.direction;
    f.position.copy(n), f.quaternion.copy(t), Hd.vectorToLocalFrame(n, t, E, v), Hd.pointToLocalFrame(n, t, M, b), Hd.pointToLocalFrame(n, t, T, S), S.x *= e.scale.x, S.y *= e.scale.y, S.z *= e.scale.z, b.x *= e.scale.x, b.y *= e.scale.y, b.z *= e.scale.z, S.vsub(b, v), v.normalize();
    const _ = b.distanceSquared(S);
    e.tree.rayQuery(this, f, I);
    for (let P = 0, U = I.length; !this.result.shouldStop && P !== U; P++) {
      const q = I[P];
      e.getNormal(q, u), e.getVertex(x[q * 3], Hh), Hh.vsub(b, h);
      const k = v.dot(u), O = u.dot(h) / k;
      if (O < 0)
        continue;
      v.scale(O, Vd), Vd.vadd(b, Vd), e.getVertex(x[q * 3 + 1], Jf), e.getVertex(x[q * 3 + 2], Qf);
      const J = Vd.distanceSquared(b);
      !(eg.pointInTriangle(Vd, Jf, Hh, Qf) || eg.pointInTriangle(Vd, Hh, Jf, Qf)) || J > _ || (Hd.vectorToWorldFrame(t, u, W), Hd.pointToWorldFrame(n, t, Vd, R), this.reportIntersection(W, R, o, i, q));
    }
    I.length = 0;
  }
  /**
   * @return True if the intersections should continue
   */
  reportIntersection(e, t, n, i, o) {
    const l = this.from, u = this.to, I = l.distanceTo(t), f = this.result;
    if (!(this.skipBackfaces && e.dot(this.direction) > 0))
      switch (f.hitFaceIndex = typeof o < "u" ? o : -1, this.mode) {
        case eg.ALL:
          this.hasHit = !0, f.set(l, u, e, t, n, i, I), f.hasHit = !0, this.callback(f);
          break;
        case eg.CLOSEST:
          (I < f.distance || !f.hasHit) && (this.hasHit = !0, f.hasHit = !0, f.set(l, u, e, t, n, i, I));
          break;
        case eg.ANY:
          this.hasHit = !0, f.hasHit = !0, f.set(l, u, e, t, n, i, I), f.shouldStop = !0;
          break;
      }
  }
  /**
   * As per "Barycentric Technique" as named
   * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
   */
  static pointInTriangle(e, t, n, i) {
    i.vsub(t, eb), n.vsub(t, WZ), e.vsub(t, qM);
    const o = eb.dot(eb), l = eb.dot(WZ), u = eb.dot(qM), I = WZ.dot(WZ), f = WZ.dot(qM);
    let h, v;
    return (h = I * u - l * f) >= 0 && (v = o * f - l * u) >= 0 && h + v < o * I - l * l;
  }
}
eg.CLOSEST = IY.CLOSEST;
eg.ANY = IY.ANY;
eg.ALL = IY.ALL;
const I3 = new KC(), jM = [], WZ = new Ne(), qM = new Ne(), Yee = new Ne(), Fee = new _g(), Vd = new Ne(), Hh = new Ne(), Jf = new Ne(), Qf = new Ne();
new Ne();
new kH();
const C3 = {
  faceList: [0]
}, E1 = new Ne(), Eee = new eg(), Tee = [], _ee = new Ne(), zee = new Ne(), Kee = new Ne();
new Ne();
new Ne();
const h3 = new Ne(), Lee = new Ne(), kee = new Ne(), Dee = new Ne(), Uee = new Ne(), Oee = new Ne(), Pee = new Ne();
new KC();
const Jee = [], Qee = new Hd(), eb = new Ne(), T1 = new Ne();
function jee(a, e, t) {
  t.vsub(a, eb);
  const n = eb.dot(e);
  return e.scale(n, T1), T1.vadd(a, T1), t.distanceTo(T1);
}
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new eg();
new Ne();
new Ne();
new Ne();
new Ne(1, 0, 0), new Ne(0, 1, 0), new Ne(0, 0, 1);
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new KC();
new Ne();
new KC();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new KC();
new Ne();
new Hd();
new KC();
zi.types.SPHERE, zi.types.SPHERE | zi.types.PLANE, zi.types.BOX | zi.types.BOX, zi.types.SPHERE | zi.types.BOX, zi.types.PLANE | zi.types.BOX, zi.types.CONVEXPOLYHEDRON, zi.types.SPHERE | zi.types.CONVEXPOLYHEDRON, zi.types.PLANE | zi.types.CONVEXPOLYHEDRON, zi.types.BOX | zi.types.CONVEXPOLYHEDRON, zi.types.SPHERE | zi.types.HEIGHTFIELD, zi.types.BOX | zi.types.HEIGHTFIELD, zi.types.CONVEXPOLYHEDRON | zi.types.HEIGHTFIELD, zi.types.PARTICLE | zi.types.SPHERE, zi.types.PLANE | zi.types.PARTICLE, zi.types.BOX | zi.types.PARTICLE, zi.types.PARTICLE | zi.types.CONVEXPOLYHEDRON, zi.types.CYLINDER, zi.types.SPHERE | zi.types.CYLINDER, zi.types.PLANE | zi.types.CYLINDER, zi.types.BOX | zi.types.CYLINDER, zi.types.CONVEXPOLYHEDRON | zi.types.CYLINDER, zi.types.HEIGHTFIELD | zi.types.CYLINDER, zi.types.PARTICLE | zi.types.CYLINDER, zi.types.SPHERE | zi.types.TRIMESH, zi.types.PLANE | zi.types.TRIMESH;
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new _g();
new _g();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new KC();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne(), new Ne(), new Ne(), new Ne(), new Ne(), new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new _g();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new Ne();
new KC();
new eg();
const VZ = globalThis.performance || {};
if (!VZ.now) {
  let a = Date.now();
  VZ.timing && VZ.timing.navigationStart && (a = VZ.timing.navigationStart), VZ.now = () => Date.now() - a;
}
new Ne();
class Wm {
  /**
   * A vector of length 9, containing all matrix elements.
   */
  /**
   * @param elements A vector of length 9, containing all matrix elements.
   */
  constructor(e) {
    e === void 0 && (e = [0, 0, 0, 0, 0, 0, 0, 0, 0]), this.elements = e;
  }
  /**
   * Sets the matrix to identity
   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
   * @todo Create another function that immediately creates an identity matrix eg. `eye()`
   */
  identity() {
    const e = this.elements;
    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1;
  }
  /**
   * Set all elements to zero
   */
  setZero() {
    const e = this.elements;
    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 0;
  }
  /**
   * Sets the matrix diagonal elements from a Vec3
   */
  setTrace(e) {
    const t = this.elements;
    t[0] = e.x, t[4] = e.y, t[8] = e.z;
  }
  /**
   * Gets the matrix diagonal elements
   */
  getTrace(e) {
    e === void 0 && (e = new Me());
    const t = this.elements;
    return e.x = t[0], e.y = t[4], e.z = t[8], e;
  }
  /**
   * Matrix-Vector multiplication
   * @param v The vector to multiply with
   * @param target Optional, target to save the result in.
   */
  vmult(e, t) {
    t === void 0 && (t = new Me());
    const n = this.elements, i = e.x, o = e.y, l = e.z;
    return t.x = n[0] * i + n[1] * o + n[2] * l, t.y = n[3] * i + n[4] * o + n[5] * l, t.z = n[6] * i + n[7] * o + n[8] * l, t;
  }
  /**
   * Matrix-scalar multiplication
   */
  smult(e) {
    for (let t = 0; t < this.elements.length; t++)
      this.elements[t] *= e;
  }
  /**
   * Matrix multiplication
   * @param matrix Matrix to multiply with from left side.
   */
  mmult(e, t) {
    t === void 0 && (t = new Wm());
    const n = this.elements, i = e.elements, o = t.elements, l = n[0], u = n[1], I = n[2], f = n[3], h = n[4], v = n[5], b = n[6], S = n[7], R = n[8], W = i[0], x = i[1], M = i[2], T = i[3], E = i[4], _ = i[5], P = i[6], U = i[7], q = i[8];
    return o[0] = l * W + u * T + I * P, o[1] = l * x + u * E + I * U, o[2] = l * M + u * _ + I * q, o[3] = f * W + h * T + v * P, o[4] = f * x + h * E + v * U, o[5] = f * M + h * _ + v * q, o[6] = b * W + S * T + R * P, o[7] = b * x + S * E + R * U, o[8] = b * M + S * _ + R * q, t;
  }
  /**
   * Scale each column of the matrix
   */
  scale(e, t) {
    t === void 0 && (t = new Wm());
    const n = this.elements, i = t.elements;
    for (let o = 0; o !== 3; o++)
      i[3 * o + 0] = e.x * n[3 * o + 0], i[3 * o + 1] = e.y * n[3 * o + 1], i[3 * o + 2] = e.z * n[3 * o + 2];
    return t;
  }
  /**
   * Solve Ax=b
   * @param b The right hand side
   * @param target Optional. Target vector to save in.
   * @return The solution x
   * @todo should reuse arrays
   */
  solve(e, t) {
    t === void 0 && (t = new Me());
    const n = 3, i = 4, o = [];
    let l, u;
    for (l = 0; l < n * i; l++)
      o.push(0);
    for (l = 0; l < 3; l++)
      for (u = 0; u < 3; u++)
        o[l + i * u] = this.elements[l + 3 * u];
    o[3 + 4 * 0] = e.x, o[3 + 4 * 1] = e.y, o[3 + 4 * 2] = e.z;
    let I = 3;
    const f = I;
    let h;
    const v = 4;
    let b;
    do {
      if (l = f - I, o[l + i * l] === 0) {
        for (u = l + 1; u < f; u++)
          if (o[l + i * u] !== 0) {
            h = v;
            do
              b = v - h, o[b + i * l] += o[b + i * u];
            while (--h);
            break;
          }
      }
      if (o[l + i * l] !== 0)
        for (u = l + 1; u < f; u++) {
          const S = o[l + i * u] / o[l + i * l];
          h = v;
          do
            b = v - h, o[b + i * u] = b <= l ? 0 : o[b + i * u] - o[b + i * l] * S;
          while (--h);
        }
    } while (--I);
    if (t.z = o[2 * i + 3] / o[2 * i + 2], t.y = (o[1 * i + 3] - o[1 * i + 2] * t.z) / o[1 * i + 1], t.x = (o[0 * i + 3] - o[0 * i + 2] * t.z - o[0 * i + 1] * t.y) / o[0 * i + 0], isNaN(t.x) || isNaN(t.y) || isNaN(t.z) || t.x === 1 / 0 || t.y === 1 / 0 || t.z === 1 / 0)
      throw `Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;
    return t;
  }
  /**
   * Get an element in the matrix by index. Index starts at 0, not 1!!!
   * @param value If provided, the matrix element will be set to this value.
   */
  e(e, t, n) {
    if (n === void 0)
      return this.elements[t + 3 * e];
    this.elements[t + 3 * e] = n;
  }
  /**
   * Copy another matrix into this matrix object.
   */
  copy(e) {
    for (let t = 0; t < e.elements.length; t++)
      this.elements[t] = e.elements[t];
    return this;
  }
  /**
   * Returns a string representation of the matrix.
   */
  toString() {
    let e = "";
    const t = ",";
    for (let n = 0; n < 9; n++)
      e += this.elements[n] + t;
    return e;
  }
  /**
   * reverse the matrix
   * @param target Target matrix to save in.
   * @return The solution x
   */
  reverse(e) {
    e === void 0 && (e = new Wm());
    const t = 3, n = 6, i = qee;
    let o, l;
    for (o = 0; o < 3; o++)
      for (l = 0; l < 3; l++)
        i[o + n * l] = this.elements[o + 3 * l];
    i[3 + 6 * 0] = 1, i[3 + 6 * 1] = 0, i[3 + 6 * 2] = 0, i[4 + 6 * 0] = 0, i[4 + 6 * 1] = 1, i[4 + 6 * 2] = 0, i[5 + 6 * 0] = 0, i[5 + 6 * 1] = 0, i[5 + 6 * 2] = 1;
    let u = 3;
    const I = u;
    let f;
    const h = n;
    let v;
    do {
      if (o = I - u, i[o + n * o] === 0) {
        for (l = o + 1; l < I; l++)
          if (i[o + n * l] !== 0) {
            f = h;
            do
              v = h - f, i[v + n * o] += i[v + n * l];
            while (--f);
            break;
          }
      }
      if (i[o + n * o] !== 0)
        for (l = o + 1; l < I; l++) {
          const b = i[o + n * l] / i[o + n * o];
          f = h;
          do
            v = h - f, i[v + n * l] = v <= o ? 0 : i[v + n * l] - i[v + n * o] * b;
          while (--f);
        }
    } while (--u);
    o = 2;
    do {
      l = o - 1;
      do {
        const b = i[o + n * l] / i[o + n * o];
        f = n;
        do
          v = n - f, i[v + n * l] = i[v + n * l] - i[v + n * o] * b;
        while (--f);
      } while (l--);
    } while (--o);
    o = 2;
    do {
      const b = 1 / i[o + n * o];
      f = n;
      do
        v = n - f, i[v + n * o] = i[v + n * o] * b;
      while (--f);
    } while (o--);
    o = 2;
    do {
      l = 2;
      do {
        if (v = i[t + l + n * o], isNaN(v) || v === 1 / 0)
          throw `Could not reverse! A=[${this.toString()}]`;
        e.e(o, l, v);
      } while (l--);
    } while (o--);
    return e;
  }
  /**
   * Set the matrix from a quaterion
   */
  setRotationFromQuaternion(e) {
    const t = e.x, n = e.y, i = e.z, o = e.w, l = t + t, u = n + n, I = i + i, f = t * l, h = t * u, v = t * I, b = n * u, S = n * I, R = i * I, W = o * l, x = o * u, M = o * I, T = this.elements;
    return T[3 * 0 + 0] = 1 - (b + R), T[3 * 0 + 1] = h - M, T[3 * 0 + 2] = v + x, T[3 * 1 + 0] = h + M, T[3 * 1 + 1] = 1 - (f + R), T[3 * 1 + 2] = S - W, T[3 * 2 + 0] = v - x, T[3 * 2 + 1] = S + W, T[3 * 2 + 2] = 1 - (f + b), this;
  }
  /**
   * Transpose the matrix
   * @param target Optional. Where to store the result.
   * @return The target Mat3, or a new Mat3 if target was omitted.
   */
  transpose(e) {
    e === void 0 && (e = new Wm());
    const t = this.elements, n = e.elements;
    let i;
    return n[0] = t[0], n[4] = t[4], n[8] = t[8], i = t[1], n[1] = t[3], n[3] = i, i = t[2], n[2] = t[6], n[6] = i, i = t[5], n[5] = t[7], n[7] = i, e;
  }
}
const qee = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
class Me {
  constructor(e, t, n) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), this.x = e, this.y = t, this.z = n;
  }
  /**
   * Vector cross product
   * @param target Optional target to save in.
   */
  cross(e, t) {
    t === void 0 && (t = new Me());
    const n = e.x, i = e.y, o = e.z, l = this.x, u = this.y, I = this.z;
    return t.x = u * o - I * i, t.y = I * n - l * o, t.z = l * i - u * n, t;
  }
  /**
   * Set the vectors' 3 elements
   */
  set(e, t, n) {
    return this.x = e, this.y = t, this.z = n, this;
  }
  /**
   * Set all components of the vector to zero.
   */
  setZero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Vector addition
   */
  vadd(e, t) {
    if (t)
      t.x = e.x + this.x, t.y = e.y + this.y, t.z = e.z + this.z;
    else
      return new Me(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  /**
   * Vector subtraction
   * @param target Optional target to save in.
   */
  vsub(e, t) {
    if (t)
      t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z;
    else
      return new Me(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  /**
   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
   *
   * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Umeå University Lecture}
   */
  crossmat() {
    return new Wm([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  /**
   * Normalize the vector. Note that this changes the values in the vector.
    * @return Returns the norm of the vector
   */
  normalize() {
    const e = this.x, t = this.y, n = this.z, i = Math.sqrt(e * e + t * t + n * n);
    if (i > 0) {
      const o = 1 / i;
      this.x *= o, this.y *= o, this.z *= o;
    } else
      this.x = 0, this.y = 0, this.z = 0;
    return i;
  }
  /**
   * Get the version of this vector that is of length 1.
   * @param target Optional target to save in
   * @return Returns the unit vector
   */
  unit(e) {
    e === void 0 && (e = new Me());
    const t = this.x, n = this.y, i = this.z;
    let o = Math.sqrt(t * t + n * n + i * i);
    return o > 0 ? (o = 1 / o, e.x = t * o, e.y = n * o, e.z = i * o) : (e.x = 1, e.y = 0, e.z = 0), e;
  }
  /**
   * Get the length of the vector
   */
  length() {
    const e = this.x, t = this.y, n = this.z;
    return Math.sqrt(e * e + t * t + n * n);
  }
  /**
   * Get the squared length of the vector.
   */
  lengthSquared() {
    return this.dot(this);
  }
  /**
   * Get distance from this point to another point
   */
  distanceTo(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z;
    return Math.sqrt((o - t) * (o - t) + (l - n) * (l - n) + (u - i) * (u - i));
  }
  /**
   * Get squared distance from this point to another point
   */
  distanceSquared(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, u = e.z;
    return (o - t) * (o - t) + (l - n) * (l - n) + (u - i) * (u - i);
  }
  /**
   * Multiply all the components of the vector with a scalar.
   * @param target The vector to save the result in.
   */
  scale(e, t) {
    t === void 0 && (t = new Me());
    const n = this.x, i = this.y, o = this.z;
    return t.x = e * n, t.y = e * i, t.z = e * o, t;
  }
  /**
   * Multiply the vector with an other vector, component-wise.
   * @param target The vector to save the result in.
   */
  vmul(e, t) {
    return t === void 0 && (t = new Me()), t.x = e.x * this.x, t.y = e.y * this.y, t.z = e.z * this.z, t;
  }
  /**
   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
   * @param target The vector to save the result in.
   */
  addScaledVector(e, t, n) {
    return n === void 0 && (n = new Me()), n.x = this.x + e * t.x, n.y = this.y + e * t.y, n.z = this.z + e * t.z, n;
  }
  /**
   * Calculate dot product
   * @param vector
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  /**
   * Make the vector point in the opposite direction.
   * @param target Optional target to save in
   */
  negate(e) {
    return e === void 0 && (e = new Me()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e;
  }
  /**
   * Compute two artificial tangents to the vector
   * @param t1 Vector object to save the first tangent in
   * @param t2 Vector object to save the second tangent in
   */
  tangents(e, t) {
    const n = this.length();
    if (n > 0) {
      const i = $ee, o = 1 / n;
      i.set(this.x * o, this.y * o, this.z * o);
      const l = ete;
      Math.abs(i.x) < 0.9 ? (l.set(1, 0, 0), i.cross(l, e)) : (l.set(0, 1, 0), i.cross(l, e)), i.cross(e, t);
    } else
      e.set(1, 0, 0), t.set(0, 1, 0);
  }
  /**
   * Converts to a more readable format
   */
  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  /**
   * Converts to an array
   */
  toArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * Copies value of source to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Do a linear interpolation between two vectors
   * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
   */
  lerp(e, t, n) {
    const i = this.x, o = this.y, l = this.z;
    n.x = i + (e.x - i) * t, n.y = o + (e.y - o) * t, n.z = l + (e.z - l) * t;
  }
  /**
   * Check if a vector equals is almost equal to another one.
   */
  almostEquals(e, t) {
    return t === void 0 && (t = 1e-6), !(Math.abs(this.x - e.x) > t || Math.abs(this.y - e.y) > t || Math.abs(this.z - e.z) > t);
  }
  /**
   * Check if a vector is almost zero
   */
  almostZero(e) {
    return e === void 0 && (e = 1e-6), !(Math.abs(this.x) > e || Math.abs(this.y) > e || Math.abs(this.z) > e);
  }
  /**
   * Check if the vector is anti-parallel to another vector.
   * @param precision Set to zero for exact comparisons
   */
  isAntiparallelTo(e, t) {
    return this.negate(f3), f3.almostEquals(e, t);
  }
  /**
   * Clone the vector
   */
  clone() {
    return new Me(this.x, this.y, this.z);
  }
}
Me.ZERO = new Me(0, 0, 0);
Me.UNIT_X = new Me(1, 0, 0);
Me.UNIT_Y = new Me(0, 1, 0);
Me.UNIT_Z = new Me(0, 0, 1);
const $ee = new Me(), ete = new Me(), f3 = new Me();
class LC {
  /**
   * The lower bound of the bounding box
   */
  /**
   * The upper bound of the bounding box
   */
  constructor(e) {
    e === void 0 && (e = {}), this.lowerBound = new Me(), this.upperBound = new Me(), e.lowerBound && this.lowerBound.copy(e.lowerBound), e.upperBound && this.upperBound.copy(e.upperBound);
  }
  /**
   * Set the AABB bounds from a set of points.
   * @param points An array of Vec3's.
   * @return The self object
   */
  setFromPoints(e, t, n, i) {
    const o = this.lowerBound, l = this.upperBound, u = n;
    o.copy(e[0]), u && u.vmult(o, o), l.copy(o);
    for (let I = 1; I < e.length; I++) {
      let f = e[I];
      u && (u.vmult(f, p3), f = p3), f.x > l.x && (l.x = f.x), f.x < o.x && (o.x = f.x), f.y > l.y && (l.y = f.y), f.y < o.y && (o.y = f.y), f.z > l.z && (l.z = f.z), f.z < o.z && (o.z = f.z);
    }
    return t && (t.vadd(o, o), t.vadd(l, l)), i && (o.x -= i, o.y -= i, o.z -= i, l.x += i, l.y += i, l.z += i), this;
  }
  /**
   * Copy bounds from an AABB to this AABB
   * @param aabb Source to copy from
   * @return The this object, for chainability
   */
  copy(e) {
    return this.lowerBound.copy(e.lowerBound), this.upperBound.copy(e.upperBound), this;
  }
  /**
   * Clone an AABB
   */
  clone() {
    return new LC().copy(this);
  }
  /**
   * Extend this AABB so that it covers the given AABB too.
   */
  extend(e) {
    this.lowerBound.x = Math.min(this.lowerBound.x, e.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, e.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, e.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, e.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, e.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, e.upperBound.z);
  }
  /**
   * Returns true if the given AABB overlaps this AABB.
   */
  overlaps(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, o = e.upperBound, l = i.x <= n.x && n.x <= o.x || t.x <= o.x && o.x <= n.x, u = i.y <= n.y && n.y <= o.y || t.y <= o.y && o.y <= n.y, I = i.z <= n.z && n.z <= o.z || t.z <= o.z && o.z <= n.z;
    return l && u && I;
  }
  // Mostly for debugging
  volume() {
    const e = this.lowerBound, t = this.upperBound;
    return (t.x - e.x) * (t.y - e.y) * (t.z - e.z);
  }
  /**
   * Returns true if the given AABB is fully contained in this AABB.
   */
  contains(e) {
    const t = this.lowerBound, n = this.upperBound, i = e.lowerBound, o = e.upperBound;
    return t.x <= i.x && n.x >= o.x && t.y <= i.y && n.y >= o.y && t.z <= i.z && n.z >= o.z;
  }
  getCorners(e, t, n, i, o, l, u, I) {
    const f = this.lowerBound, h = this.upperBound;
    e.copy(f), t.set(h.x, f.y, f.z), n.set(h.x, h.y, f.z), i.set(f.x, h.y, h.z), o.set(h.x, f.y, h.z), l.set(f.x, h.y, f.z), u.set(f.x, f.y, h.z), I.copy(h);
  }
  /**
   * Get the representation of an AABB in another frame.
   * @return The "target" AABB object.
   */
  toLocalFrame(e, t) {
    const n = m3, i = n[0], o = n[1], l = n[2], u = n[3], I = n[4], f = n[5], h = n[6], v = n[7];
    this.getCorners(i, o, l, u, I, f, h, v);
    for (let b = 0; b !== 8; b++) {
      const S = n[b];
      e.pointToLocal(S, S);
    }
    return t.setFromPoints(n);
  }
  /**
   * Get the representation of an AABB in the global frame.
   * @return The "target" AABB object.
   */
  toWorldFrame(e, t) {
    const n = m3, i = n[0], o = n[1], l = n[2], u = n[3], I = n[4], f = n[5], h = n[6], v = n[7];
    this.getCorners(i, o, l, u, I, f, h, v);
    for (let b = 0; b !== 8; b++) {
      const S = n[b];
      e.pointToWorld(S, S);
    }
    return t.setFromPoints(n);
  }
  /**
   * Check if the AABB is hit by a ray.
   */
  overlapsRay(e) {
    const {
      direction: t,
      from: n
    } = e, i = 1 / t.x, o = 1 / t.y, l = 1 / t.z, u = (this.lowerBound.x - n.x) * i, I = (this.upperBound.x - n.x) * i, f = (this.lowerBound.y - n.y) * o, h = (this.upperBound.y - n.y) * o, v = (this.lowerBound.z - n.z) * l, b = (this.upperBound.z - n.z) * l, S = Math.max(Math.max(Math.min(u, I), Math.min(f, h)), Math.min(v, b)), R = Math.min(Math.min(Math.max(u, I), Math.max(f, h)), Math.max(v, b));
    return !(R < 0 || S > R);
  }
}
const p3 = new Me(), m3 = [new Me(), new Me(), new Me(), new Me(), new Me(), new Me(), new Me(), new Me()];
class zg {
  constructor(e, t, n, i) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = 0), i === void 0 && (i = 1), this.x = e, this.y = t, this.z = n, this.w = i;
  }
  /**
   * Set the value of the quaternion.
   */
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  /**
   * Convert to a readable format
   * @return "x,y,z,w"
   */
  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  /**
   * Convert to an Array
   * @return [x, y, z, w]
   */
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * Set the quaternion components given an axis and an angle in radians.
   */
  setFromAxisAngle(e, t) {
    const n = Math.sin(t * 0.5);
    return this.x = e.x * n, this.y = e.y * n, this.z = e.z * n, this.w = Math.cos(t * 0.5), this;
  }
  /**
   * Converts the quaternion to [ axis, angle ] representation.
   * @param targetAxis A vector object to reuse for storing the axis.
   * @return An array, first element is the axis and the second is the angle in radians.
   */
  toAxisAngle(e) {
    e === void 0 && (e = new Me()), this.normalize();
    const t = 2 * Math.acos(this.w), n = Math.sqrt(1 - this.w * this.w);
    return n < 1e-3 ? (e.x = this.x, e.y = this.y, e.z = this.z) : (e.x = this.x / n, e.y = this.y / n, e.z = this.z / n), [e, t];
  }
  /**
   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
   */
  setFromVectors(e, t) {
    if (e.isAntiparallelTo(t)) {
      const n = tte, i = nte;
      e.tangents(n, i), this.setFromAxisAngle(n, Math.PI);
    } else {
      const n = e.cross(t);
      this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(e.length() ** 2 * t.length() ** 2) + e.dot(t), this.normalize();
    }
    return this;
  }
  /**
   * Multiply the quaternion with an other quaternion.
   */
  mult(e, t) {
    t === void 0 && (t = new zg());
    const n = this.x, i = this.y, o = this.z, l = this.w, u = e.x, I = e.y, f = e.z, h = e.w;
    return t.x = n * h + l * u + i * f - o * I, t.y = i * h + l * I + o * u - n * f, t.z = o * h + l * f + n * I - i * u, t.w = l * h - n * u - i * I - o * f, t;
  }
  /**
   * Get the inverse quaternion rotation.
   */
  inverse(e) {
    e === void 0 && (e = new zg());
    const t = this.x, n = this.y, i = this.z, o = this.w;
    this.conjugate(e);
    const l = 1 / (t * t + n * n + i * i + o * o);
    return e.x *= l, e.y *= l, e.z *= l, e.w *= l, e;
  }
  /**
   * Get the quaternion conjugate
   */
  conjugate(e) {
    return e === void 0 && (e = new zg()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e.w = this.w, e;
  }
  /**
   * Normalize the quaternion. Note that this changes the values of the quaternion.
   */
  normalize() {
    let e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  /**
   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
   * @author unphased, https://github.com/unphased
   */
  normalizeFast() {
    const e = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  /**
   * Multiply the quaternion by a vector
   */
  vmult(e, t) {
    t === void 0 && (t = new Me());
    const n = e.x, i = e.y, o = e.z, l = this.x, u = this.y, I = this.z, f = this.w, h = f * n + u * o - I * i, v = f * i + I * n - l * o, b = f * o + l * i - u * n, S = -l * n - u * i - I * o;
    return t.x = h * f + S * -l + v * -I - b * -u, t.y = v * f + S * -u + b * -l - h * -I, t.z = b * f + S * -I + h * -u - v * -l, t;
  }
  /**
   * Copies value of source to this quaternion.
   * @return this
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  /**
   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
   * @param order Three-character string, defaults to "YZX"
   */
  toEuler(e, t) {
    t === void 0 && (t = "YZX");
    let n, i, o;
    const l = this.x, u = this.y, I = this.z, f = this.w;
    switch (t) {
      case "YZX":
        const h = l * u + I * f;
        if (h > 0.499 && (n = 2 * Math.atan2(l, f), i = Math.PI / 2, o = 0), h < -0.499 && (n = -2 * Math.atan2(l, f), i = -Math.PI / 2, o = 0), n === void 0) {
          const v = l * l, b = u * u, S = I * I;
          n = Math.atan2(2 * u * f - 2 * l * I, 1 - 2 * b - 2 * S), i = Math.asin(2 * h), o = Math.atan2(2 * l * f - 2 * u * I, 1 - 2 * v - 2 * S);
        }
        break;
      default:
        throw new Error(`Euler order ${t} not supported yet.`);
    }
    e.y = n, e.z = i, e.x = o;
  }
  /**
   * Set the quaternion components given Euler angle representation.
   *
   * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
   *
   * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
   */
  setFromEuler(e, t, n, i) {
    i === void 0 && (i = "XYZ");
    const o = Math.cos(e / 2), l = Math.cos(t / 2), u = Math.cos(n / 2), I = Math.sin(e / 2), f = Math.sin(t / 2), h = Math.sin(n / 2);
    return i === "XYZ" ? (this.x = I * l * u + o * f * h, this.y = o * f * u - I * l * h, this.z = o * l * h + I * f * u, this.w = o * l * u - I * f * h) : i === "YXZ" ? (this.x = I * l * u + o * f * h, this.y = o * f * u - I * l * h, this.z = o * l * h - I * f * u, this.w = o * l * u + I * f * h) : i === "ZXY" ? (this.x = I * l * u - o * f * h, this.y = o * f * u + I * l * h, this.z = o * l * h + I * f * u, this.w = o * l * u - I * f * h) : i === "ZYX" ? (this.x = I * l * u - o * f * h, this.y = o * f * u + I * l * h, this.z = o * l * h - I * f * u, this.w = o * l * u + I * f * h) : i === "YZX" ? (this.x = I * l * u + o * f * h, this.y = o * f * u + I * l * h, this.z = o * l * h - I * f * u, this.w = o * l * u - I * f * h) : i === "XZY" && (this.x = I * l * u - o * f * h, this.y = o * f * u - I * l * h, this.z = o * l * h + I * f * u, this.w = o * l * u + I * f * h), this;
  }
  clone() {
    return new zg(this.x, this.y, this.z, this.w);
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param toQuat second operand
   * @param t interpolation amount between the self quaternion and toQuat
   * @param target A quaternion to store the result in. If not provided, a new one will be created.
   * @returns {Quaternion} The "target" object
   */
  slerp(e, t, n) {
    n === void 0 && (n = new zg());
    const i = this.x, o = this.y, l = this.z, u = this.w;
    let I = e.x, f = e.y, h = e.z, v = e.w, b, S, R, W, x;
    return S = i * I + o * f + l * h + u * v, S < 0 && (S = -S, I = -I, f = -f, h = -h, v = -v), 1 - S > 1e-6 ? (b = Math.acos(S), R = Math.sin(b), W = Math.sin((1 - t) * b) / R, x = Math.sin(t * b) / R) : (W = 1 - t, x = t), n.x = W * i + x * I, n.y = W * o + x * f, n.z = W * l + x * h, n.w = W * u + x * v, n;
  }
  /**
   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
   */
  integrate(e, t, n, i) {
    i === void 0 && (i = new zg());
    const o = e.x * n.x, l = e.y * n.y, u = e.z * n.z, I = this.x, f = this.y, h = this.z, v = this.w, b = t * 0.5;
    return i.x += b * (o * v + l * h - u * f), i.y += b * (l * v + u * I - o * h), i.z += b * (u * v + o * f - l * I), i.w += b * (-o * I - l * f - u * h), i;
  }
}
const tte = new Me(), nte = new Me(), ite = {
  /** SPHERE */
  SPHERE: 1,
  /** PLANE */
  PLANE: 2,
  /** BOX */
  BOX: 4,
  /** COMPOUND */
  COMPOUND: 8,
  /** CONVEXPOLYHEDRON */
  CONVEXPOLYHEDRON: 16,
  /** HEIGHTFIELD */
  HEIGHTFIELD: 32,
  /** PARTICLE */
  PARTICLE: 64,
  /** CYLINDER */
  CYLINDER: 128,
  /** TRIMESH */
  TRIMESH: 256
};
class Ki {
  /**
   * Identifier of the Shape.
   */
  /**
   * The type of this shape. Must be set to an int > 0 by subclasses.
   */
  /**
   * The local bounding sphere radius of this shape.
   */
  /**
   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
   * @default true
   */
  /**
   * @default 1
   */
  /**
   * @default -1
   */
  /**
   * Optional material of the shape that regulates contact properties.
   */
  /**
   * The body to which the shape is added to.
   */
  /**
   * All the Shape types.
   */
  constructor(e) {
    e === void 0 && (e = {}), this.id = Ki.idCounter++, this.type = e.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = e.collisionResponse ? e.collisionResponse : !0, this.collisionFilterGroup = e.collisionFilterGroup !== void 0 ? e.collisionFilterGroup : 1, this.collisionFilterMask = e.collisionFilterMask !== void 0 ? e.collisionFilterMask : -1, this.material = e.material ? e.material : null, this.body = null;
  }
  /**
   * Computes the bounding sphere radius.
   * The result is stored in the property `.boundingSphereRadius`
   */
  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  /**
   * Get the volume of this shape
   */
  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  /**
   * Calculates the inertia in the local frame for this shape.
   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  calculateLocalInertia(e, t) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  /**
   * @todo use abstract for these kind of methods
   */
  calculateWorldAABB(e, t, n, i) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }
}
Ki.idCounter = 0;
Ki.types = ite;
class Xd {
  /**
   * position
   */
  /**
   * quaternion
   */
  constructor(e) {
    e === void 0 && (e = {}), this.position = new Me(), this.quaternion = new zg(), e.position && this.position.copy(e.position), e.quaternion && this.quaternion.copy(e.quaternion);
  }
  /**
   * Get a global point in local transform coordinates.
   */
  pointToLocal(e, t) {
    return Xd.pointToLocalFrame(this.position, this.quaternion, e, t);
  }
  /**
   * Get a local point in global transform coordinates.
   */
  pointToWorld(e, t) {
    return Xd.pointToWorldFrame(this.position, this.quaternion, e, t);
  }
  /**
   * vectorToWorldFrame
   */
  vectorToWorldFrame(e, t) {
    return t === void 0 && (t = new Me()), this.quaternion.vmult(e, t), t;
  }
  /**
   * pointToLocalFrame
   */
  static pointToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new Me()), n.vsub(e, i), t.conjugate(A3), A3.vmult(i, i), i;
  }
  /**
   * pointToWorldFrame
   */
  static pointToWorldFrame(e, t, n, i) {
    return i === void 0 && (i = new Me()), t.vmult(n, i), i.vadd(e, i), i;
  }
  /**
   * vectorToWorldFrame
   */
  static vectorToWorldFrame(e, t, n) {
    return n === void 0 && (n = new Me()), e.vmult(t, n), n;
  }
  /**
   * vectorToLocalFrame
   */
  static vectorToLocalFrame(e, t, n, i) {
    return i === void 0 && (i = new Me()), t.w *= -1, t.vmult(n, i), t.w *= -1, i;
  }
}
const A3 = new zg();
new Me();
new Me();
new Me();
new Me();
new Me(), new Me(), new Me(), new Me(), new Me(), new Me(), new Me(), new Me();
new Me();
new zg();
new LC();
new Wm();
new Wm();
new Wm();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new zg();
new Me();
new Me();
new Me();
new Me();
class DH {
  /**
   * rayFromWorld
   */
  /**
   * rayToWorld
   */
  /**
   * hitNormalWorld
   */
  /**
   * hitPointWorld
   */
  /**
   * hasHit
   */
  /**
   * shape
   */
  /**
   * body
   */
  /**
   * The index of the hit triangle, if the hit shape was a trimesh
   */
  /**
   * Distance to the hit. Will be set to -1 if there was no hit
   */
  /**
   * If the ray should stop traversing the bodies
   */
  constructor() {
    this.rayFromWorld = new Me(), this.rayToWorld = new Me(), this.hitNormalWorld = new Me(), this.hitPointWorld = new Me(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  /**
   * Reset all result data.
   */
  reset() {
    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  /**
   * abort
   */
  abort() {
    this.shouldStop = !0;
  }
  /**
   * Set result data.
   */
  set(e, t, n, i, o, l, u) {
    this.rayFromWorld.copy(e), this.rayToWorld.copy(t), this.hitNormalWorld.copy(n), this.hitPointWorld.copy(i), this.shape = o, this.body = l, this.distance = u;
  }
}
let vL, yL, bL, GL, BL, SL, ZL;
const CY = {
  /** CLOSEST */
  CLOSEST: 1,
  /** ANY */
  ANY: 2,
  /** ALL */
  ALL: 4
};
vL = Ki.types.SPHERE;
yL = Ki.types.PLANE;
bL = Ki.types.BOX;
GL = Ki.types.CYLINDER;
BL = Ki.types.CONVEXPOLYHEDRON;
SL = Ki.types.HEIGHTFIELD;
ZL = Ki.types.TRIMESH;
class tg {
  /**
   * from
   */
  /**
   * to
   */
  /**
   * direction
   */
  /**
   * The precision of the ray. Used when checking parallelity etc.
   * @default 0.0001
   */
  /**
   * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
   * @default true
   */
  /**
   * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
   * @default false
   */
  /**
   * collisionFilterMask
   * @default -1
   */
  /**
   * collisionFilterGroup
   * @default -1
   */
  /**
   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
   * @default RAY.ANY
   */
  /**
   * Current result object.
   */
  /**
   * Will be set to `true` during intersectWorld() if the ray hit anything.
   */
  /**
   * User-provided result callback. Will be used if mode is Ray.ALL.
   */
  /**
   * CLOSEST
   */
  /**
   * ANY
   */
  /**
   * ALL
   */
  get [vL]() {
    return this._intersectSphere;
  }
  get [yL]() {
    return this._intersectPlane;
  }
  get [bL]() {
    return this._intersectBox;
  }
  get [GL]() {
    return this._intersectConvex;
  }
  get [BL]() {
    return this._intersectConvex;
  }
  get [SL]() {
    return this._intersectHeightfield;
  }
  get [ZL]() {
    return this._intersectTrimesh;
  }
  constructor(e, t) {
    e === void 0 && (e = new Me()), t === void 0 && (t = new Me()), this.from = e.clone(), this.to = t.clone(), this.direction = new Me(), this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = tg.ANY, this.result = new DH(), this.hasHit = !1, this.callback = (n) => {
    };
  }
  /**
   * Do itersection against all bodies in the given World.
   * @return True if the ray hit anything, otherwise false.
   */
  intersectWorld(e, t) {
    return this.mode = t.mode || tg.ANY, this.result = t.result || new DH(), this.skipBackfaces = !!t.skipBackfaces, this.collisionFilterMask = typeof t.collisionFilterMask < "u" ? t.collisionFilterMask : -1, this.collisionFilterGroup = typeof t.collisionFilterGroup < "u" ? t.collisionFilterGroup : -1, this.checkCollisionResponse = typeof t.checkCollisionResponse < "u" ? t.checkCollisionResponse : !0, t.from && this.from.copy(t.from), t.to && this.to.copy(t.to), this.callback = t.callback || (() => {
    }), this.hasHit = !1, this.result.reset(), this.updateDirection(), this.getAABB(v3), $M.length = 0, e.broadphase.aabbQuery(e, v3, $M), this.intersectBodies($M), this.hasHit;
  }
  /**
   * Shoot a ray at a body, get back information about the hit.
   * @deprecated @param result set the result property of the Ray instead.
   */
  intersectBody(e, t) {
    t && (this.result = t, this.updateDirection());
    const n = this.checkCollisionResponse;
    if (n && !e.collisionResponse || !(this.collisionFilterGroup & e.collisionFilterMask) || !(e.collisionFilterGroup & this.collisionFilterMask))
      return;
    const i = rte, o = ate;
    for (let l = 0, u = e.shapes.length; l < u; l++) {
      const I = e.shapes[l];
      if (!(n && !I.collisionResponse) && (e.quaternion.mult(e.shapeOrientations[l], o), e.quaternion.vmult(e.shapeOffsets[l], i), i.vadd(e.position, i), this.intersectShape(I, o, i, e), this.result.shouldStop))
        break;
    }
  }
  /**
   * Shoot a ray at an array bodies, get back information about the hit.
   * @param bodies An array of Body objects.
   * @deprecated @param result set the result property of the Ray instead.
   *
   */
  intersectBodies(e, t) {
    t && (this.result = t, this.updateDirection());
    for (let n = 0, i = e.length; !this.result.shouldStop && n < i; n++)
      this.intersectBody(e[n]);
  }
  /**
   * Updates the direction vector.
   */
  updateDirection() {
    this.to.vsub(this.from, this.direction), this.direction.normalize();
  }
  intersectShape(e, t, n, i) {
    const o = this.from;
    if (Ate(o, this.direction, n) > e.boundingSphereRadius)
      return;
    const u = this[e.type];
    u && u.call(this, e, t, n, i, e);
  }
  _intersectBox(e, t, n, i, o) {
    return this._intersectConvex(e.convexPolyhedronRepresentation, t, n, i, o);
  }
  _intersectPlane(e, t, n, i, o) {
    const l = this.from, u = this.to, I = this.direction, f = new Me(0, 0, 1);
    t.vmult(f, f);
    const h = new Me();
    l.vsub(n, h);
    const v = h.dot(f);
    u.vsub(n, h);
    const b = h.dot(f);
    if (v * b > 0 || l.distanceTo(u) < v)
      return;
    const S = f.dot(I);
    if (Math.abs(S) < this.precision)
      return;
    const R = new Me(), W = new Me(), x = new Me();
    l.vsub(n, R);
    const M = -f.dot(R) / S;
    I.scale(M, W), l.vadd(W, x), this.reportIntersection(f, x, o, i, -1);
  }
  /**
   * Get the world AABB of the ray.
   */
  getAABB(e) {
    const {
      lowerBound: t,
      upperBound: n
    } = e, i = this.to, o = this.from;
    t.x = Math.min(i.x, o.x), t.y = Math.min(i.y, o.y), t.z = Math.min(i.z, o.z), n.x = Math.max(i.x, o.x), n.y = Math.max(i.y, o.y), n.z = Math.max(i.z, o.z);
  }
  _intersectHeightfield(e, t, n, i, o) {
    e.data, e.elementSize;
    const l = ote;
    l.from.copy(this.from), l.to.copy(this.to), Xd.pointToLocalFrame(n, t, l.from, l.from), Xd.pointToLocalFrame(n, t, l.to, l.to), l.updateDirection();
    const u = ste;
    let I, f, h, v;
    I = f = 0, h = v = e.data.length - 1;
    const b = new LC();
    l.getAABB(b), e.getIndexOfPosition(b.lowerBound.x, b.lowerBound.y, u, !0), I = Math.max(I, u[0]), f = Math.max(f, u[1]), e.getIndexOfPosition(b.upperBound.x, b.upperBound.y, u, !0), h = Math.min(h, u[0] + 1), v = Math.min(v, u[1] + 1);
    for (let S = I; S < h; S++)
      for (let R = f; R < v; R++) {
        if (this.result.shouldStop)
          return;
        if (e.getAabbAtIndex(S, R, b), !!b.overlapsRay(l)) {
          if (e.getConvexTrianglePillar(S, R, !1), Xd.pointToWorldFrame(n, t, e.pillarOffset, _1), this._intersectConvex(e.pillarConvex, t, _1, i, o, y3), this.result.shouldStop)
            return;
          e.getConvexTrianglePillar(S, R, !0), Xd.pointToWorldFrame(n, t, e.pillarOffset, _1), this._intersectConvex(e.pillarConvex, t, _1, i, o, y3);
        }
      }
  }
  _intersectSphere(e, t, n, i, o) {
    const l = this.from, u = this.to, I = e.radius, f = (u.x - l.x) ** 2 + (u.y - l.y) ** 2 + (u.z - l.z) ** 2, h = 2 * ((u.x - l.x) * (l.x - n.x) + (u.y - l.y) * (l.y - n.y) + (u.z - l.z) * (l.z - n.z)), v = (l.x - n.x) ** 2 + (l.y - n.y) ** 2 + (l.z - n.z) ** 2 - I ** 2, b = h ** 2 - 4 * f * v, S = lte, R = ute;
    if (!(b < 0))
      if (b === 0)
        l.lerp(u, b, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1);
      else {
        const W = (-h - Math.sqrt(b)) / (2 * f), x = (-h + Math.sqrt(b)) / (2 * f);
        if (W >= 0 && W <= 1 && (l.lerp(u, W, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1)), this.result.shouldStop)
          return;
        x >= 0 && x <= 1 && (l.lerp(u, x, S), S.vsub(n, R), R.normalize(), this.reportIntersection(R, S, o, i, -1));
      }
  }
  _intersectConvex(e, t, n, i, o, l) {
    const u = cte, I = b3, f = l && l.faceList || null, h = e.faces, v = e.vertices, b = e.faceNormals, S = this.direction, R = this.from, W = this.to, x = R.distanceTo(W), M = f ? f.length : h.length, T = this.result;
    for (let E = 0; !T.shouldStop && E < M; E++) {
      const _ = f ? f[E] : E, P = h[_], U = b[_], q = t, k = n;
      I.copy(v[P[0]]), q.vmult(I, I), I.vadd(k, I), I.vsub(R, I), q.vmult(U, u);
      const O = S.dot(u);
      if (Math.abs(O) < this.precision)
        continue;
      const J = u.dot(I) / O;
      if (!(J < 0)) {
        S.scale(J, Nd), Nd.vadd(R, Nd), Xh.copy(v[P[0]]), q.vmult(Xh, Xh), k.vadd(Xh, Xh);
        for (let te = 1; !T.shouldStop && te < P.length - 1; te++) {
          jf.copy(v[P[te]]), qf.copy(v[P[te + 1]]), q.vmult(jf, jf), q.vmult(qf, qf), k.vadd(jf, jf), k.vadd(qf, qf);
          const fe = Nd.distanceTo(R);
          !(tg.pointInTriangle(Nd, Xh, jf, qf) || tg.pointInTriangle(Nd, jf, Xh, qf)) || fe > x || this.reportIntersection(u, Nd, o, i, _);
        }
      }
    }
  }
  /**
   * @todo Optimize by transforming the world to local space first.
   * @todo Use Octree lookup
   */
  _intersectTrimesh(e, t, n, i, o, l) {
    const u = gte, I = pte, f = mte, h = b3, v = dte, b = Ite, S = Cte, R = fte, W = hte, x = e.indices;
    e.vertices;
    const M = this.from, T = this.to, E = this.direction;
    f.position.copy(n), f.quaternion.copy(t), Xd.vectorToLocalFrame(n, t, E, v), Xd.pointToLocalFrame(n, t, M, b), Xd.pointToLocalFrame(n, t, T, S), S.x *= e.scale.x, S.y *= e.scale.y, S.z *= e.scale.z, b.x *= e.scale.x, b.y *= e.scale.y, b.z *= e.scale.z, S.vsub(b, v), v.normalize();
    const _ = b.distanceSquared(S);
    e.tree.rayQuery(this, f, I);
    for (let P = 0, U = I.length; !this.result.shouldStop && P !== U; P++) {
      const q = I[P];
      e.getNormal(q, u), e.getVertex(x[q * 3], Xh), Xh.vsub(b, h);
      const k = v.dot(u), O = u.dot(h) / k;
      if (O < 0)
        continue;
      v.scale(O, Nd), Nd.vadd(b, Nd), e.getVertex(x[q * 3 + 1], jf), e.getVertex(x[q * 3 + 2], qf);
      const J = Nd.distanceSquared(b);
      !(tg.pointInTriangle(Nd, jf, Xh, qf) || tg.pointInTriangle(Nd, Xh, jf, qf)) || J > _ || (Xd.vectorToWorldFrame(t, u, W), Xd.pointToWorldFrame(n, t, Nd, R), this.reportIntersection(W, R, o, i, q));
    }
    I.length = 0;
  }
  /**
   * @return True if the intersections should continue
   */
  reportIntersection(e, t, n, i, o) {
    const l = this.from, u = this.to, I = l.distanceTo(t), f = this.result;
    if (!(this.skipBackfaces && e.dot(this.direction) > 0))
      switch (f.hitFaceIndex = typeof o < "u" ? o : -1, this.mode) {
        case tg.ALL:
          this.hasHit = !0, f.set(l, u, e, t, n, i, I), f.hasHit = !0, this.callback(f);
          break;
        case tg.CLOSEST:
          (I < f.distance || !f.hasHit) && (this.hasHit = !0, f.hasHit = !0, f.set(l, u, e, t, n, i, I));
          break;
        case tg.ANY:
          this.hasHit = !0, f.hasHit = !0, f.set(l, u, e, t, n, i, I), f.shouldStop = !0;
          break;
      }
  }
  /**
   * As per "Barycentric Technique" as named
   * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
   */
  static pointInTriangle(e, t, n, i) {
    i.vsub(t, tb), n.vsub(t, NZ), e.vsub(t, eH);
    const o = tb.dot(tb), l = tb.dot(NZ), u = tb.dot(eH), I = NZ.dot(NZ), f = NZ.dot(eH);
    let h, v;
    return (h = I * u - l * f) >= 0 && (v = o * f - l * u) >= 0 && h + v < o * I - l * l;
  }
}
tg.CLOSEST = CY.CLOSEST;
tg.ANY = CY.ANY;
tg.ALL = CY.ALL;
const v3 = new LC(), $M = [], NZ = new Me(), eH = new Me(), rte = new Me(), ate = new zg(), Nd = new Me(), Xh = new Me(), jf = new Me(), qf = new Me();
new Me();
new DH();
const y3 = {
  faceList: [0]
}, _1 = new Me(), ote = new tg(), ste = [], lte = new Me(), ute = new Me(), cte = new Me();
new Me();
new Me();
const b3 = new Me(), gte = new Me(), dte = new Me(), Ite = new Me(), Cte = new Me(), hte = new Me(), fte = new Me();
new LC();
const pte = [], mte = new Xd(), tb = new Me(), z1 = new Me();
function Ate(a, e, t) {
  t.vsub(a, tb);
  const n = tb.dot(e);
  return e.scale(n, z1), z1.vadd(a, z1), t.distanceTo(z1);
}
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new tg();
new Me();
new Me();
new Me();
new Me(1, 0, 0), new Me(0, 1, 0), new Me(0, 0, 1);
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new LC();
new Me();
new LC();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new LC();
new Me();
new Xd();
new LC();
Ki.types.SPHERE, Ki.types.SPHERE | Ki.types.PLANE, Ki.types.BOX | Ki.types.BOX, Ki.types.SPHERE | Ki.types.BOX, Ki.types.PLANE | Ki.types.BOX, Ki.types.CONVEXPOLYHEDRON, Ki.types.SPHERE | Ki.types.CONVEXPOLYHEDRON, Ki.types.PLANE | Ki.types.CONVEXPOLYHEDRON, Ki.types.BOX | Ki.types.CONVEXPOLYHEDRON, Ki.types.SPHERE | Ki.types.HEIGHTFIELD, Ki.types.BOX | Ki.types.HEIGHTFIELD, Ki.types.CONVEXPOLYHEDRON | Ki.types.HEIGHTFIELD, Ki.types.PARTICLE | Ki.types.SPHERE, Ki.types.PLANE | Ki.types.PARTICLE, Ki.types.BOX | Ki.types.PARTICLE, Ki.types.PARTICLE | Ki.types.CONVEXPOLYHEDRON, Ki.types.CYLINDER, Ki.types.SPHERE | Ki.types.CYLINDER, Ki.types.PLANE | Ki.types.CYLINDER, Ki.types.BOX | Ki.types.CYLINDER, Ki.types.CONVEXPOLYHEDRON | Ki.types.CYLINDER, Ki.types.HEIGHTFIELD | Ki.types.CYLINDER, Ki.types.PARTICLE | Ki.types.CYLINDER, Ki.types.SPHERE | Ki.types.TRIMESH, Ki.types.PLANE | Ki.types.TRIMESH;
new Me();
new Me();
new Me();
new Me();
new Me();
new zg();
new zg();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new LC();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me(), new Me(), new Me(), new Me(), new Me(), new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new zg();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new Me();
new LC();
new tg();
const MZ = globalThis.performance || {};
if (!MZ.now) {
  let a = Date.now();
  MZ.timing && MZ.timing.navigationStart && (a = MZ.timing.navigationStart), MZ.now = () => Date.now() - a;
}
new Me();
const vte = /* @__PURE__ */ xe.createContext(null), yte = () => xe.useContext(vte), wL = /* @__PURE__ */ xe.createContext(null), bte = () => {
  const a = xe.useContext(wL);
  if (!a) throw new Error("Physics context not found. @react-three/cannon & components can only be used within a Physics provider");
  return a;
};
new Ze(1, 1, 1);
new Ze();
new tr();
const G3 = new Aa();
function Gte(a) {
  const e = xe.useRef(null);
  return a && typeof a != "function" ? a : e;
}
function B3(a) {
  return a.charAt(0).toUpperCase() + a.slice(1);
}
function bc(a, e) {
  const t = e === void 0 ? "" : `/${e}`;
  return typeof a == "function" ? null : a && a.current && `${a.current.uuid}${t}`;
}
const Bte = new Kd(), Ste = new zu(), Zte = (a) => (e) => a(Bte.setFromQuaternion(Ste.fromArray(e)).toArray());
let RL = 0;
function tH(a, e, t, n, i, o) {
  return o === void 0 && (o = "bodies"), (l) => {
    const u = RL++;
    t[u] = {
      [n]: l
    };
    const I = bc(a, i);
    return I && e.subscribe({
      props: {
        id: u,
        target: o,
        type: n
      },
      uuid: I
    }), () => {
      delete t[u], e.unsubscribe({
        props: u
      });
    };
  };
}
function S3(a, e) {
  let {
    position: t = [0, 0, 0],
    rotation: n = [0, 0, 0],
    userData: i = {}
  } = e;
  a.userData = i, a.position.set(...t), a.rotation.set(...n), a.updateMatrix();
}
function Z3(a, e, t) {
  let {
    onCollide: n,
    onCollideBegin: i,
    onCollideEnd: o
  } = e;
  a[t] = {
    collide: n,
    collideBegin: i,
    collideEnd: o
  };
}
function xL(a, e, t, n, i) {
  n === void 0 && (n = null), i === void 0 && (i = []);
  const o = Gte(n), {
    events: l,
    refs: u,
    scaleOverrides: I,
    subscriptions: f,
    worker: h
  } = bte(), v = yte();
  xe.useLayoutEffect(() => {
    o.current || (o.current = new Aa());
    const S = o.current, R = h, W = S instanceof OG ? (S.instanceMatrix.setUsage(xz), S.count) : 1, x = S instanceof OG ? new Array(W).fill(0).map((T, E) => `${S.uuid}/${E}`) : [S.uuid], M = S instanceof OG ? x.map((T, E) => {
      const _ = e(E);
      return S3(G3, _), S.setMatrixAt(E, G3.matrix), S.instanceMatrix.needsUpdate = !0, u[T] = S, v?.add(T, _, a), Z3(l, _, T), {
        ..._,
        args: t(_.args)
      };
    }) : x.map((T, E) => {
      const _ = e(E);
      return S3(S, _), u[T] = S, v?.add(T, _, a), Z3(l, _, T), {
        ..._,
        args: t(_.args)
      };
    });
    return R.addBodies({
      props: M.map((T) => {
        let {
          onCollide: E,
          onCollideBegin: _,
          onCollideEnd: P,
          ...U
        } = T;
        return {
          onCollide: !!E,
          ...U
        };
      }),
      type: a,
      uuid: x
    }), () => {
      x.forEach((T) => {
        delete u[T], v?.remove(T), delete l[T];
      }), R.removeBodies({
        uuid: x
      });
    };
  }, i);
  const b = xe.useMemo(() => {
    const S = (E, _) => {
      const P = `set${B3(E)}`;
      return {
        set: (U) => {
          const q = bc(o, _);
          q && h[P]({
            props: U,
            uuid: q
          });
        },
        subscribe: tH(o, h, f, E, _)
      };
    }, R = (E) => ({
      copy: (P) => {
        let {
          w: U,
          x: q,
          y: k,
          z: O
        } = P;
        const J = bc(o, E);
        J && h.setQuaternion({
          props: [q, k, O, U],
          uuid: J
        });
      },
      set: (P, U, q, k) => {
        const O = bc(o, E);
        O && h.setQuaternion({
          props: [P, U, q, k],
          uuid: O
        });
      },
      subscribe: tH(o, h, f, "quaternion", E)
    }), W = (E) => ({
      copy: (_) => {
        let {
          x: P,
          y: U,
          z: q
        } = _;
        const k = bc(o, E);
        k && h.setRotation({
          props: [P, U, q],
          uuid: k
        });
      },
      set: (_, P, U) => {
        const q = bc(o, E);
        q && h.setRotation({
          props: [_, P, U],
          uuid: q
        });
      },
      subscribe: (_) => {
        const P = RL++, U = "bodies", q = "quaternion", k = bc(o, E);
        return f[P] = {
          [q]: Zte(_)
        }, k && h.subscribe({
          props: {
            id: P,
            target: U,
            type: q
          },
          uuid: k
        }), () => {
          delete f[P], h.unsubscribe({
            props: P
          });
        };
      }
    }), x = (E, _) => {
      const P = `set${B3(E)}`;
      return {
        copy: (U) => {
          let {
            x: q,
            y: k,
            z: O
          } = U;
          const J = bc(o, _);
          J && h[P]({
            props: [q, k, O],
            uuid: J
          });
        },
        set: (U, q, k) => {
          const O = bc(o, _);
          O && h[P]({
            props: [U, q, k],
            uuid: O
          });
        },
        subscribe: tH(o, h, f, E, _)
      };
    };
    function M(E) {
      return {
        allowSleep: S("allowSleep", E),
        angularDamping: S("angularDamping", E),
        angularFactor: x("angularFactor", E),
        angularVelocity: x("angularVelocity", E),
        applyForce(_, P) {
          const U = bc(o, E);
          U && h.applyForce({
            props: [_, P],
            uuid: U
          });
        },
        applyImpulse(_, P) {
          const U = bc(o, E);
          U && h.applyImpulse({
            props: [_, P],
            uuid: U
          });
        },
        applyLocalForce(_, P) {
          const U = bc(o, E);
          U && h.applyLocalForce({
            props: [_, P],
            uuid: U
          });
        },
        applyLocalImpulse(_, P) {
          const U = bc(o, E);
          U && h.applyLocalImpulse({
            props: [_, P],
            uuid: U
          });
        },
        applyTorque(_) {
          const P = bc(o, E);
          P && h.applyTorque({
            props: [_],
            uuid: P
          });
        },
        collisionFilterGroup: S("collisionFilterGroup", E),
        collisionFilterMask: S("collisionFilterMask", E),
        collisionResponse: S("collisionResponse", E),
        fixedRotation: S("fixedRotation", E),
        isTrigger: S("isTrigger", E),
        linearDamping: S("linearDamping", E),
        linearFactor: x("linearFactor", E),
        mass: S("mass", E),
        material: S("material", E),
        position: x("position", E),
        quaternion: R(E),
        rotation: W(E),
        scaleOverride(_) {
          const P = bc(o, E);
          P && (I[P] = new Ze(..._));
        },
        sleep() {
          const _ = bc(o, E);
          _ && h.sleep({
            uuid: _
          });
        },
        sleepSpeedLimit: S("sleepSpeedLimit", E),
        sleepTimeLimit: S("sleepTimeLimit", E),
        userData: S("userData", E),
        velocity: x("velocity", E),
        wakeUp() {
          const _ = bc(o, E);
          _ && h.wakeUp({
            uuid: _
          });
        }
      };
    }
    const T = {};
    return {
      ...M(void 0),
      at: (E) => T[E] || (T[E] = M(E))
    };
  }, []);
  return [o, b];
}
function WL(a, e, t) {
  return xL("Plane", a, () => [], e, t);
}
function wte(a, e, t) {
  const n = [1, 1, 1];
  return xL("Box", a, function(i) {
    return i === void 0 && (i = n), i;
  }, e, t);
}
const Rte = new Ze(), xte = new Ze(1, 1, 1), Wte = new zu(), K1 = new tr();
function w3(a, e, t, n, i) {
  return n === void 0 && (n = xte), a !== void 0 ? (K1.compose(Rte.fromArray(e, a * 3), Wte.fromArray(t, a * 4), n), i && (i.matrixAutoUpdate = !1, i.matrix.copy(K1)), K1) : K1.identity();
}
const Vte = () => {
  const a = [];
  return (e) => a.includes(e) ? !1 : !!a.push(e);
};
function Nte(a) {
  let {
    allowSleep: e = !1,
    axisIndex: t = 0,
    broadphase: n = "Naive",
    children: i,
    defaultContactMaterial: o = {
      contactEquationStiffness: 1e6
    },
    frictionGravity: l = null,
    gravity: u = [0, -9.81, 0],
    isPaused: I = !1,
    iterations: f = 5,
    maxSubSteps: h = 10,
    quatNormalizeFast: v = !1,
    quatNormalizeSkip: b = 0,
    shouldInvalidate: S = !0,
    size: R = 1e3,
    solver: W = "GS",
    stepSize: x = 1 / 60,
    tolerance: M = 1e-3
  } = a;
  const {
    invalidate: T
  } = Tg(), [{
    bodies: E,
    events: _,
    refs: P,
    scaleOverrides: U,
    subscriptions: q,
    worker: k
  }] = xe.useState(() => ({
    bodies: {},
    events: {},
    refs: {},
    scaleOverrides: {},
    subscriptions: {},
    worker: new xee({
      allowSleep: e,
      axisIndex: t,
      broadphase: n,
      defaultContactMaterial: o,
      frictionGravity: l,
      gravity: u,
      iterations: f,
      quatNormalizeFast: v,
      quatNormalizeSkip: b,
      size: R,
      solver: W,
      tolerance: M
    })
  }));
  let O = 0;
  const J = xe.useCallback((je, ee) => {
    I || (O += ee, k.step({
      maxSubSteps: h,
      stepSize: x,
      timeSinceLastCalled: O
    }), O = 0);
  }, [I, h, x]), te = (je) => {
    var ee;
    let {
      body: Ce,
      contact: {
        bi: be,
        bj: le,
        ...Ye
      },
      target: $e,
      ...ke
    } = je;
    const ot = (ee = _[$e]) == null ? void 0 : ee.collide;
    ot && ot({
      body: P[Ce],
      contact: {
        bi: P[be],
        bj: P[le],
        ...Ye
      },
      target: P[$e],
      ...ke
    });
  }, fe = (je) => {
    var ee, Ce;
    let {
      bodyA: be,
      bodyB: le
    } = je;
    const Ye = (ee = _[be]) == null ? void 0 : ee.collideBegin;
    Ye && Ye({
      body: P[le],
      op: "event",
      target: P[be],
      type: "collideBegin"
    });
    const $e = (Ce = _[le]) == null ? void 0 : Ce.collideBegin;
    $e && $e({
      body: P[be],
      op: "event",
      target: P[le],
      type: "collideBegin"
    });
  }, pe = (je) => {
    var ee, Ce;
    let {
      bodyA: be,
      bodyB: le
    } = je;
    const Ye = (ee = _[be]) == null ? void 0 : ee.collideEnd;
    Ye && Ye({
      body: P[le],
      op: "event",
      target: P[be],
      type: "collideEnd"
    });
    const $e = (Ce = _[le]) == null ? void 0 : Ce.collideEnd;
    $e && $e({
      body: P[be],
      op: "event",
      target: P[le],
      type: "collideEnd"
    });
  }, Ae = (je) => {
    let {
      active: ee,
      bodies: Ce = [],
      observations: be,
      positions: le,
      quaternions: Ye
    } = je;
    for (let $e = 0; $e < Ce.length; $e++)
      E[Ce[$e]] = $e;
    if (be.forEach(($e) => {
      let [ke, ot, wt] = $e;
      const ln = (q[ke] || {})[wt];
      ln && ln(ot);
    }), !!ee) {
      for (const $e of Object.values(P).filter(Vte()))
        if ($e instanceof OG)
          for (let ke = 0; ke < $e.count; ke++) {
            const ot = `${$e.uuid}/${ke}`, wt = E[ot];
            wt !== void 0 && ($e.setMatrixAt(ke, w3(wt, le, Ye, U[ot])), $e.instanceMatrix.needsUpdate = !0);
          }
        else {
          const ke = U[$e.uuid] || $e.scale;
          w3(E[$e.uuid], le, Ye, ke, $e);
        }
      S && T();
    }
  }, Te = (je) => {
    var ee;
    let {
      body: Ce,
      ray: {
        uuid: be,
        ...le
      },
      ...Ye
    } = je;
    const $e = (ee = _[be]) == null ? void 0 : ee.rayhit;
    $e && $e({
      body: Ce ? P[Ce] : null,
      ray: {
        uuid: be,
        ...le
      },
      ...Ye
    });
  };
  KW(J), xe.useEffect(() => (k.connect(), k.init(), k.on("collide", te), k.on("collideBegin", fe), k.on("collideEnd", pe), k.on("frame", Ae), k.on("rayhit", Te), () => {
    k.terminate(), k.removeAllListeners();
  }), []), xe.useEffect(() => {
    k.axisIndex = t;
  }, [t]), xe.useEffect(() => {
    k.broadphase = n;
  }, [n]), xe.useEffect(() => {
    k.gravity = u;
  }, [u]), xe.useEffect(() => {
    k.iterations = f;
  }, [f]), xe.useEffect(() => {
    k.tolerance = M;
  }, [M]);
  const Ke = xe.useMemo(() => ({
    bodies: E,
    events: _,
    refs: P,
    scaleOverrides: U,
    subscriptions: q,
    worker: k
  }), [E, _, P, q, k]);
  return /* @__PURE__ */ ze.jsx(wL.Provider, {
    value: Ke,
    children: i
  });
}
const VL = {
  [Og.DEFAULT]: "#22303c",
  [Og.DARK]: "#0e0d0c",
  [Og.LIGHT]: "#a9e5e0"
}, Mte = {
  [Og.DEFAULT]: "#b26c41",
  [Og.DARK]: "#30d5c8",
  [Og.LIGHT]: "#588d67"
}, Hte = {
  [Og.DEFAULT]: "#efcb2d",
  [Og.DARK]: "#bac8c6",
  [Og.LIGHT]: "#494544"
};
function bm(a) {
  if (a === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return a;
}
function NL(a, e) {
  a.prototype = Object.create(e.prototype), a.prototype.constructor = a, a.__proto__ = e;
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var KI = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, rB = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, hY, sg, hs, YC = 1e8, Jo = 1 / YC, UH = Math.PI * 2, Xte = UH / 4, Yte = 0, ML = Math.sqrt, Fte = Math.cos, Ete = Math.sin, Ku = function(e) {
  return typeof e == "string";
}, il = function(e) {
  return typeof e == "function";
}, Ym = function(e) {
  return typeof e == "number";
}, fY = function(e) {
  return typeof e > "u";
}, gp = function(e) {
  return typeof e == "object";
}, Fd = function(e) {
  return e !== !1;
}, pY = function() {
  return typeof window < "u";
}, L1 = function(e) {
  return il(e) || Ku(e);
}, HL = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, lg = Array.isArray, OH = /(?:-?\.?\d|\.)+/gi, XL = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, LG = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, nH = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, YL = /[+-]=-?[.\d]+/, FL = /[^,'"\[\]\s]+/gi, Tte = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Hs, $f, PH, mY, LI = {}, K2 = {}, EL, TL = function(e) {
  return (K2 = Gb(e, LI)) && Ld;
}, AY = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, Ww = function(e, t) {
  return !t && console.warn(e);
}, _L = function(e, t) {
  return e && (LI[e] = t) && K2 && (K2[e] = t) || LI;
}, Vw = function() {
  return 0;
}, _te = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, $1 = {
  suppressEvents: !0,
  kill: !1
}, zte = {
  suppressEvents: !0
}, vY = {}, JA = [], JH = {}, zL, FI = {}, iH = {}, R3 = 30, e2 = [], yY = "", bY = function(e) {
  var t = e[0], n, i;
  if (gp(t) || il(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
    for (i = e2.length; i-- && !e2[i].targetTest(t); )
      ;
    n = e2[i];
  }
  for (i = e.length; i--; )
    e[i] && (e[i]._gsap || (e[i]._gsap = new g9(e[i], n))) || e.splice(i, 1);
  return e;
}, Cb = function(e) {
  return e._gsap || bY(FC(e))[0]._gsap;
}, KL = function(e, t, n) {
  return (n = e[t]) && il(n) ? e[t]() : fY(n) && e.getAttribute && e.getAttribute(t) || n;
}, Ed = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, bl = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, Tu = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, JG = function(e, t) {
  var n = t.charAt(0), i = parseFloat(t.substr(2));
  return e = parseFloat(e), n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i;
}, Kte = function(e, t) {
  for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; )
    ;
  return i < n;
}, L2 = function() {
  var e = JA.length, t = JA.slice(0), n, i;
  for (JH = {}, JA.length = 0, n = 0; n < e; n++)
    i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
}, LL = function(e, t, n, i) {
  JA.length && !sg && L2(), e.render(t, n, sg && t < 0 && (e._initted || e._startAt)), JA.length && !sg && L2();
}, kL = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(FL).length < 2 ? t : Ku(e) ? e.trim() : e;
}, DL = function(e) {
  return e;
}, TC = function(e, t) {
  for (var n in t)
    n in e || (e[n] = t[n]);
  return e;
}, Lte = function(e) {
  return function(t, n) {
    for (var i in n)
      i in t || i === "duration" && e || i === "ease" || (t[i] = n[i]);
  };
}, Gb = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, x3 = function a(e, t) {
  for (var n in t)
    n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = gp(t[n]) ? a(e[n] || (e[n] = {}), t[n]) : t[n]);
  return e;
}, k2 = function(e, t) {
  var n = {}, i;
  for (i in e)
    i in t || (n[i] = e[i]);
  return n;
}, ew = function(e) {
  var t = e.parent || Hs, n = e.keyframes ? Lte(lg(e.keyframes)) : TC;
  if (Fd(e.inherit))
    for (; t; )
      n(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, kte = function(e, t) {
  for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; )
    ;
  return n < 0;
}, UL = function(e, t, n, i, o) {
  var l = e[i], u;
  if (o)
    for (u = t[o]; l && l[o] > u; )
      l = l._prev;
  return l ? (t._next = l._next, l._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = l, t.parent = t._dp = e, t;
}, kW = function(e, t, n, i) {
  n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
  var o = t._prev, l = t._next;
  o ? o._next = l : e[n] === t && (e[n] = l), l ? l._prev = o : e[i] === t && (e[i] = o), t._next = t._prev = t.parent = null;
}, tv = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, hb = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0))
    for (var n = e; n; )
      n._dirty = 1, n = n.parent;
  return e;
}, Dte = function(e) {
  for (var t = e.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, QH = function(e, t, n, i) {
  return e._startAt && (sg ? e._startAt.revert($1) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i));
}, Ute = function a(e) {
  return !e || e._ts && a(e.parent);
}, W3 = function(e) {
  return e._repeat ? aB(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, aB = function(e, t) {
  var n = Math.floor(e /= t);
  return e && n === e ? n - 1 : n;
}, D2 = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, DW = function(e) {
  return e._end = Tu(e._start + (e._tDur / Math.abs(e._ts || e._rts || Jo) || 0));
}, UW = function(e, t) {
  var n = e._dp;
  return n && n.smoothChildTiming && e._ts && (e._start = Tu(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), DW(e), n._dirty || hb(n, e)), e;
}, OL = function(e, t) {
  var n;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = D2(e.rawTime(), t), (!t._dur || $w(0, t.totalDuration(), n) - t._tTime > Jo) && t.render(n, !0)), hb(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration())
      for (n = e; n._dp; )
        n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
    e._zTime = -Jo;
  }
}, tp = function(e, t, n, i) {
  return t.parent && tv(t), t._start = Tu((Ym(n) ? n : n || e !== Hs ? MC(e, n, t) : e._time) + t._delay), t._end = Tu(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), UL(e, t, "_first", "_last", e._sort ? "_start" : 0), jH(t) || (e._recent = t), i || OL(e, t), e._ts < 0 && UW(e, e._tTime), e;
}, PL = function(e, t) {
  return (LI.ScrollTrigger || AY("scrollTrigger", t)) && LI.ScrollTrigger.create(t, e);
}, JL = function(e, t, n, i, o) {
  if (BY(e, t, o), !e._initted)
    return 1;
  if (!n && e._pt && !sg && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && zL !== TI.frame)
    return JA.push(e), e._lazy = [o, i], 1;
}, Ote = function a(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || a(t));
}, jH = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, Pte = function(e, t, n, i) {
  var o = e.ratio, l = t < 0 || !t && (!e._start && Ote(e) && !(!e._initted && jH(e)) || (e._ts < 0 || e._dp._ts < 0) && !jH(e)) ? 0 : 1, u = e._rDelay, I = 0, f, h, v;
  if (u && e._repeat && (I = $w(0, e._tDur, t), h = aB(I, u), e._yoyo && h & 1 && (l = 1 - l), h !== aB(e._tTime, u) && (o = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== o || sg || i || e._zTime === Jo || !t && e._zTime) {
    if (!e._initted && JL(e, t, i, n, I))
      return;
    for (v = e._zTime, e._zTime = t || (n ? Jo : 0), n || (n = t && !v), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = I, f = e._pt; f; )
      f.r(l, f.d), f = f._next;
    t < 0 && QH(e, t, n, !0), e._onUpdate && !n && _I(e, "onUpdate"), I && e._repeat && !n && e.parent && _I(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && tv(e, 1), !n && !sg && (_I(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, Jte = function(e, t, n) {
  var i;
  if (n > t)
    for (i = e._first; i && i._start <= n; ) {
      if (i.data === "isPause" && i._start > t)
        return i;
      i = i._next;
    }
  else
    for (i = e._last; i && i._start >= n; ) {
      if (i.data === "isPause" && i._start < t)
        return i;
      i = i._prev;
    }
}, oB = function(e, t, n, i) {
  var o = e._repeat, l = Tu(t) || 0, u = e._tTime / e._tDur;
  return u && !i && (e._time *= l / e._dur), e._dur = l, e._tDur = o ? o < 0 ? 1e10 : Tu(l * (o + 1) + e._rDelay * o) : l, u > 0 && !i && UW(e, e._tTime = e._tDur * u), e.parent && DW(e), n || hb(e.parent, e), e;
}, V3 = function(e) {
  return e instanceof Lg ? hb(e) : oB(e, e._dur);
}, Qte = {
  _start: 0,
  endTime: Vw,
  totalDuration: Vw
}, MC = function a(e, t, n) {
  var i = e.labels, o = e._recent || Qte, l = e.duration() >= YC ? o.endTime(!1) : e._dur, u, I, f;
  return Ku(t) && (isNaN(t) || t in i) ? (I = t.charAt(0), f = t.substr(-1) === "%", u = t.indexOf("="), I === "<" || I === ">" ? (u >= 0 && (t = t.replace(/=/, "")), (I === "<" ? o._start : o.endTime(o._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (f ? (u < 0 ? o : n).totalDuration() / 100 : 1)) : u < 0 ? (t in i || (i[t] = l), i[t]) : (I = parseFloat(t.charAt(u - 1) + t.substr(u + 1)), f && n && (I = I / 100 * (lg(n) ? n[0] : n).totalDuration()), u > 1 ? a(e, t.substr(0, u - 1), n) + I : l + I)) : t == null ? l : +t;
}, tw = function(e, t, n) {
  var i = Ym(t[1]), o = (i ? 2 : 1) + (e < 2 ? 0 : 1), l = t[o], u, I;
  if (i && (l.duration = t[1]), l.parent = n, e) {
    for (u = l, I = n; I && !("immediateRender" in u); )
      u = I.vars.defaults || {}, I = Fd(I.vars.inherit) && I.parent;
    l.immediateRender = Fd(u.immediateRender), e < 2 ? l.runBackwards = 1 : l.startAt = t[o - 1];
  }
  return new Yl(t[0], l, t[o + 1]);
}, sv = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, $w = function(e, t, n) {
  return n < e ? e : n > t ? t : n;
}, ig = function(e, t) {
  return !Ku(e) || !(t = Tte.exec(e)) ? "" : t[1];
}, jte = function(e, t, n) {
  return sv(n, function(i) {
    return $w(e, t, i);
  });
}, qH = [].slice, QL = function(e, t) {
  return e && gp(e) && "length" in e && (!t && !e.length || e.length - 1 in e && gp(e[0])) && !e.nodeType && e !== $f;
}, qte = function(e, t, n) {
  return n === void 0 && (n = []), e.forEach(function(i) {
    var o;
    return Ku(i) && !t || QL(i, 1) ? (o = n).push.apply(o, FC(i)) : n.push(i);
  }) || n;
}, FC = function(e, t, n) {
  return hs && !t && hs.selector ? hs.selector(e) : Ku(e) && !n && (PH || !sB()) ? qH.call((t || mY).querySelectorAll(e), 0) : lg(e) ? qte(e, n) : QL(e) ? qH.call(e, 0) : e ? [e] : [];
}, $H = function(e) {
  return e = FC(e)[0] || Ww("Invalid scope") || {}, function(t) {
    var n = e.current || e.nativeElement || e;
    return FC(t, n.querySelectorAll ? n : n === e ? Ww("Invalid scope") || mY.createElement("div") : e);
  };
}, jL = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, qL = function(e) {
  if (il(e))
    return e;
  var t = gp(e) ? e : {
    each: e
  }, n = fb(t.ease), i = t.from || 0, o = parseFloat(t.base) || 0, l = {}, u = i > 0 && i < 1, I = isNaN(i) || u, f = t.axis, h = i, v = i;
  return Ku(i) ? h = v = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[i] || 0 : !u && I && (h = i[0], v = i[1]), function(b, S, R) {
    var W = (R || t).length, x = l[W], M, T, E, _, P, U, q, k, O;
    if (!x) {
      if (O = t.grid === "auto" ? 0 : (t.grid || [1, YC])[1], !O) {
        for (q = -YC; q < (q = R[O++].getBoundingClientRect().left) && O < W; )
          ;
        O < W && O--;
      }
      for (x = l[W] = [], M = I ? Math.min(O, W) * h - 0.5 : i % O, T = O === YC ? 0 : I ? W * v / O - 0.5 : i / O | 0, q = 0, k = YC, U = 0; U < W; U++)
        E = U % O - M, _ = T - (U / O | 0), x[U] = P = f ? Math.abs(f === "y" ? _ : E) : ML(E * E + _ * _), P > q && (q = P), P < k && (k = P);
      i === "random" && jL(x), x.max = q - k, x.min = k, x.v = W = (parseFloat(t.amount) || parseFloat(t.each) * (O > W ? W - 1 : f ? f === "y" ? W / O : O : Math.max(O, W / O)) || 0) * (i === "edges" ? -1 : 1), x.b = W < 0 ? o - W : o, x.u = ig(t.amount || t.each) || 0, n = n && W < 0 ? l9(n) : n;
    }
    return W = (x[b] - x.min) / x.max || 0, Tu(x.b + (n ? n(W) : W) * x.v) + x.u;
  };
}, eX = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(n) {
    var i = Tu(Math.round(parseFloat(n) / e) * e * t);
    return (i - i % 1) / t + (Ym(n) ? 0 : ig(n));
  };
}, $L = function(e, t) {
  var n = lg(e), i, o;
  return !n && gp(e) && (i = n = e.radius || YC, e.values ? (e = FC(e.values), (o = !Ym(e[0])) && (i *= i)) : e = eX(e.increment)), sv(t, n ? il(e) ? function(l) {
    return o = e(l), Math.abs(o - l) <= i ? o : l;
  } : function(l) {
    for (var u = parseFloat(o ? l.x : l), I = parseFloat(o ? l.y : 0), f = YC, h = 0, v = e.length, b, S; v--; )
      o ? (b = e[v].x - u, S = e[v].y - I, b = b * b + S * S) : b = Math.abs(e[v] - u), b < f && (f = b, h = v);
    return h = !i || f <= i ? e[h] : l, o || h === l || Ym(l) ? h : h + ig(l);
  } : eX(e));
}, e9 = function(e, t, n, i) {
  return sv(lg(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
    return lg(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) * n * i) / i;
  });
}, $te = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(i) {
    return t.reduce(function(o, l) {
      return l(o);
    }, i);
  };
}, ene = function(e, t) {
  return function(n) {
    return e(parseFloat(n)) + (t || ig(n));
  };
}, tne = function(e, t, n) {
  return n9(e, t, 0, 1, n);
}, t9 = function(e, t, n) {
  return sv(n, function(i) {
    return e[~~t(i)];
  });
}, nne = function a(e, t, n) {
  var i = t - e;
  return lg(e) ? t9(e, a(0, e.length), t) : sv(n, function(o) {
    return (i + (o - e) % i) % i + e;
  });
}, ine = function a(e, t, n) {
  var i = t - e, o = i * 2;
  return lg(e) ? t9(e, a(0, e.length - 1), t) : sv(n, function(l) {
    return l = (o + (l - e) % o) % o || 0, e + (l > i ? o - l : l);
  });
}, Nw = function(e) {
  for (var t = 0, n = "", i, o, l, u; ~(i = e.indexOf("random(", t)); )
    l = e.indexOf(")", i), u = e.charAt(i + 7) === "[", o = e.substr(i + 7, l - i - 7).match(u ? FL : OH), n += e.substr(t, i - t) + e9(u ? o : +o[0], u ? 0 : +o[1], +o[2] || 1e-5), t = l + 1;
  return n + e.substr(t, e.length - t);
}, n9 = function(e, t, n, i, o) {
  var l = t - e, u = i - n;
  return sv(o, function(I) {
    return n + ((I - e) / l * u || 0);
  });
}, rne = function a(e, t, n, i) {
  var o = isNaN(e + t) ? 0 : function(S) {
    return (1 - S) * e + S * t;
  };
  if (!o) {
    var l = Ku(e), u = {}, I, f, h, v, b;
    if (n === !0 && (i = 1) && (n = null), l)
      e = {
        p: e
      }, t = {
        p: t
      };
    else if (lg(e) && !lg(t)) {
      for (h = [], v = e.length, b = v - 2, f = 1; f < v; f++)
        h.push(a(e[f - 1], e[f]));
      v--, o = function(R) {
        R *= v;
        var W = Math.min(b, ~~R);
        return h[W](R - W);
      }, n = t;
    } else i || (e = Gb(lg(e) ? [] : {}, e));
    if (!h) {
      for (I in t)
        GY.call(u, e, I, "get", t[I]);
      o = function(R) {
        return wY(R, u) || (l ? e.p : e);
      };
    }
  }
  return sv(n, o);
}, N3 = function(e, t, n) {
  var i = e.labels, o = YC, l, u, I;
  for (l in i)
    u = i[l] - t, u < 0 == !!n && u && o > (u = Math.abs(u)) && (I = l, o = u);
  return I;
}, _I = function(e, t, n) {
  var i = e.vars, o = i[t], l = hs, u = e._ctx, I, f, h;
  if (o)
    return I = i[t + "Params"], f = i.callbackScope || e, n && JA.length && L2(), u && (hs = u), h = I ? o.apply(f, I) : o.call(f), hs = l, h;
}, zZ = function(e) {
  return tv(e), e.scrollTrigger && e.scrollTrigger.kill(!!sg), e.progress() < 1 && _I(e, "onInterrupt"), e;
}, kG, i9 = [], r9 = function(e) {
  if (e)
    if (e = !e.name && e.default || e, pY() || e.headless) {
      var t = e.name, n = il(e), i = t && !n && e.init ? function() {
        this._props = [];
      } : e, o = {
        init: Vw,
        render: wY,
        add: GY,
        kill: vne,
        modifier: Ane,
        rawVars: 0
      }, l = {
        targetTest: 0,
        get: 0,
        getSetter: ZY,
        aliases: {},
        register: 0
      };
      if (sB(), e !== i) {
        if (FI[t])
          return;
        TC(i, TC(k2(e, o), l)), Gb(i.prototype, Gb(o, k2(e, l))), FI[i.prop = t] = i, e.targetTest && (e2.push(i), vY[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      _L(t, i), e.register && e.register(Ld, i, Td);
    } else
      i9.push(e);
}, _o = 255, KZ = {
  aqua: [0, _o, _o],
  lime: [0, _o, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _o],
  navy: [0, 0, 128],
  white: [_o, _o, _o],
  olive: [128, 128, 0],
  yellow: [_o, _o, 0],
  orange: [_o, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_o, 0, 0],
  pink: [_o, 192, 203],
  cyan: [0, _o, _o],
  transparent: [_o, _o, _o, 0]
}, rH = function(e, t, n) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < 0.5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * _o + 0.5 | 0;
}, a9 = function(e, t, n) {
  var i = e ? Ym(e) ? [e >> 16, e >> 8 & _o, e & _o] : 0 : KZ.black, o, l, u, I, f, h, v, b, S, R;
  if (!i) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), KZ[e])
      i = KZ[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (o = e.charAt(1), l = e.charAt(2), u = e.charAt(3), e = "#" + o + o + l + l + u + u + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9)
        return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & _o, i & _o, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & _o, e & _o];
    } else if (e.substr(0, 3) === "hsl") {
      if (i = R = e.match(OH), !t)
        I = +i[0] % 360 / 360, f = +i[1] / 100, h = +i[2] / 100, l = h <= 0.5 ? h * (f + 1) : h + f - h * f, o = h * 2 - l, i.length > 3 && (i[3] *= 1), i[0] = rH(I + 1 / 3, o, l), i[1] = rH(I, o, l), i[2] = rH(I - 1 / 3, o, l);
      else if (~e.indexOf("="))
        return i = e.match(XL), n && i.length < 4 && (i[3] = 1), i;
    } else
      i = e.match(OH) || KZ.transparent;
    i = i.map(Number);
  }
  return t && !R && (o = i[0] / _o, l = i[1] / _o, u = i[2] / _o, v = Math.max(o, l, u), b = Math.min(o, l, u), h = (v + b) / 2, v === b ? I = f = 0 : (S = v - b, f = h > 0.5 ? S / (2 - v - b) : S / (v + b), I = v === o ? (l - u) / S + (l < u ? 6 : 0) : v === l ? (u - o) / S + 2 : (o - l) / S + 4, I *= 60), i[0] = ~~(I + 0.5), i[1] = ~~(f * 100 + 0.5), i[2] = ~~(h * 100 + 0.5)), n && i.length < 4 && (i[3] = 1), i;
}, o9 = function(e) {
  var t = [], n = [], i = -1;
  return e.split(QA).forEach(function(o) {
    var l = o.match(LG) || [];
    t.push.apply(t, l), n.push(i += l.length + 1);
  }), t.c = n, t;
}, M3 = function(e, t, n) {
  var i = "", o = (e + i).match(QA), l = t ? "hsla(" : "rgba(", u = 0, I, f, h, v;
  if (!o)
    return e;
  if (o = o.map(function(b) {
    return (b = a9(b, t, 1)) && l + (t ? b[0] + "," + b[1] + "%," + b[2] + "%," + b[3] : b.join(",")) + ")";
  }), n && (h = o9(e), I = n.c, I.join(i) !== h.c.join(i)))
    for (f = e.replace(QA, "1").split(LG), v = f.length - 1; u < v; u++)
      i += f[u] + (~I.indexOf(u) ? o.shift() || l + "0,0,0,0)" : (h.length ? h : o.length ? o : n).shift());
  if (!f)
    for (f = e.split(QA), v = f.length - 1; u < v; u++)
      i += f[u] + o[u];
  return i + f[v];
}, QA = function() {
  var a = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in KZ)
    a += "|" + e + "\\b";
  return new RegExp(a + ")", "gi");
}(), ane = /hsl[a]?\(/, s9 = function(e) {
  var t = e.join(" "), n;
  if (QA.lastIndex = 0, QA.test(t))
    return n = ane.test(t), e[1] = M3(e[1], n), e[0] = M3(e[0], n, o9(e[1])), !0;
}, Mw, TI = function() {
  var a = Date.now, e = 500, t = 33, n = a(), i = n, o = 1e3 / 240, l = o, u = [], I, f, h, v, b, S, R = function W(x) {
    var M = a() - i, T = x === !0, E, _, P, U;
    if ((M > e || M < 0) && (n += M - t), i += M, P = i - n, E = P - l, (E > 0 || T) && (U = ++v.frame, b = P - v.time * 1e3, v.time = P = P / 1e3, l += E + (E >= o ? 4 : o - E), _ = 1), T || (I = f(W)), _)
      for (S = 0; S < u.length; S++)
        u[S](P, b, U, x);
  };
  return v = {
    time: 0,
    frame: 0,
    tick: function() {
      R(!0);
    },
    deltaRatio: function(x) {
      return b / (1e3 / (x || 60));
    },
    wake: function() {
      EL && (!PH && pY() && ($f = PH = window, mY = $f.document || {}, LI.gsap = Ld, ($f.gsapVersions || ($f.gsapVersions = [])).push(Ld.version), TL(K2 || $f.GreenSockGlobals || !$f.gsap && $f || {}), i9.forEach(r9)), h = typeof requestAnimationFrame < "u" && requestAnimationFrame, I && v.sleep(), f = h || function(x) {
        return setTimeout(x, l - v.time * 1e3 + 1 | 0);
      }, Mw = 1, R(2));
    },
    sleep: function() {
      (h ? cancelAnimationFrame : clearTimeout)(I), Mw = 0, f = Vw;
    },
    lagSmoothing: function(x, M) {
      e = x || 1 / 0, t = Math.min(M || 33, e);
    },
    fps: function(x) {
      o = 1e3 / (x || 240), l = v.time * 1e3 + o;
    },
    add: function(x, M, T) {
      var E = M ? function(_, P, U, q) {
        x(_, P, U, q), v.remove(E);
      } : x;
      return v.remove(x), u[T ? "unshift" : "push"](E), sB(), E;
    },
    remove: function(x, M) {
      ~(M = u.indexOf(x)) && u.splice(M, 1) && S >= M && S--;
    },
    _listeners: u
  }, v;
}(), sB = function() {
  return !Mw && TI.wake();
}, ma = {}, one = /^[\d.\-M][\d.\-,\s]/, sne = /["']/g, lne = function(e) {
  for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], o = 1, l = n.length, u, I, f; o < l; o++)
    I = n[o], u = o !== l - 1 ? I.lastIndexOf(",") : I.length, f = I.substr(0, u), t[i] = isNaN(f) ? f.replace(sne, "").trim() : +f, i = I.substr(u + 1).trim();
  return t;
}, une = function(e) {
  var t = e.indexOf("(") + 1, n = e.indexOf(")"), i = e.indexOf("(", t);
  return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
}, cne = function(e) {
  var t = (e + "").split("("), n = ma[t[0]];
  return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [lne(t[1])] : une(e).split(",").map(kL)) : ma._CE && one.test(e) ? ma._CE("", e) : n;
}, l9 = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, u9 = function a(e, t) {
  for (var n = e._first, i; n; )
    n instanceof Lg ? a(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? a(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next;
}, fb = function(e, t) {
  return e && (il(e) ? e : ma[e] || cne(e)) || t;
}, Nb = function(e, t, n, i) {
  n === void 0 && (n = function(I) {
    return 1 - t(1 - I);
  }), i === void 0 && (i = function(I) {
    return I < 0.5 ? t(I * 2) / 2 : 1 - t((1 - I) * 2) / 2;
  });
  var o = {
    easeIn: t,
    easeOut: n,
    easeInOut: i
  }, l;
  return Ed(e, function(u) {
    ma[u] = LI[u] = o, ma[l = u.toLowerCase()] = n;
    for (var I in o)
      ma[l + (I === "easeIn" ? ".in" : I === "easeOut" ? ".out" : ".inOut")] = ma[u + "." + I] = o[I];
  }), o;
}, c9 = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, aH = function a(e, t, n) {
  var i = t >= 1 ? t : 1, o = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), l = o / UH * (Math.asin(1 / i) || 0), u = function(h) {
    return h === 1 ? 1 : i * Math.pow(2, -10 * h) * Ete((h - l) * o) + 1;
  }, I = e === "out" ? u : e === "in" ? function(f) {
    return 1 - u(1 - f);
  } : c9(u);
  return o = UH / o, I.config = function(f, h) {
    return a(e, f, h);
  }, I;
}, oH = function a(e, t) {
  t === void 0 && (t = 1.70158);
  var n = function(l) {
    return l ? --l * l * ((t + 1) * l + t) + 1 : 0;
  }, i = e === "out" ? n : e === "in" ? function(o) {
    return 1 - n(1 - o);
  } : c9(n);
  return i.config = function(o) {
    return a(e, o);
  }, i;
};
Ed("Linear,Quad,Cubic,Quart,Quint,Strong", function(a, e) {
  var t = e < 5 ? e + 1 : e;
  Nb(a + ",Power" + (t - 1), e ? function(n) {
    return Math.pow(n, t);
  } : function(n) {
    return n;
  }, function(n) {
    return 1 - Math.pow(1 - n, t);
  }, function(n) {
    return n < 0.5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2;
  });
});
ma.Linear.easeNone = ma.none = ma.Linear.easeIn;
Nb("Elastic", aH("in"), aH("out"), aH());
(function(a, e) {
  var t = 1 / e, n = 2 * t, i = 2.5 * t, o = function(u) {
    return u < t ? a * u * u : u < n ? a * Math.pow(u - 1.5 / e, 2) + 0.75 : u < i ? a * (u -= 2.25 / e) * u + 0.9375 : a * Math.pow(u - 2.625 / e, 2) + 0.984375;
  };
  Nb("Bounce", function(l) {
    return 1 - o(1 - l);
  }, o);
})(7.5625, 2.75);
Nb("Expo", function(a) {
  return a ? Math.pow(2, 10 * (a - 1)) : 0;
});
Nb("Circ", function(a) {
  return -(ML(1 - a * a) - 1);
});
Nb("Sine", function(a) {
  return a === 1 ? 1 : -Fte(a * Xte) + 1;
});
Nb("Back", oH("in"), oH("out"), oH());
ma.SteppedEase = ma.steps = LI.SteppedEase = {
  config: function(e, t) {
    e === void 0 && (e = 1);
    var n = 1 / e, i = e + (t ? 0 : 1), o = t ? 1 : 0, l = 1 - Jo;
    return function(u) {
      return ((i * $w(0, l, u) | 0) + o) * n;
    };
  }
};
rB.ease = ma["quad.out"];
Ed("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(a) {
  return yY += a + "," + a + "Params,";
});
var g9 = function(e, t) {
  this.id = Yte++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : KL, this.set = t ? t.getSetter : ZY;
}, Hw = /* @__PURE__ */ function() {
  function a(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, oB(this, +t.duration, 1, 1), this.data = t.data, hs && (this._ctx = hs, hs.data.push(this)), Mw || TI.wake();
  }
  var e = a.prototype;
  return e.delay = function(n) {
    return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay;
  }, e.duration = function(n) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(n) {
    return arguments.length ? (this._dirty = 0, oB(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(n, i) {
    if (sB(), !arguments.length)
      return this._tTime;
    var o = this._dp;
    if (o && o.smoothChildTiming && this._ts) {
      for (UW(this, n), !o._dp || o.parent || OL(o, this); o && o.parent; )
        o.parent._time !== o._start + (o._ts >= 0 ? o._tTime / o._ts : (o.totalDuration() - o._tTime) / -o._ts) && o.totalTime(o._tTime, !0), o = o.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && tp(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === Jo || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), LL(this, n, i)), this;
  }, e.time = function(n, i) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + W3(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time;
  }, e.totalProgress = function(n, i) {
    return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  }, e.progress = function(n, i) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + W3(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(n, i) {
    var o = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (n - 1) * o, i) : this._repeat ? aB(this._tTime, o) + 1 : 1;
  }, e.timeScale = function(n, i) {
    if (!arguments.length)
      return this._rts === -Jo ? 0 : this._rts;
    if (this._rts === n)
      return this;
    var o = this.parent && this._ts ? D2(this.parent._time, this) : this._tTime;
    return this._rts = +n || 0, this._ts = this._ps || n === -Jo ? 0 : this._rts, this.totalTime($w(-Math.abs(this._delay), this._tDur, o), i !== !1), DW(this), Dte(this);
  }, e.paused = function(n) {
    return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (sB(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Jo && (this._tTime -= Jo)))), this) : this._ps;
  }, e.startTime = function(n) {
    if (arguments.length) {
      this._start = n;
      var i = this.parent || this._dp;
      return i && (i._sort || !this.parent) && tp(i, this, n - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(n) {
    return this._start + (Fd(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(n) {
    var i = this.parent || this._dp;
    return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? D2(i.rawTime(n), this) : this._tTime : this._tTime;
  }, e.revert = function(n) {
    n === void 0 && (n = zte);
    var i = sg;
    return sg = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), sg = i, this;
  }, e.globalTime = function(n) {
    for (var i = this, o = arguments.length ? n : i.rawTime(); i; )
      o = i._start + o / (Math.abs(i._ts) || 1), i = i._dp;
    return !this.parent && this._sat ? this._sat.globalTime(n) : o;
  }, e.repeat = function(n) {
    return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, V3(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(n) {
    if (arguments.length) {
      var i = this._time;
      return this._rDelay = n, V3(this), i ? this.time(i) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(n) {
    return arguments.length ? (this._yoyo = n, this) : this._yoyo;
  }, e.seek = function(n, i) {
    return this.totalTime(MC(this, n), Fd(i));
  }, e.restart = function(n, i) {
    return this.play().totalTime(n ? -this._delay : 0, Fd(i));
  }, e.play = function(n, i) {
    return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
  }, e.reverse = function(n, i) {
    return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1);
  }, e.pause = function(n, i) {
    return n != null && this.seek(n, i), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(n) {
    return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -Jo : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -Jo, this;
  }, e.isActive = function() {
    var n = this.parent || this._dp, i = this._start, o;
    return !!(!n || this._ts && this._initted && n.isActive() && (o = n.rawTime(!0)) >= i && o < this.endTime(!0) - Jo);
  }, e.eventCallback = function(n, i, o) {
    var l = this.vars;
    return arguments.length > 1 ? (i ? (l[n] = i, o && (l[n + "Params"] = o), n === "onUpdate" && (this._onUpdate = i)) : delete l[n], this) : l[n];
  }, e.then = function(n) {
    var i = this;
    return new Promise(function(o) {
      var l = il(n) ? n : DL, u = function() {
        var f = i.then;
        i.then = null, il(l) && (l = l(i)) && (l.then || l === i) && (i.then = f), o(l), i.then = f;
      };
      i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? u() : i._prom = u;
    });
  }, e.kill = function() {
    zZ(this);
  }, a;
}();
TC(Hw.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -Jo,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Lg = /* @__PURE__ */ function(a) {
  NL(e, a);
  function e(n, i) {
    var o;
    return n === void 0 && (n = {}), o = a.call(this, n) || this, o.labels = {}, o.smoothChildTiming = !!n.smoothChildTiming, o.autoRemoveChildren = !!n.autoRemoveChildren, o._sort = Fd(n.sortChildren), Hs && tp(n.parent || Hs, bm(o), i), n.reversed && o.reverse(), n.paused && o.paused(!0), n.scrollTrigger && PL(bm(o), n.scrollTrigger), o;
  }
  var t = e.prototype;
  return t.to = function(i, o, l) {
    return tw(0, arguments, this), this;
  }, t.from = function(i, o, l) {
    return tw(1, arguments, this), this;
  }, t.fromTo = function(i, o, l, u) {
    return tw(2, arguments, this), this;
  }, t.set = function(i, o, l) {
    return o.duration = 0, o.parent = this, ew(o).repeatDelay || (o.repeat = 0), o.immediateRender = !!o.immediateRender, new Yl(i, o, MC(this, l), 1), this;
  }, t.call = function(i, o, l) {
    return tp(this, Yl.delayedCall(0, i, o), l);
  }, t.staggerTo = function(i, o, l, u, I, f, h) {
    return l.duration = o, l.stagger = l.stagger || u, l.onComplete = f, l.onCompleteParams = h, l.parent = this, new Yl(i, l, MC(this, I)), this;
  }, t.staggerFrom = function(i, o, l, u, I, f, h) {
    return l.runBackwards = 1, ew(l).immediateRender = Fd(l.immediateRender), this.staggerTo(i, o, l, u, I, f, h);
  }, t.staggerFromTo = function(i, o, l, u, I, f, h, v) {
    return u.startAt = l, ew(u).immediateRender = Fd(u.immediateRender), this.staggerTo(i, o, u, I, f, h, v);
  }, t.render = function(i, o, l) {
    var u = this._time, I = this._dirty ? this.totalDuration() : this._tDur, f = this._dur, h = i <= 0 ? 0 : Tu(i), v = this._zTime < 0 != i < 0 && (this._initted || !f), b, S, R, W, x, M, T, E, _, P, U, q;
    if (this !== Hs && h > I && i >= 0 && (h = I), h !== this._tTime || l || v) {
      if (u !== this._time && f && (h += this._time - u, i += this._time - u), b = h, _ = this._start, E = this._ts, M = !E, v && (f || (u = this._zTime), (i || !o) && (this._zTime = i)), this._repeat) {
        if (U = this._yoyo, x = f + this._rDelay, this._repeat < -1 && i < 0)
          return this.totalTime(x * 100 + i, o, l);
        if (b = Tu(h % x), h === I ? (W = this._repeat, b = f) : (W = ~~(h / x), W && W === h / x && (b = f, W--), b > f && (b = f)), P = aB(this._tTime, x), !u && this._tTime && P !== W && this._tTime - P * x - this._dur <= 0 && (P = W), U && W & 1 && (b = f - b, q = 1), W !== P && !this._lock) {
          var k = U && P & 1, O = k === (U && W & 1);
          if (W < P && (k = !k), u = k ? 0 : h % f ? f : h, this._lock = 1, this.render(u || (q ? 0 : Tu(W * x)), o, !f)._lock = 0, this._tTime = h, !o && this.parent && _I(this, "onRepeat"), this.vars.repeatRefresh && !q && (this.invalidate()._lock = 1), u && u !== this._time || M !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (f = this._dur, I = this._tDur, O && (this._lock = 2, u = k ? f : -1e-4, this.render(u, !0), this.vars.repeatRefresh && !q && this.invalidate()), this._lock = 0, !this._ts && !M)
            return this;
          u9(this, q);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (T = Jte(this, Tu(u), Tu(b)), T && (h -= b - (b = T._start))), this._tTime = h, this._time = b, this._act = !E, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, u = 0), !u && b && !o && !W && (_I(this, "onStart"), this._tTime !== h))
        return this;
      if (b >= u && i >= 0)
        for (S = this._first; S; ) {
          if (R = S._next, (S._act || b >= S._start) && S._ts && T !== S) {
            if (S.parent !== this)
              return this.render(i, o, l);
            if (S.render(S._ts > 0 ? (b - S._start) * S._ts : (S._dirty ? S.totalDuration() : S._tDur) + (b - S._start) * S._ts, o, l), b !== this._time || !this._ts && !M) {
              T = 0, R && (h += this._zTime = -Jo);
              break;
            }
          }
          S = R;
        }
      else {
        S = this._last;
        for (var J = i < 0 ? i : b; S; ) {
          if (R = S._prev, (S._act || J <= S._end) && S._ts && T !== S) {
            if (S.parent !== this)
              return this.render(i, o, l);
            if (S.render(S._ts > 0 ? (J - S._start) * S._ts : (S._dirty ? S.totalDuration() : S._tDur) + (J - S._start) * S._ts, o, l || sg && (S._initted || S._startAt)), b !== this._time || !this._ts && !M) {
              T = 0, R && (h += this._zTime = J ? -Jo : Jo);
              break;
            }
          }
          S = R;
        }
      }
      if (T && !o && (this.pause(), T.render(b >= u ? 0 : -Jo)._zTime = b >= u ? 1 : -1, this._ts))
        return this._start = _, DW(this), this.render(i, o, l);
      this._onUpdate && !o && _I(this, "onUpdate", !0), (h === I && this._tTime >= this.totalDuration() || !h && u) && (_ === this._start || Math.abs(E) !== Math.abs(this._ts)) && (this._lock || ((i || !f) && (h === I && this._ts > 0 || !h && this._ts < 0) && tv(this, 1), !o && !(i < 0 && !u) && (h || u || !I) && (_I(this, h === I && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < I && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(i, o) {
    var l = this;
    if (Ym(o) || (o = MC(this, o, i)), !(i instanceof Hw)) {
      if (lg(i))
        return i.forEach(function(u) {
          return l.add(u, o);
        }), this;
      if (Ku(i))
        return this.addLabel(i, o);
      if (il(i))
        i = Yl.delayedCall(0, i);
      else
        return this;
    }
    return this !== i ? tp(this, i, o) : this;
  }, t.getChildren = function(i, o, l, u) {
    i === void 0 && (i = !0), o === void 0 && (o = !0), l === void 0 && (l = !0), u === void 0 && (u = -YC);
    for (var I = [], f = this._first; f; )
      f._start >= u && (f instanceof Yl ? o && I.push(f) : (l && I.push(f), i && I.push.apply(I, f.getChildren(!0, o, l)))), f = f._next;
    return I;
  }, t.getById = function(i) {
    for (var o = this.getChildren(1, 1, 1), l = o.length; l--; )
      if (o[l].vars.id === i)
        return o[l];
  }, t.remove = function(i) {
    return Ku(i) ? this.removeLabel(i) : il(i) ? this.killTweensOf(i) : (kW(this, i), i === this._recent && (this._recent = this._last), hb(this));
  }, t.totalTime = function(i, o) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Tu(TI.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), a.prototype.totalTime.call(this, i, o), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(i, o) {
    return this.labels[i] = MC(this, o), this;
  }, t.removeLabel = function(i) {
    return delete this.labels[i], this;
  }, t.addPause = function(i, o, l) {
    var u = Yl.delayedCall(0, o || Vw, l);
    return u.data = "isPause", this._hasPause = 1, tp(this, u, MC(this, i));
  }, t.removePause = function(i) {
    var o = this._first;
    for (i = MC(this, i); o; )
      o._start === i && o.data === "isPause" && tv(o), o = o._next;
  }, t.killTweensOf = function(i, o, l) {
    for (var u = this.getTweensOf(i, l), I = u.length; I--; )
      UA !== u[I] && u[I].kill(i, o);
    return this;
  }, t.getTweensOf = function(i, o) {
    for (var l = [], u = FC(i), I = this._first, f = Ym(o), h; I; )
      I instanceof Yl ? Kte(I._targets, u) && (f ? (!UA || I._initted && I._ts) && I.globalTime(0) <= o && I.globalTime(I.totalDuration()) > o : !o || I.isActive()) && l.push(I) : (h = I.getTweensOf(u, o)).length && l.push.apply(l, h), I = I._next;
    return l;
  }, t.tweenTo = function(i, o) {
    o = o || {};
    var l = this, u = MC(l, i), I = o, f = I.startAt, h = I.onStart, v = I.onStartParams, b = I.immediateRender, S, R = Yl.to(l, TC({
      ease: o.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: u,
      overwrite: "auto",
      duration: o.duration || Math.abs((u - (f && "time" in f ? f.time : l._time)) / l.timeScale()) || Jo,
      onStart: function() {
        if (l.pause(), !S) {
          var x = o.duration || Math.abs((u - (f && "time" in f ? f.time : l._time)) / l.timeScale());
          R._dur !== x && oB(R, x, 0, 1).render(R._time, !0, !0), S = 1;
        }
        h && h.apply(R, v || []);
      }
    }, o));
    return b ? R.render(0) : R;
  }, t.tweenFromTo = function(i, o, l) {
    return this.tweenTo(o, TC({
      startAt: {
        time: MC(this, i)
      }
    }, l));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(i) {
    return i === void 0 && (i = this._time), N3(this, MC(this, i));
  }, t.previousLabel = function(i) {
    return i === void 0 && (i = this._time), N3(this, MC(this, i), 1);
  }, t.currentLabel = function(i) {
    return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Jo);
  }, t.shiftChildren = function(i, o, l) {
    l === void 0 && (l = 0);
    for (var u = this._first, I = this.labels, f; u; )
      u._start >= l && (u._start += i, u._end += i), u = u._next;
    if (o)
      for (f in I)
        I[f] >= l && (I[f] += i);
    return hb(this);
  }, t.invalidate = function(i) {
    var o = this._first;
    for (this._lock = 0; o; )
      o.invalidate(i), o = o._next;
    return a.prototype.invalidate.call(this, i);
  }, t.clear = function(i) {
    i === void 0 && (i = !0);
    for (var o = this._first, l; o; )
      l = o._next, this.remove(o), o = l;
    return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), hb(this);
  }, t.totalDuration = function(i) {
    var o = 0, l = this, u = l._last, I = YC, f, h, v;
    if (arguments.length)
      return l.timeScale((l._repeat < 0 ? l.duration() : l.totalDuration()) / (l.reversed() ? -i : i));
    if (l._dirty) {
      for (v = l.parent; u; )
        f = u._prev, u._dirty && u.totalDuration(), h = u._start, h > I && l._sort && u._ts && !l._lock ? (l._lock = 1, tp(l, u, h - u._delay, 1)._lock = 0) : I = h, h < 0 && u._ts && (o -= h, (!v && !l._dp || v && v.smoothChildTiming) && (l._start += h / l._ts, l._time -= h, l._tTime -= h), l.shiftChildren(-h, !1, -1 / 0), I = 0), u._end > o && u._ts && (o = u._end), u = f;
      oB(l, l === Hs && l._time > o ? l._time : o, 1, 1), l._dirty = 0;
    }
    return l._tDur;
  }, e.updateRoot = function(i) {
    if (Hs._ts && (LL(Hs, D2(i, Hs)), zL = TI.frame), TI.frame >= R3) {
      R3 += KI.autoSleep || 120;
      var o = Hs._first;
      if ((!o || !o._ts) && KI.autoSleep && TI._listeners.length < 2) {
        for (; o && !o._ts; )
          o = o._next;
        o || TI.sleep();
      }
    }
  }, e;
}(Hw);
TC(Lg.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var gne = function(e, t, n, i, o, l, u) {
  var I = new Td(this._pt, e, t, 0, 1, p9, null, o), f = 0, h = 0, v, b, S, R, W, x, M, T;
  for (I.b = n, I.e = i, n += "", i += "", (M = ~i.indexOf("random(")) && (i = Nw(i)), l && (T = [n, i], l(T, e, t), n = T[0], i = T[1]), b = n.match(nH) || []; v = nH.exec(i); )
    R = v[0], W = i.substring(f, v.index), S ? S = (S + 1) % 5 : W.substr(-5) === "rgba(" && (S = 1), R !== b[h++] && (x = parseFloat(b[h - 1]) || 0, I._pt = {
      _next: I._pt,
      p: W || h === 1 ? W : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: x,
      c: R.charAt(1) === "=" ? JG(x, R) - x : parseFloat(R) - x,
      m: S && S < 4 ? Math.round : 0
    }, f = nH.lastIndex);
  return I.c = f < i.length ? i.substring(f, i.length) : "", I.fp = u, (YL.test(i) || M) && (I.e = 0), this._pt = I, I;
}, GY = function(e, t, n, i, o, l, u, I, f, h) {
  il(i) && (i = i(o || 0, e, l));
  var v = e[t], b = n !== "get" ? n : il(v) ? f ? e[t.indexOf("set") || !il(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](f) : e[t]() : v, S = il(v) ? f ? fne : h9 : SY, R;
  if (Ku(i) && (~i.indexOf("random(") && (i = Nw(i)), i.charAt(1) === "=" && (R = JG(b, i) + (ig(b) || 0), (R || R === 0) && (i = R))), !h || b !== i || tX)
    return !isNaN(b * i) && i !== "" ? (R = new Td(this._pt, e, t, +b || 0, i - (b || 0), typeof v == "boolean" ? mne : f9, 0, S), f && (R.fp = f), u && R.modifier(u, this, e), this._pt = R) : (!v && !(t in e) && AY(t, i), gne.call(this, e, t, b, i, S, I || KI.stringFilter, f));
}, dne = function(e, t, n, i, o) {
  if (il(e) && (e = nw(e, o, t, n, i)), !gp(e) || e.style && e.nodeType || lg(e) || HL(e))
    return Ku(e) ? nw(e, o, t, n, i) : e;
  var l = {}, u;
  for (u in e)
    l[u] = nw(e[u], o, t, n, i);
  return l;
}, d9 = function(e, t, n, i, o, l) {
  var u, I, f, h;
  if (FI[e] && (u = new FI[e]()).init(o, u.rawVars ? t[e] : dne(t[e], i, o, l, n), n, i, l) !== !1 && (n._pt = I = new Td(n._pt, o, e, 0, 1, u.render, u, 0, u.priority), n !== kG))
    for (f = n._ptLookup[n._targets.indexOf(o)], h = u._props.length; h--; )
      f[u._props[h]] = I;
  return u;
}, UA, tX, BY = function a(e, t, n) {
  var i = e.vars, o = i.ease, l = i.startAt, u = i.immediateRender, I = i.lazy, f = i.onUpdate, h = i.runBackwards, v = i.yoyoEase, b = i.keyframes, S = i.autoRevert, R = e._dur, W = e._startAt, x = e._targets, M = e.parent, T = M && M.data === "nested" ? M.vars.targets : x, E = e._overwrite === "auto" && !hY, _ = e.timeline, P, U, q, k, O, J, te, fe, pe, Ae, Te, Ke, je;
  if (_ && (!b || !o) && (o = "none"), e._ease = fb(o, rB.ease), e._yEase = v ? l9(fb(v === !0 ? o : v, rB.ease)) : 0, v && e._yoyo && !e._repeat && (v = e._yEase, e._yEase = e._ease, e._ease = v), e._from = !_ && !!i.runBackwards, !_ || b && !i.stagger) {
    if (fe = x[0] ? Cb(x[0]).harness : 0, Ke = fe && i[fe.prop], P = k2(i, vY), W && (W._zTime < 0 && W.progress(1), t < 0 && h && u && !S ? W.render(-1, !0) : W.revert(h && R ? $1 : _te), W._lazy = 0), l) {
      if (tv(e._startAt = Yl.set(x, TC({
        data: "isStart",
        overwrite: !1,
        parent: M,
        immediateRender: !0,
        lazy: !W && Fd(I),
        startAt: null,
        delay: 0,
        onUpdate: f && function() {
          return _I(e, "onUpdate");
        },
        stagger: 0
      }, l))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (sg || !u && !S) && e._startAt.revert($1), u && R && t <= 0 && n <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (h && R && !W) {
      if (t && (u = !1), q = TC({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: u && !W && Fd(I),
        immediateRender: u,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: M
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, P), Ke && (q[fe.prop] = Ke), tv(e._startAt = Yl.set(x, q)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (sg ? e._startAt.revert($1) : e._startAt.render(-1, !0)), e._zTime = t, !u)
        a(e._startAt, Jo, Jo);
      else if (!t)
        return;
    }
    for (e._pt = e._ptCache = 0, I = R && Fd(I) || I && !R, U = 0; U < x.length; U++) {
      if (O = x[U], te = O._gsap || bY(x)[U]._gsap, e._ptLookup[U] = Ae = {}, JH[te.id] && JA.length && L2(), Te = T === x ? U : T.indexOf(O), fe && (pe = new fe()).init(O, Ke || P, e, Te, T) !== !1 && (e._pt = k = new Td(e._pt, O, pe.name, 0, 1, pe.render, pe, 0, pe.priority), pe._props.forEach(function(ee) {
        Ae[ee] = k;
      }), pe.priority && (J = 1)), !fe || Ke)
        for (q in P)
          FI[q] && (pe = d9(q, P, e, Te, O, T)) ? pe.priority && (J = 1) : Ae[q] = k = GY.call(e, O, q, "get", P[q], Te, T, 0, i.stringFilter);
      e._op && e._op[U] && e.kill(O, e._op[U]), E && e._pt && (UA = e, Hs.killTweensOf(O, Ae, e.globalTime(t)), je = !e.parent, UA = 0), e._pt && I && (JH[te.id] = 1);
    }
    J && m9(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = f, e._initted = (!e._op || e._pt) && !je, b && t <= 0 && _.render(YC, !0, !0);
}, Ine = function(e, t, n, i, o, l, u, I) {
  var f = (e._pt && e._ptCache || (e._ptCache = {}))[t], h, v, b, S;
  if (!f)
    for (f = e._ptCache[t] = [], b = e._ptLookup, S = e._targets.length; S--; ) {
      if (h = b[S][t], h && h.d && h.d._pt)
        for (h = h.d._pt; h && h.p !== t && h.fp !== t; )
          h = h._next;
      if (!h)
        return tX = 1, e.vars[t] = "+=0", BY(e, u), tX = 0, I ? Ww(t + " not eligible for reset") : 1;
      f.push(h);
    }
  for (S = f.length; S--; )
    v = f[S], h = v._pt || v, h.s = (i || i === 0) && !o ? i : h.s + (i || 0) + l * h.c, h.c = n - h.s, v.e && (v.e = bl(n) + ig(v.e)), v.b && (v.b = h.s + ig(v.b));
}, Cne = function(e, t) {
  var n = e[0] ? Cb(e[0]).harness : 0, i = n && n.aliases, o, l, u, I;
  if (!i)
    return t;
  o = Gb({}, t);
  for (l in i)
    if (l in o)
      for (I = i[l].split(","), u = I.length; u--; )
        o[I[u]] = o[l];
  return o;
}, hne = function(e, t, n, i) {
  var o = t.ease || i || "power1.inOut", l, u;
  if (lg(t))
    u = n[e] || (n[e] = []), t.forEach(function(I, f) {
      return u.push({
        t: f / (t.length - 1) * 100,
        v: I,
        e: o
      });
    });
  else
    for (l in t)
      u = n[l] || (n[l] = []), l === "ease" || u.push({
        t: parseFloat(e),
        v: t[l],
        e: o
      });
}, nw = function(e, t, n, i, o) {
  return il(e) ? e.call(t, n, i, o) : Ku(e) && ~e.indexOf("random(") ? Nw(e) : e;
}, I9 = yY + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", C9 = {};
Ed(I9 + ",id,stagger,delay,duration,paused,scrollTrigger", function(a) {
  return C9[a] = 1;
});
var Yl = /* @__PURE__ */ function(a) {
  NL(e, a);
  function e(n, i, o, l) {
    var u;
    typeof i == "number" && (o.duration = i, i = o, o = null), u = a.call(this, l ? i : ew(i)) || this;
    var I = u.vars, f = I.duration, h = I.delay, v = I.immediateRender, b = I.stagger, S = I.overwrite, R = I.keyframes, W = I.defaults, x = I.scrollTrigger, M = I.yoyoEase, T = i.parent || Hs, E = (lg(n) || HL(n) ? Ym(n[0]) : "length" in i) ? [n] : FC(n), _, P, U, q, k, O, J, te;
    if (u._targets = E.length ? bY(E) : Ww("GSAP target " + n + " not found. https://gsap.com", !KI.nullTargetWarn) || [], u._ptLookup = [], u._overwrite = S, R || b || L1(f) || L1(h)) {
      if (i = u.vars, _ = u.timeline = new Lg({
        data: "nested",
        defaults: W || {},
        targets: T && T.data === "nested" ? T.vars.targets : E
      }), _.kill(), _.parent = _._dp = bm(u), _._start = 0, b || L1(f) || L1(h)) {
        if (q = E.length, J = b && qL(b), gp(b))
          for (k in b)
            ~I9.indexOf(k) && (te || (te = {}), te[k] = b[k]);
        for (P = 0; P < q; P++)
          U = k2(i, C9), U.stagger = 0, M && (U.yoyoEase = M), te && Gb(U, te), O = E[P], U.duration = +nw(f, bm(u), P, O, E), U.delay = (+nw(h, bm(u), P, O, E) || 0) - u._delay, !b && q === 1 && U.delay && (u._delay = h = U.delay, u._start += h, U.delay = 0), _.to(O, U, J ? J(P, O, E) : 0), _._ease = ma.none;
        _.duration() ? f = h = 0 : u.timeline = 0;
      } else if (R) {
        ew(TC(_.vars.defaults, {
          ease: "none"
        })), _._ease = fb(R.ease || i.ease || "none");
        var fe = 0, pe, Ae, Te;
        if (lg(R))
          R.forEach(function(Ke) {
            return _.to(E, Ke, ">");
          }), _.duration();
        else {
          U = {};
          for (k in R)
            k === "ease" || k === "easeEach" || hne(k, R[k], U, R.easeEach);
          for (k in U)
            for (pe = U[k].sort(function(Ke, je) {
              return Ke.t - je.t;
            }), fe = 0, P = 0; P < pe.length; P++)
              Ae = pe[P], Te = {
                ease: Ae.e,
                duration: (Ae.t - (P ? pe[P - 1].t : 0)) / 100 * f
              }, Te[k] = Ae.v, _.to(E, Te, fe), fe += Te.duration;
          _.duration() < f && _.to({}, {
            duration: f - _.duration()
          });
        }
      }
      f || u.duration(f = _.duration());
    } else
      u.timeline = 0;
    return S === !0 && !hY && (UA = bm(u), Hs.killTweensOf(E), UA = 0), tp(T, bm(u), o), i.reversed && u.reverse(), i.paused && u.paused(!0), (v || !f && !R && u._start === Tu(T._time) && Fd(v) && Ute(bm(u)) && T.data !== "nested") && (u._tTime = -Jo, u.render(Math.max(0, -h) || 0)), x && PL(bm(u), x), u;
  }
  var t = e.prototype;
  return t.render = function(i, o, l) {
    var u = this._time, I = this._tDur, f = this._dur, h = i < 0, v = i > I - Jo && !h ? I : i < Jo ? 0 : i, b, S, R, W, x, M, T, E, _;
    if (!f)
      Pte(this, i, o, l);
    else if (v !== this._tTime || !i || l || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h) {
      if (b = v, E = this.timeline, this._repeat) {
        if (W = f + this._rDelay, this._repeat < -1 && h)
          return this.totalTime(W * 100 + i, o, l);
        if (b = Tu(v % W), v === I ? (R = this._repeat, b = f) : (R = ~~(v / W), R && R === Tu(v / W) && (b = f, R--), b > f && (b = f)), M = this._yoyo && R & 1, M && (_ = this._yEase, b = f - b), x = aB(this._tTime, W), b === u && !l && this._initted && R === x)
          return this._tTime = v, this;
        R !== x && (E && this._yEase && u9(E, M), this.vars.repeatRefresh && !M && !this._lock && this._time !== W && this._initted && (this._lock = l = 1, this.render(Tu(W * R), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (JL(this, h ? i : b, l, o, v))
          return this._tTime = 0, this;
        if (u !== this._time && !(l && this.vars.repeatRefresh && R !== x))
          return this;
        if (f !== this._dur)
          return this.render(i, o, l);
      }
      if (this._tTime = v, this._time = b, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = T = (_ || this._ease)(b / f), this._from && (this.ratio = T = 1 - T), b && !u && !o && !R && (_I(this, "onStart"), this._tTime !== v))
        return this;
      for (S = this._pt; S; )
        S.r(T, S.d), S = S._next;
      E && E.render(i < 0 ? i : E._dur * E._ease(b / this._dur), o, l) || this._startAt && (this._zTime = i), this._onUpdate && !o && (h && QH(this, i, o, l), _I(this, "onUpdate")), this._repeat && R !== x && this.vars.onRepeat && !o && this.parent && _I(this, "onRepeat"), (v === this._tDur || !v) && this._tTime === v && (h && !this._onUpdate && QH(this, i, !0, !0), (i || !f) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && tv(this, 1), !o && !(h && !u) && (v || u || M) && (_I(this, v === I ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < I && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(i) {
    return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), a.prototype.invalidate.call(this, i);
  }, t.resetTo = function(i, o, l, u, I) {
    Mw || TI.wake(), this._ts || this.play();
    var f = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
    return this._initted || BY(this, f), h = this._ease(f / this._dur), Ine(this, i, o, l, u, h, f, I) ? this.resetTo(i, o, l, u, 1) : (UW(this, 0), this.parent || UL(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(i, o) {
    if (o === void 0 && (o = "all"), !i && (!o || o === "all"))
      return this._lazy = this._pt = 0, this.parent ? zZ(this) : this;
    if (this.timeline) {
      var l = this.timeline.totalDuration();
      return this.timeline.killTweensOf(i, o, UA && UA.vars.overwrite !== !0)._first || zZ(this), this.parent && l !== this.timeline.totalDuration() && oB(this, this._dur * this.timeline._tDur / l, 0, 1), this;
    }
    var u = this._targets, I = i ? FC(i) : u, f = this._ptLookup, h = this._pt, v, b, S, R, W, x, M;
    if ((!o || o === "all") && kte(u, I))
      return o === "all" && (this._pt = 0), zZ(this);
    for (v = this._op = this._op || [], o !== "all" && (Ku(o) && (W = {}, Ed(o, function(T) {
      return W[T] = 1;
    }), o = W), o = Cne(u, o)), M = u.length; M--; )
      if (~I.indexOf(u[M])) {
        b = f[M], o === "all" ? (v[M] = o, R = b, S = {}) : (S = v[M] = v[M] || {}, R = o);
        for (W in R)
          x = b && b[W], x && ((!("kill" in x.d) || x.d.kill(W) === !0) && kW(this, x, "_pt"), delete b[W]), S !== "all" && (S[W] = 1);
      }
    return this._initted && !this._pt && h && zZ(this), this;
  }, e.to = function(i, o) {
    return new e(i, o, arguments[2]);
  }, e.from = function(i, o) {
    return tw(1, arguments);
  }, e.delayedCall = function(i, o, l, u) {
    return new e(o, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: i,
      onComplete: o,
      onReverseComplete: o,
      onCompleteParams: l,
      onReverseCompleteParams: l,
      callbackScope: u
    });
  }, e.fromTo = function(i, o, l) {
    return tw(2, arguments);
  }, e.set = function(i, o) {
    return o.duration = 0, o.repeatDelay || (o.repeat = 0), new e(i, o);
  }, e.killTweensOf = function(i, o, l) {
    return Hs.killTweensOf(i, o, l);
  }, e;
}(Hw);
TC(Yl.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
Ed("staggerTo,staggerFrom,staggerFromTo", function(a) {
  Yl[a] = function() {
    var e = new Lg(), t = qH.call(arguments, 0);
    return t.splice(a === "staggerFromTo" ? 5 : 4, 0, 0), e[a].apply(e, t);
  };
});
var SY = function(e, t, n) {
  return e[t] = n;
}, h9 = function(e, t, n) {
  return e[t](n);
}, fne = function(e, t, n, i) {
  return e[t](i.fp, n);
}, pne = function(e, t, n) {
  return e.setAttribute(t, n);
}, ZY = function(e, t) {
  return il(e[t]) ? h9 : fY(e[t]) && e.setAttribute ? pne : SY;
}, f9 = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, mne = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, p9 = function(e, t) {
  var n = t._pt, i = "";
  if (!e && t.b)
    i = t.b;
  else if (e === 1 && t.e)
    i = t.e;
  else {
    for (; n; )
      i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
    i += t.c;
  }
  t.set(t.t, t.p, i, t);
}, wY = function(e, t) {
  for (var n = t._pt; n; )
    n.r(e, n.d), n = n._next;
}, Ane = function(e, t, n, i) {
  for (var o = this._pt, l; o; )
    l = o._next, o.p === i && o.modifier(e, t, n), o = l;
}, vne = function(e) {
  for (var t = this._pt, n, i; t; )
    i = t._next, t.p === e && !t.op || t.op === e ? kW(this, t, "_pt") : t.dep || (n = 1), t = i;
  return !n;
}, yne = function(e, t, n, i) {
  i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
}, m9 = function(e) {
  for (var t = e._pt, n, i, o, l; t; ) {
    for (n = t._next, i = o; i && i.pr > t.pr; )
      i = i._next;
    (t._prev = i ? i._prev : l) ? t._prev._next = t : o = t, (t._next = i) ? i._prev = t : l = t, t = n;
  }
  e._pt = o;
}, Td = /* @__PURE__ */ function() {
  function a(t, n, i, o, l, u, I, f, h) {
    this.t = n, this.s = o, this.c = l, this.p = i, this.r = u || f9, this.d = I || this, this.set = f || SY, this.pr = h || 0, this._next = t, t && (t._prev = this);
  }
  var e = a.prototype;
  return e.modifier = function(n, i, o) {
    this.mSet = this.mSet || this.set, this.set = yne, this.m = n, this.mt = o, this.tween = i;
  }, a;
}();
Ed(yY + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(a) {
  return vY[a] = 1;
});
LI.TweenMax = LI.TweenLite = Yl;
LI.TimelineLite = LI.TimelineMax = Lg;
Hs = new Lg({
  sortChildren: !1,
  defaults: rB,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
KI.stringFilter = s9;
var pb = [], t2 = {}, bne = [], H3 = 0, Gne = 0, sH = function(e) {
  return (t2[e] || bne).map(function(t) {
    return t();
  });
}, nX = function() {
  var e = Date.now(), t = [];
  e - H3 > 2 && (sH("matchMediaInit"), pb.forEach(function(n) {
    var i = n.queries, o = n.conditions, l, u, I, f;
    for (u in i)
      l = $f.matchMedia(i[u]).matches, l && (I = 1), l !== o[u] && (o[u] = l, f = 1);
    f && (n.revert(), I && t.push(n));
  }), sH("matchMediaRevert"), t.forEach(function(n) {
    return n.onMatch(n, function(i) {
      return n.add(null, i);
    });
  }), H3 = e, sH("matchMedia"));
}, A9 = /* @__PURE__ */ function() {
  function a(t, n) {
    this.selector = n && $H(n), this.data = [], this._r = [], this.isReverted = !1, this.id = Gne++, t && this.add(t);
  }
  var e = a.prototype;
  return e.add = function(n, i, o) {
    il(n) && (o = i, i = n, n = il);
    var l = this, u = function() {
      var f = hs, h = l.selector, v;
      return f && f !== l && f.data.push(l), o && (l.selector = $H(o)), hs = l, v = i.apply(l, arguments), il(v) && l._r.push(v), hs = f, l.selector = h, l.isReverted = !1, v;
    };
    return l.last = u, n === il ? u(l, function(I) {
      return l.add(null, I);
    }) : n ? l[n] = u : u;
  }, e.ignore = function(n) {
    var i = hs;
    hs = null, n(this), hs = i;
  }, e.getTweens = function() {
    var n = [];
    return this.data.forEach(function(i) {
      return i instanceof a ? n.push.apply(n, i.getTweens()) : i instanceof Yl && !(i.parent && i.parent.data === "nested") && n.push(i);
    }), n;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(n, i) {
    var o = this;
    if (n ? function() {
      for (var u = o.getTweens(), I = o.data.length, f; I--; )
        f = o.data[I], f.data === "isFlip" && (f.revert(), f.getChildren(!0, !0, !1).forEach(function(h) {
          return u.splice(u.indexOf(h), 1);
        }));
      for (u.map(function(h) {
        return {
          g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0,
          t: h
        };
      }).sort(function(h, v) {
        return v.g - h.g || -1 / 0;
      }).forEach(function(h) {
        return h.t.revert(n);
      }), I = o.data.length; I--; )
        f = o.data[I], f instanceof Lg ? f.data !== "nested" && (f.scrollTrigger && f.scrollTrigger.revert(), f.kill()) : !(f instanceof Yl) && f.revert && f.revert(n);
      o._r.forEach(function(h) {
        return h(n, o);
      }), o.isReverted = !0;
    }() : this.data.forEach(function(u) {
      return u.kill && u.kill();
    }), this.clear(), i)
      for (var l = pb.length; l--; )
        pb[l].id === this.id && pb.splice(l, 1);
  }, e.revert = function(n) {
    this.kill(n || {});
  }, a;
}(), Bne = /* @__PURE__ */ function() {
  function a(t) {
    this.contexts = [], this.scope = t, hs && hs.data.push(this);
  }
  var e = a.prototype;
  return e.add = function(n, i, o) {
    gp(n) || (n = {
      matches: n
    });
    var l = new A9(0, o || this.scope), u = l.conditions = {}, I, f, h;
    hs && !l.selector && (l.selector = hs.selector), this.contexts.push(l), i = l.add("onMatch", i), l.queries = n;
    for (f in n)
      f === "all" ? h = 1 : (I = $f.matchMedia(n[f]), I && (pb.indexOf(l) < 0 && pb.push(l), (u[f] = I.matches) && (h = 1), I.addListener ? I.addListener(nX) : I.addEventListener("change", nX)));
    return h && i(l, function(v) {
      return l.add(null, v);
    }), this;
  }, e.revert = function(n) {
    this.kill(n || {});
  }, e.kill = function(n) {
    this.contexts.forEach(function(i) {
      return i.kill(n, !0);
    });
  }, a;
}(), U2 = {
  registerPlugin: function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    t.forEach(function(i) {
      return r9(i);
    });
  },
  timeline: function(e) {
    return new Lg(e);
  },
  getTweensOf: function(e, t) {
    return Hs.getTweensOf(e, t);
  },
  getProperty: function(e, t, n, i) {
    Ku(e) && (e = FC(e)[0]);
    var o = Cb(e || {}).get, l = n ? DL : kL;
    return n === "native" && (n = ""), e && (t ? l((FI[t] && FI[t].get || o)(e, t, n, i)) : function(u, I, f) {
      return l((FI[u] && FI[u].get || o)(e, u, I, f));
    });
  },
  quickSetter: function(e, t, n) {
    if (e = FC(e), e.length > 1) {
      var i = e.map(function(h) {
        return Ld.quickSetter(h, t, n);
      }), o = i.length;
      return function(h) {
        for (var v = o; v--; )
          i[v](h);
      };
    }
    e = e[0] || {};
    var l = FI[t], u = Cb(e), I = u.harness && (u.harness.aliases || {})[t] || t, f = l ? function(h) {
      var v = new l();
      kG._pt = 0, v.init(e, n ? h + n : h, kG, 0, [e]), v.render(1, v), kG._pt && wY(1, kG);
    } : u.set(e, I);
    return l ? f : function(h) {
      return f(e, I, n ? h + n : h, u, 1);
    };
  },
  quickTo: function(e, t, n) {
    var i, o = Ld.to(e, Gb((i = {}, i[t] = "+=0.1", i.paused = !0, i), n || {})), l = function(I, f, h) {
      return o.resetTo(t, I, f, h);
    };
    return l.tween = o, l;
  },
  isTweening: function(e) {
    return Hs.getTweensOf(e, !0).length > 0;
  },
  defaults: function(e) {
    return e && e.ease && (e.ease = fb(e.ease, rB.ease)), x3(rB, e || {});
  },
  config: function(e) {
    return x3(KI, e || {});
  },
  registerEffect: function(e) {
    var t = e.name, n = e.effect, i = e.plugins, o = e.defaults, l = e.extendTimeline;
    (i || "").split(",").forEach(function(u) {
      return u && !FI[u] && !LI[u] && Ww(t + " effect requires " + u + " plugin.");
    }), iH[t] = function(u, I, f) {
      return n(FC(u), TC(I || {}, o), f);
    }, l && (Lg.prototype[t] = function(u, I, f) {
      return this.add(iH[t](u, gp(I) ? I : (f = I) && {}, this), f);
    });
  },
  registerEase: function(e, t) {
    ma[e] = fb(t);
  },
  parseEase: function(e, t) {
    return arguments.length ? fb(e, t) : ma;
  },
  getById: function(e) {
    return Hs.getById(e);
  },
  exportRoot: function(e, t) {
    e === void 0 && (e = {});
    var n = new Lg(e), i, o;
    for (n.smoothChildTiming = Fd(e.smoothChildTiming), Hs.remove(n), n._dp = 0, n._time = n._tTime = Hs._time, i = Hs._first; i; )
      o = i._next, (t || !(!i._dur && i instanceof Yl && i.vars.onComplete === i._targets[0])) && tp(n, i, i._start - i._delay), i = o;
    return tp(Hs, n, 0), n;
  },
  context: function(e, t) {
    return e ? new A9(e, t) : hs;
  },
  matchMedia: function(e) {
    return new Bne(e);
  },
  matchMediaRefresh: function() {
    return pb.forEach(function(e) {
      var t = e.conditions, n, i;
      for (i in t)
        t[i] && (t[i] = !1, n = 1);
      n && e.revert();
    }) || nX();
  },
  addEventListener: function(e, t) {
    var n = t2[e] || (t2[e] = []);
    ~n.indexOf(t) || n.push(t);
  },
  removeEventListener: function(e, t) {
    var n = t2[e], i = n && n.indexOf(t);
    i >= 0 && n.splice(i, 1);
  },
  utils: {
    wrap: nne,
    wrapYoyo: ine,
    distribute: qL,
    random: e9,
    snap: $L,
    normalize: tne,
    getUnit: ig,
    clamp: jte,
    splitColor: a9,
    toArray: FC,
    selector: $H,
    mapRange: n9,
    pipe: $te,
    unitize: ene,
    interpolate: rne,
    shuffle: jL
  },
  install: TL,
  effects: iH,
  ticker: TI,
  updateRoot: Lg.updateRoot,
  plugins: FI,
  globalTimeline: Hs,
  core: {
    PropTween: Td,
    globals: _L,
    Tween: Yl,
    Timeline: Lg,
    Animation: Hw,
    getCache: Cb,
    _removeLinkedListItem: kW,
    reverting: function() {
      return sg;
    },
    context: function(e) {
      return e && hs && (hs.data.push(e), e._ctx = hs), hs;
    },
    suppressOverwrites: function(e) {
      return hY = e;
    }
  }
};
Ed("to,from,fromTo,delayedCall,set,killTweensOf", function(a) {
  return U2[a] = Yl[a];
});
TI.add(Lg.updateRoot);
kG = U2.to({}, {
  duration: 0
});
var Sne = function(e, t) {
  for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
    n = n._next;
  return n;
}, Zne = function(e, t) {
  var n = e._targets, i, o, l;
  for (i in t)
    for (o = n.length; o--; )
      l = e._ptLookup[o][i], l && (l = l.d) && (l._pt && (l = Sne(l, i)), l && l.modifier && l.modifier(t[i], e, n[o], i));
}, lH = function(e, t) {
  return {
    name: e,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(i, o, l) {
      l._onInit = function(u) {
        var I, f;
        if (Ku(o) && (I = {}, Ed(o, function(h) {
          return I[h] = 1;
        }), o = I), t) {
          I = {};
          for (f in o)
            I[f] = t(o[f]);
          o = I;
        }
        Zne(u, o);
      };
    }
  };
}, Ld = U2.registerPlugin({
  name: "attr",
  init: function(e, t, n, i, o) {
    var l, u, I;
    this.tween = n;
    for (l in t)
      I = e.getAttribute(l) || "", u = this.add(e, "setAttribute", (I || 0) + "", t[l], i, o, 0, 0, l), u.op = l, u.b = I, this._props.push(l);
  },
  render: function(e, t) {
    for (var n = t._pt; n; )
      sg ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next;
  }
}, {
  name: "endArray",
  init: function(e, t) {
    for (var n = t.length; n--; )
      this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
  }
}, lH("roundProps", eX), lH("modifiers"), lH("snap", $L)) || U2;
Yl.version = Lg.version = Ld.version = "3.12.5";
EL = 1;
pY() && sB();
ma.Power0;
ma.Power1;
ma.Power2;
ma.Power3;
ma.Power4;
ma.Linear;
ma.Quad;
ma.Cubic;
ma.Quart;
ma.Quint;
ma.Strong;
ma.Elastic;
ma.Back;
ma.SteppedEase;
ma.Bounce;
ma.Sine;
ma.Expo;
ma.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var X3, OA, QG, RY, lb, Y3, xY, wne = function() {
  return typeof window < "u";
}, Fm = {}, jy = 180 / Math.PI, jG = Math.PI / 180, VG = Math.atan2, F3 = 1e8, WY = /([A-Z])/g, Rne = /(left|right|width|margin|padding|x)/i, xne = /[\s,\(]\S/, rp = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, iX = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, Wne = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, Vne = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, Nne = function(e, t) {
  var n = t.s + t.c * e;
  t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
}, v9 = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, y9 = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, Mne = function(e, t, n) {
  return e.style[t] = n;
}, Hne = function(e, t, n) {
  return e.style.setProperty(t, n);
}, Xne = function(e, t, n) {
  return e._gsap[t] = n;
}, Yne = function(e, t, n) {
  return e._gsap.scaleX = e._gsap.scaleY = n;
}, Fne = function(e, t, n, i, o) {
  var l = e._gsap;
  l.scaleX = l.scaleY = n, l.renderTransform(o, l);
}, Ene = function(e, t, n, i, o) {
  var l = e._gsap;
  l[t] = n, l.renderTransform(o, l);
}, Ys = "transform", _d = Ys + "Origin", Tne = function a(e, t) {
  var n = this, i = this.target, o = i.style, l = i._gsap;
  if (e in Fm && o) {
    if (this.tfm = this.tfm || {}, e !== "transform")
      e = rp[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(u) {
        return n.tfm[u] = Bm(i, u);
      }) : this.tfm[e] = l.x ? l[e] : Bm(i, e), e === _d && (this.tfm.zOrigin = l.zOrigin);
    else
      return rp.transform.split(",").forEach(function(u) {
        return a.call(n, u, t);
      });
    if (this.props.indexOf(Ys) >= 0)
      return;
    l.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(_d, t, "")), e = Ys;
  }
  (o || t) && this.props.push(e, t, o[e]);
}, b9 = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, _ne = function() {
  var e = this.props, t = this.target, n = t.style, i = t._gsap, o, l;
  for (o = 0; o < e.length; o += 3)
    e[o + 1] ? t[e[o]] = e[o + 2] : e[o + 2] ? n[e[o]] = e[o + 2] : n.removeProperty(e[o].substr(0, 2) === "--" ? e[o] : e[o].replace(WY, "-$1").toLowerCase());
  if (this.tfm) {
    for (l in this.tfm)
      i[l] = this.tfm[l];
    i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), o = xY(), (!o || !o.isStart) && !n[Ys] && (b9(n), i.zOrigin && n[_d] && (n[_d] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
  }
}, G9 = function(e, t) {
  var n = {
    target: e,
    props: [],
    revert: _ne,
    save: Tne
  };
  return e._gsap || Ld.core.getCache(e), t && t.split(",").forEach(function(i) {
    return n.save(i);
  }), n;
}, B9, rX = function(e, t) {
  var n = OA.createElementNS ? OA.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : OA.createElement(e);
  return n && n.style ? n : OA.createElement(e);
}, cp = function a(e, t, n) {
  var i = getComputedStyle(e);
  return i[t] || i.getPropertyValue(t.replace(WY, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && a(e, lB(t) || t, 1) || "";
}, E3 = "O,Moz,ms,Ms,Webkit".split(","), lB = function(e, t, n) {
  var i = t || lb, o = i.style, l = 5;
  if (e in o && !n)
    return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); l-- && !(E3[l] + e in o); )
    ;
  return l < 0 ? null : (l === 3 ? "ms" : l >= 0 ? E3[l] : "") + e;
}, aX = function() {
  wne() && window.document && (X3 = window, OA = X3.document, QG = OA.documentElement, lb = rX("div") || {
    style: {}
  }, rX("div"), Ys = lB(Ys), _d = Ys + "Origin", lb.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", B9 = !!lB("perspective"), xY = Ld.core.reverting, RY = 1);
}, uH = function a(e) {
  var t = rX("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = this.parentNode, i = this.nextSibling, o = this.style.cssText, l;
  if (QG.appendChild(t), t.appendChild(this), this.style.display = "block", e)
    try {
      l = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = a;
    } catch {
    }
  else this._gsapBBox && (l = this._gsapBBox());
  return n && (i ? n.insertBefore(this, i) : n.appendChild(this)), QG.removeChild(t), this.style.cssText = o, l;
}, T3 = function(e, t) {
  for (var n = t.length; n--; )
    if (e.hasAttribute(t[n]))
      return e.getAttribute(t[n]);
}, S9 = function(e) {
  var t;
  try {
    t = e.getBBox();
  } catch {
    t = uH.call(e, !0);
  }
  return t && (t.width || t.height) || e.getBBox === uH || (t = uH.call(e, !0)), t && !t.width && !t.x && !t.y ? {
    x: +T3(e, ["x", "cx", "x1"]) || 0,
    y: +T3(e, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, Z9 = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && S9(e));
}, Bb = function(e, t) {
  if (t) {
    var n = e.style, i;
    t in Fm && t !== _d && (t = Ys), n.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(i === "--" ? t : t.replace(WY, "-$1").toLowerCase())) : n.removeAttribute(t);
  }
}, PA = function(e, t, n, i, o, l) {
  var u = new Td(e._pt, t, n, 0, 1, l ? y9 : v9);
  return e._pt = u, u.b = i, u.e = o, e._props.push(n), u;
}, _3 = {
  deg: 1,
  rad: 1,
  turn: 1
}, zne = {
  grid: 1,
  flex: 1
}, nv = function a(e, t, n, i) {
  var o = parseFloat(n) || 0, l = (n + "").trim().substr((o + "").length) || "px", u = lb.style, I = Rne.test(t), f = e.tagName.toLowerCase() === "svg", h = (f ? "client" : "offset") + (I ? "Width" : "Height"), v = 100, b = i === "px", S = i === "%", R, W, x, M;
  if (i === l || !o || _3[i] || _3[l])
    return o;
  if (l !== "px" && !b && (o = a(e, t, n, "px")), M = e.getCTM && Z9(e), (S || l === "%") && (Fm[t] || ~t.indexOf("adius")))
    return R = M ? e.getBBox()[I ? "width" : "height"] : e[h], bl(S ? o / R * v : o / 100 * R);
  if (u[I ? "width" : "height"] = v + (b ? l : i), W = ~t.indexOf("adius") || i === "em" && e.appendChild && !f ? e : e.parentNode, M && (W = (e.ownerSVGElement || {}).parentNode), (!W || W === OA || !W.appendChild) && (W = OA.body), x = W._gsap, x && S && x.width && I && x.time === TI.time && !x.uncache)
    return bl(o / x.width * v);
  if (S && (t === "height" || t === "width")) {
    var T = e.style[t];
    e.style[t] = v + i, R = e[h], T ? e.style[t] = T : Bb(e, t);
  } else
    (S || l === "%") && !zne[cp(W, "display")] && (u.position = cp(e, "position")), W === e && (u.position = "static"), W.appendChild(lb), R = lb[h], W.removeChild(lb), u.position = "absolute";
  return I && S && (x = Cb(W), x.time = TI.time, x.width = W[h]), bl(b ? R * o / v : R && o ? v / R * o : 0);
}, Bm = function(e, t, n, i) {
  var o;
  return RY || aX(), t in rp && t !== "transform" && (t = rp[t], ~t.indexOf(",") && (t = t.split(",")[0])), Fm[t] && t !== "transform" ? (o = Yw(e, i), o = t !== "transformOrigin" ? o[t] : o.svg ? o.origin : P2(cp(e, _d)) + " " + o.zOrigin + "px") : (o = e.style[t], (!o || o === "auto" || i || ~(o + "").indexOf("calc(")) && (o = O2[t] && O2[t](e, t, n) || cp(e, t) || KL(e, t) || (t === "opacity" ? 1 : 0))), n && !~(o + "").trim().indexOf(" ") ? nv(e, t, o, n) + n : o;
}, Kne = function(e, t, n, i) {
  if (!n || n === "none") {
    var o = lB(t, e, 1), l = o && cp(e, o, 1);
    l && l !== n ? (t = o, n = l) : t === "borderColor" && (n = cp(e, "borderTopColor"));
  }
  var u = new Td(this._pt, e.style, t, 0, 1, p9), I = 0, f = 0, h, v, b, S, R, W, x, M, T, E, _, P;
  if (u.b = n, u.e = i, n += "", i += "", i === "auto" && (W = e.style[t], e.style[t] = i, i = cp(e, t) || i, W ? e.style[t] = W : Bb(e, t)), h = [n, i], s9(h), n = h[0], i = h[1], b = n.match(LG) || [], P = i.match(LG) || [], P.length) {
    for (; v = LG.exec(i); )
      x = v[0], T = i.substring(I, v.index), R ? R = (R + 1) % 5 : (T.substr(-5) === "rgba(" || T.substr(-5) === "hsla(") && (R = 1), x !== (W = b[f++] || "") && (S = parseFloat(W) || 0, _ = W.substr((S + "").length), x.charAt(1) === "=" && (x = JG(S, x) + _), M = parseFloat(x), E = x.substr((M + "").length), I = LG.lastIndex - E.length, E || (E = E || KI.units[t] || _, I === i.length && (i += E, u.e += E)), _ !== E && (S = nv(e, t, W, E) || 0), u._pt = {
        _next: u._pt,
        p: T || f === 1 ? T : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: S,
        c: M - S,
        m: R && R < 4 || t === "zIndex" ? Math.round : 0
      });
    u.c = I < i.length ? i.substring(I, i.length) : "";
  } else
    u.r = t === "display" && i === "none" ? y9 : v9;
  return YL.test(i) && (u.e = 0), this._pt = u, u;
}, z3 = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, Lne = function(e) {
  var t = e.split(" "), n = t[0], i = t[1] || "50%";
  return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = z3[n] || n, t[1] = z3[i] || i, t.join(" ");
}, kne = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var n = t.t, i = n.style, o = t.u, l = n._gsap, u, I, f;
    if (o === "all" || o === !0)
      i.cssText = "", I = 1;
    else
      for (o = o.split(","), f = o.length; --f > -1; )
        u = o[f], Fm[u] && (I = 1, u = u === "transformOrigin" ? _d : Ys), Bb(n, u);
    I && (Bb(n, Ys), l && (l.svg && n.removeAttribute("transform"), Yw(n, 1), l.uncache = 1, b9(i)));
  }
}, O2 = {
  clearProps: function(e, t, n, i, o) {
    if (o.data !== "isFromStart") {
      var l = e._pt = new Td(e._pt, t, n, 0, 0, kne);
      return l.u = i, l.pr = -10, l.tween = o, e._props.push(n), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, Xw = [1, 0, 0, 1, 0, 0], w9 = {}, R9 = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, K3 = function(e) {
  var t = cp(e, Ys);
  return R9(t) ? Xw : t.substr(7).match(XL).map(bl);
}, VY = function(e, t) {
  var n = e._gsap || Cb(e), i = e.style, o = K3(e), l, u, I, f;
  return n.svg && e.getAttribute("transform") ? (I = e.transform.baseVal.consolidate().matrix, o = [I.a, I.b, I.c, I.d, I.e, I.f], o.join(",") === "1,0,0,1,0,0" ? Xw : o) : (o === Xw && !e.offsetParent && e !== QG && !n.svg && (I = i.display, i.display = "block", l = e.parentNode, (!l || !e.offsetParent) && (f = 1, u = e.nextElementSibling, QG.appendChild(e)), o = K3(e), I ? i.display = I : Bb(e, "display"), f && (u ? l.insertBefore(e, u) : l ? l.appendChild(e) : QG.removeChild(e))), t && o.length > 6 ? [o[0], o[1], o[4], o[5], o[12], o[13]] : o);
}, oX = function(e, t, n, i, o, l) {
  var u = e._gsap, I = o || VY(e, !0), f = u.xOrigin || 0, h = u.yOrigin || 0, v = u.xOffset || 0, b = u.yOffset || 0, S = I[0], R = I[1], W = I[2], x = I[3], M = I[4], T = I[5], E = t.split(" "), _ = parseFloat(E[0]) || 0, P = parseFloat(E[1]) || 0, U, q, k, O;
  n ? I !== Xw && (q = S * x - R * W) && (k = _ * (x / q) + P * (-W / q) + (W * T - x * M) / q, O = _ * (-R / q) + P * (S / q) - (S * T - R * M) / q, _ = k, P = O) : (U = S9(e), _ = U.x + (~E[0].indexOf("%") ? _ / 100 * U.width : _), P = U.y + (~(E[1] || E[0]).indexOf("%") ? P / 100 * U.height : P)), i || i !== !1 && u.smooth ? (M = _ - f, T = P - h, u.xOffset = v + (M * S + T * W) - M, u.yOffset = b + (M * R + T * x) - T) : u.xOffset = u.yOffset = 0, u.xOrigin = _, u.yOrigin = P, u.smooth = !!i, u.origin = t, u.originIsAbsolute = !!n, e.style[_d] = "0px 0px", l && (PA(l, u, "xOrigin", f, _), PA(l, u, "yOrigin", h, P), PA(l, u, "xOffset", v, u.xOffset), PA(l, u, "yOffset", b, u.yOffset)), e.setAttribute("data-svg-origin", _ + " " + P);
}, Yw = function(e, t) {
  var n = e._gsap || new g9(e);
  if ("x" in n && !t && !n.uncache)
    return n;
  var i = e.style, o = n.scaleX < 0, l = "px", u = "deg", I = getComputedStyle(e), f = cp(e, _d) || "0", h, v, b, S, R, W, x, M, T, E, _, P, U, q, k, O, J, te, fe, pe, Ae, Te, Ke, je, ee, Ce, be, le, Ye, $e, ke, ot;
  return h = v = b = W = x = M = T = E = _ = 0, S = R = 1, n.svg = !!(e.getCTM && Z9(e)), I.translate && ((I.translate !== "none" || I.scale !== "none" || I.rotate !== "none") && (i[Ys] = (I.translate !== "none" ? "translate3d(" + (I.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (I.rotate !== "none" ? "rotate(" + I.rotate + ") " : "") + (I.scale !== "none" ? "scale(" + I.scale.split(" ").join(",") + ") " : "") + (I[Ys] !== "none" ? I[Ys] : "")), i.scale = i.rotate = i.translate = "none"), q = VY(e, n.svg), n.svg && (n.uncache ? (ee = e.getBBox(), f = n.xOrigin - ee.x + "px " + (n.yOrigin - ee.y) + "px", je = "") : je = !t && e.getAttribute("data-svg-origin"), oX(e, je || f, !!je || n.originIsAbsolute, n.smooth !== !1, q)), P = n.xOrigin || 0, U = n.yOrigin || 0, q !== Xw && (te = q[0], fe = q[1], pe = q[2], Ae = q[3], h = Te = q[4], v = Ke = q[5], q.length === 6 ? (S = Math.sqrt(te * te + fe * fe), R = Math.sqrt(Ae * Ae + pe * pe), W = te || fe ? VG(fe, te) * jy : 0, T = pe || Ae ? VG(pe, Ae) * jy + W : 0, T && (R *= Math.abs(Math.cos(T * jG))), n.svg && (h -= P - (P * te + U * pe), v -= U - (P * fe + U * Ae))) : (ot = q[6], $e = q[7], be = q[8], le = q[9], Ye = q[10], ke = q[11], h = q[12], v = q[13], b = q[14], k = VG(ot, Ye), x = k * jy, k && (O = Math.cos(-k), J = Math.sin(-k), je = Te * O + be * J, ee = Ke * O + le * J, Ce = ot * O + Ye * J, be = Te * -J + be * O, le = Ke * -J + le * O, Ye = ot * -J + Ye * O, ke = $e * -J + ke * O, Te = je, Ke = ee, ot = Ce), k = VG(-pe, Ye), M = k * jy, k && (O = Math.cos(-k), J = Math.sin(-k), je = te * O - be * J, ee = fe * O - le * J, Ce = pe * O - Ye * J, ke = Ae * J + ke * O, te = je, fe = ee, pe = Ce), k = VG(fe, te), W = k * jy, k && (O = Math.cos(k), J = Math.sin(k), je = te * O + fe * J, ee = Te * O + Ke * J, fe = fe * O - te * J, Ke = Ke * O - Te * J, te = je, Te = ee), x && Math.abs(x) + Math.abs(W) > 359.9 && (x = W = 0, M = 180 - M), S = bl(Math.sqrt(te * te + fe * fe + pe * pe)), R = bl(Math.sqrt(Ke * Ke + ot * ot)), k = VG(Te, Ke), T = Math.abs(k) > 2e-4 ? k * jy : 0, _ = ke ? 1 / (ke < 0 ? -ke : ke) : 0), n.svg && (je = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !R9(cp(e, Ys)), je && e.setAttribute("transform", je))), Math.abs(T) > 90 && Math.abs(T) < 270 && (o ? (S *= -1, T += W <= 0 ? 180 : -180, W += W <= 0 ? 180 : -180) : (R *= -1, T += T <= 0 ? 180 : -180)), t = t || n.uncache, n.x = h - ((n.xPercent = h && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + l, n.y = v - ((n.yPercent = v && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-v) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + l, n.z = b + l, n.scaleX = bl(S), n.scaleY = bl(R), n.rotation = bl(W) + u, n.rotationX = bl(x) + u, n.rotationY = bl(M) + u, n.skewX = T + u, n.skewY = E + u, n.transformPerspective = _ + l, (n.zOrigin = parseFloat(f.split(" ")[2]) || !t && n.zOrigin || 0) && (i[_d] = P2(f)), n.xOffset = n.yOffset = 0, n.force3D = KI.force3D, n.renderTransform = n.svg ? Une : B9 ? x9 : Dne, n.uncache = 0, n;
}, P2 = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, cH = function(e, t, n) {
  var i = ig(t);
  return bl(parseFloat(t) + parseFloat(nv(e, "x", n + "px", i))) + i;
}, Dne = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, x9(e, t);
}, Dy = "0deg", HZ = "0px", Uy = ") ", x9 = function(e, t) {
  var n = t || this, i = n.xPercent, o = n.yPercent, l = n.x, u = n.y, I = n.z, f = n.rotation, h = n.rotationY, v = n.rotationX, b = n.skewX, S = n.skewY, R = n.scaleX, W = n.scaleY, x = n.transformPerspective, M = n.force3D, T = n.target, E = n.zOrigin, _ = "", P = M === "auto" && e && e !== 1 || M === !0;
  if (E && (v !== Dy || h !== Dy)) {
    var U = parseFloat(h) * jG, q = Math.sin(U), k = Math.cos(U), O;
    U = parseFloat(v) * jG, O = Math.cos(U), l = cH(T, l, q * O * -E), u = cH(T, u, -Math.sin(U) * -E), I = cH(T, I, k * O * -E + E);
  }
  x !== HZ && (_ += "perspective(" + x + Uy), (i || o) && (_ += "translate(" + i + "%, " + o + "%) "), (P || l !== HZ || u !== HZ || I !== HZ) && (_ += I !== HZ || P ? "translate3d(" + l + ", " + u + ", " + I + ") " : "translate(" + l + ", " + u + Uy), f !== Dy && (_ += "rotate(" + f + Uy), h !== Dy && (_ += "rotateY(" + h + Uy), v !== Dy && (_ += "rotateX(" + v + Uy), (b !== Dy || S !== Dy) && (_ += "skew(" + b + ", " + S + Uy), (R !== 1 || W !== 1) && (_ += "scale(" + R + ", " + W + Uy), T.style[Ys] = _ || "translate(0, 0)";
}, Une = function(e, t) {
  var n = t || this, i = n.xPercent, o = n.yPercent, l = n.x, u = n.y, I = n.rotation, f = n.skewX, h = n.skewY, v = n.scaleX, b = n.scaleY, S = n.target, R = n.xOrigin, W = n.yOrigin, x = n.xOffset, M = n.yOffset, T = n.forceCSS, E = parseFloat(l), _ = parseFloat(u), P, U, q, k, O;
  I = parseFloat(I), f = parseFloat(f), h = parseFloat(h), h && (h = parseFloat(h), f += h, I += h), I || f ? (I *= jG, f *= jG, P = Math.cos(I) * v, U = Math.sin(I) * v, q = Math.sin(I - f) * -b, k = Math.cos(I - f) * b, f && (h *= jG, O = Math.tan(f - h), O = Math.sqrt(1 + O * O), q *= O, k *= O, h && (O = Math.tan(h), O = Math.sqrt(1 + O * O), P *= O, U *= O)), P = bl(P), U = bl(U), q = bl(q), k = bl(k)) : (P = v, k = b, U = q = 0), (E && !~(l + "").indexOf("px") || _ && !~(u + "").indexOf("px")) && (E = nv(S, "x", l, "px"), _ = nv(S, "y", u, "px")), (R || W || x || M) && (E = bl(E + R - (R * P + W * q) + x), _ = bl(_ + W - (R * U + W * k) + M)), (i || o) && (O = S.getBBox(), E = bl(E + i / 100 * O.width), _ = bl(_ + o / 100 * O.height)), O = "matrix(" + P + "," + U + "," + q + "," + k + "," + E + "," + _ + ")", S.setAttribute("transform", O), T && (S.style[Ys] = O);
}, One = function(e, t, n, i, o) {
  var l = 360, u = Ku(o), I = parseFloat(o) * (u && ~o.indexOf("rad") ? jy : 1), f = I - i, h = i + f + "deg", v, b;
  return u && (v = o.split("_")[1], v === "short" && (f %= l, f !== f % (l / 2) && (f += f < 0 ? l : -l)), v === "cw" && f < 0 ? f = (f + l * F3) % l - ~~(f / l) * l : v === "ccw" && f > 0 && (f = (f - l * F3) % l - ~~(f / l) * l)), e._pt = b = new Td(e._pt, t, n, i, f, Wne), b.e = h, b.u = "deg", e._props.push(n), b;
}, L3 = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, Pne = function(e, t, n) {
  var i = L3({}, n._gsap), o = "perspective,force3D,transformOrigin,svgOrigin", l = n.style, u, I, f, h, v, b, S, R;
  i.svg ? (f = n.getAttribute("transform"), n.setAttribute("transform", ""), l[Ys] = t, u = Yw(n, 1), Bb(n, Ys), n.setAttribute("transform", f)) : (f = getComputedStyle(n)[Ys], l[Ys] = t, u = Yw(n, 1), l[Ys] = f);
  for (I in Fm)
    f = i[I], h = u[I], f !== h && o.indexOf(I) < 0 && (S = ig(f), R = ig(h), v = S !== R ? nv(n, I, f, R) : parseFloat(f), b = parseFloat(h), e._pt = new Td(e._pt, u, I, v, b - v, iX), e._pt.u = R || 0, e._props.push(I));
  L3(u, i);
};
Ed("padding,margin,Width,Radius", function(a, e) {
  var t = "Top", n = "Right", i = "Bottom", o = "Left", l = (e < 3 ? [t, n, i, o] : [t + o, t + n, i + n, i + o]).map(function(u) {
    return e < 2 ? a + u : "border" + u + a;
  });
  O2[e > 1 ? "border" + a : a] = function(u, I, f, h, v) {
    var b, S;
    if (arguments.length < 4)
      return b = l.map(function(R) {
        return Bm(u, R, f);
      }), S = b.join(" "), S.split(b[0]).length === 5 ? b[0] : S;
    b = (h + "").split(" "), S = {}, l.forEach(function(R, W) {
      return S[R] = b[W] = b[W] || b[(W - 1) / 2 | 0];
    }), u.init(I, S, v);
  };
});
var W9 = {
  name: "css",
  register: aX,
  targetTest: function(e) {
    return e.style && e.nodeType;
  },
  init: function(e, t, n, i, o) {
    var l = this._props, u = e.style, I = n.vars.startAt, f, h, v, b, S, R, W, x, M, T, E, _, P, U, q, k;
    RY || aX(), this.styles = this.styles || G9(e), k = this.styles.props, this.tween = n;
    for (W in t)
      if (W !== "autoRound" && (h = t[W], !(FI[W] && d9(W, t, n, i, e, o)))) {
        if (S = typeof h, R = O2[W], S === "function" && (h = h.call(n, i, e, o), S = typeof h), S === "string" && ~h.indexOf("random(") && (h = Nw(h)), R)
          R(this, e, W, h, n) && (q = 1);
        else if (W.substr(0, 2) === "--")
          f = (getComputedStyle(e).getPropertyValue(W) + "").trim(), h += "", QA.lastIndex = 0, QA.test(f) || (x = ig(f), M = ig(h)), M ? x !== M && (f = nv(e, W, f, M) + M) : x && (h += x), this.add(u, "setProperty", f, h, i, o, 0, 0, W), l.push(W), k.push(W, 0, u[W]);
        else if (S !== "undefined") {
          if (I && W in I ? (f = typeof I[W] == "function" ? I[W].call(n, i, e, o) : I[W], Ku(f) && ~f.indexOf("random(") && (f = Nw(f)), ig(f + "") || f === "auto" || (f += KI.units[W] || ig(Bm(e, W)) || ""), (f + "").charAt(1) === "=" && (f = Bm(e, W))) : f = Bm(e, W), b = parseFloat(f), T = S === "string" && h.charAt(1) === "=" && h.substr(0, 2), T && (h = h.substr(2)), v = parseFloat(h), W in rp && (W === "autoAlpha" && (b === 1 && Bm(e, "visibility") === "hidden" && v && (b = 0), k.push("visibility", 0, u.visibility), PA(this, u, "visibility", b ? "inherit" : "hidden", v ? "inherit" : "hidden", !v)), W !== "scale" && W !== "transform" && (W = rp[W], ~W.indexOf(",") && (W = W.split(",")[0]))), E = W in Fm, E) {
            if (this.styles.save(W), _ || (P = e._gsap, P.renderTransform && !t.parseTransform || Yw(e, t.parseTransform), U = t.smoothOrigin !== !1 && P.smooth, _ = this._pt = new Td(this._pt, u, Ys, 0, 1, P.renderTransform, P, 0, -1), _.dep = 1), W === "scale")
              this._pt = new Td(this._pt, P, "scaleY", P.scaleY, (T ? JG(P.scaleY, T + v) : v) - P.scaleY || 0, iX), this._pt.u = 0, l.push("scaleY", W), W += "X";
            else if (W === "transformOrigin") {
              k.push(_d, 0, u[_d]), h = Lne(h), P.svg ? oX(e, h, 0, U, 0, this) : (M = parseFloat(h.split(" ")[2]) || 0, M !== P.zOrigin && PA(this, P, "zOrigin", P.zOrigin, M), PA(this, u, W, P2(f), P2(h)));
              continue;
            } else if (W === "svgOrigin") {
              oX(e, h, 1, U, 0, this);
              continue;
            } else if (W in w9) {
              One(this, P, W, b, T ? JG(b, T + h) : h);
              continue;
            } else if (W === "smoothOrigin") {
              PA(this, P, "smooth", P.smooth, h);
              continue;
            } else if (W === "force3D") {
              P[W] = h;
              continue;
            } else if (W === "transform") {
              Pne(this, h, e);
              continue;
            }
          } else W in u || (W = lB(W) || W);
          if (E || (v || v === 0) && (b || b === 0) && !xne.test(h) && W in u)
            x = (f + "").substr((b + "").length), v || (v = 0), M = ig(h) || (W in KI.units ? KI.units[W] : x), x !== M && (b = nv(e, W, f, M)), this._pt = new Td(this._pt, E ? P : u, W, b, (T ? JG(b, T + v) : v) - b, !E && (M === "px" || W === "zIndex") && t.autoRound !== !1 ? Nne : iX), this._pt.u = M || 0, x !== M && M !== "%" && (this._pt.b = f, this._pt.r = Vne);
          else if (W in u)
            Kne.call(this, e, W, f, T ? T + h : h);
          else if (W in e)
            this.add(e, W, f || e[W], T ? T + h : h, i, o);
          else if (W !== "parseTransform") {
            AY(W, h);
            continue;
          }
          E || (W in u ? k.push(W, 0, u[W]) : k.push(W, 1, f || e[W])), l.push(W);
        }
      }
    q && m9(this);
  },
  render: function(e, t) {
    if (t.tween._time || !xY())
      for (var n = t._pt; n; )
        n.r(e, n.d), n = n._next;
    else
      t.styles.revert();
  },
  get: Bm,
  aliases: rp,
  getSetter: function(e, t, n) {
    var i = rp[t];
    return i && i.indexOf(",") < 0 && (t = i), t in Fm && t !== _d && (e._gsap.x || Bm(e, "x")) ? n && Y3 === n ? t === "scale" ? Yne : Xne : (Y3 = n || {}) && (t === "scale" ? Fne : Ene) : e.style && !fY(e.style[t]) ? Mne : ~t.indexOf("-") ? Hne : ZY(e, t);
  },
  core: {
    _removeProperty: Bb,
    _getMatrix: VY
  }
};
Ld.utils.checkPrefix = lB;
Ld.core.getStyleSaver = G9;
(function(a, e, t, n) {
  var i = Ed(a + "," + e + "," + t, function(o) {
    Fm[o] = 1;
  });
  Ed(e, function(o) {
    KI.units[o] = "deg", w9[o] = 1;
  }), rp[i[13]] = a + "," + e, Ed(n, function(o) {
    var l = o.split(":");
    rp[l[1]] = i[l[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Ed("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(a) {
  KI.units[a] = "px";
});
Ld.registerPlugin(W9);
var V9 = Ld.registerPlugin(W9) || Ld;
V9.core.Tween;
const OW = (a) => {
  const e = pee(), [t, n] = xe.useState(!0), i = xe.useRef(null);
  return xe.useEffect(() => {
    if (i.current) {
      const o = a[e];
      V9.to(i.current.color, {
        r: parseInt(o.slice(1, 3), 16) / 255,
        g: parseInt(o.slice(3, 5), 16) / 255,
        b: parseInt(o.slice(5, 7), 16) / 255,
        duration: t ? 0 : 0.7,
        ease: "power1.inOut"
      });
    }
    t && n(!1);
  }, [e]), i;
}, N9 = (a) => a <= iB ? {
  position: [0, -0.42, 0],
  rotation: [-Math.PI / 2, 0, 0]
} : {
  position: [0, -1.3, 0],
  rotation: [-Math.PI / 2, 0, 0]
}, Jne = (a) => a <= iB ? {
  position: [0, 9.6, -10],
  rotation: [0, 0, 0]
} : {
  position: [0, 8.6, -10],
  rotation: [0, 0, 0]
}, Qne = (a) => a <= iB ? {
  position: [0, -0.7, -0.2],
  rotation: [-Math.PI / 2, 0, 0]
} : {
  position: [0, -1.6, -0.3],
  rotation: [-Math.PI / 2, 0, 0]
}, jne = () => {
  const { width: a } = Vb(), e = Qne(a), t = OW(VL);
  return /* @__PURE__ */ ze.jsxs("mesh", { position: e.position, rotation: e.rotation, receiveShadow: !0, castShadow: !0, children: [
    /* @__PURE__ */ ze.jsx("planeGeometry", { args: [50, 20, 1, 1] }),
    /* @__PURE__ */ ze.jsx("meshStandardMaterial", { ref: t, opacity: 0.5, transparent: !0 })
  ] });
}, qne = (a) => {
  const { width: e } = Vb(), t = N9(e), [n] = WL(() => t, xe.useRef(null));
  return /* @__PURE__ */ ze.jsxs("mesh", { ref: n, receiveShadow: !0, castShadow: !0, ...t, children: [
    /* @__PURE__ */ ze.jsx("planeGeometry", { args: [50, 20, 1, 1] }),
    /* @__PURE__ */ ze.jsx("meshStandardMaterial", { color: "white", opacity: 0, transparent: !0 })
  ] });
}, $ne = (a) => {
  const { width: e } = Vb(), t = Jne(e), n = OW(VL), [i] = WL(() => t, xe.useRef(null));
  return /* @__PURE__ */ ze.jsxs("mesh", { ref: i, receiveShadow: !0, castShadow: !0, ...t, children: [
    /* @__PURE__ */ ze.jsx("planeGeometry", { args: [54, 20, 1, 1] }),
    /* @__PURE__ */ ze.jsx("meshStandardMaterial", { ref: n })
  ] });
}, eie = (a) => {
  const { width: e } = Vb(), t = N9(e), n = xe.useRef(null), i = OW(Mte);
  return KW(({ clock: o }) => {
    if (!n.current)
      return;
    const l = o.getElapsedTime() * 0.12, u = n.current.attributes.position.array;
    for (let I = 0; I < u.length; I += 3) {
      const f = u[I], h = u[I + 1];
      u[I + 2] = Math.sin(f * 2 + l) * Math.cos(h * 2 + l) * 0.1;
    }
    n.current.attributes.position.needsUpdate = !0;
  }), /* @__PURE__ */ ze.jsxs("mesh", { castShadow: !0, ...t, children: [
    /* @__PURE__ */ ze.jsx("planeGeometry", { ref: n, args: [54, 20, 54, 20] }),
    /* @__PURE__ */ ze.jsx("meshStandardMaterial", { ref: i, wireframe: !0 })
  ] });
}, tie = (a) => {
  const [e] = wte(() => a, xe.useRef(null)), t = OW(Hte);
  return /* @__PURE__ */ ze.jsxs("mesh", { ref: e, receiveShadow: !0, castShadow: !0, children: [
    /* @__PURE__ */ ze.jsx("boxGeometry", { args: a.args }),
    /* @__PURE__ */ ze.jsx("meshStandardMaterial", { ref: t })
  ] });
}, nie = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (a) => {
  const e = Math.random() * 16 | 0;
  return (a === "x" ? e : e & 3 | 8).toString(16);
}), iie = () => Math.random() * (2 * Math.PI) - Math.PI, rie = () => {
  const a = [0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.8], e = Math.floor(Math.random() * a.length);
  return a[e];
}, aie = (a) => 6e-5 * a + -0.1367, oie = (a) => -44e-5 * a + 0.4336, sie = () => {
  const { scene: a, camera: e, gl: t } = Tg(), [n, i] = xe.useState([]), o = (l) => {
    const u = new oY(), I = new sn(), f = aie(t.domElement.clientWidth), h = oie(t.domElement.clientHeight);
    I.setX(l.clientX / t.domElement.clientWidth * 2 - 1 + f), I.setY(-(l.clientY / t.domElement.clientHeight * 2 - 1) + h), u.setFromCamera(I, e);
    const v = e.position.clone().add(u.ray.direction.clone().multiplyScalar(2)), b = u.ray.direction.clone().multiplyScalar(30);
    i((S) => {
      const R = rie(), W = iie(), x = {
        key: nie(),
        mass: 5,
        args: [R, R, R],
        position: v.toArray(),
        velocity: b.toArray(),
        rotation: [W, W, W]
      };
      return S.length >= 120 && S.shift(), [...S, x];
    });
  };
  return xe.useEffect(() => (t.domElement.addEventListener("pointerdown", o), () => {
    t.domElement.removeEventListener("pointerdown", o);
  }), [t, e, a]), /* @__PURE__ */ ze.jsx(ze.Fragment, { children: n.map((l) => /* @__PURE__ */ xe.createElement(tie, { ...l, key: l.key })) });
}, lie = () => {
  const a = xe.useRef(null);
  return a.current?.shadow.mapSize, xe.useEffect(() => {
    a.current && (a.current.shadow.mapSize.width = 2048, a.current.shadow.mapSize.height = 2048, a.current.shadow.bias = -1e-3, a.current.shadow.camera.left = -26, a.current.shadow.camera.right = 26, a.current.shadow.camera.top = 20, a.current.shadow.camera.bottom = -20, a.current.shadow.camera.near = 0, a.current.shadow.camera.far = 50);
  }, [a.current]), /* @__PURE__ */ ze.jsxs(xe.Suspense, { fallback: /* @__PURE__ */ ze.jsx(hee, {}), children: [
    /* @__PURE__ */ ze.jsx(Iee, { enableZoom: !1, enablePan: !1, enableRotate: !1, enableDamping: !1 }),
    /* @__PURE__ */ ze.jsx("ambientLight", { intensity: 1 }),
    /* @__PURE__ */ ze.jsx("directionalLight", { ref: a, position: [0, 5, 8], intensity: 0.8, castShadow: !0 }),
    /* @__PURE__ */ ze.jsx(jne, {}),
    /* @__PURE__ */ ze.jsx(eie, {}),
    /* @__PURE__ */ ze.jsxs(Nte, { children: [
      /* @__PURE__ */ ze.jsx(qne, {}),
      /* @__PURE__ */ ze.jsx($ne, {}),
      /* @__PURE__ */ ze.jsx(sie, {})
    ] })
  ] });
}, uie = ({ className: a }) => {
  const { width: e } = Vb();
  return /* @__PURE__ */ ze.jsxs(aee, { className: a, shadows: !0, children: [
    /* @__PURE__ */ ze.jsx(
      dee,
      {
        makeDefault: !0,
        rotation: [0, 1, 0],
        fov: 75,
        position: [0, e <= iB ? 0.8 : 0.7, 6],
        near: 1,
        far: 1e3
      }
    ),
    /* @__PURE__ */ ze.jsx(lie, {})
  ] }, String(e <= iB));
}, cie = () => {
  const [a, e] = xe.useState(!1);
  return xe.useEffect(() => {
    e(window.matchMedia("(pointer: coarse)").matches);
    const n = window.matchMedia("(pointer: coarse)"), i = (o) => {
      e(o.matches);
    };
    return n.addEventListener("change", i), () => {
      n.removeEventListener("change", i);
    };
  }, []), a;
}, M9 = ({ id: a, turnGray: e = !1, title: t, children: n, hoverState: i }) => {
  const [o, l] = i, u = cie(), I = o === a, f = o === "", h = () => u ? "" : I ? "opacity-100 bg-white/10 xs:bg-white/0 shadow-card xs:shadow-none" : f ? "opacity-80" : "opacity-40", v = () => "";
  return /* @__PURE__ */ ze.jsxs("div", { id: a.toString(), className: `cardFrame ${h()}`, onMouseEnter: () => l(a), children: [
    /* @__PURE__ */ ze.jsx("div", { className: `cardFrame-title ${v()}`, children: t }),
    /* @__PURE__ */ ze.jsx("div", { className: "grow flex flex-col h-auto justify-between gap-2", children: n })
  ] });
}, H9 = ({ tags: a, selectable: e = !1 }) => {
  const [t, n] = N5(), i = t.get("tags"), o = (l) => {
    if (!e)
      return;
    const u = i ? i.split(",") : [];
    if (u.includes(l.value)) {
      const I = u.filter((f) => f !== l.value);
      I.length > 0 ? t.set("tags", I.join(",")) : t.delete("tags");
    } else
      u.push(l.value), t.set("tags", u.join(","));
    n(t);
  };
  return /* @__PURE__ */ ze.jsx("ul", { className: "flex flex-row flex-wrap gap-2", children: a.map((l) => {
    const u = i?.includes(l.value);
    return /* @__PURE__ */ ze.jsx(
      "li",
      {
        className: `${u ? "chip-selected" : "chip-normal"} ${e ? "cursor-pointer" : "cursor-default"}`,
        onClick: (I) => {
          I.stopPropagation(), o(l);
        },
        children: l.name
      },
      l.value + u
    );
  }) });
}, gie = () => /* @__PURE__ */ ze.jsxs("div", { className: "copyright", children: [
  /* @__PURE__ */ ze.jsx("span", { className: "copyright-mark", children: "©" }),
  /* @__PURE__ */ ze.jsxs("svg", { className: "signature", viewBox: "0 0 134.67 56.18", children: [
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M19.38,41.6l-2.05.62a91.64,91.64,0,0,0-10,3.71,7.43,7.43,0,0,0-2.15,1.28S5,47.3,5,47.35a1,1,0,0,1-1.38-.07,1,1,0,0,1,0-1.39A4.3,4.3,0,0,1,5,44.72a51.66,51.66,0,0,1,8-3.49Q16.47,40,20.07,39a1.3,1.3,0,0,0,1-1,7.48,7.48,0,0,0,.36-2.81,2.84,2.84,0,0,1,0-.41,1,1,0,0,1,.85-1,1,1,0,0,1,1.1.68,4.53,4.53,0,0,1,.14,2.75c0,.17-.08.34-.11.51s.06.3.26.26a3.41,3.41,0,0,0,.46-.1L34.3,35.3a4.35,4.35,0,0,1,.52-.1,1.19,1.19,0,0,1,1.35.84,1.18,1.18,0,0,1-.73,1.37c-.65.29-1.32.55-2,.81-.47.19-1,0-1.44.07C29,39,25.89,39.77,22.85,40.6a.88.88,0,0,0-.63.54c-.3.65-.59,1.31-.92,2-.23.42-.12.61.29.79,1.61.69,3.24,1.32,4.82,2.06A75.71,75.71,0,0,1,35.18,51c3,1.92,6,3.8,8.94,5.7a2.46,2.46,0,0,1,.74.66,1.07,1.07,0,0,1,0,1.3,1.09,1.09,0,0,1-1.23.46,2.09,2.09,0,0,1-.63-.28c-4.69-3.18-9.49-6.2-14.34-9.14a75.19,75.19,0,0,0-8.2-4c-.36-.16-.52-.05-.69.25A36.68,36.68,0,0,1,17,50.2,79.28,79.28,0,0,1,8,60.55a3.08,3.08,0,0,1-1.15.66,1.36,1.36,0,0,1-1.59-.76c-.2-.55.08-1.06.74-1.39a7.92,7.92,0,0,0,2.12-1.88,71.2,71.2,0,0,0,9.76-12.51c.51-.89,1-1.81,1.45-2.72A1.79,1.79,0,0,0,19.38,41.6Z",
        transform: "translate(-4.88 -6.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M64.81,30.91c2.08-.61,4-1.22,6-1.76,2.79-.78,5.59-1.5,8.39-2.24a4.4,4.4,0,0,1,1.73-.2,1.22,1.22,0,0,1,1.2,1.41,1.43,1.43,0,0,1-1.73,1.16,2.45,2.45,0,0,0-1.47.09c-5.34,1.33-10.59,3-15.89,4.44a12.73,12.73,0,0,1-1.36.31,1.6,1.6,0,0,1-1.83-.81,1.54,1.54,0,0,1,.59-1.9c.94-.81,1.91-1.58,2.85-2.39a28.26,28.26,0,0,0,3.38-3.54.72.72,0,0,0,0-.85,24.13,24.13,0,0,1-1.78-4.49,2.18,2.18,0,0,1,.21-1.94c-.14-.18-.3-.09-.44-.1a1.42,1.42,0,0,1-1.39-2,16.39,16.39,0,0,1,1.21-2.45c.87-1.71,1.76-3.42,2.66-5.11a5.52,5.52,0,0,1,.74-1.05,1.12,1.12,0,0,1,1.53-.15,1,1,0,0,1,.12,1.41,16.37,16.37,0,0,0-1.6,3c-.54,1.08-1,2.16-1.57,3.29a1.14,1.14,0,0,0,.75-.18C69.2,14,71.2,13,73.31,12.26A5.5,5.5,0,0,1,74,12a1.11,1.11,0,0,1,1.29.65,1.09,1.09,0,0,1-.46,1.41,3.24,3.24,0,0,1-.63.29c-2.85,1-5.53,2.47-8.52,3.51.92.21,1.11.81,1.23,1.53a11.9,11.9,0,0,0,1.33,3.34c.11.22.24.25.38,0,1.08-1.63,2.51-3,3.07-5A1,1,0,0,1,73,17a1.16,1.16,0,0,1,.8,1.42A8.33,8.33,0,0,1,72.55,21c-.86,1.32-1.73,2.63-2.64,3.92a.9.9,0,0,0-.07,1.16,1.6,1.6,0,0,1,.32.8,1.06,1.06,0,0,1-.52,1,1.1,1.1,0,0,1-1.31-.09c-.21-.16-.36-.35-.61,0A35.21,35.21,0,0,1,65,30.66Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M19.78,16.74c.87-.32,1.74-.66,2.61-1s1.52-.48,2.28-.7a1.24,1.24,0,0,1,1.43.38,1.19,1.19,0,0,1,.08,1.38,1.21,1.21,0,0,1-1.29.7,2.14,2.14,0,0,0-1.08.21c-1.42.51-2.83,1.05-4.26,1.57a13,13,0,0,1-1.38.44c-.47.11-.47.33-.22.65l.07.09a1.05,1.05,0,0,1,0,1.59A1.26,1.26,0,0,1,16.24,22a3.16,3.16,0,0,1-.74-1.37c-.42-1.33-.83-2.67-1.2-4a47.58,47.58,0,0,1-1.22-5.76,1.59,1.59,0,0,0-.3-.74,2.12,2.12,0,0,1-.28-1.73,1.06,1.06,0,0,1,.88-.91A1.13,1.13,0,0,1,14.54,8a6,6,0,0,1,.64,2c.07.33,0,.83.29.93s.49-.37.74-.58A13.38,13.38,0,0,1,23.67,7a4.18,4.18,0,0,1,1.61.2A1.73,1.73,0,0,1,26.4,9.69a7.2,7.2,0,0,1-1.47,2.16,43.87,43.87,0,0,1-3.6,3.21A7.56,7.56,0,0,0,19.78,16.74Zm-3-.33c.24-.08.34-.31.47-.49a18.72,18.72,0,0,1,2.64-2.7,42.1,42.1,0,0,0,3.38-3c.17-.2.52-.44.4-.65s-.53-.1-.8-.05a12.75,12.75,0,0,0-5.34,2.72C16.2,13.29,16.09,14.65,16.81,16.41Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M47.85,34.64a12.72,12.72,0,0,0-1.87,2,1.09,1.09,0,0,1-1.27.6,1.13,1.13,0,0,1-.87-1,2.1,2.1,0,0,1,1.49-2.34,1.49,1.49,0,0,0,.68-.41,1.59,1.59,0,0,1,.29-.29c2.2-1.39,1.81-3.52,1.6-5.6,0-.15-.07-.3-.09-.46a1.11,1.11,0,0,1,.83-1.18,1.12,1.12,0,0,1,1.23.66,3.21,3.21,0,0,1,.26,1.3,4.66,4.66,0,0,0,.18,1.44c.72-.6,1.38-1.16,2-1.7a6.27,6.27,0,0,1,1.47-1,1.21,1.21,0,0,1,1.46.23,1.2,1.2,0,0,1,.21,1.36.74.74,0,0,1-.41.47,9.37,9.37,0,0,0-2.54,1.82c-.65.52-1.26,1.09-1.89,1.64a.92.92,0,0,0-.39.74A46.86,46.86,0,0,1,50,38.34a2.38,2.38,0,0,0,.9-.65c1.58-1.35,3.22-2.62,4.89-3.86a5.55,5.55,0,0,1,1.06-.6A1,1,0,0,1,58,35c-.7.62-1.44,1.19-2.17,1.77a72.28,72.28,0,0,0-6,4.94c-.69.67-1.32,1.42-2,2.1a1.21,1.21,0,0,1-1.42.4c-.94-.41-.86-1.53,0-2.25a2.3,2.3,0,0,0,.69-1.07A21.06,21.06,0,0,0,47.9,35,2.61,2.61,0,0,0,47.85,34.64Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M74.78,53.5l2.92-.63a2.26,2.26,0,0,1,1.21,0,1.18,1.18,0,0,1,.9,1.21,1.14,1.14,0,0,1-1.1,1,16.25,16.25,0,0,0-3,.6c-1.42.39-2.84.82-4.26,1.21a.7.7,0,0,0-.5.51,1.21,1.21,0,0,1-2.11.48,2.74,2.74,0,0,1-.64-1,6,6,0,0,1-.59-3.27,1.5,1.5,0,0,0-.11-.75c-.44-1.47-.89-2.93-1.3-4.41A1.13,1.13,0,0,1,67,47a1,1,0,0,1,1.4,1.13,5.09,5.09,0,0,0,.52,2c.13.38.32.09.44-.07a23.26,23.26,0,0,1,1.53-1.91,12,12,0,0,1,2.45-2,5.64,5.64,0,0,1,1.16-.56,2.15,2.15,0,0,1,3,2.62,10.42,10.42,0,0,1-1.66,4C75.5,52.57,75.18,53,74.78,53.5Zm-4.71,0c0,.19,0,.36.16.45s.25-.05.36-.12l1.31-1A7.86,7.86,0,0,0,75,48.45c0-.18.2-.42,0-.54s-.39.07-.56.18a13.08,13.08,0,0,0-4.2,4.81A3.54,3.54,0,0,0,70.07,53.47Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M24.17,27.29a17.27,17.27,0,0,0-5.35,1.26,53.13,53.13,0,0,1-5.27,1.85,4.37,4.37,0,0,1-1.39.16,2.3,2.3,0,0,1-2.2-2.8,7.54,7.54,0,0,1,1.3-3,1.44,1.44,0,0,1,1.42-.72,1,1,0,0,1,.83.8,1.5,1.5,0,0,1-.57,1.61,2,2,0,0,0-.73,1.27c-.13.48,0,.61.5.5A24.32,24.32,0,0,0,16,27.13a41.66,41.66,0,0,1,5.46-1.83A11,11,0,0,1,25,25a2.75,2.75,0,0,1,2.79,2A3.15,3.15,0,0,1,27,29.53a12.6,12.6,0,0,1-2.41,2.59,1.08,1.08,0,0,1-1.52.09,1.1,1.1,0,0,1,0-1.58c.62-.77,1.27-1.51,1.91-2.27a3.92,3.92,0,0,0,.25-.32c.32-.51.24-.69-.36-.74C24.64,27.28,24.4,27.29,24.17,27.29Z",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M97.06,45.6c.33-.11.42-.37.56-.56a5,5,0,0,1,2.58-1.81,2,2,0,0,1,2.11.4,1.9,1.9,0,0,1,.41,2.06,9.55,9.55,0,0,1-4.35,5.68,1.15,1.15,0,0,0-.64.77,1.09,1.09,0,0,1-1,.87,1.17,1.17,0,0,1-1.15-.75,1.55,1.55,0,0,1-.19-.84,24.88,24.88,0,0,0-.42-4.56,22.79,22.79,0,0,1,0-3.2A1.19,1.19,0,0,1,96,42.42a1,1,0,0,1,1.08,1.34A4.38,4.38,0,0,0,97.06,45.6Z",
        className: "scale-105 -translate-x-[10px] -translate-y-[7px]",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M96.6,15.72c.86-.4,1.55-.73,2.26-1a8.09,8.09,0,0,1,1.6-.52,1.55,1.55,0,0,1,1.22.26,1,1,0,0,1,.51,1.09,1,1,0,0,1-.83.87c-2.49.44-4.47,1.92-6.53,3.21-.46.29-.89.58-1.44.27A1.08,1.08,0,0,1,93,18.31a41.82,41.82,0,0,0,2.55-5.87,8,8,0,0,1,.63-1.24,1.12,1.12,0,0,1,1.25-.54,1.24,1.24,0,0,1,1,1.11A1,1,0,0,1,97.83,13a.7.7,0,0,0-.37.37C97.19,14.06,96.93,14.81,96.6,15.72Z",
        className: " scale-105 -translate-x-[10px] -translate-y-[7px]",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M100.61,20.76A1.49,1.49,0,0,1,102,22.22a1.14,1.14,0,0,1-1.29,1.23,1.14,1.14,0,0,0-.77.34l-4.21,3.66a3.16,3.16,0,0,1-.83.53,1,1,0,0,1-1.19-.21,1,1,0,0,1-.21-1.18,1.72,1.72,0,0,1,.29-.49c.42-.52.85-1,1.28-1.52.17-.18.34-.44.55-.49,1.27-.29,1.92-1.39,2.86-2.11a8.25,8.25,0,0,1,1.46-1A1.6,1.6,0,0,1,100.61,20.76Z",
        className: " scale-105 -translate-x-[10px] -translate-y-[7px]",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M101.84,29.54a1.39,1.39,0,0,1-.55,1,53.25,53.25,0,0,1-4.64,3.69,1.44,1.44,0,0,1-1.47.29,1,1,0,0,1-.72-.9,1.07,1.07,0,0,1,.63-1.1c1.76-.78,3-2.26,4.44-3.43a2.33,2.33,0,0,1,1-.6A1.13,1.13,0,0,1,101.84,29.54Z",
        className: " scale-105 -translate-x-[10px] -translate-y-[7px]",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M127.86,36.09c.54-1.28,1.06-2.56,1.62-3.81.83-1.82,1.67-3.63,2.52-5.45a3,3,0,0,1,.75-1.09,1,1,0,0,1,1.28-.07,1,1,0,0,1,.3,1.3c-1.89,3.73-3.3,7.66-4.93,11.51a2.52,2.52,0,0,0,0,2.1c1,2.45,2,4.89,3.2,7.25.11.22.24.43.38.69a.87.87,0,0,0,.27-.67,42.06,42.06,0,0,0,.37-4.35c0-1,.07-2,.13-3a2.31,2.31,0,0,1,.15-.68,1,1,0,0,1,1-.7,1.07,1.07,0,0,1,1,.78,1.29,1.29,0,0,1,.08.4,35.67,35.67,0,0,1-.55,8.75,4.64,4.64,0,0,1-.66,1.67A1.73,1.73,0,0,1,132,51a6.73,6.73,0,0,1-1.36-1.94c-1-1.87-1.81-3.78-2.62-5.72-.06-.16-.07-.35-.25-.45-.23.08-.21.31-.28.47-1.49,3.65-2.9,7.34-4.58,10.91a4.09,4.09,0,0,1-.71,1.12,1.44,1.44,0,0,1-1.8.34,1,1,0,0,1-.31-1.49,9,9,0,0,0,1.69-3.09c1.6-3.67,3-7.4,4.54-11.11a1.52,1.52,0,0,0,0-1.13,147.39,147.39,0,0,1-4.86-16.6c-.17-.72-.18-.73-.81-.37a62.64,62.64,0,0,0-6.16,3.77c-.3.22-.44.4-.22.75a.8.8,0,0,1,0,.79c-1,1.89-1.19,4-1.52,6.06-.08.48-.13,1-.21,1.53a9.12,9.12,0,0,1,1.18-.89,1.75,1.75,0,0,1,2.48.76,4.81,4.81,0,0,1,.49,3,10.37,10.37,0,0,1-1,3.39,2.06,2.06,0,0,1-1.26,1.14,1.21,1.21,0,0,1-1.38-.49,1.12,1.12,0,0,1,.25-1.38c.95-1.07,1-2.4,1.11-3.82a1.14,1.14,0,0,0-.65.6,11.12,11.12,0,0,0-2.39,4.73,10.31,10.31,0,0,1-.7,2.23A1.8,1.8,0,0,1,110,45a1.15,1.15,0,0,1-1.77-.44,1.77,1.77,0,0,1-.13-1.24,7.9,7.9,0,0,1,.68-2,12.76,12.76,0,0,0,1.11-4.32,52.64,52.64,0,0,1,1.66-8.81c.11-.32,0-.39-.3-.43a1,1,0,0,1-.86-.83,1,1,0,0,1,.44-1.07,67.81,67.81,0,0,1,7.28-5c.71-.4,1.4-.82,2.13-1.2a.6.6,0,0,0,.37-.78,58.43,58.43,0,0,0-2-7.26,6.07,6.07,0,0,0-.24-.59,1,1,0,0,1,.32-1.47,1.13,1.13,0,0,1,1.55.48,8.19,8.19,0,0,1,.5,1.18,53.65,53.65,0,0,1,1.85,6.19c.2.8.2.79.94.38a8.5,8.5,0,0,1,1.09-.54,1.12,1.12,0,0,1,1.48.54,1.14,1.14,0,0,1-.54,1.53c-.56.31-1.12.63-1.69.92a.68.68,0,0,0-.39.89c.81,3.56,1.72,7.1,2.78,10.59.4,1.32.84,2.63,1.27,3.94C127.65,35.73,127.65,35.94,127.86,36.09Z",
        className: " scale-110 -translate-x-[14px] -translate-y-2",
        transform: "translate(-3.28 -5.08)"
      }
    ),
    /* @__PURE__ */ ze.jsx(
      "path",
      {
        d: "M135,9a1,1,0,0,1-1.26,1,2,2,0,0,1-1.29-1.09,10.24,10.24,0,0,0-1.22-1.9,1.07,1.07,0,0,1,.13-1.68,1.22,1.22,0,0,1,1.66.43c.66.84,1.09,1.83,1.75,2.66A1.18,1.18,0,0,1,135,9Z",
        className: " scale-110 -translate-x-[18px] -translate-y-[6px]",
        transform: "translate(-3.28 -5.08)"
      }
    )
  ] })
] }), die = (...a) => {
  console?.warn && (mb(a[0]) && (a[0] = `react-i18next:: ${a[0]}`), console.warn(...a));
}, k3 = {}, sX = (...a) => {
  mb(a[0]) && k3[a[0]] || (mb(a[0]) && (k3[a[0]] = /* @__PURE__ */ new Date()), die(...a));
}, X9 = (a, e) => () => {
  if (a.isInitialized)
    e();
  else {
    const t = () => {
      setTimeout(() => {
        a.off("initialized", t);
      }, 0), e();
    };
    a.on("initialized", t);
  }
}, D3 = (a, e, t) => {
  a.loadNamespaces(e, X9(a, t));
}, U3 = (a, e, t, n) => {
  mb(t) && (t = [t]), t.forEach((i) => {
    a.options.ns.indexOf(i) < 0 && a.options.ns.push(i);
  }), a.loadLanguages(e, X9(a, n));
}, Iie = (a, e, t = {}) => !e.languages || !e.languages.length ? (sX("i18n.languages were undefined or empty", e.languages), !0) : e.hasLoadedNamespace(a, {
  lng: t.lng,
  precheck: (n, i) => {
    if (t.bindI18n?.indexOf("languageChanging") > -1 && n.services.backendConnector.backend && n.isLanguageChangingTo && !i(n.isLanguageChangingTo, a)) return !1;
  }
}), mb = (a) => typeof a == "string", Cie = (a) => typeof a == "object" && a !== null, hie = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, fie = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
}, pie = (a) => fie[a], mie = (a) => a.replace(hie, pie);
let lX = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: mie
};
const Aie = (a = {}) => {
  lX = {
    ...lX,
    ...a
  };
}, vie = () => lX;
let Y9;
const yie = (a) => {
  Y9 = a;
}, bie = () => Y9, Gie = {
  type: "3rdParty",
  init(a) {
    Aie(a.options.react), yie(a);
  }
}, Bie = xe.createContext();
class Sie {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(e) {
    e.forEach((t) => {
      this.usedNamespaces[t] ??= !0;
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const Zie = (a, e) => {
  const t = xe.useRef();
  return xe.useEffect(() => {
    t.current = a;
  }, [a, e]), t.current;
}, F9 = (a, e, t, n) => a.getFixedT(e, t, n), wie = (a, e, t, n) => xe.useCallback(F9(a, e, t, n), [a, e, t, n]), Lu = (a, e = {}) => {
  const {
    i18n: t
  } = e, {
    i18n: n,
    defaultNS: i
  } = xe.useContext(Bie) || {}, o = t || n || bie();
  if (o && !o.reportNamespaces && (o.reportNamespaces = new Sie()), !o) {
    sX("You will need to pass in an i18next instance by using initReactI18next");
    const _ = (U, q) => mb(q) ? q : Cie(q) && mb(q.defaultValue) ? q.defaultValue : Array.isArray(U) ? U[U.length - 1] : U, P = [_, {}, !1];
    return P.t = _, P.i18n = {}, P.ready = !1, P;
  }
  o.options.react?.wait && sX("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const l = {
    ...vie(),
    ...o.options.react,
    ...e
  }, {
    useSuspense: u,
    keyPrefix: I
  } = l;
  let f = i || o.options?.defaultNS;
  f = mb(f) ? [f] : f || ["translation"], o.reportNamespaces.addUsedNamespaces?.(f);
  const h = (o.isInitialized || o.initializedStoreOnce) && f.every((_) => Iie(_, o, l)), v = wie(o, e.lng || null, l.nsMode === "fallback" ? f : f[0], I), b = () => v, S = () => F9(o, e.lng || null, l.nsMode === "fallback" ? f : f[0], I), [R, W] = xe.useState(b);
  let x = f.join();
  e.lng && (x = `${e.lng}${x}`);
  const M = Zie(x), T = xe.useRef(!0);
  xe.useEffect(() => {
    const {
      bindI18n: _,
      bindI18nStore: P
    } = l;
    T.current = !0, !h && !u && (e.lng ? U3(o, e.lng, f, () => {
      T.current && W(S);
    }) : D3(o, f, () => {
      T.current && W(S);
    })), h && M && M !== x && T.current && W(S);
    const U = () => {
      T.current && W(S);
    };
    return _ && o?.on(_, U), P && o?.store.on(P, U), () => {
      T.current = !1, o && _?.split(" ").forEach((q) => o.off(q, U)), P && o && P.split(" ").forEach((q) => o.store.off(q, U));
    };
  }, [o, x]), xe.useEffect(() => {
    T.current && h && W(b);
  }, [o, I, h]);
  const E = [R, o, h];
  if (E.t = R, E.i18n = o, E.ready = h, h || !h && !u) return E;
  throw new Promise((_) => {
    e.lng ? U3(o, e.lng, f, () => _()) : D3(o, f, () => _());
  });
};
var E9 = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, O3 = ag.createContext && /* @__PURE__ */ ag.createContext(E9), Rie = ["attr", "size", "title"];
function xie(a, e) {
  if (a == null) return {};
  var t = Wie(a, e), n, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(a);
    for (i = 0; i < o.length; i++)
      n = o[i], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(a, n) && (t[n] = a[n]);
  }
  return t;
}
function Wie(a, e) {
  if (a == null) return {};
  var t = {};
  for (var n in a)
    if (Object.prototype.hasOwnProperty.call(a, n)) {
      if (e.indexOf(n) >= 0) continue;
      t[n] = a[n];
    }
  return t;
}
function J2() {
  return J2 = Object.assign ? Object.assign.bind() : function(a) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (a[n] = t[n]);
    }
    return a;
  }, J2.apply(this, arguments);
}
function P3(a, e) {
  var t = Object.keys(a);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(a);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(a, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Q2(a) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? P3(Object(t), !0).forEach(function(n) {
      Vie(a, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(t)) : P3(Object(t)).forEach(function(n) {
      Object.defineProperty(a, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return a;
}
function Vie(a, e, t) {
  return e = Nie(e), e in a ? Object.defineProperty(a, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = t, a;
}
function Nie(a) {
  var e = Mie(a, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Mie(a, e) {
  if (typeof a != "object" || !a) return a;
  var t = a[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(a, e || "default");
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(a);
}
function T9(a) {
  return a && a.map((e, t) => /* @__PURE__ */ ag.createElement(e.tag, Q2({
    key: t
  }, e.attr), T9(e.child)));
}
function Mb(a) {
  return (e) => /* @__PURE__ */ ag.createElement(Hie, J2({
    attr: Q2({}, a.attr)
  }, e), T9(a.child));
}
function Hie(a) {
  var e = (t) => {
    var {
      attr: n,
      size: i,
      title: o
    } = a, l = xie(a, Rie), u = i || t.size || "1em", I;
    return t.className && (I = t.className), a.className && (I = (I ? I + " " : "") + a.className), /* @__PURE__ */ ag.createElement("svg", J2({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, t.attr, n, l, {
      className: I,
      style: Q2(Q2({
        color: a.color || t.color
      }, t.style), a.style),
      height: u,
      width: u,
      xmlns: "http://www.w3.org/2000/svg"
    }), o && /* @__PURE__ */ ag.createElement("title", null, o), a.children);
  };
  return O3 !== void 0 ? /* @__PURE__ */ ag.createElement(O3.Consumer, null, (t) => e(t)) : e(E9);
}
function Xie(a) {
  return Mb({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z" }, child: [] }] })(a);
}
function Yie(a) {
  return Mb({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z" }, child: [] }] })(a);
}
function Fie(a) {
  return Mb({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M480 416v16c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V176c0-26.51 21.49-48 48-48h16v48H54a6 6 0 0 0-6 6v244a6 6 0 0 0 6 6h372a6 6 0 0 0 6-6v-10h48zm42-336H150a6 6 0 0 0-6 6v244a6 6 0 0 0 6 6h372a6 6 0 0 0 6-6V86a6 6 0 0 0-6-6zm6-48c26.51 0 48 21.49 48 48v256c0 26.51-21.49 48-48 48H144c-26.51 0-48-21.49-48-48V80c0-26.51 21.49-48 48-48h384zM264 144c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.909-40 40-40 40 17.909 40 40zm-72 96l39.515-39.515c4.686-4.686 12.284-4.686 16.971 0L288 240l103.515-103.515c4.686-4.686 12.284-4.686 16.971 0L480 208v80H192v-48z" }, child: [] }] })(a);
}
const Eie = (a, e, t = []) => {
  const { current: n } = xe.useRef({ callback: a, timer: null });
  return xe.useEffect(() => {
    n.callback = a;
  }, [a]), xe.useCallback((...i) => {
    n.timer || (n.timer = setTimeout(() => {
      n.timer = null;
    }, e), n.callback(...i));
  }, t);
}, Tie = ({ url: a, children: e }) => {
  const { t } = Lu(), n = Sb(), o = Pg().pathname === a, { width: l } = Vb(), u = Eie(() => {
    n(o ? ng.HOME : a);
  }, 400);
  return /* @__PURE__ */ ze.jsx("button", { className: `linkBtn${o ? "--active" : ""}`, onClick: u, children: o && l > iB ? /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
    /* @__PURE__ */ ze.jsx(Yie, { size: "14px" }),
    t("nav_home")
  ] }) : t(e) });
}, _ie = {
  type: "logger",
  log(a) {
    this.output("log", a);
  },
  warn(a) {
    this.output("warn", a);
  },
  error(a) {
    this.output("error", a);
  },
  output(a, e) {
    console && console[a] && console[a].apply(console, e);
  }
};
class j2 {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(e, t);
  }
  init(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = t.prefix || "i18next:", this.logger = e || _ie, this.options = t, this.debug = t.debug;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "log", "", !0);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "", !0);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(e, t, n, i) {
    return i && !this.debug ? null : (typeof e[0] == "string" && (e[0] = `${n}${this.prefix} ${e[0]}`), this.logger[t](e));
  }
  create(e) {
    return new j2(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options
    });
  }
  clone(e) {
    return e = e || this.options, e.prefix = e.prefix || this.prefix, new j2(this.logger, e);
  }
}
var ap = new j2();
class PW {
  constructor() {
    this.observers = {};
  }
  on(e, t) {
    return e.split(" ").forEach((n) => {
      this.observers[n] || (this.observers[n] = /* @__PURE__ */ new Map());
      const i = this.observers[n].get(t) || 0;
      this.observers[n].set(t, i + 1);
    }), this;
  }
  off(e, t) {
    if (this.observers[e]) {
      if (!t) {
        delete this.observers[e];
        return;
      }
      this.observers[e].delete(t);
    }
  }
  emit(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    this.observers[e] && Array.from(this.observers[e].entries()).forEach((l) => {
      let [u, I] = l;
      for (let f = 0; f < I; f++)
        u(...n);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((l) => {
      let [u, I] = l;
      for (let f = 0; f < I; f++)
        u.apply(u, [e, ...n]);
    });
  }
}
const XZ = () => {
  let a, e;
  const t = new Promise((n, i) => {
    a = n, e = i;
  });
  return t.resolve = a, t.reject = e, t;
}, J3 = (a) => a == null ? "" : "" + a, zie = (a, e, t) => {
  a.forEach((n) => {
    e[n] && (t[n] = e[n]);
  });
}, Kie = /###/g, Q3 = (a) => a && a.indexOf("###") > -1 ? a.replace(Kie, ".") : a, j3 = (a) => !a || typeof a == "string", iw = (a, e, t) => {
  const n = typeof e != "string" ? e : e.split(".");
  let i = 0;
  for (; i < n.length - 1; ) {
    if (j3(a)) return {};
    const o = Q3(n[i]);
    !a[o] && t && (a[o] = new t()), Object.prototype.hasOwnProperty.call(a, o) ? a = a[o] : a = {}, ++i;
  }
  return j3(a) ? {} : {
    obj: a,
    k: Q3(n[i])
  };
}, q3 = (a, e, t) => {
  const {
    obj: n,
    k: i
  } = iw(a, e, Object);
  if (n !== void 0 || e.length === 1) {
    n[i] = t;
    return;
  }
  let o = e[e.length - 1], l = e.slice(0, e.length - 1), u = iw(a, l, Object);
  for (; u.obj === void 0 && l.length; )
    o = `${l[l.length - 1]}.${o}`, l = l.slice(0, l.length - 1), u = iw(a, l, Object), u && u.obj && typeof u.obj[`${u.k}.${o}`] < "u" && (u.obj = void 0);
  u.obj[`${u.k}.${o}`] = t;
}, Lie = (a, e, t, n) => {
  const {
    obj: i,
    k: o
  } = iw(a, e, Object);
  i[o] = i[o] || [], i[o].push(t);
}, q2 = (a, e) => {
  const {
    obj: t,
    k: n
  } = iw(a, e);
  if (t)
    return t[n];
}, kie = (a, e, t) => {
  const n = q2(a, t);
  return n !== void 0 ? n : q2(e, t);
}, _9 = (a, e, t) => {
  for (const n in e)
    n !== "__proto__" && n !== "constructor" && (n in a ? typeof a[n] == "string" || a[n] instanceof String || typeof e[n] == "string" || e[n] instanceof String ? t && (a[n] = e[n]) : _9(a[n], e[n], t) : a[n] = e[n]);
  return a;
}, NG = (a) => a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var Die = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const Uie = (a) => typeof a == "string" ? a.replace(/[&<>"'\/]/g, (e) => Die[e]) : a;
class Oie {
  constructor(e) {
    this.capacity = e, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(e) {
    const t = this.regExpMap.get(e);
    if (t !== void 0)
      return t;
    const n = new RegExp(e);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, n), this.regExpQueue.push(e), n;
  }
}
const Pie = [" ", ",", "?", "!", ";"], Jie = new Oie(20), Qie = (a, e, t) => {
  e = e || "", t = t || "";
  const n = Pie.filter((l) => e.indexOf(l) < 0 && t.indexOf(l) < 0);
  if (n.length === 0) return !0;
  const i = Jie.getRegExp(`(${n.map((l) => l === "?" ? "\\?" : l).join("|")})`);
  let o = !i.test(a);
  if (!o) {
    const l = a.indexOf(t);
    l > 0 && !i.test(a.substring(0, l)) && (o = !0);
  }
  return o;
}, uX = function(a, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!a) return;
  if (a[e]) return a[e];
  const n = e.split(t);
  let i = a;
  for (let o = 0; o < n.length; ) {
    if (!i || typeof i != "object")
      return;
    let l, u = "";
    for (let I = o; I < n.length; ++I)
      if (I !== o && (u += t), u += n[I], l = i[u], l !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof l) > -1 && I < n.length - 1)
          continue;
        o += I - o + 1;
        break;
      }
    i = l;
  }
  return i;
}, $2 = (a) => a && a.indexOf("_") > 0 ? a.replace("_", "-") : a;
class $3 extends PW {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const t = this.options.ns.indexOf(e);
    t > -1 && this.options.ns.splice(t, 1);
  }
  getResource(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, l = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let u;
    e.indexOf(".") > -1 ? u = e.split(".") : (u = [e, t], n && (Array.isArray(n) ? u.push(...n) : typeof n == "string" && o ? u.push(...n.split(o)) : u.push(n)));
    const I = q2(this.data, u);
    return !I && !t && !n && e.indexOf(".") > -1 && (e = u[0], t = u[1], n = u.slice(2).join(".")), I || !l || typeof n != "string" ? I : uX(this.data && this.data[e] && this.data[e][t], n, o);
  }
  addResource(e, t, n, i) {
    let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const l = o.keySeparator !== void 0 ? o.keySeparator : this.options.keySeparator;
    let u = [e, t];
    n && (u = u.concat(l ? n.split(l) : n)), e.indexOf(".") > -1 && (u = e.split("."), i = t, t = u[1]), this.addNamespaces(t), q3(this.data, u, i), o.silent || this.emit("added", e, t, n, i);
  }
  addResources(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const o in n)
      (typeof n[o] == "string" || Array.isArray(n[o])) && this.addResource(e, t, o, n[o], {
        silent: !0
      });
    i.silent || this.emit("added", e, t, n);
  }
  addResourceBundle(e, t, n, i, o) {
    let l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, u = [e, t];
    e.indexOf(".") > -1 && (u = e.split("."), i = n, n = t, t = u[1]), this.addNamespaces(t);
    let I = q2(this.data, u) || {};
    l.skipCopy || (n = JSON.parse(JSON.stringify(n))), i ? _9(I, n, o) : I = {
      ...I,
      ...n
    }, q3(this.data, u, I), l.silent || this.emit("added", e, t, n);
  }
  removeResourceBundle(e, t) {
    this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t);
  }
  hasResourceBundle(e, t) {
    return this.getResource(e, t) !== void 0;
  }
  getResourceBundle(e, t) {
    return t || (t = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(e, t)
    } : this.getResource(e, t);
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const t = this.getDataByLanguage(e);
    return !!(t && Object.keys(t) || []).find((i) => t[i] && Object.keys(t[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var z9 = {
  processors: {},
  addPostProcessor(a) {
    this.processors[a.name] = a;
  },
  handle(a, e, t, n, i) {
    return a.forEach((o) => {
      this.processors[o] && (e = this.processors[o].process(e, t, n, i));
    }), e;
  }
};
const e5 = {};
class eW extends PW {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), zie(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = ap.create("translator");
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (e == null)
      return !1;
    const n = this.resolve(e, t);
    return n && n.res !== void 0;
  }
  extractFromKey(e, t) {
    let n = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
    n === void 0 && (n = ":");
    const i = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator;
    let o = t.ns || this.options.defaultNS || [];
    const l = n && e.indexOf(n) > -1, u = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !Qie(e, n, i);
    if (l && !u) {
      const I = e.match(this.interpolator.nestingRegexp);
      if (I && I.length > 0)
        return {
          key: e,
          namespaces: o
        };
      const f = e.split(n);
      (n !== i || n === i && this.options.ns.indexOf(f[0]) > -1) && (o = f.shift()), e = f.join(i);
    }
    return typeof o == "string" && (o = [o]), {
      key: e,
      namespaces: o
    };
  }
  translate(e, t, n) {
    if (typeof t != "object" && this.options.overloadTranslationOptionHandler && (t = this.options.overloadTranslationOptionHandler(arguments)), typeof t == "object" && (t = {
      ...t
    }), t || (t = {}), e == null) return "";
    Array.isArray(e) || (e = [String(e)]);
    const i = t.returnDetails !== void 0 ? t.returnDetails : this.options.returnDetails, o = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator, {
      key: l,
      namespaces: u
    } = this.extractFromKey(e[e.length - 1], t), I = u[u.length - 1], f = t.lng || this.language, h = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (f && f.toLowerCase() === "cimode") {
      if (h) {
        const _ = t.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${I}${_}${l}`,
          usedKey: l,
          exactUsedKey: l,
          usedLng: f,
          usedNS: I,
          usedParams: this.getUsedParamsDetails(t)
        } : `${I}${_}${l}`;
      }
      return i ? {
        res: l,
        usedKey: l,
        exactUsedKey: l,
        usedLng: f,
        usedNS: I,
        usedParams: this.getUsedParamsDetails(t)
      } : l;
    }
    const v = this.resolve(e, t);
    let b = v && v.res;
    const S = v && v.usedKey || l, R = v && v.exactUsedKey || l, W = Object.prototype.toString.apply(b), x = ["[object Number]", "[object Function]", "[object RegExp]"], M = t.joinArrays !== void 0 ? t.joinArrays : this.options.joinArrays, T = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (T && b && (typeof b != "string" && typeof b != "boolean" && typeof b != "number") && x.indexOf(W) < 0 && !(typeof M == "string" && Array.isArray(b))) {
      if (!t.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const _ = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(S, b, {
          ...t,
          ns: u
        }) : `key '${l} (${this.language})' returned an object instead of string.`;
        return i ? (v.res = _, v.usedParams = this.getUsedParamsDetails(t), v) : _;
      }
      if (o) {
        const _ = Array.isArray(b), P = _ ? [] : {}, U = _ ? R : S;
        for (const q in b)
          if (Object.prototype.hasOwnProperty.call(b, q)) {
            const k = `${U}${o}${q}`;
            P[q] = this.translate(k, {
              ...t,
              joinArrays: !1,
              ns: u
            }), P[q] === k && (P[q] = b[q]);
          }
        b = P;
      }
    } else if (T && typeof M == "string" && Array.isArray(b))
      b = b.join(M), b && (b = this.extendTranslation(b, e, t, n));
    else {
      let _ = !1, P = !1;
      const U = t.count !== void 0 && typeof t.count != "string", q = eW.hasDefaultValue(t), k = U ? this.pluralResolver.getSuffix(f, t.count, t) : "", O = t.ordinal && U ? this.pluralResolver.getSuffix(f, t.count, {
        ordinal: !1
      }) : "", J = U && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), te = J && t[`defaultValue${this.options.pluralSeparator}zero`] || t[`defaultValue${k}`] || t[`defaultValue${O}`] || t.defaultValue;
      !this.isValidLookup(b) && q && (_ = !0, b = te), this.isValidLookup(b) || (P = !0, b = l);
      const pe = (t.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && P ? void 0 : b, Ae = q && te !== b && this.options.updateMissing;
      if (P || _ || Ae) {
        if (this.logger.log(Ae ? "updateKey" : "missingKey", f, I, l, Ae ? te : b), o) {
          const ee = this.resolve(l, {
            ...t,
            keySeparator: !1
          });
          ee && ee.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let Te = [];
        const Ke = this.languageUtils.getFallbackCodes(this.options.fallbackLng, t.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && Ke && Ke[0])
          for (let ee = 0; ee < Ke.length; ee++)
            Te.push(Ke[ee]);
        else this.options.saveMissingTo === "all" ? Te = this.languageUtils.toResolveHierarchy(t.lng || this.language) : Te.push(t.lng || this.language);
        const je = (ee, Ce, be) => {
          const le = q && be !== b ? be : pe;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(ee, I, Ce, le, Ae, t) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(ee, I, Ce, le, Ae, t), this.emit("missingKey", ee, I, Ce, b);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && U ? Te.forEach((ee) => {
          const Ce = this.pluralResolver.getSuffixes(ee, t);
          J && t[`defaultValue${this.options.pluralSeparator}zero`] && Ce.indexOf(`${this.options.pluralSeparator}zero`) < 0 && Ce.push(`${this.options.pluralSeparator}zero`), Ce.forEach((be) => {
            je([ee], l + be, t[`defaultValue${be}`] || te);
          });
        }) : je(Te, l, te));
      }
      b = this.extendTranslation(b, e, t, v, n), P && b === l && this.options.appendNamespaceToMissingKey && (b = `${I}:${l}`), (P || _) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? b = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${I}:${l}` : l, _ ? b : void 0) : b = this.options.parseMissingKeyHandler(b));
    }
    return i ? (v.res = b, v.usedParams = this.getUsedParamsDetails(t), v) : b;
  }
  extendTranslation(e, t, n, i, o) {
    var l = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e = this.i18nFormat.parse(e, {
        ...this.options.interpolation.defaultVariables,
        ...n
      }, n.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!n.skipInterpolation) {
      n.interpolation && this.interpolator.init({
        ...n,
        interpolation: {
          ...this.options.interpolation,
          ...n.interpolation
        }
      });
      const f = typeof e == "string" && (n && n.interpolation && n.interpolation.skipOnVariables !== void 0 ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let h;
      if (f) {
        const b = e.match(this.interpolator.nestingRegexp);
        h = b && b.length;
      }
      let v = n.replace && typeof n.replace != "string" ? n.replace : n;
      if (this.options.interpolation.defaultVariables && (v = {
        ...this.options.interpolation.defaultVariables,
        ...v
      }), e = this.interpolator.interpolate(e, v, n.lng || this.language || i.usedLng, n), f) {
        const b = e.match(this.interpolator.nestingRegexp), S = b && b.length;
        h < S && (n.nest = !1);
      }
      !n.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (n.lng = this.language || i.usedLng), n.nest !== !1 && (e = this.interpolator.nest(e, function() {
        for (var b = arguments.length, S = new Array(b), R = 0; R < b; R++)
          S[R] = arguments[R];
        return o && o[0] === S[0] && !n.context ? (l.logger.warn(`It seems you are nesting recursively key: ${S[0]} in key: ${t[0]}`), null) : l.translate(...S, t);
      }, n)), n.interpolation && this.interpolator.reset();
    }
    const u = n.postProcess || this.options.postProcess, I = typeof u == "string" ? [u] : u;
    return e != null && I && I.length && n.applyPostProcessor !== !1 && (e = z9.handle(I, e, t, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(n)
      },
      ...n
    } : n, this)), e;
  }
  resolve(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n, i, o, l, u;
    return typeof e == "string" && (e = [e]), e.forEach((I) => {
      if (this.isValidLookup(n)) return;
      const f = this.extractFromKey(I, t), h = f.key;
      i = h;
      let v = f.namespaces;
      this.options.fallbackNS && (v = v.concat(this.options.fallbackNS));
      const b = t.count !== void 0 && typeof t.count != "string", S = b && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), R = t.context !== void 0 && (typeof t.context == "string" || typeof t.context == "number") && t.context !== "", W = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng);
      v.forEach((x) => {
        this.isValidLookup(n) || (u = x, !e5[`${W[0]}-${x}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(u) && (e5[`${W[0]}-${x}`] = !0, this.logger.warn(`key "${i}" for languages "${W.join(", ")}" won't get resolved as namespace "${u}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), W.forEach((M) => {
          if (this.isValidLookup(n)) return;
          l = M;
          const T = [h];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(T, h, M, x, t);
          else {
            let _;
            b && (_ = this.pluralResolver.getSuffix(M, t.count, t));
            const P = `${this.options.pluralSeparator}zero`, U = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (b && (T.push(h + _), t.ordinal && _.indexOf(U) === 0 && T.push(h + _.replace(U, this.options.pluralSeparator)), S && T.push(h + P)), R) {
              const q = `${h}${this.options.contextSeparator}${t.context}`;
              T.push(q), b && (T.push(q + _), t.ordinal && _.indexOf(U) === 0 && T.push(q + _.replace(U, this.options.pluralSeparator)), S && T.push(q + P));
            }
          }
          let E;
          for (; E = T.pop(); )
            this.isValidLookup(n) || (o = E, n = this.getResource(M, x, E, t));
        }));
      });
    }), {
      res: n,
      usedKey: i,
      exactUsedKey: o,
      usedLng: l,
      usedNS: u
    };
  }
  isValidLookup(e) {
    return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "");
  }
  getResource(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, i) : this.resourceStore.getResource(e, t, n, i);
  }
  getUsedParamsDetails() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], n = e.replace && typeof e.replace != "string";
    let i = n ? e.replace : e;
    if (n && typeof e.count < "u" && (i.count = e.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !n) {
      i = {
        ...i
      };
      for (const o of t)
        delete i[o];
    }
    return i;
  }
  static hasDefaultValue(e) {
    const t = "defaultValue";
    for (const n in e)
      if (Object.prototype.hasOwnProperty.call(e, n) && t === n.substring(0, t.length) && e[n] !== void 0)
        return !0;
    return !1;
  }
}
const gH = (a) => a.charAt(0).toUpperCase() + a.slice(1);
class t5 {
  constructor(e) {
    this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = ap.create("languageUtils");
  }
  getScriptPartFromCode(e) {
    if (e = $2(e), !e || e.indexOf("-") < 0) return null;
    const t = e.split("-");
    return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(t.join("-"));
  }
  getLanguagePartFromCode(e) {
    if (e = $2(e), !e || e.indexOf("-") < 0) return e;
    const t = e.split("-");
    return this.formatLanguageCode(t[0]);
  }
  formatLanguageCode(e) {
    if (typeof e == "string" && e.indexOf("-") > -1) {
      const t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let n = e.split("-");
      return this.options.lowerCaseLng ? n = n.map((i) => i.toLowerCase()) : n.length === 2 ? (n[0] = n[0].toLowerCase(), n[1] = n[1].toUpperCase(), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = gH(n[1].toLowerCase()))) : n.length === 3 && (n[0] = n[0].toLowerCase(), n[1].length === 2 && (n[1] = n[1].toUpperCase()), n[0] !== "sgn" && n[2].length === 2 && (n[2] = n[2].toUpperCase()), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = gH(n[1].toLowerCase())), t.indexOf(n[2].toLowerCase()) > -1 && (n[2] = gH(n[2].toLowerCase()))), n.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e;
  }
  isSupportedCode(e) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1;
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let t;
    return e.forEach((n) => {
      if (t) return;
      const i = this.formatLanguageCode(n);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (t = i);
    }), !t && this.options.supportedLngs && e.forEach((n) => {
      if (t) return;
      const i = this.getLanguagePartFromCode(n);
      if (this.isSupportedCode(i)) return t = i;
      t = this.options.supportedLngs.find((o) => {
        if (o === i) return o;
        if (!(o.indexOf("-") < 0 && i.indexOf("-") < 0) && (o.indexOf("-") > 0 && i.indexOf("-") < 0 && o.substring(0, o.indexOf("-")) === i || o.indexOf(i) === 0 && i.length > 1))
          return o;
      });
    }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t;
  }
  getFallbackCodes(e, t) {
    if (!e) return [];
    if (typeof e == "function" && (e = e(t)), typeof e == "string" && (e = [e]), Array.isArray(e)) return e;
    if (!t) return e.default || [];
    let n = e[t];
    return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [];
  }
  toResolveHierarchy(e, t) {
    const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e), i = [], o = (l) => {
      l && (this.isSupportedCode(l) ? i.push(l) : this.logger.warn(`rejecting language code not found in supportedLngs: ${l}`));
    };
    return typeof e == "string" && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(e))) : typeof e == "string" && o(this.formatLanguageCode(e)), n.forEach((l) => {
      i.indexOf(l) < 0 && o(this.formatLanguageCode(l));
    }), i;
  }
}
let jie = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], qie = {
  1: (a) => +(a > 1),
  2: (a) => +(a != 1),
  3: (a) => 0,
  4: (a) => a % 10 == 1 && a % 100 != 11 ? 0 : a % 10 >= 2 && a % 10 <= 4 && (a % 100 < 10 || a % 100 >= 20) ? 1 : 2,
  5: (a) => a == 0 ? 0 : a == 1 ? 1 : a == 2 ? 2 : a % 100 >= 3 && a % 100 <= 10 ? 3 : a % 100 >= 11 ? 4 : 5,
  6: (a) => a == 1 ? 0 : a >= 2 && a <= 4 ? 1 : 2,
  7: (a) => a == 1 ? 0 : a % 10 >= 2 && a % 10 <= 4 && (a % 100 < 10 || a % 100 >= 20) ? 1 : 2,
  8: (a) => a == 1 ? 0 : a == 2 ? 1 : a != 8 && a != 11 ? 2 : 3,
  9: (a) => +(a >= 2),
  10: (a) => a == 1 ? 0 : a == 2 ? 1 : a < 7 ? 2 : a < 11 ? 3 : 4,
  11: (a) => a == 1 || a == 11 ? 0 : a == 2 || a == 12 ? 1 : a > 2 && a < 20 ? 2 : 3,
  12: (a) => +(a % 10 != 1 || a % 100 == 11),
  13: (a) => +(a !== 0),
  14: (a) => a == 1 ? 0 : a == 2 ? 1 : a == 3 ? 2 : 3,
  15: (a) => a % 10 == 1 && a % 100 != 11 ? 0 : a % 10 >= 2 && (a % 100 < 10 || a % 100 >= 20) ? 1 : 2,
  16: (a) => a % 10 == 1 && a % 100 != 11 ? 0 : a !== 0 ? 1 : 2,
  17: (a) => a == 1 || a % 10 == 1 && a % 100 != 11 ? 0 : 1,
  18: (a) => a == 0 ? 0 : a == 1 ? 1 : 2,
  19: (a) => a == 1 ? 0 : a == 0 || a % 100 > 1 && a % 100 < 11 ? 1 : a % 100 > 10 && a % 100 < 20 ? 2 : 3,
  20: (a) => a == 1 ? 0 : a == 0 || a % 100 > 0 && a % 100 < 20 ? 1 : 2,
  21: (a) => a % 100 == 1 ? 1 : a % 100 == 2 ? 2 : a % 100 == 3 || a % 100 == 4 ? 3 : 0,
  22: (a) => a == 1 ? 0 : a == 2 ? 1 : (a < 0 || a > 10) && a % 10 == 0 ? 2 : 3
};
const $ie = ["v1", "v2", "v3"], ere = ["v4"], n5 = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, tre = () => {
  const a = {};
  return jie.forEach((e) => {
    e.lngs.forEach((t) => {
      a[t] = {
        numbers: e.nr,
        plurals: qie[e.fc]
      };
    });
  }), a;
};
class nre {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = e, this.options = t, this.logger = ap.create("pluralResolver"), (!this.options.compatibilityJSON || ere.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = tre(), this.pluralRulesCache = {};
  }
  addRule(e, t) {
    this.rules[e] = t;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        const n = $2(e === "dev" ? "en" : e), i = t.ordinal ? "ordinal" : "cardinal", o = JSON.stringify({
          cleanedCode: n,
          type: i
        });
        if (o in this.pluralRulesCache)
          return this.pluralRulesCache[o];
        const l = new Intl.PluralRules(n, {
          type: i
        });
        return this.pluralRulesCache[o] = l, l;
      } catch {
        return;
      }
    return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)];
  }
  needsPlural(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return this.shouldUseIntlApi() ? n && n.resolvedOptions().pluralCategories.length > 1 : n && n.numbers.length > 1;
  }
  getPluralFormsOfKey(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(e, n).map((i) => `${t}${i}`);
  }
  getSuffixes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return n ? this.shouldUseIntlApi() ? n.resolvedOptions().pluralCategories.sort((i, o) => n5[i] - n5[o]).map((i) => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : n.numbers.map((i) => this.getSuffix(e, i, t)) : [];
  }
  getSuffix(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(e, n);
    return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(t)}` : this.getSuffixRetroCompatible(i, t) : (this.logger.warn(`no plural rule found for: ${e}`), "");
  }
  getSuffixRetroCompatible(e, t) {
    const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
    let i = e.numbers[n];
    this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
    const o = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : o() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? o() : this.options.prepend && n.toString() ? this.options.prepend + n.toString() : n.toString();
  }
  shouldUseIntlApi() {
    return !$ie.includes(this.options.compatibilityJSON);
  }
}
const i5 = function(a, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, o = kie(a, e, t);
  return !o && i && typeof t == "string" && (o = uX(a, t, n), o === void 0 && (o = uX(e, t, n))), o;
}, dH = (a) => a.replace(/\$/g, "$$$$");
class ire {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = ap.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || ((t) => t), this.init(e);
  }
  init() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e.interpolation || (e.interpolation = {
      escapeValue: !0
    });
    const {
      escape: t,
      escapeValue: n,
      useRawValueToEscape: i,
      prefix: o,
      prefixEscaped: l,
      suffix: u,
      suffixEscaped: I,
      formatSeparator: f,
      unescapeSuffix: h,
      unescapePrefix: v,
      nestingPrefix: b,
      nestingPrefixEscaped: S,
      nestingSuffix: R,
      nestingSuffixEscaped: W,
      nestingOptionsSeparator: x,
      maxReplaces: M,
      alwaysFormat: T
    } = e.interpolation;
    this.escape = t !== void 0 ? t : Uie, this.escapeValue = n !== void 0 ? n : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = o ? NG(o) : l || "{{", this.suffix = u ? NG(u) : I || "}}", this.formatSeparator = f || ",", this.unescapePrefix = h ? "" : v || "-", this.unescapeSuffix = this.unescapePrefix ? "" : h || "", this.nestingPrefix = b ? NG(b) : S || NG("$t("), this.nestingSuffix = R ? NG(R) : W || NG(")"), this.nestingOptionsSeparator = x || ",", this.maxReplaces = M || 1e3, this.alwaysFormat = T !== void 0 ? T : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (t, n) => t && t.source === n ? (t.lastIndex = 0, t) : new RegExp(n, "g");
    this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(e, t, n, i) {
    let o, l, u;
    const I = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, f = (S) => {
      if (S.indexOf(this.formatSeparator) < 0) {
        const M = i5(t, I, S, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(M, void 0, n, {
          ...i,
          ...t,
          interpolationkey: S
        }) : M;
      }
      const R = S.split(this.formatSeparator), W = R.shift().trim(), x = R.join(this.formatSeparator).trim();
      return this.format(i5(t, I, W, this.options.keySeparator, this.options.ignoreJSONStructure), x, n, {
        ...i,
        ...t,
        interpolationkey: W
      });
    };
    this.resetRegExp();
    const h = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler, v = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (S) => dH(S)
    }, {
      regex: this.regexp,
      safeValue: (S) => this.escapeValue ? dH(this.escape(S)) : dH(S)
    }].forEach((S) => {
      for (u = 0; o = S.regex.exec(e); ) {
        const R = o[1].trim();
        if (l = f(R), l === void 0)
          if (typeof h == "function") {
            const x = h(e, o, i);
            l = typeof x == "string" ? x : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, R))
            l = "";
          else if (v) {
            l = o[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${R} for interpolating ${e}`), l = "";
        else typeof l != "string" && !this.useRawValueToEscape && (l = J3(l));
        const W = S.safeValue(l);
        if (e = e.replace(o[0], W), v ? (S.regex.lastIndex += l.length, S.regex.lastIndex -= o[0].length) : S.regex.lastIndex = 0, u++, u >= this.maxReplaces)
          break;
      }
    }), e;
  }
  nest(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, o, l;
    const u = (I, f) => {
      const h = this.nestingOptionsSeparator;
      if (I.indexOf(h) < 0) return I;
      const v = I.split(new RegExp(`${h}[ ]*{`));
      let b = `{${v[1]}`;
      I = v[0], b = this.interpolate(b, l);
      const S = b.match(/'/g), R = b.match(/"/g);
      (S && S.length % 2 === 0 && !R || R.length % 2 !== 0) && (b = b.replace(/'/g, '"'));
      try {
        l = JSON.parse(b), f && (l = {
          ...f,
          ...l
        });
      } catch (W) {
        return this.logger.warn(`failed parsing options string in nesting for key ${I}`, W), `${I}${h}${b}`;
      }
      return l.defaultValue && l.defaultValue.indexOf(this.prefix) > -1 && delete l.defaultValue, I;
    };
    for (; i = this.nestingRegexp.exec(e); ) {
      let I = [];
      l = {
        ...n
      }, l = l.replace && typeof l.replace != "string" ? l.replace : l, l.applyPostProcessor = !1, delete l.defaultValue;
      let f = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const h = i[1].split(this.formatSeparator).map((v) => v.trim());
        i[1] = h.shift(), I = h, f = !0;
      }
      if (o = t(u.call(this, i[1].trim(), l), l), o && i[0] === e && typeof o != "string") return o;
      typeof o != "string" && (o = J3(o)), o || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${e}`), o = ""), f && (o = I.reduce((h, v) => this.format(h, v, n.lng, {
        ...n,
        interpolationkey: i[1].trim()
      }), o.trim())), e = e.replace(i[0], o), this.regexp.lastIndex = 0;
    }
    return e;
  }
}
const rre = (a) => {
  let e = a.toLowerCase().trim();
  const t = {};
  if (a.indexOf("(") > -1) {
    const n = a.split("(");
    e = n[0].toLowerCase().trim();
    const i = n[1].substring(0, n[1].length - 1);
    e === "currency" && i.indexOf(":") < 0 ? t.currency || (t.currency = i.trim()) : e === "relativetime" && i.indexOf(":") < 0 ? t.range || (t.range = i.trim()) : i.split(";").forEach((l) => {
      if (l) {
        const [u, ...I] = l.split(":"), f = I.join(":").trim().replace(/^'+|'+$/g, ""), h = u.trim();
        t[h] || (t[h] = f), f === "false" && (t[h] = !1), f === "true" && (t[h] = !0), isNaN(f) || (t[h] = parseInt(f, 10));
      }
    });
  }
  return {
    formatName: e,
    formatOptions: t
  };
}, MG = (a) => {
  const e = {};
  return (t, n, i) => {
    let o = i;
    i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (o = {
      ...o,
      [i.interpolationkey]: void 0
    });
    const l = n + JSON.stringify(o);
    let u = e[l];
    return u || (u = a($2(n), i), e[l] = u), u(t);
  };
};
class are {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = ap.create("formatter"), this.options = e, this.formats = {
      number: MG((t, n) => {
        const i = new Intl.NumberFormat(t, {
          ...n
        });
        return (o) => i.format(o);
      }),
      currency: MG((t, n) => {
        const i = new Intl.NumberFormat(t, {
          ...n,
          style: "currency"
        });
        return (o) => i.format(o);
      }),
      datetime: MG((t, n) => {
        const i = new Intl.DateTimeFormat(t, {
          ...n
        });
        return (o) => i.format(o);
      }),
      relativetime: MG((t, n) => {
        const i = new Intl.RelativeTimeFormat(t, {
          ...n
        });
        return (o) => i.format(o, n.range || "day");
      }),
      list: MG((t, n) => {
        const i = new Intl.ListFormat(t, {
          ...n
        });
        return (o) => i.format(o);
      })
    }, this.init(e);
  }
  init(e) {
    const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",";
  }
  add(e, t) {
    this.formats[e.toLowerCase().trim()] = t;
  }
  addCached(e, t) {
    this.formats[e.toLowerCase().trim()] = MG(t);
  }
  format(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const o = t.split(this.formatSeparator);
    if (o.length > 1 && o[0].indexOf("(") > 1 && o[0].indexOf(")") < 0 && o.find((u) => u.indexOf(")") > -1)) {
      const u = o.findIndex((I) => I.indexOf(")") > -1);
      o[0] = [o[0], ...o.splice(1, u)].join(this.formatSeparator);
    }
    return o.reduce((u, I) => {
      const {
        formatName: f,
        formatOptions: h
      } = rre(I);
      if (this.formats[f]) {
        let v = u;
        try {
          const b = i && i.formatParams && i.formatParams[i.interpolationkey] || {}, S = b.locale || b.lng || i.locale || i.lng || n;
          v = this.formats[f](u, S, {
            ...h,
            ...i,
            ...b
          });
        } catch (b) {
          this.logger.warn(b);
        }
        return v;
      } else
        this.logger.warn(`there was no format function for ${f}`);
      return u;
    }, e);
  }
}
const ore = (a, e) => {
  a.pending[e] !== void 0 && (delete a.pending[e], a.pendingCount--);
};
class sre extends PW {
  constructor(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = e, this.store = t, this.services = n, this.languageUtils = n.languageUtils, this.options = i, this.logger = ap.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(n, i.backend, i);
  }
  queueLoad(e, t, n, i) {
    const o = {}, l = {}, u = {}, I = {};
    return e.forEach((f) => {
      let h = !0;
      t.forEach((v) => {
        const b = `${f}|${v}`;
        !n.reload && this.store.hasResourceBundle(f, v) ? this.state[b] = 2 : this.state[b] < 0 || (this.state[b] === 1 ? l[b] === void 0 && (l[b] = !0) : (this.state[b] = 1, h = !1, l[b] === void 0 && (l[b] = !0), o[b] === void 0 && (o[b] = !0), I[v] === void 0 && (I[v] = !0)));
      }), h || (u[f] = !0);
    }), (Object.keys(o).length || Object.keys(l).length) && this.queue.push({
      pending: l,
      pendingCount: Object.keys(l).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(o),
      pending: Object.keys(l),
      toLoadLanguages: Object.keys(u),
      toLoadNamespaces: Object.keys(I)
    };
  }
  loaded(e, t, n) {
    const i = e.split("|"), o = i[0], l = i[1];
    t && this.emit("failedLoading", o, l, t), !t && n && this.store.addResourceBundle(o, l, n, void 0, void 0, {
      skipCopy: !0
    }), this.state[e] = t ? -1 : 2, t && n && (this.state[e] = 0);
    const u = {};
    this.queue.forEach((I) => {
      Lie(I.loaded, [o], l), ore(I, e), t && I.errors.push(t), I.pendingCount === 0 && !I.done && (Object.keys(I.loaded).forEach((f) => {
        u[f] || (u[f] = {});
        const h = I.loaded[f];
        h.length && h.forEach((v) => {
          u[f][v] === void 0 && (u[f][v] = !0);
        });
      }), I.done = !0, I.errors.length ? I.callback(I.errors) : I.callback());
    }), this.emit("loaded", u), this.queue = this.queue.filter((I) => !I.done);
  }
  read(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, l = arguments.length > 5 ? arguments[5] : void 0;
    if (!e.length) return l(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: e,
        ns: t,
        fcName: n,
        tried: i,
        wait: o,
        callback: l
      });
      return;
    }
    this.readingCalls++;
    const u = (f, h) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const v = this.waitingReads.shift();
        this.read(v.lng, v.ns, v.fcName, v.tried, v.wait, v.callback);
      }
      if (f && h && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, e, t, n, i + 1, o * 2, l);
        }, o);
        return;
      }
      l(f, h);
    }, I = this.backend[n].bind(this.backend);
    if (I.length === 2) {
      try {
        const f = I(e, t);
        f && typeof f.then == "function" ? f.then((h) => u(null, h)).catch(u) : u(null, f);
      } catch (f) {
        u(f);
      }
      return;
    }
    return I(e, t, u);
  }
  prepareLoading(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    typeof e == "string" && (e = this.languageUtils.toResolveHierarchy(e)), typeof t == "string" && (t = [t]);
    const o = this.queueLoad(e, t, n, i);
    if (!o.toLoad.length)
      return o.pending.length || i(), null;
    o.toLoad.forEach((l) => {
      this.loadOne(l);
    });
  }
  load(e, t, n) {
    this.prepareLoading(e, t, {}, n);
  }
  reload(e, t, n) {
    this.prepareLoading(e, t, {
      reload: !0
    }, n);
  }
  loadOne(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const n = e.split("|"), i = n[0], o = n[1];
    this.read(i, o, "read", void 0, void 0, (l, u) => {
      l && this.logger.warn(`${t}loading namespace ${o} for language ${i} failed`, l), !l && u && this.logger.log(`${t}loaded namespace ${o} for language ${i}`, u), this.loaded(e, l, u);
    });
  }
  saveMissing(e, t, n, i, o) {
    let l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, u = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t)) {
      this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(n == null || n === "")) {
      if (this.backend && this.backend.create) {
        const I = {
          ...l,
          isUpdate: o
        }, f = this.backend.create.bind(this.backend);
        if (f.length < 6)
          try {
            let h;
            f.length === 5 ? h = f(e, t, n, i, I) : h = f(e, t, n, i), h && typeof h.then == "function" ? h.then((v) => u(null, v)).catch(u) : u(null, h);
          } catch (h) {
            u(h);
          }
        else
          f(e, t, n, i, u, I);
      }
      !e || !e[0] || this.store.addResource(e[0], t, n, i);
    }
  }
}
const r5 = () => ({
  debug: !1,
  initImmediate: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (a) => {
    let e = {};
    if (typeof a[1] == "object" && (e = a[1]), typeof a[1] == "string" && (e.defaultValue = a[1]), typeof a[2] == "string" && (e.tDescription = a[2]), typeof a[2] == "object" || typeof a[3] == "object") {
      const t = a[3] || a[2];
      Object.keys(t).forEach((n) => {
        e[n] = t[n];
      });
    }
    return e;
  },
  interpolation: {
    escapeValue: !0,
    format: (a) => a,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), a5 = (a) => (typeof a.ns == "string" && (a.ns = [a.ns]), typeof a.fallbackLng == "string" && (a.fallbackLng = [a.fallbackLng]), typeof a.fallbackNS == "string" && (a.fallbackNS = [a.fallbackNS]), a.supportedLngs && a.supportedLngs.indexOf("cimode") < 0 && (a.supportedLngs = a.supportedLngs.concat(["cimode"])), a), k1 = () => {
}, lre = (a) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(a)).forEach((t) => {
    typeof a[t] == "function" && (a[t] = a[t].bind(a));
  });
};
class Fw extends PW {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = a5(e), this.services = {}, this.logger = ap, this.modules = {
      external: []
    }, lre(this), t && !this.isInitialized && !e.isClone) {
      if (!this.options.initImmediate)
        return this.init(e, t), this;
      setTimeout(() => {
        this.init(e, t);
      }, 0);
    }
  }
  init() {
    var e = this;
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof t == "function" && (n = t, t = {}), !t.defaultNS && t.defaultNS !== !1 && t.ns && (typeof t.ns == "string" ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const i = r5();
    this.options = {
      ...i,
      ...this.options,
      ...a5(t)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }), t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    const o = (h) => h ? typeof h == "function" ? new h() : h : null;
    if (!this.options.isClone) {
      this.modules.logger ? ap.init(o(this.modules.logger), this.options) : ap.init(null, this.options);
      let h;
      this.modules.formatter ? h = this.modules.formatter : typeof Intl < "u" && (h = are);
      const v = new t5(this.options);
      this.store = new $3(this.options.resources, this.options);
      const b = this.services;
      b.logger = ap, b.resourceStore = this.store, b.languageUtils = v, b.pluralResolver = new nre(v, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), h && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (b.formatter = o(h), b.formatter.init(b, this.options), this.options.interpolation.format = b.formatter.format.bind(b.formatter)), b.interpolator = new ire(this.options), b.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, b.backendConnector = new sre(o(this.modules.backend), b.resourceStore, b, this.options), b.backendConnector.on("*", function(S) {
        for (var R = arguments.length, W = new Array(R > 1 ? R - 1 : 0), x = 1; x < R; x++)
          W[x - 1] = arguments[x];
        e.emit(S, ...W);
      }), this.modules.languageDetector && (b.languageDetector = o(this.modules.languageDetector), b.languageDetector.init && b.languageDetector.init(b, this.options.detection, this.options)), this.modules.i18nFormat && (b.i18nFormat = o(this.modules.i18nFormat), b.i18nFormat.init && b.i18nFormat.init(this)), this.translator = new eW(this.services, this.options), this.translator.on("*", function(S) {
        for (var R = arguments.length, W = new Array(R > 1 ? R - 1 : 0), x = 1; x < R; x++)
          W[x - 1] = arguments[x];
        e.emit(S, ...W);
      }), this.modules.external.forEach((S) => {
        S.init && S.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, n || (n = k1), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const h = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      h.length > 0 && h[0] !== "dev" && (this.options.lng = h[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((h) => {
      this[h] = function() {
        return e.store[h](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((h) => {
      this[h] = function() {
        return e.store[h](...arguments), e;
      };
    });
    const I = XZ(), f = () => {
      const h = (v, b) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), I.resolve(b), n(v, b);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return h(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, h);
    };
    return this.options.resources || !this.options.initImmediate ? f() : setTimeout(f, 0), I;
  }
  loadResources(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : k1;
    const i = typeof e == "string" ? e : this.language;
    if (typeof e == "function" && (n = e), !this.options.resources || this.options.partialBundledLanguages) {
      if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return n();
      const o = [], l = (u) => {
        if (!u || u === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(u).forEach((f) => {
          f !== "cimode" && o.indexOf(f) < 0 && o.push(f);
        });
      };
      i ? l(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((I) => l(I)), this.options.preload && this.options.preload.forEach((u) => l(u)), this.services.backendConnector.load(o, this.options.ns, (u) => {
        !u && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), n(u);
      });
    } else
      n(null);
  }
  reloadResources(e, t, n) {
    const i = XZ();
    return typeof e == "function" && (n = e, e = void 0), typeof t == "function" && (n = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), n || (n = k1), this.services.backendConnector.reload(e, t, (o) => {
      i.resolve(), n(o);
    }), i;
  }
  use(e) {
    if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && z9.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this;
  }
  setResolvedLanguage(e) {
    if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
      for (let t = 0; t < this.languages.length; t++) {
        const n = this.languages[t];
        if (!(["cimode", "dev"].indexOf(n) > -1) && this.store.hasLanguageSomeTranslations(n)) {
          this.resolvedLanguage = n;
          break;
        }
      }
  }
  changeLanguage(e, t) {
    var n = this;
    this.isLanguageChangingTo = e;
    const i = XZ();
    this.emit("languageChanging", e);
    const o = (I) => {
      this.language = I, this.languages = this.services.languageUtils.toResolveHierarchy(I), this.resolvedLanguage = void 0, this.setResolvedLanguage(I);
    }, l = (I, f) => {
      f ? (o(f), this.translator.changeLanguage(f), this.isLanguageChangingTo = void 0, this.emit("languageChanged", f), this.logger.log("languageChanged", f)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
        return n.t(...arguments);
      }), t && t(I, function() {
        return n.t(...arguments);
      });
    }, u = (I) => {
      !e && !I && this.services.languageDetector && (I = []);
      const f = typeof I == "string" ? I : this.services.languageUtils.getBestMatchFromCodes(I);
      f && (this.language || o(f), this.translator.language || this.translator.changeLanguage(f), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(f)), this.loadResources(f, (h) => {
        l(h, f);
      });
    };
    return !e && this.services.languageDetector && !this.services.languageDetector.async ? u(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(u) : this.services.languageDetector.detect(u) : u(e), i;
  }
  getFixedT(e, t, n) {
    var i = this;
    const o = function(l, u) {
      let I;
      if (typeof u != "object") {
        for (var f = arguments.length, h = new Array(f > 2 ? f - 2 : 0), v = 2; v < f; v++)
          h[v - 2] = arguments[v];
        I = i.options.overloadTranslationOptionHandler([l, u].concat(h));
      } else
        I = {
          ...u
        };
      I.lng = I.lng || o.lng, I.lngs = I.lngs || o.lngs, I.ns = I.ns || o.ns, I.keyPrefix !== "" && (I.keyPrefix = I.keyPrefix || n || o.keyPrefix);
      const b = i.options.keySeparator || ".";
      let S;
      return I.keyPrefix && Array.isArray(l) ? S = l.map((R) => `${I.keyPrefix}${b}${R}`) : S = I.keyPrefix ? `${I.keyPrefix}${b}${l}` : l, i.t(S, I);
    };
    return typeof e == "string" ? o.lng = e : o.lngs = e, o.ns = t, o.keyPrefix = n, o;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const n = t.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, o = this.languages[this.languages.length - 1];
    if (n.toLowerCase() === "cimode") return !0;
    const l = (u, I) => {
      const f = this.services.backendConnector.state[`${u}|${I}`];
      return f === -1 || f === 0 || f === 2;
    };
    if (t.precheck) {
      const u = t.precheck(this, l);
      if (u !== void 0) return u;
    }
    return !!(this.hasResourceBundle(n, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || l(n, e) && (!i || l(o, e)));
  }
  loadNamespaces(e, t) {
    const n = XZ();
    return this.options.ns ? (typeof e == "string" && (e = [e]), e.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      n.resolve(), t && t(i);
    }), n) : (t && t(), Promise.resolve());
  }
  loadLanguages(e, t) {
    const n = XZ();
    typeof e == "string" && (e = [e]);
    const i = this.options.preload || [], o = e.filter((l) => i.indexOf(l) < 0 && this.services.languageUtils.isSupportedCode(l));
    return o.length ? (this.options.preload = i.concat(o), this.loadResources((l) => {
      n.resolve(), t && t(l);
    }), n) : (t && t(), Promise.resolve());
  }
  dir(e) {
    if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
    const t = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], n = this.services && this.services.languageUtils || new t5(r5());
    return t.indexOf(n.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    return new Fw(e, t);
  }
  cloneInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : k1;
    const n = e.forkResourceStore;
    n && delete e.forkResourceStore;
    const i = {
      ...this.options,
      ...e,
      isClone: !0
    }, o = new Fw(i);
    return (e.debug !== void 0 || e.prefix !== void 0) && (o.logger = o.logger.clone(e)), ["store", "services", "language"].forEach((u) => {
      o[u] = this[u];
    }), o.services = {
      ...this.services
    }, o.services.utils = {
      hasLoadedNamespace: o.hasLoadedNamespace.bind(o)
    }, n && (o.store = new $3(this.store.data, i), o.services.resourceStore = o.store), o.translator = new eW(o.services, i), o.translator.on("*", function(u) {
      for (var I = arguments.length, f = new Array(I > 1 ? I - 1 : 0), h = 1; h < I; h++)
        f[h - 1] = arguments[h];
      o.emit(u, ...f);
    }), o.init(i, t), o.translator.options = i, o.translator.backendConnector.services.utils = {
      hasLoadedNamespace: o.hasLoadedNamespace.bind(o)
    }, o;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const El = Fw.createInstance();
El.createInstance = Fw.createInstance;
El.createInstance;
El.dir;
El.init;
El.loadResources;
El.reloadResources;
El.use;
El.changeLanguage;
El.getFixedT;
El.t;
El.exists;
El.setDefaultNamespace;
El.hasLoadedNamespace;
El.loadNamespaces;
El.loadLanguages;
const ure = {
  zh: {
    translation: {
      myName: "吳 培誠",
      myPosition: "前端工程師",
      lang_zh: "中文",
      lang_en: "english",
      theme_default: "默認",
      theme_dark: "暗",
      theme_light: "亮",
      nav_home: "首頁",
      nav_about: "關於",
      nav_experience: "工作經驗",
      nav_projects: "專案",
      nav_links: "連結",
      subtitle_aboutme: "關於",
      subtitle_aboutweb: "關於網站",
      subtitle_experience: "工作經驗",
      subtitle_projects: "專案",
      subtitle_links: "個人連結",
      subtitle_materials: "學習資源",
      proj_download: "download",
      proj_link: "link",
      proj_github: "github",
      link_email: "電子信箱",
      link_git: "GitHub",
      link_youtube: "YouTube",
      toast_copy: "已複製連結"
    }
  },
  en: {
    translation: {
      myName: "Wu, Pei-Cheng",
      myPosition: "Frontend Engineer",
      lang_zh: "中文",
      lang_en: "english",
      theme_default: "default",
      theme_dark: "dark",
      theme_light: "light",
      nav_home: "Home",
      nav_about: "About",
      nav_experience: "Experience",
      nav_projects: "Projects",
      nav_links: "Links",
      subtitle_aboutme: "About",
      subtitle_aboutweb: "Website Overview",
      subtitle_experience: "Work Experience",
      subtitle_projects: "Projects",
      subtitle_links: "Profile Links",
      subtitle_materials: "Study Materials",
      proj_download: "download",
      proj_link: "link",
      proj_github: "github",
      link_email: "Email",
      link_git: "GitHub",
      link_youtube: "YouTube",
      toast_copy: "copied link"
    }
  }
}, cre = () => {
  const a = location.href, e = a.indexOf("?lang=") !== -1 ? a.indexOf("?lang=") : a.indexOf("&lang=");
  if (e !== -1) {
    const n = a.substring(e), o = /[?&]lang=([^&]+)/.exec(n);
    if (o && o.length > 1 && o[1]) {
      const l = o[1];
      if ($Z.includes(l))
        return l;
    }
  }
  const t = localStorage.getItem(xw.lang);
  return $Z.includes(t) ? t : $Z[0];
};
El.use(Gie).init({
  debug: !1,
  fallbackLng: cre(),
  interpolation: { escapeValue: !1 },
  supportedLngs: $Z,
  resources: ure
});
const gre = ({ className: a }) => {
  const { t: e } = Lu(), t = Pg(), n = Sb();
  return /* @__PURE__ */ ze.jsxs("nav", { className: `mobile-nav-${El.language} ${a}`, children: [
    /* @__PURE__ */ ze.jsxs("label", { className: "cursor-pointer flex flex-row gap-1 text-nowrap", onClick: () => n(ng.HOME), children: [
      /* @__PURE__ */ ze.jsx(Xie, { size: "12px", className: El.language === "zh" ? "rotate-0" : "rotate-180" }),
      e("nav_home")
    ] }),
    cY.map(({ url: i, title: o }) => /* @__PURE__ */ ze.jsxs("label", { className: "cursor-pointer text-nowrap", children: [
      /* @__PURE__ */ ze.jsx("input", { type: "radio", checked: t.pathname === i, onChange: () => n(i) }),
      e(o)
    ] }, o))
  ] });
}, o5 = ({ defaultChecked: a, name: e, options: t, onChange: n }) => {
  const { t: i } = Lu();
  return /* @__PURE__ */ ze.jsx("div", { className: "radiogroup uppercase", children: t.map((o) => /* @__PURE__ */ ze.jsxs("label", { className: "custom-radio", children: [
    /* @__PURE__ */ ze.jsx(
      "input",
      {
        type: "radio",
        defaultChecked: o.value === a,
        name: e,
        value: o.value,
        onChange: (l) => n(l.target.value)
      }
    ),
    i(o.name)
  ] }, o.value)) });
}, dre = ({ type: a, during: e, text: t }) => {
  const [n, i] = xe.useState("open");
  return xe.useEffect(() => {
    setTimeout(() => {
      i("close");
    }, e);
  }, []), /* @__PURE__ */ ze.jsx("div", { className: `toast_content-${n}`, children: t });
}, Ire = ({ children: a }) => {
  let e = document.getElementById("toast-wrapper");
  if (!e) {
    const t = document.getElementById("root"), n = document.createElement("div");
    n.id = "toast-wrapper", document.body.insertBefore(n, t), e = n;
  }
  return gX.createPortal(a, e);
}, Cre = ({ during: a = 3e3, maxCount: e = 1 }) => {
  const [t, n] = xe.useState([]), i = 290, o = (l) => {
    n((u) => u.filter(({ key: I }) => I !== l.key));
  };
  return n2 = (l) => {
    n((u) => [...u, l]), setTimeout(() => {
      o(l);
    }, a + i);
  }, xe.useEffect(() => {
    if (t.length > e) {
      const [l] = t;
      o(l);
    }
  }, [t]), /* @__PURE__ */ ze.jsx(Ire, { children: /* @__PURE__ */ ze.jsx("div", { className: "toast_container", children: t.map(({ key: l, type: u, text: I }) => /* @__PURE__ */ ze.jsx(dre, { during: a, type: u, text: I }, l)) }) });
};
let n2, s5 = 0;
const hre = Date.now(), IH = () => {
  const a = s5;
  return s5 += 1, `${hre}_${a}`;
}, l5 = {
  success: (a) => {
    n2({
      text: a,
      key: IH(),
      type: "success"
    });
  },
  warning: (a) => {
    n2({
      text: a,
      key: IH(),
      type: "warning"
    });
  },
  error: (a) => {
    n2({
      text: a,
      key: IH(),
      type: "error"
    });
  }
}, JW = ({ title: a, children: e }) => /* @__PURE__ */ ze.jsxs("section", { className: "section", children: [
  /* @__PURE__ */ ze.jsxs("div", { className: "titleFrame", children: [
    /* @__PURE__ */ ze.jsx("div", { className: "titleFrame-linel" }),
    /* @__PURE__ */ ze.jsx("h2", { className: "title", children: a }),
    /* @__PURE__ */ ze.jsx("div", { className: "titleFrame-liner" })
  ] }),
  e
] }), hp = (a) => {
  const e = {
    [DA.EN]: DA.EN,
    [DA.ZH]: DA.ZH
  };
  return ((n) => n in e)(a) ? e[a] : DA.EN;
}, D1 = {
  phaseI: {
    en: "I'm Randy, a frontend developer. I created this website to document the projects I've worked on over the past few years, including side projects and those I've participated in at work. As long as the projects are publicly accessible, they will be showcased here as part of my portfolio.",
    zh: "我是吳培誠，一名網站前端的開發者，建立本站的目地是希望，透過本站來紀錄自己工作這幾年所累積的專案，不論是個人作品或工作上參與過的專案，只要是有對外開放的，皆會以作品集的方式呈現於此。"
  },
  phaseII: {
    en: "Currently, I'm a frontend engineer at Kang Da Information Inc., responsible for the frontend project development of the Taiwan Intellectual Property Office (TIPO) and provided technical support, such as project architecture planning, writing tests, training, etc..",
    zh: "目前，我在康大資訊擔任前端工程師，負責為臺灣經濟部智慧財產局 (TIPO) 開發專案並提供技術支援。包括專案架構規劃、撰寫測試、教育訓練等…。"
  },
  phaseIII: {
    en: "Prior to this role, I worked at a gaming company as a developer, contributing to game development projects. This experience allowed me to appreciate the unique challenges and joys of working on different types of projects",
    zh: "在此之前，我也曾於遊戲公司擔任開發者，參與遊戲專案的開發，這段經歷讓我體會到不同類型專案開發的樂趣與挑戰。"
  },
  phaseIV: {
    en: "In my spare time, I'm usually reading, playing the guitar, and recently, I reunited with some university friends to form a new band.",
    zh: "在空閒時間，我通常會閱讀、彈吉他，最近還與大學時的好友重新組了一個樂團。"
  }
}, fre = () => {
  const { t: a, i18n: e } = Lu(), t = hp(e.language);
  return /* @__PURE__ */ ze.jsx(JW, { title: a("subtitle_aboutme"), children: /* @__PURE__ */ ze.jsxs("article", { className: "text-base sm:text-sm flex flex-col gap-6 transition-theme text-defaccent dark:text-darkaccent light:text-lightaccent md:px-4 xs:p-0", children: [
    /* @__PURE__ */ ze.jsx("p", { children: D1.phaseI[t] }),
    /* @__PURE__ */ ze.jsx("p", { children: D1.phaseII[t] }),
    /* @__PURE__ */ ze.jsx("p", { children: D1.phaseIII[t] }),
    /* @__PURE__ */ ze.jsx("p", { children: D1.phaseIV[t] })
  ] }) });
}, $c = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
function pre() {
  const a = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return ($c[a & 255] + $c[a >> 8 & 255] + $c[a >> 16 & 255] + $c[a >> 24 & 255] + "-" + $c[e & 255] + $c[e >> 8 & 255] + "-" + $c[e >> 16 & 15 | 64] + $c[e >> 24 & 255] + "-" + $c[t & 63 | 128] + $c[t >> 8 & 255] + "-" + $c[t >> 16 & 255] + $c[t >> 24 & 255] + $c[n & 255] + $c[n >> 8 & 255] + $c[n >> 16 & 255] + $c[n >> 24 & 255]).toLowerCase();
}
const mre = ({
  experience: { id: a, coname: e, district: t, position: n, period: i, description: o, link: l, tags: u, contributions: I },
  hoverState: f
}) => {
  const { i18n: h } = Lu(), v = hp(h.language);
  return /* @__PURE__ */ ze.jsxs(
    M9,
    {
      id: a,
      hoverState: f,
      title: /* @__PURE__ */ ze.jsxs("p", { className: "text-xs uppercase", children: [
        /* @__PURE__ */ ze.jsx("span", { className: "text-nowrap", children: i[0] }),
        " — ",
        /* @__PURE__ */ ze.jsx("span", { className: "text-nowrap", children: i[1] })
      ] }),
      children: [
        /* @__PURE__ */ ze.jsx("div", { className: "flex flex-col gap-2", children: /* @__PURE__ */ ze.jsxs("div", { className: "flex flex-row flex-wrap justify-between items-center gap-x-2", children: [
          /* @__PURE__ */ ze.jsx("a", { target: "_blank", rel: "noopener noreferrer", href: l, children: /* @__PURE__ */ ze.jsxs("h3", { className: "text-nowrap xs:text-wrap text-lg font-medium md:underline", children: [
            e[v],
            /* @__PURE__ */ ze.jsx("span", { className: "text-sm underline md:hidden ml-2", children: "link" })
          ] }) }),
          /* @__PURE__ */ ze.jsx("div", { className: "text-xs font-normal", children: t[v] }),
          /* @__PURE__ */ ze.jsx("div", { className: "mt-1 w-full flex flex-row justify-between items-center", children: n[v] })
        ] }) }),
        /* @__PURE__ */ ze.jsx("div", { className: "text-sm", children: o[v] }),
        /* @__PURE__ */ ze.jsx("div", { className: "text-sm", children: /* @__PURE__ */ ze.jsx("ul", { className: "list-disc ml-5", children: I.map((b) => /* @__PURE__ */ ze.jsx("li", { children: b[v] }, pre())) }) }),
        /* @__PURE__ */ ze.jsx("div", { className: "mt-1 flex flex-row justify-between items-end text-sm font-medium", children: /* @__PURE__ */ ze.jsx(H9, { tags: u }) })
      ]
    }
  );
}, Are = [
  {
    id: "1",
    coname: {
      en: "Kang Da Information Inc.",
      zh: "康大資訊股份有限公司"
    },
    district: {
      en: "Zhongshan Dist., Taipei City",
      zh: "台北市中山區"
    },
    position: {
      en: "Frontend Engineer",
      zh: "前端工程師"
    },
    period: [`${Yd.SEP} 2022`, "present"],
    description: {
      en: "Responsible for React project development at the Taiwan Intellectual Property Office (TIPO) and for providing technical support, including technology selection, writing tests, training, and more.",
      zh: "負責臺灣經濟部智慧財產局 (TIPO) 的前端技術支援，包括了 React 專案開發、技術選型、測試撰寫、以及教育訓練等。"
    },
    link: "https://www.kangdainfo.com/web/index.html?pageId=1",
    contributions: [
      {
        en: "Developed a Chrome extension for developers, increasing their work efficiency by over 300%.",
        zh: "開發了測試人員專用的 chrome extension，提升了測試人員 3 倍以上的工作效率。"
      },
      {
        en: "Designed and implemented a batch file conversion module for an online patent application system, allowing users to upload and process large files before submission.",
        zh: "為 專利線上申請系統 開發了大型文件批量轉檔模組，使用者可於申請專利前，預先上傳多個大型檔案。"
      },
      {
        en: "Designed and developed a dedicated UI library for TIPO, which has been implemented across all TIPO projects.",
        zh: "建立 / 設計一套 TIPO 專用的 UI Library，目前用於 TIPO 所有前端專案。"
      },
      {
        en: "Refactored the online fee payment system by applying Domain-Driven Design (DDD) principles to restructure and layer its architecture.",
        zh: "重構 規費線上繳納系統，運用 Domain-Driven Design (DDD) 的知識，重新對架構進行分層設計。"
      },
      {
        en: "Wrote unit tests in Jest for the online fee payment system, achieving 100% code coverage for business logic modules.",
        zh: "使用 Jest 為 規費線上繳納系統 撰寫 unit test，將業務邏輯模組的測試覆蓋率提升至 100% 。"
      },
      {
        en: "Conducted training for TIPO employees, guiding maintenance team members on using React and functional programming concepts for project maintenance and feature expansion, while also conducting code reviews for the team.",
        zh: "規劃 TIPO 員工教育訓練，指導維護組同仁使用 React 及 Functional programming 概念進行專案維護及功能擴充，同時負責維護人員的 code review。"
      }
    ],
    tags: [sr.react, sr.express, sr.nativeJS, sr.typescript, sr.tailwind, sr.vite, sr.jest, sr.i18n]
  },
  {
    id: "0",
    coname: {
      en: "Chenhe Digital Technology CO., LTD.",
      zh: "宸和數位科技有限公司（原禾向數位科技）"
    },
    district: {
      en: "Neihu Dist., Taipei City",
      zh: "台北市內湖區"
    },
    position: {
      en: "Game Frontend Engineer",
      zh: "遊戲前端工程師"
    },
    period: [`${Yd.AUG} 2020`, `${Yd.AUG} 2022`],
    description: {
      en: 'Responsible for the development and maintenance of the "王道棋牌" game project together with the team.',
      zh: '與團隊一同負責 "王道棋牌" 遊戲專案的開發與維護。'
    },
    link: "https://www.linkedin.com/company/%E5%AE%B8%E5%92%8C%E6%95%B8%E4%BD%8D%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/",
    contributions: [
      {
        en: "Developed seven game projects, taking responsibility for architecture planning and task allocation for three of them, and achieving a 100% project completion rate.",
        zh: "開發了七款遊戲專案，負責三款專案的架構規劃及工作分配，獨立開發一款專案，專案完成率 100%。"
      },
      {
        en: "Handled real-time user messages using WebSocket.",
        zh: "使用 WebSocket 處理使用者的即時訊息。"
      },
      {
        en: "Optimized the web version of games, reducing image requests by half and cutting project loading time by 50%.",
        zh: "優化遊戲網頁版，減少一半的圖片請求數量，並減少至少 50% 專案載入時間。"
      },
      {
        en: "Developed internal tools using Python and Shell, streamlining the development process and saving 4 hours per engineer.",
        zh: "使用 Python 與 Shell 撰寫公司內部開發工具，減少每位工程師 4 小時的開發流程。"
      }
    ],
    tags: [sr.htmlscss, sr.websocket, sr.typescript, sr.java, sr.python, sr.canvas, sr.glsl, sr.i18n]
  }
], vre = () => {
  const { t: a } = Lu(), [e, t] = xe.useState("");
  return /* @__PURE__ */ ze.jsx(JW, { title: a("subtitle_experience"), children: /* @__PURE__ */ ze.jsx("div", { className: "w-full flex flex-col gap-0 xs:gap-8 md:pr-4 xs:p-0", onMouseLeave: () => t(""), children: Are.map((n) => /* @__PURE__ */ ze.jsx(mre, { experience: n, hoverState: [e, t] }, n.id)) }) });
}, Ew = (a) => a === ng.HOME, yre = ({ className: a }) => {
  const { pathname: t } = Pg(), [n, i] = xe.useState(Ew(t));
  return xe.useEffect(() => {
    const o = setTimeout(() => {
      i(!1);
    }, 2e3);
    return () => clearTimeout(o);
  }, [2e3]), n && Ew(t) && /* @__PURE__ */ ze.jsx("div", { className: `${a} animation`, children: /* @__PURE__ */ ze.jsx("div", { className: "animation-spec", children: /* @__PURE__ */ ze.jsxs("div", { className: "animation-text", children: [
    "Randy's",
    /* @__PURE__ */ ze.jsx("br", {}),
    "Website"
  ] }) }) });
}, u5 = (a) => {
  const e = {
    [ng.HOME]: /* @__PURE__ */ ze.jsx(ze.Fragment, {}),
    [ng.ABOUT]: /* @__PURE__ */ ze.jsx(fre, {}),
    [ng.EXPERIENCE]: /* @__PURE__ */ ze.jsx(vre, {}),
    [ng.PROJECTS]: /* @__PURE__ */ ze.jsx(yae, {}),
    [ng.LINKS]: /* @__PURE__ */ ze.jsx(xre, {})
  };
  if (((n) => n in e)(a))
    return e[a];
}, bre = ({ className: a }) => {
  const e = xe.useRef(null), t = xe.useRef(null), { t: n } = Lu(), { pathname: i, search: o } = Pg(), l = xe.useRef(i), [u, I] = xe.useState(u5(i)), f = i.replace("/", "");
  return xe.useEffect(() => {
    e.current && e.current.scrollTo({ top: 0 });
  }, [o]), xe.useEffect(() => {
    const h = e.current;
    if (!h)
      return;
    h.classList.remove("outlet-fadein"), h.classList.add("outlet-fadeout"), h.style.overflow = "hidden";
    const v = Ew(l.current) ? 0 : 200;
    return t.current = setTimeout(() => {
      h.scrollTo({ top: 0 }), I(u5(i)), h.classList.remove("outlet-fadeout"), h.style.overflow = "auto", Ew(i) || h.classList.add("outlet-fadein");
    }, v), l.current = i, () => {
      t.current && clearTimeout(t.current);
    };
  }, [i]), /* @__PURE__ */ ze.jsxs("main", { id: "outlet", ref: e, className: a, children: [
    f && /* @__PURE__ */ ze.jsx("h1", { className: "hidden uppercase", children: n(`nav_${f}`) }),
    u
  ] });
}, Gre = (a) => {
  const e = hp(a);
  El.changeLanguage(e), localStorage.setItem(xw.lang, e);
}, Bre = (a) => {
  const e = window.document.documentElement;
  e.classList.remove(...z2);
  const t = z2.includes(a) ? a : Og.DEFAULT;
  window.dispatchEvent(new CustomEvent("change-theme", { detail: { theme: t } })), localStorage.setItem(xw.theme, t), e.classList.add(t);
}, Sre = "" + new URL("assets/myphoto.webp", import.meta.url).href, Zre = () => {
  const { t: a } = Lu(), e = Sb(), t = Ew(Pg().pathname);
  return /* @__PURE__ */ ze.jsxs(fee, { className: "main-grid", children: [
    /* @__PURE__ */ ze.jsx(uie, { className: t ? "background-home" : "background" }),
    /* @__PURE__ */ ze.jsx("div", { className: t ? "mask-close" : "mask-open" }),
    /* @__PURE__ */ ze.jsx(bre, { className: t ? "outlet-home" : "outlet" }),
    /* @__PURE__ */ ze.jsxs(
      "header",
      {
        className: t ? "my-info" : "my-info-hidden cursor-pointer",
        onClick: () => e(ng.HOME),
        children: [
          /* @__PURE__ */ ze.jsx("img", { draggable: !1, className: "w-28 h-28 object-cover animate-rotateCube", src: Sre, alt: "photo" }),
          /* @__PURE__ */ ze.jsxs("div", { className: "my-title", children: [
            /* @__PURE__ */ ze.jsx("div", { className: "text-2xl xs:text-xl", children: a("myName") }),
            /* @__PURE__ */ ze.jsx("div", { className: "text-sm", children: a("myPosition") })
          ] })
        ]
      }
    ),
    /* @__PURE__ */ ze.jsxs("aside", { className: "setting", children: [
      /* @__PURE__ */ ze.jsx(
        o5,
        {
          defaultChecked: El.language,
          name: "lang",
          options: $Z.map((n) => ({ name: `lang_${n}`, value: n })),
          onChange: Gre
        }
      ),
      /* @__PURE__ */ ze.jsx(
        o5,
        {
          defaultChecked: gY(),
          name: "theme",
          options: z2.map((n) => ({ name: `theme_${n}`, value: n })),
          onChange: Bre
        }
      )
    ] }),
    /* @__PURE__ */ ze.jsx(gre, { className: `mobile-nav-${t ? "fadeout" : "fadein"}` }),
    /* @__PURE__ */ ze.jsx("nav", { className: t ? "btngroup" : "btngroup-hidden", children: cY.map(({ title: n, url: i }) => /* @__PURE__ */ ze.jsx(Tie, { url: i, children: n }, n)) }),
    /* @__PURE__ */ ze.jsx("footer", { className: "footer", children: /* @__PURE__ */ ze.jsx(gie, {}) }),
    /* @__PURE__ */ ze.jsx(yre, { className: "intro-ani" })
  ] });
};
function wre(a) {
  return Mb({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M7.024 3.75c0-.966.784-1.75 1.75-1.75H20.25c.966 0 1.75.784 1.75 1.75v11.498a1.75 1.75 0 0 1-1.75 1.75H8.774a1.75 1.75 0 0 1-1.75-1.75Zm1.75-.25a.25.25 0 0 0-.25.25v11.498c0 .139.112.25.25.25H20.25a.25.25 0 0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25Z" }, child: [] }, { tag: "path", attr: { d: "M1.995 10.749a1.75 1.75 0 0 1 1.75-1.751H5.25a.75.75 0 1 1 0 1.5H3.745a.25.25 0 0 0-.25.25L3.5 20.25c0 .138.111.25.25.25h9.5a.25.25 0 0 0 .25-.25v-1.51a.75.75 0 1 1 1.5 0v1.51A1.75 1.75 0 0 1 13.25 22h-9.5A1.75 1.75 0 0 1 2 20.25l-.005-9.501Z" }, child: [] }] })(a);
}
function c5(a) {
  return Mb({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M15.5 2.25a.75.75 0 0 1 .75-.75h5.5a.75.75 0 0 1 .75.75v5.5a.75.75 0 0 1-1.5 0V4.06l-6.22 6.22a.75.75 0 1 1-1.06-1.06L19.94 3h-3.69a.75.75 0 0 1-.75-.75Z" }, child: [] }, { tag: "path", attr: { d: "M2.5 4.25c0-.966.784-1.75 1.75-1.75h8.5a.75.75 0 0 1 0 1.5h-8.5a.25.25 0 0 0-.25.25v15.5c0 .138.112.25.25.25h15.5a.25.25 0 0 0 .25-.25v-8.5a.75.75 0 0 1 1.5 0v8.5a1.75 1.75 0 0 1-1.75 1.75H4.25a1.75 1.75 0 0 1-1.75-1.75V4.25Z" }, child: [] }] })(a);
}
const CH = ({ title: a, href: e }) => {
  const { t } = Lu(), n = e.replace("mailto:", ""), i = async () => {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText)
        await navigator.clipboard.writeText(n);
      else {
        const o = document.createElement("textarea");
        o.value = n, document.body.appendChild(o), o.select(), document.execCommand("copy"), document.body.removeChild(o);
      }
      l5.success(t("toast_copy"));
    } catch (o) {
      console.error("Failed to copy: ", o), l5.error(t("toast_copy_failed"));
    }
  };
  return /* @__PURE__ */ ze.jsx("li", { children: /* @__PURE__ */ ze.jsxs("div", { className: "flex items-center gap-x-2 flex-wrap", children: [
    /* @__PURE__ */ ze.jsx("span", { className: "capitalize text-nowrap xs:w-14", children: a }),
    /* @__PURE__ */ ze.jsxs("span", { className: "flex items-center gap-2", children: [
      e.includes("mailto:") ? /* @__PURE__ */ ze.jsx("a", { className: "underline xs:hidden", href: e, children: n }) : /* @__PURE__ */ ze.jsx("a", { target: "_blank", rel: "noopener noreferrer", className: "underline xs:hidden", href: e, children: n }),
      e.includes("mailto:") ? /* @__PURE__ */ ze.jsx("a", { className: "underline hidden xs:block", href: e, children: /* @__PURE__ */ ze.jsx(c5, { size: "14px" }) }) : /* @__PURE__ */ ze.jsx("a", { target: "_blank", rel: "noopener noreferrer", className: "underline hidden xs:block", href: e, children: /* @__PURE__ */ ze.jsx(c5, { size: "14px" }) }),
      /* @__PURE__ */ ze.jsx("button", { onClick: i, children: /* @__PURE__ */ ze.jsx(wre, { className: "cursor-pointer", size: "16px" }) })
    ] })
  ] }) });
}, Rre = ({ children: a }) => /* @__PURE__ */ ze.jsx("ul", { className: "linkList", children: a }), xre = () => {
  const { t: a } = Lu();
  return /* @__PURE__ */ ze.jsx(JW, { title: a("subtitle_links"), children: /* @__PURE__ */ ze.jsxs(Rre, { children: [
    /* @__PURE__ */ ze.jsx(CH, { title: a("link_email"), href: "mailto:randywu417@gmail.com" }),
    /* @__PURE__ */ ze.jsx(CH, { title: a("link_git"), href: "https://github.com/randywu417" }),
    /* @__PURE__ */ ze.jsx(CH, { title: a("link_youtube"), href: "https://www.youtube.com/@randywu417" })
  ] }) });
};
function Wre(a) {
  return Mb({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M10 12.796V3.204L4.519 8zm-.659.753-5.48-4.796a1 1 0 0 1 0-1.506l5.48-4.796A1 1 0 0 1 11 3.204v9.592a1 1 0 0 1-1.659.753" }, child: [] }] })(a);
}
function Vre(a) {
  return Mb({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M6 12.796V3.204L11.481 8zm.659.753 5.48-4.796a1 1 0 0 0 0-1.506L6.66 2.451C6.011 1.885 5 2.345 5 3.204v9.592a1 1 0 0 0 1.659.753" }, child: [] }] })(a);
}
var K9 = { exports: {} };
(function(a, e) {
  (function(t, n) {
    a.exports = n(xe);
  })(lZ, (t) => (() => {
    var n = { 703: (u, I, f) => {
      var h = f(414);
      function v() {
      }
      function b() {
      }
      b.resetWarningCache = v, u.exports = function() {
        function S(x, M, T, E, _, P) {
          if (P !== h) {
            var U = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw U.name = "Invariant Violation", U;
          }
        }
        function R() {
          return S;
        }
        S.isRequired = S;
        var W = { array: S, bool: S, func: S, number: S, object: S, string: S, symbol: S, any: S, arrayOf: R, element: S, elementType: S, instanceOf: R, node: S, objectOf: R, oneOf: R, oneOfType: R, shape: R, exact: R, checkPropTypes: b, resetWarningCache: v };
        return W.PropTypes = W, W;
      };
    }, 697: (u, I, f) => {
      u.exports = f(703)();
    }, 414: (u) => {
      u.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    }, 590: (u) => {
      var I = typeof Element < "u", f = typeof Map == "function", h = typeof Set == "function", v = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
      function b(S, R) {
        if (S === R) return !0;
        if (S && R && typeof S == "object" && typeof R == "object") {
          if (S.constructor !== R.constructor) return !1;
          var W, x, M, T;
          if (Array.isArray(S)) {
            if ((W = S.length) != R.length) return !1;
            for (x = W; x-- != 0; ) if (!b(S[x], R[x])) return !1;
            return !0;
          }
          if (f && S instanceof Map && R instanceof Map) {
            if (S.size !== R.size) return !1;
            for (T = S.entries(); !(x = T.next()).done; ) if (!R.has(x.value[0])) return !1;
            for (T = S.entries(); !(x = T.next()).done; ) if (!b(x.value[1], R.get(x.value[0]))) return !1;
            return !0;
          }
          if (h && S instanceof Set && R instanceof Set) {
            if (S.size !== R.size) return !1;
            for (T = S.entries(); !(x = T.next()).done; ) if (!R.has(x.value[0])) return !1;
            return !0;
          }
          if (v && ArrayBuffer.isView(S) && ArrayBuffer.isView(R)) {
            if ((W = S.length) != R.length) return !1;
            for (x = W; x-- != 0; ) if (S[x] !== R[x]) return !1;
            return !0;
          }
          if (S.constructor === RegExp) return S.source === R.source && S.flags === R.flags;
          if (S.valueOf !== Object.prototype.valueOf) return S.valueOf() === R.valueOf();
          if (S.toString !== Object.prototype.toString) return S.toString() === R.toString();
          if ((W = (M = Object.keys(S)).length) !== Object.keys(R).length) return !1;
          for (x = W; x-- != 0; ) if (!Object.prototype.hasOwnProperty.call(R, M[x])) return !1;
          if (I && S instanceof Element) return !1;
          for (x = W; x-- != 0; ) if ((M[x] !== "_owner" && M[x] !== "__v" && M[x] !== "__o" || !S.$$typeof) && !b(S[M[x]], R[M[x]])) return !1;
          return !0;
        }
        return S != S && R != R;
      }
      u.exports = function(S, R) {
        try {
          return b(S, R);
        } catch (W) {
          if ((W.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1;
          throw W;
        }
      };
    }, 359: (u) => {
      u.exports = t;
    } }, i = {};
    function o(u) {
      var I = i[u];
      if (I !== void 0) return I.exports;
      var f = i[u] = { exports: {} };
      return n[u](f, f.exports, o), f.exports;
    }
    o.n = (u) => {
      var I = u && u.__esModule ? () => u.default : () => u;
      return o.d(I, { a: I }), I;
    }, o.d = (u, I) => {
      for (var f in I) o.o(I, f) && !o.o(u, f) && Object.defineProperty(u, f, { enumerable: !0, get: I[f] });
    }, o.g = function() {
      if (typeof globalThis == "object") return globalThis;
      try {
        return this || new Function("return this")();
      } catch {
        if (typeof window == "object") return window;
      }
    }(), o.o = (u, I) => Object.prototype.hasOwnProperty.call(u, I), o.r = (u) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(u, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(u, "__esModule", { value: !0 });
    };
    var l = {};
    return (() => {
      function u(ge) {
        var ue, We, et = "";
        if (typeof ge == "string" || typeof ge == "number") et += ge;
        else if (typeof ge == "object") if (Array.isArray(ge)) for (ue = 0; ue < ge.length; ue++) ge[ue] && (We = u(ge[ue])) && (et && (et += " "), et += We);
        else for (ue in ge) ge[ue] && (et && (et += " "), et += ue);
        return et;
      }
      function I() {
        for (var ge, ue, We = 0, et = ""; We < arguments.length; ) (ge = arguments[We++]) && (ue = u(ge)) && (et && (et += " "), et += ue);
        return et;
      }
      o.r(l), o.d(l, { default: () => Ln });
      var f = o(359), h = o.n(f);
      const v = function(ge) {
        var ue = typeof ge;
        return ge != null && (ue == "object" || ue == "function");
      }, b = typeof lZ == "object" && lZ && lZ.Object === Object && lZ;
      var S = typeof self == "object" && self && self.Object === Object && self;
      const R = b || S || Function("return this")(), W = function() {
        return R.Date.now();
      };
      var x = /\s/, M = /^\s+/;
      const T = function(ge) {
        return ge && ge.slice(0, function(ue) {
          for (var We = ue.length; We-- && x.test(ue.charAt(We)); ) ;
          return We;
        }(ge) + 1).replace(M, "");
      }, E = R.Symbol;
      var _ = Object.prototype, P = _.hasOwnProperty, U = _.toString, q = E ? E.toStringTag : void 0, k = Object.prototype.toString, O = E ? E.toStringTag : void 0;
      const J = function(ge) {
        return ge == null ? ge === void 0 ? "[object Undefined]" : "[object Null]" : O && O in Object(ge) ? function(ue) {
          var We = P.call(ue, q), et = ue[q];
          try {
            ue[q] = void 0;
            var Mt = !0;
          } catch {
          }
          var bn = U.call(ue);
          return Mt && (We ? ue[q] = et : delete ue[q]), bn;
        }(ge) : function(ue) {
          return k.call(ue);
        }(ge);
      };
      var te = /^[-+]0x[0-9a-f]+$/i, fe = /^0b[01]+$/i, pe = /^0o[0-7]+$/i, Ae = parseInt;
      const Te = function(ge) {
        if (typeof ge == "number") return ge;
        if (function(et) {
          return typeof et == "symbol" || function(Mt) {
            return Mt != null && typeof Mt == "object";
          }(et) && J(et) == "[object Symbol]";
        }(ge)) return NaN;
        if (v(ge)) {
          var ue = typeof ge.valueOf == "function" ? ge.valueOf() : ge;
          ge = v(ue) ? ue + "" : ue;
        }
        if (typeof ge != "string") return ge === 0 ? ge : +ge;
        ge = T(ge);
        var We = fe.test(ge);
        return We || pe.test(ge) ? Ae(ge.slice(2), We ? 2 : 8) : te.test(ge) ? NaN : +ge;
      };
      var Ke = Math.max, je = Math.min;
      const ee = function(ge, ue, We) {
        var et, Mt, bn, Ai, ve, Be, mt = 0, $t = !1, In = !1, un = !0;
        if (typeof ge != "function") throw new TypeError("Expected a function");
        function Bi(ti) {
          var Di = et, qi = Mt;
          return et = Mt = void 0, mt = ti, Ai = ge.apply(qi, Di);
        }
        function Si(ti) {
          return mt = ti, ve = setTimeout(En, ue), $t ? Bi(ti) : Ai;
        }
        function Ji(ti) {
          var Di = ti - Be;
          return Be === void 0 || Di >= ue || Di < 0 || In && ti - mt >= bn;
        }
        function En() {
          var ti = W();
          if (Ji(ti)) return cn(ti);
          ve = setTimeout(En, function(Di) {
            var qi = ue - (Di - Be);
            return In ? je(qi, bn - (Di - mt)) : qi;
          }(ti));
        }
        function cn(ti) {
          return ve = void 0, un && et ? Bi(ti) : (et = Mt = void 0, Ai);
        }
        function kn() {
          var ti = W(), Di = Ji(ti);
          if (et = arguments, Mt = this, Be = ti, Di) {
            if (ve === void 0) return Si(Be);
            if (In) return clearTimeout(ve), ve = setTimeout(En, ue), Bi(Be);
          }
          return ve === void 0 && (ve = setTimeout(En, ue)), Ai;
        }
        return ue = Te(ue) || 0, v(We) && ($t = !!We.leading, bn = (In = "maxWait" in We) ? Ke(Te(We.maxWait) || 0, ue) : bn, un = "trailing" in We ? !!We.trailing : un), kn.cancel = function() {
          ve !== void 0 && clearTimeout(ve), mt = 0, et = Be = Mt = ve = void 0;
        }, kn.flush = function() {
          return ve === void 0 ? Ai : cn(W());
        }, kn;
      }, Ce = function(ge, ue, We) {
        var et = !0, Mt = !0;
        if (typeof ge != "function") throw new TypeError("Expected a function");
        return v(We) && (et = "leading" in We ? !!We.leading : et, Mt = "trailing" in We ? !!We.trailing : Mt), ee(ge, ue, { leading: et, maxWait: ue, trailing: Mt });
      };
      var be = o(590), le = o.n(be), Ye = function() {
        if (typeof Map < "u") return Map;
        function ge(ue, We) {
          var et = -1;
          return ue.some(function(Mt, bn) {
            return Mt[0] === We && (et = bn, !0);
          }), et;
        }
        return function() {
          function ue() {
            this.__entries__ = [];
          }
          return Object.defineProperty(ue.prototype, "size", { get: function() {
            return this.__entries__.length;
          }, enumerable: !0, configurable: !0 }), ue.prototype.get = function(We) {
            var et = ge(this.__entries__, We), Mt = this.__entries__[et];
            return Mt && Mt[1];
          }, ue.prototype.set = function(We, et) {
            var Mt = ge(this.__entries__, We);
            ~Mt ? this.__entries__[Mt][1] = et : this.__entries__.push([We, et]);
          }, ue.prototype.delete = function(We) {
            var et = this.__entries__, Mt = ge(et, We);
            ~Mt && et.splice(Mt, 1);
          }, ue.prototype.has = function(We) {
            return !!~ge(this.__entries__, We);
          }, ue.prototype.clear = function() {
            this.__entries__.splice(0);
          }, ue.prototype.forEach = function(We, et) {
            et === void 0 && (et = null);
            for (var Mt = 0, bn = this.__entries__; Mt < bn.length; Mt++) {
              var Ai = bn[Mt];
              We.call(et, Ai[1], Ai[0]);
            }
          }, ue;
        }();
      }(), $e = typeof window < "u" && typeof document < "u" && window.document === document, ke = o.g !== void 0 && o.g.Math === Math ? o.g : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")(), ot = typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(ke) : function(ge) {
        return setTimeout(function() {
          return ge(Date.now());
        }, 1e3 / 60);
      }, wt = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], St = typeof MutationObserver < "u", ln = function() {
        function ge() {
          this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = /* @__PURE__ */ function(ue, We) {
            var et = !1, Mt = !1, bn = 0;
            function Ai() {
              et && (et = !1, ue()), Mt && Be();
            }
            function ve() {
              ot(Ai);
            }
            function Be() {
              var mt = Date.now();
              if (et) {
                if (mt - bn < 2) return;
                Mt = !0;
              } else et = !0, Mt = !1, setTimeout(ve, 20);
              bn = mt;
            }
            return Be;
          }(this.refresh.bind(this));
        }
        return ge.prototype.addObserver = function(ue) {
          ~this.observers_.indexOf(ue) || this.observers_.push(ue), this.connected_ || this.connect_();
        }, ge.prototype.removeObserver = function(ue) {
          var We = this.observers_, et = We.indexOf(ue);
          ~et && We.splice(et, 1), !We.length && this.connected_ && this.disconnect_();
        }, ge.prototype.refresh = function() {
          this.updateObservers_() && this.refresh();
        }, ge.prototype.updateObservers_ = function() {
          var ue = this.observers_.filter(function(We) {
            return We.gatherActive(), We.hasActive();
          });
          return ue.forEach(function(We) {
            return We.broadcastActive();
          }), ue.length > 0;
        }, ge.prototype.connect_ = function() {
          $e && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), St ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, { attributes: !0, childList: !0, characterData: !0, subtree: !0 })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
        }, ge.prototype.disconnect_ = function() {
          $e && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
        }, ge.prototype.onTransitionEnd_ = function(ue) {
          var We = ue.propertyName, et = We === void 0 ? "" : We;
          wt.some(function(Mt) {
            return !!~et.indexOf(Mt);
          }) && this.refresh();
        }, ge.getInstance = function() {
          return this.instance_ || (this.instance_ = new ge()), this.instance_;
        }, ge.instance_ = null, ge;
      }(), hn = function(ge, ue) {
        for (var We = 0, et = Object.keys(ue); We < et.length; We++) {
          var Mt = et[We];
          Object.defineProperty(ge, Mt, { value: ue[Mt], enumerable: !1, writable: !1, configurable: !0 });
        }
        return ge;
      }, mn = function(ge) {
        return ge && ge.ownerDocument && ge.ownerDocument.defaultView || ke;
      }, Pn = Gt(0, 0, 0, 0);
      function he(ge) {
        return parseFloat(ge) || 0;
      }
      function Lt(ge) {
        for (var ue = [], We = 1; We < arguments.length; We++) ue[We - 1] = arguments[We];
        return ue.reduce(function(et, Mt) {
          return et + he(ge["border-" + Mt + "-width"]);
        }, 0);
      }
      var Wt = typeof SVGGraphicsElement < "u" ? function(ge) {
        return ge instanceof mn(ge).SVGGraphicsElement;
      } : function(ge) {
        return ge instanceof mn(ge).SVGElement && typeof ge.getBBox == "function";
      };
      function tn(ge) {
        return $e ? Wt(ge) ? function(ue) {
          var We = ue.getBBox();
          return Gt(0, 0, We.width, We.height);
        }(ge) : function(ue) {
          var We = ue.clientWidth, et = ue.clientHeight;
          if (!We && !et) return Pn;
          var Mt = mn(ue).getComputedStyle(ue), bn = function(un) {
            for (var Bi = {}, Si = 0, Ji = ["top", "right", "bottom", "left"]; Si < Ji.length; Si++) {
              var En = Ji[Si], cn = un["padding-" + En];
              Bi[En] = he(cn);
            }
            return Bi;
          }(Mt), Ai = bn.left + bn.right, ve = bn.top + bn.bottom, Be = he(Mt.width), mt = he(Mt.height);
          if (Mt.boxSizing === "border-box" && (Math.round(Be + Ai) !== We && (Be -= Lt(Mt, "left", "right") + Ai), Math.round(mt + ve) !== et && (mt -= Lt(Mt, "top", "bottom") + ve)), !function(un) {
            return un === mn(un).document.documentElement;
          }(ue)) {
            var $t = Math.round(Be + Ai) - We, In = Math.round(mt + ve) - et;
            Math.abs($t) !== 1 && (Be -= $t), Math.abs(In) !== 1 && (mt -= In);
          }
          return Gt(bn.left, bn.top, Be, mt);
        }(ge) : Pn;
      }
      function Gt(ge, ue, We, et) {
        return { x: ge, y: ue, width: We, height: et };
      }
      var Rn = function() {
        function ge(ue) {
          this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = Gt(0, 0, 0, 0), this.target = ue;
        }
        return ge.prototype.isActive = function() {
          var ue = tn(this.target);
          return this.contentRect_ = ue, ue.width !== this.broadcastWidth || ue.height !== this.broadcastHeight;
        }, ge.prototype.broadcastRect = function() {
          var ue = this.contentRect_;
          return this.broadcastWidth = ue.width, this.broadcastHeight = ue.height, ue;
        }, ge;
      }(), nn = function(ge, ue) {
        var We, et, Mt, bn, Ai, ve, Be, mt = (et = (We = ue).x, Mt = We.y, bn = We.width, Ai = We.height, ve = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, Be = Object.create(ve.prototype), hn(Be, { x: et, y: Mt, width: bn, height: Ai, top: Mt, right: et + bn, bottom: Ai + Mt, left: et }), Be);
        hn(this, { target: ge, contentRect: mt });
      }, Bn = function() {
        function ge(ue, We, et) {
          if (this.activeObservations_ = [], this.observations_ = new Ye(), typeof ue != "function") throw new TypeError("The callback provided as parameter 1 is not a function.");
          this.callback_ = ue, this.controller_ = We, this.callbackCtx_ = et;
        }
        return ge.prototype.observe = function(ue) {
          if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
          if (typeof Element < "u" && Element instanceof Object) {
            if (!(ue instanceof mn(ue).Element)) throw new TypeError('parameter 1 is not of type "Element".');
            var We = this.observations_;
            We.has(ue) || (We.set(ue, new Rn(ue)), this.controller_.addObserver(this), this.controller_.refresh());
          }
        }, ge.prototype.unobserve = function(ue) {
          if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
          if (typeof Element < "u" && Element instanceof Object) {
            if (!(ue instanceof mn(ue).Element)) throw new TypeError('parameter 1 is not of type "Element".');
            var We = this.observations_;
            We.has(ue) && (We.delete(ue), We.size || this.controller_.removeObserver(this));
          }
        }, ge.prototype.disconnect = function() {
          this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
        }, ge.prototype.gatherActive = function() {
          var ue = this;
          this.clearActive(), this.observations_.forEach(function(We) {
            We.isActive() && ue.activeObservations_.push(We);
          });
        }, ge.prototype.broadcastActive = function() {
          if (this.hasActive()) {
            var ue = this.callbackCtx_, We = this.activeObservations_.map(function(et) {
              return new nn(et.target, et.broadcastRect());
            });
            this.callback_.call(ue, We, ue), this.clearActive();
          }
        }, ge.prototype.clearActive = function() {
          this.activeObservations_.splice(0);
        }, ge.prototype.hasActive = function() {
          return this.activeObservations_.length > 0;
        }, ge;
      }(), Se = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new Ye(), oe = function ge(ue) {
        if (!(this instanceof ge)) throw new TypeError("Cannot call a class as a function.");
        if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
        var We = ln.getInstance(), et = new Bn(ue, We, this);
        Se.set(this, et);
      };
      ["observe", "unobserve", "disconnect"].forEach(function(ge) {
        oe.prototype[ge] = function() {
          var ue;
          return (ue = Se.get(this))[ge].apply(ue, arguments);
        };
      });
      const ct = ke.ResizeObserver !== void 0 ? ke.ResizeObserver : oe, Ft = "Left", pt = "Right", zt = "Up", Sn = "Down", rn = { delta: 10, preventScrollOnSwipe: !1, rotationAngle: 0, trackMouse: !1, trackTouch: !0, swipeDuration: 1 / 0, touchEventOptions: { passive: !0 } }, gn = { first: !0, initial: [0, 0], start: 0, swiping: !1, xy: [0, 0] }, qn = "mousemove", qt = "mouseup";
      function An(ge, ue) {
        if (ue === 0) return ge;
        const We = Math.PI / 180 * ue;
        return [ge[0] * Math.cos(We) + ge[1] * Math.sin(We), ge[1] * Math.cos(We) - ge[0] * Math.sin(We)];
      }
      function Fe(ge) {
        const { trackMouse: ue } = ge, We = f.useRef(Object.assign({}, gn)), et = f.useRef(Object.assign({}, rn)), Mt = f.useRef(Object.assign({}, et.current));
        let bn;
        for (bn in Mt.current = Object.assign({}, et.current), et.current = Object.assign(Object.assign({}, rn), ge), rn) et.current[bn] === void 0 && (et.current[bn] = rn[bn]);
        const [Ai, ve] = f.useMemo(() => function(Be, mt) {
          const $t = (En) => {
            const cn = "touches" in En;
            cn && En.touches.length > 1 || Be((kn, ti) => {
              ti.trackMouse && !cn && (document.addEventListener(qn, In), document.addEventListener(qt, Bi));
              const { clientX: Di, clientY: qi } = cn ? En.touches[0] : En, ci = An([Di, qi], ti.rotationAngle);
              return ti.onTouchStartOrOnMouseDown && ti.onTouchStartOrOnMouseDown({ event: En }), Object.assign(Object.assign(Object.assign({}, kn), gn), { initial: ci.slice(), xy: ci, start: En.timeStamp || 0 });
            });
          }, In = (En) => {
            Be((cn, kn) => {
              const ti = "touches" in En;
              if (ti && En.touches.length > 1) return cn;
              if (En.timeStamp - cn.start > kn.swipeDuration) return cn.swiping ? Object.assign(Object.assign({}, cn), { swiping: !1 }) : cn;
              const { clientX: Di, clientY: qi } = ti ? En.touches[0] : En, [ci, Hr] = An([Di, qi], kn.rotationAngle), Za = ci - cn.xy[0], gi = Hr - cn.xy[1], yr = Math.abs(Za), Hn = Math.abs(gi), Pa = (En.timeStamp || 0) - cn.start, zo = Math.sqrt(yr * yr + Hn * Hn) / (Pa || 1), Ko = [Za / (Pa || 1), gi / (Pa || 1)], Xr = function(Lo, ko, cu, Ja) {
                return Lo > ko ? cu > 0 ? pt : Ft : Ja > 0 ? Sn : zt;
              }(yr, Hn, Za, gi), ia = typeof kn.delta == "number" ? kn.delta : kn.delta[Xr.toLowerCase()] || rn.delta;
              if (yr < ia && Hn < ia && !cn.swiping) return cn;
              const kr = { absX: yr, absY: Hn, deltaX: Za, deltaY: gi, dir: Xr, event: En, first: cn.first, initial: cn.initial, velocity: zo, vxvy: Ko };
              kr.first && kn.onSwipeStart && kn.onSwipeStart(kr), kn.onSwiping && kn.onSwiping(kr);
              let ua = !1;
              return (kn.onSwiping || kn.onSwiped || kn[`onSwiped${Xr}`]) && (ua = !0), ua && kn.preventScrollOnSwipe && kn.trackTouch && En.cancelable && En.preventDefault(), Object.assign(Object.assign({}, cn), { first: !1, eventData: kr, swiping: !0 });
            });
          }, un = (En) => {
            Be((cn, kn) => {
              let ti;
              if (cn.swiping && cn.eventData) {
                if (En.timeStamp - cn.start < kn.swipeDuration) {
                  ti = Object.assign(Object.assign({}, cn.eventData), { event: En }), kn.onSwiped && kn.onSwiped(ti);
                  const Di = kn[`onSwiped${ti.dir}`];
                  Di && Di(ti);
                }
              } else kn.onTap && kn.onTap({ event: En });
              return kn.onTouchEndOrOnMouseUp && kn.onTouchEndOrOnMouseUp({ event: En }), Object.assign(Object.assign(Object.assign({}, cn), gn), { eventData: ti });
            });
          }, Bi = (En) => {
            document.removeEventListener(qn, In), document.removeEventListener(qt, Bi), un(En);
          }, Si = (En, cn) => {
            let kn = () => {
            };
            if (En && En.addEventListener) {
              const ti = Object.assign(Object.assign({}, rn.touchEventOptions), cn.touchEventOptions), Di = [["touchstart", $t, ti], ["touchmove", In, Object.assign(Object.assign({}, ti), cn.preventScrollOnSwipe ? { passive: !1 } : {})], ["touchend", un, ti]];
              Di.forEach(([qi, ci, Hr]) => En.addEventListener(qi, ci, Hr)), kn = () => Di.forEach(([qi, ci]) => En.removeEventListener(qi, ci));
            }
            return kn;
          }, Ji = { ref: (En) => {
            En !== null && Be((cn, kn) => {
              if (cn.el === En) return cn;
              const ti = {};
              return cn.el && cn.el !== En && cn.cleanUpTouch && (cn.cleanUpTouch(), ti.cleanUpTouch = void 0), kn.trackTouch && En && (ti.cleanUpTouch = Si(En, kn)), Object.assign(Object.assign(Object.assign({}, cn), { el: En }), ti);
            });
          } };
          return mt.trackMouse && (Ji.onMouseDown = $t), [Ji, Si];
        }((Be) => We.current = Be(We.current, et.current), { trackMouse: ue }), [ue]);
        return We.current = function(Be, mt, $t, In) {
          return mt.trackTouch && Be.el ? Be.cleanUpTouch ? mt.preventScrollOnSwipe !== $t.preventScrollOnSwipe || mt.touchEventOptions.passive !== $t.touchEventOptions.passive ? (Be.cleanUpTouch(), Object.assign(Object.assign({}, Be), { cleanUpTouch: In(Be.el, mt) })) : Be : Object.assign(Object.assign({}, Be), { cleanUpTouch: In(Be.el, mt) }) : (Be.cleanUpTouch && Be.cleanUpTouch(), Object.assign(Object.assign({}, Be), { cleanUpTouch: void 0 }));
        }(We.current, et.current, Mt.current, ve), Ai;
      }
      var Ie = o(697);
      function at(ge) {
        return at = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
          return typeof ue;
        } : function(ue) {
          return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue;
        }, at(ge);
      }
      function ye(ge, ue) {
        var We = Object.keys(ge);
        if (Object.getOwnPropertySymbols) {
          var et = Object.getOwnPropertySymbols(ge);
          ue && (et = et.filter(function(Mt) {
            return Object.getOwnPropertyDescriptor(ge, Mt).enumerable;
          })), We.push.apply(We, et);
        }
        return We;
      }
      function Pe(ge) {
        for (var ue = 1; ue < arguments.length; ue++) {
          var We = arguments[ue] != null ? arguments[ue] : {};
          ue % 2 ? ye(Object(We), !0).forEach(function(et) {
            Ot(ge, et, We[et]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ge, Object.getOwnPropertyDescriptors(We)) : ye(Object(We)).forEach(function(et) {
            Object.defineProperty(ge, et, Object.getOwnPropertyDescriptor(We, et));
          });
        }
        return ge;
      }
      function Ot(ge, ue, We) {
        return (ue = function(et) {
          var Mt = function(bn, Ai) {
            if (at(bn) !== "object" || bn === null) return bn;
            var ve = bn[Symbol.toPrimitive];
            if (ve !== void 0) {
              var Be = ve.call(bn, Ai);
              if (at(Be) !== "object") return Be;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(bn);
          }(et, "string");
          return at(Mt) === "symbol" ? Mt : String(Mt);
        }(ue)) in ge ? Object.defineProperty(ge, ue, { value: We, enumerable: !0, configurable: !0, writable: !0 }) : ge[ue] = We, ge;
      }
      var Re = { description: "", fullscreen: "", isFullscreen: !1, originalAlt: "", originalHeight: "", originalWidth: "", originalTitle: "", sizes: "", srcSet: "", loading: "eager" }, lt = h().memo(function(ge) {
        var ue = Pe(Pe({}, Re), ge), We = ue.description, et = ue.fullscreen, Mt = ue.handleImageLoaded, bn = ue.isFullscreen, Ai = ue.onImageError, ve = ue.original, Be = ue.originalAlt, mt = ue.originalHeight, $t = ue.originalWidth, In = ue.originalTitle, un = ue.sizes, Bi = ue.srcSet, Si = ue.loading, Ji = bn && et || ve;
        return h().createElement(h().Fragment, null, h().createElement("img", { className: "image-gallery-image", src: Ji, alt: Be, srcSet: Bi, height: mt, width: $t, sizes: un, title: In, onLoad: function(En) {
          return Mt(En, ve);
        }, onError: Ai, loading: Si }), We && h().createElement("span", { className: "image-gallery-description" }, We));
      });
      lt.displayName = "Item", lt.propTypes = { description: Ie.string, fullscreen: Ie.string, handleImageLoaded: Ie.func.isRequired, isFullscreen: Ie.bool, onImageError: Ie.func.isRequired, original: Ie.string.isRequired, originalAlt: Ie.string, originalHeight: Ie.string, originalWidth: Ie.string, originalTitle: Ie.string, sizes: Ie.string, srcSet: Ie.string, loading: Ie.string };
      const _e = lt;
      function ht(ge) {
        return ht = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
          return typeof ue;
        } : function(ue) {
          return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue;
        }, ht(ge);
      }
      function Ht(ge, ue) {
        var We = Object.keys(ge);
        if (Object.getOwnPropertySymbols) {
          var et = Object.getOwnPropertySymbols(ge);
          ue && (et = et.filter(function(Mt) {
            return Object.getOwnPropertyDescriptor(ge, Mt).enumerable;
          })), We.push.apply(We, et);
        }
        return We;
      }
      function an(ge) {
        for (var ue = 1; ue < arguments.length; ue++) {
          var We = arguments[ue] != null ? arguments[ue] : {};
          ue % 2 ? Ht(Object(We), !0).forEach(function(et) {
            fi(ge, et, We[et]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ge, Object.getOwnPropertyDescriptors(We)) : Ht(Object(We)).forEach(function(et) {
            Object.defineProperty(ge, et, Object.getOwnPropertyDescriptor(We, et));
          });
        }
        return ge;
      }
      function fi(ge, ue, We) {
        return (ue = function(et) {
          var Mt = function(bn, Ai) {
            if (ht(bn) !== "object" || bn === null) return bn;
            var ve = bn[Symbol.toPrimitive];
            if (ve !== void 0) {
              var Be = ve.call(bn, Ai);
              if (ht(Be) !== "object") return Be;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(bn);
          }(et, "string");
          return ht(Mt) === "symbol" ? Mt : String(Mt);
        }(ue)) in ge ? Object.defineProperty(ge, ue, { value: We, enumerable: !0, configurable: !0, writable: !0 }) : ge[ue] = We, ge;
      }
      var xi = { left: h().createElement("polyline", { points: "15 18 9 12 15 6" }), right: h().createElement("polyline", { points: "9 18 15 12 9 6" }), maximize: h().createElement("path", { d: "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" }), minimize: h().createElement("path", { d: "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" }), play: h().createElement("polygon", { points: "5 3 19 12 5 21 5 3" }), pause: h().createElement(h().Fragment, null, h().createElement("rect", { x: "6", y: "4", width: "4", height: "16" }), h().createElement("rect", { x: "14", y: "4", width: "4", height: "16" })) }, Ir = { strokeWidth: 1, viewBox: "0 0 24 24" }, Xi = function(ge) {
        var ue = an(an({}, Ir), ge), We = ue.strokeWidth, et = ue.viewBox, Mt = ue.icon;
        return h().createElement("svg", { className: "image-gallery-svg", xmlns: "http://www.w3.org/2000/svg", viewBox: et, fill: "none", stroke: "currentColor", strokeWidth: We, strokeLinecap: "round", strokeLinejoin: "round" }, xi[Mt]);
      };
      Xi.propTypes = { strokeWidth: Ie.number, viewBox: Ie.string, icon: (0, Ie.oneOf)(["left", "right", "maximize", "minimize", "play", "pause"]).isRequired };
      const pi = Xi;
      var Cr = h().memo(function(ge) {
        var ue = ge.isFullscreen, We = ge.onClick;
        return h().createElement("button", { type: "button", className: "image-gallery-icon image-gallery-fullscreen-button", onClick: We, "aria-label": "Open Fullscreen" }, h().createElement(pi, { strokeWidth: 2, icon: ue ? "minimize" : "maximize" }));
      });
      Cr.displayName = "Fullscreen", Cr.propTypes = { isFullscreen: Ie.bool.isRequired, onClick: Ie.func.isRequired };
      const Sa = Cr;
      var zr = h().memo(function(ge) {
        var ue = ge.disabled, We = ge.onClick;
        return h().createElement("button", { type: "button", className: "image-gallery-icon image-gallery-left-nav", disabled: ue, onClick: We, "aria-label": "Previous Slide" }, h().createElement(pi, { icon: "left", viewBox: "6 0 12 24" }));
      });
      zr.displayName = "LeftNav", zr.propTypes = { disabled: Ie.bool.isRequired, onClick: Ie.func.isRequired };
      const na = zr;
      var la = h().memo(function(ge) {
        var ue = ge.disabled, We = ge.onClick;
        return h().createElement("button", { type: "button", className: "image-gallery-icon image-gallery-right-nav", disabled: ue, onClick: We, "aria-label": "Next Slide" }, h().createElement(pi, { icon: "right", viewBox: "6 0 12 24" }));
      });
      la.displayName = "RightNav", la.propTypes = { disabled: Ie.bool.isRequired, onClick: Ie.func.isRequired };
      const Oa = la;
      var Le = h().memo(function(ge) {
        var ue = ge.isPlaying, We = ge.onClick;
        return h().createElement("button", { type: "button", className: "image-gallery-icon image-gallery-play-button", onClick: We, "aria-label": "Play or Pause Slideshow" }, h().createElement(pi, { strokeWidth: 2, icon: ue ? "pause" : "play" }));
      });
      Le.displayName = "PlayPause", Le.propTypes = { isPlaying: Ie.bool.isRequired, onClick: Ie.func.isRequired };
      const qe = Le;
      function gt(ge) {
        return gt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
          return typeof ue;
        } : function(ue) {
          return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue;
        }, gt(ge);
      }
      function Pt() {
        return Pt = Object.assign ? Object.assign.bind() : function(ge) {
          for (var ue = 1; ue < arguments.length; ue++) {
            var We = arguments[ue];
            for (var et in We) Object.prototype.hasOwnProperty.call(We, et) && (ge[et] = We[et]);
          }
          return ge;
        }, Pt.apply(this, arguments);
      }
      function me(ge, ue) {
        var We = Object.keys(ge);
        if (Object.getOwnPropertySymbols) {
          var et = Object.getOwnPropertySymbols(ge);
          ue && (et = et.filter(function(Mt) {
            return Object.getOwnPropertyDescriptor(ge, Mt).enumerable;
          })), We.push.apply(We, et);
        }
        return We;
      }
      function ut(ge) {
        for (var ue = 1; ue < arguments.length; ue++) {
          var We = arguments[ue] != null ? arguments[ue] : {};
          ue % 2 ? me(Object(We), !0).forEach(function(et) {
            Bt(ge, et, We[et]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ge, Object.getOwnPropertyDescriptors(We)) : me(Object(We)).forEach(function(et) {
            Object.defineProperty(ge, et, Object.getOwnPropertyDescriptor(We, et));
          });
        }
        return ge;
      }
      function Bt(ge, ue, We) {
        return (ue = function(et) {
          var Mt = function(bn, Ai) {
            if (gt(bn) !== "object" || bn === null) return bn;
            var ve = bn[Symbol.toPrimitive];
            if (ve !== void 0) {
              var Be = ve.call(bn, Ai);
              if (gt(Be) !== "object") return Be;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(bn);
          }(et, "string");
          return gt(Mt) === "symbol" ? Mt : String(Mt);
        }(ue)) in ge ? Object.defineProperty(ge, ue, { value: We, enumerable: !0, configurable: !0, writable: !0 }) : ge[ue] = We, ge;
      }
      var Tt = { className: "", delta: 0, onSwiping: function() {
      }, onSwiped: function() {
      } }, ae = function(ge) {
        var ue = ut(ut({}, Tt), ge), We = ue.children, et = ue.className, Mt = Fe({ delta: ue.delta, onSwiping: ue.onSwiping, onSwiped: ue.onSwiped });
        return h().createElement("div", Pt({}, Mt, { className: et }), We);
      };
      ae.propTypes = { children: Ie.node.isRequired, className: Ie.string, delta: Ie.number, onSwiped: Ie.func, onSwiping: Ie.func };
      const we = ae;
      function Ee(ge) {
        return Ee = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
          return typeof ue;
        } : function(ue) {
          return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue;
        }, Ee(ge);
      }
      function Ue(ge, ue) {
        var We = Object.keys(ge);
        if (Object.getOwnPropertySymbols) {
          var et = Object.getOwnPropertySymbols(ge);
          ue && (et = et.filter(function(Mt) {
            return Object.getOwnPropertyDescriptor(ge, Mt).enumerable;
          })), We.push.apply(We, et);
        }
        return We;
      }
      function Oe(ge) {
        for (var ue = 1; ue < arguments.length; ue++) {
          var We = arguments[ue] != null ? arguments[ue] : {};
          ue % 2 ? Ue(Object(We), !0).forEach(function(et) {
            Fn(ge, et, We[et]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ge, Object.getOwnPropertyDescriptors(We)) : Ue(Object(We)).forEach(function(et) {
            Object.defineProperty(ge, et, Object.getOwnPropertyDescriptor(We, et));
          });
        }
        return ge;
      }
      function Nt(ge, ue) {
        for (var We = 0; We < ue.length; We++) {
          var et = ue[We];
          et.enumerable = et.enumerable || !1, et.configurable = !0, "value" in et && (et.writable = !0), Object.defineProperty(ge, _n(et.key), et);
        }
      }
      function Kt(ge, ue) {
        return Kt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(We, et) {
          return We.__proto__ = et, We;
        }, Kt(ge, ue);
      }
      function vn(ge, ue) {
        if (ue && (Ee(ue) === "object" || typeof ue == "function")) return ue;
        if (ue !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
        return Yt(ge);
      }
      function Yt(ge) {
        if (ge === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return ge;
      }
      function Yn(ge) {
        return Yn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ue) {
          return ue.__proto__ || Object.getPrototypeOf(ue);
        }, Yn(ge);
      }
      function Fn(ge, ue, We) {
        return (ue = _n(ue)) in ge ? Object.defineProperty(ge, ue, { value: We, enumerable: !0, configurable: !0, writable: !0 }) : ge[ue] = We, ge;
      }
      function _n(ge) {
        var ue = function(We, et) {
          if (Ee(We) !== "object" || We === null) return We;
          var Mt = We[Symbol.toPrimitive];
          if (Mt !== void 0) {
            var bn = Mt.call(We, et);
            if (Ee(bn) !== "object") return bn;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(We);
        }(ge, "string");
        return Ee(ue) === "symbol" ? ue : String(ue);
      }
      var Xn = ["fullscreenchange", "MSFullscreenChange", "mozfullscreenchange", "webkitfullscreenchange"], or = (0, Ie.arrayOf)((0, Ie.shape)({ srcSet: Ie.string, media: Ie.string }));
      function Ei(ge) {
        var ue = parseInt(ge.keyCode || ge.which || 0, 10);
        return ue === 66 || ue === 62;
      }
      var pr = function(ge) {
        (function(ve, Be) {
          if (typeof Be != "function" && Be !== null) throw new TypeError("Super expression must either be null or a function");
          ve.prototype = Object.create(Be && Be.prototype, { constructor: { value: ve, writable: !0, configurable: !0 } }), Object.defineProperty(ve, "prototype", { writable: !1 }), Be && Kt(ve, Be);
        })(Ai, ge);
        var ue, We, et, Mt, bn = (et = Ai, Mt = function() {
          if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
          if (typeof Proxy == "function") return !0;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), !0;
          } catch {
            return !1;
          }
        }(), function() {
          var ve, Be = Yn(et);
          if (Mt) {
            var mt = Yn(this).constructor;
            ve = Reflect.construct(Be, arguments, mt);
          } else ve = Be.apply(this, arguments);
          return vn(this, ve);
        });
        function Ai(ve) {
          var Be;
          return function(mt, $t) {
            if (!(mt instanceof $t)) throw new TypeError("Cannot call a class as a function");
          }(this, Ai), Fn(Yt(Be = bn.call(this, ve)), "onBulletClick", function(mt, $t) {
            var In = Be.props, un = In.onBulletClick, Bi = In.items, Si = Be.state.currentIndex;
            mt.target.blur(), Si !== $t && (Bi.length === 2 ? Be.slideToIndexWithStyleReset($t, mt) : Be.slideToIndex($t, mt)), un && un(mt, $t);
          }), Be.state = { currentIndex: ve.startIndex, thumbsTranslate: 0, thumbsSwipedTranslate: 0, currentSlideOffset: 0, galleryWidth: 0, thumbnailsWrapperWidth: 0, thumbnailsWrapperHeight: 0, thumbsStyle: { transition: "all ".concat(ve.slideDuration, "ms ease-out") }, isFullscreen: !1, isSwipingThumbnail: !1, isPlaying: !1 }, Be.loadedImages = {}, Be.imageGallery = h().createRef(), Be.thumbnailsWrapper = h().createRef(), Be.thumbnails = h().createRef(), Be.imageGallerySlideWrapper = h().createRef(), Be.handleImageLoaded = Be.handleImageLoaded.bind(Yt(Be)), Be.handleKeyDown = Be.handleKeyDown.bind(Yt(Be)), Be.handleMouseDown = Be.handleMouseDown.bind(Yt(Be)), Be.handleResize = Be.handleResize.bind(Yt(Be)), Be.handleTouchMove = Be.handleTouchMove.bind(Yt(Be)), Be.handleOnSwiped = Be.handleOnSwiped.bind(Yt(Be)), Be.handleScreenChange = Be.handleScreenChange.bind(Yt(Be)), Be.handleSwiping = Be.handleSwiping.bind(Yt(Be)), Be.handleThumbnailSwiping = Be.handleThumbnailSwiping.bind(Yt(Be)), Be.handleOnThumbnailSwiped = Be.handleOnThumbnailSwiped.bind(Yt(Be)), Be.onThumbnailMouseLeave = Be.onThumbnailMouseLeave.bind(Yt(Be)), Be.handleImageError = Be.handleImageError.bind(Yt(Be)), Be.pauseOrPlay = Be.pauseOrPlay.bind(Yt(Be)), Be.renderThumbInner = Be.renderThumbInner.bind(Yt(Be)), Be.renderItem = Be.renderItem.bind(Yt(Be)), Be.slideLeft = Be.slideLeft.bind(Yt(Be)), Be.slideRight = Be.slideRight.bind(Yt(Be)), Be.toggleFullScreen = Be.toggleFullScreen.bind(Yt(Be)), Be.togglePlay = Be.togglePlay.bind(Yt(Be)), Be.unthrottledSlideToIndex = Be.slideToIndex, Be.slideToIndex = Ce(Be.unthrottledSlideToIndex, ve.slideDuration, { trailing: !1 }), ve.lazyLoad && (Be.lazyLoaded = []), Be;
        }
        return ue = Ai, We = [{ key: "componentDidMount", value: function() {
          var ve = this.props, Be = ve.autoPlay, mt = ve.useWindowKeyDown;
          Be && this.play(), mt ? window.addEventListener("keydown", this.handleKeyDown) : this.imageGallery.current.addEventListener("keydown", this.handleKeyDown), window.addEventListener("mousedown", this.handleMouseDown), window.addEventListener("touchmove", this.handleTouchMove, { passive: !1 }), this.initSlideWrapperResizeObserver(this.imageGallerySlideWrapper), this.initThumbnailWrapperResizeObserver(this.thumbnailsWrapper), this.addScreenChangeEvent();
        } }, { key: "componentDidUpdate", value: function(ve, Be) {
          var mt = this.props, $t = mt.items, In = mt.lazyLoad, un = mt.slideDuration, Bi = mt.slideInterval, Si = mt.startIndex, Ji = mt.thumbnailPosition, En = mt.showThumbnails, cn = mt.useWindowKeyDown, kn = this.state, ti = kn.currentIndex, Di = kn.isPlaying, qi = ve.items.length !== $t.length, ci = !le()(ve.items, $t), Hr = ve.startIndex !== Si, Za = ve.thumbnailPosition !== Ji, gi = ve.showThumbnails !== En;
          Bi === ve.slideInterval && un === ve.slideDuration || Di && (this.pause(), this.play()), Za && (this.removeResizeObserver(), this.initSlideWrapperResizeObserver(this.imageGallerySlideWrapper), this.initThumbnailWrapperResizeObserver(this.thumbnailsWrapper)), gi && En && this.initThumbnailWrapperResizeObserver(this.thumbnailsWrapper), gi && !En && this.removeThumbnailsResizeObserver(), (qi || gi) && this.handleResize(), Be.currentIndex !== ti && this.slideThumbnailBar(), ve.slideDuration !== un && (this.slideToIndex = Ce(this.unthrottledSlideToIndex, un, { trailing: !1 })), !In || ve.lazyLoad && !ci || (this.lazyLoaded = []), cn !== ve.useWindowKeyDown && (cn ? (this.imageGallery.current.removeEventListener("keydown", this.handleKeyDown), window.addEventListener("keydown", this.handleKeyDown)) : (window.removeEventListener("keydown", this.handleKeyDown), this.imageGallery.current.addEventListener("keydown", this.handleKeyDown))), (Hr || ci) && this.setState({ currentIndex: Si, slideStyle: { transition: "none" } });
        } }, { key: "componentWillUnmount", value: function() {
          var ve = this.props.useWindowKeyDown;
          window.removeEventListener("mousedown", this.handleMouseDown), window.removeEventListener("touchmove", this.handleTouchMove), this.removeScreenChangeEvent(), this.removeResizeObserver(), this.playPauseIntervalId && (window.clearInterval(this.playPauseIntervalId), this.playPauseIntervalId = null), this.transitionTimer && window.clearTimeout(this.transitionTimer), ve ? window.removeEventListener("keydown", this.handleKeyDown) : this.imageGallery.current.removeEventListener("keydown", this.handleKeyDown);
        } }, { key: "onSliding", value: function() {
          var ve = this, Be = this.state, mt = Be.currentIndex, $t = Be.isTransitioning, In = this.props, un = In.onSlide, Bi = In.slideDuration;
          this.transitionTimer = window.setTimeout(function() {
            $t && (ve.setState({ isTransitioning: !$t, isSwipingThumbnail: !1 }), un && un(mt));
          }, Bi + 50);
        } }, { key: "onThumbnailClick", value: function(ve, Be) {
          var mt = this.props, $t = mt.onThumbnailClick, In = mt.items, un = this.state.currentIndex;
          ve.target.parentNode.parentNode.blur(), un !== Be && (In.length === 2 ? this.slideToIndexWithStyleReset(Be, ve) : this.slideToIndex(Be, ve)), $t && $t(ve, Be);
        } }, { key: "onThumbnailMouseOver", value: function(ve, Be) {
          var mt = this;
          this.thumbnailMouseOverTimer && (window.clearTimeout(this.thumbnailMouseOverTimer), this.thumbnailMouseOverTimer = null), this.thumbnailMouseOverTimer = window.setTimeout(function() {
            mt.slideToIndex(Be), mt.pause();
          }, 300);
        } }, { key: "onThumbnailMouseLeave", value: function() {
          if (this.thumbnailMouseOverTimer) {
            var ve = this.props.autoPlay;
            window.clearTimeout(this.thumbnailMouseOverTimer), this.thumbnailMouseOverTimer = null, ve && this.play();
          }
        } }, { key: "setThumbsTranslate", value: function(ve) {
          this.setState({ thumbsTranslate: ve });
        } }, { key: "setModalFullscreen", value: function(ve) {
          var Be = this.props.onScreenChange;
          this.setState({ modalFullscreen: ve }), Be && Be(ve);
        } }, { key: "getThumbsTranslate", value: function(ve) {
          var Be, mt = this.props, $t = mt.disableThumbnailScroll, In = mt.items, un = this.state, Bi = un.thumbnailsWrapperWidth, Si = un.thumbnailsWrapperHeight, Ji = this.thumbnails && this.thumbnails.current;
          if ($t) return 0;
          if (Ji) {
            if (this.isThumbnailVertical()) {
              if (Ji.scrollHeight <= Si) return 0;
              Be = Ji.scrollHeight - Si;
            } else {
              if (Ji.scrollWidth <= Bi || Bi <= 0) return 0;
              Be = Ji.scrollWidth - Bi;
            }
            return ve * (Be / (In.length - 1));
          }
          return 0;
        } }, { key: "getThumbnailPositionClassName", value: function(ve) {
          switch (ve) {
            case "left":
              ve = " ".concat("image-gallery-thumbnails-left");
              break;
            case "right":
              ve = " ".concat("image-gallery-thumbnails-right");
              break;
            case "bottom":
              ve = " ".concat("image-gallery-thumbnails-bottom");
              break;
            case "top":
              ve = " ".concat("image-gallery-thumbnails-top");
          }
          return ve;
        } }, { key: "getAlignmentClassName", value: function(ve) {
          var Be = this.state.currentIndex, mt = this.props, $t = mt.infinite, In = mt.items, un = "", Bi = "image-gallery-left", Si = "image-gallery-right";
          switch (ve) {
            case Be - 1:
              un = " ".concat(Bi);
              break;
            case Be:
              un = " ".concat("image-gallery-center");
              break;
            case Be + 1:
              un = " ".concat(Si);
          }
          return In.length >= 3 && $t && (ve === 0 && Be === In.length - 1 ? un = " ".concat(Si) : ve === In.length - 1 && Be === 0 && (un = " ".concat(Bi))), un;
        } }, { key: "getTranslateXForTwoSlide", value: function(ve) {
          var Be = this.state, mt = Be.currentIndex, $t = Be.currentSlideOffset, In = Be.previousIndex, un = mt !== In, Bi = ve === 0 && In === 0, Si = ve === 1 && In === 1, Ji = ve === 0 && mt === 1, En = ve === 1 && mt === 0, cn = $t === 0, kn = -100 * mt + 100 * ve + $t;
          return $t > 0 ? this.direction = "left" : $t < 0 && (this.direction = "right"), En && $t > 0 && (kn = -100 + $t), Ji && $t < 0 && (kn = 100 + $t), un ? Bi && cn && this.direction === "left" ? kn = 100 : Si && cn && this.direction === "right" && (kn = -100) : (En && cn && this.direction === "left" && (kn = -100), Ji && cn && this.direction === "right" && (kn = 100)), kn;
        } }, { key: "getThumbnailBarHeight", value: function() {
          return this.isThumbnailVertical() ? { height: this.state.gallerySlideWrapperHeight } : {};
        } }, { key: "getSlideStyle", value: function(ve) {
          var Be = this.state, mt = Be.currentIndex, $t = Be.currentSlideOffset, In = Be.slideStyle, un = this.props, Bi = un.infinite, Si = un.items, Ji = un.useTranslate3D, En = un.isRTL, cn = -100 * mt, kn = Si.length - 1, ti = (cn + 100 * ve) * (En ? -1 : 1) + $t;
          Bi && Si.length > 2 && (mt === 0 && ve === kn ? ti = -100 * (En ? -1 : 1) + $t : mt === kn && ve === 0 && (ti = 100 * (En ? -1 : 1) + $t)), Bi && Si.length === 2 && (ti = this.getTranslateXForTwoSlide(ve));
          var Di = "translate(".concat(ti, "%, 0)");
          return Ji && (Di = "translate3d(".concat(ti, "%, 0, 0)")), Oe({ display: this.isSlideVisible(ve) ? "inherit" : "none", WebkitTransform: Di, MozTransform: Di, msTransform: Di, OTransform: Di, transform: Di }, In);
        } }, { key: "getCurrentIndex", value: function() {
          return this.state.currentIndex;
        } }, { key: "getThumbnailStyle", value: function() {
          var ve, Be = this.props, mt = Be.useTranslate3D, $t = Be.isRTL, In = this.state, un = In.thumbsTranslate, Bi = In.thumbsStyle, Si = $t ? -1 * un : un;
          return this.isThumbnailVertical() ? (ve = "translate(0, ".concat(un, "px)"), mt && (ve = "translate3d(0, ".concat(un, "px, 0)"))) : (ve = "translate(".concat(Si, "px, 0)"), mt && (ve = "translate3d(".concat(Si, "px, 0, 0)"))), Oe({ WebkitTransform: ve, MozTransform: ve, msTransform: ve, OTransform: ve, transform: ve }, Bi);
        } }, { key: "getSlideItems", value: function() {
          var ve = this, Be = this.state.currentIndex, mt = this.props, $t = mt.items, In = mt.slideOnThumbnailOver, un = mt.onClick, Bi = mt.lazyLoad, Si = mt.onTouchMove, Ji = mt.onTouchEnd, En = mt.onTouchStart, cn = mt.onMouseOver, kn = mt.onMouseLeave, ti = mt.renderItem, Di = mt.renderThumbInner, qi = mt.showThumbnails, ci = mt.showBullets, Hr = [], Za = [], gi = [];
          return $t.forEach(function(yr, Hn) {
            var Pa = ve.getAlignmentClassName(Hn), zo = yr.originalClass ? " ".concat(yr.originalClass) : "", Ko = yr.thumbnailClass ? " ".concat(yr.thumbnailClass) : "", Xr = yr.renderItem || ti || ve.renderItem, ia = yr.renderThumbInner || Di || ve.renderThumbInner, kr = !Bi || Pa || ve.lazyLoaded[Hn];
            kr && Bi && !ve.lazyLoaded[Hn] && (ve.lazyLoaded[Hn] = !0);
            var ua = ve.getSlideStyle(Hn), Lo = h().createElement("div", { "aria-label": "Go to Slide ".concat(Hn + 1), key: "slide-".concat(Hn), tabIndex: "-1", className: "image-gallery-slide ".concat(Pa, " ").concat(zo), style: ua, onClick: un, onKeyUp: ve.handleSlideKeyUp, onTouchMove: Si, onTouchEnd: Ji, onTouchStart: En, onMouseOver: cn, onFocus: cn, onMouseLeave: kn, role: "button" }, kr ? Xr(yr) : h().createElement("div", { style: { height: "100%" } }));
            if (Hr.push(Lo), qi && yr.thumbnail) {
              var ko = I("image-gallery-thumbnail", Ko, { active: Be === Hn });
              Za.push(h().createElement("button", { key: "thumbnail-".concat(Hn), type: "button", tabIndex: "0", "aria-pressed": Be === Hn ? "true" : "false", "aria-label": "Go to Slide ".concat(Hn + 1), className: ko, onMouseLeave: In ? ve.onThumbnailMouseLeave : null, onMouseOver: function(Ja) {
                return ve.handleThumbnailMouseOver(Ja, Hn);
              }, onFocus: function(Ja) {
                return ve.handleThumbnailMouseOver(Ja, Hn);
              }, onKeyUp: function(Ja) {
                return ve.handleThumbnailKeyUp(Ja, Hn);
              }, onClick: function(Ja) {
                return ve.onThumbnailClick(Ja, Hn);
              } }, ia(yr)));
            }
            if (ci) {
              var cu = I("image-gallery-bullet", yr.bulletClass, { active: Be === Hn });
              gi.push(h().createElement("button", { type: "button", key: "bullet-".concat(Hn), className: cu, onClick: function(Ja) {
                return ve.onBulletClick(Ja, Hn);
              }, "aria-pressed": Be === Hn ? "true" : "false", "aria-label": "Go to Slide ".concat(Hn + 1) }));
            }
          }), { slides: Hr, thumbnails: Za, bullets: gi };
        } }, { key: "ignoreIsTransitioning", value: function() {
          var ve = this.props.items, Be = this.state, mt = Be.previousIndex, $t = Be.currentIndex, In = ve.length - 1;
          return Math.abs(mt - $t) > 1 && !(mt === 0 && $t === In) && !(mt === In && $t === 0);
        } }, { key: "isFirstOrLastSlide", value: function(ve) {
          return ve === this.props.items.length - 1 || ve === 0;
        } }, { key: "slideIsTransitioning", value: function(ve) {
          var Be = this.state, mt = Be.isTransitioning, $t = Be.previousIndex, In = Be.currentIndex;
          return mt && !(ve === $t || ve === In);
        } }, { key: "isSlideVisible", value: function(ve) {
          return !this.slideIsTransitioning(ve) || this.ignoreIsTransitioning() && !this.isFirstOrLastSlide(ve);
        } }, { key: "slideThumbnailBar", value: function() {
          var ve = this.state, Be = ve.currentIndex, mt = ve.isSwipingThumbnail, $t = -this.getThumbsTranslate(Be);
          mt || (Be === 0 ? this.setState({ thumbsTranslate: 0, thumbsSwipedTranslate: 0 }) : this.setState({ thumbsTranslate: $t, thumbsSwipedTranslate: $t }));
        } }, { key: "canSlide", value: function() {
          return this.props.items.length >= 2;
        } }, { key: "canSlideLeft", value: function() {
          return this.props.infinite || this.canSlidePrevious();
        } }, { key: "canSlideRight", value: function() {
          return this.props.infinite || this.canSlideNext();
        } }, { key: "canSlidePrevious", value: function() {
          return this.state.currentIndex > 0;
        } }, { key: "canSlideNext", value: function() {
          return this.state.currentIndex < this.props.items.length - 1;
        } }, { key: "handleSwiping", value: function(ve) {
          var Be = ve.event, mt = ve.absX, $t = ve.dir, In = this.props, un = In.disableSwipe, Bi = In.stopPropagation, Si = this.state, Ji = Si.galleryWidth, En = Si.isTransitioning, cn = Si.swipingUpDown, kn = Si.swipingLeftRight;
          if ($t !== zt && $t !== Sn && !cn || kn) {
            if ($t !== Ft && $t !== pt || kn || this.setState({ swipingLeftRight: !0 }), !un) {
              var ti = this.props.swipingTransitionDuration;
              if (Bi && Be.preventDefault(), En) this.setState({ currentSlideOffset: 0 });
              else {
                var Di = $t === pt ? 1 : -1, qi = mt / Ji * 100;
                Math.abs(qi) >= 100 && (qi = 100);
                var ci = { transition: "transform ".concat(ti, "ms ease-out") };
                this.setState({ currentSlideOffset: Di * qi, slideStyle: ci });
              }
            }
          } else cn || this.setState({ swipingUpDown: !0 });
        } }, { key: "handleThumbnailSwiping", value: function(ve) {
          var Be = ve.event, mt = ve.absX, $t = ve.absY, In = ve.dir, un = this.props, Bi = un.stopPropagation, Si = un.swipingThumbnailTransitionDuration, Ji = this.state, En = Ji.thumbsSwipedTranslate, cn = Ji.thumbnailsWrapperHeight, kn = Ji.thumbnailsWrapperWidth, ti = Ji.swipingUpDown, Di = Ji.swipingLeftRight;
          if (this.isThumbnailVertical()) {
            if ((In === Ft || In === pt || Di) && !ti) return void (Di || this.setState({ swipingLeftRight: !0 }));
            In !== zt && In !== Sn || ti || this.setState({ swipingUpDown: !0 });
          } else {
            if ((In === zt || In === Sn || ti) && !Di) return void (ti || this.setState({ swipingUpDown: !0 }));
            In !== Ft && In !== pt || Di || this.setState({ swipingLeftRight: !0 });
          }
          var qi, ci, Hr, Za, gi, yr = this.thumbnails && this.thumbnails.current;
          if (this.isThumbnailVertical() ? (qi = En + (In === Sn ? $t : -$t), ci = yr.scrollHeight - cn + 20, Hr = Math.abs(qi) > ci, Za = qi > 20, gi = yr.scrollHeight <= cn) : (qi = En + (In === pt ? mt : -mt), ci = yr.scrollWidth - kn + 20, Hr = Math.abs(qi) > ci, Za = qi > 20, gi = yr.scrollWidth <= kn), !gi && (In !== Ft && In !== zt || !Hr) && (In !== pt && In !== Sn || !Za)) {
            Bi && Be.stopPropagation();
            var Hn = { transition: "transform ".concat(Si, "ms ease-out") };
            this.setState({ thumbsTranslate: qi, thumbsStyle: Hn });
          }
        } }, { key: "handleOnThumbnailSwiped", value: function() {
          var ve = this.state.thumbsTranslate, Be = this.props.slideDuration;
          this.resetSwipingDirection(), this.setState({ isSwipingThumbnail: !0, thumbsSwipedTranslate: ve, thumbsStyle: { transition: "all ".concat(Be, "ms ease-out") } });
        } }, { key: "sufficientSwipe", value: function() {
          var ve = this.state.currentSlideOffset, Be = this.props.swipeThreshold;
          return Math.abs(ve) > Be;
        } }, { key: "resetSwipingDirection", value: function() {
          var ve = this.state, Be = ve.swipingUpDown, mt = ve.swipingLeftRight;
          Be && this.setState({ swipingUpDown: !1 }), mt && this.setState({ swipingLeftRight: !1 });
        } }, { key: "handleOnSwiped", value: function(ve) {
          var Be = ve.event, mt = ve.dir, $t = ve.velocity, In = this.props, un = In.disableSwipe, Bi = In.stopPropagation, Si = In.flickThreshold;
          if (!un) {
            var Ji = this.props.isRTL;
            Bi && Be.stopPropagation(), this.resetSwipingDirection();
            var En = (mt === Ft ? 1 : -1) * (Ji ? -1 : 1), cn = $t > Si && !(mt === zt || mt === Sn);
            this.handleOnSwipedTo(En, cn);
          }
        } }, { key: "handleOnSwipedTo", value: function(ve, Be) {
          var mt = this.state, $t = mt.currentIndex, In = mt.isTransitioning, un = $t;
          !this.sufficientSwipe() && !Be || In || (un += ve), (ve === -1 && !this.canSlideLeft() || ve === 1 && !this.canSlideRight()) && (un = $t), this.unthrottledSlideToIndex(un);
        } }, { key: "handleTouchMove", value: function(ve) {
          this.state.swipingLeftRight && ve.preventDefault();
        } }, { key: "handleMouseDown", value: function() {
          this.imageGallery.current.classList.add("image-gallery-using-mouse");
        } }, { key: "handleKeyDown", value: function(ve) {
          var Be = this.props, mt = Be.disableKeyDown, $t = Be.useBrowserFullscreen, In = this.state.isFullscreen;
          if (this.imageGallery.current.classList.remove("image-gallery-using-mouse"), !mt) switch (parseInt(ve.keyCode || ve.which || 0, 10)) {
            case 37:
              this.canSlideLeft() && !this.playPauseIntervalId && this.slideLeft(ve);
              break;
            case 39:
              this.canSlideRight() && !this.playPauseIntervalId && this.slideRight(ve);
              break;
            case 27:
              In && !$t && this.exitFullScreen();
          }
        } }, { key: "handleImageError", value: function(ve) {
          var Be = this.props.onErrorImageURL;
          Be && ve.target.src.indexOf(Be) === -1 && (ve.target.src = Be);
        } }, { key: "removeThumbnailsResizeObserver", value: function() {
          this.resizeThumbnailWrapperObserver && this.thumbnailsWrapper && this.thumbnailsWrapper.current && (this.resizeThumbnailWrapperObserver.unobserve(this.thumbnailsWrapper.current), this.resizeThumbnailWrapperObserver = null);
        } }, { key: "removeResizeObserver", value: function() {
          this.resizeSlideWrapperObserver && this.imageGallerySlideWrapper && this.imageGallerySlideWrapper.current && (this.resizeSlideWrapperObserver.unobserve(this.imageGallerySlideWrapper.current), this.resizeSlideWrapperObserver = null), this.removeThumbnailsResizeObserver();
        } }, { key: "handleResize", value: function() {
          var ve = this.state.currentIndex;
          this.imageGallery && (this.imageGallery && this.imageGallery.current && this.setState({ galleryWidth: this.imageGallery.current.offsetWidth }), this.imageGallerySlideWrapper && this.imageGallerySlideWrapper.current && this.setState({ gallerySlideWrapperHeight: this.imageGallerySlideWrapper.current.offsetHeight }), this.setThumbsTranslate(-this.getThumbsTranslate(ve)));
        } }, { key: "initSlideWrapperResizeObserver", value: function(ve) {
          var Be = this;
          ve && !ve.current || (this.resizeSlideWrapperObserver = new ct(ee(function(mt) {
            mt && mt.forEach(function($t) {
              Be.setState({ thumbnailsWrapperWidth: $t.contentRect.width }, Be.handleResize);
            });
          }, 50)), this.resizeSlideWrapperObserver.observe(ve.current));
        } }, { key: "initThumbnailWrapperResizeObserver", value: function(ve) {
          var Be = this;
          ve && !ve.current || (this.resizeThumbnailWrapperObserver = new ct(ee(function(mt) {
            mt && mt.forEach(function($t) {
              Be.setState({ thumbnailsWrapperHeight: $t.contentRect.height }, Be.handleResize);
            });
          }, 50)), this.resizeThumbnailWrapperObserver.observe(ve.current));
        } }, { key: "toggleFullScreen", value: function() {
          this.state.isFullscreen ? this.exitFullScreen() : this.fullScreen();
        } }, { key: "togglePlay", value: function() {
          this.playPauseIntervalId ? this.pause() : this.play();
        } }, { key: "handleScreenChange", value: function() {
          var ve = this.props, Be = ve.onScreenChange, mt = ve.useBrowserFullscreen, $t = document.fullscreenElement || document.msFullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement, In = this.imageGallery.current === $t;
          Be && Be(In), mt && this.setState({ isFullscreen: In });
        } }, { key: "slideToIndex", value: function(ve, Be) {
          var mt = this.state, $t = mt.currentIndex, In = mt.isTransitioning, un = this.props, Bi = un.items, Si = un.slideDuration, Ji = un.onBeforeSlide;
          if (!In) {
            Be && this.playPauseIntervalId && (this.pause(!1), this.play(!1));
            var En = Bi.length - 1, cn = ve;
            ve < 0 ? cn = En : ve > En && (cn = 0), Ji && cn !== $t && Ji(cn), this.setState({ previousIndex: $t, currentIndex: cn, isTransitioning: cn !== $t, currentSlideOffset: 0, slideStyle: { transition: "all ".concat(Si, "ms ease-out") } }, this.onSliding);
          }
        } }, { key: "slideLeft", value: function(ve) {
          var Be = this.props.isRTL;
          this.slideTo(ve, Be ? "right" : "left");
        } }, { key: "slideRight", value: function(ve) {
          var Be = this.props.isRTL;
          this.slideTo(ve, Be ? "left" : "right");
        } }, { key: "slideTo", value: function(ve, Be) {
          var mt = this.state, $t = mt.currentIndex, In = mt.isTransitioning, un = this.props.items, Bi = $t + (Be === "left" ? -1 : 1);
          In || (un.length === 2 ? this.slideToIndexWithStyleReset(Bi, ve) : this.slideToIndex(Bi, ve));
        } }, { key: "slideToIndexWithStyleReset", value: function(ve, Be) {
          var mt = this, $t = this.state, In = $t.currentIndex, un = $t.currentSlideOffset;
          this.setState({ currentSlideOffset: un + (In > ve ? 1e-3 : -1e-3), slideStyle: { transition: "none" } }, function() {
            window.setTimeout(function() {
              return mt.slideToIndex(ve, Be);
            }, 25);
          });
        } }, { key: "handleThumbnailMouseOver", value: function(ve, Be) {
          this.props.slideOnThumbnailOver && this.onThumbnailMouseOver(ve, Be);
        } }, { key: "handleThumbnailKeyUp", value: function(ve, Be) {
          Ei(ve) && this.onThumbnailClick(ve, Be);
        } }, { key: "handleSlideKeyUp", value: function(ve) {
          Ei(ve) && (0, this.props.onClick)(ve);
        } }, { key: "isThumbnailVertical", value: function() {
          var ve = this.props.thumbnailPosition;
          return ve === "left" || ve === "right";
        } }, { key: "addScreenChangeEvent", value: function() {
          var ve = this;
          Xn.forEach(function(Be) {
            document.addEventListener(Be, ve.handleScreenChange);
          });
        } }, { key: "removeScreenChangeEvent", value: function() {
          var ve = this;
          Xn.forEach(function(Be) {
            document.removeEventListener(Be, ve.handleScreenChange);
          });
        } }, { key: "fullScreen", value: function() {
          var ve = this.props.useBrowserFullscreen, Be = this.imageGallery.current;
          ve ? Be.requestFullscreen ? Be.requestFullscreen() : Be.msRequestFullscreen ? Be.msRequestFullscreen() : Be.mozRequestFullScreen ? Be.mozRequestFullScreen() : Be.webkitRequestFullscreen ? Be.webkitRequestFullscreen() : this.setModalFullscreen(!0) : this.setModalFullscreen(!0), this.setState({ isFullscreen: !0 });
        } }, { key: "exitFullScreen", value: function() {
          var ve = this.state.isFullscreen, Be = this.props.useBrowserFullscreen;
          ve && (Be ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen ? document.msExitFullscreen() : this.setModalFullscreen(!1) : this.setModalFullscreen(!1), this.setState({ isFullscreen: !1 }));
        } }, { key: "pauseOrPlay", value: function() {
          var ve = this.props.infinite, Be = this.state.currentIndex;
          ve || this.canSlideRight() ? this.slideToIndex(Be + 1) : this.pause();
        } }, { key: "play", value: function() {
          var ve = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], Be = this.props, mt = Be.onPlay, $t = Be.slideInterval, In = Be.slideDuration, un = this.state.currentIndex;
          this.playPauseIntervalId || (this.setState({ isPlaying: !0 }), this.playPauseIntervalId = window.setInterval(this.pauseOrPlay, Math.max($t, In)), mt && ve && mt(un));
        } }, { key: "pause", value: function() {
          var ve = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], Be = this.props.onPause, mt = this.state.currentIndex;
          this.playPauseIntervalId && (window.clearInterval(this.playPauseIntervalId), this.playPauseIntervalId = null, this.setState({ isPlaying: !1 }), Be && ve && Be(mt));
        } }, { key: "isImageLoaded", value: function(ve) {
          return !!this.loadedImages[ve.original] || (this.loadedImages[ve.original] = !0, !1);
        } }, { key: "handleImageLoaded", value: function(ve, Be) {
          var mt = this.props.onImageLoad;
          !this.loadedImages[Be] && mt && (this.loadedImages[Be] = !0, mt(ve));
        } }, { key: "renderItem", value: function(ve) {
          var Be = this.state.isFullscreen, mt = this.props.onImageError || this.handleImageError;
          return h().createElement(_e, { description: ve.description, fullscreen: ve.fullscreen, handleImageLoaded: this.handleImageLoaded, isFullscreen: Be, onImageError: mt, original: ve.original, originalAlt: ve.originalAlt, originalHeight: ve.originalHeight, originalWidth: ve.originalWidth, originalTitle: ve.originalTitle, sizes: ve.sizes, loading: ve.loading, srcSet: ve.srcSet });
        } }, { key: "renderThumbInner", value: function(ve) {
          var Be = this.props.onThumbnailError || this.handleImageError;
          return h().createElement("span", { className: "image-gallery-thumbnail-inner" }, h().createElement("img", { className: "image-gallery-thumbnail-image", src: ve.thumbnail, height: ve.thumbnailHeight, width: ve.thumbnailWidth, alt: ve.thumbnailAlt, title: ve.thumbnailTitle, loading: ve.thumbnailLoading, onError: Be }), ve.thumbnailLabel && h().createElement("div", { className: "image-gallery-thumbnail-label" }, ve.thumbnailLabel));
        } }, { key: "render", value: function() {
          var ve = this.state, Be = ve.currentIndex, mt = ve.isFullscreen, $t = ve.modalFullscreen, In = ve.isPlaying, un = this.props, Bi = un.additionalClass, Si = un.disableThumbnailSwipe, Ji = un.indexSeparator, En = un.isRTL, cn = un.items, kn = un.thumbnailPosition, ti = un.renderFullscreenButton, Di = un.renderCustomControls, qi = un.renderLeftNav, ci = un.renderRightNav, Hr = un.showBullets, Za = un.showFullscreenButton, gi = un.showIndex, yr = un.showThumbnails, Hn = un.showNav, Pa = un.showPlayButton, zo = un.renderPlayPauseButton, Ko = this.getThumbnailStyle(), Xr = this.getSlideItems(), ia = Xr.slides, kr = Xr.thumbnails, ua = Xr.bullets, Lo = I("image-gallery-slide-wrapper", this.getThumbnailPositionClassName(kn), { "image-gallery-rtl": En }), ko = h().createElement("div", { ref: this.imageGallerySlideWrapper, className: Lo }, Di && Di(), this.canSlide() ? h().createElement(h().Fragment, null, Hn && h().createElement(h().Fragment, null, qi(this.slideLeft, !this.canSlideLeft()), ci(this.slideRight, !this.canSlideRight())), h().createElement(we, { className: "image-gallery-swipe", delta: 0, onSwiping: this.handleSwiping, onSwiped: this.handleOnSwiped }, h().createElement("div", { className: "image-gallery-slides" }, ia))) : h().createElement("div", { className: "image-gallery-slides" }, ia), Pa && zo(this.togglePlay, In), Hr && h().createElement("div", { className: "image-gallery-bullets" }, h().createElement("div", { className: "image-gallery-bullets-container", role: "navigation", "aria-label": "Bullet Navigation" }, ua)), Za && ti(this.toggleFullScreen, mt), gi && h().createElement("div", { className: "image-gallery-index" }, h().createElement("span", { className: "image-gallery-index-current" }, Be + 1), h().createElement("span", { className: "image-gallery-index-separator" }, Ji), h().createElement("span", { className: "image-gallery-index-total" }, cn.length))), cu = I("image-gallery", Bi, { "fullscreen-modal": $t }), Ja = I("image-gallery-content", this.getThumbnailPositionClassName(kn), { fullscreen: mt }), is = I("image-gallery-thumbnails-wrapper", this.getThumbnailPositionClassName(kn), { "thumbnails-wrapper-rtl": !this.isThumbnailVertical() && En }, { "thumbnails-swipe-horizontal": !this.isThumbnailVertical() && !Si }, { "thumbnails-swipe-vertical": this.isThumbnailVertical() && !Si });
          return h().createElement("div", { ref: this.imageGallery, className: cu, "aria-live": "polite" }, h().createElement("div", { className: Ja }, (kn === "bottom" || kn === "right") && ko, yr && kr.length > 0 ? h().createElement(we, { className: is, delta: 0, onSwiping: !Si && this.handleThumbnailSwiping, onSwiped: !Si && this.handleOnThumbnailSwiped }, h().createElement("div", { className: "image-gallery-thumbnails", ref: this.thumbnailsWrapper, style: this.getThumbnailBarHeight() }, h().createElement("nav", { ref: this.thumbnails, className: "image-gallery-thumbnails-container", style: Ko, "aria-label": "Thumbnail Navigation" }, kr))) : null, (kn === "top" || kn === "left") && ko));
        } }], We && Nt(ue.prototype, We), Object.defineProperty(ue, "prototype", { writable: !1 }), Ai;
      }(h().Component);
      pr.propTypes = { flickThreshold: Ie.number, items: (0, Ie.arrayOf)((0, Ie.shape)({ bulletClass: Ie.string, bulletOnClick: Ie.func, description: Ie.string, original: Ie.string, originalHeight: Ie.number, originalWidth: Ie.number, loading: Ie.string, thumbnailHeight: Ie.number, thumbnailWidth: Ie.number, thumbnailLoading: Ie.string, fullscreen: Ie.string, originalAlt: Ie.string, originalTitle: Ie.string, thumbnail: Ie.string, thumbnailAlt: Ie.string, thumbnailLabel: Ie.string, thumbnailTitle: Ie.string, originalClass: Ie.string, thumbnailClass: Ie.string, renderItem: Ie.func, renderThumbInner: Ie.func, imageSet: or, srcSet: Ie.string, sizes: Ie.string })).isRequired, showNav: Ie.bool, autoPlay: Ie.bool, lazyLoad: Ie.bool, infinite: Ie.bool, showIndex: Ie.bool, showBullets: Ie.bool, showThumbnails: Ie.bool, showPlayButton: Ie.bool, showFullscreenButton: Ie.bool, disableThumbnailScroll: Ie.bool, disableKeyDown: Ie.bool, disableSwipe: Ie.bool, disableThumbnailSwipe: Ie.bool, useBrowserFullscreen: Ie.bool, onErrorImageURL: Ie.string, indexSeparator: Ie.string, thumbnailPosition: (0, Ie.oneOf)(["top", "bottom", "left", "right"]), startIndex: Ie.number, slideDuration: Ie.number, slideInterval: Ie.number, slideOnThumbnailOver: Ie.bool, swipeThreshold: Ie.number, swipingTransitionDuration: Ie.number, swipingThumbnailTransitionDuration: Ie.number, onSlide: Ie.func, onBeforeSlide: Ie.func, onScreenChange: Ie.func, onPause: Ie.func, onPlay: Ie.func, onClick: Ie.func, onImageLoad: Ie.func, onImageError: Ie.func, onTouchMove: Ie.func, onTouchEnd: Ie.func, onTouchStart: Ie.func, onMouseOver: Ie.func, onMouseLeave: Ie.func, onBulletClick: Ie.func, onThumbnailError: Ie.func, onThumbnailClick: Ie.func, renderCustomControls: Ie.func, renderLeftNav: Ie.func, renderRightNav: Ie.func, renderPlayPauseButton: Ie.func, renderFullscreenButton: Ie.func, renderItem: Ie.func, renderThumbInner: Ie.func, stopPropagation: Ie.bool, additionalClass: Ie.string, useTranslate3D: Ie.bool, isRTL: Ie.bool, useWindowKeyDown: Ie.bool }, pr.defaultProps = { onErrorImageURL: "", additionalClass: "", showNav: !0, autoPlay: !1, lazyLoad: !1, infinite: !0, showIndex: !1, showBullets: !1, showThumbnails: !0, showPlayButton: !0, showFullscreenButton: !0, disableThumbnailScroll: !1, disableKeyDown: !1, disableSwipe: !1, disableThumbnailSwipe: !1, useTranslate3D: !0, isRTL: !1, useBrowserFullscreen: !0, flickThreshold: 0.4, stopPropagation: !1, indexSeparator: " / ", thumbnailPosition: "bottom", startIndex: 0, slideDuration: 450, swipingTransitionDuration: 0, swipingThumbnailTransitionDuration: 0, onSlide: null, onBeforeSlide: null, onScreenChange: null, onPause: null, onPlay: null, onClick: null, onImageLoad: null, onImageError: null, onTouchMove: null, onTouchEnd: null, onTouchStart: null, onMouseOver: null, onMouseLeave: null, onBulletClick: null, onThumbnailError: null, onThumbnailClick: null, renderCustomControls: null, renderThumbInner: null, renderItem: null, slideInterval: 3e3, slideOnThumbnailOver: !1, swipeThreshold: 30, renderLeftNav: function(ge, ue) {
        return h().createElement(na, { onClick: ge, disabled: ue });
      }, renderRightNav: function(ge, ue) {
        return h().createElement(Oa, { onClick: ge, disabled: ue });
      }, renderPlayPauseButton: function(ge, ue) {
        return h().createElement(qe, { onClick: ge, isPlaying: ue });
      }, renderFullscreenButton: function(ge, ue) {
        return h().createElement(Sa, { onClick: ge, isFullscreen: ue });
      }, useWindowKeyDown: !0 };
      const Ln = pr;
    })(), l;
  })());
})(K9);
var Nre = K9.exports;
const Mre = /* @__PURE__ */ Tw(Nre), Hre = (a, e = "div", t = "") => {
  const n = document.getElementById("root"), i = document.createElement(e);
  return i.id = a, i.className = t, document.body.insertBefore(i, n), i;
}, Xre = (a, e = "div", t = "") => {
  const n = document.getElementById(a);
  return n || Hre(a, e, t);
}, Yre = ({ visible: a, items: e, setItems: t, onClose: n }) => {
  const [i, o] = xe.useState(a), l = Xre("modal");
  if (xe.useEffect(() => {
    a ? o(!0) : setTimeout(() => {
      o(!1), t(null);
    }, 200);
  }, [a]), !!i)
    return gX.createPortal(
      /* @__PURE__ */ ze.jsxs("div", { className: `imageGalleryModal ${a ? "animate-fadein" : "animate-fadeout"}`, children: [
        /* @__PURE__ */ ze.jsx("div", { className: "imageGalleryModal-bg", onClick: n }),
        /* @__PURE__ */ ze.jsxs("div", { className: "gallery", children: [
          /* @__PURE__ */ ze.jsx("button", { className: "close-btn", onClick: n, children: "close" }),
          /* @__PURE__ */ ze.jsx(
            Mre,
            {
              items: e ?? [],
              showFullscreenButton: !1,
              showPlayButton: !1,
              slideDuration: 200,
              renderLeftNav: (u) => /* @__PURE__ */ ze.jsx("button", { className: "gallery-arrow left-2", onClick: u, children: /* @__PURE__ */ ze.jsx(Wre, { size: "2.5rem" }) }),
              renderRightNav: (u) => /* @__PURE__ */ ze.jsx("button", { className: "gallery-arrow right-2", onClick: u, children: /* @__PURE__ */ ze.jsx(Vre, { size: "2.5rem" }) })
            }
          )
        ] })
      ] }),
      l
    );
}, Fre = (a) => a != null && typeof a == "object" && "en" in a && typeof a.en == "string" && "zh" in a && typeof a.zh == "string", L9 = (a) => {
  const e = document.getElementById("outlet"), t = document.getElementById(a);
  if (e && t) {
    const n = window.innerWidth <= 575 ? 57 : window.innerWidth <= 767 ? 66 : 72, o = t.getBoundingClientRect().top + e.scrollTop - n;
    e.scrollTo({ behavior: "smooth", top: o });
  }
}, Ere = ({
  project: { id: a, title: e, description: t, picPath: n, tags: i, link: o, date: l, images: u },
  hoverState: I,
  setGalleryItems: f
}) => {
  const h = Pg(), v = Sb(), { i18n: b, t: S } = Lu(), R = hp(b.language), W = u && u.length, x = () => {
    v({ ...h, hash: `#${a}` }), L9(a.toString());
  }, M = (T) => /* @__PURE__ */ ze.jsx(
    "a",
    {
      target: "_blank",
      rel: "noopener noreferrer",
      href: T.site,
      className: "sm:self-end text-sm underline",
      onClick: (E) => E.stopPropagation(),
      children: S(`proj_${T.type}`)
    }
  );
  return /* @__PURE__ */ ze.jsxs(
    M9,
    {
      id: a,
      turnGray: !0,
      hoverState: I,
      title: /* @__PURE__ */ ze.jsxs(
        "div",
        {
          className: `relative pt-[56.25%] transition-theme overflow-hidden ${W ? "cursor-pointer" : "cursor-default"}`,
          onClick: () => {
            W && f(u);
          },
          children: [
            W && /* @__PURE__ */ ze.jsx(
              Fie,
              {
                className: "transition-theme mt-2 ml-auto text-defaccent dark:text-darkaccent light:text-lightaccent sm:absolute sm:bottom-2 sm:right-2 z-[2]",
                size: "18px"
              }
            ),
            /* @__PURE__ */ ze.jsx(
              "img",
              {
                draggable: !1,
                className: "absolute w-full top-0 left-0 object-contain max-w-full max-h-full",
                src: n,
                alt: e[R]
              }
            )
          ]
        }
      ),
      children: [
        /* @__PURE__ */ ze.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ ze.jsx(
            "div",
            {
              className: "text-lg md:text-base font-medium flex flex-row items-center sm:mt-3 gap-x-2 cursor-pointer",
              onClick: x,
              children: /* @__PURE__ */ ze.jsxs("p", { children: [
                e[R],
                " ",
                M(o)
              ] })
            }
          ),
          /* @__PURE__ */ ze.jsx("div", { className: "text-sm", children: Fre(t) ? t[R] : t })
        ] }),
        /* @__PURE__ */ ze.jsxs("div", { className: "mt-1 flex flex-row justify-between items-end text-sm font-medium", children: [
          /* @__PURE__ */ ze.jsx(H9, { selectable: !0, tags: i }),
          /* @__PURE__ */ ze.jsxs("div", { className: "text-nowrap text-xs", children: [
            l.month,
            " ",
            l.year
          ] })
        ] })
      ]
    }
  );
};
var zd = /* @__PURE__ */ ((a) => (a.PROJECT = "project", a.SIDE_PROJECT = "side_project", a.OTHERS = "others", a))(zd || {});
const Tre = "keyboard", _re = {
  id: Tre,
  title: {
    en: "Keyboard",
    zh: "keyboard"
  },
  type: zd.OTHERS,
  tags: [sr.webAudio],
  picPath: "/assets/keyboard.webp",
  description: {
    en: "A keyboard implemented using WebAudio for the first time. After downloading, click index.html to start the project.",
    zh: "初次使用 WebAudio 實做的 Keyboard，下載後點擊 index.html 即可開啟專案。"
  },
  link: {
    type: "download",
    site: "https://drive.google.com/file/d/1NgQFqJ2N6pBeSbCv-HcWH-vlAfUioUWm/view?usp=sharing"
  },
  date: {
    year: 2023,
    month: Yd.JAN
  }
}, zre = "kitchen-timer", Kre = {
  id: zre,
  title: {
    en: "Kitchen Timer",
    zh: "Kitchen Timer"
  },
  type: zd.SIDE_PROJECT,
  tags: [sr.nativeJS],
  picPath: "/assets/kitchen-timer/preview2.webp",
  images: [
    {
      original: "/assets/kitchen-timer/preview1.webp",
      thumbnail: "/assets/kitchen-timer/preview1.webp"
    },
    {
      original: "/assets/kitchen-timer/preview2.webp",
      thumbnail: "/assets/kitchen-timer/preview2.webp"
    },
    {
      original: "/assets/kitchen-timer/preview3.webp",
      thumbnail: "/assets/kitchen-timer/preview3.webp"
    },
    {
      original: "/assets/kitchen-timer/preview4.webp",
      thumbnail: "/assets/kitchen-timer/preview4.webp"
    }
  ],
  description: {
    en: 'This game is inspired by a minigame from "Everybody 1-2-Switch!" by Nintendo. After downloading, click "index.html" to start the game.',
    zh: '這款遊戲是模仿 Nintendo 的 "Everybody 1-2-Switch!" 中的一款小遊戲 "Kitchen Timer"，下載後點擊 index.html 即可開始遊戲。'
  },
  link: {
    type: "download",
    site: "https://drive.google.com/file/d/19sycv9WDLah-2teR5dLgkUL4itxPn4L4/view?usp=sharing"
  },
  date: {
    year: 2024,
    month: Yd.JUN
  }
}, eR = ({ target: a, state: e }) => {
  const t = Pg(), [n, i] = e, o = (l) => {
    l.stopPropagation(), i((u) => !u), L9(a);
  };
  return /* @__PURE__ */ ze.jsx(
    AX,
    {
      replace: !0,
      to: { ...t, hash: `#${a}` },
      onClick: o,
      className: "text-xs underline outline-none",
      children: n ? "Show less..." : "Show more..."
    }
  );
}, k9 = "mog-simulation", Lre = {
  en: "This project is a simulation exercise of a multiplayer online game, where players can create rooms and interact with each other through their characters, as well as perform various actions. The project technologies are as follows: ",
  zh: "本專案是一個多人線上遊戲的模擬練習，玩家可以創建房間並透過角色進行互動與聊天，同時角色還能執行各種動作。專案技術如下："
}, kre = [
  {
    title: { en: "Mesh Network: ", zh: "Mesh 架構：" },
    content: {
      en: "Uses a Mesh Network to establish peer-to-peer (P2P) connections between players.",
      zh: "採用 Mesh Network，讓每個玩家之間建立 點對點(P2P) 的連線。"
    }
  },
  {
    title: { en: "WebSocket: ", zh: "WebSocket：" },
    content: {
      en: "Implements text chat between players and WebRTC P2P connection functionality.",
      zh: "用於實現玩家之間的文字聊天以及 WebRTC 的 P2P 連線功能。"
    }
  },
  {
    title: { en: "WebRTC Data Channels: ", zh: "WebRTC Data Channels：" },
    content: {
      en: "Responsible for transmitting character movement data to ensure the game screen can immediately render the latest coordinates of other players.",
      zh: "負責傳輸角色移動的資料，確保遊戲畫面能即時渲染其他玩家的最新座標。"
    }
  }
], Dre = {
  en: "This project demonstrates how WebSocket and WebRTC technologies work together to achieve real-time interaction and data transmission in a multiplayer game environment.",
  zh: "此專案展示了利用 WebSocket 和 WebRTC 合作，實現即時互動與資料傳輸的多人連線場景。"
}, Ure = () => {
  const { i18n: a } = Lu(), e = hp(a.language), [t, n] = xe.useState(!1);
  return /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
    /* @__PURE__ */ ze.jsx("p", { className: `${t ? "mb-3" : ""}`, children: Lre[e] }),
    t && /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
      /* @__PURE__ */ ze.jsx("ul", { className: "list-disc ml-4", children: kre.map((i, o) => /* @__PURE__ */ ze.jsxs("li", { className: "mb-3", children: [
        /* @__PURE__ */ ze.jsx("b", { children: i.title[e] }),
        i.content[e]
      ] }, o)) }),
      /* @__PURE__ */ ze.jsx("p", { children: Dre[e] })
    ] }),
    /* @__PURE__ */ ze.jsx(eR, { target: k9, state: [t, n] })
  ] });
}, Ore = {
  id: k9,
  title: {
    en: "Multiplayer Online Game Simulation",
    zh: "多人線上遊戲模擬"
  },
  type: zd.SIDE_PROJECT,
  tags: [sr.next, sr.express, sr.tailwind, sr.websocket, sr.webRTC, sr.three],
  picPath: "assets/mog-simulation/preview2.webp",
  description: ag.createElement(Ure),
  images: [
    {
      original: "/assets/mog-simulation/lobby.webp",
      thumbnail: "/assets/mog-simulation/lobby.webp"
    },
    {
      original: "/assets/mog-simulation/join-room.webp",
      thumbnail: "/assets/mog-simulation/join-room.webp"
    },
    {
      original: "/assets/mog-simulation/preview1.webp",
      thumbnail: "/assets/mog-simulation/preview1.webp"
    },
    {
      original: "/assets/mog-simulation/preview2.webp",
      thumbnail: "/assets/mog-simulation/preview2.webp"
    },
    {
      original: "/assets/mog-simulation/preview3.webp",
      thumbnail: "/assets/mog-simulation/preview3.webp"
    }
  ],
  link: { type: "github", site: "https://github.com/randywu417/mogs" },
  date: {
    year: 2025,
    month: Yd.JAN
  }
}, D9 = "patent-application", Pre = {
  en: "This system is an online platform provided by the Taiwan Intellectual Property Office (TIPO) under the Ministry of Economic Affairs, designed to facilitate patent applications for individuals and legal entities in Taiwan.",
  zh: "本系統為台灣經濟部智慧財產局 (TIPO) 提供的專利線上申請平台，旨在便利台灣自然人與法人進行專利申請。"
}, Jre = {
  en: "In addition to patent applications, the system supports 50 types of patent-related requests, such as filing supplementary documents, amendments, and responses. The system also features large-file splitting and conversion tools, ensuring stable transmission of large files. Users can upload completed application documents in advance, simplifying subsequent application processes and significantly enhancing efficiency and convenience.",
  zh: "除了專利申請作業外，系統還支援 50 項專利相關事項的申請功能，例如補正文件申請、修正申請、申復申請等。此外，系統內建大型文件分割與轉檔功能，不僅確保大檔案傳輸的穩定性，還能讓使用者預先上傳完成的申請書，簡化後續申請流程，全面提升操作效率與便利性。"
}, Qre = () => {
  const { i18n: a } = Lu(), e = hp(a.language), [t, n] = xe.useState(!1);
  return /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
    /* @__PURE__ */ ze.jsx("p", { className: `${t ? "mb-3" : ""}`, children: Pre[e] }),
    t && /* @__PURE__ */ ze.jsx("p", { children: Jre[e] }),
    /* @__PURE__ */ ze.jsx(eR, { target: D9, state: [t, n] })
  ] });
}, jre = {
  id: D9,
  title: {
    en: "Patent Application System",
    zh: "專利線上申請系統"
  },
  type: zd.PROJECT,
  tags: [sr.react, sr.vite, sr.jest, sr.e2e],
  picPath: "/assets/patent-application/preview1.webp",
  description: ag.createElement(Qre),
  images: [
    {
      original: "/assets/patent-application/preview1.webp",
      thumbnail: "/assets/patent-application/preview1.webp"
    },
    {
      original: "/assets/patent-application/preview2.webp",
      thumbnail: "/assets/patent-application/preview2.webp"
    },
    {
      original: "/assets/patent-application/preview3.webp",
      thumbnail: "/assets/patent-application/preview3.webp"
    },
    {
      original: "/assets/patent-application/preview4.webp",
      thumbnail: "/assets/patent-application/preview4.webp"
    },
    {
      original: "/assets/patent-application/preview5.webp",
      thumbnail: "/assets/patent-application/preview5.webp"
    }
  ],
  link: {
    type: "link",
    site: "https://tiponet.tipo.gov.tw/patent"
  },
  date: {
    year: 2024,
    month: Yd.NOV
  }
}, U9 = "personal-website", qre = {
  en: "My personal website is a platform for showcasing professional skills, project work, and technical insights. The website covers the following aspects:",
  zh: "我的個人網站是一個展示專業技能、專案作品與技術分享的平台。網站內容涵蓋："
}, $re = [
  {
    title: {
      en: "Personal Introduction: ",
      zh: "個人簡介："
    },
    content: {
      en: "A brief introduction to my interests and professional background.",
      zh: "簡單的介紹個人興趣及專業背景。"
    }
  },
  {
    title: {
      en: "Project Portfolio: ",
      zh: "專案作品："
    },
    content: {
      en: "A detailed showcase of past projects, including technology stack, key features, and implementation details.",
      zh: "詳細展示過往開發的專案，包含技術選型、功能特色與實作細節。"
    }
  },
  {
    title: {
      en: "Interactive Design: ",
      zh: "互動設計："
    },
    content: {
      en: "The website features an intuitive interface and a clean, minimalist design. It also includes an interactive homepage scene created using Three.js.",
      zh: "網站採用直觀的介面與設計，呈現乾淨簡潔的視覺效果，同時使用 Three.js 製作首頁的互動場景。"
    }
  }
], eae = {
  en: "This website is not only a platform to showcase my work but also a gateway to connect with the world.",
  zh: "這個網站不僅是個人作品的展示平台，也是我與世界交流的重要窗口。"
}, tae = () => {
  const { i18n: a } = Lu(), e = hp(a.language), [t, n] = xe.useState(!1);
  return /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
    /* @__PURE__ */ ze.jsx("p", { className: `${t ? "mb-3" : ""}`, children: qre[e] }),
    t && /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
      /* @__PURE__ */ ze.jsx("ul", { className: "list-disc ml-4", children: $re.map((i, o) => /* @__PURE__ */ ze.jsxs("li", { className: "mb-3", children: [
        /* @__PURE__ */ ze.jsx("b", { children: i.title[e] }),
        i.content[e]
      ] }, o)) }),
      /* @__PURE__ */ ze.jsx("p", { children: eae[e] })
    ] }),
    /* @__PURE__ */ ze.jsx(eR, { target: U9, state: [t, n] })
  ] });
}, nae = {
  id: U9,
  title: {
    en: "Personal Website",
    zh: "個人網站"
  },
  type: zd.SIDE_PROJECT,
  tags: [sr.react, sr.three, sr.canvas],
  picPath: "/assets/personal-website/preview1.webp",
  description: ag.createElement(tae),
  images: [
    {
      original: "/assets/personal-website/preview1.webp",
      thumbnail: "/assets/personal-website/preview1.webp"
    },
    {
      original: "/assets/personal-website/preview2.webp",
      thumbnail: "/assets/personal-website/preview2.webp"
    },
    {
      original: "/assets/personal-website/preview3.webp",
      thumbnail: "/assets/personal-website/preview3.webp"
    },
    {
      original: "/assets/personal-website/preview4.webp",
      thumbnail: "/assets/personal-website/preview4.webp"
    }
  ],
  link: { type: "link", site: "https://randywu417.github.io" },
  date: {
    year: 2024,
    month: Yd.OCT
  }
}, iae = "python-tool", rae = {
  id: iae,
  title: {
    en: "Bulk Folder Rename Tool",
    zh: "批量修改資料夾工具"
  },
  type: zd.OTHERS,
  tags: [sr.python],
  picPath: "/assets/python.webp",
  description: {
    en: "",
    zh: ""
  },
  link: {
    type: "github",
    site: "https://github.com/randywu417/bulk-folder-rename-tool"
  },
  date: {
    year: 2022,
    month: Yd.AUG
  }
}, O9 = "saboteur", aae = {
  en: 'This project is a real-time, faction-based board game built using WebSocket connections, inspired by the board game "Saboteur" published by Swan Panasia.',
  zh: '此專案是基於 WebSocket 連線所建構的即時對戰陣營桌遊，設計均參考自 新天鵝堡桌遊 代理的桌遊 "矮人礦坑"。'
}, oae = {
  en: "The project includes features such as card animations, a chatroom, heartbeat packets, reconnection upon disconnection, player timers, and maze-related algorithms.",
  zh: "此專案實作了卡牌動畫、聊天室、心跳包、斷線重連、玩家計時、以及一些迷宮相關的演算法。"
}, sae = {
  en: "Due to the use of copyrighted artwork, this project is intended solely for personal practice and cannot be shared publicly. If you're interested in viewing the code, please email me at randywu417@gmail.com to request the password for final.zip and include a brief explanation of your purpose. Thank you for your understanding.",
  zh: "由於此專案使用了有版權的美術素材，故無法公開，僅作為個人練習用。若想暸解程式碼，請來信至 randywu417@gmail.com 索取 final.zip 的密碼並說明來意，謝謝您的配合。"
}, lae = () => {
  const { i18n: a } = Lu(), e = hp(a.language), [t, n] = xe.useState(!1);
  return /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
    /* @__PURE__ */ ze.jsx("p", { children: aae[e] }),
    /* @__PURE__ */ ze.jsx("p", { children: oae[e] }),
    t && /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
      /* @__PURE__ */ ze.jsx("br", {}),
      /* @__PURE__ */ ze.jsx("p", { children: sae[e] })
    ] }),
    /* @__PURE__ */ ze.jsx(eR, { target: O9, state: [t, n] })
  ] });
}, uae = {
  id: O9,
  title: {
    en: "Saboteur",
    zh: "矮人礦坑"
  },
  type: zd.SIDE_PROJECT,
  tags: [sr.react, sr.nodeJS, sr.express, sr.websocket, sr.jest],
  picPath: "/assets/saboteur/game-preview2.webp",
  description: ag.createElement(lae),
  images: [
    {
      original: "/assets/saboteur/home.webp",
      thumbnail: "/assets/saboteur/home.webp"
    },
    {
      original: "/assets/saboteur/hall-preview.webp",
      thumbnail: "/assets/saboteur/hall-preview.webp"
    },
    {
      original: "/assets/saboteur/game-loading.webp",
      thumbnail: "/assets/saboteur/game-loading.webp"
    },
    {
      original: "/assets/saboteur/game-preview1.webp",
      thumbnail: "/assets/saboteur/game-preview1.webp"
    },
    {
      original: "/assets/saboteur/game-preview2.webp",
      thumbnail: "/assets/saboteur/game-preview2.webp"
    },
    {
      original: "/assets/saboteur/game-preview3.webp",
      thumbnail: "/assets/saboteur/game-preview3.webp"
    }
  ],
  link: {
    type: "download",
    site: "https://drive.google.com/file/d/1rHa5sLhgSN-XQmHdRzQ-JYbO-NN6keLZ/view?usp=sharing"
  },
  date: {
    year: 2023,
    month: Yd.DEC
  }
}, cae = "shader-materials", gae = {
  id: cae,
  title: {
    en: "2D Shader Material",
    zh: "2D Shader Material"
  },
  type: zd.OTHERS,
  tags: [sr.canvas, sr.glsl],
  picPath: "/assets/shader-materials.webp",
  description: {
    en: "Shaders that have been implemented.",
    zh: "曾經實作過的 shader。"
  },
  link: {
    type: "github",
    site: "https://github.com/randywu417/basic-2d-shader-material"
  },
  date: {
    year: 2022,
    month: Yd.JUN
  }
}, dae = "trademark-fee-payment", Iae = {
  id: dae,
  title: {
    en: "Online Fee Payment System",
    zh: "規費線上繳納系統"
  },
  type: zd.PROJECT,
  tags: [sr.react, sr.vite, sr.jest, sr.i18n],
  picPath: "/assets/trademark-fee-payment.webp",
  description: {
    en: "Provides an online platform for trademark fee payments, along with features for payment records, querying payable fees, and annual fee calculations.",
    zh: "提供商標規費線上繳納平台，另提供繳費紀錄、查詢應繳規費、年費試算等功能。"
  },
  link: { type: "link", site: "https://tiponet.tipo.gov.tw/S080WV1/#/" },
  date: {
    year: 2023,
    month: Yd.JUL
  }
}, P9 = "trademark-search", Cae = {
  en: "This system offers a powerful trademark search platform, supporting diverse search methods to help users quickly locate the required trademark information.",
  zh: "本系統提供使用者一個功能強大的商標檢索平台，支援多樣化的檢索方式，方便使用者快速找到所需的商標資訊。"
}, hae = {
  en: "Key Features: ",
  zh: "主要功能包括："
}, fae = [
  {
    title: { en: "Basic and Advanced Search: ", zh: "簡易與進階搜尋功能：" },
    content: {
      en: "Provides six basic, easy-to-use search methods, along with tens of thousands of advanced search combinations to meet diverse needs.",
      zh: "提供 6 種基本的簡易搜尋方式，並支援多達上萬種組合的進階搜尋，滿足多樣化需求。"
    }
  },
  {
    title: { en: "Image Editing and Search: ", zh: "圖片編輯與搜尋：" },
    content: {
      en: "Equipped with a built-in image editor that allows users to crop specific parts of an image for more precise searches.",
      zh: "內建圖片編輯器，允許使用者裁切圖片中的特定部分進行搜尋，提升搜尋準確性。"
    }
  },
  {
    title: { en: "Detailed Trademark Information: ", zh: "商標詳細資訊：" },
    content: {
      en: "Displays comprehensive trademark details, enabling users to gain a deeper understanding of the related information.",
      zh: "顯示商標的細部資訊，讓使用者可以深入了解此商標的相關資料。"
    }
  }
], pae = {
  en: "This system is designed to provide an intuitive and efficient trademark search, assisting users in quickly accessing the information they need.",
  zh: "此系統提供直觀、有效率的商標檢索方式，協助使用者快速找到所需的商標資料。"
}, mae = () => {
  const { i18n: a } = Lu(), e = hp(a.language), [t, n] = xe.useState(!1);
  return /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
    /* @__PURE__ */ ze.jsx("p", { className: "mb-3", children: Cae[e] }),
    /* @__PURE__ */ ze.jsx("p", { className: `${t ? "mb-3" : ""}`, children: hae[e] }),
    t && /* @__PURE__ */ ze.jsxs(ze.Fragment, { children: [
      /* @__PURE__ */ ze.jsx("ul", { className: "list-disc ml-4", children: fae.map((i, o) => /* @__PURE__ */ ze.jsxs("li", { className: "mb-3", children: [
        /* @__PURE__ */ ze.jsx("b", { children: i.title[e] }),
        i.content[e]
      ] }, o)) }),
      /* @__PURE__ */ ze.jsx("p", { children: pae[e] })
    ] }),
    /* @__PURE__ */ ze.jsx(eR, { target: P9, state: [t, n] })
  ] });
}, Aae = {
  id: P9,
  title: {
    en: "Trademark Search System",
    zh: "商標線上檢索系統"
  },
  type: zd.PROJECT,
  tags: [sr.react, sr.canvas, sr.nodeJS, sr.vite, sr.jest, sr.e2e],
  picPath: "/assets/trademark-search/preview1.webp",
  description: ag.createElement(mae),
  images: [
    {
      original: "/assets/trademark-search/preview1.webp",
      thumbnail: "/assets/trademark-search/preview1.webp"
    },
    {
      original: "/assets/trademark-search/preview2.webp",
      thumbnail: "/assets/trademark-search/preview2.webp"
    },
    {
      original: "/assets/trademark-search/preview3.webp",
      thumbnail: "/assets/trademark-search/preview3.webp"
    },
    {
      original: "/assets/trademark-search/preview4.webp",
      thumbnail: "/assets/trademark-search/preview4.webp"
    },
    {
      original: "/assets/trademark-search/preview5.webp",
      thumbnail: "/assets/trademark-search/preview5.webp"
    },
    {
      original: "/assets/trademark-search/preview6.webp",
      thumbnail: "/assets/trademark-search/preview6.webp"
    },
    {
      original: "/assets/trademark-search/preview7.webp",
      thumbnail: "/assets/trademark-search/preview7.webp"
    }
  ],
  link: {
    type: "link",
    site: "https://cloud.tipo.gov.tw/S282/S282WV1/"
  },
  date: {
    year: 2024,
    month: Yd.MAR
  }
}, tW = [
  { title: { en: "Other", zh: "其他" }, value: zd.OTHERS },
  { title: { en: "Side Project", zh: "個人專案" }, value: zd.SIDE_PROJECT },
  { title: { en: "Project", zh: "專案" }, value: zd.PROJECT },
  { title: { en: "All", zh: "全部" }, value: "" }
], g5 = [
  Ore,
  jre,
  nae,
  Kre,
  Aae,
  uae,
  Iae,
  _re,
  gae,
  rae
], vae = ({ activeTab: a, setActiveTab: e }) => {
  const { width: t } = Vb(), { i18n: n } = Lu(), i = [
    xe.useRef(null),
    xe.useRef(null),
    xe.useRef(null),
    xe.useRef(null)
  ], o = hp(n.language), l = (h) => h === a, u = tW.findIndex((h) => a === h.value), [I, f] = xe.useState({});
  return xe.useEffect(() => {
    const h = () => i[u] && i[u].current ? i[u].current.getBoundingClientRect().width + "px" : "", v = () => {
      let b = 0;
      for (let S = 0; S < u; S++) {
        const R = i[S];
        R && R.current && (b += R.current.getBoundingClientRect().width);
      }
      return b + "px";
    };
    f({
      width: h(),
      right: v()
    });
  }, [u, i[0].current, i[1].current, i[2].current, i[3].current, t, o]), /* @__PURE__ */ ze.jsxs("div", { className: "project-tabs", children: [
    tW.map((h, v) => /* @__PURE__ */ ze.jsx(
      "a",
      {
        ref: i[v],
        className: `tab ${l(h.value) ? "opacity-100" : "opacity-30 hover:opacity-100"}`,
        onClick: () => e(h.value),
        children: h.title[o]
      },
      v
    )),
    /* @__PURE__ */ ze.jsx("span", { className: "line xs:hidden", style: I })
  ] });
}, yae = () => {
  const { t: a } = Lu(), [e, t] = N5(), [n, i] = xe.useState(!1), [o, l] = xe.useState(null), [u, I] = xe.useState(""), [f, h] = xe.useState(
    (() => {
      const W = e.get("tab");
      return !W || !tW.find(({ value: x }) => x === W) ? "" : W;
    })()
  ), v = e.get("tab"), b = e.get("tags"), S = xe.useMemo(
    () => f === "" ? g5 : g5.filter(({ type: W }) => W === f),
    [f]
  ), R = (W) => {
    W ? e.set("tab", W) : e.delete("tab"), e.delete("tags"), t(e);
  };
  return xe.useEffect(() => {
    !v || !tW.find(({ value: W }) => W === v) ? h("") : h(v);
  }, [v]), /* @__PURE__ */ ze.jsxs(JW, { title: a("subtitle_projects"), children: [
    /* @__PURE__ */ ze.jsx(vae, { activeTab: f, setActiveTab: R }),
    /* @__PURE__ */ ze.jsx("div", { className: "w-full flex flex-col gap-0 xs:gap-8 md:pr-4 xs:p-0", onMouseLeave: () => I(""), children: S.filter((W) => b ? W.tags.some((x) => b.includes(x.value)) : W).map((W) => /* @__PURE__ */ ze.jsx(
      Ere,
      {
        project: W,
        hoverState: [u, I],
        setGalleryItems: (x) => {
          i(!0), l(x);
        }
      },
      W.id
    )) }),
    /* @__PURE__ */ ze.jsx(
      Yre,
      {
        items: o,
        visible: n,
        setItems: l,
        onClose: () => i(!1)
      }
    )
  ] });
}, bae = FZ.createRoot(document.getElementById("root")), Gae = HP(
  [
    {
      path: ng.HOME,
      element: /* @__PURE__ */ ze.jsx(Zre, {}),
      errorElement: /* @__PURE__ */ ze.jsx(mP, { to: ng.HOME }),
      children: cY.map((a) => ({ path: a.url, element: /* @__PURE__ */ ze.jsx(ze.Fragment, {}) }))
    }
  ],
  { basename: "/" }
);
bae.render(
  /* @__PURE__ */ ze.jsxs(ag.StrictMode, { children: [
    /* @__PURE__ */ ze.jsx(zP, { router: Gae }),
    /* @__PURE__ */ ze.jsx(Cre, { maxCount: 1 })
  ] })
);
